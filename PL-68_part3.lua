--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 3/10 - 06/04/2025


--PATH lua/autorun/aarivaros.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end

AddPlayerModel( "atlas", "models/player/atlas/starwars/atlas.mdl" )
--PATH lua/autorun/admiral.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/arccw/shared/arccw_sw_effects.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/arccw/shared/arccw_sw_effects.lua:
game.AddParticles( "particles/dc17_muzzleparticle.pcf" )
game.AddParticles( "particles/dc17_muzzleparticlemasita.pcf" )
game.AddParticles( "particles/muzzleflashes_test.pcf" )
game.AddParticles( "particles/muzzleflashes_test_b.pcf" )

-- Kraken's
game.AddParticles( "particles/lasgun_fx.pcf" )
game.AddParticles( "particles/BlasterBlue.pcf" )
game.AddParticles( "particles/BlasterGreen.pcf" )
game.AddParticles( "particles/BlasterPurple.pcf" )
game.AddParticles( "particles/BlasterRed.pcf" )
game.AddParticles( "particles/BlasterYellow.pcf" )
game.AddParticles( "particles/particles_plasma.pcf" )

-- Sci-Fi
game.AddParticles( "particles/bloomtest.pcf" )
game.AddParticles( "particles/boxglove_fx.pcf" )
game.AddParticles( "particles/corrosion_fx.pcf" )
game.AddParticles( "particles/cryo_fx.pcf" )
game.AddParticles( "particles/darkling_fx.pcf" )
game.AddParticles( "particles/fallingstar_fx.pcf" )
game.AddParticles( "particles/gravrifle_fx.pcf" )
game.AddParticles( "particles/hellfire_fx.pcf" )
game.AddParticles( "particles/hwave_fx.pcf" )
game.AddParticles( "particles/lanka_fx.pcf" )
game.AddParticles( "particles/ngen_fx.pcf" )
game.AddParticles( "particles/nio_fx.pcf" )
game.AddParticles( "particles/pulsar_fx.pcf" )
game.AddParticles( "particles/spectra_fx.pcf" )
game.AddParticles( "particles/stinger_fx.pcf" )
game.AddParticles( "particles/storm_fx.pcf" )
game.AddParticles( "particles/tbolt_fx_reborn.pcf" )
game.AddParticles( "particles/trace_fx.pcf" )
game.AddParticles( "particles/umbra_fx.pcf" )
game.AddParticles( "particles/underscore_fx.pcf" )
game.AddParticles( "particles/vapor_fx.pcf" )
game.AddParticles( "particles/veho_fx.pcf" )
game.AddParticles( "particles/shitsonfireyo.pcf" )


-- Plasma
PrecacheParticleSystem( "plasma_bolt" )
PrecacheParticleSystem( "plasma_bolt_big" )
PrecacheParticleSystem( "plasma_bolt_small" )
PrecacheParticleSystem( "plasma_trail" )
PrecacheParticleSystem( "plasma_trail_small" )

-- Particles Sci-Fi
PrecacheParticleSystem( "shitsonfireyo" )

-- Particle systems --
PrecacheParticleSystem( "_ghost_upgrade" )
PrecacheParticleSystem( "_wraithgun_muzzle" )
PrecacheParticleSystem( "_wraithgun_tracer" )
PrecacheParticleSystem( "_wraithgun_hit" )
PrecacheParticleSystem( "_wrath_hit_sparks" )
PrecacheParticleSystem( "_wrath_tracer" )
PrecacheParticleSystem( "aeblast_muzzle" )
PrecacheParticleSystem( "aquamarine_charge" )
PrecacheParticleSystem( "aquamarine_tracer" )
PrecacheParticleSystem( "asa6_hit" )
PrecacheParticleSystem( "asa6_tracer" )
PrecacheParticleSystem( "astra_beam" )
PrecacheParticleSystem( "astra_beam_lightning_1" )
PrecacheParticleSystem( "astra_bolt" )
PrecacheParticleSystem( "astra_hit" )
PrecacheParticleSystem( "astra_hit_heavy" )
PrecacheParticleSystem( "astra_muzzle" )
PrecacheParticleSystem( "astra_muzzle_heavy" )
PrecacheParticleSystem( "astra_muzzle_lightning" )
PrecacheParticleSystem( "blade_glow" )
PrecacheParticleSystem( "blade_hit" )
PrecacheParticleSystem( "bloom_beam_0" )
PrecacheParticleSystem( "bloom_halo_0" )
PrecacheParticleSystem( "celest_dissolve" )
PrecacheParticleSystem( "celest_wrath_core" )
PrecacheParticleSystem( "celest_wrath_core_charging" )
PrecacheParticleSystem( "celest_wrath_dissolve" )
PrecacheParticleSystem( "celest_wrath_explode" )
PrecacheParticleSystem( "celest_wrath_hit" )
PrecacheParticleSystem( "celest_wrath_muzzle" )
PrecacheParticleSystem( "celest_wrath_nade" )
PrecacheParticleSystem( "celest_wrath_pulse" )
PrecacheParticleSystem( "celest_wrath_tracer" )
PrecacheParticleSystem( "corro_muzzle" )
PrecacheParticleSystem( "corro_proc" )
PrecacheParticleSystem( "corro_tracer" )
PrecacheParticleSystem( "corruptor_impact" )
PrecacheParticleSystem( "corruptor_muzzle" )
PrecacheParticleSystem( "corruptor_tracer" )
PrecacheParticleSystem( "crsv_dissolve" )
PrecacheParticleSystem( "crsv_dissolve_cheap" )
PrecacheParticleSystem( "cryo_explosion_large" )
PrecacheParticleSystem( "cryo_ragshatter" )
PrecacheParticleSystem( "cryo_ragshatter_frags" )
PrecacheParticleSystem( "drake_hit" )
PrecacheParticleSystem( "drake_muzzle" )
PrecacheParticleSystem( "drake_tracer" )
PrecacheParticleSystem( "ember_hit_entity" )
PrecacheParticleSystem( "ember_hit_nothing" )
PrecacheParticleSystem( "ember_hit_world" )
PrecacheParticleSystem( "ember_laser" )
PrecacheParticleSystem( "ember_laser_underwater" )
PrecacheParticleSystem( "ember_muzzle" )
PrecacheParticleSystem( "ember_muzzle_turnoff" )
PrecacheParticleSystem( "ember_muzzle_turnon" )
PrecacheParticleSystem( "ember_underwater_bubbles" )
PrecacheParticleSystem( "emg_tracer" )
PrecacheParticleSystem( "emg_hit" )
PrecacheParticleSystem( "eml_dps_shock" )
PrecacheParticleSystem( "eml_generic_blast" )
PrecacheParticleSystem( "eml_generic_crsv" )
PrecacheParticleSystem( "eml_generic_crsv_splat" )
PrecacheParticleSystem( "eml_generic_cryo" )
PrecacheParticleSystem( "eml_generic_cryo_ground" )
PrecacheParticleSystem( "eml_generic_heat" )
PrecacheParticleSystem( "eml_generic_shock" )
PrecacheParticleSystem( "eml_generic_cryo_small" )
PrecacheParticleSystem( "eml_muzzle_cryo" )
PrecacheParticleSystem( "eml_tracer_cryo" )
PrecacheParticleSystem( "event_onwater_remove" )
PrecacheParticleSystem( "fathom_blast" )
PrecacheParticleSystem( "fathom_cloud" )
PrecacheParticleSystem( "fathom_death" )
PrecacheParticleSystem( "fathom_muzzle" )
PrecacheParticleSystem( "flare_halo_0" )
PrecacheParticleSystem( "flathr" )
PrecacheParticleSystem( "fstar_charge" )
PrecacheParticleSystem( "fstar_hit" )
PrecacheParticleSystem( "fstar_freeze_catch" )
PrecacheParticleSystem( "fstar_freeze_release" )
PrecacheParticleSystem( "fstar_muzzle" )
PrecacheParticleSystem( "fstar_muzzle_altfire" )
PrecacheParticleSystem( "fstar_tracer" )
PrecacheParticleSystem( "fstar_secfire" )
PrecacheParticleSystem( "fstar_sfire_hit_swave" )
PrecacheParticleSystem( "gravrifle_blast" )
PrecacheParticleSystem( "gravrifle_blast_parentable" )
PrecacheParticleSystem( "gravrifle_blast_smoke" )
PrecacheParticleSystem( "gravrifle_charge" )
PrecacheParticleSystem( "gravrifle_dissolve" )
PrecacheParticleSystem( "gravrifle_hit" )
PrecacheParticleSystem( "gravrifle_nade" )
PrecacheParticleSystem( "gravrifle_tracer" )
PrecacheParticleSystem( "grinder_muzzle" )
PrecacheParticleSystem( "gunsmoke" )
PrecacheParticleSystem( "hellfire_muzzle" )
PrecacheParticleSystem( "hellfire_muzzle_smoke" )
PrecacheParticleSystem( "hellfire_tracer" )
PrecacheParticleSystem( "hellfire_blast" )
PrecacheParticleSystem( "hellnade_fragments" )
PrecacheParticleSystem( "hellnade_heat" )
PrecacheParticleSystem( "hellnade_shockwave" )
PrecacheParticleSystem( "hornet_blast" )
PrecacheParticleSystem( "hornet_blast_charged" )
PrecacheParticleSystem( "hornet_blast_cheap" )
PrecacheParticleSystem( "hornet_trail" )
PrecacheParticleSystem( "hornet_trail_cheaper" )
PrecacheParticleSystem( "hwave_charge" )
PrecacheParticleSystem( "hwave_charged" )
PrecacheParticleSystem( "hwave_debris_small" )
PrecacheParticleSystem( "hwave_hit" )
PrecacheParticleSystem( "hwave_hit_fleks" )
PrecacheParticleSystem( "hwave_muzzle" )
PrecacheParticleSystem( "hwave_muzzle_embers" )
PrecacheParticleSystem( "hwave_muzzle_finish" )
PrecacheParticleSystem( "hwave_tracer" )
PrecacheParticleSystem( "hwave_tracer_cheap" )
PrecacheParticleSystem( "ice_crystals" )
PrecacheParticleSystem( "ice_crystals_2" )
PrecacheParticleSystem( "ice_crystals_3" )
PrecacheParticleSystem( "ice_freezing" )
PrecacheParticleSystem( "ice_freezing_shortlt" )
PrecacheParticleSystem( "ice_freezing_release" )
PrecacheParticleSystem( "ice_impact" )
PrecacheParticleSystem( "ice_impact_heavy" )
PrecacheParticleSystem( "ice_tracer_smoke" )
PrecacheParticleSystem( "ice_muzzle_small" )
PrecacheParticleSystem( "ice_sfire_charge" )
PrecacheParticleSystem( "item_flare" )
PrecacheParticleSystem( "item_orb_battery" )
PrecacheParticleSystem( "item_orb_health" )
PrecacheParticleSystem( "item_orb_upgrade" )
PrecacheParticleSystem( "item_pfx_battery" )
PrecacheParticleSystem( "item_pfx_health" )
PrecacheParticleSystem( "item_pfx_upgrade" )
PrecacheParticleSystem( "item_pkin_amb" )
PrecacheParticleSystem( "item_pkin_break" )
PrecacheParticleSystem( "item_upg_break" )
--PrecacheParticleSystem( "jotunn_bolt_break" )
--PrecacheParticleSystem( "jotunn_bolt_impact" )
PrecacheParticleSystem( "jotunn_charge_init" )
PrecacheParticleSystem( "jotunn_charging" )
PrecacheParticleSystem( "jotunn_muzzle" )
PrecacheParticleSystem( "lanka_hit_riv" )
PrecacheParticleSystem( "lapis_vent" )
PrecacheParticleSystem( "meridian_tracer" )
PrecacheParticleSystem( "moby_hit" )
PrecacheParticleSystem( "moby_muzzle" )
PrecacheParticleSystem( "moby_tracer" )
PrecacheParticleSystem( "ngen_core_playerfx" )
PrecacheParticleSystem( "ngen_core_small" )
PrecacheParticleSystem( "ngen_core_small_cheap" )
PrecacheParticleSystem( "ngen_explosion" )
PrecacheParticleSystem( "ngen_explosion_energy" )
PrecacheParticleSystem( "ngen_hit" )
PrecacheParticleSystem( "ngen_hit_lgtning" )
PrecacheParticleSystem( "ngen_hit_sparks_2" )
PrecacheParticleSystem( "ngen_missile_smoke" )
PrecacheParticleSystem( "ngen_muzzle" )
PrecacheParticleSystem( "ngen_muzzle_2" )
PrecacheParticleSystem( "ngen_muzzle_3" )
PrecacheParticleSystem( "ngen_muzzle_4" )
PrecacheParticleSystem( "ngen_muzzle_4_shotgun" )
PrecacheParticleSystem( "ngen_muzzle_4_simplified" )
PrecacheParticleSystem( "ngen_muzzle_charge" )
PrecacheParticleSystem( "ngen_muzzle_embers_overheat" )
PrecacheParticleSystem( "ngen_tracer" )
PrecacheParticleSystem( "lasgun_tracer" )
PrecacheParticleSystem( "lasgun_charge" )
PrecacheParticleSystem( "nio_beam" )
PrecacheParticleSystem( "nio_muzzle" )
PrecacheParticleSystem( "nio_impact" )
PrecacheParticleSystem( "nio_dissolve" )
PrecacheParticleSystem( "nio_dissolve_cheap" )
PrecacheParticleSystem( "nio_charge" )
PrecacheParticleSystem( "nrg_hit" )
PrecacheParticleSystem( "nrg_tracer" )
PrecacheParticleSystem( "onwater_bubbles" )
PrecacheParticleSystem( "panda_charge" )
PrecacheParticleSystem( "panda_charged" )
PrecacheParticleSystem( "panda_hit" )
PrecacheParticleSystem( "panda_muzzle" )
PrecacheParticleSystem( "panda_tracer" )
PrecacheParticleSystem( "pele_hit")
PrecacheParticleSystem( "pele_muzzle")
PrecacheParticleSystem( "pele_tracer")
PrecacheParticleSystem( "pest_muzzle" )
PrecacheParticleSystem( "pest_hit" )
PrecacheParticleSystem( "phasma_absorb" )
PrecacheParticleSystem( "phasma_blade_enable" )
PrecacheParticleSystem( "phasma_blade_enable_sparks" )
PrecacheParticleSystem( "phasma_blade_disable" )
PrecacheParticleSystem( "phasma_blade_sparks" )
PrecacheParticleSystem( "phasma_blast" )
PrecacheParticleSystem( "phasma_core" )
PrecacheParticleSystem( "phasma_initial_mist" )
PrecacheParticleSystem( "phasma_trail" )
PrecacheParticleSystem( "phasma_w_blade_enable" )
PrecacheParticleSystem( "phasma_w_initial_mist" )
PrecacheParticleSystem( "phasma_w_trail" )
PrecacheParticleSystem( "prisma_core" )
PrecacheParticleSystem( "pulsar_charge" )
PrecacheParticleSystem( "pulsar_charge_fail" )
PrecacheParticleSystem( "pulsar_beam" )
PrecacheParticleSystem( "pulsar_hit_weak" )
PrecacheParticleSystem( "pulsar_muzzle" )
PrecacheParticleSystem( "pyro_dissolve" )
PrecacheParticleSystem( "pyro_dissolve_ash_0" )
PrecacheParticleSystem( "pyro_dissolve_ash_3" )
PrecacheParticleSystem( "pyro_dissolve_cheap" )
PrecacheParticleSystem( "pyro_dissolve_ash_cheap" )
PrecacheParticleSystem( "pyro_explode" )
PrecacheParticleSystem( "pyro_nade" )
PrecacheParticleSystem( "saphyre_absorb" )
PrecacheParticleSystem( "saphyre_hit" )
PrecacheParticleSystem( "saphyre_hit_fleks" )
PrecacheParticleSystem( "saphyre_muzzle" )
PrecacheParticleSystem( "saphyre_muzzle_embers" )
PrecacheParticleSystem( "saphyre_muzzle_flames_0a" )
PrecacheParticleSystem( "saphyre_tracer" )
PrecacheParticleSystem( "sentinel_hit" )
PrecacheParticleSystem( "sentinel_muzzle" )
PrecacheParticleSystem( "seraph_hit" )
PrecacheParticleSystem( "seraph_muzzle" )
PrecacheParticleSystem( "seraph_tracer" )
PrecacheParticleSystem( "shk_hit" )
PrecacheParticleSystem( "shk_muzzle" )
PrecacheParticleSystem( "shk_tracer" )
PrecacheParticleSystem( "spectra_blast" )
PrecacheParticleSystem( "spectra_charging" )
PrecacheParticleSystem( "spectra_core" )
PrecacheParticleSystem( "spectra_core_crsv" )
PrecacheParticleSystem( "spectra_core_evensmaller" )
PrecacheParticleSystem( "spectra_core_fire" )
PrecacheParticleSystem( "spectra_core_ice" )
PrecacheParticleSystem( "spectra_core_small" )
PrecacheParticleSystem( "spectra_explode" )
PrecacheParticleSystem( "spectra_fmchange" )
PrecacheParticleSystem( "spectra_hit" )
PrecacheParticleSystem( "spectra_muzzle" )
PrecacheParticleSystem( "spectra_muzzle_2" )
PrecacheParticleSystem( "spectra_muzzle_old" )
PrecacheParticleSystem( "spectra_muzzle_overheat" )
PrecacheParticleSystem( "spectra_tracer" )
PrecacheParticleSystem( "spr_explosion" )
PrecacheParticleSystem( "spr_explosion_large" )
PrecacheParticleSystem( "spr_explosion_large_flash_noz" )
PrecacheParticleSystem( "spr_explosion_large_smoshroom" )
PrecacheParticleSystem( "spr_hit" )
PrecacheParticleSystem( "spr_muzzle" )
PrecacheParticleSystem( "spr_nade_tick" )
PrecacheParticleSystem( "spr_tracer" )
PrecacheParticleSystem( "stinger_muzzle" )
PrecacheParticleSystem( "stinger_core_small" )
PrecacheParticleSystem( "stinger_explode" )
PrecacheParticleSystem( "stinger_muzzle_2" )
PrecacheParticleSystem( "stinger_core_small_2" )
PrecacheParticleSystem( "stinger_explode_2" )
PrecacheParticleSystem( "supra_c_hit" )
PrecacheParticleSystem( "supra_charging" )
PrecacheParticleSystem( "supra_mirv" )
PrecacheParticleSystem( "supra_nade" )
PrecacheParticleSystem( "supra_p_hit" )
PrecacheParticleSystem( "storm_muzzle" )
PrecacheParticleSystem( "storm_muzzle_cheap" )
PrecacheParticleSystem( "tbolt_muzzle" )
PrecacheParticleSystem( "tbolt_hit" )
PrecacheParticleSystem( "tbolt_tracer" )
PrecacheParticleSystem( "tbolt_tracer_cheap" )
PrecacheParticleSystem( "trace_muzzle" )
PrecacheParticleSystem( "trace_trace" )
PrecacheParticleSystem( "trace_projectile" )
PrecacheParticleSystem( "trace_projectile_pws" )
PrecacheParticleSystem( "trace_sparks_new" )
PrecacheParticleSystem( "umbra_ammo" )
PrecacheParticleSystem( "umbra_ammo_pickup" )
PrecacheParticleSystem( "umbra_ammo_consumed" )
PrecacheParticleSystem( "umbra_cast" )
PrecacheParticleSystem( "umbra_core" )
PrecacheParticleSystem( "umbra_darken" )
PrecacheParticleSystem( "umbra_darken_stackup" )
PrecacheParticleSystem( "umbra_hit" )
PrecacheParticleSystem( "umbra_muzzle" )
PrecacheParticleSystem( "umbra_muzzle_embers" )
PrecacheParticleSystem( "umbra_muzzle_vented" )
PrecacheParticleSystem( "umbra_ptru" )
PrecacheParticleSystem( "umbra_shutdown_flecks" )
PrecacheParticleSystem( "umbra_succumb" )
PrecacheParticleSystem( "vapor" )
PrecacheParticleSystem( "vapor_cheap" )
PrecacheParticleSystem( "vapor_charge_glow" )
PrecacheParticleSystem( "vapor_charge_secfire" )
PrecacheParticleSystem( "vapor_collapse" )
PrecacheParticleSystem( "vapor_collapse_cheap" )
PrecacheParticleSystem( "vapor_muzzle" )
PrecacheParticleSystem( "vapor_muzzle_altfire" )
PrecacheParticleSystem( "vapor_muzzle_evensmaller" )
PrecacheParticleSystem( "vapor_muzzle_small" )
PrecacheParticleSystem( "vectra_charged" )
PrecacheParticleSystem( "vectra_charging" )
PrecacheParticleSystem( "vp_binary_muzzle" )
PrecacheParticleSystem( "vp_binary_tracer" )
PrecacheParticleSystem( "vp_dissolve" )
PrecacheParticleSystem( "vp_dissolve_cheap" )
PrecacheParticleSystem( "vsecfire_shockwave" )
PrecacheParticleSystem( "vh_muzzle" )
PrecacheParticleSystem( "vh_tracer_old" )
PrecacheParticleSystem( "vh_hit" )
PrecacheParticleSystem( "xplo_tracer" )
PrecacheParticleSystem( "xplo_hit" )
PrecacheParticleSystem( "xplo_hit_cheap" )
PrecacheParticleSystem( "zeala_charged" )
PrecacheParticleSystem( "zeala_charging" )
PrecacheParticleSystem( "zeala_burst" )
PrecacheParticleSystem( "zeala_muzzle" )
PrecacheParticleSystem( "zeala_nade" )
PrecacheParticleSystem( "zeala_vortex" )
PrecacheParticleSystem( "zeala_vortex_cheap" )

PrecacheParticleSystem("wpn_muzzleflash_mgl_FULL")
PrecacheParticleSystem("tfa_apex_tracer_anvil")
PrecacheParticleSystem("tfa_apex_tracer_ar")
PrecacheParticleSystem("tfa_apex_tracer_hmg")
PrecacheParticleSystem("tfa_apex_tracer_hmg_rampage")
PrecacheParticleSystem("tfa_apex_tracer_pistol")
PrecacheParticleSystem("tfa_apex_tracer_shotgun")
PrecacheParticleSystem("tfa_apex_tracer_smg")
PrecacheParticleSystem("tfa_apex_tracer_sniper")
PrecacheParticleSystem("tfa_apex_lstar_explode_core")
PrecacheParticleSystem("tfa_apex_arcstar_explode")
PrecacheParticleSystem("tfa_apex_frag_explode")
PrecacheParticleSystem("grenade_final")
PrecacheParticleSystem("tfa_apex_arcstar_impact")
PrecacheParticleSystem("tfa_apex_bocek_impact")
PrecacheParticleSystem("tfa_apex_bocek_trail")
PrecacheParticleSystem("tfa_apex_bullet_trail")
PrecacheParticleSystem("tfa_apex_bullet_energy_trail")
PrecacheParticleSystem("tfa_apex_bullet_sent_trail")

-- Kraken's
PrecacheParticleSystem( "blaster_muzzle_blue" )
PrecacheParticleSystem( "blaster_muzzle_red" )
PrecacheParticleSystem( "blaster_muzzle_green" )
PrecacheParticleSystem( "blaster_muzzle_purple" )

-- Other's
PrecacheParticleSystem( "wpn_muzzleflash_dc17_red" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_purple" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_green" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_orange" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_red" )
PrecacheParticleSystem( "muzzleflash_smg" )
PrecacheParticleSystem( "muzzleflash_smg_bizon" )
PrecacheParticleSystem( "muzzleflash_shotgun" )
PrecacheParticleSystem( "muzzleflash_slug" )
PrecacheParticleSystem( "muzzleflash_slug_flame" )
PrecacheParticleSystem( "muzzleflash_pistol" )
PrecacheParticleSystem( "muzzleflash_pistol_cleric" )
PrecacheParticleSystem( "muzzleflash_pistol_deagle" )
PrecacheParticleSystem( "muzzleflash_suppressed" )
PrecacheParticleSystem( "muzzleflash_mp5" )
PrecacheParticleSystem( "muzzleflash_MINIMI" )
PrecacheParticleSystem( "muzzleflash_m79" )
PrecacheParticleSystem( "muzzleflash_m14" )
PrecacheParticleSystem( "muzzleflash_ak47" )
PrecacheParticleSystem( "muzzleflash_ak74" )
PrecacheParticleSystem( "muzzleflash_m82" )
PrecacheParticleSystem( "muzzleflash_m3" )
PrecacheParticleSystem( "muzzleflash_famas" )
PrecacheParticleSystem( "muzzleflash_g3" )
PrecacheParticleSystem( "muzzleflash_1" )
PrecacheParticleSystem( "muzzleflash_3" )
PrecacheParticleSystem( "muzzleflash_4" )
PrecacheParticleSystem( "muzzleflash_5" )
PrecacheParticleSystem( "muzzleflash_6" )
--PATH lua/arccw/shared/sh_convars.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_convars.lua:
ArcCW.ConVars = {}

ArcCW.ConVars["enable_penetration"] = CreateConVar("arccw_enable_penetration", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)
ArcCW.ConVars["enable_ricochet"] = CreateConVar("arccw_enable_ricochet", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)
ArcCW.ConVars["enable_customization"] = CreateConVar("arccw_enable_customization", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", -1, 1)
ArcCW.ConVars["enable_dropping"] = CreateConVar("arccw_enable_dropping", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)
ArcCW.ConVars["enable_sway"] = CreateConVar("arccw_enable_sway", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)

ArcCW.ConVars["bodydamagemult_cancel"] = CreateConVar("arccw_bodydamagemult_cancel", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 1)

ArcCW.ConVars["attinv_lockmode"] = CreateConVar("arccw_attinv_lockmode", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Once owned, players can use attachments as much as they like.")
ArcCW.ConVars["attinv_free"] = CreateConVar("arccw_attinv_free", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "All attachments can always be used.")
ArcCW.ConVars["attinv_loseondie"] = CreateConVar("arccw_attinv_loseondie", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "All attachments reset on death. If set to 2, drops all attachments in a box.", 0, 2)

ArcCW.ConVars["atts_spawnrand"] = CreateConVar("arccw_atts_spawnrand", 0, FCVAR_ARCHIVE, "Randomly give attachments to player spawned SWEPs.", 0, 1)
ArcCW.ConVars["atts_ubglautoload"] = CreateConVar("arccw_atts_ubglautoload", 0, FCVAR_ARCHIVE, "Automatically load underbarrel weapons when attached.", 0, 1)
ArcCW.ConVars["atts_pickx"] = CreateConVar("arccw_atts_pickx", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Limit weapons to this many maximum attachments. 0 = disable system.", 0)

ArcCW.ConVars["npc_replace"] = CreateConVar("arccw_npc_replace", 0, FCVAR_ARCHIVE, "Replace NPC weapons with ArcCW weapons.")
ArcCW.ConVars["npc_atts"] = CreateConVar("arccw_npc_atts", 1, FCVAR_ARCHIVE, "Randomly give NPC weapons attachments.")

ArcCW.ConVars["truenames"] = CreateConVar("arccw_truenames", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Use true names instead of fake names, where applicable. Requires restart.")

ArcCW.ConVars["equipmentammo"] = CreateConVar("arccw_equipmentammo", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Generate unique ammo types for throwables.", 0, 1) -- Automatically assign unique ammo types to each throwable weapon. Prone to running into the ammo type limit.
ArcCW.ConVars["equipmentsingleton"] = CreateConVar("arccw_equipmentsingleton", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Make grenades and equipment not use ammo, and remove themselves on use.", 0, 1)
ArcCW.ConVars["equipmenttime"] = CreateConVar("arccw_equipmenttime", 180, FCVAR_ARCHIVE, "How long equipment such as Claymores will remain on the map before self-destructing.")

ArcCW.ConVars["mult_damage"] = CreateConVar("arccw_mult_damage", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for damage done by all weapons.")
ArcCW.ConVars["mult_npcdamage"] = CreateConVar("arccw_mult_npcdamage", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for damage done by weapons used by NPCs.")
ArcCW.ConVars["mult_hipfire"] = CreateConVar("arccw_mult_hipfire", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for hip fire spread.")
ArcCW.ConVars["mult_reloadtime"] = CreateConVar("arccw_mult_reloadtime", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how long weapons take to reload.", 0.01)
ArcCW.ConVars["mult_sighttime"] = CreateConVar("arccw_mult_sighttime", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how long weapons take to enter sights.", 0.1)
ArcCW.ConVars["mult_rpm"] = CreateConVar("arccw_mult_rpm", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how fast weapons fire. May be disastrous on performance.", 0.01)
ArcCW.ConVars["mult_range"] = CreateConVar("arccw_mult_range", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for range of all weapons.")
ArcCW.ConVars["mult_recoil"] = CreateConVar("arccw_mult_recoil", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for recoil of all weapons.")
ArcCW.ConVars["mult_accuracy"] = CreateConVar("arccw_mult_accuracy", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for mechanical inprecision of weapons.")
ArcCW.ConVars["mult_movedisp"] = CreateConVar("arccw_mult_movedisp", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for moving inaccuracy of weapons.")
ArcCW.ConVars["mult_penetration"] = CreateConVar("arccw_mult_penetration", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how far weapons should penetrate.")
ArcCW.ConVars["mult_startunloaded"] = CreateConVar("arccw_mult_startunloaded", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "All weapons spawn unloaded.")
ArcCW.ConVars["mult_shootwhilesprinting"] = CreateConVar("arccw_mult_shootwhilesprinting", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Allow any weapon to shoot while sprinting.")
ArcCW.ConVars["mult_defaultammo"] = CreateConVar("arccw_mult_defaultammo", 3, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for default ammo supply.")
ArcCW.ConVars["mult_attchance"] = CreateConVar("arccw_mult_attchance", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for random attachment chance on NPCs and in TTT.")
ArcCW.ConVars["mult_heat"] = CreateConVar("arccw_mult_heat", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much heat increases per shot on certain weapons.", 0)
ArcCW.ConVars["mult_sway"] = CreateConVar("arccw_mult_sway", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much sway exists when in sights.", 0)
ArcCW.ConVars["mult_malfunction"] = CreateConVar("arccw_mult_malfunction", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how often malfunctions occur.", 0)
ArcCW.ConVars["mult_meleedamage"] = CreateConVar("arccw_mult_meleedamage", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for melee damage.", 0)
ArcCW.ConVars["mult_meleetime"] = CreateConVar("arccw_mult_meleetime", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for melee speed.", 0)
ArcCW.ConVars["mult_bottomlessclip"] = CreateConVar("arccw_mult_bottomlessclip", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Enable bottomless clip.", 0, 1)
ArcCW.ConVars["mult_infiniteammo"] = CreateConVar("arccw_mult_infiniteammo", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Enable infinite reserve ammo.", 0, 1)
ArcCW.ConVars["mult_crouchdisp"] = CreateConVar("arccw_mult_crouchdisp", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for hip dispersion while crouching.", 0)
ArcCW.ConVars["mult_crouchrecoil"] = CreateConVar("arccw_mult_crouchrecoil", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for recoil while crouching.", 0)
ArcCW.ConVars["mult_movespeed"] = CreateConVar("arccw_mult_movespeed", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much weapons should affect your regular movespeed.", 0)
ArcCW.ConVars["mult_movespeedads"] = CreateConVar("arccw_mult_movespeedads", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much weapons should affect your movespeed while aiming down sights.", 0)
ArcCW.ConVars["mult_movespeedfire"] = CreateConVar("arccw_mult_movespeedfire", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much weapons should affect your movespeed while firing them.", 0)
ArcCW.ConVars["add_sway"] = CreateConVar("arccw_add_sway", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Add this much sway to all weapons.", 0)

ArcCW.ConVars["override_crosshair_off"] = CreateConVar("arccw_override_crosshair_off", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Set to true to force everyone's crosshairs off.", 0, 1)
ArcCW.ConVars["override_hud_off"] = CreateConVar("arccw_override_hud_off", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Set to true to force everyone's HUDs off.", 0, 1)
ArcCW.ConVars["override_nearwall"] = CreateConVar("arccw_override_nearwall", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Disable weapon length and near-walling.", 0, 1)
ArcCW.ConVars["override_lunge_off"] = CreateConVar("arccw_override_lunge_off", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Disable melee lunging.", 0, 1)

ArcCW.ConVars["ammo_detonationmode"] = CreateConVar("arccw_ammo_detonationmode", 2, FCVAR_REPLICATED, "The type of ammo detonation to use. -1 = don't explode, 0 = simple explosion, 1 = fragmentation, 2 = full", -1, 2)
ArcCW.ConVars["ammo_autopickup"] = CreateConVar("arccw_ammo_autopickup", 1, FCVAR_REPLICATED, "Whether to pick up ammo when walking over in addition to pressing Use.", 0, 1)
ArcCW.ConVars["ammo_largetrigger"] = CreateConVar("arccw_ammo_largetrigger", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Whether to use larger trigger boxes for ammo, similar to HL2. Only useful when autopickup is true.", 0, 1)
ArcCW.ConVars["ammo_rareskin"] = CreateConVar("arccw_ammo_rareskin", 0.08, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Chance for a rare skin to appear. Only specific models have these.", 0, 1)
ArcCW.ConVars["ammo_chaindet"] = CreateConVar("arccw_ammo_chaindet", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Whether to allow ammoboxes to detonate each other. If disabled, they will still be destroyed but !explode.", 0, 1)
ArcCW.ConVars["ammo_replace"] = CreateConVar("arccw_ammo_replace", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "If enabled, all vanilla ammo entities will be forcefully replaced with ArcCW equivalents.", 0, 1)

ArcCW.ConVars["mult_ammohealth"] = CreateConVar("arccw_mult_ammohealth", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much health ammo boxes have. Set to -1 for indestructible boxes.", -1)
ArcCW.ConVars["mult_ammoamount"] = CreateConVar("arccw_mult_ammoamount", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Multiplier for how much ammo are in ammo boxes.", 0)

ArcCW.ConVars["limityear_enable"] = CreateConVar("arccw_limityear_enable", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Limit the maximum year for weapons.")
ArcCW.ConVars["limityear"] = CreateConVar("arccw_limityear", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Limit the maximum year for weapons.")

ArcCW.ConVars["doorbust"] = CreateConVar("arccw_doorbust", 0, FCVAR_ARCHIVE, "Whether to allow door busting. 1 - break down, 2 - open only", 0, 2)
ArcCW.ConVars["doorbust_threshold"] = CreateConVar("arccw_doorbust_threshold", 80, FCVAR_ARCHIVE, "The amount of damage needed to bust a normal sized door.")
ArcCW.ConVars["doorbust_time"] = CreateConVar("arccw_doorbust_time", 180, FCVAR_ARCHIVE, "The amount of time to keep the door busted by.", 1)

ArcCW.ConVars["driveby"] = CreateConVar("arccw_driveby", 0, FCVAR_ARCHIVE, "Enable special checks that allow you to fire out of vehicles (assuming some vehicle weaponizer addon exists).", 0, 1)

ArcCW.ConVars["clicktocycle"] = CreateConVar("arccw_clicktocycle", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Whether to make it so left clicking after shooting cycles instead of on mouse release.")
ArcCW.ConVars["throwinertia"] = CreateConVar("arccw_throwinertia", 1, FCVAR_ARCHIVE, "Set to make throwable equipment inherit the player's velocity.", 0, 1)

ArcCW.ConVars["bullet_enable"] = CreateConVar("arccw_bullet_enable", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Use physical bullets with drop and travel time.")
ArcCW.ConVars["bullet_velocity"] = CreateConVar("arccw_bullet_velocity", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED)
ArcCW.ConVars["bullet_drag"] = CreateConVar("arccw_bullet_drag", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED)
ArcCW.ConVars["bullet_lifetime"] = CreateConVar("arccw_bullet_lifetime", 10, FCVAR_ARCHIVE + FCVAR_REPLICATED)
ArcCW.ConVars["bullet_gravity"] = CreateConVar("arccw_bullet_gravity", 600, FCVAR_ARCHIVE + FCVAR_REPLICATED)

ArcCW.ConVars["weakensounds"] = CreateConVar("arccw_weakensounds", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Reduce all weapons' firing volume by this much decibels, making it easier to hide shooting sounds. Clamped to 60-150dB.")

ArcCW.ConVars["desync"] = CreateConVar("arccw_desync", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Turning this on prevents cheaters from predicting the bullet direction/spread, making the nospread cheat useless.")

ArcCW.ConVars["aimassist"] = CreateConVar("arccw_aimassist", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Enable A I M B O T", 0, 1)
ArcCW.ConVars["aimassist_head"] = CreateConVar("arccw_aimassist_head", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "My advice for you: aim for the head!", 0, 1)
ArcCW.ConVars["aimassist_cone"] = CreateConVar("arccw_aimassist_cone", 5, FCVAR_ARCHIVE + FCVAR_REPLICATED, "The angle of the cone within which targets can be seeked.", 1, 360)
ArcCW.ConVars["aimassist_distance"] = CreateConVar("arccw_aimassist_distance", 1024, FCVAR_ARCHIVE + FCVAR_REPLICATED, "The distance within which aim assist will trigger.", 128)
ArcCW.ConVars["aimassist_intensity"] = CreateConVar("arccw_aimassist_intensity", 0.5, FCVAR_ARCHIVE + FCVAR_REPLICATED, "How strong the assist is.", 0, 10)

ArcCW.ConVars["malfunction"] = CreateConVar("arccw_malfunction", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 2)

ArcCW.ConVars["attinv_giveonspawn"] = CreateConVar("arccw_attinv_giveonspawn", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Give this many random attachments to players on spawn.", 0)

ArcCW.ConVars["reloadincust"] = CreateConVar("arccw_reloadincust", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Allow players to reload when customizing.", 0, 1)
ArcCW.ConVars["freeaim"] = CreateConVar("arccw_freeaim", 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "", 0, 2)

-- developer stuff
ArcCW.ConVars["reloadatts_mapcleanup"] = CreateConVar("arccw_reloadatts_mapcleanup", 0, 0, "Whether to reload ArcCW attachments on admin clean up.")
ArcCW.ConVars["reloadatts_registerentities"] = CreateConVar("arccw_reloadatts_registerentities", 1, 0, "Register attachment entities. This may increase time to reload attachments.")
ArcCW.ConVars["reloadatts_showignored"] = CreateConVar("arccw_reloadatts_showignored", 0, 0, "Whether to include attachments set to Ignore.")
ArcCW.ConVars["dev_debug"] = CreateConVar("arccw_dev_debug", 0, 0, "Developer debug HUD showing cool time shit.", 0, 1)
ArcCW.ConVars["dev_shootinfo"] = CreateConVar("arccw_dev_shootinfo", 0, 0, "Show debug overlay firing information. Only works when developer is set to 1.", 0, 3)
ArcCW.ConVars["dev_alwaysready"] = CreateConVar("arccw_dev_alwaysready", 0, 0, "Always draw using the ready animation.", 0, 1)
--CreateConVar("arccw_dev_cust2beta", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Use the new beta customize hud.", 0, 1)

if engine.ActiveGamemode() == "terrortown" then
    ArcCW.ConVars["ttt_replace"] = CreateConVar("arccw_ttt_replace", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Use custom code to forcefully replace TTT weapons with ArcCW ones.", 0, 1)
    ArcCW.ConVars["ttt_ammo"] = CreateConVar("arccw_ttt_ammo", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Replace TTT ammo with ArcCW ones, takes precedence over the default convar.", 0, 1)
    ArcCW.ConVars["ttt_atts"] = CreateConVar("arccw_ttt_atts", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Automatically set up ArcCW weapons with an attachment loadout.", 0, 1)
    ArcCW.ConVars["ttt_customizemode"] = CreateConVar("arccw_ttt_customizemode", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "If set to 1, disallow customization on ArcCW weapons. If set to 2, players can customize during setup and postgame. If set to 3, only T and Ds can customize.", 0, 3)
    ArcCW.ConVars["ttt_bodyattinfo"] = CreateConVar("arccw_ttt_bodyattinfo", 1, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Whether a corpse contains info on the attachments of the murder weapon. 1 means detective only and 2 means everyone.", 0, 2)
end
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_barrel_extended.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_barrel_extended.lua:
att.PrintName = "15a Extended barrel"
att.Description = "Extended barrel for DC-15a."
att.SortOrder = 40
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_a280c_grip.png")
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_barrel"
att.ActivateElements = {"15a_barrel_extended"}

att.Mult_MoveSpeed = 0.9

att.Mult_MoveDispersion = 1.25
att.Mult_SightTime = 1.15
att.Mult_AccuracyMOA = 0.8
att.Mult_ShootPitch = 0.95

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_stock_short.lua:
att.PrintName = "15a Skeleton Stock"
att.PrintName = "Skeleton Stock for DC-15a. Improves speed with more recoil."
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}

att.Slot = {"15a_stock"}
att.ActivateElements = {"15a_stock_short"}

att.Mult_Damage = 1.05
att.Mult_SightTime = 1.05
att.Mult_Sway = 1.2
att.Mult_SpeedMult = 1.5
att.Mult_DrawTime = 0.65
att.Mult_HolsterTime = 1.05
att.Mult_HipDispersion = 1.30
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_mag_a280.lua:
att.PrintName = "15s Extended Magazine (A280)"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine for DC-15s"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "15s_mag"
att.ActivateElements = {"15s_mag_a280"}

att.AutoStats = true
att.HideIfBlocked = true
att.Override_ClipSize = 75

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1
att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95
att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25
att.Mult_HipDispersion = 1.3

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/242_barrel_sniper.lua:
att.PrintName = "NT-242 Extended Barrel"
att.Description = "Extended barrel for NT-242."
att.SortOrder = 40
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_a280c_grip.png")
att.Desc_Cons = {}

att.AutoStats = true
att.Slot = "242_barrel"
att.ActivateElements = {"242_barrel_extended"}

att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_green"
att.Override_Tracer = "tracer_green"

att.Mult_MoveSpeed = 0.9
att.Mult_MoveDispersion = 1.25
att.Mult_SightTime = 1.15
att.Mult_Range = 2.5
att.Mult_RPM = 0.9
att.Mult_Damage = 2
att.Override_AccuracyMOA = 0.1
att.Mult_ShootPitch = 0.70

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a180_barrel_extended.lua:
att.PrintName = "Extended Barrel"
att.Icon = Material("entities/kraken/sops/atts/a180barrel.png", "mips smooth")
att.Description = "Improves ranged performance, but at the cost of mobility."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "a180_barrele"
att.ActivateElements = {"a180_barrele"}

att.Mult_MoveSpeed = 0.9

att.Mult_MoveDispersion = 1.25
att.Mult_SightTime = 1.15
att.Mult_AccuracyMOA = 0.8
att.Mult_ShootPitch = 0.95

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_destabilization_mod.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_impact.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_smoke.lua:
att.PrintName = "Smoke Grenade Launcher"
att.Icon = Material("interfaz/armas/sw_smokegrenade.png")
att.Description = "Throwable grenade with smoke capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_smoke"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH lua/arccw/shared/attachments/ammo_high.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/dc17_module.lua:
att.PrintName = "DC-17S Module"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/module2.png")
att.Description = "Integrates the module of a DC-17S into the weapon."

att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true
att.Slot = "dc17s_module"
att.ActivateElements = {"dc17s_module"}

att.Mult_Damage = 1.15
att.Mult_Range = 1.15
att.Mult_SightTime = 1.10
att.Mult_AccuracyMOA = 0.85
att.Mult_ShootPitch = 0.95
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/dc17_powerpack.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_smoke.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/muzzle_a280cfe_mod.lua:
att.PrintName = "A280-CFE Barrel Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/a280cfe_barrel_mod.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 0.9
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_cloneairborne.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_loadingdrills.lua:
att.PrintName = "Loading Drills"

att.Icon = Material("interfaz/iconos/kraken/jedi comm assault specialist/4234321436_1053532338.png")
att.Description = "Every second counts in the heat of battle. Repeated training drills allow you to reload your weapon more quickly."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.Mult_ReloadTime = 0.6

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_sledge.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_technician.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/special_explosive.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/special_heal.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc17m_85mag.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_physbullet2.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_truenames.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_truenames.lua:
hook.Add("CreateTeams", "ArcCW_TrueNames", function()
    if !ArcCW.ConVars["truenames"]:GetBool() then return end

    for _, i in pairs(weapons.GetList()) do
        local wpn = weapons.GetStored(i.ClassName)

        if wpn.TrueName then
            wpn.PrintName = wpn.TrueName
        end
    end
end)
--PATH lua/arccw/shared/status_effects.lua:
return gluapack()()
--PATH lua/arccw/client/cl_autostats.lua:
return gluapack()()
--PATH lua/arccw/client/cl_menus.lua:
return gluapack()()
--PATH lua/arccw/client/cl_vrmod.lua:
local function addmenu()
    if !vrmod then return end

    vrmod.AddInGameMenuItem("ArcCW Customize", 3, 1, function()
        local wep = LocalPlayer():GetActiveWeapon()

        if !IsValid(wep) or !wep.ArcCW then return end

        wep:ToggleCustomizeHUD(!IsValid(ArcCW.InvHUD))
    end)
end

hook.Add("VRMod_Start", "ArcCW", addmenu)
--PATH lua/autorun/arccw_kraken_sharedsounds.lua:
return gluapack()()
--PATH lua/autorun/assasin_cgi.lua:
return gluapack()()
--PATH lua/autorun/aura_canofen_lvs_capital_ship_config.lua:
print("--------------------------------------------------")
print("Aura LVS Capital Ships config has been initialized")
print("--------------------------------------------------")

Aura_LVS_CapitalShipsRepublic = Aura_LVS_CapitalShipsRepublic or {} -- Don't touch this
--[[

************************************************************************
                          IMPORTANT, PLEASE READ
************************************************************************

To add ships, first select the faction you want in the tables below like CIS, Republic, ect.
Next, using the format below, add a new line with the details of the ship you want to add, next save the file and it should be good to go

Format:

Aura_LVS_CapitalShipsRepublic =
{
	["Name"] = "class",
}
Name can be whatever you want it to show as in the edit properties menu, class is the actual entity class of the ship, that can be found by copying it from the spawn menu

Hopefully this was helpful, thanks!

(All ships below are just examples, they are in game currently so if you want to remove them, remove it and decrement the thing in [], although these are my preferences)
(Also I couldn't find like any Rebel ships so it has the same as republic)
]]--

Aura_LVS_Enable_Death_Explosion			 = true -- Set this to false to remove all gbomb related things for the ships such as death explosions
Aura_LVS_Enable_Explode_On_Shot			 = true -- Set this to false to disable mini-explosions when the ships get shot

Aura_LVS_Capital_Ships_Lists = 
{
    ["aura_lvs_capital_ship_base"] =
    {
        [""] = "",
    },
    ["aura_lvs_acclamator_mk2"] = 
    {
        ["ARC-170"] = "lvs_starfighter_arc170",
        ["V-Wing"] = "lvs_starfighter_vwing",
        ["LAAT/i"] = "lvs_repulsorlift_gunship",
        ["NBT-630"] = "lvs_starfighter_nbt630",
        ["N1 Starfighter"] = "lvs_starfighter_n1",
    },
	["aura_lvs_venator_mk2"] = 
    {
        ["ARC-170"] = "lvs_starfighter_arc170",
        ["V-Wing"] = "lvs_starfighter_vwing",
        ["LAAT/i"] = "lvs_repulsorlift_gunship",
        ["NBT-630"] = "lvs_starfighter_nbt630",
        ["N1 Starfighter"] = "lvs_starfighter_n1",
    },
	["aura_lvs_arquitens"] = 
    {
    },
	["aura_lvs_pelta"] = 
    {
    },
	["aura_lvs_consular"] = 
    {
    },
	["aura_lvs_cr25"] = 
    {
    },
	["aura_lvs_cr90_rep"] = 
    {
    },
	["aura_lvs_rtt04"] = 
    {
    },
	["aura_lvs_cargo"] = 
    {
    },
	["aura_lvs_cargo2"] = 
    {
    },
	["aura_lvs_cargo3"] = 
    {
    },
	["aura_lvs_cargo4"] = 
    {
    },
	["aura_lvs_cargo5"] = 
    {
    },
	["aura_lvs_cargo6"] = 
    {
    },
	["aura_lvs_cargo7"] = 
    {
    },
	["aura_lvs_cargo8"] = 
    {
    },
	["aura_lvs_cr90_neu"] = 
    {
    },
	["aura_lvs_aa-9_liner"] = 
    {
    },
	["aura_lvs_satellite_neu_1"] = 
    {
    },
	["aura_lvs_satellite_csi_1"] = 
    {
    },
	["aura_lvs_satellite_csi_2"] = 
    {
    },
	["aura_lvs_satellite_rep_1"] = 
    {
    },
	["aura_lvs_satellite_rep_2"] = 
    {
    },
    ["aura_lvs_munificent_mk2"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["Droid Gunship"] = "lvs_gunship_hmp",
    },
	["aura_lvs_recusant"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["Droid Gunship"] = "lvs_gunship_hmp",
    },
	["aura_lvs_providence_mk2"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["Droid Gunship"] = "lvs_gunship_hmp",
    },
	["aura_lvs_core"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["Droid Gunship"] = "lvs_gunship_hmp",
    },
    ["aura_lvs_dh_omni"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["Droid Gunship"] = "lvs_gunship_hmp",
    },	
    ["aura_lvs_bulwark"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["Droid Gunship"] = "lvs_gunship_hmp",
    },	
    ["aura_lvs_hardcell"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["AAT"] = "lvs_fakehover_aat",
        ["GAT"] = "lvs_hover_cistank",
        ["HAG"] = "lvs_hover_mortar",
    },	
    ["aura_lvs_lucrehulk"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["Droid Gunship"] = "lvs_gunship_hmp",
    },	
    ["aura_lvs_9799"] =
    {
        ["AAT"] = "lvs_fakehover_aat",
        ["GAT"] = "lvs_hover_cistank",
        ["HAG"] = "lvs_hover_mortar",
    },	
    ["aura_lvs_geo_cruiser"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["Chasseur Nantex Embarqué"] = "lvs_starfighter_geo",
    },	
    ["aura_lvs_diamond"] =
    {
    },	
    ["aura_lvs_captor"] =
    {
        ["Tri-Fighter"] = "lvs_starfighter_droidtrifighter",
        ["Vulture Droid"] = "lvs_starfighter_vulturedroid",
        ["Hyena Bomber"] = "lvs_starfighter_hyenabomber",
        ["Droid Gunship"] = "lvs_gunship_hmp",
    },	
    ["aura_lvs_gozanti"] =
    {
    },	

   ["aura_lvs_acclamator"] = 
    {

    },
    ["aura_lvs_venator"] =
    {

    },
    ["aura_lvs_mon_calamari"] =
    {

    },
    ["aura_lvs_munificent"] =
    {

    },
    ["aura_lvs_providence"] =
    {

    },
}

--PATH lua/autorun/aussi_cgiunassigned_arms.lua:
return gluapack()()
--PATH lua/autorun/aussi_cgiunassigned_arms.lua:
list.Set( "PlayerOptionsModel", "Phase 2 Trooper (CGI)", "models/aussiwozzi/cgi/base/unassigned_trp.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper (CGI)", "models/aussiwozzi/cgi/base/unassigned_trp.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper (CGI)", "models/aussiwozzi/cgi/base/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Trooper ARF (CGI)", "models/aussiwozzi/cgi/base/unassigned_arf.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper ARF (CGI)", "models/aussiwozzi/cgi/base/unassigned_arf.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper ARF (CGI)", "models/aussiwozzi/cgi/base/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Trooper BARC (CGI)", "models/aussiwozzi/cgi/base/unassigned_barc.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper BARC (CGI)", "models/aussiwozzi/cgi/base/unassigned_barc.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper BARC (CGI)", "models/aussiwozzi/cgi/base/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Trooper Pilot (CGI)", "models/aussiwozzi/cgi/base/unassigned_pilot.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper Pilot (CGI)", "models/aussiwozzi/cgi/base/unassigned_pilot.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper Pilot (CGI)", "models/aussiwozzi/cgi/base/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Trooper Engineer (CGI)", "models/aussiwozzi/cgi/base/unassigned_engineer.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper Engineer (CGI)", "models/aussiwozzi/cgi/base/unassigned_engineer.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper Engineer (CGI)", "models/aussiwozzi/cgi/base/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Trooper Heavy (CGI)", "models/aussiwozzi/cgi/base/unassigned_heavy.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper Heavy (CGI)", "models/aussiwozzi/cgi/base/unassigned_heavy.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper Heavy (CGI)", "models/aussiwozzi/cgi/base/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Trooper Para (CGI)", "models/aussiwozzi/cgi/base/unassigned_para.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper Para (CGI)", "models/aussiwozzi/cgi/base/unassigned_para.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper Para (CGI)", "models/aussiwozzi/cgi/base/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Trooper Scout (CGI)", "models/aussiwozzi/cgi/base/unassigned_scout.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper Scout (CGI)", "models/aussiwozzi/cgi/base/unassigned_scout.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper Scout (CGI)", "models/aussiwozzi/cgi/base/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Trooper Spec Ops (CGI)", "models/aussiwozzi/cgi/base/unassigned_specops.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper Spec Ops (CGI)", "models/aussiwozzi/cgi/base/unassigned_specops.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper Spec Ops (CGI)", "models/aussiwozzi/cgi/base/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Republic High Command (CGI)", "models/aussiwozzi/cgi/base/rhc_1.mdl" )
player_manager.AddValidModel( "Phase 2 Republic High Command (CGI)", "models/aussiwozzi/cgi/base/rhc_1.mdl" )
player_manager.AddValidHands( "Phase 2 Republic High Command (CGI)", "models/aussiwozzi/cgi/base/rhc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Republic High Command 2 (CGI)", "models/aussiwozzi/cgi/base/rhc_2.mdl" )
player_manager.AddValidModel( "Phase 2 Republic High Command 2 (CGI)", "models/aussiwozzi/cgi/base/rhc_2.mdl" )
player_manager.AddValidHands( "Phase 2 Republic High Command 2 (CGI)", "models/aussiwozzi/cgi/base/rhc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Trooper ARC (CGI)", "models/aussiwozzi/cgi/base/unassigned_arc.mdl" )
player_manager.AddValidModel( "Phase 2 Trooper ARC (CGI)", "models/aussiwozzi/cgi/base/unassigned_arc.mdl" )
player_manager.AddValidHands( "Phase 2 Trooper ARC (CGI)", "models/aussiwozzi/cgi/base/arc_unassigned_arms.mdl",0,"10000000" )


list.Set( "PlayerOptionsModel", "Phase 1.5 Trooper ARC (CGI)", "models/aussiwozzi/cgi/base/unassigned_arc_phase15.mdl" )
player_manager.AddValidModel( "Phase 1.5 Trooper ARC (CGI)", "models/aussiwozzi/cgi/base/unassigned_arc_phase15.mdl" )
player_manager.AddValidHands( "Phase 1.5 Trooper ARC (CGI)", "models/aussiwozzi/cgi/base/arc_unassigned_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Sergeant Pilot (CGI)", "models/aussiwozzi/cgi/base/pilot_sgt.mdl" )
player_manager.AddValidModel( "Phase 2 Sergeant Pilot (CGI)", "models/aussiwozzi/cgi/base/pilot_sgt.mdl" )
player_manager.AddValidHands( "Phase 2 Sergeant Pilot (CGI)", "models/aussiwozzi/cgi/base/sgt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Sergeant (CGI)", "models/aussiwozzi/cgi/base/unassigned_sgt.mdl" )
player_manager.AddValidModel( "Phase 2 Sergeant (CGI)", "models/aussiwozzi/cgi/base/unassigned_sgt.mdl" )
player_manager.AddValidHands( "Phase 2 Sergeant (CGI)", "models/aussiwozzi/cgi/base/sgt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Lieuteant Pilot (CGI)", "models/aussiwozzi/cgi/base/pilot_lt.mdl" )
player_manager.AddValidModel( "Phase 2 Lieuteant Pilot (CGI)", "models/aussiwozzi/cgi/base/pilot_lt.mdl" )
player_manager.AddValidHands( "Phase 2 Lieuteant Pilot (CGI)", "models/aussiwozzi/cgi/base/lt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Lieuteant (CGI)", "models/aussiwozzi/cgi/base/unassigned_lt.mdl" )
player_manager.AddValidModel( "Phase 2 Lieuteant (CGI)", "models/aussiwozzi/cgi/base/unassigned_lt.mdl" )
player_manager.AddValidHands( "Phase 2 Lieuteant (CGI)", "models/aussiwozzi/cgi/base/lt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Captain Pilot (CGI)", "models/aussiwozzi/cgi/base/pilot_cpt.mdl" )
player_manager.AddValidModel( "Phase 2 Captain Pilot (CGI)", "models/aussiwozzi/cgi/base/pilot_cpt.mdl" )
player_manager.AddValidHands( "Phase 2 Captain Pilot (CGI)", "models/aussiwozzi/cgi/base/cpt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Captain (CGI)", "models/aussiwozzi/cgi/base/unassigned_cpt.mdl" )
player_manager.AddValidModel( "Phase 2 Captain (CGI)", "models/aussiwozzi/cgi/base/unassigned_cpt.mdl" )
player_manager.AddValidHands( "Phase 2 Captain (CGI)", "models/aussiwozzi/cgi/base/cpt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Commander Pilot (CGI)", "models/aussiwozzi/cgi/base/pilot_com.mdl" )
player_manager.AddValidModel( "Phase 2 Commander Pilot (CGI)", "models/aussiwozzi/cgi/base/pilot_com.mdl" )
player_manager.AddValidHands( "Phase 2 Commander Pilot (CGI)", "models/aussiwozzi/cgi/base/com_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Commander (CGI)", "models/aussiwozzi/cgi/base/unassigned_com.mdl" )
player_manager.AddValidModel( "Phase 2 Commander (CGI)", "models/aussiwozzi/cgi/base/unassigned_com.mdl" )
player_manager.AddValidHands( "Phase 2 Commander (CGI)", "models/aussiwozzi/cgi/base/com_arms.mdl",0,"10000000" )
























--PATH addons/[admin] awarn3/lua/localizations/en-us.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/no.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/awarn3_vgui.lua:
AddCSLuaFile()
--[[
      __          __              ____  
     /\ \        / /             |___ \ 
    /  \ \  /\  / /_ _ _ __ _ __   __) |
   / /\ \ \/  \/ / _` | '__| '_ \ |__ < 
  / ____ \  /\  / (_| | |  | | | |___) |
 /_/    \_\/  \/ \__,_|_|  |_| |_|____/ 

	AWarn3 by Mr.President
]]

MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, "Loading VGUI Module\n" )


AWarn.SelectedLanguage = "EN-US"
AWarn.SelectedTheme = "Light"

include( "includes/vgui/aw3_menu_configuration_settings.lua")

hook.Add( "InitPostEntity", "awarn3_loadlanguage", function()
	AWarn.SelectedLanguage = LocalPlayer():GetPData( "awarn3_lang", "EN-US" )
	AWarn.SelectedTheme = LocalPlayer():GetPData( "awarn3_theme", "Light" )
	
end )

local function ScrWM()
	local wid = ScrW()
	if wid > 3840 then wid = 3840 end
	return wid
end

local function ScrHM()
	local hgt = ScrH()
	if hgt > 2160 then hgt = 2160 end
	return hgt
end

local function ScreenScale( size )
	return size * ( ScrWM() / 640.0 )	
end

local screenscale = ScreenScale( 0.4 )

surface.CreateFont( "AWarn3NavButton", {
	font = "Arial",
	size = math.Round(10 * screenscale),
	weight = 800,
} )

surface.CreateFont( "AWarn3NavButton3", {
	font = "Arial",
	size = math.Round(14 * screenscale),
	weight = 800,
} )

surface.CreateFont( "AWarn3NavButton2", {
	font = "Arial",
	size = math.Round(24 * screenscale),
	weight = 800,
} )

surface.CreateFont( "AWarn3Label1", {
	font = "Arial",
	size = math.Round(20 * screenscale),
	weight = 800,
} )

surface.CreateFont( "AWarn3Label2", {
	font = "Arial",
	size = math.Round(16 * screenscale),
	weight = 800,
} )

surface.CreateFont( "AWarn3Label3", {
	font = "Arial",
	size = math.Round(12 * screenscale),
	weight = 600,
} )

surface.CreateFont( "AWarn3CardText1", {
	font = "Arial",
	size = math.Round(14 * screenscale),
	weight = 800,
} )

surface.CreateFont( "AWarn3CardText2", {
	font = "Arial",
	size = math.Round(12 * screenscale),
	weight = 800,
} )

surface.CreateFont( "AWarn3ToggleText1", {
	font = "Arial",
	size = math.Round(18 * screenscale),
	weight = 800,
} )

surface.CreateFont( "AWarn3ToggleText2", {
	font = "Arial",
	size = math.Round(12 * screenscale),
	weight = 600,
} )

surface.CreateFont( "AWarn3NotesTextBoxMono", {
	font = "Lucida Console",
	size = math.Round(12 * screenscale),
	weight = 400,
} )

local logoImage = Material( "materials/vgui/awlogo.png", "noclamp smooth" )
local playerWarningsImage = Material( "materials/vgui/awarn3_playerwarnings.png", "noclamp smooth" )
local optionsImage = Material( "materials/vgui/aw3_options.png", "noclamp smooth" )
local deleteImage = Material( "materials/vgui/awarn3_delete.png", "noclamp smooth" )
local minusImage = Material( "materials/vgui/awarn3_minus.png", "noclamp smooth" )
local searchImage = Material( "materials/vgui/awarn3_search.png", "noclamp smooth" )
local punishmentOptionsImage = Material( "materials/vgui/aw3_punishment_options.png", "noclamp smooth" )
local serverOptionsImage = Material( "materials/vgui/aw3_server_options.png", "noclamp smooth" )
local userOptionsImage = Material( "materials/vgui/aw3_user_options.png", "noclamp smooth" )
local closeImage = Material( "materials/vgui/aw3_close.png", "noclamp smooth" )
local xImage = Material( "materials/vgui/aw3_x.png", "noclamp smooth" )
local boldXImage = Material( "materials/vgui/awarn3_boldx.png", "noclamp smooth" )
local activeWarnings = Material( "materials/vgui/aw3_active_warnings.png", "noclamp smooth" )
local playerNotes = Material( "materials/vgui/aw3_notes.png", "noclamp smooth" )

local easings = include("includes/awarn3_easings.lua")

AWarn.Colors = AWarn.Colors or {
	COLOR_SELECTED = Color( 255, 0, 200, 160 ),
	COLOR_BUTTON_SELECTED = Color( 180, 40, 40, 40 ),
	COLOR_BUTTON = Color( 80, 80, 80, 0 ),
	COLOR_BUTTON_2 = Color( 180, 80, 80, 120 ),
	COLOR_BUTTON_2_HOVERED = Color( 180, 80, 80, 180 ),
	COLOR_BUTTON_HOVERED = Color( 80, 80, 80, 30 ),
	COLOR_BUTTON_DISABLED = Color( 120, 120, 120, 40 ),
	COLOR_BUTTON_TEXT = Color( 20, 20, 20, 180 ),
	COLOR_LABEL_TEXT = Color( 180, 80, 160, 255 ),
	COLOR_LABEL_VALUE_TEXT = Color( 220, 80, 220, 220 ),
	COLOR_THEME_PRIMARY = Color( 255, 230, 255, 250 ),
	COLOR_THEME_SECONDARY = Color( 255, 210, 255, 255 ),
	COLOR_THEME_PRIMARY_SHADOW = Color( 235, 216, 234, 250 ),
	COLOR_RED_BUTTON = Color(255,80,80,200),
	COLOR_RED_BUTTON_HOVERED = Color(255,80,80,255),
}

function AWarn:OpenMenu()
	if IsValid( self.menu ) then self.menu:Remove() end
	self.menu = vgui.Create( "awarn3_menu" )
	self.menu:SetWide( ScrWM() * 0.75 )
	self.menu:SetTall( ScrHM() * 0.75 )
	self.menu:Center()
	self.menu:MakePopup()
	self.menu:DrawElements()
	
	AWarn:RequestOptions()
	AWarn:RequestPunishments()
	AWarn:RequestPresets()
	AWarn:RequestOwnWarnings()
end

function AWarn:RequestOptions()
	net.Start( "awarn3_networkoptions" )
	net.WriteString( "update" )
	net.SendToServer()
end

function AWarn:RequestPunishments()
	net.Start( "awarn3_networkpunishments" )
	net.WriteString( "update" )
	net.SendToServer()
end

function AWarn:RequestPresets()
	net.Start( "awarn3_networkpresets" )
	net.WriteString( "update" )
	net.SendToServer()
end

function AWarn:SendOptionUpdate( option, value )
	net.Start( "awarn3_networkoptions" )
	net.WriteString( "write" )
	
	if AWarn.Options[ option ].type == "boolean" then
		net.WriteString( option )
		net.WriteBool( value )
	elseif AWarn.Options[ option ].type == "integer" then
		net.WriteString( option )
		net.WriteInt( value, 32 )
	elseif AWarn.Options[ option ].type == "string" then
		net.WriteString( option )
		net.WriteString( value )
	end
	
	net.SendToServer()
end

net.Receive( "awarn3_networkoptions", function()
	if not IsValid( AWarn.menu ) then return end
	local options = net.ReadTable()
	AWarn.Options = options
	
	if table.Count( AWarn.Options ) > 0 then
		AWarn:RefreshSettings()
	end
end )

net.Receive( "awarn3_networkpunishments", function()
	if not IsValid( AWarn.menu ) then return end
	local punishments = net.ReadTable()
	AWarn.Punishments = punishments
	
	AWarn:RefreshPunishments()
end )


net.Receive( "awarn3_networkpresets", function()
	if not IsValid( AWarn.menu ) then return end
	local presets = net.ReadTable()
	AWarn.Presets = presets
	
	AWarn:RefreshPresets()
end )

net.Receive( "awarn3_openmenu", function( l, pl )
	AWarn:OpenMenu()
end )

function AWarn:CloseMenu()
	if IsValid( self.menu ) then self.menu:Remove() end
	AWarn:SaveClientSettings()
end

local text = "~Rainbow~"
local PANEL = {}
function PANEL:Init()
	self.startTime = SysTime()
	self:SetDraggable( false )
	self:SetTitle( "" )
	self:ShowCloseButton( false )
end
function PANEL:Paint()
	
	if tobool(LocalPlayer():GetPData( "awarn3_blurbackground", true )) then
		Derma_DrawBackgroundBlur( self, self.startTime )
	end
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_SECONDARY )
	surface.DrawRect( 80 * screenscale, 70 * screenscale, self:GetWide(), self:GetTall() )  --Main Body
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 0, 0, self:GetWide(), 70 * screenscale ) --Header
	
	surface.DrawRect( 0, 70 * screenscale, 80 * screenscale, self:GetTall() - 70 * screenscale ) --Left Panel
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 80 * screenscale, 70 * screenscale, 3 * screenscale, self:GetTall() - 70 * screenscale ) --Left Panel Shadow
	surface.DrawRect( 80 * screenscale + 3 * screenscale, 70 * screenscale, self:GetWide() - (80 * screenscale + 3 * screenscale), 3 * screenscale ) --Header Shadow
	
	surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	surface.SetMaterial( logoImage	)
	surface.DrawTexturedRect( 16 * screenscale, 16 * screenscale, 48 * screenscale, 48 * screenscale )
	
	if AWarn.Outdated then
		surface.SetFont( "AWarn3Label2" )
		surface.SetTextColor( 255, 0, 0 )
		surface.SetTextPos(  self:GetWide() - 350 * screenscale, 30 * screenscale ) 
		surface.DrawText( "A new version of AWarn3 is available for download." )
	end
end
function PANEL:DrawElements()

	local navButtonPanel = vgui.Create( "DPanel", self )
	navButtonPanel:SetPos( 0, 70 * screenscale )
	navButtonPanel:DockPadding( 0, 10, 0, 70 * screenscale )
	navButtonPanel:SetSize( 80 * screenscale, self:GetTall() )
	navButtonPanel.Paint = function()
		--Render Invisible
		surface.SetDrawColor( 200, 200, 200, 0 )
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end

	local mainBodyPanel = vgui.Create( "DPanel", self )
	mainBodyPanel:SetPos( 80 * screenscale, 70 * screenscale )
	mainBodyPanel:DockPadding( 0, 0, 0, 0 )
	mainBodyPanel:SetSize( self:GetWide() - 80 * screenscale, self:GetTall() )
	mainBodyPanel.Paint = function()
		--Render Invisible
		surface.SetDrawColor( 200, 0, 200, 0 )
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	
	if AWarn:CheckPermission( LocalPlayer(), "awarn_view" ) then
		if IsValid( self.adminWarningsView ) then self.adminWarningsView:Remove() end
		self.adminWarningsView = vgui.Create( "awarn3_adminwarningsview", mainBodyPanel )
	else
		if IsValid( self.selfWarningsView ) then self.selfWarningsView:Remove() end
		self.selfWarningsView = vgui.Create( "awarn3_selfwarningsview", mainBodyPanel )	
	end
	
	if IsValid( self.configurationview ) then self.configurationview:Remove() end
	self.configurationview = vgui.Create( "awarn3_configurationview", mainBodyPanel )
	self.configurationview:Dock( FILL )
	self.configurationview:InvalidateParent( true )
	self.configurationview:InvalidateLayout( true )
	self.configurationview:DrawElements()
	self.configurationview:Hide()
	
	local navButton = vgui.Create( "awarn3_navbutton", navButtonPanel )
	navButton:SetText(AWarn.Localization:GetTranslation( "viewwarnings" ))
	navButton:SetIcon( playerWarningsImage )
	navButton:SetEnabled( true )
	navButton.OnSelected = function()
		if AWarn:CheckPermission( LocalPlayer(), "awarn_view" ) then
			self.adminWarningsView:Show()
		else
			self.selfWarningsView:Show()
		end
		self.configurationview:Hide()
	end
	AWarn.lastSelectedNavButton = navButton
	
	local navButton = vgui.Create( "awarn3_navbutton", navButtonPanel )
	navButton:SetText(AWarn.Localization:GetTranslation( "configuration" ))
	navButton:SetIcon( optionsImage )
	navButton.OnSelected = function()
		if AWarn:CheckPermission( LocalPlayer(), "awarn_view" ) then
			self.adminWarningsView:Hide()
		else
			self.selfWarningsView:Hide()		
		end		
		self.configurationview:Show()
	end
	
	local navButton = vgui.Create( "awarn3_navbutton2", navButtonPanel )
	navButton:SetText( AWarn.Localization:GetTranslation( "closemenu" ) )
	navButton:SetIcon( closeImage )
	navButton.OnSelected = function()
		AWarn:CloseMenu()
	end
	
	
	if AWarn:CheckPermission( LocalPlayer(), "awarn_view" ) then
		local navButton = vgui.Create( "awarn3_navbutton2", navButtonPanel )
		navButton:SetText( AWarn.Localization:GetTranslation( "searchplayers" ) )
		navButton:SetIcon( searchImage )
		navButton.OnSelected = function()
			if IsValid( AWarn.menu.playerwarndialogue ) then AWarn.menu.playerwarndialogue:Remove() end
			if IsValid( AWarn.menu.playersearch ) then AWarn.menu.playersearch:Remove() end
			AWarn.menu.playersearch = vgui.Create( "awarn3_playersearch" )
			AWarn.menu.playersearch:MakePopup()
			AWarn.menu.playersearch:SetParent( AWarn.menu )
		end
	end

	
end
function PANEL:Think()
	self:MoveToBack()
end
vgui.Register( "awarn3_menu", PANEL, "DFrame" )




function AWarn:CreatePunishmentCard( tblInfo )
	local searchPlayerCard = vgui.Create( "awarn3_punishmentcard" )
	AWarn.menu.configurationview.PunishmentsCardsPanel:AddItem( searchPlayerCard )
	searchPlayerCard:SetInfo( tblInfo )
	searchPlayerCard:Dock( TOP )
	local cardNum = #AWarn.menu.configurationview.PunishmentsCardsPanel:GetCanvas():GetChildren()
	AWarn.menu.configurationview.PunishmentsCardsPanel:SetHeight( math.Clamp( ( 60 * screenscale ) * cardNum, 100, 300 ) )
	searchPlayerCard:DrawElements()
		
	searchPlayerCard.hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	searchPlayerCard.hdiv:Dock( TOP )
	AWarn.menu.configurationview.PunishmentsCardsPanel:AddItem( searchPlayerCard.hdiv )
end

function AWarn:RefreshPunishments()

	AWarn.menu.configurationview.PunishmentsCardsPanel:Clear()
	for k, v in SortedPairs( AWarn.Punishments ) do
		AWarn:CreatePunishmentCard( v )
	end

end


function AWarn:CreatePresetCard( tblInfo )
	local presetCard = vgui.Create( "awarn3_presetcard" )
	AWarn.menu.configurationview.PresetsCardsPanel:AddItem( presetCard )
	presetCard:SetInfo( tblInfo )
	presetCard:Dock( TOP )
	local cardNum = #AWarn.menu.configurationview.PresetsCardsPanel:GetCanvas():GetChildren()
	AWarn.menu.configurationview.PresetsCardsPanel:SetHeight( math.Clamp( ( 60 * screenscale ) * cardNum, 100, 300 ) )
	presetCard:DrawElements()
		
	presetCard.hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	presetCard.hdiv:Dock( TOP )
	AWarn.menu.configurationview.PresetsCardsPanel:AddItem( presetCard.hdiv )
end

function AWarn:RefreshPresets()

	AWarn.menu.configurationview.PresetsCardsPanel:Clear()
	for k, v in SortedPairs( AWarn.Presets ) do
		AWarn:CreatePresetCard( v )
	end

end


local PANEL = {}
function PANEL:Init()
	local dockMargin = 4 * screenscale
	self:DockMargin( dockMargin, dockMargin, dockMargin, dockMargin )
	self:SetHeight( 42 * screenscale )
	self:Dock( TOP )
	
	self.hovered = false
	
	self.start = RealTime()
	self.stop = RealTime() + 0.1
	self.animating = true

	self.pName = "NULL"
	self.pReason = "NULL"

end
function PANEL:SetInfo( tbl )
	self.pName = tbl.pName or "NULL"
	self.pReason = tbl.pReason or "NULL"
	
	
	self:SetTooltip( ([[
	%s: %s
	%s: %s]]):format(AWarn.Localization:GetTranslation( "presetname" ), self.pName, AWarn.Localization:GetTranslation( "presetreason" ), self.pReason ) )
end
function PANEL:Paint()
	
	if self.hovered == true then
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_HOVERED )
	else
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON )
	end
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
		
	surface.SetFont( "AWarn3Label2" )
	local text = self.pName
	local x = 10 * screenscale
	local y = 6 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
	surface.SetFont( "AWarn3CardText2" )
	local text = self.pReason
	local x = 10 * screenscale
	local y = 24 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )

end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
	self:AnimateThink()
end
function PANEL:AnimateThink()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self:GetWide(), 0.1 )
		local x, y = self:GetPos()
		local easeAmt = ( easingsX * -1 ) + self:GetWide()
		self:SetPos( easeAmt, y )
	else
		local x, y = self:GetPos()
		self.animating = false
	end
end
function PANEL:DrawElements( pl )
	local deleteButtonFrame = vgui.Create( "DPanel", self )
	deleteButtonFrame:SetWidth( 80 * screenscale )
	deleteButtonFrame:Dock( RIGHT )
	deleteButtonFrame.Paint = function()
	end

	local deleteButton = vgui.Create( "awarn3_iconbutton", deleteButtonFrame )
	deleteButton:SetTooltip("Delete Preset")
	deleteButton:SetSize(24 * screenscale, 24 * screenscale)
	deleteButton:SetIcon( deleteImage )
	deleteButton:SetPos( 10 * screenscale, 10 * screenscale )
	deleteButton.OnSelected = function()
		AWarn.Presets[ self.pName ] = nil
		self.hdiv:Remove()
		self:Remove()
		local cardNum = #AWarn.menu.configurationview.PresetsCardsPanel:GetCanvas():GetChildren()
		AWarn.menu.configurationview.PresetsCardsPanel:SetHeight( math.Clamp( ( 60 * screenscale ) * cardNum, 100, 300 ) )
		AWarn:SavePresets()
	end
end
function PANEL:OnMousePressed( key )
	if key == MOUSE_LEFT then
		AWarn.menu.configurationview.presetNameTxtBox:SetValue( self.pName )
		AWarn.menu.configurationview.presetValueTxtBox:SetValue( self.pReason )
	end
end
vgui.Register( "awarn3_presetcard", PANEL )

function AWarn:SavePresets()
	net.Start( "awarn3_networkpresets" )
	net.WriteString( "write" )
	net.WriteTable( AWarn.Presets )
	net.SendToServer()
end


local PANEL = {}
function PANEL:Init()
	local dockMargin = 4 * screenscale
	self:DockMargin( dockMargin, dockMargin, dockMargin, 0 )
	self:SetHeight( 55 * screenscale )
	self:Dock( TOP )
	
	self.hovered = false
	
	self.start = RealTime()
	self.stop = RealTime() + 0.1
	self.animating = true

	self.wNum = 0
	self.pType = "NULL"
	self.pLength = 0
	self.pMessage = ""
	self.sMessage = ""

end
function PANEL:SetInfo( tbl )
	self.wNum = tbl.warnings or 0
	self.pType = tbl.pType or "NULL"
	self.pLength = tbl.pLength or 0
	self.pMessage = tbl.pMessage or "NULL"
	self.sMessage = tbl.sMessage or "NULL"
	self.pGroup = tbl.pGroup or "NULL"
	self.pCommand = tbl.pCommand or "NULL"
	
	
	self:SetTooltip( ([[
	%s: %u     %s: %s     %s: %u
	%s: %s
	%s: %s]]):format(AWarn.Localization:GetTranslation( "warnings" ), self.wNum, AWarn.Localization:GetTranslation( "punishtype" ), self.pType, AWarn.Localization:GetTranslation( "punishlength" ), self.pLength, AWarn.Localization:GetTranslation( "playermessage" ), self.pMessage, AWarn.Localization:GetTranslation( "servermessage" ), self.sMessage) )
end
function PANEL:Paint()
	
	if self.hovered == true then
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_HOVERED )
	else
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON )
	end
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
		
	surface.SetFont( "AWarn3CardText2" )
	local text = AWarn.Localization:GetTranslation( "warnings" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	local x = 10 * screenscale
	local y = 6 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
		
	text = self.wNum 
	x = x + tW + 6 * screenscale
	y = y
	tW, tH = surface.GetTextSize( text )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
	
	text = AWarn.Localization:GetTranslation( "punishtype" ) .. ":"
	x = x + tW + 30 * screenscale
	y = y
	tW, tH = surface.GetTextSize( text )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
		
	text = self.pType
	x = x + tW + 6 * screenscale
	y = y
	tW, tH = surface.GetTextSize( text )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
	if self.pType == "ban" then

		text = AWarn.Localization:GetTranslation( "punishlength" ) .. ":"
		x = x + tW + 30 * screenscale
		y = y
		tW, tH = surface.GetTextSize( text )
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
			
		text = self.pLength
		x = x + tW + 6 * screenscale
		y = y
		tW, tH = surface.GetTextSize( text )
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
	
	end
	
	if self.pType == "group" then

		text = AWarn.Localization:GetTranslation( "punishgroup" ) .. ":"
		x = x + tW + 30 * screenscale
		y = y
		tW, tH = surface.GetTextSize( text )
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
			
		text = self.pGroup
		x = x + tW + 6 * screenscale
		y = y
		tW, tH = surface.GetTextSize( text )
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
	
	end
	
	if self.pType == "command" then

		text = AWarn.Localization:GetTranslation( "customcommand" ) .. ":"
		x = x + tW + 30 * screenscale
		y = y
		tW, tH = surface.GetTextSize( text )
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
			
		text = self.pCommand
		x = x + tW + 6 * screenscale
		y = y
		tW, tH = surface.GetTextSize( text )
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
	
	end
	
				
	local text = AWarn.Localization:GetTranslation( "playermessage" ) .. ":"
	local x = 10 * screenscale
	local y = 22 * screenscale
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
		
	text = self.pMessage
	x = x + tW + 6 * screenscale
	y = y
	tW, tH = surface.GetTextSize( text )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
			
	local text = AWarn.Localization:GetTranslation( "servermessage" ) .. ":"
	local x = 10 * screenscale
	local y = 38 * screenscale
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
		
	text = self.sMessage
	x = x + tW + 6 * screenscale
	y = y
	tW, tH = surface.GetTextSize( text )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )

end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
	self:AnimateThink()
end
function PANEL:AnimateThink()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self:GetWide(), 0.1 )
		local x, y = self:GetPos()
		local easeAmt = ( easingsX * -1 ) + self:GetWide()
		self:SetPos( easeAmt, y )
	else
		local x, y = self:GetPos()
		self.animating = false
	end
end
function PANEL:DrawElements( pl )
	local deleteButtonFrame = vgui.Create( "DPanel", self )
	deleteButtonFrame:SetWidth( 80 * screenscale )
	deleteButtonFrame:Dock( RIGHT )
	deleteButtonFrame.Paint = function()
	end

	local deleteButton = vgui.Create( "awarn3_iconbutton", deleteButtonFrame )
	deleteButton:SetTooltip("Delete Punishment")
	deleteButton:SetSize(24 * screenscale, 24 * screenscale)
	deleteButton:SetIcon( deleteImage )
	deleteButton:SetPos( 10 * screenscale, 12 * screenscale )
	deleteButton.OnSelected = function()
		AWarn.Punishments[ self.wNum ] = nil
		self.hdiv:Remove()
		self:Remove()
		local cardNum = #AWarn.menu.configurationview.PunishmentsCardsPanel:GetCanvas():GetChildren()
		AWarn.menu.configurationview.PunishmentsCardsPanel:SetHeight( math.Clamp( ( 60 * screenscale ) * cardNum, 100, 300 ) )
		AWarn:SavePunishments()
	end
end
function PANEL:OnMousePressed( key )
	--self.wNum = tbl.warnings or 0
	--self.pType = tbl.pType or "NULL"
	--self.pLength = tbl.pLength or 0
	--self.pMessage = tbl.pMessage or "NULL"
	--self.sMessage = tbl.sMessage or "NULL"
	if key == MOUSE_LEFT then
		AWarn.punishmentCreationFields.pActiveWarningsTxtBox:SetValue( self.wNum )
		AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:SetValue( self.pMessage )
		AWarn.punishmentCreationFields.pMessageToServerTxtBox:SetValue( self.sMessage )
		AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetValue( self.pLength )
		AWarn.punishmentCreationFields.pTypeDropdown:ChooseOptionID( table.KeyFromValue( AWarn.punishmentCreationFields.pTypeDropdown.Choices, string.SetChar( self.pType, 1, string.upper( string.Left( self.pType, 1 ) ) ) ) )
		if self.pType == "group" then
			AWarn.punishmentCreationFields.pPunishmentGroupDropdown:ChooseOptionID( table.KeyFromValue( AWarn.punishmentCreationFields.pPunishmentGroupDropdown.Choices, self.pGroup, 1 ) )
		end
		if self.pType == "command" then
			AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetValue( self.pCommand )
		end
	end
end
vgui.Register( "awarn3_punishmentcard", PANEL )

function AWarn:SavePunishments()
	net.Start( "awarn3_networkpunishments" )
	net.WriteString( "write" )
	net.WriteTable( AWarn.Punishments )
	net.SendToServer()
end



local PANEL = {}
function PANEL:Init()
	self.start = RealTime()
	self.stop = RealTime() + 0.5
	self.animating = true
	self:SetWide( ScrWM() * 0.25 )
	self:SetTall( ScrHM() * 0.28 )
	self.dX = ScrWM() / 2 - self:GetWide() / 2
	self.dY = ScrHM() / 2 - self:GetTall() / 2
	self:SetPos( ScrWM(), self.dY )
	self:DrawElements()
	self.animspeed = 30
	self:SetTitle( "" )
	self:ShowCloseButton( false )
	
	self.ptype = "kick"

end
function PANEL:Paint()
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
	surface.SetFont( "AWarn3Label2" )
	local text = AWarn.Localization:GetTranslation( "punishaddmenu" )
	local x = 12 * screenscale
	local y = 8 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
	surface.SetFont( "AWarn3CardText1" )
	
	local text = AWarn.Localization:GetTranslation( "warnings" ) .. ":"
	local x = 18 * screenscale
	local y = 35 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
	local text = AWarn.Localization:GetTranslation( "punishtype" ) .. ":"
	local x = 115 * screenscale
	local y = 35 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
	if self.ptype == "ban" then
		local text = AWarn.Localization:GetTranslation( "punishlength" ) .. ":"
		local x = 250 * screenscale
		local y = 35 * screenscale
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
		
		surface.SetFont( "AWarn3CardText2" )
		local text = "(" .. AWarn.Localization:GetTranslation( "inminutes" ) .. ")"
		local x = 318 * screenscale
		local y = 54 * screenscale
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
		
		local text = AWarn.Localization:GetTranslation( "0equalperma" )
		local x = 312 * screenscale
		local y = 65 * screenscale
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
		
		
		surface.SetFont( "AWarn3CardText1" )
		
	end
	
	local text = AWarn.Localization:GetTranslation( "messagetoplayer" ) .. ":"
	local x = 18 * screenscale
	local y = 85 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
	local text = AWarn.Localization:GetTranslation( "messagetoserver" ) .. ":"
	local x = 18 * screenscale
	local y = 130 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
	surface.SetFont( "AWarn3CardText2" )
	
	local text = AWarn.Localization:GetTranslation( "use%" ) .. ":"
	local x = 20 * screenscale
	local y = 172 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
	
	surface.SetFont( "AWarn3CardText1" )
	
end
function PANEL:Think()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self.dX + self:GetWide(), 0.5 )
		local x, y = self:GetPos()
		self:SetPos( ScrWM() + easingsX * -1, y )
	else
		local x, y = self:GetPos()
		self:SetPos( self.dX, y )
		self.animating = false
	end
end
function PANEL:DrawElements()
	local dockmargin = 6 * screenscale
		
	local closeButton = vgui.Create( "awarn3_iconbutton", self )
	closeButton:SetTooltip( AWarn.Localization:GetTranslation( "closemenu" ) )
	closeButton:SetSize(16 * screenscale, 16 * screenscale)
	closeButton:SetPos( self:GetWide() - closeButton:GetWide() - 6 * screenscale, 6 * screenscale )
	closeButton.OnSelected = function()
		self:Remove()
	end
	
	local x = 20 * screenscale
	
	local txtWarningNum = vgui.Create( "DTextEntry", self )
	txtWarningNum:SetPos( 20 * screenscale, 55 * screenscale)
	txtWarningNum:SetSize( 50 * screenscale, 20 * screenscale )
	txtWarningNum:SetText( "1" )
	txtWarningNum:SetNumeric( true )
	
	local comboBoxPunishType = vgui.Create( "DComboBox", self )
	comboBoxPunishType:SetPos( 117 * screenscale, 55 * screenscale )
	comboBoxPunishType:SetSize( 50 * screenscale, 20 * screenscale )
	comboBoxPunishType:SetValue( "Kick" )
	comboBoxPunishType:AddChoice( "Kick" )
	comboBoxPunishType:AddChoice( "Ban" )
	comboBoxPunishType:AddChoice( "Rank" )
	
	local txtPunishLen = vgui.Create( "DTextEntry", self )
	txtPunishLen:SetPos( 252 * screenscale, 55 * screenscale)
	txtPunishLen:SetSize( 50 * screenscale, 20 * screenscale )
	txtPunishLen:SetText( "1" )
	txtPunishLen:SetNumeric( true )
	txtPunishLen:SetVisible( false )
	comboBoxPunishType.OnSelect = function( self, index, value )
		if value == "Ban" then
			txtPunishLen:SetVisible( true )
			self:GetParent().ptype = "ban"
		else
			txtPunishLen:SetVisible( false )
			self:GetParent().ptype = "kick"
		end
	end
	
	local txtPlayerMessage = vgui.Create( "DTextEntry", self )
	txtPlayerMessage:SetPos( 20 * screenscale, 105 * screenscale)
	txtPlayerMessage:SetSize( self:GetWide() - 40, 20 * screenscale )
	
	local txtServerMessage = vgui.Create( "DTextEntry", self )
	txtServerMessage:SetPos( 20 * screenscale, 150 * screenscale)
	txtServerMessage:SetSize( self:GetWide() - 40, 20 * screenscale )
	
	
	local addPunishmentButton = vgui.Create( "awarn3_button", self )
	addPunishmentButton:SetText( AWarn.Localization:GetTranslation( "addpunishment" ) )
	addPunishmentButton:Dock( BOTTOM )
	addPunishmentButton:DockMargin( dockmargin, 0, dockmargin, dockmargin )
	addPunishmentButton.OnSelected = function()
		if txtPlayerMessage:GetValue() == "" or txtServerMessage:GetValue() == "" then return end
		AWarn.Punishments[ tonumber( txtWarningNum:GetValue() ) ] = { pType = comboBoxPunishType:GetValue():lower(), warnings = tonumber( txtWarningNum:GetValue() ), pMessage = txtPlayerMessage:GetValue(), sMessage = txtServerMessage:GetValue() }
		if comboBoxPunishType:GetValue() == "Ban" then
			AWarn.Punishments[ tonumber( txtWarningNum:GetValue() ) ].pLength = tonumber( txtPunishLen:GetValue() )
		end
		self:Remove()
		AWarn:RefreshPunishments()
		AWarn:SavePunishments()
	end
	
end
vgui.Register( "awarn3_addpunishmentdialog", PANEL, "DFrame" )


local PANEL = {}
function PANEL:Init()
	self.text = ""
	self:SetHeight( 30 )
	self.font = "AWarn3Label1"
	self.align = "left"
end
function PANEL:Paint()
	surface.SetFont( self.font )
	local tW, tH = surface.GetTextSize( self.text )
	local x = self:GetWide() / 2 - tW / 2
	if self.align == "left" then
		x = 4
	end
	local y = self:GetTall() / 2 - tH / 2
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( self.text )
end
function PANEL:SetFont( font )
	self.font = font
end
function PANEL:SetText( txt )
	self.text = txt
end
vgui.Register( "awarn3_configlabel", PANEL )



local PANEL = {}
function PANEL:Init()
	self:SetHeight( 10 * screenscale )
end
function PANEL:Paint()
	--Render Invisible
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_SECONDARY )
	surface.DrawRect( 3 * screenscale, self:GetTall() / 2 - 1 * screenscale, self:GetWide() - 6 * screenscale, 3 * screenscale )
end
vgui.Register( "awarn3_hdiv", PANEL )


local PANEL = {}
function PANEL:Init()
	self:SetWidth( 2 * screenscale )
end
function PANEL:Paint()
	--Render Invisible
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( self:GetWide() / 2 - 1 * screenscale, 2 * screenscale, 2 * screenscale, self:GetTall() - 74 * screenscale )
end
vgui.Register( "awarn3_vdiv", PANEL )



local PANEL = {}
function PANEL:Init()
	self.paused = true
	self.start = RealTime()
	self.stop = RealTime() + 0.5
	self.animating = true
	self:SetWide( 250 * screenscale )
	self:SetTall( 225 * screenscale )
	self:SetTitle( "" )
	self:ShowCloseButton( false )
	self.optionColor = nil
	self:DrawElements()
	self.parentbutton = nil
end
function PANEL:Paint()
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
		
	surface.SetFont( "AWarn3Label1" )
	local text = AWarn.Localization:GetTranslation( "colorselection" ) 
	local tW, tH = surface.GetTextSize( text )
	local x = self:GetWide() / 2 - tW / 2
	local y = 6 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( x, y )
	surface.DrawText( text )
end
function PANEL:SetOptionColor( col )
	self.optionColor = col
	self.Mixer:SetColor( AWarn.Colors[ col ] )
	self.paused = false
end
function PANEL:SetParentButton( pnl )
	self.parentbutton = pnl
end
function PANEL:Think()
	self:AnimatePanel()
	self:CheckClose()
end
function PANEL:CheckClose()
    if not input.IsMouseDown( MOUSE_LEFT ) then return end

    local x, y = self:GetPos()
    local mx, my = input.GetCursorPos()
    local w, h = self:GetSize()

    local minsX = x
    local maxsX = x + w
    local minsY = y
    local maxsY = y + h
	
    if mx < minsX or mx > maxsX then
        return self:Remove()
    end

    if my < minsY or my > maxsY then
        return self:Remove()
    end
end
function PANEL:AnimatePanel()
	if not self.animating then return end
	if RealTime() < self.stop then

	else
		self.animating = false
	end
end
function PANEL:DrawElements()
	local dockmargin = 6 * screenscale
	
	self.Mixer = vgui.Create( "DColorMixer", self )
	self.Mixer:Dock( TOP )
	self.Mixer:SetTall( 160 )
	self.Mixer:SetPalette( false )
	self.Mixer:SetAlphaBar( false )
	self.Mixer:SetWangs( true )
	self.Mixer:SetColor( Color( 30, 100, 160 ) )
	function self.Mixer:ValueChanged( col )
		if self:GetParent().paused then return end
		local nC = Color( col.r, col.g, col.b, AWarn.ColorsBackup[ self:GetParent().optionColor ].a )
		self:GetParent().parentbutton:SetColor( nC )
		AWarn.Colors[ self:GetParent().optionColor ] = nC
	end
		
	local warnButton = vgui.Create( "awarn3_button", self )
	warnButton:SetText( AWarn.Localization:GetTranslation( "setdefault" ) )
	warnButton:Dock( BOTTOM )
	warnButton:DockMargin( 0, 0, 0, 0 )
	warnButton:SetEnabled( true )
	warnButton.OnSelected = function()
		self.Mixer:SetColor( AWarn.ColorsBackup[ self.optionColor ] )
	end
end
vgui.Register( "awarn3_colorpicker", PANEL, "DFrame" )





local PANEL = {}
function PANEL:Init()
	self:Dock( FILL )
	self:DrawElements()
end
function PANEL:Paint()
	--Render Invisible
	surface.SetDrawColor( 200, 100, 100, 50 )
	--surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
end
function PANEL:DrawElements()

	local headerPanel = vgui.Create( "DPanel", self )
	headerPanel:SetHeight( 60 * screenscale )
	headerPanel:Dock( TOP )
	headerPanel:DockMargin( 8 * screenscale, 8 * screenscale, 8 * screenscale, 8 * screenscale )
	headerPanel.Paint = function()	
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, headerPanel:GetWide() - 3 * screenscale, headerPanel:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( headerPanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, headerPanel:GetTall() - 1 )
		surface.DrawRect( 0, headerPanel:GetTall() - 3 * screenscale, headerPanel:GetWide() - 3 * screenscale, 3 * screenscale )
			
		surface.SetFont( "AWarn3Label1" )
		local text = AWarn.Localization:GetTranslation( "showingownwarnings" )
		local tW, tH = surface.GetTextSize( text )
		local x = headerPanel:GetWide() / 2 - tW / 2
		local y = headerPanel:GetTall() / 2 - tH / 2
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( text )
		
		
						
		surface.SetDrawColor( AWarn.Colors.COLOR_RED_BUTTON )
		surface.SetMaterial( activeWarnings )
		surface.DrawTexturedRect( headerPanel:GetWide() - 60 * screenscale , headerPanel:GetTall() - 26 * screenscale, 16 * screenscale, 16 * screenscale )
				
		surface.SetFont( "AWarn3Label1" )
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
		local text = LocalPlayer():GetActiveWarnings()
		surface.SetTextPos( headerPanel:GetWide() - 40 * screenscale, headerPanel:GetTall() - 27 * screenscale )
		surface.DrawText( text )
	end

	self.WarningCardsPanel = vgui.Create( "DScrollPanel", self )
	self.WarningCardsPanel:Dock( FILL )
	self.WarningCardsPanel:DockMargin( 8 * screenscale, 0 * screenscale, 8 * screenscale, 75 * screenscale )
	self.WarningCardsPanel:GetCanvas():DockPadding( 0, 0, 0, 6 * screenscale )
	self.WarningCardsPanel.Paint = function()	
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, self.WarningCardsPanel:GetWide() - 3 * screenscale, self.WarningCardsPanel:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( self.WarningCardsPanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, self.WarningCardsPanel:GetTall() - 1 )
		surface.DrawRect( 0, self.WarningCardsPanel:GetTall() - 3 * screenscale, self.WarningCardsPanel:GetWide() - 3 * screenscale, 3 * screenscale )
	end
	
	local ScrollBar = self.WarningCardsPanel:GetVBar()
	ScrollBar:SetHideButtons( true )
	ScrollBar:SetWidth( 6 * screenscale )
	function ScrollBar:Paint( w, h )
		surface.SetDrawColor( 0, 0, 0, 0 )
		surface.DrawRect( 0, 0, w, h )
	end
	function ScrollBar.btnGrip:Paint( w, h )
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( 0, 0, w, h )
	end
	
end
vgui.Register( "awarn3_selfwarningsview", PANEL )


function AWarn:AddSelfWarningCard( tbl )
	if not IsValid( self.menu ) then return end
	if not IsValid( self.menu.selfWarningsView ) then return end
	if not IsValid( self.menu.selfWarningsView.WarningCardsPanel ) then return end

	local warningCard = vgui.Create( "awarn3_selfwarningcard" )
	self.menu.selfWarningsView.WarningCardsPanel:AddItem( warningCard )
	warningCard:Dock( TOP )
	warningCard:SetInfo( tbl )	
	
	warningCard.hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	warningCard.hdiv:Dock( TOP )
	self.menu.selfWarningsView.WarningCardsPanel:AddItem( warningCard.hdiv )
	
end

net.Receive( "awarn3_requestownwarnings", function()
	local warningsTable = net.ReadTable()
	AWarn:PopulateOwnWarnings( warningsTable )	
end )

function AWarn:PopulateOwnWarnings( tbl )

	if not IsValid( self.menu ) then return end
	if not IsValid( self.menu.selfWarningsView ) then return end
	if not IsValid( self.menu.selfWarningsView.WarningCardsPanel ) then return end
	self.menu.selfWarningsView.WarningCardsPanel:Clear()
	
	for k, v in pairs( tbl ) do
		timer.Simple( k * 0.1, function()
			AWarn:AddSelfWarningCard( v )
		end )
	end

end

function AWarn:RequestOwnWarnings()
	net.Start("awarn3_requestownwarnings")
	net.SendToServer()
end


local PANEL = {}
function PANEL:Init()
	local dockMargin = 4 * screenscale
	self:DockMargin( dockMargin, dockMargin, dockMargin, 0 )
	self:SetHeight( 60 * screenscale )
	self:Dock( TOP )
	self.hovered = false
	self.buttonEnabled = false
	self.warninginfotbl = {}
	
	self.start = RealTime()
	self.stop = RealTime() + 0.25
	self.animating = true
	
	self.dX, self.dY = self:GetPos()
end
function PANEL:Paint()
	
	if self.hovered == true then
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_HOVERED )
	else
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON )
	end
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
	if self.buttonEnabled then
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( self:GetWide() - 10 * screenscale, 0, 8 * screenscale, self:GetTall() )
	end
		
	surface.SetFont( "AWarn3CardText1" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	
	local x = 110 * screenscale
	
	local text = AWarn.Localization:GetTranslation( "warnedby" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x - tW, 6 * screenscale )
	surface.DrawText( text )
	
	local text = AWarn.Localization:GetTranslation( "warningserver" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x - tW, 22 * screenscale )
	surface.DrawText( text )	
	
	local text = AWarn.Localization:GetTranslation( "warningreason" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x - tW, 38 * screenscale )
	surface.DrawText( text )
	
	local x = 800 * screenscale
	
	local text = AWarn.Localization:GetTranslation( "warningdate" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x - tW, 6 * screenscale )
	surface.DrawText( text )	
	
	
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	
	local x = 115 * screenscale
	
	local text = self.warninginfotbl.PlayerName or AWarn.Localization:GetTranslation( "nothing" )
	surface.SetTextPos( x , 6 * screenscale )
	surface.DrawText( text )	
	
	local text = self.warninginfotbl.WarningServer or AWarn.Localization:GetTranslation( "nothing" )
	surface.SetTextPos( x , 22 * screenscale )
	surface.DrawText( text )	
	
	local text = self.warninginfotbl.WarningReason or AWarn.Localization:GetTranslation( "nothing" )
	surface.SetTextPos( x , 38 * screenscale )
	surface.DrawText( text )
	
	local x = 805 * screenscale
	
	local text = os.date( "%d/%m/%Y %H:%M:%S" , self.warninginfotbl.WarningDate or 111111111 )
	surface.SetTextPos( x , 6 * screenscale )
	surface.DrawText( text )
	
	
end
function PANEL:SetEnabled( bool )
	self.buttonEnabled = bool
end
function PANEL:SetInfo( tbl )
	self.warninginfotbl = tbl
end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
	self:AnimateThink()
end
function PANEL:AnimateThink()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self:GetWide(), 0.25 )
		local x, y = self:GetPos()
		local easeAmt = ( easingsX * -1 ) + self:GetWide()
		self:SetPos( easeAmt, y )
	else
		local x, y = self:GetPos()
		self.animating = false
	end
end
vgui.Register( "awarn3_selfwarningcard", PANEL )



local PANEL = {}
function PANEL:Init()
	self:Dock( FILL )
	self:DrawElements()
	self.selectedplayer = nil
	self.selectedplayerid = nil
	self.selectedplayerwarns = 0
end
function PANEL:Paint()
	--Render Invisible
	--surface.SetDrawColor( 200, 100, 100, 200 )
	--surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
end
function PANEL:DrawElements()


	local PlayerListDockPanel = vgui.Create( "DPanel", self )
	PlayerListDockPanel:SetWide( 200 * screenscale )
	PlayerListDockPanel:Dock( RIGHT )
	PlayerListDockPanel:DockMargin( 0, 8 * screenscale, 5 * screenscale, 76 * screenscale )
	PlayerListDockPanel:DockPadding( 4 * screenscale, 30 * screenscale, 4 * screenscale, 4 * screenscale )
	PlayerListDockPanel.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, PlayerListDockPanel:GetWide() - 3 * screenscale, PlayerListDockPanel:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( PlayerListDockPanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, PlayerListDockPanel:GetTall() - 1 )
		surface.DrawRect( 0, PlayerListDockPanel:GetTall() - 3 * screenscale, PlayerListDockPanel:GetWide() - 3 * screenscale, 3 * screenscale )
			
		surface.SetFont( "AWarn3Label2" )
		local tW, tH = surface.GetTextSize( AWarn.Localization:GetTranslation( "connectedplayers" ) )
		local x = PlayerListDockPanel:GetWide() - ( 200 * screenscale / 2 ) - tW / 2
		local y = 8 * screenscale
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( AWarn.Localization:GetTranslation( "connectedplayers" ) )
	end

	self.PlayerListPanel = vgui.Create( "DScrollPanel", PlayerListDockPanel )
	self.PlayerListPanel:Dock( FILL )
	self.PlayerListPanel:DockMargin( 0, 0, 0, 10 * screenscale )
	self.PlayerListPanel:GetCanvas():DockPadding( 0, 0, 0, 6 * screenscale )
	self.PlayerListPanel.Paint = function()
		surface.SetDrawColor( 200, 200, 200, 0 )
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	
	local warnButton = vgui.Create( "awarn3_button", PlayerListDockPanel )
	warnButton:SetText(AWarn.Localization:GetTranslation( "warnplayer" ))
	warnButton:Dock( BOTTOM )
	--warnButton.buttoncoloroverride = Color( 120, 0, 0, 200 )
	--warnButton.buttoncolorhoveroverride = Color( 140, 20, 20, 200 )
	warnButton:SetEnabled( false )
	warnButton.PostThink = function()
		if not warnButton.enabled then 
			if self.selectedplayer then warnButton:SetEnabled( true ) end
		end
	end
	warnButton.OnSelected = function()
		if IsValid( AWarn.menu.playerwarndialogue ) then AWarn.menu.playerwarndialogue:Remove() end
		AWarn.menu.playerwarndialogue = vgui.Create( "awarn3_warndialogue" )
		AWarn.menu.playerwarndialogue:MakePopup()
		AWarn.menu.playerwarndialogue:SetParent( AWarn.menu )
		AWarn.menu.playerwarndialogue:SetPlayer( self.selectedplayerid )
		AWarn.menu.playerwarndialogue:SetPlayerName( self.selectedplayer )
	end
	
	timer.Simple( 0, function() AWarn:PopulatePlayers() end ) --This needs to run in the next frame.
	
	local ScrollBar = self.PlayerListPanel:GetVBar()
	ScrollBar:SetHideButtons( true )
	ScrollBar:SetWidth( 6 * screenscale )
	function ScrollBar:Paint( w, h )
		surface.SetDrawColor( 0, 0, 0, 0 )
		surface.DrawRect( 0, 0, w, h )
	end
	function ScrollBar.btnGrip:Paint( w, h )
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( 0, 0, w, h )
	end
	
	local playerInfoPanel = vgui.Create( "DPanel", self )
	playerInfoPanel:SetHeight( 100 * screenscale )
	playerInfoPanel:Dock( TOP )
	playerInfoPanel:DockMargin( 8 * screenscale, 8 * screenscale, 5 * screenscale, 0 )
	playerInfoPanel:DockPadding( 4 * screenscale, 30 * screenscale, 4 * screenscale, 4 * screenscale )
	playerInfoPanel.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, playerInfoPanel:GetWide() - 3 * screenscale, playerInfoPanel:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( playerInfoPanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, playerInfoPanel:GetTall() - 1 )
		surface.DrawRect( 0, playerInfoPanel:GetTall() - 3 * screenscale, playerInfoPanel:GetWide() - 3 * screenscale, 3 * screenscale )
		
		if AWarn.menu.adminWarningsView.selectedplayer then
			surface.SetFont( "AWarn3Label1" )
			surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
			local text = self.selectedplayer
			surface.SetTextPos( 120 * screenscale, 26 * screenscale )
			surface.DrawText( text )
			
			surface.SetFont( "AWarn3Label3" )
			local text = self.selectedplayerid
			surface.SetTextPos( 120 * screenscale, 48 * screenscale )
			surface.DrawText( text )
			
			local text = util.SteamIDFrom64( self.selectedplayerid )
			surface.SetTextPos( 120 * screenscale, 62 * screenscale )
			surface.DrawText( text )
						
			surface.SetDrawColor( AWarn.Colors.COLOR_RED_BUTTON )
			surface.SetMaterial( activeWarnings )
			surface.DrawTexturedRect( playerInfoPanel:GetWide() - 80 * screenscale , playerInfoPanel:GetTall() - 26 * screenscale, 16 * screenscale, 16 * screenscale )
					
			surface.SetFont( "AWarn3Label1" )
			surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
			local text = self.selectedplayerwarns
			surface.SetTextPos( playerInfoPanel:GetWide() - 52 * screenscale, playerInfoPanel:GetTall() - 27 * screenscale )
			surface.DrawText( text )	
		else
			surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
			surface.SetFont( "AWarn3Label1" )
			local text = AWarn.Localization:GetTranslation( "selectplayerseewarnings" )
			local tW, tH = surface.GetTextSize( text )
			surface.SetTextPos( playerInfoPanel:GetWide() / 2 - tW / 2, playerInfoPanel:GetTall() / 2 - tH / 2 )
			surface.DrawText( text )
		end
	end
	
	self.PlayerInfoAvatar = vgui.Create("AWEnhancedAvatarImage", playerInfoPanel)
	self.PlayerInfoAvatar:SetPos( playerInfoPanel:GetTall() / 2 - 40 * screenscale, playerInfoPanel:GetTall() / 2 - 40 * screenscale)
	self.PlayerInfoAvatar:SetVertices( 64 )
	self.PlayerInfoAvatar:SetSize(80 * screenscale, 80 * screenscale)
	
	self.WarningCardsPanel = vgui.Create( "DScrollPanel", self )
	self.WarningCardsPanel:Dock( FILL )
	self.WarningCardsPanel:DockMargin( 8 * screenscale, 5 * screenscale, 5 * screenscale, 76 * screenscale )
	self.WarningCardsPanel:GetCanvas():DockPadding( 0, 0, 0, 6 * screenscale )
	self.WarningCardsPanel.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, self.WarningCardsPanel:GetWide() - 3 * screenscale, self.WarningCardsPanel:GetTall() - 3 * screenscale )
		
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( self.WarningCardsPanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, self.WarningCardsPanel:GetTall() - 1 )
		surface.DrawRect( 0, self.WarningCardsPanel:GetTall() - 3 * screenscale, self.WarningCardsPanel:GetWide() - 3 * screenscale, 3 * screenscale )	
		
		if AWarn.menu.adminWarningsView.selectedplayer then	
			
			if AWarn.menu.adminWarningsView.WarningCardsPanel:GetCanvas():ChildCount() == 0 then
				surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
				surface.SetFont( "AWarn3Label1" )
				local text = AWarn.Localization:GetTranslation( "selectedplayernowarnings" )
				local tW, tH = surface.GetTextSize( text )
				local x = AWarn.menu.adminWarningsView.WarningCardsPanel:GetWide() / 2 - tW / 2
				surface.SetTextPos( x, 40 * screenscale )
				surface.DrawText( text )
			end
		
		end
		
	end
	
	local ScrollBar = self.WarningCardsPanel:GetVBar()
	ScrollBar:SetHideButtons( true )
	ScrollBar:SetWidth( 6 * screenscale )
	function ScrollBar:Paint( w, h )
		surface.SetDrawColor( 0, 0, 0, 0 )
		surface.DrawRect( 0, 0, w, h )
	end
	function ScrollBar.btnGrip:Paint( w, h )
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( 0, 0, w, h )
	end
		
	self.subWarningButton = vgui.Create( "awarn3_iconbutton", playerInfoPanel )
	self.subWarningButton:SetTooltip(AWarn.Localization:GetTranslation( "reduceactiveby1" ))
	self.subWarningButton:SetSize(12 * screenscale, 12 * screenscale)
	self.subWarningButton:SetPos( 874 * screenscale, playerInfoPanel:GetTall() - 25 * screenscale )
	self.subWarningButton:SetIcon( minusImage )
	self.subWarningButton:SetVisible( false )
	self.subWarningButton.OnSelected = function()
		if tonumber(self.selectedplayerwarns) > 0 then
			AWarn:AddActiveWarning( self.selectedplayerid, -1 )
			self.selectedplayerwarns = self.selectedplayerwarns - 1
		end
	end
	
	self.deleteWarningButton2 = vgui.Create( "awarn3_button", playerInfoPanel )
	self.deleteWarningButton2:SetText("Delete All Warnings")
	self.deleteWarningButton2:SetSize(140 * screenscale, 20 * screenscale)
	self.deleteWarningButton2:SetPos( 755 * screenscale, 8 * screenscale )
	self.deleteWarningButton2.buttoncoloroverride = Color( 120, 0, 0, 200 )
	self.deleteWarningButton2.buttoncolorhoveroverride = Color( 140, 20, 20, 200 )
	self.deleteWarningButton2:SetEnabled( true )
	self.deleteWarningButton2:SetVisible( false )
	self.deleteWarningButton2.OnSelected = function()    
		if IsValid( AWarn.menu.deletewarningsconfirmation ) then AWarn.menu.deletewarningsconfirmation:Remove() end
		AWarn.menu.deletewarningsconfirmation = vgui.Create( "awarn3_deletewarningsconfirmation" )
		AWarn.menu.deletewarningsconfirmation:MakePopup()
		AWarn.menu.deletewarningsconfirmation:SetParent( AWarn.menu )
		AWarn.menu.deletewarningsconfirmation:SetPlayer( self.selectedplayerid )
		AWarn.menu.deletewarningsconfirmation:SetPlayerName( self.selectedplayer )
		AWarn.menu.deletewarningsconfirmation.PlayerInfoAvatar:SetSteamID( self.selectedplayerid, 184)
    
	end
	self.deleteWarningButton2:SetTooltip(
		[[Delete ALL warnings for player.
		This completely deletes their entire warning history.]]
	)

		
	self.playerNotesButton = vgui.Create( "awarn3_iconbutton", playerInfoPanel )
	self.playerNotesButton:SetTooltip(AWarn.Localization:GetTranslation( "viewnotes" ))
	self.playerNotesButton:SetSize(16 * screenscale, 16 * screenscale)
	self.playerNotesButton:SetPos( 80 * screenscale, 8 * screenscale )
	self.playerNotesButton:SetIcon( playerNotes )
	self.playerNotesButton:SetVisible( false )
	self.playerNotesButton:SetIconColor( Color(0,128,255,255), Color(0,128,255,180) )
	self.playerNotesButton.OnSelected = function()
		if IsValid( AWarn.menu.playernotesdialogue ) then AWarn.menu.playernotesdialogue:Remove() end
		AWarn.menu.playernotesdialogue = vgui.Create( "awarn3_playernotesdialogue" )
		AWarn.menu.playernotesdialogue:MakePopup()
		AWarn.menu.playernotesdialogue:SetParent( AWarn.menu )
		AWarn.menu.playernotesdialogue:SetPlayer( self.selectedplayerid )
		AWarn.menu.playernotesdialogue:SetPlayerName( self.selectedplayer )
		AWarn.menu.playernotesdialogue.PlayerInfoAvatar:SetSteamID( self.selectedplayerid, 184)
		AWarn.menu.playernotesdialogue:RequestNotes( self.selectedplayerid )
	end
end
vgui.Register( "awarn3_adminwarningsview", PANEL )

function ReturnSortedPlayerTable()	
	local playerinfo = {}
	local playertable = {}
	
	for _, pl in pairs( player.GetAll() ) do
		playerinfo = { Name = pl:GetName(), Entity = pl }
		table.insert( playertable, playerinfo )
	end
	
	table.SortByMember(playertable, "Name", function(a, b) return a > b end)
	return playertable
end

function AWarn:PopulatePlayers()

	for k, v in SortedPairs( ReturnSortedPlayerTable() ) do
		AWarn:AddPlayerCard( v.Entity )
	end
end

function AWarn:AddPlayerCard( pl )
	if not IsValid( self.menu ) then return end
	if not IsValid( self.menu.adminWarningsView ) then return end
	if not IsValid( self.menu.adminWarningsView.PlayerListPanel ) then return end
	
	if not IsValid( pl ) then return end
	
	local PButton = vgui.Create( "awarn3_playerbutton" )
	self.menu.adminWarningsView.PlayerListPanel:AddItem( PButton )
	PButton:SetText( pl:GetName() )
	PButton:Dock( TOP )
	PButton:DrawElements( pl )
	PButton:SetPlayerID( AWarn:SteamID64( pl ) )
end

function AWarn:RemovePlayerCard( id )
	if not IsValid( self.menu ) then return end
	if not IsValid( self.menu.adminWarningsView ) then return end
	if not IsValid( self.menu.adminWarningsView.PlayerListPanel ) then return end
	
	for k, v in pairs( self.menu.adminWarningsView.PlayerListPanel:GetCanvas():GetChildren() ) do
		if v.playerid == id then v:Remove() end
	end
end

net.Receive( "awarn3_playerjoinandleave", function()
	local state = net.ReadString()
	
	if state == "join" then
		local pl = net.ReadEntity()
		AWarn:AddPlayerCard( pl )
	elseif state == "leave" then
		local id = net.ReadString()
		AWarn:RemovePlayerCard( id )
	end
end )

function AWarn:PopulatePlayerWarnings( tbl )

	if not IsValid( self.menu ) then return end
	if not IsValid( self.menu.adminWarningsView ) then return end
	if not IsValid( self.menu.adminWarningsView.WarningCardsPanel ) then return end
	self.menu.adminWarningsView.WarningCardsPanel:Clear()
	
	for k, v in pairs( tbl ) do
		timer.Simple( k * 0.1, function()
			AWarn:AddWarningCard( v )
		end )
	end

end

function AWarn:AddWarningCard( tbl )

	if not IsValid( self.menu ) then return end
	if not IsValid( self.menu.adminWarningsView ) then return end
	if not IsValid( self.menu.adminWarningsView.WarningCardsPanel ) then return end

	local warningCard = vgui.Create( "awarn3_adminwarningcard" )
	self.menu.adminWarningsView.WarningCardsPanel:AddItem( warningCard )
	warningCard:Dock( TOP )
	warningCard:SetInfo( tbl )
	warningCard:DrawElements()
	
	warningCard.hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	warningCard.hdiv:Dock( TOP )
	self.menu.adminWarningsView.WarningCardsPanel:AddItem(warningCard.hdiv)
	
end

net.Receive( "awarn3_requestplayerwarnings", function()
	local netType = net.ReadString()
	
	if netType == "warnings" then
		local warningsTable = net.ReadTable()
		AWarn:PopulatePlayerWarnings( warningsTable )
	elseif netType == "info" then
		local infoTable = net.ReadTable()
		if not IsValid( AWarn.menu ) then return end
		if not IsValid( AWarn.menu.adminWarningsView ) then return end
		if #infoTable == 1 then
			AWarn.menu.adminWarningsView.selectedplayer = infoTable[1].PlayerName
			AWarn.menu.adminWarningsView.selectedplayerwarns = infoTable[1].PlayerWarnings
			AWarn.menu.adminWarningsView.selectedplayerlastwarn = infoTable[1].LastWarning
		else
			AWarn.menu.adminWarningsView.selectedplayerwarns = 0
			AWarn.menu.adminWarningsView.selectedplayerlastwarn = "N/A"
		end
	end
	
end )


local PANEL = {}
function PANEL:Init()
	local dockMargin = 4 * screenscale
	self:DockMargin( 4 * screenscale, 4 * screenscale, 7 * screenscale, 0 )
	self:SetHeight( 60 * screenscale )
	self:Dock( TOP )
	self.hovered = false
	self.buttonEnabled = false
	self.warninginfotbl = {}
	
	self:DrawElements()
	
	
	self.start = RealTime()
	self.stop = RealTime() + 0.25
	self.animating = true
	
	self.dX, self.dY = self:GetPos()
end
function PANEL:Paint()
	
	if self.hovered == true then
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_HOVERED )
	else
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON )
	end
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
	if self.buttonEnabled then
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( self:GetWide() - 10 * screenscale, 0, 8 * screenscale, self:GetTall() )
	end
		
	surface.SetFont( "AWarn3CardText1" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	
	
	local l, _ = surface.GetTextSize( AWarn.Localization:GetTranslation( "warnedby" ) .. ":" )
	local l2, _ = surface.GetTextSize( AWarn.Localization:GetTranslation( "warningserver" ) .. ":" )
	local l3, _ = surface.GetTextSize( AWarn.Localization:GetTranslation( "warningreason`" ) .. ":" )
	
	local x = l
	if l2 > x then x = l2 end
	if l3 > x then x = l3 end
	
	
	x = x + 15 * screenscale
	--local x = 110 * screenscale
	
	local text = AWarn.Localization:GetTranslation( "warnedby" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x - tW, 6 * screenscale )
	surface.DrawText( text )
	
	local text = AWarn.Localization:GetTranslation( "warningserver" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x - tW, 22 * screenscale )
	surface.DrawText( text )	
	
	local text = AWarn.Localization:GetTranslation( "warningreason" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x - tW, 38 * screenscale )
	surface.DrawText( text )
	
	local x2 = 700 * screenscale
	
	local text = AWarn.Localization:GetTranslation( "warningdate" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x2 - tW, 6 * screenscale )
	surface.DrawText( text )	
	
	
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	
	local x = x + 5 * screenscale
	
	local text = self.warninginfotbl.PlayerName or AWarn.Localization:GetTranslation( "nothing" )
	surface.SetTextPos( x , 6 * screenscale )
	surface.DrawText( text )	
	
	local text = self.warninginfotbl.WarningServer or AWarn.Localization:GetTranslation( "nothing" )
	surface.SetTextPos( x , 22 * screenscale )
	surface.DrawText( text )	
	
	local text = self.warninginfotbl.WarningReason or AWarn.Localization:GetTranslation( "nothing" )
	surface.SetTextPos( x , 38 * screenscale )
	surface.DrawText( text )
	
	local x = 705 * screenscale
	
	local text = os.date( "%d/%m/%Y %H:%M:%S" , self.warninginfotbl.WarningDate or 111111111 )
	surface.SetTextPos( x , 6 * screenscale )
	surface.DrawText( text )
	
	
end
function PANEL:SetEnabled( bool )
	self.buttonEnabled = bool
end
function PANEL:SetInfo( tbl )
	self.warninginfotbl = tbl
end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
	self:AnimateThink()
end
function PANEL:AnimateThink()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self:GetWide(), 0.25 )
		local x, y = self:GetPos()
		local easeAmt = ( easingsX * -1 ) + self:GetWide()
		self:SetPos( easeAmt, y )
	else
		local x, y = self:GetPos()
		self.animating = false
	end
end
function PANEL:DrawElements( pl )
	local deleteButton = vgui.Create( "awarn3_iconbutton", self )
	deleteButton:SetTooltip(AWarn.Localization:GetTranslation( "deletewarning" ))
	deleteButton:SetIcon( deleteImage )
	deleteButton:SetSize(16 * screenscale, 16 * screenscale)
	deleteButton:SetPos( self:GetParent():GetWide() - deleteButton:GetWide() - 14 * screenscale, 6 * screenscale )
	deleteButton.OnSelected = function()
    if AWarn.Options.awarn_removewhendeletewarning.value then
      if tonumber(AWarn.menu.adminWarningsView.selectedplayerwarns) > 0 then
        AWarn:AddActiveWarning( AWarn.menu.adminWarningsView.selectedplayerid, -1 )      
        AWarn.menu.adminWarningsView.selectedplayerwarns = AWarn.menu.adminWarningsView.selectedplayerwarns - 1
      end
    end
		AWarn:DeleteSingleWarning( self.warninginfotbl.WarningID, pl )
		self.hdiv:Remove()
		self:Remove()
	end
end
function PANEL:OnMousePressed( key )
	if key == MOUSE_RIGHT then
	
	end
end
vgui.Register( "awarn3_adminwarningcard", PANEL )




function AWarn:DeleteSingleWarning( warningID, pl )
	net.Start( "awarn3_deletesinglewarning" )
	net.WriteInt( warningID, 32 )
	net.SendToServer()
   
end




local PANEL = {}
function PANEL:Init()
	local dockMargin = 4 * screenscale
	self:DockMargin( 0, dockMargin, dockMargin, 0 )
	self:SetHeight( 24 * screenscale )
	self:Dock( TOP )
	self.buttonLabel = AWarn.Localization:GetTranslation( "playername" )
	self.playerid = 0
	self.buttonEnabled = false
	self.hovered = false
end
function PANEL:Paint()
	
	if self.hovered == true then
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_HOVERED )
	else
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON )
	end
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
	if self.buttonEnabled then
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( self:GetWide() - 10 * screenscale, 0, 8 * screenscale, self:GetTall() )
	end
	
	surface.SetFont( "AWarn3NavButton" )
	local tW, tH = surface.GetTextSize( self.buttonLabel or "" )
	
	surface.SetTextColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	surface.SetTextPos( 30 * screenscale, ( self:GetTall() / 2 ) - tH / 2 )
	surface.DrawText( self.buttonLabel )
end
function PANEL:SetText( txt )
	self.buttonLabel = txt
end
function PANEL:SetPlayerID( id )
	self.playerid = id
end
function PANEL:SetEnabled( bool )
	self.buttonEnabled = bool
end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
end
function PANEL:DrawElements( pl )
	self.Avatar = vgui.Create( "AvatarImage", self )
	self.Avatar:SetSize( 20 * screenscale, 20 * screenscale )
	self.Avatar:SetPos( 2 * screenscale, 2 * screenscale )
	self.Avatar:SetPlayer( pl, 16 * screenscale )
end
function PANEL:OnMousePressed( key )
	if key == MOUSE_LEFT then
		if IsValid( AWarn.lastSelectedPlayerButton ) then AWarn.lastSelectedPlayerButton:SetEnabled( false ) end
		self:SetEnabled( true )
		AWarn.lastSelectedPlayerButton = self
		AWarn:RequestWarningsForPlayer( self.playerid )
		if string.Left(tostring(self.playerid), 3) == "Bot" then
			AWarn.menu.adminWarningsView.PlayerInfoAvatar:SetPlayer(Entity(0))
		else
			AWarn.menu.adminWarningsView.PlayerInfoAvatar:SetSteamID(tostring(self.playerid), 184)	
		end
		AWarn.menu.adminWarningsView.selectedplayerid = self.playerid
		AWarn.menu.adminWarningsView.subWarningButton:SetVisible( true )
		AWarn.menu.adminWarningsView.deleteWarningButton2:SetVisible( true )
		AWarn.menu.adminWarningsView.playerNotesButton:SetVisible( true )
	end
end
vgui.Register( "awarn3_playerbutton", PANEL )

function AWarn:RequestWarningsForPlayer( PlayerID )
	net.Start( "awarn3_requestplayerwarnings" )
	net.WriteString( PlayerID or "BOT" )
	net.SendToServer()
end

function AWarn:UnselectPlayer()

	AWarn.menu.adminWarningsView.selectedplayer = nil
	AWarn.menu.adminWarningsView.selectedplayerwarns = 0
	AWarn.menu.adminWarningsView.selectedplayerid = nil
	AWarn.menu.adminWarningsView.subWarningButton:SetVisible( false )
	AWarn.menu.adminWarningsView.deleteWarningButton2:SetVisible( false )
	AWarn.menu.adminWarningsView.playerNotesButton:SetVisible( false )
	if IsValid( AWarn.lastSelectedPlayerButton ) then AWarn.lastSelectedPlayerButton:SetEnabled( false ) end
	AWarn.lastSelectedPlayerButton = nil
	AWarn.menu.adminWarningsView.WarningCardsPanel:Clear()
end





local PANEL = {}
function PANEL:Init()
	local dockMargin = 4 * screenscale
	self:DockMargin( 0, dockMargin, dockMargin, dockMargin )
	self:SetHeight( 24 * screenscale )
	self.buttonLabel = "DEFAULT"
	self.hovered = false
	self.buttoncoloroverride = nil
	self.buttoncolorhoveroverride = nil
	self.buttoncolordisabledoverride = nil
	self.enabled = true
end
function PANEL:Paint()
	if self.enabled then
		if self.hovered == true then
			surface.SetDrawColor( self.buttoncolorhoveroverride or AWarn.Colors.COLOR_BUTTON_2_HOVERED )
		else
			surface.SetDrawColor( self.buttoncoloroverride or AWarn.Colors.COLOR_BUTTON_2 )
		end
	else
		surface.SetDrawColor( self.buttoncolordisabledoverride or AWarn.Colors.COLOR_BUTTON_DISABLED )
	end
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
	surface.SetFont( "AWarn3NavButton3" )
	local tW, tH = surface.GetTextSize( self.buttonLabel or "" )
	
	surface.SetTextColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	surface.SetTextPos( ( self:GetWide() / 2 ) - tW / 2, ( self:GetTall() / 2 ) - tH / 2 )
	surface.DrawText( self.buttonLabel )
end
function PANEL:SetText( txt )
	self.buttonLabel = txt
end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
	self:PostThink()
end
function PANEL:PostThink()

end
function PANEL:SetEnabled( enabled )
	self.enabled = enabled
end
function PANEL:OnSelected()
end
function PANEL:OnMousePressed( key )
	if key == MOUSE_LEFT then
		if not self.enabled then return end
		self:OnSelected()
	end
end
vgui.Register( "awarn3_button", PANEL )


local PANEL = {}
function PANEL:Init()
	local dockMarginX = 5 * screenscale
	local dockMarginY = 3 * screenscale
	self:SetHeight( 64 * screenscale )
	self:DockMargin( dockMarginX, 0, dockMarginX, dockMarginY * 2 )
	self:Dock( TOP )
	self:DrawElements()
	self.buttonLabel = "This is a test"
	self.buttonEnabled = false
	self.hovered = false
	self.iconsize = 24
end
function PANEL:Paint()
	local bColor
	if self.buttonEnabled then
		bColor = AWarn.Colors.COLOR_BUTTON_SELECTED
	else
		if self.hovered == true then
			bColor = AWarn.Colors.COLOR_BUTTON_HOVERED
		else
			bColor = AWarn.Colors.COLOR_BUTTON
		end
	end
	
	draw.RoundedBox( 16, 0, 0, self:GetWide(), self:GetTall(), bColor)	
		
	surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	surface.SetMaterial( self.icon )
	surface.DrawTexturedRect( self:GetWide() / 2 - self.iconsize * screenscale / 2, self:GetTall() / 2 - self.iconsize * screenscale / 2, self.iconsize * screenscale, self.iconsize * screenscale )
		
	surface.SetFont( "AWarn3NavButton" )
	local tW, tH = surface.GetTextSize( self.buttonLabel or "" )
	
	surface.SetTextColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	surface.SetTextPos( self:GetWide() / 2 - tW / 2, self:GetTall() - tH - 10  )
	surface.DrawText( self.buttonLabel )
end
function PANEL:SetText( txt )
	self.buttonLabel = txt
end
function PANEL:SetIcon( icon, size )
	self.icon = icon
	if size then self.iconsize = size end
end
function PANEL:SetEnabled( bool )
	self.buttonEnabled = bool
end
function PANEL:DrawElements()
	
end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
end
function PANEL:OnSelected()
end
function PANEL:OnMousePressed( key )
	if key == MOUSE_LEFT then
		if IsValid( AWarn.lastSelectedNavButton ) then AWarn.lastSelectedNavButton:SetEnabled( false ) end
		self:SetEnabled( true )
		AWarn.lastSelectedNavButton = self
		self:OnSelected()
	end
end
vgui.Register( "awarn3_navbutton", PANEL )


local PANEL = {}
function PANEL:Init()
	local dockMarginX = 5 * screenscale
	local dockMarginY = 3 * screenscale
	self:SetHeight( 64 * screenscale )
	self:DockMargin( dockMarginX, 0, dockMarginX, dockMarginY * 2 )
	self:Dock( TOP )
	self:DrawElements()
	self.buttonLabel = "This is a test"
	self.buttonEnabled = false
	self.hovered = false
	self.iconsize = 24
end
function PANEL:Paint()
	local bColor
	if self.buttonEnabled then
		bColor = AWarn.Colors.COLOR_BUTTON_SELECTED
	else
		if self.hovered == true then
			bColor = AWarn.Colors.COLOR_BUTTON_HOVERED
		else
			bColor = AWarn.Colors.COLOR_BUTTON
		end
	end
	
	draw.RoundedBox( 16, 0, 0, self:GetWide(), self:GetTall(), bColor)	
		
	surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	surface.SetMaterial( self.icon )
	surface.DrawTexturedRect( self:GetWide() / 2 - self.iconsize * screenscale / 2, self:GetTall() / 2 - self.iconsize * screenscale / 2, self.iconsize * screenscale, self.iconsize * screenscale )
		
	surface.SetFont( "AWarn3NavButton" )
	local tW, tH = surface.GetTextSize( self.buttonLabel or "" )
	
	surface.SetTextColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	surface.SetTextPos( self:GetWide() / 2 - tW / 2, self:GetTall() - tH - 10  )
	surface.DrawText( self.buttonLabel )
end
function PANEL:SetText( txt )
	self.buttonLabel = txt
end
function PANEL:SetIcon( icon, size )
	self.icon = icon
	if size then self.iconsize = size end
end
function PANEL:SetEnabled( bool )
	self.buttonEnabled = bool
end
function PANEL:DrawElements()
	
end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
end
function PANEL:OnSelected()
end
function PANEL:OnMousePressed( key )
	if key == MOUSE_LEFT then
		if IsValid( AWarn.lastSelectedSettingsButton ) then AWarn.lastSelectedSettingsButton:SetEnabled( false ) end
		self:SetEnabled( true )
		AWarn.lastSelectedSettingsButton = self
		self:OnSelected()
	end
end
vgui.Register( "awarn3_navbutton_settings", PANEL )


local PANEL = {}
function PANEL:Init()
	local dockMarginX = 5 * screenscale
	local dockMarginY = 3 * screenscale
	self:SetHeight( 64 * screenscale )
	self:DockMargin( dockMarginX, 0, dockMarginX, dockMarginY * 2 )
	self:Dock( BOTTOM )
	self:DrawElements()
	self.buttonLabel = "This is a test"
	self.hovered = false
end
function PANEL:Paint()
	local bColor
	if self.hovered == true then
		bColor = AWarn.Colors.COLOR_BUTTON_HOVERED
	else
		bColor = AWarn.Colors.COLOR_BUTTON
	end
	
	draw.RoundedBox( 16, 0, 0, self:GetWide(), self:GetTall(), bColor)	
		
	surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	surface.SetMaterial( self.icon )
	surface.DrawTexturedRect( self:GetWide() / 2 - 24 * screenscale / 2, self:GetTall() / 2 - 24 * screenscale / 2, 24 * screenscale, 24 * screenscale )
		
	surface.SetFont( "AWarn3NavButton" )
	local tW, tH = surface.GetTextSize( self.buttonLabel or "" )
	
	surface.SetTextColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	surface.SetTextPos( self:GetWide() / 2 - tW / 2, self:GetTall() - tH - 10  )
	surface.DrawText( self.buttonLabel )
end
function PANEL:SetText( txt )
	self.buttonLabel = txt
end
function PANEL:SetIcon( icon )
	self.icon = icon
end
function PANEL:DrawElements()
	
end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
end
function PANEL:OnSelected()
end
function PANEL:OnMousePressed( key )
	if key == MOUSE_LEFT then
		self:OnSelected()
	end
end
vgui.Register( "awarn3_navbutton2", PANEL )



local PANEL = {}
function PANEL:Init()
	self.hovered = false
	self.icon = boldXImage
	self.iconcolor = AWarn.Colors.COLOR_RED_BUTTON
	self.iconcolorhovered = AWarn.Colors.COLOR_RED_BUTTON_HOVERED
end
function PANEL:Paint()
	if self.hovered then
		surface.SetDrawColor( self.iconcolorhovered )
	else
		surface.SetDrawColor( self.iconcolor )
	end
	
	surface.SetMaterial( self.icon )
	surface.DrawTexturedRect( 0, 0, self:GetWide(), self:GetTall() )
end
function PANEL:SetIcon( icon )
	self.icon = icon
end
function PANEL:SetIconColor( color, color2 )
	if color then self.iconcolor = color end
	if color2 then self.iconcolorhovered = color2 end
end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
end
function PANEL:OnSelected()

end
function PANEL:OnMousePressed( key )
	if key == MOUSE_LEFT then
		self:OnSelected()
	end
end
vgui.Register( "awarn3_iconbutton", PANEL )

local PANEL = {}
function PANEL:Init()
	self.start = RealTime()
	self.stop = RealTime() + 0.5
	self.animating = true
	self:SetWide( 400 * screenscale )
	self:SetTall( 210 * screenscale)
	self.dX = ScrWM() / 2 - self:GetWide() / 2
	self.dY = ScrHM() / 2 - self:GetTall() / 2
	self:SetPos( ScrWM(), self.dY )
	self:DrawElements()
	self.animspeed = 30
	self.playerid = nil
	self:SetTitle( "" )
	self:ShowCloseButton( false )

end
function PANEL:Paint()
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 0, 0, self:GetWide(), 4 )
	surface.DrawRect( 0, self:GetTall() - 4, self:GetWide(), 4 )
	surface.DrawRect( 0, 0, 4, self:GetTall() )
	surface.DrawRect( self:GetWide() - 4, 0, 4, self:GetTall() )
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_SECONDARY )
	surface.DrawRect( 4, 4, self:GetWide() - 8, self:GetTall() - 8)
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 4, 4, self:GetWide() - 8, 26 * screenscale)
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 4, 4 + 26 * screenscale, self:GetWide() - 8, 3 * screenscale)
	
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 4 + 4 * screenscale, 4 + 35 * screenscale, self:GetWide() - 16 * screenscale, 78 * screenscale)
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( self:GetWide() - 9 * screenscale, 4 + 35 * screenscale, 3 * screenscale, 78 * screenscale)
	surface.DrawRect( 4 + 4 * screenscale, 4 + 35 * screenscale + 78 * screenscale, self:GetWide() - 13 * screenscale, 3 * screenscale)
	

	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	local x = 5 + 4 * screenscale
	local y = 5 + 35 * screenscale + 78 * screenscale + 4 + 4 * screenscale
	surface.DrawRect( x, y, self:GetWide() - 16 * screenscale, self:GetTall() - 130 * screenscale)
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( x, y + self:GetTall() - 130 * screenscale, self:GetWide() - 13 * screenscale, 3 * screenscale)
	surface.DrawRect( x + self:GetWide() - 16 * screenscale, y, 3 * screenscale, self:GetTall() - 130 * screenscale)

	
	surface.SetFont( "AWarn3Label2" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	
	local x = 12 * screenscale
	local text = AWarn.Localization:GetTranslation( "deleteconfirmdialogue1" )
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x , 8 * screenscale )
	surface.DrawText( text )
	
	surface.SetFont( "AWarn3Label1" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = self.playerName  or "AAA"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( 84 * screenscale, 60 * screenscale )
	surface.DrawText( text )
	
	surface.SetFont( "AWarn3Label2" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = self.playerid  or "AAA"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( 84 * screenscale, 78 * screenscale )
	surface.DrawText( text )
	
  
	surface.SetFont( "AWarn3Label3" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	
	local x = 18 * screenscale
	local text = AWarn.Localization:GetTranslation( "deleteconfirmdialogue2" )
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x , 130 * screenscale)
	surface.DrawText( text )
	
	local x = 18 * screenscale
	local text = AWarn.Localization:GetTranslation( "deleteconfirmdialogue3" )
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x , 146 * screenscale)
	surface.DrawText( text )
	
end
function PANEL:SetPlayer( id )
	self.playerid = id
end
function PANEL:SetPlayerName( str )
	self.playerName = str or "ERROR"
end
function PANEL:SetNotes( str )
	self.textReason:SetValue( str or "ERROR" )
end
function PANEL:RequestNotes( id )
	AWarn:RequestNotes( id )
end
function PANEL:Think()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self.dX + self:GetWide(), 0.5 )
		local x, y = self:GetPos()
		self:SetPos( ScrWM() + easingsX * -1, y )
	else
		local x, y = self:GetPos()
		self:SetPos( self.dX, y )
		self.animating = false
	end
end
function PANEL:DrawElements()
	
	self.PlayerInfoAvatar = vgui.Create("AWEnhancedAvatarImage", self)
	self.PlayerInfoAvatar:SetPos( 12 * screenscale, 44 * screenscale )
	self.PlayerInfoAvatar:SetVertices( 64 )
	self.PlayerInfoAvatar:SetSize(64 * screenscale, 64 * screenscale)
	
  
  local buttonDock = vgui.Create("DPanel", self)
  buttonDock:SetHeight( 30 )
	buttonDock:DockMargin( 5 * screenscale, 0, 7 * screenscale, 5 * screenscale )
	buttonDock:Dock( BOTTOM )
  buttonDock.Paint = function()
    --surface.SetDrawColor( Color(80,80,80,100) )
    --surface.DrawRect( 0, 0, self:GetWide(), self:GetTall())
  end
  
  
	local confirmButton = vgui.Create( "awarn3_button", buttonDock )
	confirmButton:SetText(AWarn.Localization:GetTranslation( "confirm" ))
	confirmButton:Dock( LEFT )
	confirmButton:SetWidth( 150 * screenscale )
	confirmButton:DockMargin( 10 * screenscale, 2 * screenscale, 14 * screenscale, 2 * screenscale )
	
	local cancelButton = vgui.Create( "awarn3_button", buttonDock )
	cancelButton:SetText(AWarn.Localization:GetTranslation( "cancel" ))
	cancelButton:Dock( RIGHT )
	cancelButton:SetWidth( 150 * screenscale )
	cancelButton:DockMargin( 10 * screenscale, 2 * screenscale, 14 * screenscale, 2 * screenscale )
	
	confirmButton.OnSelected = function()  
    AWarn:DeleteAllPlayerWarnings( AWarn.menu.adminWarningsView.selectedplayerid )
		AWarn.menu.adminWarningsView.selectedplayerwarns = 0
		AWarn.menu.adminWarningsView.WarningCardsPanel:Clear() 
		self:Remove()
	end
  
	cancelButton.OnSelected = function()
		self:Remove()
	end

	
end
vgui.Register( "awarn3_deletewarningsconfirmation", PANEL, "DFrame" )

local PANEL = {}
function PANEL:Init()
	self.start = RealTime()
	self.stop = RealTime() + 0.5
	self.animating = true
	self:SetWide( 750 * screenscale )
	self:SetTall( 410 * screenscale)
	self.dX = ScrWM() / 2 - self:GetWide() / 2
	self.dY = ScrHM() / 2 - self:GetTall() / 2
	self:SetPos( ScrWM(), self.dY )
	self:DrawElements()
	self.animspeed = 30
	self.playerid = nil
	self:SetTitle( "" )
	self:ShowCloseButton( false )

end
function PANEL:Paint()
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 0, 0, self:GetWide(), 4 )
	surface.DrawRect( 0, self:GetTall() - 4, self:GetWide(), 4 )
	surface.DrawRect( 0, 0, 4, self:GetTall() )
	surface.DrawRect( self:GetWide() - 4, 0, 4, self:GetTall() )
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_SECONDARY )
	surface.DrawRect( 4, 4, self:GetWide() - 8, self:GetTall() - 8)
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 4, 4, self:GetWide() - 8, 26 * screenscale)
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 4, 4 + 26 * screenscale, self:GetWide() - 8, 3 * screenscale)
	
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 4 + 4 * screenscale, 4 + 35 * screenscale, self:GetWide() - 16 * screenscale, 78 * screenscale)
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( self:GetWide() - 9 * screenscale, 4 + 35 * screenscale, 3 * screenscale, 78 * screenscale)
	surface.DrawRect( 4 + 4 * screenscale, 4 + 35 * screenscale + 78 * screenscale, self:GetWide() - 13 * screenscale, 3 * screenscale)
	

	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	local x = 5 + 4 * screenscale
	local y = 5 + 35 * screenscale + 78 * screenscale + 4 + 4 * screenscale
	surface.DrawRect( x, y, self:GetWide() - 16 * screenscale, self:GetTall() - 130 * screenscale)
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( x, y + self:GetTall() - 130 * screenscale, self:GetWide() - 13 * screenscale, 3 * screenscale)
	surface.DrawRect( x + self:GetWide() - 16 * screenscale, y, 3 * screenscale, self:GetTall() - 130 * screenscale)

	
	surface.SetFont( "AWarn3Label2" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	
	local x = 12 * screenscale
	local text = AWarn.Localization:GetTranslation( "playernotes" )
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x , 8 * screenscale )
	surface.DrawText( text )
	
	surface.SetFont( "AWarn3Label1" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = self.playerName  or "AAA"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( 84 * screenscale, 60 * screenscale )
	surface.DrawText( text )
	
	surface.SetFont( "AWarn3Label2" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = self.playerid  or "AAA"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( 84 * screenscale, 78 * screenscale )
	surface.DrawText( text )
	
end
function PANEL:SetPlayer( id )
	self.playerid = id
end
function PANEL:SetPlayerName( str )
	self.playerName = str or "ERROR"
end
function PANEL:SetNotes( str )
	self.textReason:SetValue( str or "ERROR" )
end
function PANEL:RequestNotes( id )
	AWarn:RequestNotes( id )
end
function PANEL:Think()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self.dX + self:GetWide(), 0.5 )
		local x, y = self:GetPos()
		self:SetPos( ScrWM() + easingsX * -1, y )
	else
		local x, y = self:GetPos()
		self:SetPos( self.dX, y )
		self.animating = false
	end
end
function PANEL:DrawElements()
	
	
	local closeButton = vgui.Create( "awarn3_iconbutton", self )
	closeButton:SetTooltip(AWarn.Localization:GetTranslation( "closemenu" ))
	closeButton:SetSize( 16 * screenscale, 16 * screenscale )
	closeButton:SetPos( self:GetWide() - closeButton:GetWide() - 8 * screenscale, 8 * screenscale )
	closeButton.OnSelected = function()
		self:Remove()
	end
	
	self.PlayerInfoAvatar = vgui.Create("AWEnhancedAvatarImage", self)
	self.PlayerInfoAvatar:SetPos( 12 * screenscale, 44 * screenscale )
	self.PlayerInfoAvatar:SetVertices( 64 )
	self.PlayerInfoAvatar:SetSize(64 * screenscale, 64 * screenscale)
	
	local submitButton = vgui.Create( "awarn3_button", self )
	submitButton:SetText(AWarn.Localization:GetTranslation( "submit" ))
	submitButton:Dock( BOTTOM )
	submitButton:DockMargin( 10 * screenscale, 0, 14 * screenscale, 10 * screenscale )
	
	self.textReason = vgui.Create( "DTextEntry", self )
	self.textReason:SetHeight( self:GetTall() - 172 * screenscale )
	self.textReason:SetMultiline( true )
	self.textReason:DockMargin( 10 * screenscale, 6 * screenscale, 14 * screenscale, 6 * screenscale )
	self.textReason:Dock( BOTTOM )
	self.textReason:SetFont( "AWarn3NotesTextBoxMono" )
	
	submitButton.OnSelected = function()
		AWarn:SavePlayerNotes( self.playerid, self.textReason:GetValue() or "" )
		self:Remove()
	end

	
end
vgui.Register( "awarn3_playernotesdialogue", PANEL, "DFrame" )

net.Receive( "awarn3_notesrequest", function()
	if not IsValid( AWarn.menu.playernotesdialogue ) then return end
	local notes = net.ReadString()
	local playerID = net.ReadString()
	if not (AWarn.menu.playernotesdialogue.playerid == playerID) then return end
	AWarn.menu.playernotesdialogue:SetNotes( notes )
end )

local PANEL = {}
function PANEL:Init()
	self.start = RealTime()
	self.stop = RealTime() + 0.5
	self.animating = true
	self:SetWide( ScrWM() * 0.25 )
	self:SetTall( 240 * screenscale )
	self.dX = ScrWM() / 2 - self:GetWide() / 2
	self.dY = ScrHM() / 2 - self:GetTall() / 2
	self:SetPos( ScrWM(), self.dY )
	self:DrawElements()
	self.animspeed = 30
	self.playerid = nil
	self:SetTitle( "" )
	self:ShowCloseButton( false )

end
function PANEL:Paint()
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 0, 0, self:GetWide(), 4 )
	surface.DrawRect( 0, self:GetTall() - 4, self:GetWide(), 4 )
	surface.DrawRect( 0, 0, 4, self:GetTall() )
	surface.DrawRect( self:GetWide() - 4, 0, 4, self:GetTall() )
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_SECONDARY )
	surface.DrawRect( 4, 4, self:GetWide() - 8, self:GetTall() - 8)
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 4, 4, self:GetWide() - 8, 26 * screenscale)
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 4, 4 + 26 * screenscale, self:GetWide() - 8, 3 * screenscale)
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 4 + 4 * screenscale, 4 + 35 * screenscale, self:GetWide() - 16 * screenscale, self:GetTall() - 46 * screenscale)
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 4 + 4 * screenscale, 4 + 35 * screenscale + self:GetTall() - 46 * screenscale, self:GetWide() - 13 * screenscale, 3 * screenscale)
	surface.DrawRect( self:GetWide() - 9 * screenscale, 4 + 35 * screenscale, 3 * screenscale,self:GetTall() - 46 * screenscale)
	
	
	surface.SetFont( "AWarn3Label2" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	
	local x = 12 * screenscale
	local text = AWarn.Localization:GetTranslation( "playerwarningmenu" )
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x , 8 * screenscale )
	surface.DrawText( text )
	
	
	local x = 65 * screenscale
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = self.playerName  or "AAA"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x + 5 * screenscale, 60 * screenscale )
	surface.DrawText( text )
	
	
	surface.SetFont( "AWarn3Label3" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = self.playerid
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x + 5 * screenscale, 75 * screenscale )
	surface.DrawText( text )
	
end
function PANEL:SetPlayer( id )
	self.playerid = id
	self.PlayerInfoAvatar:SetSteamID( id, 184 )
end
function PANEL:SetPlayerName( str )
	self.playerName = str or "ERROR"
end
function PANEL:Think()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self.dX + self:GetWide(), 0.5 )
		local x, y = self:GetPos()
		self:SetPos( ScrWM() + easingsX * -1, y )
	else
		local x, y = self:GetPos()
		self:SetPos( self.dX, y )
		self.animating = false
	end
end
function PANEL:DrawElements()
	
	
	local closeButton = vgui.Create( "awarn3_iconbutton", self )
	closeButton:SetTooltip(AWarn.Localization:GetTranslation( "closemenu" ))
	closeButton:SetSize( 16 * screenscale, 16 * screenscale )
	closeButton:SetPos( self:GetWide() - closeButton:GetWide() - 8 * screenscale, 8 * screenscale )
	closeButton.OnSelected = function()
		self:Remove()
	end
	
	self.PlayerInfoAvatar = vgui.Create("AWEnhancedAvatarImage", self)
	self.PlayerInfoAvatar:SetPos( 17 * screenscale, 49 * screenscale )
	self.PlayerInfoAvatar:SetVertices( 64 )
	self.PlayerInfoAvatar:SetSize(48 * screenscale, 48 * screenscale)
	
	local warnButton = vgui.Create( "awarn3_button", self )
	warnButton:SetText(AWarn.Localization:GetTranslation( "submit" ))
	warnButton:Dock( BOTTOM )
	warnButton:DockMargin( 10 * screenscale, 0, 14 * screenscale, 10 * screenscale )
	warnButton:SetZPos(1)
	
	local textReason = vgui.Create( "DTextEntry", self )
	textReason:SetHeight( 70 * screenscale )
	textReason:SetMultiline( true )
	textReason:DockMargin( 10 * screenscale, 2 * screenscale, 14 * screenscale, 4 * screenscale )
	textReason:Dock( BOTTOM )
	textReason:SetFont( "AWarn3CardText1" )
	textReason:SetZPos(2)
	
	local presetComboBox = vgui.Create( "DComboBox", self )
	presetComboBox:SetHeight( 20 * screenscale )
	presetComboBox:DockMargin( 10 * screenscale, 6 * screenscale, 14 * screenscale, 2 * screenscale )
	presetComboBox:Dock( BOTTOM )
	presetComboBox:SetFont( "AWarn3CardText1" )
	presetComboBox:SetZPos(3)
	presetComboBox:SetValue(AWarn.Localization:GetTranslation( "chooseapreset" ))
	function presetComboBox:OnSelect( index, text, data )
		textReason:SetValue( data )
	end
	if AWarn.Presets then
		for k, v in pairs( AWarn.Presets ) do
			presetComboBox:AddChoice( k, v.pReason )
		end
	end	
	
	warnButton.OnSelected = function()
		AWarn:CreateWarningID( self.playerid, LocalPlayer():SteamID64(), textReason:GetValue() or "" )
		if self.playerid == AWarn.menu.adminWarningsView.selectedplayerid then
			AWarn:RequestWarningsForPlayer( self.playerid )
		end
		self:Remove()
	end

	
end
vgui.Register( "awarn3_warndialogue", PANEL, "DFrame" )


local PANEL = {}
function PANEL:Init()
	self.start = RealTime()
	self.stop = RealTime() + 0.5
	self.animating = true
	self:SetWide( ScrWM() * 0.5 )
	self:SetTall( ScrHM() * 0.5 )
	self.dX = ScrWM() / 2 - self:GetWide() / 2
	self.dY = ScrHM() / 2 - self:GetTall() / 2
	self:SetPos( ScrWM(), self.dY )
	self:DrawElements()
	self:SetTitle( "" )
	self:ShowCloseButton( false )
	self:DockPadding(0,0,0,0)
	
	
	
	self.panelQueue = {}
	self.nextProcessTime = RealTime()
end
function PANEL:Paint()
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_SECONDARY )
	surface.DrawRect( 80 * screenscale, 70 * screenscale, self:GetWide(), self:GetTall() )  --Main Body
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	surface.DrawRect( 0, 0, self:GetWide(), 70 * screenscale ) --Header
	
	surface.DrawRect( 0, 70 * screenscale, 80 * screenscale, self:GetTall() - 70 * screenscale ) --Left Panel
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 80 * screenscale, 70 * screenscale, 3 * screenscale, self:GetTall() - 70 * screenscale ) --Left Panel Shadow
	surface.DrawRect( 80 * screenscale + 3 * screenscale, 70 * screenscale, self:GetWide() - (80 * screenscale + 3 * screenscale), 3 * screenscale ) --Header Shadow
	
	surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
	surface.DrawRect( 0, 0, self:GetWide(), 4 )
	surface.DrawRect( 0, self:GetTall() - 4, self:GetWide(), 4 )
	surface.DrawRect( 0, 0, 4, self:GetTall() )
	surface.DrawRect( self:GetWide() - 4, 0, 4, self:GetTall() )
		
	surface.SetFont( "AWarn3Label2" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )

	local x = 420 * screenscale
	local text = AWarn.Localization:GetTranslation( "excludeplayers" )
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x , 26 * screenscale )
	surface.DrawText( text )
	
end
function PANEL:Think()
	self:ProcessPanelQueue()
	self:AnimatePanel()
end
function PANEL:AnimatePanel()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self.dX + self:GetWide(), 0.5 )
		local x, y = self:GetPos()
		self:SetPos( ScrWM() + easingsX * -1, y )
	else
		local x, y = self:GetPos()
		self:SetPos( self.dX, y )
		self.animating = false
	end
end
function PANEL:ProcessPanelQueue()
	if self.nextProcessTime > RealTime() then return end
	self.nextProcessTime = RealTime() + 0.02
	if #self.panelQueue <= 0 then return end
	AWarn:AddSearchPlayerCard( self.panelQueue[1] )
	table.remove( self.panelQueue, 1 )
end
function PANEL:DrawElements()


	local dockmargin = 6 * screenscale
	
	local navButtonPanel = vgui.Create( "DPanel", self )
	navButtonPanel:SetPos( 0, 70 * screenscale )
	navButtonPanel:DockPadding( 0, 10, 0, 70 * screenscale )
	navButtonPanel:SetSize( 80 * screenscale, self:GetTall() )
	navButtonPanel.Paint = function()
		--Render Invisible
		--surface.SetDrawColor( 200, 200, 200, 100 )
		--surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	
	local navButton = vgui.Create( "awarn3_navbutton2", navButtonPanel )
	navButton:SetText( AWarn.Localization:GetTranslation( "closemenu" ) )
	navButton:SetIcon( closeImage )
	navButton.OnSelected = function()
		self:Remove()
	end
	
	self.PlayerCardsPanel = vgui.Create( "DScrollPanel", self )
	self.PlayerCardsPanel:SetPos( 80 * screenscale + 7 * screenscale, 70 * screenscale + 7 * screenscale )
	self.PlayerCardsPanel:SetHeight( self:GetTall() - 82 * screenscale )
	self.PlayerCardsPanel:SetWidth( self:GetWide() - (80 * screenscale + 12 * screenscale) )
	self.PlayerCardsPanel:GetCanvas():DockPadding( 0, 0, 0, 6 * screenscale )
	self.PlayerCardsPanel.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, self.PlayerCardsPanel:GetWide() - 3 * screenscale, self.PlayerCardsPanel:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( self.PlayerCardsPanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, self.PlayerCardsPanel:GetTall() - 1 )
		surface.DrawRect( 0, self.PlayerCardsPanel:GetTall() - 3 * screenscale, self.PlayerCardsPanel:GetWide() - 3 * screenscale, 3 * screenscale )
	end
	
	local ScrollBar = self.PlayerCardsPanel:GetVBar()
	ScrollBar:SetHideButtons( true )
	ScrollBar:SetWidth( 6 * screenscale )
	function ScrollBar:Paint( w, h )
		surface.SetDrawColor( 0, 0, 0, 0 )
		surface.DrawRect( 0, 0, w, h )
	end
	function ScrollBar.btnGrip:Paint( w, h )
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( 0, 0, w, h )
	end
	
	local chkBox = vgui.Create( "awarn3_customcheckbox", self )// Create the checkbox
	chkBox:SetPos( 360 * screenscale, 24 * screenscale )// Set the position
	chkBox:SetSize(48 * screenscale, 24 * screenscale)
	chkBox:SetValue( 0 )
	
	local playerSearchText = vgui.Create( "DTextEntry", self )
	playerSearchText:SetSize( 300 * screenscale, 30 * screenscale )
	playerSearchText:SetMultiline( false )
	playerSearchText:SetFont( "AWarn3Label2" )
	playerSearchText:SetPos( 10 * screenscale, 20 * screenscale )	
	playerSearchText:SetEnterAllowed( true )
	playerSearchText:SetPlaceholderText( " Search by Name/SteamID64" )
	playerSearchText:SetPaintBackground(true)
	playerSearchText.OnEnter = function()
		if not ( playerSearchText:GetValue() == "" ) then
			AWarn:SendSearchString( playerSearchText:GetValue(), chkBox:GetChecked() )
		else
			return false
		end
	end
	
	local searchButton = vgui.Create( "awarn3_iconbutton", self )
	searchButton:SetTooltip(AWarn.Localization:GetTranslation( "searchforplayers" ))
	searchButton:SetIcon( searchImage )
	searchButton:SetIconColor( AWarn.Colors.COLOR_BUTTON_TEXT )
	searchButton:SetSize( 20 * screenscale, 20 * screenscale )
	searchButton:SetPos( 320 * screenscale, 25 * screenscale )
	searchButton.OnSelected = function()
		AWarn:SendSearchString( playerSearchText:GetValue(), chkBox:GetChecked() )
	end
	
end
vgui.Register( "awarn3_playersearch", PANEL, "DFrame" )




local PANEL = {}
function PANEL:Init()
	local dockMargin = 4 * screenscale
	self:DockMargin( dockMargin, dockMargin, dockMargin, 0 )
	self:SetHeight( 40 * screenscale )
	self:Dock( TOP )
	
	self.lastclicked = RealTime()
	
	self.hovered = false
	
	self.warninginfotbl = {}
		
	self.start = RealTime()
	self.stop = RealTime() + 0.1
	self.animating = true
	
	self.dX, self.dY = self:GetPos()
	
	timer.Simple( 0.5, function() if IsValid(self) then self:DrawElements() end end )
	
end
function PANEL:Paint()
	
	if self.hovered == true then
		surface.SetDrawColor( AWarn.Colors.COLOR_BUTTON_HOVERED )
	else
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
	end
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
	surface.SetFont( "AWarn3CardText1" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	
	
		
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	local text = AWarn.Localization:GetTranslation( "name" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	local x = tW + 5 * screenscale
	surface.SetTextPos( x - tW, 5 * screenscale )
	surface.DrawText( text )
	
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = self.warninginfotbl.PlayerName or "ERROR"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x + 4 * screenscale, 5 * screenscale )
	surface.DrawText( text )
	
	
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	local text = AWarn.Localization:GetTranslation( "activewarnings" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	local x = tW + 5 * screenscale
	surface.SetTextPos( x - tW, 22 * screenscale)
	surface.DrawText( text )
	
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = self.warninginfotbl.PlayerWarnings or "ERROR"
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x + 4 * screenscale, 22 * screenscale )
	surface.DrawText( text )
	
	
	
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	local text = AWarn.Localization:GetTranslation( "lastplayed" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	local x = tW + 400 * screenscale
	surface.SetTextPos( x - tW, 5 * screenscale )
	surface.DrawText( text )
	
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = AWarn.Localization:GetTranslation( "never" )
	if self.warninginfotbl.LastPlayed and not ( self.warninginfotbl.LastPlayed == "NULL" ) then
		text = os.date( "%m/%d/%Y" , self.warninginfotbl.LastPlayed or 111111111 )
	end
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x + 4 * screenscale, 5 * screenscale )
	surface.DrawText( text )
	
	
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	local text = AWarn.Localization:GetTranslation( "lastwarned" ) .. ":"
	local tW, tH = surface.GetTextSize( text )
	local x = tW + 400 * screenscale
	surface.SetTextPos( x - tW, 22 * screenscale )
	surface.DrawText( text )
	
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
	local text = AWarn.Localization:GetTranslation( "never" )
	if self.warninginfotbl.LastWarning and not ( self.warninginfotbl.LastWarning == "NULL" ) then
		text = os.date( "%m/%d/%Y %H:%M" , self.warninginfotbl.LastWarning or 111111111 )
	end
	local tW, tH = surface.GetTextSize( text )
	surface.SetTextPos( x + 4 * screenscale, 22 * screenscale )
	surface.DrawText( text )


end
function PANEL:SetInfo( tbl )
	self.warninginfotbl = tbl
	self:SetTooltip( AWarn.Localization:GetTranslation( "playerid" ) .. ": " .. tbl.PlayerID )
end
function PANEL:Think()
	if self:IsHovered() and not self.hovered then
		self.hovered = true
	elseif self.hovered and not self:IsHovered() then
		self.hovered = false
	end
	self:AnimateThink()
end
function PANEL:AnimateThink()
	if not self.animating then return end
	if RealTime() < self.stop then
		local easingsX = easings.outCubic( RealTime() - self.start, 0, self:GetWide(), 0.1 )
		local x, y = self:GetPos()
		local easeAmt = ( easingsX * -1 ) + self:GetWide()
		self:SetPos( easeAmt, y )
	else
		local x, y = self:GetPos()
		self.animating = false
	end
end
function PANEL:DrawElements( pl )

end
function PANEL:DoSelect()
	AWarn:UnselectPlayer()
	AWarn:RequestWarningsForPlayer( self.warninginfotbl.PlayerID )
	AWarn.menu.adminWarningsView.selectedplayerid = self.warninginfotbl.PlayerID
	AWarn.menu.adminWarningsView.subWarningButton:SetVisible( true )
	AWarn.menu.adminWarningsView.deleteWarningButton2:SetVisible( true )
	AWarn.menu.adminWarningsView.playerNotesButton:SetVisible( true )
	if string.Left(tostring(self.warninginfotbl.PlayerID), 3) == "Bot" then
		AWarn.menu.adminWarningsView.PlayerInfoAvatar:SetPlayer(Entity(0))
	else
		AWarn.menu.adminWarningsView.PlayerInfoAvatar:SetSteamID(tostring(self.warninginfotbl.PlayerID), 184)	
	end
	if AWarn:CheckPermission( LocalPlayer(), "awarn_view" ) then
		AWarn.menu.adminWarningsView:Show()
	else
		AWarn.menu.selfWarningsView:Show()
	end
	AWarn.menu.configurationview:Hide()
	AWarn.menu.playersearch:Remove()
end
function PANEL:OnMousePressed( key )
	if key == MOUSE_LEFT then
			self:DoSelect()
	end
end
vgui.Register( "awarn3_searchplayercard", PANEL )






local function drawCircle( x, y, radius, seg )
	local cir = {}

	table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
	for i = 0, seg do
		local a = math.rad( ( i / seg ) * -360 )
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )
	end

	local a = math.rad( 0 ) -- This is needed for non absolute segment counts
	table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

	surface.DrawPoly( cir )
end

local PANEL = {}
function PANEL:Init()
	self:SetHeight(10)
	self:SetWidth(10)
	self.Gray1 = Color(80,80,80,255)
	self.Gray2 = Color(200,200,200,255)
	self.Green1 = Color(80,110,80,255)
	self.Green2 = Color(160,255,160,255)
	self.circlePos = 3 + self:GetTall() / 2
	self.circleNewPos = self.circlePos
end
function PANEL:Paint()
	local r = self:GetTall() / 2
	if self:GetChecked() then
		draw.RoundedBox( 24, 5, (self:GetTall() / 2) - ( (self:GetTall() / 1.5) / 2 ) , self:GetWide() - 10, self:GetTall() / 1.5, self.Green1 )
		surface.SetDrawColor( self.Green2 )	
		draw.NoTexture()
		self.circleNewPos = math.floor(self:GetWide() - (r+3))
	else
		draw.RoundedBox( 24, 5, (self:GetTall() / 2) - ( (self:GetTall() / 1.5) / 2 ) , self:GetWide() - 10, self:GetTall() / 1.5, self.Gray1 )
		surface.SetDrawColor( self.Gray2 )	
		draw.NoTexture()
		self.circleNewPos = math.ceil(3 + r)
	end
	if self.circleNewPos > self.circlePos then
		self.circlePos = self.circlePos + 1
	elseif self.circleNewPos < self.circlePos then
		self.circlePos = self.circlePos - 1		
	end
	drawCircle( self.circlePos, self:GetTall() / 2 , r, 32 )
end
vgui.Register( "awarn3_customcheckbox", PANEL, "DCheckBox" )




















function AWarn:PopulateSearchPlayerWarnings( tbl, clear )
	if not IsValid( self.menu ) then return end
	if not IsValid( self.menu.playersearch ) then return end
	
	if clear then
		self.menu.playersearch.panelQueue = {}
		self.menu.playersearch.PlayerCardsPanel:Clear()
	end
	

	if #tbl > 0 then
		table.Add( self.menu.playersearch.panelQueue, tbl )
	end
end

function AWarn:AddSearchPlayerCard( tbl )

	local searchPlayerCard = vgui.Create( "awarn3_searchplayercard" )
	self.menu.playersearch.PlayerCardsPanel:AddItem( searchPlayerCard )
	searchPlayerCard:Dock( TOP )
	searchPlayerCard:SetInfo( tbl )
	
	searchPlayerCard.hdiv = vgui.Create( "awarn3_hdiv" )
	searchPlayerCard.hdiv:Dock( TOP )
	self.menu.playersearch.PlayerCardsPanel:AddItem( searchPlayerCard.hdiv )
	
end

function AWarn:SendSearchString( str, excludePlayers )
	net.Start( "awarn3_requestplayersearchdata" )
	net.WriteString( str )
	net.WriteBool( excludePlayers )
	net.SendToServer()
end

net.Receive( "awarn3_requestplayersearchdata", function()
	local page = net.ReadInt(8)
	local data = net.ReadTable()
	local toClear = false
	if page == 1 then toClear = true end
	AWarn:PopulateSearchPlayerWarnings( data, toClear )
end )


local PANEL = {}

AccessorFunc(PANEL, "vertices", "Vertices", FORCE_NUMBER) -- so you can call panel:SetVertices and panel:GetRotation
AccessorFunc(PANEL, "rotation", "Rotation", FORCE_NUMBER) -- so you can call panel:SetRotation and panel:GetRotation

function PANEL:Init()
  self.rotation = 0
  self.vertices = 4
  self.avatar = vgui.Create("AvatarImage", self)
  self.avatar:SetPaintedManually(true)
end

function PANEL:CalculatePoly(w, h)
  local poly = {}

  local x = w/2
  local y = h/2
  local radius = h/2

  table.insert(poly, { x = x, y = y })

  for i = 0, self.vertices do
    local a = math.rad((i / self.vertices) * -360) + self.rotation;
    table.insert(poly, { x = x + math.sin(a) * radius, y = y + math.cos(a) * radius })
  end

  local a = math.rad(0)
  table.insert(poly, { x = x + math.sin(a) * radius, y = y + math.cos(a) * radius })
  self.data = poly;
end

function PANEL:PerformLayout()
  self.avatar:SetSize(self:GetWide(), self:GetTall())
  self:CalculatePoly(self:GetWide(), self:GetTall())
end

function PANEL:SetPlayer(ply, size)
  self.avatar:SetPlayer(ply, size)
end

function PANEL:SetSteamID(id, size)
  self.avatar:SetSteamID(id, size)
end

function PANEL:DrawPoly( w, h )
  if (!self.data) then
    self:CalculatePoly(w, h)
  end

  surface.DrawPoly(self.data)
end

function PANEL:Paint(w, h)
	if not AWarn.menu.adminWarningsView.selectedplayer then return end
	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1);
	render.SetStencilTestMask(1);

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	draw.NoTexture()
	surface.SetDrawColor(color_white)
	self:DrawPoly(w, h)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	self.avatar:PaintManual()

	render.SetStencilEnable(false)
	render.ClearStencil()
end
vgui.Register("AWEnhancedAvatarImage", PANEL)
--PATH addons/[admin] awarn3/lua/includes/awarn3_easings.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/awarn3_themes.lua:
AddCSLuaFile()
local themes = {}

local function RegisterTheme( theme )
	themes[theme.name] = theme
end

local THEME = {}
THEME.name = "Dark"
THEME.colors = {
	COLOR_SELECTED = Color( 255, 136, 0, 100 ),
	COLOR_BUTTON_SELECTED = Color( 180, 120, 20, 40 ),
	COLOR_BUTTON = Color( 80, 80, 80, 0 ),
	COLOR_BUTTON_2 = Color( 80, 80, 80, 255 ),
	COLOR_BUTTON_2_HOVERED = Color( 80, 80, 80, 60 ),
	COLOR_BUTTON_HOVERED = Color( 92, 92, 92, 220 ),
	COLOR_BUTTON_DISABLED = Color( 120, 120, 120, 40 ),
	COLOR_BUTTON_TEXT = Color( 255, 255, 255, 255 ),
	COLOR_LABEL_TEXT = Color( 255, 255, 255, 255 ),
	COLOR_LABEL_VALUE_TEXT = Color( 180, 180, 180, 255 ),
	COLOR_THEME_PRIMARY = Color( 40, 40, 40, 255 ),
	COLOR_THEME_PRIMARY_SHADOW = Color( 35, 35, 35, 255 ),
	COLOR_THEME_SECONDARY = Color( 50, 50, 50, 255 ),
	COLOR_RED_BUTTON = Color(200,40,40,200),
	COLOR_RED_BUTTON_HOVERED = Color(200,40,40,100),
}
RegisterTheme( THEME )

local THEME = {}
THEME.name = "Light"
THEME.colors = {
	COLOR_SELECTED = Color( 255, 136, 0, 200 ),
	COLOR_BUTTON_SELECTED = Color( 120, 120, 120, 140 ),
	COLOR_BUTTON = Color( 80, 80, 80, 0 ),
	COLOR_BUTTON_2 = Color( 200, 80, 60, 120 ),
	COLOR_BUTTON_2_HOVERED = Color( 200, 80, 60, 60 ),
	COLOR_BUTTON_HOVERED = Color( 80, 80, 80, 60 ),
	COLOR_BUTTON_DISABLED = Color( 120, 120, 120, 40 ),
	COLOR_BUTTON_TEXT = Color( 20, 20, 20, 240 ),
	COLOR_LABEL_TEXT = Color( 60, 10, 10, 210 ),
	COLOR_LABEL_VALUE_TEXT = Color( 40, 30, 30, 240 ),
	COLOR_THEME_PRIMARY = Color( 230, 230, 235, 250 ),
	COLOR_THEME_SECONDARY = Color( 206, 206, 206, 255 ),
	COLOR_THEME_PRIMARY_SHADOW = Color( 189, 189, 189, 250 ),
	COLOR_RED_BUTTON = Color(255,0,0,200),
	COLOR_RED_BUTTON_HOVERED = Color(255,0,0,200),
}
RegisterTheme( THEME )

local THEME = {}
THEME.name = "Rose"
THEME.colors = {
	COLOR_SELECTED = Color( 255, 0, 200, 160 ),
	COLOR_BUTTON_SELECTED = Color( 180, 40, 40, 40 ),
	COLOR_BUTTON = Color( 80, 80, 80, 0 ),
	COLOR_BUTTON_2 = Color( 180, 80, 80, 120 ),
	COLOR_BUTTON_2_HOVERED = Color( 180, 80, 80, 180 ),
	COLOR_BUTTON_HOVERED = Color( 80, 80, 80, 30 ),
	COLOR_BUTTON_DISABLED = Color( 120, 120, 120, 40 ),
	COLOR_BUTTON_TEXT = Color( 20, 20, 20, 180 ),
	COLOR_LABEL_TEXT = Color( 180, 80, 160, 255 ),
	COLOR_LABEL_VALUE_TEXT = Color( 220, 80, 220, 220 ),
	COLOR_THEME_PRIMARY = Color( 255, 230, 255, 250 ),
	COLOR_THEME_SECONDARY = Color( 255, 210, 255, 255 ),
	COLOR_THEME_PRIMARY_SHADOW = Color( 235, 216, 234, 250 ),
	COLOR_RED_BUTTON = Color(255,80,80,200),
	COLOR_RED_BUTTON_HOVERED = Color(255,80,80,255),
}
RegisterTheme( THEME )

local THEME = {}
THEME.name = "Burgandy"
THEME.colors = {
	COLOR_SELECTED = Color( 200, 110, 20, 200 ),
	COLOR_BUTTON_SELECTED = Color( 180, 50, 80, 80 ),
	COLOR_BUTTON = Color( 80, 80, 80, 0 ),
	COLOR_BUTTON_2 = Color( 180, 50, 80, 120 ),
	COLOR_BUTTON_2_HOVERED = Color( 180, 50, 80, 180 ),
	COLOR_BUTTON_HOVERED = Color( 80, 80, 80, 30 ),
	COLOR_BUTTON_DISABLED = Color( 120, 120, 120, 40 ),
	COLOR_BUTTON_TEXT = Color( 240, 240, 240, 150 ),
	COLOR_LABEL_TEXT = Color( 250, 250, 250, 200 ),
	COLOR_LABEL_VALUE_TEXT = Color( 255, 200, 200, 180 ),
	COLOR_THEME_PRIMARY = Color( 80, 0, 20, 250 ),
	COLOR_THEME_SECONDARY = Color( 100, 0, 40, 255 ),
	COLOR_THEME_PRIMARY_SHADOW = Color( 60, 0, 10, 250 ),
	COLOR_RED_BUTTON = Color(255,0,0,200),
	COLOR_RED_BUTTON_HOVERED = Color(255,0,0,200),
}
RegisterTheme( THEME )

function AWarn:ReturnThemes()
	return themes
end

function AWarn:SetTheme( theme )
	AWarn.Colors = themes[theme].colors
end
--PATH lua/autorun/bx_inf.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/autorun/cityworker_config.lua:
CITYWORKER = CITYWORKER or {}

CITYWORKER.Config = CITYWORKER.Config or {}

--[[
  /$$$$$$  /$$   /$$                     /$$      /$$                     /$$                          
 /$$__  $$|__/  | $$                    | $$  /$ | $$                    | $$                          
| $$  \__/ /$$ /$$$$$$   /$$   /$$      | $$ /$$$| $$  /$$$$$$   /$$$$$$ | $$   /$$  /$$$$$$   /$$$$$$ 
| $$      | $$|_  $$_/  | $$  | $$      | $$/$$ $$ $$ /$$__  $$ /$$__  $$| $$  /$$/ /$$__  $$ /$$__  $$
| $$      | $$  | $$    | $$  | $$      | $$$$_  $$$$| $$  \ $$| $$  \__/| $$$$$$/ | $$$$$$$$| $$  \__/
| $$    $$| $$  | $$ /$$| $$  | $$      | $$$/ \  $$$| $$  | $$| $$      | $$_  $$ | $$_____/| $$      
|  $$$$$$/| $$  |  $$$$/|  $$$$$$$      | $$/   \  $$|  $$$$$$/| $$      | $$ \  $$|  $$$$$$$| $$      
 \______/ |__/   \___/   \____  $$      |__/     \__/ \______/ |__/      |__/  \__/ \_______/|__/      
                         /$$  | $$                                                                     
                        |  $$$$$$/                                                                     
                         \______/                                                                      
                                
                                                v1.0.5
                                    By: Silhouhat (76561198072551027)
                                      Licensed to: 76561198196280105

--]]

-- How often should we check (in seconds) for City Workers with no assigned jobs, so we can give them?
CITYWORKER.Config.Time = 15

-- Configuration for the DarkRP job.
CITYWORKER.Config.Job = {
    name = "City Worker",

    color = Color( 20, 150, 20, 255 ),
    model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl"
    },
    description = "The city worker's job is to go around and fix leaks, fire hydrants, rubble, and electrical problems around the city, and get paid doing it!",
    weapons = { "cityworker_pliers", "cityworker_shovel", "cityworker_wrench" },
    command = "cityworker",
    max = 6,
    salary = 75,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Citizens",
}

------------
-- RUBBLE --
------------

CITYWORKER.Config.Rubble = {}

-- Whether or not rubble is enabled or disabled.
CITYWORKER.Config.Rubble.Enabled = true

-- Rubble models and the range of time (in seconds) it takes to clear them.
CITYWORKER.Config.Rubble.Models = {
    ["models/props_debris/concrete_debris128pile001a.mdl"] = { min = 20, max = 30 },
    ["models/props_debris/concrete_debris128pile001b.mdl"] = { min = 10, max = 15 },
    ["models/props_debris/concrete_floorpile01a.mdl"] = { min = 10, max = 20 },
    ["models/props_debris/concrete_cornerpile01a.mdl"] = { min = 10, max = 20 },
    ["models/props_debris/concrete_spawnplug001a.mdl"] = { min = 5, max = 10 },
    ["models/props_debris/plaster_ceilingpile001a.mdl"] = { min = 10, max = 15 },
}

-- Payout per second it takes to clear a given pile of rubble.
-- (i.e. 10 seconds = 10 * 30 = 300)
CITYWORKER.Config.Rubble.Payout = 30

-------------------
-- FIRE HYDRANTS --
-------------------

CITYWORKER.Config.FireHydrant = {}

-- Whether or not fire hydrants are enabled or disabled.
CITYWORKER.Config.FireHydrant.Enabled = true

-- The range for how long it takes to fix a fire hydrant.
-- Maximum value: 255 seconds.
CITYWORKER.Config.FireHydrant.Time = { min = 20, max = 30 }

-- Payout per second it takes to fix a fire hydrant.
CITYWORKER.Config.FireHydrant.Payout = 40

-----------
-- LEAKS --
-----------

CITYWORKER.Config.Leak = CITYWORKER.Config.Leak or {}

-- Whether or not leaks are enabled or disabled.
CITYWORKER.Config.Leak.Enabled = true

-- The range for how long it takes to fix a leak.
-- Maximum value: 255 seconds.
CITYWORKER.Config.Leak.Time = { min = 10, max = 30 }

-- Payout per second it takes to fix a leak.
CITYWORKER.Config.Leak.Payout = 20

--------------
-- ELECTRIC --
--------------

CITYWORKER.Config.Electric = CITYWORKER.Config.Electric or {}

-- Whether or not electrical problems are enabled or disabled.
CITYWORKER.Config.Electric.Enabled = true

-- The range for how long it takes to fix an electrical problem.
-- Maximum value: 255 seconds.
CITYWORKER.Config.Electric.Time = { min = 20, max = 30 }

-- Payout per second it takes to fix an electrical problem.
CITYWORKER.Config.Electric.Payout = 50

----------------------------
-- LANGUAGE CONFIGURATION --
----------------------------

CITYWORKER.Config.Language = {
    ["FireHydrant"]         = "Fixing fire hydrant...",
    ["Leak"]                = "Fixing leak..",
    ["Electric"]            = "Fixing electrical problem...",
    ["Rubble"]              = "Clearing rubble...",

    ["CANCEL"]              = "Press F2 to cancel the action.",
    ["PAYOUT"]              = "You've earned %s from your work!",
    ["CANCELLED"]           = "You've cancelled your action!",
    ["NEW_JOB"]             = "You have a new job to do!",
    ["NOT_CITY_WORKER"]     = "You are not a city worker!",
    ["JOB_WORKED"]          = "This job is already being worked!",
    ["ASSIGNED_ELSE"]       = "This job has been assigned to someone else!",
}
--PATH lua/autorun/civ_pm_popculture.lua:
return gluapack()()
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/cl_newdrzewko.lua:
return gluapack()()
--PATH lua/autorun/cshield.lua:
return gluapack()()
--PATH lua/autorun/dao.lua:
player_manager.AddValidModel( "navy dao", 		"models/navy/gnavydao.mdl" );
list.Set( "PlayerOptionsModel", "navy dao", 	"models/navy/gnavydao.mdl" );
--PATH addons/[opt] decals/lua/decals/util/sh_util.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/util/cl_parse.lua:
Decals.Parse = Decals.Parse or {
    Patterns = {
        Imgur = {
            "https?://[www%.]*.?i.imgur.com/(%w+)",
            "https?://[www%.]*.?imgur.com/a/(%w+)",
            "https?://[www%.]*.?imgur.com/gallery/(%w+)"
        }
    }
}

function Decals.Parse.Imgur( url )
    if !url:find "imgur" then
        return false
    end

    for _, pattern in ipairs( Decals.Parse.Patterns.Imgur ) do
        local res = url:match( pattern )

        if res then
            return "https://i.imgur.com/" .. res .. ".png"
        end
    end

    return nil
end

function Decals.Parse.Error( url )
    return Decals.Load.Valid[ url:GetExtensionFromFilename() ]
end

--PATH addons/!discordintegration/lua/discord_lang.lua:
--[[
    Nie ma konkretnej obsługi języka, ale obecnie istnieje możliwość zmiany wszystkich zwrotów.
]]
Discord.Lang = {
    --[[

        Rozpoczęcie konfiguracji językowej

    ]]


    --[[
        Dodatkowe obsługiwane ciągi znaków dla dowolnego ciągu znaków w języku:
        <server_ip> -> IP serwera
        <join_url> -> steam://connect/<server_ip>
        <hostname> -> Nazwa hosta serwera
        <map> -> Mapa serwera
        <gamemode> -> Tryb gry serwera
    ]]

    --[[
        Komunikat online
    ]]
    ONLINE_MESSAGE_TITLE = 'Serwer jest teraz online!',
    ONLINE_MESSAGE_DESCRIPTION = 'Dołącz teraz pod adresem <join_url>!',

    --[[
        Wydarzenie dołączenia/opuszczenia gracza

        Dodatkowe obsługiwane ciągi znaków dla PLAYER_JOIN i PLAYER_DISCONNECT:
        <steam_id> -> steamid32 gracza
        <name> -> Nazwa gracza

        Tylko dla PLAYER_DISCONNECT:
        <reason> -> Powód rozłączenia
    ]]
    PLAYER_JOIN = 'Gracz <name> (<steam_id>) łączy się z serwerem!',
    PLAYER_DISCONNECT = 'Gracz <name> (<steam_id>) rozłączył się (<reason>)',

    --[[
        RPC Discord
    ]]
    CHECK_DISCORD = 'Sprawdź swoją instancję Discord.',
    RPC_ABORTED = 'Anulowano.',
    SOMETHING_WENT_WRONG = 'Ups! Coś poszło nie tak, sprawdź konsolę po więcej informacji.',
    DISCORD_NOT_FOUND = 'Instancja Discord nie została znaleziona na twoim komputerze. Jako alternatywę, możesz uwierzytelnić się za pośrednictwem strony internetowej, którą ci podaliśmy.',

    --[[
        Dołączanie do Discord
    ]]
    JOINED_DISCORD = 'Dziękujemy za dołączenie do naszego Discorda!',
    JOINED_DISCORD_ALREADY = 'Dziękujemy za dołączenie do naszego Discorda! Ponieważ to nie był twój pierwszy raz dołączania, nie otrzymasz nagrody.',

    --[[
        Łączenie kont

        Dodatkowe obsługiwane ciągi znaków dla ACCOUNT_LINKED:
        <tag> -> Tag Discord (np. username#0001) połączonego konta
    ]]
    ACCOUNT_LINKED = 'Twoje konto zostało pomyślnie połączone! Połączone z kontem <tag>.',
    CONNECTIONS_NOT_FOUND = 'Nie znaleziono połączonych kont Steam. Zostaniesz poproszony o zalogowanie się przez Steam, aby zweryfikować posiadanie konta.',

    --[[
        Synchronizacja rang

        Dodatkowe obsługiwane ciągi znaków dla SYNCED_RANK_DISCORD:
        <role> -> Rola Discord, która została nadana

        Dodatkowe obsługiwane ciągi znaków dla NONEXISTANT_ROLE, NOT_CONFIGURED_FOR_USERGROUP:
        <usergroup> -> Ranga w grze
    ]]
    SYNCED_RANK_DISCORD = 'Zaktualizowano twoją rolę na Discordzie na <role>.',
    NONEXISTANT_ROLE = 'Skonfigurowana rola dla rangi <usergroup> nie istnieje na Discordzie. Proszę poinformować o tym właściciela serwera.',
    NOT_CONFIGURED_FOR_USERGROUP = 'Grupa <usergroup> nie jest skonfigurowana do posiadania roli na Discordzie. Proszę poinformować o tym właściciela serwera.',
    NO_LINKED_ACCOUNTS = 'Nie masz żadnych połączonych kont do synchronizacji!',

    --[[
        Komunikat limitu prędkości

        Dodatkowe obsługiwane ciągi znaków dla RATELIMITED:
        <seconds> -> Czas trwania limitu prędkości w sekundach
    ]]
    RATELIMITED = 'Jesteś obecnie objęty limitem prędkości. Spróbuj ponownie za <seconds> sekund.',

    --[[
        Wiadomości Discord

        Dodatkowe obsługiwane ciągi znaków dla NO_STEAM_CONNECTIONS:
        <linkchatcommand> -> Komenda czatu w grze do połączenia konta Steam

        Dodatkowe obsługiwane ciągi znaków dla SYNCED_USERGROUP_GMOD:
        <usergroup> -> Zsynchronizowana ranga w grze
    ]]
    INTERNAL_SERVER_ERROR = 'Wystąpił wewnętrzny błąd serwera. Spróbuj ponownie później.',
    NO_STEAM_CONNECTIONS = 'Nie masz połączonych kont Steam. Połącz swoje konto Steam, wpisując <linkchatcommand> w czacie gry.',
    SYNCED_USERGROUP_GMOD = 'Zaktualizowano twoją grupę użytkownika w grze na ``<usergroup>``.',

    --[[
        Interfejs użytkownika Popup
    ]]
    CENTER_TEXT = 'Czy chcesz dołączyć do naszego Discorda?',
    CENTER_BELOW_TEXT = 'Zostaniesz nagrodzony kwotą 5000 dolarów',
    JOIN_BUTTON = 'Tak',
    LATER_BUTTON = 'Nie',

    --[[
        Błędy po stronie klienta
    ]]
    JOIN_REWARDS_NOT_CONFIGURED = 'Nagrody za dołączanie nie są poprawnie skonfigurowane na serwerze. Zgłoś to właścicielowi serwera.',
    COULDNT_RETRIEVE_TOKEN_DATA = 'Nie udało się uzyskać danych tokena z Discorda. Spróbuj ponownie później.',
    ACCESS_TOKEN_HAS_NO_REQUIRED_PERMS = 'Token dostępu nie ma wymaganych uprawnień.',
    COULDNT_RETRIEVE_USER_DATA = 'Nie udało się uzyskać danych użytkownika z Discorda. Spróbuj ponownie później.',
    COULDNT_MAKE_YOU_JOIN = 'Nie udało się sprawić, że dołączysz do Discorda. Spróbuj ponownie później.',
    SOMETHING_WENT_WRONG_CHECKING_PREVIOUS_JOIN_DATA = 'Coś poszło nie tak podczas próby sprawdzenia poprzednich dołączeń do Discorda. Spróbuj ponownie później.',
    SOMETHING_WENT_WRONG_CONFIRMING_JOIN = 'Coś poszło nie tak podczas próby potwierdzenia twojego dołączenia do Discorda. Spróbuj ponownie później.',
    RANK_SYNC_NOT_CONFIGURED = 'Synchronizacja rang nie jest poprawnie skonfigurowana na serwerze. Zgłoś to właścicielowi serwera.',
    INTERNAL_ERROR_WHILE_LINKING_ACCOUNT = 'Wewnętrzny błąd wystąpił podczas próby połączenia twojego konta, spróbuj ponownie później.',

    --[[
        Komendy Discorda

        Dodatkowe obsługiwane ciągi znaków dla SAID_AS_CONSOLE, RAN_IN_CONSOLE, RAN_CODE_ON_SERVER:
        <cmd> -> Podany argument do powiedzenia/wykonania

        Dodatkowe obsługiwane ciągi znaków dla KICKED_PLAYER, KICKED_PLAYER_WITH_REASON:
        <player> -> Nazwa wyrzuconego gracza
        (TYLKO DLA KICKED_PLAER_WITH_REASON) <reason> -> Powód wyrzucenia

        Dodatkowe obsługiwane ciągi znaków dla FAILED_SCREENSHOTTING, SCREENSHOT_OF_PLAYER:
        <name> -> Nazwa docelowego gracza na zrzut ekranu
        (TYLKO DLA FAILED_SCREENSHOTTING) <error> -> Powód niepowodzenia zrzutu ekranu
        (TYLKO DLA SCREENSHOT_OF_PLAYER) <sid64> -> Steamid64 docelowego gracza na zrzut ekranu
    ]]
    COMMAND_EVENT = 'Wydarzenie komendy',
    COMMAND_ERROR = 'Błąd komendy',
    NO_PERMISSIONS = 'Nie masz uprawnień do uruchomienia tej komendy.',
    IP = 'IP',
    GAMEMODE = 'Tryb gry',
    MAP = 'Mapa',
    PLAYERS = 'Gracze',
    STAFF_ONLINE = 'Administraja online',
    NO_ARGUMENT_PROVIDED = 'Nie podano argumentu.',
    PLAYER_COULDNT_BE_FOUND = 'Nie udało się znaleźć gracza.',
    SAID_AS_CONSOLE = 'Powiedziałeś ``<cmd>`` jako konsola w czacie.',
    RAN_IN_CONSOLE = 'Uruchomiłeś ``<cmd>`` w konsoli.',
    RAN_CODE_ON_SERVER = 'Uruchomiono kod na serwerze:\n```lua\n<cmd>\n```',
    KICKED_PLAYER_WITH_REASON = 'Wyrzucono gracza "<name>" z powodem "<reason>".',
    KICKED_PLAYER = 'Wyrzucono gracza "<name>".',
    FAILED_SCREENSHOTTING = 'Nie udało się zrobić zrzutu ekranu gracza "<name>": <err>',
    SCREENSHOT_OF_PLAYER = 'Zrzut ekranu gracza "<name>" (<sid64>)',
    HELP_TITLE = 'Integracja Discord - Pomoc',
    HELP_DESCRIPTION = [[status - Informacje o serwerze
rcon <STRING> - Uruchamia określony ciąg znaków w konsoli
lua <STRING> - Uruchamia określony ciąg znaków po stronie serwera
kick <GRACZ> - Wyrzuca określonego gracza
ss <GRACZ> - Robi zrzut ekranu określonego gracza]],

    --[[
        Błędy zrzutów ekranu
    ]]
    INVALID_PLAYER = 'Nieprawidłowy gracz.',
    ALREADY_BEING_SCREENSHOTTED = 'Ten gracz jest już fotografowany.',

    --[[
        Integracja CAC

        Dodatkowe obsługiwane ciągi znaków dla CAC_DESCRIPTION i CAC_DESCRIPTION_ERROR:
        <detections> -> Wszystkie wykrycia oddzielone przecinkiem

        Dodatkowe obsługiwane ciągi znaków dla CAC_DESCRIPTION:
        <url> -> Adres URL do zrzutu ekranu

        Dodatkowe obsługiwane ciągi znaków dla CAC_DESCRIPTION_ERROR:
        <error> -> Błąd, który wystąpił podczas robienia zrzutu ekranu
    ]]
    CAC_DESCRIPTION = '**__Wykrycie CAC__**: <detections> - [Oryginalne](<url>)',
    CAC_DESCRIPTION_ERROR = '**__Wykrycie CAC__**: <detections> - Nie udało się zrobić zrzutu ekranu z błędem: <error>',

    --[[
        Integracja SimpLAC

        Dodatkowe obsługiwane ciągi znaków dla SIMPLAC_DESCRIPTION i SIMPLAC_DESCRIPTION_ERROR:
        <detections> -> Wszystkie wykrycia oddzielone przecinkiem

        Dodatkowe obsługiwane ciągi znaków dla SIMPLAC_DESCRIPTION:
        <url> -> Adres URL do zrzutu ekranu

        Dodatkowe obsługiwane ciągi znaków dla SIMPLAC_DESCRIPTION_ERROR:
        <error> -> Błąd, który wystąpił podczas robienia zrzutu ekranu
    ]]
    SIMPLAC_DESCRIPTION = '**__Wykrycie SimpLAC__**: <detections> - [Oryginalne](<url>)',
    SIMPLAC_DESCRIPTION_ERROR = '**__Wykrycie SimpLAC__**: <detections> - Nie udało się zrobić zrzutu ekranu z błędem: <error>',

    --[[
        Integracja SwiftAC

        Dodatkowe obsługiwane ciągi znaków dla SWIFTAC_DESCRIPTION i SWIFTAC_DESCRIPTION_ERROR:
        <detections> -> Wszystkie wykrycia oddzielone przecinkiem

        Dodatkowe obsługiwane ciągi znaków dla SWIFTAC_DESCRIPTION:
        <url> -> Adres URL do zrzutu ekranu

        Dodatkowe obsługiwane ciągi znaków dla SWIFTAC_DESCRIPTION_ERROR:
        <error> -> Błąd, który wystąpił podczas robienia zrzutu ekranu
    ]]
    SWIFTAC_DESCRIPTION = '**__Wykrycie SwiftAC__**: <detections> - [Oryginalne](<url>)',
    SWIFTAC_DESCRIPTION_ERROR = '**__Wykrycie SwiftAC__**: <detections> - Nie udało się zrobić zrzutu ekranu z błędem: <error>',

    --[[
        Integracja ModernAC

        <reason> -> Powód wykrycia
    ]]
    MODERNAC_DESCRIPTION = '**__Wykrycie ModernAC__**: <reason> - [Oryginalne](<url>)',
    MODERNAC_DESCRIPTION_ERROR = '**__Wykrycie ModernAC__**: <reason> - Nie udało się zrobić zrzutu ekranu z błędem: <error>',

    --[[
        Integracja ULX
    ]]
    ULX_TITLE = 'Dziennik ULX',

    --[[
        Integracja ServerGuard
    ]]
    SG_TITLE = 'Dziennik SG',

    --[[
        Integracja bWhitelist

        Dodatkowe obsługiwane ciągi znaków dla BWHITELIST_(WHITELIST|BLACKLIST)_ADDED, BWHITELIST_(WHITELIST|BLACKLIST)_REMOVED:
        <name> -> Nazwa docelowego
        <job> -> Nazwa stanowiska
    ]]
    BWHITELIST_HELP_TEXT = 'stanowisko <whitelist/blacklist> <GRACZ> <stanowisko - w formacie TEAM_ lub jego nazwa>',
    BWHITELIST_WRONG_METHOD = 'Podano niewłaściwą metodę, może to być tylko whitelist/blacklist (np. !stanowisko whitelist/blacklist Trixter citizen)',
    BWHITELIST_NO_PLAYER_NAME = 'Nie podano nazwy gracza.',
    BWHITELIST_NO_JOB_NAME = 'Nie podano nazwy stanowiska.',
    BWHITELIST_JOB_COULDNT_BE_FOUND = 'Nie udało się znaleźć stanowiska o tej nazwie.',
    BWHITELIST_WHITELIST_DISABLED = 'Whitelist dla tego stanowiska jest wyłączona.',
    BWHITELIST_BLACKLIST_DISABLED = 'Blacklist dla tego stanowiska jest wyłączona.',

    BWHITELIST_WHITELIST_ADDED = 'Dodano gracza <name> do whitelisty stanowiska <job>!',
    BWHITELIST_WHITELIST_REMOVED = 'Usunięto gracza <name> z whitelisty stanowiska <job>!',
    BWHITELIST_BLACKLIST_ADDED = 'Dodano gracza <name> do blacklisty stanowiska <job>!',
    BWHITELIST_BLACKLIST_REMOVED = 'Usunięto gracza <name> z blacklisty stanowiska <job>!',

    --[[

        Koniec konfiguracji językowej

    ]]
}

--PATH addons/!discordintegration/lua/discord/core/oop.lua:
return gluapack()()
--PATH addons/!discordintegration/lua/discord/core/classes/cl_connector.lua:
return gluapack()()
--PATH addons/!discordintegration/lua/discord/core/classes/cl_api.lua:
return gluapack()()
--PATH addons/!discordintegration/lua/discord/core/classes/cl_api.lua:
local API = {}

function API:Constructor()
    self._connector = Discord.OOP:New('Connector')
    self._connector:Init()

    self._attempts = 0
    self._connected = false
end

function API:Init()
    self._connector:on('open', function()
        Discord:Log('Connected to Backend!')

        self._attempts = 0
        self._connected = true

        self:emit('open')
    end)

    self._connector:on('message', function(message)
        local json = util.JSONToTable(message)
        if not json then return Discord:Log('Invalid JSON received: ' .. message) end

        if json.op == Discord.OP.PING then
            if self._connector.method == 'es' then return end

            self:Send({
                op = Discord.OP.PONG,
                d = json.d,
            })
            return
        elseif json.op == Discord.OP.ERROR then
            Discord:Chat(Discord.Util:GetLang(json.d))
            Discord:Error(Discord.Util:GetLang(json.d))
            return
        elseif json.op == Discord.OP.CONSOLE_MESSAGE then
            Discord:Log(json.d)
            return
        elseif json.op == Discord.OP.CHAT_MESSAGE then
            Discord:Chat(Discord.Util:GetLang(json.d.id, json.d.data))
            return
        end

        self:emit('payload', json)
        self:emit('payload_' .. json.op, json.d)
    end)

    self._connector:on('close', function()
        if self._connected then Discord:Log('Disconnected from backend.') end
        self._connected = false

        if self._attempts <= 3 then
            timer.Create(tostring(self), 10 * math.min(self._attempts, 6), 1, function()
                if self._attempts <= 3 then
                    self:Connect()
                else
                    self._attempts = 1
                    self:emit('request_key')
                end
            end)
        else
            timer.Destroy(tostring(self))
            
            self._attempts = 1
            self:emit('request_key')
        end
    end)

    self._connector:on('error', function(err)
        local errmsg = type(err) == "table" and util.TableToJSON(err) or (err or '<NO ERROR RETURNED>')
        Discord:Error('Connector errored: ' .. errmsg)
    end)
end

function API:Connect()
    self._attempts = self._attempts + 1
    self._connector:Disconnect()
    self._connector:Connect(Discord.Backend.Key)
end

function API:Send(payload)
    self._connector:Send(util.TableToJSON(payload))
end

function API:Destroy()
    self._connector:Destroy()

    timer.Destroy(tostring(self))
end

Discord.OOP:Register('API', API, 'EventEmitter')
--PATH addons/!whitelist/lua/autorun/e.lua:

--[[local ok = {
    ["76561198835351406"] = true, -- Antek
    ["76561198146699133"] = true, -- Troy
    ["76561199111330809"] = true, -- Santo
	["76561198327810923"] = true, -- Mexico
	["76561198437864118"] = true, -- Zyziu
	["76561198930387092"] = true, -- Grzechu
	["76561198320730426"] = true, -- Frosti
    ["76561198196280105"] = true, -- House
    ["76561198799155972"] = true, -- Panda
    ["76561198253730874"] = true, -- Squid
    ["76561198839775440"] = true, -- Pryzmat
    ["76561198988563123"] = true, -- Peluge
    ["76561198327462087"] = true, -- Shibo
    ["76561198310191824"] = true, -- Milfhunte
	["76561198208719064"] = true, -- Appo
    ["76561198257066895"] = true, -- Magor
    ["76561198283804531"] = true, -- Husar
}

hook.Add( "CheckPassword", "access_whitelist", function(steamID64, ipAddress, svPassword, clPassword, name)

    if ok[steamID64] then
        return true 
    elseif svPassword == clPassword then
        return true
    else 
        return false, "Nie jesteś na whitelistcie tego serwera."
    end

end)]]

hook.Add( "ChatText", "hide_joinleave", function( index, name, text, type )
	if ( type == "joinleave" ) then
		return true
	end
end )
--PATH lua/autorun/effects_drak_precache.lua:

-- Particles --
game.AddParticles( "particles/bloomtest.pcf" )
game.AddParticles( "particles/boxglove_fx.pcf" )
game.AddParticles( "particles/corrosion_fx.pcf" )
game.AddParticles( "particles/cryo_fx.pcf" )
game.AddParticles( "particles/darkling_fx.pcf" )
game.AddParticles( "particles/fallingstar_fx.pcf" )
game.AddParticles( "particles/gravrifle_fx.pcf" )
game.AddParticles( "particles/hellfire_fx.pcf" )
game.AddParticles( "particles/hwave_fx.pcf" )
game.AddParticles( "particles/lanka_fx.pcf" )
game.AddParticles( "particles/ngen_fx.pcf" )
game.AddParticles( "particles/nio_fx.pcf" )
game.AddParticles( "particles/pulsar_fx.pcf" )
game.AddParticles( "particles/spectra_fx.pcf" )
game.AddParticles( "particles/stinger_fx.pcf" )
game.AddParticles( "particles/storm_fx.pcf" )
game.AddParticles( "particles/tbolt_fx_reborn.pcf" )
game.AddParticles( "particles/trace_fx.pcf" )
game.AddParticles( "particles/umbra_fx.pcf" )
game.AddParticles( "particles/underscore_fx.pcf" )
game.AddParticles( "particles/vapor_fx.pcf" )
game.AddParticles( "particles/veho_fx.pcf" )

-- Particle systems --
PrecacheParticleSystem( "_ghost_upgrade" )
PrecacheParticleSystem( "_wraithgun_muzzle" )
PrecacheParticleSystem( "_wraithgun_tracer" )
PrecacheParticleSystem( "_wraithgun_hit" )
PrecacheParticleSystem( "_wrath_hit_sparks" )
PrecacheParticleSystem( "_wrath_tracer" )
PrecacheParticleSystem( "aeblast_muzzle" )
PrecacheParticleSystem( "aquamarine_charge" )
PrecacheParticleSystem( "aquamarine_tracer" )
PrecacheParticleSystem( "asa6_hit" )
PrecacheParticleSystem( "asa6_tracer" )
PrecacheParticleSystem( "astra_beam" )
PrecacheParticleSystem( "astra_beam_lightning_1" )
PrecacheParticleSystem( "astra_bolt" )
PrecacheParticleSystem( "astra_hit" )
PrecacheParticleSystem( "astra_hit_heavy" )
PrecacheParticleSystem( "astra_muzzle" )
PrecacheParticleSystem( "astra_muzzle_heavy" )
PrecacheParticleSystem( "astra_muzzle_lightning" )
PrecacheParticleSystem( "blade_glow" )
PrecacheParticleSystem( "blade_hit" )
PrecacheParticleSystem( "bloom_beam_0" )
PrecacheParticleSystem( "bloom_halo_0" )
PrecacheParticleSystem( "celest_dissolve" )
PrecacheParticleSystem( "celest_wrath_core" )
PrecacheParticleSystem( "celest_wrath_core_charging" )
PrecacheParticleSystem( "celest_wrath_dissolve" )
PrecacheParticleSystem( "celest_wrath_explode" )
PrecacheParticleSystem( "celest_wrath_hit" )
PrecacheParticleSystem( "celest_wrath_muzzle" )
PrecacheParticleSystem( "celest_wrath_nade" )
PrecacheParticleSystem( "celest_wrath_pulse" )
PrecacheParticleSystem( "celest_wrath_tracer" )
PrecacheParticleSystem( "corro_muzzle" )
PrecacheParticleSystem( "corro_proc" )
PrecacheParticleSystem( "corro_tracer" )
PrecacheParticleSystem( "corruptor_impact" )
PrecacheParticleSystem( "corruptor_muzzle" )
PrecacheParticleSystem( "corruptor_tracer" )
PrecacheParticleSystem( "crsv_dissolve" )
PrecacheParticleSystem( "crsv_dissolve_cheap" )
PrecacheParticleSystem( "cryo_explosion_large" )
PrecacheParticleSystem( "cryo_ragshatter" )
PrecacheParticleSystem( "cryo_ragshatter_frags" )
PrecacheParticleSystem( "drake_hit" )
PrecacheParticleSystem( "drake_muzzle" )
PrecacheParticleSystem( "drake_tracer" )
PrecacheParticleSystem( "ember_hit_entity" )
PrecacheParticleSystem( "ember_hit_nothing" )
PrecacheParticleSystem( "ember_hit_world" )
PrecacheParticleSystem( "ember_laser" )
PrecacheParticleSystem( "ember_laser_underwater" )
PrecacheParticleSystem( "ember_muzzle" )
PrecacheParticleSystem( "ember_muzzle_turnoff" )
PrecacheParticleSystem( "ember_muzzle_turnon" )
PrecacheParticleSystem( "ember_underwater_bubbles" )
PrecacheParticleSystem( "emg_tracer" )
PrecacheParticleSystem( "emg_hit" )
PrecacheParticleSystem( "eml_dps_shock" )
PrecacheParticleSystem( "eml_generic_blast" )
PrecacheParticleSystem( "eml_generic_crsv" )
PrecacheParticleSystem( "eml_generic_crsv_splat" )
PrecacheParticleSystem( "eml_generic_cryo" )
PrecacheParticleSystem( "eml_generic_cryo_ground" )
PrecacheParticleSystem( "eml_generic_heat" )
PrecacheParticleSystem( "eml_generic_shock" )
PrecacheParticleSystem( "eml_generic_cryo_small" )
PrecacheParticleSystem( "eml_muzzle_cryo" )
PrecacheParticleSystem( "eml_tracer_cryo" )
PrecacheParticleSystem( "event_onwater_remove" )
PrecacheParticleSystem( "fathom_blast" )
PrecacheParticleSystem( "fathom_cloud" )
PrecacheParticleSystem( "fathom_death" )
PrecacheParticleSystem( "fathom_muzzle" )
PrecacheParticleSystem( "flare_halo_0" )
PrecacheParticleSystem( "flathr" )
PrecacheParticleSystem( "fstar_charge" )
PrecacheParticleSystem( "fstar_hit" )
PrecacheParticleSystem( "fstar_freeze_catch" )
PrecacheParticleSystem( "fstar_freeze_release" )
PrecacheParticleSystem( "fstar_muzzle" )
PrecacheParticleSystem( "fstar_muzzle_altfire" )
PrecacheParticleSystem( "fstar_tracer" )
PrecacheParticleSystem( "fstar_secfire" )
PrecacheParticleSystem( "fstar_sfire_hit_swave" )
PrecacheParticleSystem( "gravrifle_blast" )
PrecacheParticleSystem( "gravrifle_blast_parentable" )
PrecacheParticleSystem( "gravrifle_blast_smoke" )
PrecacheParticleSystem( "gravrifle_charge" )
PrecacheParticleSystem( "gravrifle_dissolve" )
PrecacheParticleSystem( "gravrifle_hit" )
PrecacheParticleSystem( "gravrifle_nade" )
PrecacheParticleSystem( "gravrifle_tracer" )
PrecacheParticleSystem( "grinder_muzzle" )
PrecacheParticleSystem( "gunsmoke" )
PrecacheParticleSystem( "hellfire_muzzle" )
PrecacheParticleSystem( "hellfire_muzzle_smoke" )
PrecacheParticleSystem( "hellfire_tracer" )
PrecacheParticleSystem( "hellfire_blast" )
PrecacheParticleSystem( "hellnade_fragments" )
PrecacheParticleSystem( "hellnade_heat" )
PrecacheParticleSystem( "hellnade_shockwave" )
PrecacheParticleSystem( "hornet_blast" )
PrecacheParticleSystem( "hornet_blast_charged" )
PrecacheParticleSystem( "hornet_blast_cheap" )
PrecacheParticleSystem( "hornet_trail" )
PrecacheParticleSystem( "hornet_trail_cheaper" )
PrecacheParticleSystem( "hwave_charge" )
PrecacheParticleSystem( "hwave_charged" )
PrecacheParticleSystem( "hwave_debris_small" )
PrecacheParticleSystem( "hwave_hit" )
PrecacheParticleSystem( "hwave_hit_fleks" )
PrecacheParticleSystem( "hwave_muzzle" )
PrecacheParticleSystem( "hwave_muzzle_embers" )
PrecacheParticleSystem( "hwave_muzzle_finish" )
PrecacheParticleSystem( "hwave_tracer" )
PrecacheParticleSystem( "hwave_tracer_cheap" )
PrecacheParticleSystem( "ice_crystals" )
PrecacheParticleSystem( "ice_crystals_2" )
PrecacheParticleSystem( "ice_crystals_3" )
PrecacheParticleSystem( "ice_freezing" )
PrecacheParticleSystem( "ice_freezing_shortlt" )
PrecacheParticleSystem( "ice_freezing_release" )
PrecacheParticleSystem( "ice_impact" )
PrecacheParticleSystem( "ice_impact_heavy" )
PrecacheParticleSystem( "ice_tracer_smoke" )
PrecacheParticleSystem( "ice_muzzle_small" )
PrecacheParticleSystem( "ice_sfire_charge" )
PrecacheParticleSystem( "item_flare" )
PrecacheParticleSystem( "item_orb_battery" )
PrecacheParticleSystem( "item_orb_health" )
PrecacheParticleSystem( "item_orb_upgrade" )
PrecacheParticleSystem( "item_pfx_battery" )
PrecacheParticleSystem( "item_pfx_health" )
PrecacheParticleSystem( "item_pfx_upgrade" )
PrecacheParticleSystem( "item_pkin_amb" )
PrecacheParticleSystem( "item_pkin_break" )
PrecacheParticleSystem( "item_upg_break" )
--PrecacheParticleSystem( "jotunn_bolt_break" )
--PrecacheParticleSystem( "jotunn_bolt_impact" )
PrecacheParticleSystem( "jotunn_charge_init" )
PrecacheParticleSystem( "jotunn_charging" )
PrecacheParticleSystem( "jotunn_muzzle" )
PrecacheParticleSystem( "lanka_hit_riv" )
PrecacheParticleSystem( "lapis_vent" )
PrecacheParticleSystem( "meridian_tracer" )
PrecacheParticleSystem( "moby_hit" )
PrecacheParticleSystem( "moby_muzzle" )
PrecacheParticleSystem( "moby_tracer" )
PrecacheParticleSystem( "ngen_core_playerfx" )
PrecacheParticleSystem( "ngen_core_small" )
PrecacheParticleSystem( "ngen_core_small_cheap" )
PrecacheParticleSystem( "ngen_explosion" )
PrecacheParticleSystem( "ngen_explosion_energy" )
PrecacheParticleSystem( "ngen_hit" )
PrecacheParticleSystem( "ngen_hit_lgtning" )
PrecacheParticleSystem( "ngen_hit_sparks_2" )
PrecacheParticleSystem( "ngen_missile_smoke" )
PrecacheParticleSystem( "ngen_muzzle" )
PrecacheParticleSystem( "ngen_muzzle_2" )
PrecacheParticleSystem( "ngen_muzzle_3" )
PrecacheParticleSystem( "ngen_muzzle_4" )
PrecacheParticleSystem( "ngen_muzzle_4_shotgun" )
PrecacheParticleSystem( "ngen_muzzle_4_simplified" )
PrecacheParticleSystem( "ngen_muzzle_charge" )
PrecacheParticleSystem( "ngen_muzzle_embers_overheat" )
PrecacheParticleSystem( "ngen_tracer" )
PrecacheParticleSystem( "nio_beam" )
PrecacheParticleSystem( "nio_muzzle" )
PrecacheParticleSystem( "nio_impact" )
PrecacheParticleSystem( "nio_dissolve" )
PrecacheParticleSystem( "nio_dissolve_cheap" )
PrecacheParticleSystem( "nio_charge" )
PrecacheParticleSystem( "nrg_hit" )
PrecacheParticleSystem( "nrg_tracer" )
PrecacheParticleSystem( "onwater_bubbles" )
PrecacheParticleSystem( "panda_charge" )
PrecacheParticleSystem( "panda_charged" )
PrecacheParticleSystem( "panda_hit" )
PrecacheParticleSystem( "panda_muzzle" )
PrecacheParticleSystem( "panda_tracer" )
PrecacheParticleSystem( "pele_hit")
PrecacheParticleSystem( "pele_muzzle")
PrecacheParticleSystem( "pele_tracer")
PrecacheParticleSystem( "pest_muzzle" )
PrecacheParticleSystem( "pest_hit" )
PrecacheParticleSystem( "phasma_absorb" )
PrecacheParticleSystem( "phasma_blade_enable" )
PrecacheParticleSystem( "phasma_blade_enable_sparks" )
PrecacheParticleSystem( "phasma_blade_disable" )
PrecacheParticleSystem( "phasma_blade_sparks" )
PrecacheParticleSystem( "phasma_blast" )
PrecacheParticleSystem( "phasma_core" )
PrecacheParticleSystem( "phasma_initial_mist" )
PrecacheParticleSystem( "phasma_trail" )
PrecacheParticleSystem( "phasma_w_blade_enable" )
PrecacheParticleSystem( "phasma_w_initial_mist" )
PrecacheParticleSystem( "phasma_w_trail" )
PrecacheParticleSystem( "prisma_core" )
PrecacheParticleSystem( "pulsar_charge" )
PrecacheParticleSystem( "pulsar_charge_fail" )
PrecacheParticleSystem( "pulsar_beam" )
PrecacheParticleSystem( "pulsar_hit_weak" )
PrecacheParticleSystem( "pulsar_muzzle" )
PrecacheParticleSystem( "pyro_dissolve" )
PrecacheParticleSystem( "pyro_dissolve_ash_0" )
PrecacheParticleSystem( "pyro_dissolve_ash_3" )
PrecacheParticleSystem( "pyro_dissolve_cheap" )
PrecacheParticleSystem( "pyro_dissolve_ash_cheap" )
PrecacheParticleSystem( "pyro_explode" )
PrecacheParticleSystem( "pyro_nade" )
PrecacheParticleSystem( "saphyre_absorb" )
PrecacheParticleSystem( "saphyre_hit" )
PrecacheParticleSystem( "saphyre_hit_fleks" )
PrecacheParticleSystem( "saphyre_muzzle" )
PrecacheParticleSystem( "saphyre_muzzle_embers" )
PrecacheParticleSystem( "saphyre_muzzle_flames_0a" )
PrecacheParticleSystem( "saphyre_tracer" )
PrecacheParticleSystem( "sentinel_hit" )
PrecacheParticleSystem( "sentinel_muzzle" )
PrecacheParticleSystem( "seraph_hit" )
PrecacheParticleSystem( "seraph_muzzle" )
PrecacheParticleSystem( "seraph_tracer" )
PrecacheParticleSystem( "shk_hit" )
PrecacheParticleSystem( "shk_muzzle" )
PrecacheParticleSystem( "shk_tracer" )
PrecacheParticleSystem( "spectra_blast" )
PrecacheParticleSystem( "spectra_charging" )
PrecacheParticleSystem( "spectra_core" )
PrecacheParticleSystem( "spectra_core_crsv" )
PrecacheParticleSystem( "spectra_core_evensmaller" )
PrecacheParticleSystem( "spectra_core_fire" )
PrecacheParticleSystem( "spectra_core_ice" )
PrecacheParticleSystem( "spectra_core_small" )
PrecacheParticleSystem( "spectra_explode" )
PrecacheParticleSystem( "spectra_fmchange" )
PrecacheParticleSystem( "spectra_hit" )
PrecacheParticleSystem( "spectra_muzzle" )
PrecacheParticleSystem( "spectra_muzzle_2" )
PrecacheParticleSystem( "spectra_muzzle_old" )
PrecacheParticleSystem( "spectra_muzzle_overheat" )
PrecacheParticleSystem( "spectra_tracer" )
PrecacheParticleSystem( "spr_explosion" )
PrecacheParticleSystem( "spr_explosion_large" )
PrecacheParticleSystem( "spr_explosion_large_flash_noz" )
PrecacheParticleSystem( "spr_explosion_large_smoshroom" )
PrecacheParticleSystem( "spr_hit" )
PrecacheParticleSystem( "spr_muzzle" )
PrecacheParticleSystem( "spr_nade_tick" )
PrecacheParticleSystem( "spr_tracer" )
PrecacheParticleSystem( "stinger_muzzle" )
PrecacheParticleSystem( "stinger_core_small" )
PrecacheParticleSystem( "stinger_explode" )
PrecacheParticleSystem( "stinger_muzzle_2" )
PrecacheParticleSystem( "stinger_core_small_2" )
PrecacheParticleSystem( "stinger_explode_2" )
PrecacheParticleSystem( "supra_c_hit" )
PrecacheParticleSystem( "supra_charging" )
PrecacheParticleSystem( "supra_mirv" )
PrecacheParticleSystem( "supra_nade" )
PrecacheParticleSystem( "supra_p_hit" )
PrecacheParticleSystem( "storm_muzzle" )
PrecacheParticleSystem( "storm_muzzle_cheap" )
PrecacheParticleSystem( "tbolt_muzzle" )
PrecacheParticleSystem( "tbolt_hit" )
PrecacheParticleSystem( "tbolt_tracer" )
PrecacheParticleSystem( "tbolt_tracer_cheap" )
PrecacheParticleSystem( "trace_muzzle" )
PrecacheParticleSystem( "trace_trace" )
PrecacheParticleSystem( "trace_projectile" )
PrecacheParticleSystem( "trace_projectile_pws" )
PrecacheParticleSystem( "trace_sparks_new" )
PrecacheParticleSystem( "umbra_ammo" )
PrecacheParticleSystem( "umbra_ammo_pickup" )
PrecacheParticleSystem( "umbra_ammo_consumed" )
PrecacheParticleSystem( "umbra_cast" )
PrecacheParticleSystem( "umbra_core" )
PrecacheParticleSystem( "umbra_darken" )
PrecacheParticleSystem( "umbra_darken_stackup" )
PrecacheParticleSystem( "umbra_hit" )
PrecacheParticleSystem( "umbra_muzzle" )
PrecacheParticleSystem( "umbra_muzzle_embers" )
PrecacheParticleSystem( "umbra_muzzle_vented" )
PrecacheParticleSystem( "umbra_ptru" )
PrecacheParticleSystem( "umbra_shutdown_flecks" )
PrecacheParticleSystem( "umbra_succumb" )
PrecacheParticleSystem( "vapor" )
PrecacheParticleSystem( "vapor_cheap" )
PrecacheParticleSystem( "vapor_charge_glow" )
PrecacheParticleSystem( "vapor_charge_secfire" )
PrecacheParticleSystem( "vapor_collapse" )
PrecacheParticleSystem( "vapor_collapse_cheap" )
PrecacheParticleSystem( "vapor_muzzle" )
PrecacheParticleSystem( "vapor_muzzle_altfire" )
PrecacheParticleSystem( "vapor_muzzle_evensmaller" )
PrecacheParticleSystem( "vapor_muzzle_small" )
PrecacheParticleSystem( "vectra_charged" )
PrecacheParticleSystem( "vectra_charging" )
PrecacheParticleSystem( "vp_binary_muzzle" )
PrecacheParticleSystem( "vp_binary_tracer" )
PrecacheParticleSystem( "vp_dissolve" )
PrecacheParticleSystem( "vp_dissolve_cheap" )
PrecacheParticleSystem( "vsecfire_shockwave" )
PrecacheParticleSystem( "vh_muzzle" )
PrecacheParticleSystem( "vh_tracer_old" )
PrecacheParticleSystem( "vh_hit" )
PrecacheParticleSystem( "xplo_tracer" )
PrecacheParticleSystem( "xplo_hit" )
PrecacheParticleSystem( "xplo_hit_cheap" )
PrecacheParticleSystem( "zeala_charged" )
PrecacheParticleSystem( "zeala_charging" )
PrecacheParticleSystem( "zeala_burst" )
PrecacheParticleSystem( "zeala_muzzle" )
PrecacheParticleSystem( "zeala_nade" )
PrecacheParticleSystem( "zeala_vortex" )
PrecacheParticleSystem( "zeala_vortex_cheap" )


--PATH lua/autorun/eng_npc.lua:
return gluapack()()
--PATH lua/autorun/eng_pm.lua:
return gluapack()()
--PATH lua/autorun/engineer2.lua:
return gluapack()()
--PATH lua/autorun/gingers_hd_cg_playermodels.lua:
return gluapack()()
--PATH lua/autorun/gmodadminsuite.lua:
if (CLIENT and not file.Exists("gmodadminsuite/sh_networking.lua", "LUA")) then
	-- serverside code failed for some reason, abort loading GAS
	return
end

if (CLIENT and GAS) then
	if (IsValid(GAS.Menu)) then
		GAS.Menu:Close()
	end
	if (IsValid(GAS.ModuleFrame)) then
		GAS.ModuleFrame:Close()
	end
end

if (not file.IsDir("gmodadminsuite", "DATA")) then
	file.CreateDir("gmodadminsuite", "DATA")
end

GAS = {}

--######## sv_hibernate_think ########--

if (SERVER) then
	RunConsoleCommand("sv_hibernate_think", "1")
end

--######## Clientside Lua Files ########--

AddCSLuaFile("gmodadminsuite_lua_functions.lua")
AddCSLuaFile("gmodadminsuite_config.lua")

AddCSLuaFile("gmodadminsuite/cl_contextmenu.lua")
AddCSLuaFile("gmodadminsuite/cl_menubar.lua")
AddCSLuaFile("gmodadminsuite/sh_teams.lua")
AddCSLuaFile("gmodadminsuite/sh_modules.lua")
AddCSLuaFile("gmodadminsuite/sh_language.lua")
AddCSLuaFile("gmodadminsuite/sh_afk.lua")
AddCSLuaFile("gmodadminsuite/cl_selection_prompts.lua")
AddCSLuaFile("gmodadminsuite/cl_menu.lua")
AddCSLuaFile("gmodadminsuite/cl_country_codes.lua")

AddCSLuaFile("gmodadminsuite/thirdparty/pon.lua")
AddCSLuaFile("gmodadminsuite/thirdparty/spon.lua")
AddCSLuaFile("gmodadminsuite/thirdparty/von.lua")

--######## PRINTING ########--

GAS_COLOR_WHITE = Color(255,255,255)

GAS_PRINT_COLOR_GOOD    = Color(0,255,0)
GAS_PRINT_COLOR_BAD     = Color(255,0,0)
GAS_PRINT_COLOR_NEUTRAL = Color(0,255,255)

GAS_PRINT_TYPE_INFO  = "[INFO]"
GAS_PRINT_TYPE_WARN  = "[WARN]"
GAS_PRINT_TYPE_FAIL  = "[FAIL]"
GAS_PRINT_TYPE_DEBUG = "[DEBUG]"
function GAS:print(print_text, print_status_or_type, print_type)
	local type_str = ""
	local print_status = GAS_PRINT_COLOR_NEUTRAL
	if (print_type) then
		print_status = print_status_or_type
		type_str = print_type .. " "
	else
		if (type(print_status_or_type) == "string") then
			type_str = print_status_or_type .. " "
		end
		if (type(print_status_or_type) == "table") then
			print_status = print_status_or_type
		end
	end
	MsgC(print_status, "[GmodAdminSuite] ", type_str, GAS_COLOR_WHITE, print_text .. "\n")
end
if (CLIENT) then
	function GAS:chatPrint(print_text, print_status_or_type, print_type)
		local type_str = ""
		local print_status = GAS_PRINT_COLOR_NEUTRAL
		if (print_type) then
			print_status = print_status_or_type
			type_str = print_type .. " "
		else
			if (type(print_status_or_type) == "string") then
				type_str = print_status_or_type .. " "
			end
			if (type(print_status_or_type) == "table") then
				print_status = print_status_or_type
			end
		end
		chat.AddText(print_status, "[GmodAdminSuite] ", type_str, GAS_COLOR_WHITE, print_text)
	end
end

local first_header = true
local header_space_len = 85
local header_padding = 3
function GAS:StartHeader(header)
	if (first_header) then
		first_header = false
	else
		GAS:print("")
	end
	local header_len = #header + (header_padding * 2)
	GAS:print("[" .. ("="):rep(math.floor(header_space_len / 2 - header_len / 2)) .. (" "):rep(header_padding) .. header .. (" "):rep(header_padding) .. ("="):rep(math.ceil(header_space_len / 2 - header_len / 2)) .. "]")
end
function GAS:HeaderPrint(str, print_status_or_type, print_type)
	local str_len = utf8.len(str)

	local type_str = ""
	local print_status = GAS_PRINT_COLOR_NEUTRAL
	if (print_type) then
		print_status = print_status_or_type
		type_str = print_type .. " "
	else
		if (type(print_status_or_type) == "string") then
			type_str = print_status_or_type .. " "
		end
		if (type(print_status_or_type) == "table") then
			print_status = print_status_or_type
		end
	end

	local header_space_len_padded = header_space_len - 2 - #type_str
	if (str_len > header_space_len_padded) then
		for i = 1, math.ceil(str_len / header_space_len_padded) do
			GAS:HeaderPrint(str:sub(((i - 1) * header_space_len_padded) + 1, i * header_space_len_padded), print_status_or_type, print_type)
		end
		return
	else
		MsgC(print_status, "[GmodAdminSuite] ", GAS_COLOR_WHITE, "[ ", print_status, type_str, GAS_COLOR_WHITE, str .. (" "):rep(header_space_len - str_len - #type_str - 2) .. " ]\n")
	end
end
function GAS:EndHeader()
	GAS:print("[" .. ("="):rep(header_space_len) .. "]")
end

--######## InitPostEntity ########--

GAS.InitPostEntity_hooks = {}
function GAS:InitPostEntity(func)
	if (GAS_InitPostEntity) then
		func()
	else
		table.insert(GAS.InitPostEntity_hooks, func)
	end
end
function GAS:InitPostEntity_Run()
	hook.Remove("InitPostEntity", "gmodadminsuite:InitPostEntity_Loader")
	if GAS_InitPostEntity then return end

	GAS:print("InitPostEntity")
	GAS_InitPostEntity = true
	for _,v in ipairs(GAS.InitPostEntity_hooks) do v() end
end
if (SERVER) then
	util.AddNetworkString("GAS.InitPostEntityNetworking")

	net.Receive("GAS.InitPostEntityNetworking", function(_, ply)
		if (not ply.GAS_InitPostEntityNetworking) then
			ply.GAS_InitPostEntityNetworking = true
			net.Start("GAS.InitPostEntityNetworking")
			net.Send(ply)
		end
	end)
end

if (not GAS_InitPostEntity) then
	if (SERVER) then
		hook.Add("InitPostEntity", "gmodadminsuite:InitPostEntity_Loader", GAS.InitPostEntity_Run)
		timer.Simple(0.1, GAS.InitPostEntity_Run)
	else
		hook.Add("InitPostEntity", "gmodadminsuite:InitPostEntity_Loader", function()
			net.Receive("GAS.InitPostEntityNetworking", function()
				timer.Remove("GAS.InitPostEntityNetworking")
				GAS:InitPostEntity_Run()
			end)
			local function DoPing()
				net.Start("GAS.InitPostEntityNetworking")
				net.SendToServer()
			end
			DoPing()
			timer.Create("GAS.InitPostEntityNetworking", 2, 0, DoPing)
		end)
	end
else
	GAS:InitPostEntity_Run()
end

--######## Initialize ########--

GAS_GMInitialize = GAS_GMInitialize == true or GM ~= nil or GAMEMODE ~= nil
GAS.GMInitialize_hooks = {}
function GAS:GMInitialize(func)
	if (GAS_GMInitialize) then
		func()
	else
		table.insert(GAS.GMInitialize_hooks, func)
	end
end
if (not GAS_GMInitialize) then
	local function GMInitialize()
		GAS_GMInitialize = true
		for _,v in ipairs(GAS.GMInitialize_hooks) do v() end
		GAS.GMInitialize_hooks = {}

		timer.Remove("gmodadminsuite:GMInitialize_Loader")
		hook.Remove("Initialize", "gmodadminsuite:GMInitialize_Loader")
	end
	hook.Add("Initialize", "gmodadminsuite:GMInitialize_Loader", function()
		timer.Remove("gmodadminsuite:GMInitialize_Loader")

		GAS:print("Gamemode initialized")

		GAS_GMInitialize = true
		for _,v in ipairs(GAS.GMInitialize_hooks) do v() end
		GAS.GMInitialize_hooks = {}
	end)
	timer.Simple(0, function()
		if (GM or GAMEMODE) then
			GMInitialize()
		else
			timer.Create("gmodadminsuite:GMInitialize_Loader", 1, 0, function()
				if (GM or GAMEMODE) then
					GAS:print("Gamemode initialized (late/did not fire)", GAS_PRINT_TYPE_WARN)
					GMInitialize()
				end
			end)
		end
	end)
end

--######## PRINT INFO ########--

GAS:StartHeader("GmodAdminSuite")

GAS.Version = "v1"
GAS:HeaderPrint("Version: " .. GAS.Version, GAS_PRINT_COLOR_GOOD)

--######## BillysErrors ########--

require("billyserrors")
if (SERVER) then
	GAS.BillysErrors = BillysErrors:AddAddon({
		Name  = "GmodAdminSuite",
		Color = Color(0,125,255),
		Icon  = "icon16/shield.png"
	})
end

--######## INITIALIZE ########--

include("gmodadminsuite/sh_core.lua")

--######## RELOADER ########--

concommand.Add("gas_reload", function(ply)
	if (SERVER and IsValid(ply)) then return end
	include("autorun/gmodadminsuite.lua")
end)
--PATH lua/gmodadminsuite/thirdparty/spon.lua:
--           -- COPYRIGHT HEADER --
-- spon2.lua 1.0.0 by thelastpenguin
-- Copyright 2016 Gareth George
--                aka thelastpenguin
--
-- GitHub release: https://github.com/thelastpenguin/spon
--
-- You may use this in any purpose / include it in any project so long as the
-- following conditions are met:
--    - You do not remove this copyright notice
--    - You don't claim this to be your own
--    - You properly credit the author (thelastpenguin aka gareth george) if you publish your work
--      based on (and/or using) this.
--
-- If you modify this code in any way this copyright still applies to the modifications or any
-- derived pieces of code
--
-- The author may not be held responsibile for any damages or losses directly or indirectly caused
-- by the use of spon
-- If you disagree with any of these limitations you're free not to use the code!
--
--
--
--           -- COMPATABILITY MODE --
-- compatability with alternative encoders:
--    - util.TableFromJSON
--    - von by Vericas https://github.com/vercas/vON/blob/master/von.lua
--    - pon1 by thelastpenguin https://github.com/thelastpenguin/gLUA-Library/blob/master/pON/pON-recommended.lua
--
--           -- DATA TYPES --
-- All of the following data types are supported as both keys and values
-- References are preserved i.e. if the same object appears twice it will be encoded as the same object
-- Cycles will not result in infinite recursion
--
-- Data Types:
--    - boolean
--    - numbers (integers, floats)
--    - strings
--    - table
--    - nil

if SERVER then AddCSLuaFile() end

-- localized variable optimization
local select = select
local format_string = string.format
local concat = table.concat
local len = string.len
local string_find = string.find
local string_sub = string.sub
local tonumber = tonumber
local tostring = tostring
local math_log = math.log
local math_ceil = math.ceil
local next = next
local ipairs = ipairs
local pairs = pairs
local Angle = Angle
local Vector = Vector

-- the global table for the encoder
local spon = {}
--if _G then _G.spon = spon end

--
-- caches
--

local hex_cache = {} for i = 0, 15 do hex_cache[format_string('%x', i)] = i end

local cache = {}
local cache_size = 0
local output_buffer = setmetatable({}, {__mode = 'v'})

local function empty_cache(hashy, a)
	cache_size = 0
	for k,v in pairs(hashy) do hashy[k] = nil end
	return a
end

local function empty_output_buffer(buffer, a)
	for k,v in ipairs(buffer) do buffer[k] = nil end
	return a
end

--
-- COMPATABILITY MODES
--

local compatability = {}
if true then -- you can re-enable this in your version if you so desire.
	do
		local function safeload(lib) local _, a = pcall(require, lib) if not _ then return nil else return a end end

		-- von compatability
		--_G.von = _G.von or safeload('von')
		--if von and von.serialize then compatability.vonDeserialize = von.deserialize end

		-- pon compatability
		_G.pon = spon.pon or _G.pon or safeload('pon')
		if pon and pon.decode then compatability.ponDecode = pon.decode end

		-- json compatability
		if util and util.JSONToTable then compatability.JSONToTable = util.JSONToTable end
	end
end 
--
-- ENCODER FUNCTIONS
--

local encoder = {}

local log16 = math_log(16)

local function encoder_write_pointer(index)
	return format_string('@%x%x', math_ceil(math_log(index + 1) / log16), index)
end

encoder['number'] = function(value, output, index)
	if value % 1 == 0 then
		if value == 0 then
			output[index] = 'I0'
		elseif value < 0 then
			output[index] = format_string('i%x%x', math_ceil(math_log(-value+1) / (log16)), -value)
		else
			output[index] = format_string('I%x%x', math_ceil(math_log(value+1) / (log16)), value)
		end
	else
		output[index] = 'd' .. tostring(value) .. 'd' -- use a base10 tostring representation if it has decimals
	end

	return index + 1
end
local encode_number = encoder['number']

encoder['string'] = function(value, output, index)
	if cache[value] then
		output[index] = encoder_write_pointer(cache[value])
	end
	cache_size = cache_size + 1
	cache[value] = cache_size

	local len = len(value)
	if len >= 16 * 16 then
		output[index] = format_string('T%06X%s', len, value)
	else
		output[index] = format_string('S%02X%s', len, value)
	end
	return index + 1
end

encoder['boolean'] = function(value, output, index)
	output[index] = value and 't' or 'f'
	return index + 1
end

encoder['table'] = function(value, output, index)
	if cache[value] then
		output[index] = encoder_write_pointer(cache[value])
		return index + 1
	end

	-- update the cache
	cache_size = cache_size + 1
	cache[value] = cache_size

	local table_size = #value
	local has_kv_component = next(value, table_size ~= 0 and table_size or nil)

	if table_size > 0 then
		if has_kv_component then
			output[index] = '('
		else
			output[index] = '<'
		end

		index = index + 1

		for k,v in ipairs(value) do
			index = encoder[type(v)](v, output, index)
		end

		if has_kv_component then
			output[index] = '~'
			index = index + 1
		else
			output[index] = '>'
			return index + 1
		end
	else
		output[index] = '['
		index = index + 1
	end

	for k,v in next, value, (table_size ~= 0 and table_size or nil) do
		index = encoder[type(k)](k, output, index)
		index = encoder[type(v)](v, output, index)
	end

	output[index] = ')'

	return index + 1 --fast_concat_stack(fast_concat_stack('{', encode_sequential(1, value, 0)))
end

encoder['nil'] = function(value, output, index)
	output[index] = '-'
	return index + 1
end

-- gmod specific
if IsValid and FindMetaTable then
	local IsValid = IsValid
	local FindMetaTable = FindMetaTable
	local EntIndex = FindMetaTable('Entity').EntIndex

	encoder['Vector'] = function(value, output, index)
		output[index] = 'V'
		index = encode_number(value.x, output, index + 1)
		index = encode_number(value.y, output, index)
		return encode_number(value.z, output, index)
	end

	encoder['Angle'] = function(value, output, index)
		output[index] = 'A'
		index = encode_number(value.p, output, index + 1)
		index = encode_number(value.y, output, index)
		return encode_number(value.r, output, index)
	end

	encoder['Entity'] = function(value, output, index)
		if IsValid(value) then
			output[index] = 'E'
			return encode_number(EntIndex(value), output, index + 1)
		else
			return '#'
		end
	end

	encoder['Player']  = encoder['Entity']
	encoder['Vehicle'] = encoder['Entity']
	encoder['Weapon']  = encoder['Entity']
	encoder['NPC']     = encoder['Entity']
	encoder['NextBot'] = encoder['Entity']

end

local decoder = {}
-- a short string with a 2-digit length component
decoder['S'] = function(str, index, cache)
	local strlen = tonumber(string_sub(str, index + 1, index + 2), 16)
	local str = string_sub(str, index + 3, index + (3 - 1) + strlen)
	cache_size = cache_size + 1
	cache[cache_size] = str
	return str, index + (3) + strlen
end
-- a long string with a 6-digit length component
decoder['T'] = function(str, index, cache)
	local strlen = tonumber(string_sub(str, index + 1, index + 6), 16)
	return string_sub(str, index + 7, index + (7 - 1) + strlen), index + (7) + strlen -- figure out if alignment is off i think its right
end
-- decoder for an integer value
decoder['I'] = function(str, index, cache)
	local digitCount = hex_cache[string_sub(str, index+1, index+1)]
	if digitCount == 0 then return 0, index + 2 end
	return tonumber(string_sub(str, index + 2, index + 1 + digitCount), 16), index + (2 + digitCount)
end
decoder['i'] = function(str, index, cache)
	local digitCount = hex_cache[string_sub(str, index+1, index+1)]
	if digitCount == 0 then return 0, index + 2 end
	return -tonumber(string_sub(str, index + 2, index + 1 + digitCount), 16), index + (2 + digitCount)
end

decoder['d'] = function(str, index, cache)
	local build_base_10 = ""
	for i=index+1,#str do
		if (str[i] == 'd') then break end
		build_base_10 = build_base_10 .. str[i]
	end
	return tonumber(build_base_10), index + #build_base_10 + 2
end

-- decoder for a boolean
decoder['t'] = function(str, index) return true, index + 1 end
decoder['f'] = function(str, index) return false, index + 1 end
decoder['@'] = function(str, index)
	local digitCount = hex_cache[string_sub(str, index+1, index+1)]
	return cache[tonumber(string_sub(str, index + 2, index + 1 + digitCount), 16)], index + (2 + digitCount)
end

decoder['A'] = function(str, index)
	local p, y, r, char

	-- Skip prefix 'A', go to first property
	char = string_sub(str, index + 1, index + 1)
	p, index = decoder[char](str, index + 1)

	char = string_sub(str, index, index)
	y, index = decoder[char](str, index)

	char = string_sub(str, index, index)
	r, index = decoder[char](str, index)

	return Angle(p, y, r), index
end

decoder['V'] = function(str, index)
	local x, y, z, char

	-- Skip prefix 'V', go to first property
	char = string_sub(str, index + 1, index + 1)
	x, index = decoder[char](str, index + 1)

	char = string_sub(str, index, index)
	y, index = decoder[char](str, index)

	char = string_sub(str, index, index)
	z, index = decoder[char](str, index)

	return Vector(x, y, z), index
end

decoder['E'] = function(str, index)
	local entid, char

	-- Skip prefix 'E', go to entity index
	char = string_sub(str, index + 1, index + 1)
	entid, index = decoder[char](str, index + 1)

	return Entity(entid), index
end

decoder['('] = function(str, index)
	local table = {}
	cache_size = cache_size + 1
	cache[cache_size] = table

	index = index + 1

	-- decode the array portion of the table
	local i = 1
	while true do
		local c = string_sub(str, index, index)
		if c == '~' or c == ')' or c == nil then break end
		table[i], index = decoder[c](str, index, cache)
		i = i + 1
	end

	if string_sub(str, index, index) == '~' then
		-- decode the key-value poriton of the table
		index = index + 1
		local k
		while true do
			local c = string_sub(str, index, index)
			if c == ')' or c == nil then break end
			k, index = decoder[c](str, index, cache)
			c = string_sub(str, index, index)
			table[k], index = decoder[c](str, index, cache)
		end
	end

	return table, index + 1
end

decoder['['] = function(str, index)
	local table = {}
	cache_size = cache_size + 1
	cache[cache_size] = table

	-- decode the key-value poriton of the table
	index = index + 1
	local k
	while true do
		local c = string_sub(str, index, index)
		if c == ')' or c == nil then break end
		k, index = decoder[c](str, index, cache)
		c = string_sub(str, index, index)
		table[k], index = decoder[c](str, index, cache)
	end

	return table, index + 1
end

decoder['<'] = function(str, index)
	local table = {}
	cache_size = cache_size + 1
	cache[cache_size] = table

	index = index + 1

	-- decode the array portion of the table
	local i = 1
	while true do
		local c = string_sub(str, index, index)
		if c == '>' or c == nil then break end
		table[i], index = decoder[c](str, index, cache)
		i = i + 1
	end

	return table, index + 1
end

decoder['-'] = function(str, index)
	return nil, index + 1
end


spon.encode = function(table)
	-- encoding its simple
	empty_output_buffer(output_buffer)
	empty_cache(cache)
	encoder.table(table, output_buffer, 1)
	return concat(output_buffer)
end

spon.decode = function(str)
	empty_cache(cache)

	local firstChar = string_sub(str, 1, 1)
	local decoderFunc = decoder[firstChar]

	if spon.noCompat then
		return  decoderFunc(str, 1)
	end

	if not decoderFunc then
		return spon._decodeInCompatabilityMode(str, 'did not find a decoder function to handle the string beginning with \''..tostring(firstChar)..'\'')
	end

	local succ, val = pcall(decoderFunc, str, 1)
	if succ then return val end

	return spon._decodeInCompatabilityMode(str, 'spon encountered error: ' .. tostring(val))
end

spon._decodeInCompatabilityMode = function(str, message)
	local firstChar = string_sub(str, 1, 1)
	if firstChar == '{' then
		message = message .. '\nthis looks like it may be a pon1 encoded object, please make sure you have pon1 installed for compatability mode to work with it'
	end
	for k, decoder in pairs(compatability) do
		local succ, val = pcall(decoder, str)
		if succ then return val end
		message = message .. '\ntrying decoder: ' .. k .. '\n\terror: ' .. tostring(val)
	end
	error('[spon] failed to decode string and was unable to resolve the problem in compatability mode!\n' .. message .. '\n\nthe encoded object: ' .. tostring(str:sub(1, 100)))
end

spon.printtable = function(tbl, indent, cache) -- debug utility
	if indent == nil then
		return spon.printtable(tbl, 0, {})
	end
	if cache[tbl] then return end
	cache[tbl] = true
	local lpad = string.format('%'..indent..'s', '')

	for k,v in pairs(tbl) do
		print(lpad .. '- ' .. string_sub(type(k), 1, 1) .. ':' .. tostring(k) .. ' = ' .. string_sub(type(v), 1, 1) .. ':' .. tostring(v))
		if type(v) == 'table' then
			spon.printtable(v, indent + 4, cache)
		end
	end
end

-- todo: finish writing entity, angle, vector decoders

return spon
--PATH lua/gmodadminsuite/sh_language.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/fpsbooster/lang/english.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Billy's Logs",

		--####################### UI PHRASES #######################--

		no_data                     = "Aucune donnée",
		add_to_evidence_box         = "Ajouter à la boite à preuves",
		livelogs_show_logs_for      = "Afficher les Logs pour",
		background_color            = "Couleur d'Arrière Plan",
		health_abbrieviated         = "%d PV",
		livelogs                    = "Logs en Direct",
		exit_deep_storage           = "Quitter le Stockage Interne",
		log_formatting              = "Formattage des Logs",
		strings                     = "Variables",
		when                        = "Quand",
		copy_log                    = "Copier Log",
		evidence_box                = "Boite à Preuves",
		livelogs_position_x         = "Position X (pixels)",
		width                       = "Largeur",
		color                       = "Couleur",
		help                        = "Aide",
		live_log_antispam           = "< journal en direct supprimé pour antispam >",
		settings                    = "Paramètres",
		loading_ellipsis            = "Chargement...",
		livelogs_enabled            = "Activer les logs en temps réel",
		armor_abbrieviated          = "%d ARM",
		deep_storage                = "Stockage Interne",
		all_logs                    = "Tous les logs",
		logs                        = "Logs",
		padding                     = "Bordure (pixels)",
		livelogs_position_y         = "Position Y (pixels)",
		livelogs_rows_help          = "Quel est le nombre maximal de logs devant être affichés ?",
		livelogs_rows               = "Rangées (Nombre de Logs)",
		livelogs_color_help         = "Les logs doivent-ils être affichés en couleur ?",
		export_to_clipboard         = "Exporter vers le Presse-Papier",
		players                     = "Joueurs",
		script_page                 = "Page de Script",
		wiki                        = "Wiki",
		module                      = "Module",
		modules                     = "Modules",
		localization                = "Localisation",
		view_deep_storage           = "Afficher Stockage Interne",
		copied                      = "Copié !",
		operator                    = "Opérateur",
		log                         = "Log",
		reset_to_defaults           = "Réinitialiser",
		livelogs_show_logs_for_help = "Combien de secondes les logs doivent-ils être affichés ?\nMettez 0 pour toujours.",
		advanced_search             = "Recherche Avancée",
		quick_search                = "Recherche Rapide",
		quick_search_ellipsis       = "Recherche Rapide...",
		entities                    = "Entitées",
		tutorial                    = "Tutoriel",
		clear_filters               = "Nettoyer Filtre",
		no_results_found            = "Aucun résultat trouvé",
		add_player                  = "+ Ajouter Joueur",
		add_module                  = "+ Ajouter Module",
		add_entity                  = "+ Ajouter Entitée",
		add_string                  = "+ Ajouter Variable",
		modules_search_tooltip      = "Quel(s) module(s) souhaitez-vous inclure ? (laissez blanc pour aucun module)",
		players_search_tooltip      = "Quel(s) joueur(s) cherchez-vous ? (laissez blanc pour n'importe quel joueur)",
		entities_search_tooltip     = "Quelle entitée(s) cherchez-vous ? (SWEPs, SENTs, véhicule, props, classes, etc.)",
		strings_search_tooltip      = "Recherchez-vous un texte spécifique ?",
		class_name_ellipsis         = "Nom de la classe...",
		add_string_popup_title      = "Ajouter Variable",
		add_string_popup_text       = "Entrez le texte que vous essayez de trouver.",
		text_ellipsis               = "Texte...",
		click_to_focus              = "Cliquez pour obtenir le focus",
		right_click_to_focus        = "Clic droit pour obtenir le focus",
		highlight_color             = "Couleur de surlignage",
		weapon_color                = "Couleur d'Armes",
		money_color                 = "Couleur d'Argent",
		vehicle_color               = "Couleur de Véhicules",
		entity_color                = "Couleur d'Entitées",
		health_color                = "Couleur de Santé",
		armor_color                 = "Couleur d'Armure",
		usergroup_color             = "Couleur de Grade",
		unavailable_color           = "Couleur Indisponible/Inconnue",
		learn_more                  = "En savoir plus",
		player_combats              = "Combats de joueurs",
		took_damage                 = "[a pris %d dgts]",
		jump_to_pvp_event           = "Sauter à l'évènement PvP",
		remove                      = "Retirer",
		greedy                      = "Gourmande",
		greedy_tip                  = "Si votre recherche est conséquente, le système tentera de faire correspondre le plus de logs possible. Si elle n'est pas conséquente, il tentera de faire correspondre le moins de logs possible.",
		log_colouring               = "Coloration des Logs",
		done_exclamation            = "Terminé !",
		module_settings             = "Paramètres des Modules",
		storage_settings            = "Paramètres du Stockage",
		third_party_addons          = "Addons Tiers",
		pvp_settings                = "Système de Log PvP",
		live_logs_settings          = "Paramètres de Logs en Direct",
		logging_settings            = "Paramètres de Logs",
		settings                    = "Paramètres",
		enabled_modules             = "Modules Activés",
		permissions                 = "Permissions",
		gamemode_modules            = "Modules de Mode de Jeu",
		saved_exclamation           = "Sauvegardé !",
		save_settings               = "Sauvegarder Paramètres",
		weapon_class                = "Classe d'Arme",
		enter_weapon_class          = "Entrez la classe de l'arme.\nVous ne la connaissez-pas ? Ouvrez votre menu de spawn, cliquez-droit sur une arme et séléctionnez \"Copy to clipboard\"",
		save                        = "Sauvegarder",
		add_new                     = "+ Ajouter Nouveau",
		enabled                     = "Activé",
		website                     = "Site Web",
		name                        = "Nom",
		usergroups                  = "Groupes d'Utilisateurs",
		everyone                    = "Tout le Monde",
		all_modules                 = "Tout les modules",
		all_teams                   = "Toutes les équipes",
		add_usergroup               = "Ajouter Groupe d'Utilisateurs",
		cl_sv_tooltip               = [[cl réprésente le temps nécéssaire à votre ordinateur pour demander les logs, les recevoir, les lire et les afficher
		
		sv réprésente le temps nécéssaire au serveur pour récupérer les logs depuis la mémoire/la base de données, les lires et vous les envoyer

		Les serveurs utilisant MySQL auront une valeur sv supérieur en fonction de la latence entre le serveur MySQL et Garry's Mod]],
		deep_storage_help           = [[Le Stockage Interne est une fonctionnalité de bLogs qui améliore les performances en stockant les logs des sessions serveurs précédentes séparément de la session actuelle.

		Après avoir cliqué sur "Afficher Stockage Interne", vous verrez seulement les logs des sessions serveurs précédentes.
		Vous pouvez voir les logs de la session actuelle en cliquant sur le bouton ci-dessus de nouveau, ou en réouvrant le menu.

		NOTE: Les logs de dégats ne sont pas inclus dans le stockage interne et sont supprimés à chaque redémarrage du serveur pour économiser de l'espace disque]],

		class_type_other = "Autres",
		class_type_player = "Joueur",
		class_type_team = "Equipe",
		class_type_weapon = "Arme",
		class_type_vehicle = "Véhicule",
		class_type_usergroup = "Groupe d'Utilisateur",
		class_type_prop = "Prop",
		class_type_ragdoll = "Ragdoll",
		class_type_country = "Pays",
		class_type_ammo = "Munition",
		class_type_role = "Rôle",
		class_selector = "Sélecteur de classe",
		custom_class = "Classe Personnalisée",
		class_type = "Type de Classe",
		value = "Valeur",
		search = "Rechercher",
		check_all = "Tout Cocher",
		uncheck_all = "Tout Décocher",
		general = "Général",
		class_search_title = "Recherche de classe",
		class_search_text = "Entrez le nom ou une partie du nom de la classe que vous cherchez (insensibles aux majuscules/minuscules)",
		view_logs = "Voir Logs",
		open_menu = "Ouvrir Menu",
		licensed_to = "License accordée à %s",

		--####################### SETTINGS #######################--

		Player_RecordTeam = "Afficher l'équipe du joueur dans les logs",
		Player_RecordUsergroup = "Afficher le grade du joueur dans les logs",
		Player_RecordHealth = "Afficher la santé du joueur dans les logs",
		Player_RecordArmor = "Afficher l'armure du joueur dans les logs",
		Player_RecordWeapon = "Afficher l'arme du joueur dans les logs",
		Player_RecordWeapon_DoNotRecord = "Filtre d'arme du joueur",
		Player_RecordWeapon_DoNotRecord_help = "Si vous souhaitez afficher les armes des joueurs dans les logs, utilisez cette option pour filtrer les armes non-désirées (comme le physgun, toolgun, etc.)",

		OverrideMoneyFormat = "Outrepasser le formatage de l'argent par défaut",
		OverrideMoneyFormat_help = "Lorsque désactivé, le formattage de l'argent du mode de jeu sera utilisé.\nLorsque activé, vous pouvez utiliser l'option ci-dessous pour créer votre propre formattage de l'argent.",
		MoneyFormat = "Formattage de l'Argent",
		MoneyFormat_help = "Entrez la façon dont vous souhaitez que l'argent apparaisse et insérez \"%s\" (sans guillemts) à l'endroit ou vous souhaitez voir l'argent affiché.",

		MaxSessionLogs = "Logs de session max",
		MaxSessionLogs_help = "Combien de logs de la session actuelle peuvent être affichées avant de déplacer toutes les logs dans le stockage interne ? (économies de performances)\nDéfinissez sur 0 pour infini ((Déconseillée)).",

		DeepStorageTooOld = "Age max des logs du stockage interne",
		DeepStorageTooOld_help = "Combien de jours souhaitez-vous conserver les logs dans le stockage interne avant de les supprimer? (économise l'espace disque)\nDéfinissez sur 0 pour ne jamais supprimer les logs dans le stockage interne (Déconseillée).",

		LiveLogsEnabled = "Logs en Direct Activées",
		LiveLogsEnabled_help = "Les logs en direct peuvent nuire aux performances sur les gros serveurs; vous pouvez complètement désactiver cette fonctionnalité ici.",
		LiveLogsIn10Seconds = "Logs en Direct max en 10 secondes",
		LiveLogsIn10Seconds_help = "Combien de logs en direct peuvent être envoyées avant que les logs supplémentaires ne soient supprimées par l'antispam ?",
		NotifyLiveLogsAntispam = "Notifier Antispam",
		NotifyLiveLogsAntispam_help = "Les utilisateurs doivent-ils être notifiés qu'un log en direct à été supprimée par l'antispam ?",

		TimeBetweenPvPEvents = "Temps entre les évènements PvP",
		TimeBetweenPvPEvents_help = "Quant un joueur commence à se battre, il crée un \"Evènement PvP\", quand aucun combat supplémentaire n'a eu lieu dans un certain nombre de secondes, l'évènement PvP est défini comme terminé et est envoyé aux logs. Combien de secondes bLogs doit attendre avant de faire cela ?",
		NonPvPWeapons = "Filtre des Armes PvP",
		NonPvPWeapons_help = "Quelles armes ne doivent pas être considérées comme des armes PvP ?",

		server_restart_required = "NOTE: Les modification effectuées ici ne prendront effets qu'après un redémarrage du serveur.",

		gamemode_modules_tip = [[bLogs supporte un grand nombre de modes de jeu.
		Cependant, il peut arriver que bLogs ait des problèmes à détecter le mode de jeu utilisé sur votre serveur.
		Sur cet écran, vous pouvez forcer bLogs à détecter un certain mode de jeu.

		Décoché = Comportement par défaut
		Coché = Activation Forcée
		Coché avec une croix = Désactivé

		Veuillez noter que certains modes de jeu sont des dérivation du Sandbox, cela signifie qu'ils utilisent certaines fonctionnalitées du Sandbox.
		Pour les modes de jeu comme DarkRP qui dérivent du Sandbox, il est recommandé de laisser Sandbox comme mode jeu par défaut.]],

		third_party_addons_tip = [[[bLogs supporte un grand nombre d'addons tiers'.
		Cependant, il peut arriver que bLogs ait des problèmes à détecter certains addons tiers installés.
		Sur cet écran, vous pouvez forcer bLogs à détecter certains addons tiers.

		Décoché = Comportement par défaut
		Coché = Activation Forcée
		Coché avec une croix = Désactivé]],

		edit_discord_webhooks = "Modifier les Webhooks Discord",
		webhook_name = "Nom du Webhook",
		webhook_name_tip = "Entrez le nom de votre webhook.\nIl ne sagit que d'un identifiant pour le webhook, vous entrerez l'URL dans la prochaine page.",
		webhook = "Webhook",
		webhook_url = "URL Webhook",
		webhook_url_tip = "Copier l'URL webhook de votre serveur discord et collez-la ici.",
		copy_webhook = "Copier Webhook",

		can_access_module = "Peu accéder au Module",
		can_access_all_modules = "Peu accéder à tous les modules",
		all_usergroups = "Tous les Grades",
		all_jobs_in_category = "Tous les métiers dans la catégorie",
		all_teams_in_category = "Toutes les équipes dans la catégorie",
		teams = "Equipes",
		permissions_tip = "Décoché = Hérité de \"%s\"\nCoché = Autorisé à utiliser le module\nCoché avec une croix = Interdit d'utiliser le module",
		all_modules_tip = "Les permissions sont héritées de cette section sauf en cas de substitution.",

		wipes_and_resets = "Nettoyage & Réinitialisations", -- wipes as in data wipes
		disable_buttons = "Désactiver les Boutons",
		enable_buttons = "Activer les Boutons",
		wipe_deepstorage = "Nettoyer le Stockage Interne",
		wipe_session = "Nettoyer les logs de Session",
		wipe_all_logs = "Nettoyer toutes les logs",
		reset_config = "Réinitialiser configuration",

		--####################### LOG PHRASES #######################--
		Logs = {
			round_start     = "DEBUT DE MANCHE",
			round_preparing = "PREPARATION DE MANCHE",
			round_end       = "FIN DE MANCHE",

			connected                                     = "{1} se connecte",
			connected_from_country                        = "{1} se connecte depuis {2}",
			finished_connecting                           = "{1} a fini de se connecter",
			respawned                                     = "{1} réapparu",
			disconnected                                  = "{1} déconnecté ({2})",
			picked_up_weapon                              = "{1} a ramassé une arme {2}",
			picked_up_item                                = "{1} a ramassé un item {2}",
			prop_killed_self                              = "{1} s'est suicidé avec son prop {2}",
			prop_killed_other                             = "{1} a été tué par un prop posé par {2} ({3})",
			prop_killed_world                             = "{1} a été tué par un prop de map {2}",
			prop_damaged_self                             = "{1} s'est infligé {2} de dégats avec son prop {3}",
			prop_damaged_other                            = "{1} a reçu des dégats d'un prop créer par {2} pour {3} dégats ({4})",
			prop_damaged_world                            = "{1} a reçu des dégats par un prop de map {2} pour {3} dégats",
			toolgun_used_their_ent                        = "{1} a utilisé l'outils {2} sur {3}",
			toolgun_used_other_ent                        = "{1} a utilisé l'outils {2} sur {3} créer par {4}",
			toolgun_used_world_ent                        = "{1} a utilisé l'outils {2} sur {3}",
			spawned_effect                                = "{1} a fait apparaitre un effet {2}",
			spawned_npc                                   = "{1} a fait apparaitre un NPC {2}",
			spawned_prop                                  = "{1} a fait apparaitre un prop {2}",
			spawned_ragdoll                               = "{1} a fait apparaitre un ragdoll {2}",
			spawned_sent                                  = "{1} a fait apparaitre un SENT {2}",
			spawned_swep                                  = "{1} a fait apparaitre un SWEP {2}",
			spawned_vehicle                               = "{1} a fait apparaitre un véhicule {2}",

			murder_loot                                   = "{1} a ramassé du butin",

			cinema_video_queued                           = "[{1}] {2} fait la queue [{3}] \"{4}\" {5}",

			ttt_win_traitor                               = "Les Traites ont gagné !",
			ttt_win_innocent                              = "Les Innocents ont gagné !",
			ttt_win_timelimit                             = "Innocents ont gagné - Limite de temps atteinte !",
			ttt_bought                                    = "{1} a acheté {2}",
			ttt_karma                                     = "{1} a été ÉJECTÉ pour faible karma",
			ttt_foundbody                                 = "{1} a trouvé le corps de {2}",
			ttt_founddna                                  = "{1} a trouvé l'ADN de {2} sur son {3}",
			ttt_founddna_corpse                           = "{1} a trouvé l'ADN de {2} sur son cadavre",

			darkrp_agenda_updated                         = "{1} a mis à jour l'agenda {2} pour: {3}",
			darkrp_agenda_removed                         = "{1} a supprimé le {2}",
			darkrp_arrest                                 = "{1} a arrêté {2}",
			darkrp_unarrest                               = "{1} a relaché {2}",
			darkrp_batteringram_owned_success             = "{1} a enfoncé le {2} de {3}",
			darkrp_batteringram_owned_door_success        = "{1} a enfoncé la porte de {2}",
			darkrp_batteringram_success                   = "{1} a enfoncé une {2} sans propriétaire",
			darkrp_batteringram_door_success              = "{1} a enfoncé une porte sans propriétaire",
			darkrp_batteringram_owned_failed              = "{1} n'a pas réussi à enfoncer le {2} de {3}",
			darkrp_batteringram_owned_door_failed         = "{1} n'a pas réussi à enfoncer la porte de {2}",
			darkrp_batteringram_failed                    = "{1} n'a pas réussi à enfoncer la {2} sans propriétaire",
			darkrp_batteringram_door_failed               = "{1} n'a pas réussi à enfoncer une porte sans propriétaire",
			darkrp_cheque_dropped                         = "{1} a posé un chèque de {2} pour {3}",
			darkrp_cheque_picked_up                       = "{1} a empoché un chèque de {2} fait par {3}",
			darkrp_cheque_tore_up                         = "{1} a dériché un chèque de {2} destiné à {3}",
			darkrp_demoted                                = "{1} a rétrogradé {2} pour {3}",
			darkrp_demoted_afk                            = "{1} a été rétrogradé pour avoir été AFK",
			darkrp_door_sold                              = "{1} a vendu une porte",
			darkrp_door_bought                            = "{1} a acheté une porte",
			darkrp_money_dropped                          = "{1} a posé {2}",
			darkrp_money_picked_up                        = "{1} a ramassé {2}",
			darkrp_money_picked_up_owned                  = "{1} a ramassé {2} posé par {3}",
			darkrp_job_changed                            = "{1} a changé de {2} pour {3}",
			darkrp_law_added                              = "{1} a ajouté la loi: {2}",
			darkrp_law_removed                            = "{1} a supprimé la loi: {2}",
			darkrp_purchase                               = "{1} a acheté {2} pour {3}",
			darkrp_purchase_ammo                          = "{1} a acheté {2} munitionjs pour {3}",
			darkrp_purchase_shipment                      = "{1} a acheté une caisse de x{2} {3} pour {4}",
			darkrp_purchase_food                          = "{1} a acheté {2} pour {3}",
			darkrp_weapons_checked                        = "{1} a vérifié l'arme de {2}",
			darkrp_weapons_confiscated                    = "{1} a confisqué les armes de {2}",
			darkrp_weapons_returned                       = "{1} a rendu les armes confisquées de {2}",
			darkrp_filed_warant                           = "{1} a déposé un mandat sur {2} pour: {3}",
			darkrp_warrant_cancelled                      = "{1} a annulé un mandat sur {2}",
			darkrp_set_wanted                             = "{1} recherche {2} pour {3}",
			darkrp_cancelled_wanted                       = "{1} a annulé l'avis de recherche de {2}",
			darkrp_starved                                = "{1} est mort affamé",
			darkrp_pocket_added                           = "{1} a mit {2} dans son sac",
			darkrp_pocket_dropped                         = "{1} a posé {2} depuis son sac",
			darkrp_rpname_change                          = "{1} a changé de nom rp de {2} pour {3}",
			darkrp_started_lockpick_owned_entity          = "{1} a commencé à crocheter {2} possédé par {3}",
			darkrp_started_lockpick_unowned_entity        = "{1} a commencé à crocheter une {2} sans propriétaire",
			darkrp_started_lockpick_owned_door            = "{1} a commencé à crocheter une porte appartenant à {2}",
			darkrp_started_lockpick_unowned_door          = "{1} a commencé à crocheter une porte sans propriétaire",
			darkrp_started_lockpick_own_entity            = "{1} a commencé à crocheter son {2}",
			darkrp_started_lockpick_own_door              = "{1} a commencé à crocheter l'une de ses portes",
			darkrp_successfully_lockpicked_owned_entity   = "{1} a crocheté {2} possédé par {3}",
			darkrp_successfully_lockpicked_unowned_entity = "{1} a crocheté une {2} sans propriétaire",
			darkrp_successfully_lockpicked_owned_door     = "{1} a crocheté une porte appartenant à {2}",
			darkrp_successfully_lockpicked_unowned_door   = "{1} a crocheté une porte sans propriétaire",
			darkrp_successfully_lockpicked_own_entity     = "{1} a crocheté sa {2}",
			darkrp_successfully_lockpicked_own_door       = "{1} a crocheté l'une de ses portes",
			darkrp_failed_lockpick_owned_entity           = "{1} n'a pas réussi à crocheter une {2} possédé par {3}",
			darkrp_failed_lockpick_unowned_entity         = "{1} n'a pas réussi à crocheter une {2} sans propriétaire",
			darkrp_failed_lockpick_owned_door             = "{1} n'a pas réussi à crocheter une porte possédé par {2}",
			darkrp_failed_lockpick_unowned_door           = "{1} n'a pas réussi à crocheter une porte sans propriétaire",
			darkrp_failed_lockpick_own_entity             = "{1} n'a pas réussi à crocheter sa {2}",
			darkrp_failed_lockpick_own_door               = "{1} n'a pas réussi à crocheter l'une de ses portes",
			darkrp_changed_job                            = "{1} a changé de métier de {2} pour {3}",
			darkrp_added_law                              = "{1} a ajouté la loi: {2}",
			darkrp_removed_law                            = "{1} a supprimé la loi: {2}",
			darkrp_hit_accepted                           = "{1} a accepté un contrat sur {2} donné par {3}",
			darkrp_hit_completed                          = "{1} a completé un contrat sur {2} ayant été donné par {3}",
			darkrp_hit_failed                             = "{1} a échoué sur un contrat contre {2} parce que {3}",
			darkrp_hit_requested                          = "{1} a donné un contrat sur {2} pendant {3} pour {4}",
			darkrp_sold_door                              = "{1} a vendu une porte",
			darkrp_bought_door                            = "{1} a acheté une porte",
			darkrp_dropped_money                          = "{1} a posé {2}",
			darkrp_picked_up_money                        = "{1} a ramassé {2}",
			darkrp_picked_up_money_dropped_by             = "{1} a ramssé {2} ayant été posé(e) par {3}",
			darkrp_afk_demoted                            = "{1} a été rétrogradé pour avoir été AFK",

			pvp_instigator_killed_noweapon                = "{1} {2} a fini un combat et à TUÉ {3} {4} après {5}", -- after X seconds/minutes/hours
			pvp_instigator_killed_weapon                  = "{1} {2} a fini un combat en utilisant {3} et à TUÉ {4} {5} après {6}",
			pvp_instigator_killed_weapons                 = "{1} {2} a fini un combat en utilisant plusieurs armes et à TUÉ {3} {4} après {5}",
			pvp_victim_killed_noweapon                    = "{1} {2} a fini un combat et à ÉTÉ TUÉ PAR {3} {4} après {5}",
			pvp_victim_killed_weapon                      = "{1} {2} a fini un combat en utilisant {3} et A ÉTÉ TUÉ PAR {4} {5} après {6}",
			pvp_victim_killed_weapons                     = "{1} {2} a fini un combat en utilisant plusieurs armes et A ÉTÉ TUÉ PAR {3} {4} après {5}",
			pvp_combat_noweapon                           = "{1} {2} finished combat with {3} {4} après {5}",
			pvp_combat_weapon                             = "{1} {2} a fini un combat en utilisant {3} avec {4} {5} après {6}",
			pvp_combat_weapons                            = "{1} {2} a fini un combat en utilisant plusieurs armes avec {3} {4} après {5}",
			pvp_log_noweapon                              = "{1} a touché {2} infligeant {3} dégats",
			pvp_log_weapon                                = "{1} a touché {2} infligeant {3} dégats avec un(e) {4}",
			pvp_killed                                    = "{1} a tué {2}",
			pvp_vehicle_owned_killed                      = "{1} a été touché et tué par un(e) {2} sans conducteur et appartenant à {3}",
			pvp_vehicle_owned_damaged                     = "{1} a été touché, recevant {2} dégats par {3} sans conducteur, et appartenant à {4}",
			pvp_vehicle_killed                            = "{1} a été touché et tué par un(e) {2} sans conducteur et sans propriétaire",
			pvp_vehicle_damaged                           = "{1} a été touché, recevant {2} dégats par {3} sans conducteur et sans propriétaire",
			pvp_killed_self                               = "{1} s'est suicidé",
			pvp_damaged_self                              = "{1} s'est infligé {2} dégats",

			changed_team                                  = "{1} a changé d'équipe de {2} pour {3}",
			command_used                                  = "{1}: {2}",
			warned_reason                                 = "{1} a été averti par {2} pour {3}",
			warned_noreason                               = "{1} a été averti par {2}",
			warned_kicked                                 = "{1} a été ÉJECTÉ pour avoir dépassé le seuil maximal d'avertissements",
			warned_banned                                 = "{1} a été BANNI pour avoir dépassé le seuil maximal d'avertissements",
			handcuffed                                    = "{1} a menotté {2}",
			handcuffs_broken_by                           = "{1} a libéré {2} de ses menottes",
			handcuffs_broken                              = "{1} s'est libéré de ses menottes",
			npc_health_bought                             = "{1} a acheté de la santé à un PNJ pour {2}",
			npc_armor_bought                              = "{1} a acheté de l'armure à un PNJ pour {2}",
			pac_outfit                                    = "{1} a changé pour une tenue PAC {2}",
			party_chat                                    = "{1} ({2}): {3}",
			party_created                                 = "{1} a créer une partie {2}",
			party_join                                    = "{1} a rejoint une partie {2}",
			party_join_request                            = "{1} a demandé à rejoindre une partie {2}",
			party_invite                                  = "{1} a invité {2} sur la partie {3}",
			party_leave                                   = "{1} a quitté la partie {2}",
			party_kick                                    = "{1} a ejecté {2} de la partie {3}",
			party_disbanded                               = "{1} a supprimé la partie {2}",
			party_abandoned                               = "{1} a quitté le serveur et a abandonné sa partie {2}",
			spraymesh                                     = "{1} a utilisé son spray {2}",
			starwarsvehicle_damage_owned_weapon           = "{1} a infligé des dégats sur Star Wars vehicle {2} possédé par {3} pour {4} dégats avec {5}",
			starwarsvehicle_damage_owned                  = "{1} a infligé des dégats sur Star Wars vehicle {2} possédé par {3} pour {4} dégats",
			starwarsvehicle_damage_weapon                 = "{1} a infligé des dégats sur Star Wars vehicle {2} pour {3} dégats avec {4}",
			starwarsvehicle_damage                        = "{1} a infligé des dégats sur Star Wars vehicle {2} pour {3} dégats",
			wac_damage_owned_weapon                       = "{1} a infligé des dégats sur WAC aircraft {2} possédé par {3} pour {4} dégats avec {5}",
			wac_damage_owned                              = "{1} a infligé des dégats sur WAC aircraft {2} possédé par {3} pour {4} dégats",
			wac_damage_weapon                             = "{1} a infligé des dégats sur WAC aircraft {2} pour {3} dégats avec {4}",
			wac_damage                                    = "{1} a infligé des dégats sur WAC aircraft {2} pour {3} dégats",
			wyozi_cinema_queued                           = "{1} a demandé la vidéo {2} ➞ {3} au cinéma {4}",
			wyozi_dj_queued                               = "{1} a ajouté en file d'attente {2} ➞ {3} sur le canal {4}",
			wyozi_dj_channel_rename                       = "{1} a renommé le canal en {2}",
		}

} end }
--PATH lua/gmodadminsuite/sh_afk.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/secondaryusergroups/_gas_info.lua:
return gluapack()()
--PATH lua/gmodadminsuite/cl_menubar.lua:
return gluapack()()
--PATH lua/gmodadminsuite/cl_contextmenu.lua:
local function L(phrase, ...)
	if (#({...}) > 0) then
		return GAS:Phrase(phrase)
	else
		return GAS:PhraseFormat(phrase, nil, ...)
	end
end

GAS.ContextProperties = {}
function GAS:ContextProperty(name, propertydata)
	GAS.ContextProperties[name] = propertydata
end

properties.Add("GmodAdminSuite", {
	MenuLabel = "GmodAdminSuite",
	MenuIcon = "icon16/shield.png",
	Filter = function(self, ent, ply)
		if (not IsValid(ent)) then return false end
		if (table.Count(GAS.ContextProperties) == 0) then return false end
		return true
	end,
	MenuOpen = function(self, option, ent, tr)
		local option_submenu = option:AddSubMenu()
		option_submenu:AddOption(L"open_menu", self.Action):SetIcon("icon16/application_form_magnify.png")
		local spacer = false
		for i,v in pairs(GAS.ContextProperties) do
			if (v.Filter and v.Filter(self, ent, LocalPlayer()) == false) then continue end
			if (not spacer) then spacer = true option_submenu:AddSpacer() end
			local submenu, submenu_pnl = option_submenu:AddSubMenu(v.MenuLabel, v.Action)
			if (v.MenuIcon) then
				submenu_pnl:SetIcon(v.MenuIcon)
			end
			if (v.MenuOpen) then
				v.MenuOpen(self, submenu, ent, tr, submenu_pnl)
			end
		end
	end,
	Action = function()
		RunConsoleCommand("gmodadminsuite")
	end
})

--PATH lua/gmodadminsuite/cl_menu.lua:
return gluapack()()
--PATH lua/autorun/hologramdraw.lua:
Hologram = Hologram or {}
Hologram.EntsCache = Hologram.EntsCache or {} -- fuck fuck fuck fuck

local allowedClasses = {
	["prop_physics"] = true,
	["prop_dynamic"] = true,
}

hook.Add("InitPostEntity","Hologram.InitialTableCache",function()
	for k, v in ipairs(ents.GetAll()) do
		if not IsValid(v) then continue end
		if not v:EntIndex() or v:EntIndex() < 0 then continue end --serverside/client only entities can go to hell
		
		if allowedClasses[v:GetClass()] or ( v:IsWeapon() or v:IsNPC() or ( v:IsPlayer() and v:Alive() ) or v:IsNextBot() or v:IsVehicle() or v:IsRagdoll() or v:IsScripted() ) then
			Hologram.EntsCache[v:EntIndex()] = nil --By default, nothing is a hologram
		end
	end
end)

hook.Add("OnEntityCreated","Hologram.AddNewEntsToTable",function(ent)
	Hologram.EntsCache[ent:EntIndex()] = nil --By default, nothing is a hologram
end)

hook.Add("EntityRemoved","Hologram.RemovedEntsFromTable",function(ent)
	Hologram.EntsCache[ent:EntIndex()] = nil --Using entindexes as keys rather than the ents themselves bc less expensive I hope
end)

hook.Add("PlayerInitialSpawn","Hologram.NetworkHologramTableOnSpawn",function(ply)
	Hologram.EntsCache = Hologram.EntsCache or {}
end)


if CLIENT then
	Hologram = Hologram or {}

	Hologram.EntsCache = Hologram.EntsCache or {}

	
	net.Receive("Hologram.Tool.UpdateEntity", function(len,ply)
		local index = net.ReadUInt(16)
		local bIsHologram = net.ReadBool()
		if bIsHologram then
			Hologram.EntsCache[index] = true
		else
			Hologram.EntsCache[index] = nil
		end

	end)


	local Clr_holo_Ents = 
	{
		[ "$pp_colour_addr" ] 		= 0,
		[ "$pp_colour_addg" ] 		= 0.3,
		[ "$pp_colour_addb" ] 		= 1,
		[ "$pp_colour_brightness" ] = 0,
		[ "$pp_colour_contrast" ]	= 1,
		[ "$pp_colour_colour" ] 	= 1,
		[ "$pp_colour_mulr" ] 		= 0,
		[ "$pp_colour_mulg" ] 		= 0,
		[ "$pp_colour_mulb" ] 		= 0
	}

	local Clr_normal =
	{
		[ "$pp_colour_addr" ] 		= 0,
		[ "$pp_colour_addg" ] 		= 0,
		[ "$pp_colour_addb" ] 		= 0,
		[ "$pp_colour_brightness" ] = 0,
		[ "$pp_colour_contrast" ]	= 1,
		[ "$pp_colour_colour" ] 	= 1,
		[ "$pp_colour_mulr" ] 		= 0,
		[ "$pp_colour_mulg" ] 		= 0,
		[ "$pp_colour_mulb" ] 		= 0
	}
	local holomat = Material("ace/sw/hologram")

	hook.Add("PreDrawEffects", "HologramDraw", function(isDrawingDepth, isDrawingSkybox)

		--if isDrawingDepth then return true end --Fuck if i know whether or not I need this
		-- Reset everything to known good

		render.SetStencilWriteMask( 0xFF )
		render.SetStencilTestMask( 0xFF )
		render.SetStencilReferenceValue( 0 )
		render.SetStencilCompareFunction( STENCIL_ALWAYS )
		render.SetStencilPassOperation( STENCIL_KEEP )
		render.SetStencilFailOperation( STENCIL_KEEP )
		render.SetStencilZFailOperation( STENCIL_KEEP )
		render.ClearStencil()


		--this whole bit draws models to the first stencil buffer, i think
		render.OverrideDepthEnable(false, true)
		render.SetStencilEnable(true)
		render.SetStencilFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
		render.SetStencilReferenceValue(44)

		--this is probably a really shit way to do this, but it's fine for now
		for index, bHologram in pairs ( Hologram.EntsCache ) do
			local ent = ents.GetByIndex(index)
			if IsValid(ent) and bHologram then
				--this if statement is stupid but i dont really care, since it works and performance impact isnt too bad i think
				if ( (!ent:IsWorld() and !ent:IsWeapon())) then --and ( ent:IsNPC() or (ent:IsPlayer() and ent:Alive()) or ( ent:GetClass() == "prop_physics" || "prop_dynamic") ) and bHologram ) then
					if not ent:IsEffectActive(EF_NODRAW) then --we do this as a dumb check to see if something is dead or not
						render.SuppressEngineLighting(true)
							ent:DrawModel() --draw model to stencil buffer
						render.SuppressEngineLighting(false)
					end
				end
			end
		end
			
		render.SuppressEngineLighting(true) --why???

		--Setup stencil for drawing only shit that matches stencil reference value 1 or something
		render.SetStencilReferenceValue(45)
		render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
		render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
		render.SetStencilReferenceValue(44)
		DrawColorModify(Clr_holo_Ents)

		--cool shit that makes holograms look good
		render.OverrideBlend(true, BLEND_DST_COLOR, BLEND_SRC_COLOR, BLENDFUNC_ADD, BLEND_ONE, BLEND_ONE, BLENDFUNC_ADD)
		render.SetColorMaterialIgnoreZ()
		render.SetMaterial(holomat)

		render.DrawScreenQuad(true) --draws hologram material to whole screen but only the parts matching the stencil buffer

		--reset everything to how it should be i think
		render.OverrideBlend(false)
		render.SuppressEngineLighting(false)
		render.SetStencilEnable( false )
		--render.DepthRange(0.0,1.0) --not sure what this does

		DrawColorModify(Clr_normal)
	end)

end

--PATH lua/autorun/jiro_addon.lua:
return gluapack()()
--PATH lua/autorun/layout.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end

AddPlayerModel( "Daki", "models/player/swtor/arsenic/Daki/Daki.mdl" )


--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_lscs_thirdperson.lua:

local function Validate( ply )
	if not ply:Alive() or ply:GetViewEntity() ~= ply then return false end -- when a player uses the camera tool for example

	local weapon = ply:GetActiveWeapon()

	if not IsValid( weapon ) or not weapon.LSCS then return false end -- not holding our lightsaber

	if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return false end -- use vehicle view in vehicles

	return true
end

-- this is the main camera. If all goes to plan this should do the job
hook.Add( "CalcView", "!!!!!!!!!!!!simple_glowstickthirdperson",  function( ply, pos, angles, fov )
	if not Validate( ply ) then return end

	local view = {}
	view.origin = ply:lscsGetViewOrigin()
	view.angles = ply:EyeAngles()
	view.fov = fov
	view.drawviewer = true

	ply._lscsCalcViewTime = CurTime() + 0.1

	return view
end )

-- this is used for when the CalcView hook somehow doesn't get called but the SWEP:CalcView function is. If the hook fails this will probably fail aswell tho
hook.Add( "ShouldDrawLocalPlayer", "!!!!!!!!!!!!simple_glowstickthirdperson",  function( ply )
	if (ply._lscsCalcViewTime or 0) < CurTime() then return end

	if not Validate( ply ) then return end

	return true
end )

--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_convar.lua:
-- 2022 and i still havent bothered creating a system that does this automatically

local cVar_SaberDamage = CreateConVar( "lscs_sv_saberdamage", "200", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Amount of Damage per Saber Hit" )
LSCS.SaberDamage = cVar_SaberDamage and cVar_SaberDamage:GetInt() or 200
cvars.AddChangeCallback( "lscs_sv_saberdamage", function( convar, oldValue, newValue ) 
	LSCS.SaberDamage = tonumber( newValue )
end)


local cVar_BulletForceDrainMul = CreateConVar( "lscs_sv_forcedrain_per_bullet_mul", "0.1", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"BulletDamage is multiplied by this value and then removed from ForcePoints on deflect." )
LSCS.BulletForceDrainMul = cVar_BulletForceDrainMul and cVar_BulletForceDrainMul:GetFloat() or 0.1
cvars.AddChangeCallback( "lscs_sv_forcedrain_per_bullet_mul", function( convar, oldValue, newValue ) 
	LSCS.BulletForceDrainMul = math.max( tonumber( newValue ), 0 )
end)


local cVar_BulletForceDrainMin = CreateConVar( "lscs_sv_forcedrain_per_bullet_min", "1", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Minimum amount of force a bullet will drain on deflect." )
LSCS.BulletForceDrainMin = cVar_BulletForceDrainMin and cVar_BulletForceDrainMin:GetFloat() or 1
cvars.AddChangeCallback( "lscs_sv_forcedrain_per_bullet_min", function( convar, oldValue, newValue ) 
	LSCS.BulletForceDrainMin = math.max( tonumber( newValue ), 0 )
end)


local cVar_BulletForceDrainMax = CreateConVar( "lscs_sv_forcedrain_per_bullet_max", "5", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Maxmimum amount of force a bullet will drain on deflect." )
LSCS.BulletForceDrainMax = cVar_BulletForceDrainMax and cVar_BulletForceDrainMax:GetFloat() or 5
cvars.AddChangeCallback( "lscs_sv_forcedrain_per_bullet_max", function( convar, oldValue, newValue ) 
	LSCS.BulletForceDrainMax = math.max( tonumber( newValue ), LSCS.BulletForceDrainMin )
end)


local cVar_AttackInterruptable = CreateConVar( "lscs_sv_bullet_can_interrupt_attack", "1", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Maxmimum amount of force a bullet will drain on deflect." )
LSCS.AttackInterruptable = cVar_AttackInterruptable and cVar_AttackInterruptable:GetBool() or true
cvars.AddChangeCallback( "lscs_sv_bullet_can_interrupt_attack", function( convar, oldValue, newValue ) 
	LSCS.AttackInterruptable = tonumber( newValue ) ~=0
end)

if SERVER then
	util.AddNetworkString( "lscs_admin_setconvar" )

	net.Receive( "lscs_admin_setconvar", function( length, ply )
		if not IsValid( ply ) or not ply:IsSuperAdmin() then return end

		local ConVar = net.ReadString()
		local Value = tonumber( net.ReadString() )

		RunConsoleCommand( ConVar, Value ) 
	end)
end
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_movement.lua:
return gluapack()()
--PATH lua/lscs/combos/advanced_form4.lua:
COMBO.id = "form4b"
COMBO.PrintName = "Advanced:Ataru(IV)"
COMBO.Author = "Storm"
COMBO.Description = "the Way of the Hawk-Bat"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 75 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 100 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form4_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "ataru4_jump_attack",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "ataru4_jump_attack_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "ataru4_jump_achilles_60s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["+45+"] = {
		AttackAnim = "ataru4_jump_achilles_60s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W_S_"] = {
		AttackAnim = "ata_atk_w_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "ataru4_back_flip_60s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["_A__"] = {
		AttackAnim = "ataru4_jump_slash_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["___D"] = {
		AttackAnim = "ataru4_jump_stab_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "ataru4_wd_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["WA__"] = {
		AttackAnim = "ataru4_right_spin_v2_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "ataru4_sd_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["_AS_"] = {
		AttackAnim = "ataru4_sa_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "ataru4_jump_achilles_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/agile.lua:
return gluapack()()
--PATH lua/lscs/combos/basic_form1.lua:
return gluapack()()
--PATH lua/lscs/combos/basic_form2.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/bladedancer.lua:
COMBO.id = "dancer"
COMBO.PrintName = "Blade Dancer"
COMBO.Author = "UCCROW"
COMBO.Description = "Dance With Sword."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos_dancer_corvinus"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "ryoku_a_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.5,
		Duration = 1.2,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "ryoku_r_c1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "vanguard_b_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "ryoku_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["__S_"] = {
		AttackAnim = "pure_h_right_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1.5,
	},
	["_A__"] = {
		AttackAnim = "pure_h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["___D"] = {
		AttackAnim = "ryoku_r_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "ryoku_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.8,
	},
	["WA__"] = {
		AttackAnim = "ryoku_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["__SD"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "pure_b_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.9,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/contention.lua:
COMBO.id = "makashi"
COMBO.PrintName = "Contention"
COMBO.Author = ""
COMBO.Description = ""

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos-test-type"

COMBO.DamageMultiplier = 1.35
COMBO.BPDrainPerHit = 40
COMBO.BlockDistanceNormal = 45 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 15 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.


COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_a_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 200 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.05,
	},
	["-45-"] = {
		AttackAnim = "vanguard_b_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "vanguard_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.2,
	},
	["_A__"] = {
		AttackAnim = "judge_r_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.4,
	},
	["___D"] = {
		AttackAnim = "judge_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.4,
	},
	["W__D"] = {
		AttackAnim = "vanguard_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.4,
	},
	["WA__"] = {
		AttackAnim = "vanguard_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.2,
	},
	["__SD"] = {
		AttackAnim = "phalanx_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "phalanx_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["W___"] = {
		AttackAnim = "combo4",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.7,
	},
}
LSCS:Reload()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/crescent.lua:
COMBO.id = "crescent"
COMBO.PrintName = "Crescent"
COMBO.Author = "Kong"
COMBO.Description = "A long forgotten form of saber combat, focusing on the percise cuts and flow of movement. Rather then relying on powerful strikes, quick cuts are made."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.DamageMultiplier = 1.5
COMBO.BPDrainPerHit = 50

COMBO.HoldType = "wos-meleeelegant-type"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "combo32",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "pure_h_s1_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["___D"] = {
		AttackAnim = "a_combo2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["W__D"] = {
		AttackAnim = "combo2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	},
	["WA__"] = {
		AttackAnim = "combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["__SD"] = {
		AttackAnim = "a_combo2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["_AS_"] = {
		AttackAnim = "combo1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["W___"] = {
		AttackAnim = "phalanx_b_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
}


--PATH addons/[miecze] moce i hilty/lua/lscs/combos/djemso.lua:
COMBO.id = "djemso"
COMBO.PrintName = "Djem So(V)"
COMBO.Author = "Kong"
COMBO.Description = "Shien and Djem So was developed by practitioners of Form III who saw the need for a more offensive edge."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.DamageMultiplier = 1.15
COMBO.BPDrainPerHit = 50

COMBO.HoldType = "wos-meleeheavy-type"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "judge_h_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1.2,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "judge_r_s3_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "judge_r_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	},
	["___D"] = {
		AttackAnim = "judge_r_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "judge_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["WA__"] = {
		AttackAnim = "judge_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["__SD"] = {
		AttackAnim = "judge_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["_AS_"] = {
		AttackAnim = "judge_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["W___"] = {
		AttackAnim = "judge_r_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1.1,
	},
}


--PATH addons/[miecze] moce i hilty/lua/lscs/combos/warriordual.lua:
COMBO.id = "warriordual"
COMBO.PrintName = "Warrior (Dual Wield)"
COMBO.Author = "RareLogan"
COMBO.Description = "A more experienced blade wielder would use this stance."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "wos-test-type"

COMBO.DamageMultiplier = 1.15
COMBO.BPDrainPerHit = 50

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "h_c3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "phalanx_b_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "h_c3_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "phalanx_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "phalanx_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "judge_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "judge_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "judge_h_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "judge_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "phalanx_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "judge_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_lscs.lua:

--[[
	v v v Blade v v v
]]
local blade = {}
blade.PrintName = "Sapphire"
blade.Author = "Blu-x92 / Luna"
blade.id = "sapphire"
blade.color_blur = Color(0,65,255)
blade.color_core = Color(255,255,255)
blade.length = 45
blade.width = 0.9
blade.widthWiggle = 0.6
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true
blade.no_trail = false
blade.sounds = {
	Attack = "saber_hup",
	Attack1 = "saber_spin1",
	Attack2 = "saber_spin2",
	Attack3 = "saber_spin3",
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

-- modify previous blade, only change what we need to change
blade.PrintName = "Rubin"
blade.id = "rubin"
blade.color_blur = Color(200,0,0)
blade.width = 0.8
blade.widthWiggle = 0.7
blade.sounds.Idle = "saber_idle2"
LSCS:RegisterBlade( blade ) -- then register new blade table

-- repeat ^^
blade.PrintName = "Smaragd"
blade.id = "smaragd"
blade.color_blur = Color(0,150,0)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle5"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Citrine"
blade.id = "citrine"
blade.color_blur = Color(200,150,0)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Allnatt"
blade.id = "allnatt"
blade.color_blur = Color(200,200,0)
blade.width = 0.65
blade.widthWiggle = 1
blade.sounds.Idle = "saber_idle3"
LSCS:RegisterBlade( blade )

-- special case: model based blade
local blade = {}
blade.PrintName = "Nano Particles"
blade.Author = "Blu-x92 / Luna"
blade.id = "nanoparticles"
blade.color_blur = Color(0,127,255)
blade.color_core = Color(0,0,0)
blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl"
blade.mdl_poseparameter = "blade_retract"
blade.length = 27
blade.dynamic_light = true
blade.no_trail = false
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_barrier.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_block.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_cloak.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_heal.lua:
local force = {}
force.PrintName = "Heal"
force.Author = "Blu-x92 / Luna"
force.Description = "Heal yourself using the Force"
force.id = "heal"
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2
	

	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()

	if need > 0 and available >= 5 then
		local take = math.min( need, available, 25 )

		ply:lscsTakeForce( take )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Heal II"
force.Author = "Valkorius"
force.Description = "Heal yourself using the Force"
force.id = "healii"
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2
	

	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()

	if need > 0 and available >= 5 then
		local take = math.min( need, available, 40 )

		ply:lscsTakeForce( take )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Heal III"
force.Author = "Valkorius"
force.Description = "Heal yourself using the Force"
force.id = "healiii"
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2
	

	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()

	if need > 0 and available >= 5 then
		local take = math.min( need, available, 55 )

		ply:lscsTakeForce( take )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Mass Heal"
force.Author = "Solace"
force.Description = "Heal a group using the Force"
force.id = "massheal"
local function ForceMassHeal( ply, TIME )
	local MyPos = ply:GetShootPos()
	for _, nEntity in pairs( ents.FindInSphere( MyPos, 200 ) ) do -- Are you in a certain distance?
		
		if nEntity:IsPlayer() then -- Are you a player?
			local need = nEntity:GetMaxHealth() - nEntity:Health() -- Do you actually need healing?
			if need > 0 then
				nEntity:SetHealth( math.Clamp( nEntity:Health() + 10, 0, nEntity:GetMaxHealth() ) ) --Increases their health by 5 but does not go past their max HP
				ply:lscsTakeForce(5) -- Costs 5 force
				local effectdata = EffectData()
					effectdata:SetOrigin( nEntity:GetPos() )
					effectdata:SetEntity( nEntity )
				util.Effect( "force_heal", effectdata, true, true )
			end
		end
	end
end
force.OnClk =  function( ply, TIME )
	if not ply._lscsMassHealTime then return end -- Stops healing after a certain amount of time (Defined on line 48)
	
	ForceMassHeal( ply, TIME )
	
	if ply._lscsMassHealTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsMassHealTime = nil
	end
end
force.StartUse = function( ply )

	local Time = CurTime()
	
	if ply:lscsGetForce() < 10 then return end -- Need at least 10 force

	local CanDo = (ply._lscsNextForce or 0) < Time
	if not CanDo then return end

	ply._lscsNextForce = Time + 2 -- Cooldown
		
	ForceMassHeal( ply, TIME )
	
	ply:EmitSound("lscs/force/heal.mp3")
	
	if not ply._lscsMassHealTime then
		ply._lscsMassHealTime = CurTime() + 5 -- Only lets you heal for 3.5 seconds at a time
	end
end
force.StopUse = function( ply )
	ply._lscsMassHealTime = nil
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_kneel.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_anzatis.lua:
local hilt = {}
hilt.PrintName = "Agamemnon Insolence"
hilt.Author = "Midnight"
hilt.id = "agamemnon"
hilt.mdl = "models/wos/lct/weapons/lightsabers/agamemnon_insolence.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, 0, 6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Trisaber"
hilt.Author = "Midnight"
hilt.id = "Trisaber"
hilt.mdl = "models/anzati/lightsabers/trisaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -1.5, -4), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1.5, 4),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ancient Vibrosword"
hilt.Author = "Midnight"
hilt.id = "ancientvibro"
hilt.mdl = "models/anzati/lightsabers/vibrosword.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, -4, -5), -- up or down | Left(-) and right | backward or forward(-)
            ang = Angle(180, 0, 90), -- I HATE LUA I HATE LUA I HATE LUA
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.5, 0.5, 5),
            ang = Angle(0, 180, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )	

local hilt = {}
hilt.PrintName = "Aztec"
hilt.Author = "Midnight"
hilt.id = "Aztec"
hilt.mdl = "models/anzati/lightsabers/osnova.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.75, -0.5, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.75, -3, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Crimson Reforged"
hilt.Author = "Midnight"
hilt.id = "Crimson Reforged"
hilt.mdl = "models/anzati/lightsabers/revan_b.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.6, -0.3, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.6, -3, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Scrapped Forager"
hilt.Author = "Midnight"
hilt.id = "Scrapped Forager"
hilt.mdl = "models/anzati/lightsabers/revan_a.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -110),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5, -4, 0),
            ang = Angle(90, 90, 110),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Croc"
hilt.Author = "Midnight"
hilt.id = "croc"
hilt.mdl = "models/wos/lct/weapons/lightsabers/croc_estrella.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -3, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -20),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, -1, 10),
            ang = Angle(90, 90, 210),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Cyclops Deception"
hilt.Author = "Midnight"
hilt.id = "cyclops"
hilt.mdl = "models/wos/lct/weapons/lightsabers/cyclops_deception.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2.5, -9), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -0.5, 9),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Guardstaff"
hilt.Author = "Midnight"
hilt.id = "guardstaff"
hilt.mdl = "models/wos/lct/weapons/lightsabers/guardstaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(1, -5, 5), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(1, 2, -5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Hanzo"
hilt.Author = "Midnight"
hilt.id = "hanzo"
hilt.mdl = "models/wos/lct/weapons/lightsabers/hanzo_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -1.5, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Helen Betrayal"
hilt.Author = "Midnight"
hilt.id = "helen"
hilt.mdl = "models/wos/lct/weapons/lightsabers/helen_betrayal.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.2, -2, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, -2.2, 10),
            ang = Angle(90, -90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Blood Ritual Saberstaff"
hilt.Author = "Midnight"
hilt.id = "juzastaff"
hilt.mdl = "models/wos/lct/weapons/lightsabers/custom_juza_double.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, 0, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Blood Ritual"
hilt.Author = "Midnight"
hilt.id = "juza"
hilt.mdl = "models/wos/lct/weapons/lightsabers/custom_juza_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2, -7), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, 0, 7),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Valkyrie Saberstaff"
hilt.Author = "Midnight"
hilt.id = "valkstaff"
hilt.mdl = "models/wos/lct/weapons/lightsabers/custom_whiskey_double.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, -0.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Valkyrie"
hilt.Author = "Midnight"
hilt.id = "valk"
hilt.mdl = "models/wos/lct/weapons/lightsabers/custom_whiskey_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, -0.5, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Jedi Archivist"
hilt.Author = "Midnight"
hilt.id = "jediarchivist"
hilt.mdl = "models/wos/lct/weapons/lightsabers/j_archivist.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.75, -2.5, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -2, 10),
            ang = Angle(90, 90, -90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Sith Archivist"
hilt.Author = "Midnight"
hilt.id = "sitharchivist"
hilt.mdl = "models/wos/lct/weapons/lightsabers/s_archivist.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.75, -2.5, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -2, 10),
            ang = Angle(90, 90, -90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Keyblade"
hilt.Author = "Midnight"
hilt.id = "keyblade"
hilt.mdl = "models/wos/lct/weapons/lightsabers/keyblade.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -3, -9), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1.5, 9),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Longclaw"
hilt.Author = "Midnight"
hilt.id = "longclaw"
hilt.mdl = "models/wos/lct/weapons/lightsabers/longclaw.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -1.5, -5), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1.5, 5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Peryite"
hilt.Author = "Midnight"
hilt.id = "meliodas"
hilt.mdl = "models/wos/lct/weapons/lightsabers/meliodas_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -3.1, -5), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, 90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5, -3.1, 5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Pandora"
hilt.Author = "Midnight"
hilt.id = "pandora"
hilt.mdl = "models/wos/lct/weapons/lightsabers/pandora_plunder_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -3, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, 0, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Queen's Web"
hilt.Author = "Midnight"
hilt.id = "queenweb"
hilt.mdl = "models/wos/lct/weapons/lightsabers/queen_web_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -1.5, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, -1.5, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Theo Saberstaff"
hilt.Author = "Midnight"
hilt.id = "theodual"
hilt.mdl = "models/wos/lct/weapons/lightsabers/theo_dual.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -1.5, -15), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, -2, 15),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Treant's Guard"
hilt.Author = "Midnight"
hilt.id = "Treant's Guard"
hilt.mdl = "models/anzati/nabbypike2/nabbypike2.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -1.5, -6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1.5, 6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Sacred Treasure"
hilt.Author = "Midnight"
hilt.id = "sacredtreasure"
hilt.mdl = "models/wos/lct/weapons/lightsabers/sacred_treasure_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2, -9), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -1, 9),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Uchigatana"
hilt.Author = "Midnight"
hilt.id = "uchigatana"
hilt.mdl = "models/wos/lct/weapons/lightsabers/uchigatana.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.8, -2.5, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.8, -1, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Uchigatana"
hilt.Author = "Midnight"
hilt.id = "uchigatana"
hilt.mdl = "models/wos/lct/weapons/lightsabers/uchigatana.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.8, -2.5, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.8, -1, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}

--[[ LSCS:RegisterHilt( hilt )local hilt = {}
hilt.PrintName = "Umbrella"
hilt.Author = "Anzati"
hilt.id = "Umbrella"
hilt.mdl = "models/lightsabers/expgamer/expgamer_umbrella.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -1, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt ) ]]--

local hilt = {}
hilt.PrintName = "Consular's Mender"
hilt.Author = "Midnight"
hilt.id = "consularsmender"
hilt.mdl = "models/wos/lct/weapons/lightsabers/consularsmender.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -1.5, -1), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1.5, 1),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Crow's Bane"
hilt.Author = "Midnight"
hilt.id = "grenth"
hilt.mdl = "models/wos/lct/weapons/lightsabers/darthgrenth.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -1.5, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, -1.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Crow's Bane Saberstaff"
hilt.Author = "Midnight"
hilt.id = "grenthstaff"
hilt.mdl = "models/wos/lct/weapons/lightsabers/darthgrenthdual.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -1.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, -1.5, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Gold Deceiver Saberstaff"
hilt.Author = "Midnight"
hilt.id = "deceiverstaff"
hilt.mdl = "models/wos/lct/weapons/lightsabers/deciver_gold_dual.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -2.5, -9), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -2.5, 9),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Gold Deceiver"
hilt.Author = "Midnight"
hilt.id = "deceiver"
hilt.mdl = "models/wos/lct/weapons/lightsabers/deciver_gold_single.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -1.5, -1), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, -1.5, 1),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Kopavi Saberstaff"
hilt.Author = "Midnight"
hilt.id = "kopavistaff"
hilt.mdl = "models/wos/lct/weapons/lightsabers/kopavi_a.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -1.5, -1), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1.5, 1),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Kopavi"
hilt.Author = "Midnight"
hilt.id = "kopavi"
hilt.mdl = "models/wos/lct/weapons/lightsabers/kopavi_half.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -1.5, -1), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1.5, -1),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Gold Kopavi Saberstaff"
hilt.Author = "Midnight"
hilt.id = "gkopavistaff"
hilt.mdl = "models/wos/lct/weapons/lightsabers/kopavi_gold_dual.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -1.5, -1), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1.5, 1),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Gold Kopavi"
hilt.Author = "Midnight"
hilt.id = "gkopavi"
hilt.mdl = "models/wos/lct/weapons/lightsabers/kopavi_gold_single.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -1.5, -1), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1.5, -1),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Tulak Saberstaff"
hilt.Author = "Anzati"
hilt.id = "Tulak Saberstaff"
hilt.mdl = "models/anzati/lightsabers/tulak_double.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -1.5, -13), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1.5, 13),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Woven Blade"
hilt.Author = "Midnight"
hilt.id = "woveng"
hilt.mdl = "models/anzati/lightsabers/talon_green.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Woven Blade Pure"
hilt.Author = "Midnight"
hilt.id = "wovenp"
hilt.mdl = "models/anzati/lightsabers/talon_red.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Woven Blade Balanced"
hilt.Author = "Midnight"
hilt.id = "wovenw"
hilt.mdl = "models/anzati/lightsabers/talon_blue.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Magic"
hilt.Author = "Midnight"
hilt.id = "magicuh"
hilt.mdl = "models/anzati/sgn/lightsabers/blackcat_magichilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(20, 45, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, 90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(20, -45, 0),
            ang = Angle(90, -90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Crusader"
hilt.Author = "Midnight"
hilt.id = "crusader"
hilt.mdl = "models/anzati/crusader/crusader.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Eviscerator"
hilt.Author = "Midnight"
hilt.id = "eviscerator"
hilt.mdl = "models/anzati/beasttamer/beasttamer.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Sabertooth"
hilt.Author = "Midnight"
hilt.id = "sabertooth"
hilt.mdl = "models/anzati/sgn/lightsabers/devestator.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, -6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -4, 6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Renboga Staff"
hilt.Author = "Midnight"
hilt.id = "renboga"
hilt.mdl = "models/anzati/sgn/lightsabers/dijonhilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5, 1, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5, -3, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Rey Staff"
hilt.Author = "Midnight"
hilt.id = "Rey Staff"
hilt.mdl = "models/anzati/lightsabers/rey_staff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5, 1, 6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5, -3, -6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Hyperion"
hilt.Author = "Midnight"
hilt.id = "hyperion"
hilt.mdl = "models/anzati/tau_1.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.5, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Lyon"
hilt.Author = "Midnight"
hilt.id = "lyon"
hilt.mdl = "models/anzati/lightsabers/lyon.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Necromancer's Staff"
hilt.Author = "Midnight"
hilt.id = "hydro"
hilt.mdl = "models/anzati/sgn/lightsabers/hydro_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, 0, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.5, -3, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Fatebringer"
hilt.Author = "Midnight"
hilt.id = "kanye"
hilt.mdl = "models/anzati/sgn/lightsabers/kanye_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, 0.8, -1), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.6, -3, 1),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Krayt"
hilt.Author = "Midnight"
hilt.id = "krayt"
hilt.mdl = "models/anzati/sgn/lightsabers/krayt_single.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, 0.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.5, -3, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Krayt Saberstaff"
hilt.Author = "Midnight"
hilt.id = "krayts"
hilt.mdl = "models/anzati/sgn/lightsabers/krayt_double.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, 0.5, -1.5), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.5, -3, 1.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Clover"
hilt.Author = "Midnight"
hilt.id = "clover"
hilt.mdl = "models/anzati/sgn/lightsabers/leafclover.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, 0, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.5, -3, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Rose"
hilt.Author = "Midnight"
hilt.id = "rose"
hilt.mdl = "models/anzati/sgn/lightsabers/rose.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Priest"
hilt.Author = "Midnight"
hilt.id = "priest"
hilt.mdl = "models/anzati/jesus/jesus.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Beskar Gauntlet"
hilt.Author = "Midnight"
hilt.id = "beskar"
hilt.mdl = "models/anzati/lightsabers/yellowheart.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -3, -2), -- up and down | Left and right | up on and down in hand
            ang = Angle(90, 45, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -3, -2),
            ang = Angle(90, 45, -90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Artifact"
hilt.Author = "Midnight"
hilt.id = "artifact"
hilt.mdl = "models/anzati/39.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6.5, 0, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6.5, -4, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Clockwork"
hilt.Author = "Midnight"
hilt.id = "clockwork"
hilt.mdl = "models/anzati/arn_1.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, -3), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -4, 2.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Champion"
hilt.Author = "Midnight"
hilt.id = "mtx8"
hilt.mdl = "models/anzati/mtx_8.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, 0.5), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -4, 0.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Keeper of the Vault"
hilt.Author = "Midnight"
hilt.id = "vaultkeeper"
hilt.mdl = "models/anzati/lightsabers/blue_gray.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0.5, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.5, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Corvax"
hilt.Author = "Midnight"
hilt.id = "corvax"
hilt.mdl = "models/anzati/lightsabers/corvax.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0, 1), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.5, -1),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "The Dark King"
hilt.Author = "Midnight"
hilt.id = "darkking"
hilt.mdl = "models/anzati/lightsabers/darkking.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -1.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1.5, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Maw"
hilt.Author = "Midnight"
hilt.id = "maw"
hilt.mdl = "models/anzati/lightsabers/maw.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5, 1, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5, -3, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ogara Pike"
hilt.Author = "Midnight"
hilt.id = "ogara"
hilt.mdl = "models/anzati/lightsabers/ogarapike.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, 1, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.5, -3, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Dragon Skull"
hilt.Author = "Midnight"
hilt.id = "Dragon Skull"
hilt.mdl = "models/zyon/misc/dragon.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -1, -6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, 90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, -2, 6),
            ang = Angle(90, 90, -90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Elegant Guardian"
hilt.Author = "Midnight"
hilt.id = "elegantblue"
hilt.mdl = "models/anzati/sgn/lightsabers/elegant_blue.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.2, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Elegant Consular"
hilt.Author = "Midnight"
hilt.id = "elegantgreen"
hilt.mdl = "models/anzati/sgn/lightsabers/elegant_green.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.2, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Elegant Sentinel"
hilt.Author = "Midnight"
hilt.id = "elegantorange"
hilt.mdl = "models/anzati/sgn/lightsabers/elegant_orange.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.2, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Elegant Balanced"
hilt.Author = "Midnight"
hilt.id = "elegantpurple"
hilt.mdl = "models/anzati/sgn/lightsabers/elegant_purple.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.2, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Elegant Sith"
hilt.Author = "Midnight"
hilt.id = "elegantred"
hilt.mdl = "models/anzati/sgn/lightsabers/elegant_red.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.2, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Elegant Pure"
hilt.Author = "Midnight"
hilt.id = "elegantwhite"
hilt.mdl = "models/anzati/sgn/lightsabers/elegant_white.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.2, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Elegant Templeguard"
hilt.Author = "Midnight"
hilt.id = "elegantyellow"
hilt.mdl = "models/anzati/sgn/lightsabers/elegant_yellow.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(6, 0.5, -2), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(6, -3.2, 2),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Malgus Saberstaff"
hilt.Author = "Anzati"
hilt.id = "Malgus Saberstaff"
hilt.mdl = "models/anzati/lightsabers/new_malgus_double.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -2, 0), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -2, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Eizen Axe Saberstaff"
hilt.Author = "Dreamplay"
hilt.id = "Eizen Axe Saberstaff"
hilt.mdl = "models/dreamplay/eizen_axe_double_hilt/custom_eizen_axe_double_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -7), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, 0, 7),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Eizen Axe"
hilt.Author = "Dreamplay"
hilt.id = "Eizen Axe"
hilt.mdl = "models/dreamplay/eizen_axe_hilt/custom_eizen_axe_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -7), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, 0, 7),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Logir"
hilt.Author = "Dreamplay"
hilt.id = "Logir"
hilt.mdl = "models/dreamplay/ganchy_modern_hilt/custom_ganchy_modern_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -9), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, 0, 9),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Vortund"
hilt.Author = "Dreamplay"
hilt.id = "Vortund"
hilt.mdl = "models/dreamplay/ganchy_modern_double_hilt/custom_ganchy_modern_double_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -9), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, 0, 9),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Neutral Blade"
hilt.Author = "Dreamplay"
hilt.id = "Neutral Blade"
hilt.mdl = "models/dreamplay/dwayne_commando_hilt/custom_dwayne_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, 0, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Neutral Saberstaff"
hilt.Author = "Dreamplay"
hilt.id = "Neutral Saberstaff"
hilt.mdl = "models/dreamplay/dwayne_commando_double_hilt/custom_dwayne_double_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, 0, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Tranquility"
hilt.Author = "Dreamplay"
hilt.id = "Tranquility"
hilt.mdl = "models/dreamplay/hydrofusions_tranquility_hilt/custom_hydrofusions_tranquility_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, 0, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Revan Triedge"
hilt.Author = "Dreamplay"
hilt.id = "Revan Triedge"
hilt.mdl = "models/dreamplay/revan_triedge_hilt/custom_revan_triedge_hilt.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2, -2, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2, -0.5, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Scourgekeeper"
hilt.Author = "Anzati"
hilt.id = "Scourgekeeper"
hilt.mdl = "models/anzati/dragon/dragon.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -2, -6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -2, 6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Silver Rune"
hilt.Author = "Zyon"
hilt.id = "Silver Rune"
hilt.mdl = "models/zyon/misc/sapphire.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -3, -6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1, 6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Unstable Vented"
hilt.Author = "Zyon"
hilt.id = "Unstable Vented"
hilt.mdl = "models/zyon/swtor/unstable_vented.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2, -6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -0.5, 6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Vaylin"
hilt.Author = "Zyon"
hilt.id = "Vaylin"
hilt.mdl = "models/zyon/swtor/vaylin.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2, -6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -0.5, 6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Winged"
hilt.Author = "Zyon"
hilt.id = "Winged"
hilt.mdl = "models/zyon/misc/winged.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(2.5, -2, -6), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(2.5, -0.5, 6),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Slayer Saberstaff"
hilt.Author = "Anzati"
hilt.id = "Slayer Saberstaff"
hilt.mdl = "models/anzati/lightsabers/slayer.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3, -1.5, -12.5), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1.5, 12.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_uhhh.lua:
return gluapack()()
--PATH addons/[miecze] lscs_inventory_saver/lua/lscs/content/inventory_saver_example.lua:
-- for all the people who cant figure this out by themself...
-- just a quick script that will save and restore your inventory
-- i strongly urge you to code your own system, as this is a very inefficient way of doing it.

-- this file goes to: lua/lscs/content

if CLIENT then return end -- all this is serverside only.

local meta = FindMetaTable( "Player" )

local NumberToEquippedEntry = {
	[0] = true,
	[1] = false,
	[-1] = nil, -- just for looks, doesnt actually do anything
}

function meta:lscsWriteInventory()
	local ID = self:AccountID()

	if not ID then return end

	local inv = self:lscsGetInventory()
	local eq = self:lscsGetEquipped()

	local data = ""

	for index, item in pairs( inv ) do
		data = data..tostring( index ).."="..tostring( item )..","
	end

	data = data .."#"

	for index, equipped in pairs( eq ) do

		local eq_string

		if equipped == true then
			eq_string = "0" -- equipped right hand

		elseif equipped == false then
			eq_string = "1" -- equipped left hand

		else
			eq_string = "-1" -- unequipped
		end

		data = data..tostring( index ).."="..eq_string..","
	end

	if not file.Exists( "lscs", "DATA" ) then
		file.CreateDir( "lscs" )
	end

	if not file.Exists( "lscs/"..ID, "DATA" ) then
		file.CreateDir( "lscs/"..ID )
	end

	file.Write( "lscs/"..ID.."/inventory.txt", data )
end

function meta:lscsReadInventory()
	local ID = self:AccountID()

	if not ID then return end

	if not file.Exists( "lscs/"..ID, "DATA" ) then return end

	local file_data = file.Read( "lscs/"..ID.."/inventory.txt", "DATA" )

	if not file_data then return end -- can this fail? i dont know...  probably yes.

	local data = string.Explode( "#", file_data )

	local inventory_string = data[1]
	local equipped_string = data[2]

	local inventory = {}
	local equipped = {}

	if inventory_string and inventory_string ~= "" then
		for _, entry in pairs( string.Explode( ",", inventory_string ) ) do
			local item_piece = string.Explode( "=", entry ) 
			local index = tonumber( item_piece[1] )
	
			if not index then continue end

			inventory[ index ] = item_piece[ 2 ]
		end
	end

	if equipped_string and equipped_string ~= "" then
		for _, entry in pairs( string.Explode( ",", equipped_string ) ) do
			local item_piece = string.Explode( "=", entry ) 
			local index = tonumber( item_piece[1] )

			if not index then continue end

			equipped[ index ] = NumberToEquippedEntry[ tonumber( item_piece[ 2 ] ) ]
		end
	end

	self:lscsWipeInventory() -- clear original inventory

	for index, item in pairs( inventory ) do
		self:lscsAddInventory( item, equipped[ index ] )
	end
end

hook.Add( "LSCS:PostPlayerInventory", "!!!lscs_inventory_saver", function( ply, item, index )
	if not IsValid( ply ) then return end

	ply:lscsWriteInventory() -- ideally you would only add a single item in your saved .txt instead of rewriting it entirely
end )

hook.Add( "LSCS:OnPlayerDroppedItem", "!!!lscs_inventory_saver", function( ply, item_entity )
	ply:lscsWriteInventory() -- ideally you would only remove the dropped item from your saved .txt instead of rewriting said .txt entirely
end )

hook.Add( "LSCS:OnPlayerEquippedItem", "!!!lscs_inventory_saver", function( ply, item )
	ply:lscsWriteInventory() -- ideally you would only change the equipped state in your saved .txt of this single item instead of rewriting said .txt entirely
end)

hook.Add( "LSCS:OnPlayerUnEquippedItem", "!!!lscs_inventory_saver", function( ply, item )
	ply:lscsWriteInventory() -- ideally you would only change the equipped state in your saved .txt of this single item instead of rewriting said .txt entirely
end)

hook.Add( "PlayerInitialSpawn", "!!!lscs_inventory_saver", function( ply )
	-- ply:Give("weapon_lscs") -- shouldn't be needed
	ply:lscsReadInventory()
end )

hook.Add( "LSCS:OnPlayerForceUse", "no power", function( ply, id, item )

	-- disallow saber throw useage example
	local teamData = RPExtraTeams[ply:Team()]
    if !teamData or (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then return false end
end)

hook.Add( "LSCS:OnPlayerCraftedSaber", "no saber", function( ply, weapon_entity )
	local teamData = RPExtraTeams[ply:Team()]
    if !teamData or (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then if IsValid(weapon_entity) then weapon_entity:Remove() end return false end
end )
--[[
-- alternative to playerinitialspawn hook above:
hook.Add( "LSCS:OnPlayerFullySpawned", "!!!lscs_inventory_saver", function( ply )
	-- ply:Give("weapon_lscs") -- shouldn't be needed
	ply:lscsReadInventory()
	ply:lscsCraftSaber()
end )
]]

-- more info about inventory saving:
-- https://github.com/SpaxscE/lscs_templates_and_info/blob/main/how_to_save_and_restore_inventory.lua

 -- for more functions and info see:
 -- https://github.com/SpaxscE/lscs_templates_and_info/blob/main/useful_lua_functions.lua

--PATH addons/[miecze] moce i hilty/lua/lscs/content/lscs_forcepowers.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/lscs_hilts.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/memetis_powers.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/midnights_special_blades.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/cl_menu.lua:

local icon_load_version = Material("gui/html/refresh")

local bgMat = Material( "lvs/controlpanel_bg.png" )
local adminMat = Material( "icon16/shield.png" )
local gradient_mat = Material( "gui/gradient" )
local gradient_down = Material( "gui/gradient_down" )

local FrameSizeX = 600
local FrameSizeY = 400

local function ClientSettings( Canvas )
	local TopPanel = vgui.Create( "DPanel", Canvas )
	TopPanel:SetSize( FrameSizeX, FrameSizeY * 0.35 )
	TopPanel.Paint = function( self, w, h )
		surface.SetDrawColor( 80, 80, 80, 255 )
		surface.SetMaterial( gradient_mat )
		surface.DrawTexturedRect( 1, 0, w, 1 )

		draw.DrawText( "Mouse", "LVS_FONT", 4, 4, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end
	TopPanel:Dock( BOTTOM )

	local RightPanel = vgui.Create( "DPanel", Canvas )
	RightPanel:SetSize( FrameSizeX * 0.5, FrameSizeY )
	RightPanel.Paint = function( self, w, h )
		surface.SetDrawColor( 80, 80, 80, 255 )
		surface.SetMaterial( gradient_down )
		surface.DrawTexturedRect( 0, 0, 1, h )
		draw.DrawText( "Misc/Performance", "LVS_FONT", 4, 4, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end
	RightPanel:Dock( RIGHT )

	local RightPanelRight = vgui.Create( "DPanel", RightPanel )
	RightPanelRight:SetSize( FrameSizeX * 0.25, FrameSizeY )
	RightPanelRight.Paint = function() end
	RightPanelRight:Dock( RIGHT )

	local LeftPanel = vgui.Create( "DPanel", Canvas )
	LeftPanel:SetSize( FrameSizeX * 0.5, FrameSizeY )
	LeftPanel.Paint = function( self, w, h )
		draw.DrawText( "Preferences", "LVS_FONT", 4, 4, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end
	LeftPanel:Dock( LEFT )

	local CheckBoxPanel = vgui.Create( "DPanel", TopPanel )
	CheckBoxPanel:DockMargin( 0, 0, 0, 0 )
	CheckBoxPanel:SetSize( FrameSizeX, 55 )
	CheckBoxPanel.Paint = function() end
	CheckBoxPanel:Dock( TOP )

	if GetConVar( "lvs_mouseaim_type" ):GetInt() == 1 and not LVS:IsDirectInputForced() then
		local CheckBoxType = vgui.Create( "DCheckBoxLabel", CheckBoxPanel )
		CheckBoxType:SetSize( FrameSizeX * 0.5, 55 )
		CheckBoxType:DockMargin( 16, 36, 0, 0 )
		CheckBoxType:Dock( LEFT )
		CheckBoxType:SetText( "Mouse-Aim for:" )
		CheckBoxType:SetConVar("lvs_mouseaim_type") 
		CheckBoxType.OnChange = function( self, bVal )
			if not isbool( self.first ) then self.first = true return end
			timer.Simple(0.1, function() LVS:OpenMenu( true ) end )
		end

		local DScrollPanel = vgui.Create("DScrollPanel", CheckBoxPanel )
		DScrollPanel:SetSize( FrameSizeX * 0.25, 55 )
		DScrollPanel:DockMargin( 8, 0, 8, 0 )
		DScrollPanel:Dock( LEFT )

		for _, vehicletype in pairs( LVS:GetVehicleTypes() ) do
			local ScrollOption = vgui.Create( "DCheckBoxLabel", DScrollPanel )
			ScrollOption:SetText( vehicletype )
			ScrollOption:Dock( TOP )
			ScrollOption:DockMargin( 0, 0, 0, 5 )
			ScrollOption:SetConVar("lvs_mouseaim_type_"..vehicletype) 
		end
	else
		local CheckBox = vgui.Create( "DCheckBoxLabel", CheckBoxPanel )
		CheckBox:SetSize( FrameSizeX * 0.5, 55 )
		CheckBox:DockMargin( 16, 36, 0, 0 )
		CheckBox:Dock( LEFT )
		CheckBox:SetText( "Mouse-Aim Steering" )
		CheckBox:SetConVar("lvs_mouseaim") 
		CheckBox.OnChange = function( self, bVal )
			if not isbool( self.first ) then self.first = true return end
			timer.Simple(0.1, function() LVS:OpenMenu( true ) end )
		end
		if LVS:IsDirectInputForced() then
			CheckBox:SetText( "[DISABLED] Use Mouse-Aim Steering" )
			CheckBox:SetDisabled( true )
		end

		if not LVS:IsDirectInputForced() then
			local CheckBoxType = vgui.Create( "DCheckBoxLabel", CheckBoxPanel )
			CheckBoxType:SetSize( FrameSizeX * 0.5, 55 )
			CheckBoxType:DockMargin( 16, 36, 0, 0 )
			CheckBoxType:Dock( LEFT )
			CheckBoxType:SetText( "Edit Mouse-Aim per Type" )
			CheckBoxType:SetConVar("lvs_mouseaim_type") 
			CheckBoxType.OnChange = function( self, bVal )
				if not isbool( self.first ) then self.first = true return end
				timer.Simple(0.1, function() LVS:OpenMenu( true ) end )
			end
		end
	end

	if GetConVar( "lvs_mouseaim" ):GetInt() == 0 or LVS:IsDirectInputForced() then
		local L = vgui.Create( "DPanel", TopPanel )
		L:SetSize( FrameSizeX * 0.5, FrameSizeY )
		L.Paint = function() end
		L:Dock( LEFT )

		local R = vgui.Create( "DPanel", TopPanel )
		R:SetSize( FrameSizeX * 0.5, FrameSizeY )
		R.Paint = function() end
		R:Dock( RIGHT )

		local slider = vgui.Create( "DNumSlider", R )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "Y Sensitivity" )
		slider:SetMin( -10 )
		slider:SetMax( 10 )
		slider:SetDecimals( 3 )
		slider:SetConVar( "lvs_sensitivity_y" )

		local slider = vgui.Create( "DNumSlider", L )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "X Sensitivity" )
		slider:SetMin( 0 )
		slider:SetMax( 10 )
		slider:SetDecimals( 3 )
		slider:SetConVar( "lvs_sensitivity_x" )

		local slider = vgui.Create( "DNumSlider", L )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "Return Delta" )
		slider:SetMin( 0 )
		slider:SetMax( 10 )
		slider:SetDecimals( 3 )
		slider:SetConVar( "lvs_return_delta" )
	else
		local slider = vgui.Create( "DNumSlider", TopPanel )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "Camera Focus" )
		slider:SetMin( -1 )
		slider:SetMax( 1 )
		slider:SetDecimals( 2 )
		slider:SetConVar( "lvs_camerafocus" )
	end

	local slider = vgui.Create( "DNumSlider", LeftPanel )
	slider:DockMargin( 16, 36, 16, 4 )
	slider:Dock( TOP )
	slider:SetText( "Engine Volume" )
	slider:SetMin( 0 )
	slider:SetMax( 1 )
	slider:SetDecimals( 2 )
	slider:SetConVar( "lvs_volume" )

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanel )
	CheckBox:DockMargin( 16, 43, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Show Team Identifier" )
	CheckBox:SetConVar("lvs_show_identifier") 
	if LVS:IsIndicatorForced() then
		CheckBox:SetText( "[DISABLED] Team Identifier" )
		CheckBox:SetDisabled( true )
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanel )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Show Hit/Kill Marker" )
	CheckBox:SetConVar("lvs_hitmarker") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanel )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Enable HUD Editor" )
	CheckBox:SetConVar("lvs_edit_hud") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 43, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Trail Effects" )
	CheckBox:SetConVar("lvs_show_traileffects") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Wind/Dust FX/SFX" )
	CheckBox:SetConVar("lvs_show_effects") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Scrape/Impact FX" )
	CheckBox:SetConVar("lvs_show_physicseffects") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Bullet near miss SFX" )
	CheckBox:SetConVar("lvs_bullet_nearmiss")
end

local function ClientControls( Canvas )
	local TextHint = vgui.Create("DPanel", Canvas)
	TextHint:DockMargin( 4, 20, 4, 2 )
	TextHint:SetText("")
	TextHint:Dock( TOP )
	TextHint.Paint = function(self, w, h ) 
		draw.DrawText( "You need to re-enter the vehicle in order for the changes to take effect!", "LVS_FONT_PANEL", w * 0.5, -1, Color( 255, 50, 50, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DScrollPanel = vgui.Create("DScrollPanel", Canvas)
	DScrollPanel:DockMargin( 0, 0, 0, 24 )
	DScrollPanel:Dock( FILL )

	for category, _ in pairs( LVS.KEYS_CATEGORIES ) do
		local Header = vgui.Create("DPanel", DScrollPanel )
		Header:DockMargin( 0, 4, 4, 2 )
		Header:SetText("")
		Header:Dock( TOP )
		Header.Paint = function(self, w, h ) 
			surface.SetMaterial( gradient_mat )
			surface.SetDrawColor( 80, 80, 80, 255 )
			surface.DrawTexturedRect( 0, 0, w, 1 )
	
			draw.DrawText( category, "LVS_FONT", 4, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end

		for _, entry in pairs( LVS.KEYS_REGISTERED ) do
			if entry.category ~= category then continue end

			local DPanel = vgui.Create( "DPanel", DScrollPanel )
			DPanel.Paint = function(self, w, h ) end
			DPanel:DockMargin( 4, 2, 4, 2 )
			DPanel:SetSize( FrameSizeX, 25 )
			DPanel:Dock( TOP )

			local ConVar = GetConVar( entry.cmd )

			local DLabel = vgui.Create("DLabel", DPanel)
			DLabel:DockMargin( 16, 0, 0, 0 )
			DLabel:SetText( entry.printname )
			DLabel:SetSize( FrameSizeX * 0.5, 32 )
			DLabel:Dock( LEFT )

			local DBinder = vgui.Create("DBinder", DPanel)
			DBinder:DockMargin( 0, 0, 0, 0 )
			DBinder:SetValue( ConVar:GetInt() )
			DBinder:SetSize( FrameSizeX * 0.5, 32 )
			DBinder:Dock( RIGHT )
			DBinder.ConVar = ConVar
			DBinder.OnChange = function(self,iNum)
				self.ConVar:SetInt(iNum)

				LocalPlayer():lvsBuildControls()
			end
		end
	end

	local Header = vgui.Create("DPanel", DScrollPanel )
	Header:DockMargin( 0, 16, 0, 0 )
	Header:SetText("")
	Header:Dock( TOP )
	Header.Paint = function(self, w, h ) 
		surface.SetMaterial( gradient_mat )
		surface.SetDrawColor( 80, 80, 80, 255 )
		surface.DrawTexturedRect( 0, 0, w, 1 )
	end

	local DButton = vgui.Create("DButton",DScrollPanel)
	DButton:SetText("Reset")
	DButton:DockMargin( 4, 0, 4, 4 )
	DButton:SetSize( FrameSizeX, 32 )
	DButton:Dock( TOP )
	DButton.DoClick = function() 
		surface.PlaySound( "buttons/button14.wav" )

		for _, entry in pairs( LVS.KEYS_REGISTERED ) do
			GetConVar( entry.cmd ):SetInt( entry.default ) 
		end

		LocalPlayer():lvsBuildControls()

		LVS:OpenClientControls()
	end
end

local function ServerSettings( Canvas )
	local slider = vgui.Create( "DNumSlider", Canvas )
	slider:DockMargin( 16, 32, 16, 4 )
	slider:Dock( TOP )
	slider:SetText( "Player Default AI-Team" )
	slider:SetMin( 0 )
	slider:SetMax( 3 )
	slider:SetDecimals( 0 )
	slider:SetConVar( "lvs_default_teams" )
	function slider:OnValueChanged( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_default_teams")
			net.WriteString( tostring( math.Round(val,0) ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Freeze Player AI-Team" )
	CheckBox:SetValue( GetConVar( "lvs_freeze_teams" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_freeze_teams")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Only allow Players of matching AI-Team to enter Vehicles" )
	CheckBox:SetValue( GetConVar( "lvs_teampassenger" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_teampassenger")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "LVS-AI ignore NPC's" )
	CheckBox:SetValue( GetConVar( "lvs_ai_ignorenpcs" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_ai_ignorenpcs")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "LVS-AI ignore Players's" )
	CheckBox:SetValue( GetConVar( "lvs_ai_ignoreplayers" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_ai_ignoreplayers")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Disable Mouse Aim" )
	CheckBox:SetValue( GetConVar( "lvs_force_directinput" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_force_directinput")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Hide Team Identifier" )
	CheckBox:SetValue( GetConVar( "lvs_force_forceindicator" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_force_forceindicator")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end
end

function LVS:OpenClientSettings()
	if not IsValid( LVS.Frame ) then return end

	local BasePanel = LVS.Frame:CreatePanel()

	local DPanel = vgui.Create( "DPanel", BasePanel )
	DPanel.Paint = function(self, w, h ) end
	DPanel:DockMargin( 0, 0, 0, 0 )
	DPanel:SetSize( FrameSizeX, 25 )
	DPanel:Dock( TOP )

	local TabPanel = vgui.Create( "DPanel", BasePanel )
	TabPanel.Paint = function(self, w, h ) end
	TabPanel:DockMargin( 0, 0, 0, 0 )
	TabPanel:SetSize( FrameSizeX, 25 )
	TabPanel:Dock( TOP )

	local SettingsPanel = vgui.Create( "DPanel", TabPanel )
	SettingsPanel:DockMargin( 0, 0, 0, 0 )
	SettingsPanel:SetSize( FrameSizeX * 0.5, 32 )
	SettingsPanel:Dock( LEFT )
	SettingsPanel.Paint = function(self, w, h ) 
		draw.DrawText( "SETTINGS", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", TabPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( RIGHT )
	DButton.DoClick = function()
		surface.PlaySound( "buttons/button14.wav" )
		LVS:OpenClientControls()
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			surface.SetDrawColor( 120, 120, 120, 255 )
		else
			surface.SetDrawColor( 80, 80, 80, 255 )
		end

		surface.DrawRect(1, 0, w-2, h-1)

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "CONTROLS", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", DPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( RIGHT )
	DButton.DoClick = function()
		if LocalPlayer():IsSuperAdmin() then
			surface.PlaySound( "buttons/button14.wav" )
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 120, 120, 120, 255 ) )
		else
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 80, 80, 80, 255 ) )
		end

		surface.SetDrawColor( 255, 255, 255, Hovered and 255 or 50 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( 3, 2, 16, 16 )

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "SERVER", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local ClientPanel = vgui.Create( "DPanel", DPanel )
	ClientPanel.Paint = function(self, w, h ) end
	ClientPanel:DockMargin( 0, 0, 0, 0 )
	ClientPanel:SetSize( FrameSizeX * 0.5, 32 )
	ClientPanel:Dock( LEFT )
	ClientPanel.Paint = function(self, w, h ) 
		draw.DrawText( "CLIENT", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local Canvas = vgui.Create( "DPanel", BasePanel )
	Canvas.Paint = function(self, w, h ) end
	Canvas:DockMargin( 0, 0, 0, 0 )
	Canvas:SetSize( FrameSizeX, 25 )
	Canvas:Dock( FILL )

	ClientSettings( Canvas )
end

function LVS:OpenClientControls()
	if not IsValid( LVS.Frame ) then return end

	local BasePanel = LVS.Frame:CreatePanel()

	local DPanel = vgui.Create( "DPanel", BasePanel )
	DPanel.Paint = function(self, w, h ) end
	DPanel:DockMargin( 0, 0, 0, 0 )
	DPanel:SetSize( FrameSizeX, 25 )
	DPanel:Dock( TOP )

	local TabPanel = vgui.Create( "DPanel", BasePanel )
	TabPanel.Paint = function(self, w, h ) end
	TabPanel:DockMargin( 0, 0, 0, 0 )
	TabPanel:SetSize( FrameSizeX, 25 )
	TabPanel:Dock( TOP )

	local SettingsPanel = vgui.Create( "DPanel", TabPanel )
	SettingsPanel:DockMargin( 0, 0, 0, 0 )
	SettingsPanel:SetSize( FrameSizeX * 0.5, 32 )
	SettingsPanel:Dock( RIGHT )
	SettingsPanel.Paint = function(self, w, h ) 
		draw.DrawText( "CONTROLS", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", TabPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( LEFT )
	DButton.DoClick = function()
		surface.PlaySound( "buttons/button14.wav" )
		LVS:OpenClientSettings()
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			surface.SetDrawColor( 120, 120, 120, 255 )
		else
			surface.SetDrawColor( 80, 80, 80, 255 )
		end

		surface.DrawRect(1, 1, w-2, h-2)

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "SETTINGS", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", DPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( RIGHT )
	DButton.DoClick = function()
		if LocalPlayer():IsSuperAdmin() then
			surface.PlaySound( "buttons/button14.wav" )
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 120, 120, 120, 255 ) )
		else
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 80, 80, 80, 255 ) )
		end

		surface.SetDrawColor( 255, 255, 255, Hovered and 255 or 50 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( 3, 2, 16, 16 )

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "SERVER", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local ClientPanel = vgui.Create( "DPanel", DPanel )
	ClientPanel.Paint = function(self, w, h ) end
	ClientPanel:DockMargin( 0, 0, 0, 0 )
	ClientPanel:SetSize( FrameSizeX * 0.5, 32 )
	ClientPanel:Dock( LEFT )
	ClientPanel.Paint = function(self, w, h ) 
		draw.DrawText( "CLIENT", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local Canvas = vgui.Create( "DPanel", BasePanel )
	Canvas.Paint = function(self, w, h ) end
	Canvas:DockMargin( 0, 0, 0, 0 )
	Canvas:SetSize( FrameSizeX, 25 )
	Canvas:Dock( FILL )

	ClientControls( Canvas )
end

function LVS:OpenServerMenu()
	if not IsValid( LVS.Frame ) then return end

	local BasePanel = LVS.Frame:CreatePanel()

	local DPanel = vgui.Create( "DPanel", BasePanel )
	DPanel.Paint = function(self, w, h ) end
	DPanel:DockMargin( 0, 0, 0, 0 )
	DPanel:SetSize( FrameSizeX, 25 )
	DPanel:Dock( TOP )

	local ServerPanel = vgui.Create( "DPanel", DPanel )
	ServerPanel.Paint = function(self, w, h ) end
	ServerPanel:DockMargin( 0, 0, 0, 0 )
	ServerPanel:SetSize( FrameSizeX * 0.5, 32 )
	ServerPanel:Dock( RIGHT )
	ServerPanel.Paint = function(self, w, h ) 
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( 3, 2, 16, 16 )
		draw.DrawText( "SERVER", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", DPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( LEFT )
	DButton.DoClick = function()
		surface.PlaySound( "buttons/button14.wav" )
		LVS:OpenClientSettings()
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 120, 120, 120, 255 ) )
		else
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 80, 80, 80, 255 ) )
		end

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "CLIENT", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local Canvas = vgui.Create( "DPanel", BasePanel )
	Canvas.Paint = function(self, w, h ) end
	Canvas:DockMargin( 0, 0, 0, 0 )
	Canvas:SetSize( FrameSizeX, 25 )
	Canvas:Dock( FILL )

	ServerSettings( Canvas )
end

function LVS:CloseMenu()
	if not IsValid( LVS.Frame ) then return end

	LVS.Frame:Close()
	LVS.Frame = nil
end

function LVS:OpenMenu( keep_position )
	local xPos
	local yPos

	if IsValid( LVS.Frame ) then
		if keep_position then
			xPos = LVS.Frame:GetX()
			yPos = LVS.Frame:GetY()
		end

		LVS:CloseMenu()
	end

	LVS.Frame = vgui.Create( "DFrame" )
	LVS.Frame:SetSize( FrameSizeX, FrameSizeY )
	LVS.Frame:SetTitle( "" )
	LVS.Frame:SetDraggable( true )
	LVS.Frame:SetScreenLock( true )
	LVS.Frame:MakePopup()
	LVS.Frame:Center()
	if keep_position and xPos and yPos then
		LVS.Frame:SetPos( xPos, yPos )
	end

	LVS.Frame.Paint = function(self, w, h )
		draw.RoundedBox( 8, 0, 0, w, h, Color( 0, 0, 0, 255 ) )
		draw.RoundedBoxEx( 8, 1, 26, w-2, h-27, Color( 120, 120, 120, 255 ), false, false, true, true )
		draw.RoundedBoxEx( 8, 0, 0, w, 25, LVS.ThemeColor, true, true )

		draw.SimpleText( "[LVS] - Control Panel ", "LVS_FONT", 5, 11, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		surface.SetDrawColor( 255, 255, 255, 50 )
		surface.SetMaterial( bgMat )
		surface.DrawTexturedRect( 0, -50, w, w )
	end
	LVS.Frame.CreatePanel = function( self )

		if IsValid( self.OldPanel ) then
			self.OldPanel:Remove()
			self.OldPanel = nil
		end

		local DPanel = vgui.Create( "DPanel", LVS.Frame )
		DPanel:SetPos( 0, 25 )
		DPanel:SetSize( FrameSizeX, FrameSizeY - 25 )
		DPanel.Paint = function(self, w, h )
			local Col = Color( 255, 191, 0, 255 ) 

			if LVS.VERSION_GITHUB == 0 then
				surface.SetMaterial( icon_load_version )
				surface.SetDrawColor( Col )
				surface.DrawTexturedRectRotated( w - 14, h - 14, 16, 16, -CurTime() * 200 )

				draw.SimpleText( "v"..LVS:GetVersion()..LVS.VERSION_TYPE, "LVS_VERSION", w - 23, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )

				return
			end

			local Current = LVS:GetVersion()
			local Latest = LVS.VERSION_GITHUB

			local Pref = "v"

			if Current >= Latest and not LVS.VERSION_ADDONS_OUTDATED then
				Col = Color(0,255,0,255)
			else
				Col = Color(255,0,0,255)
				Pref = "OUTDATED v"
			end

			draw.SimpleText( Pref..LVS:GetVersion()..LVS.VERSION_TYPE, "LVS_VERSION", w - 7, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		end

		self.OldPanel = DPanel

		return DPanel
	end

	LVS:OpenClientSettings()
end

list.Set( "DesktopWindows", "LVSMenu", {
	title = "[LVS] Settings",
	icon = "icon64/iconlvs.png",
	init = function( icon, window )
		LVS:OpenMenu()
	end
} )

concommand.Add( "lvs_openmenu", function( ply, cmd, args ) LVS:OpenMenu() end )
--PATH lua/lvs_framework/autorun/lvs_player.lua:
return gluapack()()
--PATH lua/autorun/marauder_addon.lua:
player_manager.AddValidModel( "Pirate Marauder", "models/player/ohanak_gang/pm_pirate_marauder.mdl" );
list.Set( "PlayerOptionsModel",  "Pirate Marauder", "models/player/ohanak_gang/pm_pirate_marauder.mdl" );


--PATH lua/autorun/mediaplayer.lua:
local basepath = "mediaplayer/"

local function IncludeMP( filepath )
	include( basepath .. filepath )
end

local function PreLoadMediaPlayer()
	-- Check if MediaPlayer has already been loaded
	if MediaPlayer then
		MediaPlayer.__refresh = true

		-- HACK: Lua refresh fix; access local variable of baseclass lib
		local _, BaseClassTable = debug.getupvalue(baseclass.Get, 1)
		for classname, _ in pairs(BaseClassTable) do
			if classname:find("mp_") then
				BaseClassTable[classname] = nil
			end
		end
	end
end

local function PostLoadMediaPlayer()
	if SERVER then
		-- Reinstall media players on Lua refresh
		for _, mp in pairs(MediaPlayer.GetAll()) do
			if mp:GetType() == "entity" and IsValid(mp) then
				local ent = mp:GetEntity()
				local snapshot = mp:GetSnapshot()
				local listeners = table.Copy(mp:GetListeners())

				-- remove media player
				mp:Remove()

				-- install new media player
				ent:InstallMediaPlayer()

				-- restore settings
				mp = ent._mp
				mp:RestoreSnapshot( snapshot )
				mp:SetListeners( listeners )
			end
		end
	end
end

local function LoadMediaPlayer()
	print( "Loading 'mediaplayer' addon..." )

	PreLoadMediaPlayer()

	-- shared includes
	IncludeCS "includes/extensions/sh_url.lua"
	IncludeCS "includes/modules/EventEmitter.lua"

	if SERVER then
		-- Add mediaplayer models
		resource.AddWorkshop( "546392647" )

		-- download clientside includes
		AddCSLuaFile "includes/modules/browserpool.lua"
		AddCSLuaFile "includes/modules/inputhook.lua"
		AddCSLuaFile "includes/modules/htmlmaterial.lua"
		AddCSLuaFile "includes/modules/spritesheet.lua"

		-- initialize serverside mediaplayer
		IncludeMP "init.lua"
	else
		-- clientside includes
		include "includes/modules/browserpool.lua"
		include "includes/modules/inputhook.lua"
		include "includes/modules/htmlmaterial.lua"
		include "includes/modules/spritesheet.lua"

		-- initialize clientside mediaplayer
		IncludeMP "cl_init.lua"
	end

	-- Sandbox includes; these must always be included as the gamemode is still
	-- set as 'base' when the addon is loading. Can't check if gamemode derives
	-- Sandbox.
	if SERVER then
		AddCSLuaFile "menubar/mp_options.lua"
		AddCSLuaFile "properties/mediaplayer.lua"
		AddCSLuaFile "sandbox/mediaplayer_dupe.lua"
	else
		include "menubar/mp_options.lua"
		include "properties/mediaplayer.lua"
		include "sandbox/mediaplayer_dupe.lua"
	end

	--
	-- Media Player menu includes; remove these if you would rather not include
	-- the sidebar menu.
	--
	if SERVER then
		AddCSLuaFile "mp_menu/cl_init.lua"
		include "mp_menu/init.lua"
	else
		include "mp_menu/cl_init.lua"
	end

	PostLoadMediaPlayer()
end

-- First time load
LoadMediaPlayer()

--PATH lua/autorun/includes/modules/spritesheet.lua:
local math = math
local surface = surface
local table = table

_G.spritesheet = {}

local icons = {}

--[[
	Icon format example:
	{
		name 	= "example-icon",  -- icon name
		mat 	= Material( "path/spritesheet.png" ), -- material for spritesheet
		w 		= 32, 	-- icon width
		h 		= 32, 	-- icon height
		xoffset = 64, 	-- x-axis offset relative to the texture (optional)
		yoffset = 128 	-- y-axis offset relative to the texture (optional)
	}
]]

local function registerIcon( icon )
	local name = icon.name
	if not name then
		MsgN( "Icon has no name" )
		return false
	end

	local mat = icon.mat
	if not mat or mat:IsError() then
		MsgN( "Icon '" .. name .. "' uses an invalid material '" .. mat:GetName() .. "'" )
		return false
	end

	-- calculate texture UV min/max coordinates
	local mw, mh = mat:Width(), mat:Height()
	local xoffset, yoffset = icon.xoffset or 0, icon.yoffset or 0
	local umin, vmin = xoffset / mw, yoffset / mh
	local umax, vmax = umin + (icon.w / mw), vmin + (icon.h / mh)

	icon.umin = umin
	icon.umax = umax
	icon.vmin = vmin
	icon.vmax = vmax

	-- remove unneeded properties
	icon.xoffset = nil
	icon.yoffset = nil

	return true
end

---
-- Registers a single or list of icons.
--
function spritesheet.Register( iconTbl )
	iconTbl = table.Copy( iconTbl or {} )

	-- passed in single icon; wrap inside table for iteration
	if #iconTbl == 0 then
		iconTbl = { iconTbl }
	end

	-- register all icons
	for _, icon in ipairs(iconTbl) do
		local valid = registerIcon( icon )
		if valid then
			icons[icon.name] = icon
		end
	end

	return true
end

---
-- Gets the icon's width and height
--
function spritesheet.GetIconSize( name )
	local icon = icons[name]
	if not icon then
		MsgN( "Invalid icon '" .. tostring(name) .. "' passed into spritesheet.GetIconSize!" )
		return
	end

	return icon.w, icon.h
end

function spritesheet.DrawIcon( name, x, y, w, h, color )
	local icon = icons[name]
	if not icon then
		MsgN( "Invalid icon '" .. tostring(name) .. "' passed into spritesheet.DrawIcon!" )
		return
	end

	if color then surface.SetDrawColor(color) end
	surface.SetMaterial(icon.mat)
	surface.DrawTexturedRectUV( x, y, w, h,
		icon.umin, icon.vmin, icon.umax, icon.vmax )
end

--PATH lua/mediaplayer/sh_mediaplayer.lua:
return gluapack()()
--PATH lua/mediaplayer/players/base/cl_fullscreen.lua:
return gluapack()()
--PATH lua/mediaplayer/players/base/net.lua:
return gluapack()()
--PATH lua/mediaplayer/services/base/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/services/youtube/shared.lua:
DEFINE_BASECLASS( "mp_service_base" )

SERVICE.Name 	= "YouTube"
SERVICE.Id 		= "yt"
SERVICE.Base 	= "browser"

local YtVideoIdPattern = "[%a%d-_]+"
local UrlSchemes = {
	"youtube%.com/watch%?v=" .. YtVideoIdPattern,
	"youtu%.be/watch%?v=" .. YtVideoIdPattern,
	"youtube%.com/v/" .. YtVideoIdPattern,
	"youtu%.be/v/" .. YtVideoIdPattern,
	"youtube%.googleapis%.com/v/" .. YtVideoIdPattern
}

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)
	obj._data = obj:GetYouTubeVideoId()
	return obj
end

function SERVICE:Match( url )
	for _, pattern in pairs(UrlSchemes) do
		if string.find( url, pattern ) then
			return true
		end
	end

	return false
end

function SERVICE:IsTimed()
	if self._istimed == nil then
		-- YouTube Live resolves to 0 second video duration
		self._istimed = self:Duration() > 0
	end

	return self._istimed
end

function SERVICE:GetYouTubeVideoId()

	local videoId

	if self.videoId then

		videoId = self.videoId

	elseif self.urlinfo then

		local url = self.urlinfo

		-- http://www.youtube.com/watch?v=(videoId)
		if url.query and url.query.v then
			videoId = url.query.v

		-- http://www.youtube.com/v/(videoId)
		elseif url.path and string.match(url.path, "^/v/([%a%d-_]+)") then
			videoId = string.match(url.path, "^/v/([%a%d-_]+)")

		-- http://youtube.googleapis.com/v/(videoId)
		elseif url.path and string.match(url.path, "^/v/([%a%d-_]+)") then
			videoId = string.match(url.path, "^/v/([%a%d-_]+)")

		-- http://youtu.be/(videoId)
		elseif string.match(url.host, "youtu.be") and
			url.path and string.match(url.path, "^/([%a%d-_]+)$") and
			( (not url.query) or #url.query == 0 ) then -- short url

			videoId = string.match(url.path, "^/([%a%d-_]+)$")
		end

		self.videoId = videoId

	end

	return videoId

end

--PATH lua/mediaplayer/services/vimeo/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_browser" )

local JS_SetVolume = "if(window.MediaPlayer) MediaPlayer.setVolume(%s);"
local JS_Seek = "if(window.MediaPlayer) MediaPlayer.seek(%s);"

local function VimeoSetVolume( self )
	if not self.Browser then return end
	local js = JS_SetVolume:format( MediaPlayer.Volume() )
	self.Browser:RunJavascript(js)
end

local function VimeoSeek( self, seekTime )
	if not self.Browser then return end
	local js = JS_Seek:format( seekTime )
	self.Browser:RunJavascript(js)
end

function SERVICE:SetVolume( volume )
	VimeoSetVolume( self )
end

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	local videoId = self:GetVimeoVideoId()

	-- local url = VimeoVideoUrl:format( videoId )
	-- browser:OpenURL( url )

	-- browser:QueueJavascript( JS_Init )

	-- local html = EmbedHTML:format( videoId )
	-- html = self.WrapHTML( html )
	-- browser:SetHTML( html )

	local url = "http://localhost/vimeo.html#" .. videoId
	browser:OpenURL( url )

end

function SERVICE:Sync()
	local seekTime = self:CurrentTime()
	if seekTime > 0 then
		VimeoSeek( self, seekTime )
	end
end

--PATH lua/mediaplayer/services/resource/shared.lua:
SERVICE.Name 	= "Resource"
SERVICE.Id 		= "res"
SERVICE.Base 	= "browser"
SERVICE.Abstract = true

SERVICE.FileExtensions = {}

function SERVICE:Match( url )
	-- check supported file extensions
	for _, ext in pairs(self.FileExtensions) do
		if url:find("([^/]+%." .. ext .. ")$") then
			return true
		end
	end

	return false
end

function SERVICE:IsTimed()
	return false
end

--PATH lua/mediaplayer/services/webpage.lua:
return gluapack()()
--PATH lua/mediaplayer/sh_metadata.lua:
--[[---------------------------------------------------------
	Media Player Metadata

	All media metadata is cached in an SQLite table for quick
	lookup and to prevent unnecessary network requests.
-----------------------------------------------------------]]

MediaPlayer.Metadata = {}

---
-- Default metadata table name
-- @type String
--
local TableName = "mediaplayer_metadata"

---
-- SQLite table struct
-- @type String
--
local TableStruct = string.format([[
CREATE TABLE %s (
	id				VARCHAR(48) PRIMARY KEY,
	title			VARCHAR(128),
	duration		INTEGER NOT NULL DEFAULT 0,
	thumbnail		VARCHAR(512),
	extra 			VARCHAR(2048),
	request_count	INTEGER NOT NULL DEFAULT 1,
	last_request	INTEGER NOT NULL DEFAULT 0,
	last_updated	INTEGER NOT NULL DEFAULT 0,
	expired			BOOLEAN NOT NULL DEFAULT 0
)]], TableName)

---
-- Maximum cache age before it expires; currently one week in seconds.
-- @type Number
--
local MaxCacheAge = 604800

---
-- Query the metadata table for the given media object's metadata.
-- If the metadata is older than one week, it is ignored and replaced upon
-- saving.
--
-- @param media		Media service object.
-- @return table	Cached metadata results.
--
function MediaPlayer.Metadata:Query( media )
	local id = media:UniqueID()
	if not id then return end

	local query = ("SELECT * FROM `%s` WHERE id='%s'"):format(TableName, id)

	if MediaPlayer.DEBUG then
		print("MediaPlayer.Metadata.Query")
		print(query)
	end

	local results = sql.QueryRow(query)

	if results then
		local expired = ( tonumber(results.expired) == 1 )

		-- Media metadata has been marked as out-of-date
		if expired then
			return nil
		end

		local lastupdated = tonumber( results.last_updated )
		local timediff = os.time() - lastupdated

		if timediff > MaxCacheAge then

			-- Set metadata entry as expired
			query = "UPDATE `%s` SET expired=1 WHERE id='%s'"
			query = query:format( TableName, id )

			if MediaPlayer.DEBUG then
				print("MediaPlayer.Metadata.Query: Setting entry as expired")
				print(query)
			end

			sql.Query( query )

			return nil

		else
			return results
		end
	elseif results == false then
		ErrorNoHalt("MediaPlayer.Metadata.Query: There was an error executing the SQL query\n")
		print(query)
	end

	return nil
end

---
-- Save or update the given media object into the metadata table.
--
-- @param media		Media service object.
-- @return table	SQL query results.
--
function MediaPlayer.Metadata:Save( media )
	local id = media:UniqueID()
	if not id then return end

	local query = ("SELECT expired FROM `%s` WHERE id='%s'"):format(TableName, id)
	local results = sql.Query(query)

	if istable(results) then -- update

		if MediaPlayer.DEBUG then
			print("MediaPlayer.Metadata.Save Results:")
			PrintTable(results)
		end

		results = results[1]

		local expired = ( tonumber(results.expired) == 1 )

		if expired then

			-- Update possible new metadata
			query = "UPDATE `%s` SET request_count=request_count+1, title=%s, duration=%s, thumbnail=%s, extra=%s, last_request=%s, last_updated=%s, expired=0 WHERE id='%s'"
			query = query:format( TableName,
						sql.SQLStr( media:Title() ),
						media:Duration(),
						sql.SQLStr( media:Thumbnail() ),
						sql.SQLStr( util.TableToJSON(media._metadata.extra or {}) ),
						os.time(),
						os.time(),
						id )

		else

			query = "UPDATE `%s` SET request_count=request_count+1, last_request=%s WHERE id='%s'"
			query = query:format( TableName, os.time(), id )

		end

	else -- insert

		query = string.format( "INSERT INTO `%s` ", TableName ) ..
			"(id,title,duration,thumbnail,extra,last_request,last_updated) VALUES (" ..
			string.format( "'%s',", id ) ..
			string.format( "%s,", sql.SQLStr( media:Title() ) ) ..
			string.format( "%s,", media:Duration() ) ..
			string.format( "%s,", sql.SQLStr( media:Thumbnail() ) ) ..
			string.format( "%s,", sql.SQLStr( util.TableToJSON(media._metadata.extra or {}) ) ) ..
			string.format( "%d,", os.time() ) ..
			string.format( "%d)", os.time() )

	end

	if MediaPlayer.DEBUG then
		print("MediaPlayer.Metadata.Save")
		print(query)
	end

	results = sql.Query(query)

	if results == false then
		ErrorNoHalt("MediaPlayer.Metadata.Save: There was an error executing the SQL query\n")
		print(query)
	end

	return results
end

-- Create the SQLite table if it doesn't exist
if not sql.TableExists(TableName) then
	Msg("MediaPlayer.Metadata: Creating `" .. TableName .. "` table...\n")
	sql.Query(TableStruct)
end

--PATH lua/mediaplayer/cl_screen.lua:
--[[---------------------------------------------------------
	Pass mouse clicks into media player browser
-----------------------------------------------------------]]

local MAX_SCREEN_DISTANCE = 1000

local function getScreenPos( ent, aimVector )
	local w, h, pos, ang = ent:GetMediaPlayerPosition()
	local eyePos = LocalPlayer():EyePos()

	if pos:Distance( eyePos ) > MAX_SCREEN_DISTANCE then
		return
	end

	local screenNormal = ang:Up()

	if screenNormal:Dot( aimVector ) > 0 then
		return -- prevent clicks from behind the screen
	end

	local hitPos = util.IntersectRayWithPlane(
		eyePos,
		aimVector,
		pos,
		screenNormal
	)

	if not hitPos then
		return
	end

	if MediaPlayer.DEBUG then
		debugoverlay.Cross( hitPos, 1, 60 )
	end

	local localPos = WorldToLocal( pos, ang, hitPos, ang )
	local x, y = -localPos.x, localPos.y

	if ( x < 0 or x > w ) or ( y < 0 or y > h ) then
		return -- out of screen bounds
	end

	return x / w, y / h
end

function MediaPlayer.DispatchScreenTrace( func, aimVector )
	if type(func) ~= "function" then return end
	if not aimVector then
		aimVector = LocalPlayer():GetAimVector()
	end

	for name, mp in pairs( MediaPlayer.List ) do
		local ent = mp.Entity
		if IsValid( mp ) and not ent:IsDormant() then
			local x, y = getScreenPos( ent, aimVector )
			if x and y then
				func(mp, x, y)
			end
		end
	end
end

local function mpMouseReleased( mp, x, y )
	mp:OnMousePressed(x, y)
end

local function mousePressed( mouseCode, aimVector )
	if mouseCode ~= MOUSE_LEFT then
		return
	end

	MediaPlayer.DispatchScreenTrace( mpMouseReleased, aimVector )
end
hook.Add( "GUIMouseReleased", "MediaPlayer.ScreenIntersect", mousePressed )


--[[---------------------------------------------------------
	Pass mouse scrolling into media player browser
-----------------------------------------------------------]]

local mouseScroll = MediaPlayerUtils.Throttle(function( dt )
	MediaPlayer.DispatchScreenTrace(function(mp)
		mp:OnMouseWheeled(dt)
	end, aimVector)
end, 0.01, { trailing = false })

hook.Add( "ContextMenuCreated", "MediaPlayer.Scroll", function( contextMenu )
	if contextMenu.OnMouseWheeled then return end
	contextMenu.OnMouseWheeled = function(panel, scrollDelta)
		mouseScroll(scrollDelta)
	end
end )

--[[
local function checkMouseScroll( ply, cmd )
	local scrollDelta = cmd:GetMouseWheel()
	if scrollDelta == 0 then return end
	mouseScroll(scrollDelta)
end
hook.Add( "StartCommand", "MediaPlayer.Scroll", checkMouseScroll )
]]

--[[---------------------------------------------------------
	Prevent weapons from firing while the context menu is
	open and the cursor is aiming at a screen.
-----------------------------------------------------------]]

local function isAimingAtScreen()
	local aimVector = LocalPlayer():GetAimVector()
	for name, mp in pairs( MediaPlayer.List ) do
		local ent = mp.Entity
		if IsValid( mp ) and not ent:IsDormant() then
			local x, y = getScreenPos( ent, aimVector )
			if x then
				return true
			end
		end
	end
end

local function preventWorldClicker()
	local ply = LocalPlayer()

	if not ply:IsWorldClicking() then return end

	local ent = ply:GetEyeTrace().Entity
	if not ( IsValid(ent) and ent.IsMediaPlayerEntity ) then return end

	if isAimingAtScreen() then
		return true
	end
end
hook.Add( "PreventScreenClicks", "MediaPlayer.PreventWorldClicker", preventWorldClicker )

--PATH lua/mp_menu/sidebar.lua:
include "icons.lua"
include "common.lua"
include "sidebar_tabs.lua"
include "volume_control.lua"
include "playback.lua"
include "queue.lua"
include "horizontal_list.lua"


--[[--------------------------------------------
	Sidebar root panel
----------------------------------------------]]

local PANEL = {}

function PANEL:Init()

	self:SetName( "MediaPlayerSidebar" )

	self:SetPaintBackgroundEnabled( true )
	self:SetPaintBorderEnabled( false )

	self:SetZPos( -99 )
	self:SetSize( 385, 580 )

	self.Tabs = vgui.Create( "MP.SidebarTabs", self )
	self.Tabs:Dock( FILL )

	local curplaytab = vgui.Create( "MP.CurrentlyPlayingTab" )
	self.Tabs:AddSheet( "CURRENTLY PLAYING", curplaytab, nil, false, false )

	-- TODO: Implement clientside media history for recently viewed tab
	-- local panel = vgui.Create( "Panel" )
	-- self.Tabs:AddSheet( "RECENTLY VIEWED", panel, nil, false, false )

	self.VolumeControls = vgui.Create( "MP.VolumeControl", self )
	self.VolumeControls:Dock( BOTTOM )
	self.VolumeControls:SetHeight( 48 )

	self:InvalidateLayout( true )

end

function PANEL:Paint(w, h)

	surface.SetDrawColor( 0, 0, 0, 140 )
	surface.DrawRect( 0, 0, w, h )

end

function PANEL:PerformLayout()

	self:CenterVertical()
	self:AlignLeft( 10 )

	self.Tabs:SizeToContentWidth()

end

local MP_SIDEBAR = vgui.RegisterTable( PANEL, "EditablePanel" )


--[[--------------------------------------------
	Sidebar presenter
----------------------------------------------]]

local SidebarPresenter = {
	hooks = {}
}

AccessorFunc( SidebarPresenter, "m_Media", "Media" )

function SidebarPresenter:RegisterHook( hookname, callback )

	table.insert( self.hooks, hookname )

	hook.Add( hookname, "MP.SidebarPresenter", function(...)
		if MediaPlayer.DEBUG then
			print("MP.EVENTS.UI", hookname)
			PrintTable({...})
		end

		return callback(...)
	end )

end

function SidebarPresenter:SetupEvents()

	local mp = self:GetMedia()

	self:RegisterHook( MP.EVENTS.UI.OPEN_REQUEST_MENU, function()
		self:HideSidebar()
		MediaPlayer.OpenRequestMenu( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.FAVORITE_MEDIA, function( media )
		-- TODO
	end )

	self:RegisterHook( MP.EVENTS.UI.REMOVE_MEDIA, function( media )
		if not media then return end
		MediaPlayer.RequestRemove( mp, media:UniqueID() )
	end )

	self:RegisterHook( MP.EVENTS.UI.SKIP_MEDIA, function()
		MediaPlayer.Skip( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.TOGGLE_LOCK, function()
		MediaPlayer.RequestLock( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.TOGGLE_PAUSE, function()
		MediaPlayer.Pause( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.TOGGLE_REPEAT, function()
		MediaPlayer.RequestRepeat( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.TOGGLE_SHUFFLE, function()
		MediaPlayer.RequestShuffle( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.SEEK, function( seekTime )
		MediaPlayer.Seek( mp, seekTime )
	end )

	self:RegisterHook( MP.EVENTS.UI.PRIVILEGED_PLAYER, function()
		local ply = LocalPlayer()
		return mp:IsPlayerPrivileged(ply)
	end )

end

function SidebarPresenter:ClearEvents()

	for _, hookname in ipairs(self.hooks) do
		hook.Remove( hookname, "MP.SidebarPresenter" )
	end

end

function SidebarPresenter:ShowSidebar( mp )

	self:SetMedia( mp )

	if ValidPanel(self.Sidebar) then
		self:HideSidebar()
	end

	self:SetupEvents()

	-- Can be used to extend sidebar functionality
	hook.Run( MP.EVENTS.UI.SETUP_SIDEBAR, self, mp )

	local sidebar = vgui.CreateFromTable( MP_SIDEBAR )
	sidebar:MakePopup()

	-- sidebar:SetKeyboardInputEnabled( false )
	sidebar:SetMouseInputEnabled( true )

	hook.Run( MP.EVENTS.UI.MEDIA_PLAYER_CHANGED, mp )

	self.Sidebar = sidebar

end

function SidebarPresenter:HideSidebar()

	if not self.Sidebar then return end

	self:ClearEvents()

	if ValidPanel(self.Sidebar) then
		self.Sidebar:Remove()
	end

	self.Sidebar = nil

end


--[[--------------------------------------------
	MediaPlayer library sidebar helpers
----------------------------------------------]]

function MediaPlayer.ShowSidebar( mp )

	--
	-- Find a valid media player to use for the sidebar
	--

	-- First check if we're looking at a media player
	if not mp then
		local ent = LocalPlayer():GetEyeTrace().Entity
		if IsValid(ent) then
			mp = MediaPlayer.GetByObject( ent )
		end
	end

	-- Else, maybe the gamemode handles this some other way (location system, etc.)
	if not mp then
		mp = hook.Run( "GetMediaPlayer" )
	end

	-- If we still can't find a media player, give up..
	if not IsValid(mp) then return end

	SidebarPresenter:ShowSidebar( mp )

end

function MediaPlayer.HideSidebar()

	SidebarPresenter:HideSidebar()

end

hook.Add( "OnContextMenuOpen", "MP.ShowSidebar", function()
	MediaPlayer.ShowSidebar()
end )
hook.Add( "OnContextMenuClose", "MP.HideSidebar", function()
	MediaPlayer.HideSidebar()
end )

--[[--------------------------------------------
	Sidebar UI test - remove this eventually
----------------------------------------------]]

--[[inputhook.AddKeyPress( KEY_PAGEUP, "MP.ShowSidebarTest", function()
	-- Create test fixture
	local mp = MediaPlayer.Create( 'ui-test-player' )
	mp:SetPlayerState( MP_STATE_PLAYING )

	local function CreateMedia( title, duration, url, ownerName, ownerSteamID, startTime )
		local media = MediaPlayer.GetMediaForUrl( url )

		media._metadata = {
			title = title,
			duration = duration
		}

		media._OwnerName = ownerName
		media._OwnerSteamID = ownerSteamID
		media:StartTime( startTime or RealTime() )

		return media
	end

	---------------------------------
	-- Create current media object
	---------------------------------

	mp:SetMedia( CreateMedia(
		"Test media - really long title test asdfljkasdfasdjfgasdf",
		10,
		"https://www.youtube.com/watch?v=IMorTE0lFLc",
		"WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
		"STEAM_0:1:15862026"
	) )


	---------------------------------
	-- Create queued media
	---------------------------------

	mp:AddMedia( CreateMedia(
		"Test media - really long title test asdfljkasdfasdjfgasdf",
		86400,
		"https://www.youtube.com/watch?v=IMorTE0lFLc",
		"WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
		"STEAM_0:1:15862026"
	) )

	mp:AddMedia( CreateMedia(
		"Hello world",
		1800,
		"https://www.youtube.com/watch?v=IMorTE0lFLc",
		"Sam",
		"STEAM_0:1:15862026"
	) )

	mp:AddMedia( CreateMedia(
		"ASDSDFawcasiudcg awlieufgawlie",
		180,
		"https://www.youtube.com/watch?v=IMorTE0lFLc",
		"(╯°□°）╯︵ ┻━┻",
		"STEAM_0:1:15862026",
		RealTime() - 1800
	) )

	-- Display UI using fixture
	MediaPlayer.ShowSidebar( mp )
end )]]

--PATH lua/mp_menu/playback.lua:
return gluapack()()
--PATH lua/mp_menu/playback.lua:
local math = math
local ceil = math.ceil
local clamp = math.Clamp

local surface = surface
local color_white = color_white

local PANEL = {}

PANEL.Height = 72

PANEL.BgColor = Color( 13, 41, 62 )
PANEL.Padding = 12
PANEL.BtnSpacing = 4

-- PANEL.TrackbarProgressColor = Color( 28, 100, 157 )
PANEL.SeekbarHeight = 8

PANEL.TitleMaxWidth = 335

PANEL.KnobSize = 8

function PANEL:Init()

	self.PlayPauseBtn = vgui.Create( "MP.PlayPauseButton", self )

	self.MediaTitle = vgui.Create( "MP.MediaTitle", self )
	self.MediaTitle:SetText( "Very Bad Video That Everyone Hates Included" )

	self.MediaTime = vgui.Create( "MP.MediaTime", self )
	self.MediaTime:SetShowCurrentTime( true )
	self.MediaTime:SetListenForSeekEvents( true )

	self.BtnList = vgui.Create( "DHorizontalList", self )
	self.BtnList:SetSpacing( self.BtnSpacing )

	self.FavBtn = vgui.Create( "MP.FavoriteButton", self )

	hook.Run( MP.EVENTS.UI.SETUP_PLAYBACK_PANEL, self )

	if hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then
		self.SkipBtn = vgui.Create( "MP.SkipButton" )
		self:AddButton( self.SkipBtn )
	end

	self.AddedByLbl = vgui.Create( "MP.AddedBy", self )

	self.Seekbar = vgui.Create( "MP.Seekbar", self )

	self.NextThink = 0

end

function PANEL:AddButton( panel )
	self.BtnList:AddItem( panel )
end

function PANEL:Think()

	local rt = RealTime()

	if rt > self.NextThink then
		-- Perform layout every second for when the media label changes width
		self:InvalidateLayout()
		self.NextThink = rt + 1
	end

end

function PANEL:OnMediaChanged( media )

	self._Media = media

	if media then
		local title = media:Title()
		self.MediaTitle:SetText( title )
		self.MediaTitle:SetToolTip( title )

		self.AddedByLbl:SetPlayer( media:GetOwner(), media:OwnerName(), media:OwnerSteamID() )

		self.AddedByLbl:Show()
		self.FavBtn:Hide()
		self.BtnList:Show()
	else
		self.MediaTitle:SetText( "No media playing" )
		self.MediaTitle:SetTooltip( "" )

		self.AddedByLbl:Hide()
		self.FavBtn:Hide()
		self.BtnList:Hide()
	end

	if media and media:IsTimed() then
		self.MediaTime:SetMedia( media )

		self.Seekbar:SetMedia( media )
		self.Seekbar:Show()
	else
		self.MediaTime:SetMedia( nil )
		self.MediaTime:Hide()

		self.Seekbar:SetMedia( nil )
		self.Seekbar:Hide()
	end

	-- apply media for all buttons
	for _, btn in pairs( self.BtnList:GetItems() ) do
		if ValidPanel(btn) and isfunction(btn.SetMedia) then
			btn:SetMedia( media )
		end
	end

	self:InvalidateLayout()

end

function PANEL:OnPlayerStateChanged( playerState )

	self.PlayPauseBtn:SetPlayerState( playerState )

end

function PANEL:Paint( w, h )

	surface.SetDrawColor( self.BgColor )
	surface.DrawRect( 0, 0, w, h - self.SeekbarHeight / 2 )

end

function PANEL:PerformLayout()

	local w, h = self:GetSize()

	self:SetTall( self.Height )

	self.PlayPauseBtn:CenterVertical()
	self.PlayPauseBtn:AlignLeft( self.Padding )

	self.MediaTitle:SizeToContents()
	self.MediaTitle:MoveRightOf( self.PlayPauseBtn, self.Padding )

	if self._Media then
		self.MediaTitle:AlignTop( self.Padding )
	else
		self.MediaTitle:CenterVertical()
	end

	self.MediaTime:InvalidateLayout()
	self.MediaTime:MoveRightOf( self.PlayPauseBtn, self.Padding )
	self.MediaTime:AlignBottom( self.Padding - 2 )

	self.FavBtn:AlignTop( self.Padding )
	self.FavBtn:AlignRight( self.Padding )

	self.BtnList:InvalidateLayout(true)
	self.BtnList:AlignBottom( self.Padding )
	self.BtnList:AlignRight( self.Padding )

	-- 'ADDED BY Name' needs to fit between the media time and the rightmost
	-- buttons.
	local addedByMaxWidth = ( self.BtnList:GetPos() - self.BtnSpacing ) -
		( self.MediaTime:GetPos() + self.MediaTime:GetWide() + self.Padding )

	self.AddedByLbl:SetMaxWidth( addedByMaxWidth )
	self.AddedByLbl:AlignBottom( self.Padding )
	self.AddedByLbl:MoveLeftOf( self.BtnList, self.BtnSpacing )

	local maxTitleWidth = ( self.FavBtn:GetPos() - self.BtnSpacing ) -
		( self.MediaTitle:GetPos() )

	if self.MediaTitle:GetWide() > maxTitleWidth then
		self.MediaTitle:SetWide( maxTitleWidth )
	end

	self.Seekbar:SetSize( w, self.SeekbarHeight )
	self.Seekbar:SetPos( 0, h - self.SeekbarHeight )

	self:SetTall( self.Height + self.SeekbarHeight / 2 )

end

derma.DefineControl( "MP.Playback", "", PANEL, "Panel" )


local PLAYPAUSE_BTN = {
	StateIcons = {
		[1] = nil, -- MP_STATE_ENDED
		[2] = "mp-pause", -- MP_STATE_PLAYING
		[3] = "mp-play" -- MP_STATE_PAUSED
	}
}

function PLAYPAUSE_BTN:Init()
	self.BaseClass.Init( self )

	self:SetSize( 22, 25 )
	self:SetHighlighted( true )
end

function PLAYPAUSE_BTN:SetPlayerState( playerState )

	self.PlayerState = playerState

	playerState = (playerState or 0) + 1 -- Lua can't index 0

	local icon = self.StateIcons[ playerState ]

	if icon then
		self:SetIcon( icon )
		self:SetIconVisible(true)
	else
		self:SetIconVisible(false)
	end

	-- Set cursor type depending on whether player is admin/owner
	if hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then
		self:SetCursor( "hand" )
	else
		self:SetCursor( "arrow" )
	end

end

function PLAYPAUSE_BTN:DoClick()

	hook.Run( MP.EVENTS.UI.TOGGLE_PAUSE )

end

derma.DefineControl( "MP.PlayPauseButton", "", PLAYPAUSE_BTN, "MP.SidebarButton" )


local SEEKBAR = {}

SEEKBAR.KnobSize = 8
SEEKBAR.BarHeight = 2

SEEKBAR.ProgressColor = Color( 28, 100, 157 )

AccessorFunc( SEEKBAR, "m_Media", "Media" )

function SEEKBAR:Init()

	self.BaseClass.Init( self )

	self.Knob:SetSize( self.KnobSize, self.KnobSize )
	self.Knob.Paint = self.PaintKnob

	self.Knob.OnMousePressed = function( panel, mousecode )
			self:OnStartEditing( self )
			DButton.OnMousePressed( panel, mousecode )
		end
	self.Knob.OnMouseReleased = function( panel, mousecode )
			self:OnStopEditing( self )
			DButton.OnMouseReleased( panel, mousecode )
		end

	-- Remove some hidden panel child from the inherited DSlider control; I have
	-- no idea where it's being created...
	for _, child in pairs( self:GetChildren() ) do
		if child ~= self.Knob then
			child:Remove()
		end
	end

end

function SEEKBAR:OnStartEditing()

	-- only allow admins/owners to control seeking
	if not hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then return end

	hook.Run( MP.EVENTS.UI.START_SEEKING, self )

end

function SEEKBAR:OnStopEditing()

	-- only allow admins/owners to control seeking
	if not hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then return end

	hook.Run( MP.EVENTS.UI.STOP_SEEKING, self )

	if self.m_Media then
		local seekTime = ceil(self.m_fSlideX * self.m_Media:Duration())
		hook.Run( MP.EVENTS.UI.SEEK, seekTime )
	end

end

function SEEKBAR:OnMousePressed( mcode )
	self:OnStartEditing()
	self.BaseClass.OnMousePressed( self, mcode )
end

function SEEKBAR:OnMouseReleased( mcode )
	self:OnStopEditing()
	self.BaseClass.OnMouseReleased( self, mcode )
end

function SEEKBAR:Think()

	local media = self.m_Media

	if media and not self:IsEditing() then
		local progress = media:CurrentTime() / media:Duration()
		progress = clamp(progress, 0, 1)

		self:SetSlideX( progress )
		self:InvalidateLayout()
	end

end

function SEEKBAR:Paint( w, h )

	local midy = ceil( h / 2 )
	local bary = ceil(midy - (self.BarHeight / 2))

	local progress = self:GetSlideX()

	surface.SetDrawColor( self.ProgressColor )
	surface.DrawRect( 0, bary, ceil(w * progress), self.BarHeight )

end

function SEEKBAR:PaintKnob( w, h )

	draw.RoundedBoxEx( ceil(w/2), 0, 0, w, h, color_white, true, true, true, true )

end

derma.DefineControl( "MP.Seekbar", "", SEEKBAR, "DSlider" )

--PATH lua/mp_menu/horizontal_list.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/language/tr.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/ui/msdframe.lua:
return gluapack()()
--PATH lua/mvp/core/logger/sh_logger.meta.lua:
mvp = mvp or {}
mvp.meta = mvp.meta or {}

mvp.meta.logger = mvp.meta.logger or {}
mvp.meta.logger.__proto = mvp.meta.logger

mvp.meta.logger.__proto.isLogger = true

function mvp.meta.logger:New()
    local o = table.Copy(self.__proto)

    setmetatable(o, self)
    o.__index = self

    return o
end

function mvp.meta.logger:Init()
    ErrorNoHalt("Not implemented")
end

function mvp.meta.logger:Log(...)
    ErrorNoHalt("Not implemented")
end
--PATH lua/mvp/core/ui/cl_gradient.lua:
return gluapack()()
--PATH lua/mvp/core/util/sh_kitchensink.lua:
return gluapack()()
--PATH lua/mvp/core/util/sh_lerps.lua:
return gluapack()()
--PATH lua/mvp/core/config/sh_config.lua:
return gluapack()()
--PATH lua/mvp/core/config/sh_config.lua:
mvp = mvp or {}
mvp.config = mvp.config or {}

mvp.config.list = mvp.config.list or {}

mvp.config.categories = {}
mvp.config.sections = {}

function mvp.config.RegisterSection(name, sortIndex)
    if (mvp.config.sections[name]) then 
        return name, mvp.config.sections[name] 
    end

    local sectionTbl = {
        name = name,
        sortIndex = sortIndex or 99,
        categories = {}
    }

    mvp.config.sections[name] = sectionTbl

    return name, sectionTbl
end

function mvp.config.RegisterCategory(name, section, sortIndex)
    if (mvp.config.GetCategoryByName(name, section)) then 
        return mvp.config.GetCategoryByName(name, section)
    end
    
    local nextIndex = #mvp.config.categories + 1
    
    local categoryTbl = {
        name = name,
        section = section,
        sortIndex = sortIndex or 99,
        configs = {}
    }

    mvp.config.categories[nextIndex] = categoryTbl
    mvp.config.sections[section].categories[nextIndex] = categoryTbl

    return nextIndex, categoryTbl
end

function mvp.config.GetCategoryByName(name, section)
    for index, category in ipairs(mvp.config.categories) do
        if (not section) then
            if (category.name == name) then
                return index, category -- guess we can return first one we find
            end
        else
            if (category.name == name and category.section == section) then
                return index, category
            end
        end
    end
end

function mvp.config.GetCategory(index)
    return index, mvp.config.categories[index]
end

function mvp.config.Add(key, defaultValue, configuration, sortIndex)
    mvp.utils.AssertType(key, mvp.type.string, "mvp.config.Add", 1)
    mvp.utils.Assert(defaultValue ~= nil, "mvp.config.Add", 2)
    mvp.utils.AssertType(configuration, mvp.type.array, "mvp.config.Add", 3)

    configuration = istable(configuration) and configuration or {}

    local oldConfig = mvp.config.list[key]
    local typeOf = configuration.typeOf or mvp.types.GetTypeFromValue(defaultValue)

    mvp.utils.AssertNamed(typeOf, "mvp.config.Add", "configuration.typeOf", 3)

    local currentValue = defaultValue

    if (oldConfig ~= nil) then
        if (oldConfig.value ~= nil) then
            currentValue = oldConfig.value
        end

        if (oldConfig.default ~= nil) then
            defaultValue = oldConfig.default
        end
    end

    mvp.config.list[key] = {
        key = key,
        typeOf = typeOf,
        value = currentValue,
        default = defaultValue,

        description = configuration.description or "",
        category = configuration.category or "Other",

        isServerOnly = configuration.isServerOnly or false,
        isMapOnly = configuration.isMapOnly or false,

        preSet = configuration.preSet or function() end,
        postSet = configuration.postSet or function() end,

        ui = configuration.ui or {},
        sortIndex = sortIndex or 99
    }

    if (configuration.category) then
        local _, category = mvp.config.GetCategory(configuration.category)

        if (category) then
            category.configs[key] = mvp.config.list[key]
        end
    end

    mvp.logger.Log(mvp.LOG.DEBUG, "Config", "Added config key '" .. key .. "'")
    hook.Run("mvp.config.Added", key, defaultValue, configuration)
end

function mvp.config.Get(key, defaultValue)
    local config = mvp.config.list[key]

    if (config and config.typeOf) then
        if (config.value ~= nil) then
            return config.value
        end

        if (config.default ~= nil) then
            return config.default
        end
    end
    
    return defaultValue
end

function mvp.config.GetStored(key)
    local config = mvp.config.list[key]

    if (config and config.typeOf) then
        return config
    end
end

function mvp.config.GetList()
    return mvp.config.list
end

function mvp.config.Set(key, value)
    local config = mvp.config.list[key]

    if (not config or not config.typeOf) then
        -- @todo: throw error, for now just return
        return
    end

    if (SERVER) then
        mvp.config.UpdateValue(key, value)
    else
        net.Start("mvp.config.ChangeValue")
            net.WriteString(key)
            net.WriteType(value)
        net.SendToServer()
    end
end

function mvp.config.InitFolder(path)
    mvp.loader.LoadFolder(path)
end

function mvp.config.Init()
    mvp.q.LogInfo("Configs", "Loading Terminal configs system...")
    mvp.config.InitFolder("configs")

    hook.Run("mvp.config.Inited")
end
--PATH lua/mvp/credits/sh_contributors.lua:
return gluapack()()
--PATH lua/mvp/core/command/sh_command.meta.lua:
return gluapack()()
--PATH lua/mvp/packages/radialmenu/languages/en.lua:
return gluapack()()
--PATH lua/mvp/packages/radialmenu/languages/ru.lua:
return gluapack()()
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/languages/en.lua:
return gluapack()()
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/sh_animations_list.lua:
local P = mvp.package.Get()

P.animations.list = {}
P.animations.listSeq = {}

P.animations.Add("salute", {
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(80, -95, -77.5),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(35, -125, -5),
})

P.animations.Add("surrender", {
    ["ValveBiped.Bip01_L_Forearm"] = Angle(25, -65, 25),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(-25, -65, -25),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(-70, -180, 70),
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(70, -180, -70)
}) 

P.animations.Add("armsinfront", {
    ["ValveBiped.Bip01_R_Forearm"] = Angle(-43, -107, 15),
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(20, -57, -6),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(-28, -59, 1),
    ["ValveBiped.Bip01_R_Thigh"] = Angle(4, -6, -0),
    ["ValveBiped.Bip01_L_Thigh"] = Angle(-7, -0, 0),
    ["ValveBiped.Bip01_L_Forearm"] = Angle(51, -120, -18),
    ["ValveBiped.Bip01_R_Hand"] = Angle(14, -33, -7),
    ["ValveBiped.Bip01_L_Hand"] = Angle(25, 31, -14),
})

P.animations.Add("armsbehind", {
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(3, 15, 2),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(-63, 1 , -84),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(3, 15, 2.654),
    ["ValveBiped.Bip01_L_Forearm"] = Angle(53, -29, 31),
    ["ValveBiped.Bip01_R_Thigh"] = Angle(4, 0, 0),
    ["ValveBiped.Bip01_L_Thigh"] = Angle(-8, 0, 0),
})

P.animations.Add("armsbehindhead", {
    ["ValveBiped.Bip01_L_Forearm"] = Angle(25,-115,15),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(-32,-115,-15),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(-50,-210,80),
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(50,-210,-80),
})

P.animations.Add("armsonbelt", {
    ["ValveBiped.Bip01_L_Forearm"] = Angle(50,-90,5),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(-50,-90,5),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(-40,30,-20),
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(40,30,20),
})

P.animations.Add("comlink", {
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(32.9448, -103.5211, 2.2273),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(-90.3271, -31.3616, -41.8804),
    ["ValveBiped.Bip01_R_Hand"] = Angle(0,0,-24),
})

P.animations.Add("highfive", {
    ["ValveBiped.Bip01_L_Forearm"] = Angle(25,-65,25),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(-70,-180,70),
})

P.animations.Add("hololink", {
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(10,-20),
    ["ValveBiped.Bip01_R_Hand"] = Angle(0,1,50),
    ["ValveBiped.Bip01_Head1"] = Angle(0,-30,-20),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(0,-65,39.8863),
})

P.animations.Add("point", {
    ["ValveBiped.Bip01_R_Finger2"] = Angle(4, -52, 0),
    ["ValveBiped.Bip01_R_Finger21"] = Angle(0, -58, 0),
    ["ValveBiped.Bip01_R_Finger3"] = Angle(4, -52, 0),
    ["ValveBiped.Bip01_R_Finger31"] = Angle(0, -58, 0),
    ["ValveBiped.Bip01_R_Finger4"] = Angle(4, -52, 0),
    ["ValveBiped.Bip01_R_Finger41"] = Angle(0, -58, 0),
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(25, -87, -0),
})

P.animations.Add("pensive", {
    ["ValveBiped.Bip01_R_Forearm"] = Angle(-14.4,-106.18412780762,76.318969154358),
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(23.656689071655, -58.723915100098, -5.3269416809082),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(-28.913911819458, -59.408206939697, 1.0253102779388),
    ["ValveBiped.Bip01_R_Thigh"] = Angle(4.7250719070435, -6.0294013023376, -0.46876749396324),
    ["ValveBiped.Bip01_L_Thigh"] = Angle(-7.6583762168884, -0.21996378898621, 0.4060270190239),
    ["ValveBiped.Bip01_L_Forearm"] = Angle(51.038677215576, -120.44165039063, -18.86986541748),
    ["ValveBiped.Bip01_R_Hand"] = Angle(-6.224224853516, -7.906204223633, 10.8624106407166),
    ["ValveBiped.Bip01_L_Hand"] = Angle(25.959447860718, 31.564517974854, -14.979378700256),
})

P.animations.Add("typing", {
    ["ValveBiped.Bip01_L_Forearm"] = Angle(0,0,0),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(0,0,0),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(-28,-65,50),
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(20,-65,-50),
})

-- Attention animation by TheCookieYT
P.animations.Add("attention", {
    ["ValveBiped.Bip01_Head1"] = Angle( 0,12,0 ),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(-6, -6, 0),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(-9, 0, 0),
    ["ValveBiped.Bip01_L_Forearm"] = Angle(9, 0, 0),
    ["ValveBiped.Bip01_R_Thigh"] = Angle(-3, 0, 0),
    ["ValveBiped.Bip01_L_Thigh"] = Angle(3, 5, 0),
    ["ValveBiped.Bip01_R_Foot"] = Angle(20, 0, 0),
    ["ValveBiped.Bip01_L_Foot"] = Angle(-20, 0, 0),
    ["ValveBiped.Bip01_R_Hand"] = Angle(0, 0, 20),
    ["ValveBiped.Bip01_L_Hand"] = Angle(0, 0, -20),
})

-- Middle finger animation by TheCookieYT
P.animations.Add("middlefinger", {
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(15,-55,-0),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(0,-55,-0),
    ["ValveBiped.Bip01_R_Hand"] = Angle(20,20,90),
    ["ValveBiped.Bip01_R_Finger1"] = Angle(20,-40,-0),
    ["ValveBiped.Bip01_R_Finger3"] = Angle(0,-30,0),
    ["ValveBiped.Bip01_R_Finger4"] = Angle(-10,-40,0),
    ["ValveBiped.Bip01_R_Finger11"] = Angle(-0,-70,-0),
    ["ValveBiped.Bip01_R_Finger31"] = Angle(0,-70,0),
    ["ValveBiped.Bip01_R_Finger41"] = Angle(0,-70,0),
    ["ValveBiped.Bip01_R_Finger12"] = Angle(-0,-70,-0),
    ["ValveBiped.Bip01_R_Finger32"] = Angle(0,-70,0),
    ["ValveBiped.Bip01_R_Finger42"] = Angle(0,-70,-0),
})

P.animations.Add("kneel", {
    ["Animation.ZOffset"] = -17,

    ["ValveBiped.Bip01_L_Forearm"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_R_Forearm"] = Angle(-90, -30, -70),
    ["ValveBiped.Bip01_L_UpperArm"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_R_UpperArm"] = Angle(50, -20, 40),
    ["ValveBiped.Bip01_Pelvis"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_Spine"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_Spine4"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_R_Calf"] = Angle(0, 90, 0),
    ["ValveBiped.Bip01_L_Calf"] = Angle(0, 80, 0),
    ["ValveBiped.Bip01_R_Foot"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_L_Foot"] = Angle(0, 48.5, 0),
    ["ValveBiped.Bip01_R_Thigh"] = Angle(0, -90, 0),
    ["ValveBiped.Bip01_L_Thigh"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_R_Hand"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_L_Hand"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_L_Finger2"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_L_Finger11"] = Angle(0, 0, 0),
    ["ValveBiped.Bip01_Head1"] = Angle(0, -15, 0)
})
--PATH lua/mvp/packages/simpledefcons/cl_hud.lua:
local P = mvp.package.Get()

local spacing = mvp.ui.Scale(10)
local POSITION_MAP = {
    ["tl"] = function(sx, sy)
        return 0 + spacing, 0 + spacing, -sx, -sy
    end,
    ["tc"] = function(sx, sy)
        return ScrW() * .5 - sx * .5, 0 + spacing, ScrW() * .5 - sx * .5, -sy
    end,
    ["tr"] = function(sx, sy)
        return ScrW() - sx - spacing, 0 + spacing, ScrW(), -sy
    end,
    ["cl"] = function(sx, sy)
        return 0 + spacing, ScrH() * .5 - sy * .5, -sx, ScrH() * .5 - sy * .5
    end,
    ["cc"] = function(sx, sy)
        return ScrW() * .5 - sx * .5, ScrH() * .5 + sy, ScrW() * .5 - sx * .5, ScrH() 
    end,
    ["cr"] = function(sx, sy)
        return ScrW() - sx - spacing, ScrH() * .5 - sy * .5, ScrW(), ScrH() * .5 - sy * .5
    end,
    ["bl"] = function(sx, sy)
        return 0 + spacing, ScrH() - sy - spacing, -sx - spacing, ScrH()
    end,
    ["bc"] = function(sx, sy)
        return ScrW() * .5 - sx * .5, ScrH() - sy - spacing, ScrW() * .5 - sx * .5, ScrH()
    end,
    ["br"] = function(sx, sy)
        return ScrW() - sx - spacing, ScrH() - sy - spacing, ScrW(), ScrH()
    end
}

hook.Add("HUDPaint", "mvp.simpledefcons.HUDDisplay", function()
    if (not mvp.config.Get("simpledefcons.showHUD", true)) then return end

    local position = mvp.config.Get("simpledefcons.hudPosition", "tc")

    local activeDefcon = mvp.config.Get("simpledefcons.defcons")[P.activeDefcon]
    local defconFont = mvp.q.Font(32, 800)

    local defconText = activeDefcon.name
    local defconColor = activeDefcon.color or mvp.colors.Accent

    surface.SetFont(defconFont)
    local tw, th = surface.GetTextSize(defconText)
    local x, y = POSITION_MAP[position](tw + spacing * 2, th + spacing * 2)

    draw.RoundedBox(mvp.ui.ScaleWithFactor(8), x, y, tw + spacing * 2, th + spacing * 2, ColorAlpha(mvp.colors.SecondaryBackground, 200))

    local _, th2 = draw.SimpleText(mvp.q.Lang("simpledefcons.base_status"), mvp.q.Font(18, 600), x + spacing, y + th * .5 + spacing, mvp.colors.Text)
    draw.SimpleText(defconText, defconFont, x + tw * .5 + spacing, y + th * .5 + spacing - th2 * .5, defconColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end)
--PATH lua/mvp/core/gamemode/sh_gamemode.meta.lua:
return gluapack()()
--PATH lua/mvp/vgui/cl_card.lua:
local PANEL = {}

local roundness = mvp.ui.ScaleWithFactor(16)

AccessorFunc(PANEL, "roundness", "Roundness")

function PANEL:Init()
    self.colors = {}
    self.colors.Background = mvp.colors.Background

    self:SetRoundness(roundness)
end

function PANEL:SetBackground(color)
    self.colors.Background = color
end

function PANEL:SetStyle(style)
    if (style == "primary") then
        self:SetBackground(mvp.colors.Background)
    elseif (style == "secondary") then
        self:SetBackground(mvp.colors.SecondaryBackground)
    end
end

function PANEL:Paint(w, h)
    draw.RoundedBox(self.roundness, 0, 0, w, h, self.colors.Background)
end

vgui.Register("mvp.Card", PANEL, "EditablePanel")

local PANEL = {}

local roundness = mvp.ui.ScaleWithFactor(16)
local titleFont = mvp.Font(28, 600)

function PANEL:Init()
    self.colors = {}
    self.colors.Background = mvp.ui.MuteColor(mvp.colors.SecondaryBackground)

    self.top = vgui.Create("DPanel", self)
    self.top:Dock(TOP)
    self.top:DockMargin(0, 0, 0, 0)
    self.top:SetTall(mvp.ui.Scale(60))

    self.top.Paint = function(pnl, w, h)
        draw.RoundedBoxEx(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, mvp.ui.MuteColor(mvp.colors.SecondaryBackground, 1.1), true, true, false, false)
    end

    self.icon = vgui.Create("DPanel", self.top)
    self.icon:Dock(LEFT)
    self.icon:DockMargin(5, 5, 5, 5)

    self.icon.Paint = function(pnl, w, h)

        if (not self.iconData) then return end
        if (self.iconData.isGradient) then
            mvp.ui.DrawRoundedGradient( mvp.ui.ScaleWithFactor(8), 0, 0, w, h, self.iconData.bg.startCol, self.iconData.bg.endCol )
        else
            draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, self.iconData.bg)
        end
        -- mvp.ui.DrawRoundedGradient( mvp.ui.ScaleWithFactor(16), 0, 0, w, h, mvp.colors.Red, mvp.colors.Accent )

        surface.SetDrawColor(self.iconData.col)

        local iconSize = w - 18
        surface.SetMaterial(self.iconData.mat)
        surface.DrawTexturedRect(9, 9, iconSize, iconSize)

        return true
    end

    self.title = vgui.Create("DLabel", self.top)
    self.title:Dock(LEFT)
    self.title:SetTextColor(mvp.colors.Text)
    self.title:SetFont(titleFont)
    self.title:SetContentAlignment(4)
end

function PANEL:SetBackground(color)
    self.colors.Background = color
end

function PANEL:SetStyle(style)
    if (style == "primary") then
        self:SetBackground(mvp.colors.Background)
    elseif (style == "secondary") then
        self:SetBackground(ColorAlpha(mvp.colors.SecondaryBackground, 100))
    end
end

function PANEL:SetupIcon(iconMat, iconCol, bgColor)
    if (not iconMat) then return end
    iconCol = mvp.utils.IsColor(iconCol) and iconCol or mvp.colors.Text
    
    local isGradient = false 

    if (bgColor and bgColor.startCol and bgColor.endCol and mvp.utils.IsColor(bgColor.startCol) and mvp.utils.IsColor(bgColor.endCol)) then
        isGradient = true
    else
        bgColor = mvp.utils.IsColor(bgColor) and bgColor or mvp.colors.SecondaryBackground
    end

    self.iconData = {
        mat = iconMat,
        col = iconCol,
        bg = bgColor,
        isGradient = isGradient
    }
end

function PANEL:SetTitle(title)
    self.title:SetText(title)
    self.title:SizeToContents()
end

function PANEL:PerformLayout(w, h)    
    if (self.iconData) then
        self.icon:SetWide(mvp.ui.Scale(60) - 10)
    else
        self.icon:SetWide(0)
    end
end

function PANEL:Paint(w, h)
    draw.RoundedBox(roundness, 0, 0, w, h, self.colors.Background)
end

vgui.Register("mvp.CardExtended", PANEL, "EditablePanel")
--PATH lua/mvp/vgui/button/cl_image_button.lua:
return gluapack()()
--PATH lua/mvp/vgui/dropdown/cl_dropdown_option.lua:
return gluapack()()
--PATH lua/mvp/vgui/sidebar/cl_sidebar_button.lua:
local PANEL = {}

local roundness = mvp.ui.ScaleWithFactor(16)
local spaceBetween = mvp.ui.Scale(10)

AccessorFunc(PANEL, "useAnimations", "Animations", FORCE_BOOL)

function PANEL:Init()
    self._x, self._y = 0, 0
    self._w, self._h = 0, 0
    self.spaceBetween = spaceBetween * .75

    self.active = false

    self:SetCursor("hand")
    self:SetAnimations(true)

    self.backgroundColor = mvp.colors.Background
    self.iconColor = Color(187, 187, 187)

    self.colors = {}
    self.colors.Background = mvp.colors.Background
    self.colors.BackgroundHover = mvp.colors.BackgroundHover
    self.colors.Accent = mvp.colors.SecondaryAccent

    self.colors.Icon = Color(187, 187, 187)
    self.colors.IconHover = Color(255, 255, 255, 255)

    self.hint = vgui.Create("mvp.SidebarHint")
    self.hint:SetHintFor(self)
    -- self.hint:SetVisible(false)
end

function PANEL:OnRemove()
    self.hint:Remove()
end

function PANEL:DoClick(...)
    self:GetParent():OnButtonClickedInternal()
    self:SetActive(true)

    if (self.OnClicked) then
        self:OnClicked(...)
    end
end

function PANEL:SetActive(bool)
    self.active = bool

    if (not self:GetAnimations()) then
        return 
    end

    if bool then
        self:Lerp("_x", spaceBetween * 3, .2)
        self:LerpColor("backgroundColor", self.colors.Accent, .2)
        self:LerpColor("iconColor", self.colors.IconHover, .2)
    else
        self:Lerp("_x", 0, .2)
        self:LerpColor("backgroundColor", self.colors.Background, .2)
        self:LerpColor("iconColor", self.colors.Icon, .2)
    end
end

function PANEL:OnCursorEntered()
    self.hint:Lerp("alpha", 255, .2)
    if self.active then return end

    if (self:GetAnimations()) then
        self:Lerp("_x", spaceBetween * 3, .2)
    end

    self:LerpColor("backgroundColor", self.colors.BackgroundHover, .2)
    self:LerpColor("iconColor", self.colors.IconHover, .2)
end

function PANEL:OnCursorExited()
    self.hint:Lerp("alpha", 0, .2)

    if self.active then return end

    if (self:GetAnimations()) then
        self:Lerp("_x", 0, .2)
    end

    self:LerpColor("backgroundColor", self.colors.Background, .2)
    self:LerpColor("iconColor", self.colors.Icon, .2)
end

function PANEL:SetIcon(icon, matParams)
    if (type(icon) == "string") then
        self.icon = Material(icon, matParams)
    else
        self.icon = icon
    end
end

function PANEL:SetText(text)
    self.hint:SetText(text)
end

function PANEL:Paint(w, h)
    local centerX = self._x + self._w * .5
    local centerY = self._y + self._h * .5

    draw.RoundedBox(roundness, self._x + self.spaceBetween, self._y + self.spaceBetween, self._w - self.spaceBetween * 2, self._h - self.spaceBetween * 2, self.backgroundColor)

    if (self.icon) then
        surface.SetDrawColor(self.iconColor)
        surface.SetMaterial(self.icon)
        
        local iconSize = mvp.ui.Scale(28)

        surface.DrawTexturedRect(centerX - iconSize / 2, centerY - iconSize / 2, iconSize, iconSize)
    end

    return true
end

function PANEL:PerformLayout(w, h)
    self._w, self._h = w - spaceBetween * 3, h
end

vgui.Register("mvp.SidebarButton", PANEL, "DButton")
--PATH lua/mvp/menus/admin/cl_credits.lua:
return gluapack()()
--PATH lua/ncs_shared/cl_overhead.lua:
return gluapack()()
--PATH lua/ncs_shared/sh_functions.lua:
return gluapack()()
--PATH lua/ncs_shared/sh_lang.lua:
local LANG = {}

local function RegisterLang(NEW)
    if LANG[NEW] then return end

    local LIST = {}

    for k, v in pairs(LANG) do
        table.insert(LIST, k)
    end

    table.insert(LIST, NEW)
end


function NCS_SHARED.AddLang(lang, note)
    RegisterLang(lang)

    LANG[lang] = LANG[lang] or {}

    for k, v in pairs(note) do 
        LANG[lang][k] = v
    end

    hook.Run("NCS_SHARED_LanguageRegistered")
end

function NCS_SHARED.GetLang(lang, note, replacements)
    if !lang then
        lang = NCS_SHARED.GetDataOption("language_library") or "en"
    end
    
    if !LANG[lang] then
        if LANG["en"] then
            lang = "en"
        else
            return note
        end
    end

    if !LANG[lang][note] then
        return note
    else
        note = LANG[lang][note]
    end

    if replacements and istable(replacements) then
        note = note:format(unpack(replacements))
    end

    return (note or "NOT FOUND")
end

function NCS_SHARED.GetLangs()
    return LANG
end
--PATH lua/ncs_shared/characters/sh_characters.lua:
return gluapack()()
--PATH lua/ncs_shared/characters/sh_characters.lua:
NCS_SHARED.CharSystems = NCS_SHARED.CharSystems or {}

hook.Add("NCS_SHARED_ConfigurationModuleLoaded", "checkLoadedCharacterModule", function()
    if !NCS_SHARED.CharacterSystemEnabled() then return end

    for k, v in pairs(NCS_SHARED.CharSystems) do
        if (NCS_SHARED.GetDataOption("charactersystem_library") != k ) then continue end

        print("---------------------------------------------------------------------------")
        print("[NCS] Shared Library")
        print("We've executed character support integration for ("..k.."), we're adding the following hooks!")
        
        for k, v in pairs(v.hooks) do
            print("Added Hook: ("..k..")")
            hook.Add(k, "NCS_SHARED_CharacterSystem_"..k, function(...)
                v(...)
            end )
        end

        print("---------------------------------------------------------------------------")

    end
end )

function NCS_SHARED.AddCharacterSystem(name, data)
    NCS_SHARED.CharSystems[name] = data
end

function NCS_SHARED.CharacterSystemEnabled()
    return NCS_SHARED.GetDataOption("charactersystemenabled_library")
end

function NCS_SHARED.GetCharacterID(P)
    local dOption = NCS_SHARED.GetDataOption("charactersystem_library")

    if !NCS_SHARED.CharSystems[dOption] then return end
    if !NCS_SHARED.CharSystems[dOption].GetCharacterID then return end

    return NCS_SHARED.CharSystems[dOption].GetCharacterID(P)
end


--PATH lua/ncs_shared/currencies/currencies/sh_helix.lua:
NCS_SHARED.RegisterCurrency("helix", {
    addMoney = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        if AMOUNT > 0 then
            P:GetCharacter():GiveMoney(AMOUNT)
        else
            P:GetCharacter():TakeMoney(AMOUNT)
        end
    end,
    canAfford = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        if not P:GetCharacter():HasMoney(AMOUNT) then
            return false
        else
            return true
        end
    end,
    getMoney = function(P)
        return P:GetCharacter():GetMoney()
    end,
    formatMoney = function(AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        return ix.currency.Get(AMOUNT)
    end,
})
--PATH lua/ncs_shared/currencies/currencies/sh_nmoney2.lua:
return gluapack()()
--PATH lua/ncs_shared/currencies/currencies/sh_nutscript.lua:
return gluapack()()
--PATH lua/ncs_shared/vgui/cl_scroll.lua:
local PANEL = {}

function PANEL:Init()
    local VBAR = self:GetVBar()

    function VBAR:Paint(w, h)
        surface.SetDrawColor(Color(49,56,58,255))
        surface.DrawRect( 0, 0, w, h )
    end

    local W, H = VBAR:GetSize()

    VBAR:SetWide(W * 0.5)
    VBAR:SetHideButtons(true)

    local GRIP = VBAR:GetChildren()[3]

    function GRIP:Paint(w, h)
        surface.SetDrawColor(Color(124,137,140,255))
        surface.DrawRect( 0, 0, w, h )
    end
end

vgui.Register("NCS_SHARED_SCROLL", PANEL, "DScrollPanel")
--PATH lua/ncs_shared/vgui/cl_sidebar.lua:
return gluapack()()
--PATH lua/autorun/netstream.lua:
--A net extension which allows sending large streams of data without overflowing the reliable channel
--Keep it in lua/autorun so it will be shared between addons
AddCSLuaFile()

net.Stream = {}
net.Stream.SendSize = 20000 --This is the size of each packet to send
net.Stream.Timeout = 10 --How long to wait for client response before cleaning up
net.Stream.MaxWriteStreams = 1024 --The maximum number of write data items to store
net.Stream.MaxReadStreams = 128 --The maximum number of queued read data items to store
net.Stream.MaxChunks = 3200 --Maximum number of pieces the stream can send to the server. 64 MB
net.Stream.MaxSize = net.Stream.SendSize*net.Stream.MaxChunks
net.Stream.MaxTries = 3 --Maximum times the client may retry downloading the whole data

local WriteStreamQueue = {
	__index = {
		Add = function(self, stream)
			local identifier = self.curidentifier
			local startid = identifier
			while self.queue[identifier] do
				identifier = identifier % net.Stream.MaxWriteStreams + 1
				if identifier == startid then
					ErrorNoHalt("Netstream is full of WriteStreams!")
					net.WriteUInt(0, 32)
					return
				end
			end
			self.curidentifier = identifier % net.Stream.MaxWriteStreams + 1

			if next(self.queue)==nil then
				self.activitytimeout = CurTime()+net.Stream.Timeout
				timer.Create("netstream_queueclean", 5, 0, function() self:Clean() end)
			end
			self.queue[identifier] = stream
			stream.identifier = identifier
			return stream
		end,

		Write = function(self, ply)
			local identifier = net.ReadUInt(32)
			local chunkidx = net.ReadUInt(32)
			local stream = self.queue[identifier]
			--print("Got request", identifier, chunkidx, stream)
			if stream then
				if stream:Write(ply, chunkidx) then
					self.activitytimeout = CurTime()+net.Stream.Timeout
					stream.timeout = CurTime()+net.Stream.Timeout
				end
			else
				-- Tell them the stream doesn't exist
				net.Start("NetStreamRead")
				net.WriteUInt(identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(ply) else net.SendToServer() end
			end
		end,

		Clean = function(self)
			local t = CurTime()
			for k, stream in pairs(self.queue) do
				if (next(stream.clients)~=nil and t >= stream.timeout) or t >= self.activitytimeout then
					stream:Remove()
					self.queue[k] = nil
				end
			end
			if next(self.queue)==nil then
				timer.Remove("netstream_queueclean")
			end
		end,
	},
	__call = function(t)
		return setmetatable({
			activitytimeout = CurTime()+net.Stream.Timeout,
			curidentifier = 1,
			queue = {}
		}, t)
	end
}
setmetatable(WriteStreamQueue, WriteStreamQueue)
net.Stream.WriteStreams = WriteStreamQueue()

local ReadStreamQueue = {
	__index = {
		Add = function(self, stream)
			local queue = self.queues[stream.player]

			if #queue == net.Stream.MaxReadStreams then
				ErrorNoHalt("Receiving too many ReadStream requests!")
				return
			end
			
			for _, v in ipairs(queue) do
				if v.identifier == stream.identifier then
					ErrorNoHalt("Tried to start a new ReadStream for an already existing stream!")
					return
				end
			end

			queue[#queue+1] = stream
			if #queue == 1 then
				stream:Request()
			end
			return stream
		end,

		Remove = function(self, stream)
			local queue = rawget(self.queues, stream.player)
			if queue then
				if stream == queue[1] then
					table.remove(queue, 1)
					local nextInQueue = queue[1]
					if nextInQueue then
						nextInQueue:Request()
					else
						self.queues[stream.player] = nil
					end
				else
					for k, v in ipairs(queue) do
						if v == stream then
							table.remove(queue, k)
							break
						end
					end
				end
			end
		end,

		Read = function(self, ply)
			local identifier = net.ReadUInt(32)
			local queue = rawget(self.queues, ply)
			if queue and queue[1] then
				queue[1]:Read(identifier)
			end
		end
	},
	__call = function(t)
		return setmetatable({
			queues = setmetatable({}, {__index = function(t,k) local r={} t[k]=r return r end})
		}, t)
	end
}
setmetatable(ReadStreamQueue, ReadStreamQueue)
net.Stream.ReadStreams = ReadStreamQueue()


local WritingDataItem = {
	__index = {
		Write = function(self, ply, chunkidx)
			local client = self.clients[ply]
			if client.finished then return false end
			if chunkidx == #self.chunks+1 then self:Finished(ply) return true end

			if client.downloads+#self.chunks-client.progress >= net.Stream.MaxTries * #self.chunks then self:Finished(ply) return false end
			client.downloads = client.downloads + 1

			local chunk = self.chunks[chunkidx]
			if not chunk then return false end

			client.progress = chunkidx

			--print("Sending", "NetStreamRead", self.identifier, #chunk.data, chunkidx, chunk.crc)
			net.Start("NetStreamRead")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#chunk.data, 32)
			net.WriteUInt(chunkidx, 32)
			net.WriteString(chunk.crc)
			net.WriteData(chunk.data, #chunk.data)
			if CLIENT then net.SendToServer() else net.Send(ply) end
			return true
		end,

		Finished = function(self, ply)
			self.clients[ply].finished = true
			if self.callback then
				local ok, err = xpcall(self.callback, debug.traceback, ply)
				if not ok then ErrorNoHalt(err) end
			end
		end,

		GetProgress = function(self, ply)
			return self.clients[ply].progress / #self.chunks
		end,

		Remove = function(self)
			local sendTo = {}
			for ply, client in pairs(self.clients) do
				if not client.finished then
					client.finished = true
					if CLIENT or ply:IsValid() then sendTo[#sendTo+1] = ply end
				end
			end

			if next(sendTo)~=nil then
				--print("Sending", "NetStreamRead", self.identifier, 0)
				net.Start("NetStreamRead")
				net.WriteUInt(self.identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(sendTo) else net.SendToServer() end
			end
		end

	},
	__call = function(t, data, callback)
		local chunks = {}
		for i=1, math.ceil(#data / net.Stream.SendSize) do
			local datachunk = string.sub(data, (i - 1) * net.Stream.SendSize + 1, i * net.Stream.SendSize)
			chunks[i] = { data = datachunk, crc = util.CRC(datachunk) }
		end

		return setmetatable({
			timeout = CurTime()+net.Stream.Timeout,
			chunks = chunks,
			callback = callback,
			lasttouched = 0,
			clients = setmetatable({},{__index = function(t,k)
				local r = {
					finished = false,
					downloads = 0,
					progress = 0,
				} t[k]=r return r
			end})
		}, t)
	end
}
setmetatable(WritingDataItem, WritingDataItem)

local ReadingDataItem = {
	__index = {
		Request = function(self)
			if self.downloads+self.numchunks-#self.chunks >= net.Stream.MaxTries*self.numchunks then self:Remove() return end
			self.downloads = self.downloads + 1
			timer.Create("NetStreamReadTimeout" .. self.identifier, net.Stream.Timeout*0.5, 1, function() self:Request() end)
			self:WriteRequest()
		end,

		WriteRequest = function(self)
			--print("Requesting", self.identifier, #self.chunks)
			net.Start("NetStreamWrite")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#self.chunks+1, 32)
			if CLIENT then net.SendToServer() else net.Send(self.player) end
		end,

		Read = function(self, identifier)
			if self.identifier ~= identifier then self:Request() return end

			local size = net.ReadUInt(32)
			if size == 0 then self:Remove() return end

			local chunkidx = net.ReadUInt(32)
			if chunkidx ~= #self.chunks+1 then self:Request() return end

			local crc = net.ReadString()
			local data = net.ReadData(size)

			if crc ~= util.CRC(data) then self:Request() return end

			self.chunks[chunkidx] = data
			if #self.chunks == self.numchunks then self:Remove(true) return end

			self:Request()
		end,

		GetProgress = function(self)
			return #self.chunks/self.numchunks
		end,

		Remove = function(self, finished)
			timer.Remove("NetStreamReadTimeout" .. self.identifier)

			local data
			if finished then
				data = table.concat(self.chunks)
				if self.compressed then
					data = util.Decompress(data, net.Stream.MaxSize)
				end
				self:WriteRequest() -- Notify we finished
			end

			local ok, err = xpcall(self.callback, debug.traceback, data)
			if not ok then ErrorNoHalt(err) end

			net.Stream.ReadStreams:Remove(self)
		end
	},
	__call = function(t, ply, callback, numchunks, identifier, compressed)
		return setmetatable({
			identifier = identifier,
			chunks = {},
			compressed = compressed,
			numchunks = numchunks,
			callback = callback,
			player = ply,
			downloads = 0
		}, t)
	end
}
setmetatable(ReadingDataItem, ReadingDataItem)


function net.WriteStream(data, callback, dontcompress)
	if not isstring(data) then
		error("bad argument #1 to 'WriteStream' (string expected, got " .. type(data) .. ")", 2)
	end
	if callback ~= nil and not isfunction(callback) then
		error("bad argument #2 to 'WriteStream' (function expected, got " .. type(callback) .. ")", 2)
	end

	local compressed = not dontcompress
	if compressed then
		data = util.Compress(data) or ""
	end

	if #data == 0 then
		net.WriteUInt(0, 32)
		return
	end

	if #data > net.Stream.MaxSize then
		ErrorNoHalt("net.WriteStream request is too large! ", #data/1048576, "MiB")
		net.WriteUInt(0, 32)
		return
	end

	local stream = net.Stream.WriteStreams:Add(WritingDataItem(data, callback, compressed))
	if not stream then return end
	
	--print("WriteStream", #stream.chunks, stream.identifier, compressed)
	net.WriteUInt(#stream.chunks, 32)
	net.WriteUInt(stream.identifier, 32)
	net.WriteBool(compressed)

	return stream
end

--If the receiver is a player then add it to a queue.
--If the receiver is the server then add it to a queue for each individual player
function net.ReadStream(ply, callback)
	if CLIENT then
		ply = NULL
	else
		if type(ply) ~= "Player" then
			error("bad argument #1 to 'ReadStream' (Player expected, got " .. type(ply) .. ")", 2)
		elseif not ply:IsValid() then
			error("bad argument #1 to 'ReadStream' (Tried to use a NULL entity!)", 2)
		end
	end
	if not isfunction(callback) then
		error("bad argument #2 to 'ReadStream' (function expected, got " .. type(callback) .. ")", 2)
	end
	
	local numchunks = net.ReadUInt(32)
	if numchunks == nil then
		return
	elseif numchunks == 0 then
		local ok, err = xpcall(callback, debug.traceback, "")
		if not ok then ErrorNoHalt(err) end
		return
	end

	local identifier = net.ReadUInt(32)
	local compressed = net.ReadBool()

	if numchunks > net.Stream.MaxChunks then
		ErrorNoHalt("ReadStream requests from ", ply, " is too large! ", numchunks * net.Stream.SendSize / 1048576, "MiB")
		return
	end

	--print("ReadStream", numchunks, identifier, compressed)

	return net.Stream.ReadStreams:Add(ReadingDataItem(ply, callback, numchunks, identifier, compressed))
end

if SERVER then
	util.AddNetworkString("NetStreamWrite")
	util.AddNetworkString("NetStreamRead")
end

--Send requested stream data
net.Receive("NetStreamWrite", function(len, ply)
	net.Stream.WriteStreams:Write(ply or NULL)
end)

--Download the sent stream data
net.Receive("NetStreamRead", function(len, ply)
	net.Stream.ReadStreams:Read(ply or NULL)
end)

--PATH lua/effect/trail.bone_set.lua:
return gluapack()()
--PATH lua/autorun/officer.lua:
player_manager.AddValidModel( "navy officer", 		"models/navy/gnavyofficer.mdl" );
list.Set( "PlayerOptionsModel", "navy officer", 	"models/navy/gnavyofficer.mdl" );
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_1.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_2.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_util.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/05/2023

--]]

function onyx.WaitForGamemode(id, fn)
    if (GM or GAMEMODE) then
        fn()
    else
        if (SERVER) then
            hook.Add('PostGamemodeLoaded', id, fn) -- I hate ULX lol (`InitPostEntity` doesn't get called on serverside :\\\\)
        else
            hook.Add('InitPostEntity', id, fn) -- 'PostGamemodeLoaded' ain't called on CLIENT with uLib
        end
    end
end

function onyx.AssertType(variable, expected, funcname, pos)
    local given = type(variable)
    assert(given == expected, string.format('bad argument #%i to \'%s\' (expected %s, got %s)', pos, funcname, expected, given))
end

function onyx.ColorToHex(color)
    local r = bit.tohex(color.r, 2)
    local g = bit.tohex(color.g, 2)
    local b = bit.tohex(color.b, 2)

    return ('#' .. r .. g .. b)
end

function onyx.HexToColor(color)
    color = color:gsub('#', '')

    local r = tonumber('0x' .. color:sub(1, 2))
    local g = tonumber('0x' .. color:sub(3, 4))
    local b = tonumber('0x' .. color:sub(5, 6))

    return Color(r, g, b)
end

function onyx.MultiArg(arg, amount)
    local tbl = {}
    for i = 1, amount do
        tbl[i] = arg
    end
    return unpack(tbl)
end

do
    local replacements = {
        TypeToString = {
            ['boolean'] = 'b',
            ['number'] = 'n',
            ['string'] = 's',
            ['Vector'] = 'v',
            ['Angle'] = 'a',
        },
        StringToType = {
            ['b'] = 'bool',
            ['n'] = 'int',
            ['s'] = 'string',
            ['v'] = 'vector',
            ['a'] = 'angle',
            ['f'] = 'float'
        },
    }

    function onyx.TypeToString(any)
        local name = replacements.TypeToString[type(any)]
        assert(name, 'wrong type (' .. type(any) .. ')')
        local str = util.TypeToString(any)
        if (name == 'n' and (any % 1) ~= 0) then
            name = 'f'
        end
        local full = name .. '!' .. str
        return full
    end

    function onyx.StringToType(str)
        local typeShort = str:match('%w!-')
        local value = str:gsub(typeShort .. '!', '', 1)
        local typeFull = replacements.StringToType[typeShort]
        return util.StringToType(value, typeFull)
    end
end

if (SERVER) then
    util.AddNetworkString('onyx:Notify')

    function onyx.Notify(ply, text, notificationType, length)
        assert(IsEntity(ply), Format('bad argument #1 to `onyx.Notify` (expected player, got %s)', type(ply)))
        assert(isstring(text), Format('bad argument #2 to `onyx.Notify` (expected string, got %s)', type(text)))

        net.Start('onyx:Notify')
            net.WriteString(text)
            net.WriteUInt(notificationType or 0, 3)
            net.WriteUInt(length or 3, 4)
            net.WriteBool(false)
        net.Send(ply)
    end

    function onyx.NotifyLocalized(ply, text, args, notificationType, length)
        assert(IsEntity(ply), Format('bad argument #1 to `onyx.NotifyLocalized` (expected player, got %s)', type(ply)))
        assert(isstring(text), Format('bad argument #2 to `onyx.NotifyLocalized` (expected string, got %s)', type(text)))
        assert(istable(args), Format('bad argument #3 to `onyx.NotifyLocalized` (expected table, got %s)', type(args)))

        net.Start('onyx:Notify')
            net.WriteString(text)
            net.WriteUInt(notificationType or 0, 3)
            net.WriteUInt(length or 3, 4)
            net.WriteBool(true)
            onyx.net.WriteTable(args)
        net.Send(ply)
    end
else
    net.Receive('onyx:Notify', function(len)
        local text = net.ReadString()
        local notificationType = net.ReadUInt(3)
        local length = net.ReadUInt(4)
        local bLocalized = net.ReadBool()
        local arguments = bLocalized and onyx.net.ReadTable()

        if (bLocalized) then
            text = onyx.lang:Get(text, arguments)
        end

        notification.AddLegacy(text, notificationType, length)
    end)
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_util.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

do
    local Lerp = Lerp
    local Color = Color
    local Clamp = math.Clamp
    function onyx.LerpColor(speed, from, to)
        local r = Lerp(speed, from.r, to.r)
        local g = Lerp(speed, from.g, to.g)
        local b = Lerp(speed, from.b, to.b)
        local a = Lerp(speed, from.a, to.a)

        return Color(r, g, b, a)
    end

    function onyx.CopyColor(color)
        assert(color, 'missing color')
        return Color(color.r, color.g, color.b, color.a)
    end

    function onyx.ColorBetween(clr1, clr2, fraction)
        fraction = fraction or .5
        local r = Lerp(fraction, clr1.r, clr2.r)
        local g = Lerp(fraction, clr1.g, clr2.g)
        local b = Lerp(fraction, clr1.b, clr2.b)
        return Color(r, g, b)
    end

    function onyx.OffsetColor(color, offset)
        assert(color, 'missing color')

        offset = offset or 0

        local r = Clamp(color.r + offset, 0, 255)
        local g = Clamp(color.g + offset, 0, 255)
        local b = Clamp(color.b + offset, 0, 255)

        return Color(r, g, b)
    end

    function onyx.ColorEditHSV(color, hue, saturation, value)
        local h, s, v = ColorToHSV(color)
        return HSVToColor(hue or h, math.Clamp(saturation or s, 0, 1), math.Clamp(value or v, 0, 1))
    end

    function onyx.GetOppositeAccentColor()
        local color = onyx:Config('colors.accent')
        local h, s, v = ColorToHSV(color)
        return onyx.ColorEditHSV(color, (h + 180) % 360)
    end
end

do
    local matBlur = Material('pp/blurscreen')

    local UpdateScreenEffectTexture = render.UpdateScreenEffectTexture
    local DrawTexturedRect = surface.DrawTexturedRect
    local SetMaterial = surface.SetMaterial
    local SetDrawColor = surface.SetDrawColor

    function onyx.DrawBlurExpensive(panel, amount)
        local x, y = panel:LocalToScreen(0, 0)
        local scrW, scrH = ScrW(), ScrH()

        SetDrawColor(255, 255, 255)
        SetMaterial(matBlur)

        for i = 1, 3 do
            matBlur:SetFloat('$blur', (i / 3) * (amount or 6))
            matBlur:Recompute()
            UpdateScreenEffectTexture()
            DrawTexturedRect(x * -1, y * -1, scrW, scrH)
        end
    end
end

do
    local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
    local DrawTexturedRect = surface.DrawTexturedRect
    local SetDrawColor = surface.SetDrawColor
    local SetMaterial = surface.SetMaterial

    function onyx.DrawMaterial(mat, x, y, w, h, color)
        color = color or color_white

        SetMaterial(mat)
        SetDrawColor(color)
        DrawTexturedRect(x, y, w, h)
    end

    function onyx.DrawMaterialRotated(mat, x, y, w, h, angle, color)
        color = color or color_white
        angle = angle or 0

        SetMaterial(mat)
        SetDrawColor(color)
        DrawTexturedRectRotated(x + w * .5, y + h * .5, w, h, angle)
    end
end

function onyx.DrawTextInBox(text, font, x, y, roundness, paddingX, paddingY, textColor, boxColor, alignmentX, alignmentY)
    alignmentX = alignmentX or 1
    alignmentY = alignmentY or 1

    surface.SetFont(font)
    local textW, textH = surface.GetTextSize(text)

    textW = textW + paddingX * 2
    textH = textH + paddingY * 2

    draw.RoundedBox(roundness, x - textW * .5, y - textH * .5, textW, textH, boxColor)
    draw.SimpleText(text, font, x, y, textColor, alignmentX, alignmentY)
end

do
    local matGradientToBottom = Material('vgui/gradient-u')
    local matGradientToTop = Material('vgui/gradient-d')
    local matGradientToLeft = Material('vgui/gradient-l')
    local matGradientToRight = Material('vgui/gradient-r')

    local SetMaterial = surface.SetMaterial
    local SetDrawColor = surface.SetDrawColor
    local DrawTexturedRect = surface.DrawTexturedRect

    function onyx.DrawMatGradient(x, y, w, h, dir, color)
        if dir == BOTTOM then
            SetMaterial(matGradientToBottom)
        elseif (dir == LEFT) then
            SetMaterial(matGradientToLeft)
        elseif (dir == RIGHT) then
            SetMaterial(matGradientToRight)
        else
            SetMaterial(matGradientToTop)
        end
        SetDrawColor(color)
        DrawTexturedRect(x, y, w, h)
    end
end

function onyx.GetTextSize(text, font)
    surface.SetFont(font)
    return surface.GetTextSize(text)
end

do
    local ScrW = ScrW
    local ScrH = ScrH
    local Round = math.Round

    function onyx.ScaleWide(w, ref)
        ref = ref or 1600
        return Round(w / ref * ScrW())
    end

    function onyx.ScaleTall(h, ref)
        ref = ref or 900
        return Round(h / ref * ScrH())
    end
end

--[[------------------------------
SHAPES
--------------------------------]]
do
    local rad = math.rad
    local sin = math.sin
    local cos = math.cos
    local Round = math.Round

    function onyx.CalculateCircle(x0, y0, radius, vertices)
        local tbl, count = {}, 0
        local step = Round(360 / vertices)

        for ang = 0, 360, step do
            local rad = rad(ang)
            local cos = cos(rad)
            local sin = sin(rad)

            local x = x0 + radius * cos
            local y = y0 + radius * sin

            count = count + 1
            tbl[count] = {x = x, y = y}
        end

        return tbl
    end
end

do
    local rad = math.rad
    local sin = math.sin
    local cos = math.cos
    local Round = math.Round

    local insert = table.insert
    local table_Add = table.Add

    local function calculateCircle(x0, y0, startAngle, angleLength, radius, vertices, addCenter)
        local startAngle = startAngle - 90
        local vertices = vertices or 32
        local step = angleLength / vertices
        local tbl, count = {}, 0

        if (addCenter) then
            tbl[1] = {x = x0, y = y0}
            count = 1
        end

        for i = 0, vertices do
            local ang = startAngle + i * step
            local rad = rad(ang)
            local sin = sin(rad)
            local cos = cos(rad)

            local x = x0 + radius * cos
            local y = y0 + radius * sin

            count = count + 1
            tbl[count] = {x = x, y = y}
        end

        return tbl
    end
    onyx.CalculateArc = calculateCircle

    -- Custom
    function onyx.CalculateRoundedBoxEx(r, x, y, w, h, ruCorner, rbCorner, ldCorner, lbCorner)
        r = math.ceil(math.min(r, h / 2))

        if (r == 0) then
            ruCorner = false
            rbCorner = false
            ldCorner = false
            lbCorner = false
        end

        local vertices = {}

        insert(vertices, {x = x + r, y = y})

        -- Right Upper Corner
        if (ruCorner) then
            insert(vertices, {x = x + w - r, y = y})
            table_Add(vertices, calculateCircle(x + w - r, y + r, 0, 90, r, r))
            insert(vertices, {x = x + w, y = y + r})
        else
            insert(vertices, {x = x + w, y = y})
        end

        -- Right Bottom Corner
        if (rbCorner) then
            insert(vertices, {x = x + w, y = y + h - r})
            table_Add(vertices, calculateCircle(x + w - r, y + h - r, 90, 90, r, r))
            insert(vertices, {x = x + w - r, y = y + h})
        else
            insert(vertices, {x = x + w, y = y + h})
        end

        -- Left Bottom Corner
        if (ldCorner) then
            insert(vertices, {x = x + r, y = y + h})
            table_Add(vertices, calculateCircle(x + r, y + h - r, 180, 90, r, r))
            insert(vertices, {x = x, y = y + h - r})
        else
            insert(vertices, {x = x, y = y + h})
        end

        -- Left Upper Corner
        if (lbCorner) then
            insert(vertices, {x = x, y = y + r})
            table_Add(vertices, calculateCircle(x + r, y + r, 270, 90, r, r))
            insert(vertices, {x = x + r, y = y})
        else
            insert(vertices, {x = x, y = y})
        end

        return vertices
    end

    function onyx.CalculateRoundedBox(r, x, y, w, h)
        return onyx.CalculateRoundedBoxEx(r, x, y, w, h, true, true, true, true)
    end
end

function onyx.DrawPoly(poly, color, material)
    if (not poly or #poly < 1) then
        return
    end

    if (material) then
        surface.SetMaterial(material)
    else
        draw.NoTexture()
    end

    surface.SetDrawColor(color or color_white)
    surface.DrawPoly(poly)
end

--[[------------------------------
MASKING
--------------------------------]]
function onyx.MaskFn(funcMask, funcDraw)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)
    render.SetStencilReferenceValue(0)
    render.SetStencilPassOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.ClearStencil()

    render.SetStencilEnable(true)
    render.SetStencilReferenceValue(1)
    render.SetStencilCompareFunction(STENCIL_NEVER)
    render.SetStencilFailOperation(STENCIL_REPLACE)

    funcMask()

    render.SetStencilCompareFunction(STENCIL_EQUAL)
    render.SetStencilFailOperation(STENCIL_KEEP)

    funcDraw()

    render.SetStencilEnable(false)
end

function onyx.InverseMaskFn(funcMask, funcDraw)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)
    render.SetStencilReferenceValue(0)
    render.SetStencilPassOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.ClearStencil()

    render.SetStencilEnable(true)
    render.SetStencilReferenceValue(1)
    render.SetStencilCompareFunction(STENCIL_NEVER)
    render.SetStencilFailOperation(STENCIL_REPLACE)

    funcMask()

    render.SetStencilCompareFunction(STENCIL_GREATER)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)

    funcDraw()

    render.SetStencilEnable(false)
end

function onyx.DrawWithPolyMask(poly, funcDraw)
    if (not istable(poly)) then return end

    onyx.MaskFn(function()
        draw.NoTexture()
        surface.SetDrawColor(color_white)
        surface.DrawPoly(poly)
    end, funcDraw)
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_category.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2023

--]]

local wimgArrow = onyx.wimg.Simple('https://i.imgur.com/KGC51Ws.png', 'smooth mips')
local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')

local font0 = onyx.Font('Comfortaa Bold@16')

local PANEL = {}

AccessorFunc(PANEL, 'm_Title', 'Title')
AccessorFunc(PANEL, 'm_iCategoryHeight', 'CategoryHeight')
AccessorFunc(PANEL, 'm_iSpace', 'Space')
AccessorFunc(PANEL, 'm_iInset', 'Inset')
AccessorFunc(PANEL, 'm_bExpanded', 'Expanded')
AccessorFunc(PANEL, 'm_iTextMargin', 'TextMargin')
AccessorFunc(PANEL, 'm_bSquareCorners', 'SquareCorners')

function PANEL:Init()
    local padding = onyx.ScaleTall(5)

    self.m_iArrowAngle = 90

    self.button = vgui.Create('Panel', self)
    onyx.gui.Extend(self.button)
    self.button:Import('click')
    self.button:Import('hovercolor')
    self.button:SetColorKey('backgroundColor')
    self.button:SetColorIdle(onyx.ColorBetween(colorSecondary, colorPrimary))
    self.button:SetColorHover(colorTertiary)
    self.button.textColor = color_white
    self.button.Paint = function(p, w, h)
        if (self.m_bSquareCorners and self.canvas:GetTall() > 0) then
            draw.RoundedBoxEx(8, 0, 0, w, h, p.backgroundColor, true, true)
        else
            draw.RoundedBox(8, 0, 0, w, h, p.backgroundColor)
        end

        local x = self.m_iTextMargin or padding
        local sz = math.floor(h * .5)

        if (self.wimage) then
            self.wimage:Draw(h * .5 - sz * .5, h * .5 - sz * .5, sz, sz, colorAccent)

            x = h
        end

        draw.SimpleText(self:GetTitle(), font0, x, h * .5, p.textColor, 0, 1)

        local sz = math.floor(h * .33)
        wimgArrow:DrawRotated(w - h * .5, h * .5, sz, sz, self.m_iArrowAngle, color_white)
    end

    self.button.DoClick = function()
        if self:GetExpanded() then
            self:Close()
        else
            self:Open()
        end
    end

    self.canvas = vgui.Create('Panel', self)

    self:SetTitle('CATEGORY')
    self:SetInset(0)
    self:SetCategoryHeight(onyx.ScaleTall(30))
    self:SetSpace(onyx.ScaleTall(5))
    self:SetTall(self:GetCategoryHeight())
end

function PANEL:GetItems()
    return self.canvas:GetChildren()
end

function PANEL:SetExpanded(bBool)
    if (bBool) then
        self.button:SetColorIdle(colorSecondary)
    else
        self.button:SetColorIdle(onyx.ColorBetween(colorSecondary, colorPrimary))
    end

    self.m_bExpanded = bBool

    self:Call('OnStateChanged', nil, bBool)
end

function PANEL:Animate(height, arrowAngle)
    self.ah = self:GetTall()

    onyx.anim.Create(self, 0.3, {
        index = 1,
        target = {ah = height, m_iArrowAngle = arrowAngle},
        think = function(anim, panel)
            panel:SetTall(panel.ah)
            panel.canvas:SetTall(panel.ah - panel:GetSpace() - panel:GetCategoryHeight())
        end
    })
end

function PANEL:Think()
    self.canvas:SetVisible(self.canvas:GetTall() > 0) -- optimization
end

function PANEL:Open()
    local height = self:GetTotalHeight()

    self:SetExpanded(true)

    self:Animate(height, 0)
end

function PANEL:Close()
    self:SetExpanded(false)

    self:Animate(self:GetCategoryHeight(), 90)
end

function PANEL:Update()
    if (self:GetExpanded()) then
        local categoryHeight = self:GetCategoryHeight()
        local space = self:GetSpace()
        local height = self:GetTotalHeight()

        self.m_iArrowAngle = 0

        self:SetTall(height)
        self.canvas:SetTall(height - space - categoryHeight)
    end
end

function PANEL:UpdateInTick(ticks)
    ticks = ticks or 2
    timer.Simple(engine.TickInterval() * ticks, function()
        if (IsValid(self)) then
            self:Update()
        end
    end)
end

function PANEL:SetIcon(url, params)
    self.wimage = onyx.wimg.Simple(url, params)
end

function PANEL:PerformLayout(w, h)
    self.button:SetSize(w, self:GetCategoryHeight())
    self.canvas:SetWide(w)
    self.canvas:SetPos(0, self.button:GetTall() + self:GetSpace())
end

function PANEL:GetContentHeight()
    local panels = self.canvas:GetChildren()
    local count = #panels
    local size = 0

    for index, child in ipairs(panels) do
        if child:IsVisible() then
            local _, top, _, bottom = child:GetDockMargin()

            size = size + child:GetTall()
            size = size + top
            size = size + (index ~= count and bottom or 0)
        end
    end

    return size
end

function PANEL:GetTotalHeight()
    local h = self:GetCategoryHeight() + self:GetContentHeight() + self:GetSpace()

    h = h + self:GetInset() * 2

    return h
end

function PANEL:SetInset(amt)
    self.m_iInset = amt
    if (IsValid(self.canvas)) then
        self.canvas:DockPadding(amt, amt, amt, 0)
    end
end

function PANEL:Add(class)
    local panel = self.canvas:Add(class)

    -- self:AddPanel(panel)

    return panel
end

function PANEL:AddPanel(panel)
    return self.canvas:Add(panel)
end

function PANEL:GetItems()
    return self.canvas:GetChildren()
end

onyx.gui.Register('onyx.Category', PANEL)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_grid.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_image_button.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_label.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

local fontCommon = onyx.Font('Comfortaa@16')
local colorCommon = Color(235, 235, 235)

function PANEL:Init()
    self:SetTextColor(colorCommon)
    self:SetFont(fontCommon)
end

function PANEL:CenterText()
    self:SetContentAlignment(5)
end

-- Trying to save my time....

function PANEL:Font(...)
    self:SetFont(onyx.Font(...))
end

function PANEL:Color(r, g, b, a)
    if isnumber(r) then
        self:SetTextColor(Color(r, g, b, a))
    else
        self:SetTextColor(r)
    end
end

function PANEL:Shadow(distance, color)
    distance = distance or 1
    color = color and (isnumber(color) and Color(0, 0, 0, color) or color) or Color(0, 0, 0, 100)

    self:SetExpensiveShadow(distance, color)
end

function PANEL:AlignText(a)
    self:SetContentAlignment(a)
end

function PANEL:GetContentWidth()
    surface.SetFont(self:GetFont())
    return select(1, surface.GetTextSize(self:GetText()))
end

onyx.gui.Register('onyx.Label', PANEL, 'DLabel')
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_scrollpanel.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_text_entry.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_danish.lua:
--[[

Author: LucaReno
Steam Profile: https://steamcommunity.com/id/LucaReno/
 
09/16/2024

--]]

local LANG = {}

-- TABS
LANG.f4_jobs_u = 'JOBS'
LANG.f4_jobs_desc = 'Vælg din vej'

LANG.f4_dashboard_u = 'DASHBOARD'
LANG.f4_dashboard_desc = 'Generel information'

LANG.f4_shop_u = 'BUTIK'
LANG.f4_shop_desc = 'Køb varer'

LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Konfigurer addon'

LANG.f4_donate_u = 'DONER'
LANG.f4_donate_desc = 'Støt serveren'

LANG.addon_settings_u = 'INDSTILLINGER'
LANG.addon_settings_desc = 'Konfigurer addonet'

LANG.addon_stats_u = 'STATISTIK'
LANG.addon_stats_desc = 'Se addon statistik'

LANG.addon_return_u = 'TILBAGE'
LANG.addon_return_desc = 'Gå tilbage til menuen'

-- Other
LANG.f4_salary = 'Løn'
LANG.f4_price = 'Pris'
LANG.f4_loading = 'Indlæser'
LANG.f4_purchases = 'Køb'
LANG.f4_switches = 'Skift'
LANG.f4_unavailable = 'Utilgængelig'
LANG.f4_description_u = 'BESKRIVELSE'
LANG.f4_weapons_u = 'VÅBEN'
LANG.f4_entities_u = 'ENTITETER'
LANG.f4_ammo_u = 'AMMO'
LANG.f4_food_u = 'MAD'
LANG.f4_shipments_u = 'SHIPMENTS'
LANG.f4_become_u = 'BLIV'
LANG.f4_create_vote_u = 'LAV AFSTEMNING'
LANG.f4_general_u = 'GENERELT'
LANG.f4_police_u = 'POLITI'
LANG.f4_mayor_u = 'BORGMESTER'
LANG.f4_confirm_u = 'BEKRÆFT'
LANG.f4_cancel_u = 'ANNULLER'
LANG.f4_mostpopular_u = 'MEST POPULÆRE'
LANG.f4_chart_u = 'GRAFIK'
LANG.f4_loading_u = 'INDLÆSER'
LANG.f4_empty_u = 'TOM'
LANG.f4_favorite_u = 'FAVORIT'

LANG.f4_playersonline_u = 'SPILLERE ONLINE'
LANG.f4_totalmoney_u = 'TOTAL PENGE'
LANG.f4_staffonline_u = 'STAFF ONLINE'
LANG.f4_actions_u = 'HANDLINGER'

LANG.f4_show_favorite = 'Vis favoritter'

LANG.requires_level = 'Kræver level {level}'

-- Actions
LANG['f4_action_input_amount'] = 'Indtast beløbet'
LANG['f4_action_input_text'] = 'Indtast teksten'
LANG['f4_action_input_reason'] = 'Indtast grunden'
LANG['f4_action_choose_player'] = 'Vælg en spiller'

LANG['f4_action_confirm_action'] = 'Bekræft handling'
LANG['f4_action_drop_money'] = 'Smid penge'
LANG['f4_action_give_money'] = 'Giv penge'
LANG['f4_action_change_name'] = 'Skift navn'
LANG['f4_action_drop_weapon'] = 'Smid våben'
LANG['f4_action_sell_doors'] = 'Sælg alle døre'

LANG['f4_action_warrant'] = 'Lav arrestordre'
LANG['f4_action_wanted'] = 'Gør eftersøgt'

LANG['f4_toggle_lockdown'] = 'Skift nedlukning'
LANG['f4_give_license'] = 'Giv licens'

-- Phrases
LANG['f4_search_text'] = 'Søg efter navn...'

-- Settings
LANG['f4.option_url_desc'] = 'Indtast URL (lad være tom for at deaktivere)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Deltag i vores Discord server'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Mød fællesskabet'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Deltag i vores Steam gruppe'

LANG['f4.rules_url.name'] = 'Regler'
LANG['f4.rules_url.desc'] = 'Kend reglerne'

LANG['f4.donate_url.name'] = 'Doner'

LANG['f4.website_ingame.name'] = 'Browser'
LANG['f4.website_ingame.desc'] = 'Brug in-game browser til at åbne website URL'

LANG['f4.title.name'] = 'Titel'
LANG['f4.title.desc'] = 'Titlen for menuen'

LANG['f4.hide_donate_tab.name'] = 'Skjul Doner Fane'
LANG['f4.hide_donate_tab.desc'] = 'Skjul kreditbutik integration fane'

LANG['f4.edit_job_colors.name'] = 'Ændr Job Farver'
LANG['f4.edit_job_colors.desc'] = 'Skal job farver vises lysere'

LANG['f4.hide_admins.name'] = 'Skjul Admin Sektion'
LANG['f4.hide_admins.desc'] = 'Skjul dashboard admin liste sektion'

LANG['f4.admin_on_duty.name'] = 'Admin Job Aktiveret'
LANG['f4.admin_on_duty.desc'] = 'Vis som admin kun en person med et bestemt job'

LANG['f4.admin_on_duty_job.name'] = 'Admin Job Navn'
LANG['f4.admin_on_duty_job.desc'] = 'Admin\'s job navn*'

LANG['f4.colored_items.name'] = 'Farvet Gradient'
LANG['f4.colored_items.desc'] = 'Aktiver let gradient på items/jobs'

LANG['f4.item_columns.name'] = 'Kolonner'
LANG['f4.item_columns.desc'] = 'Antallet af kolonner for Items'

LANG['f4.job_columns.name'] = 'Kolonner'
LANG['f4.job_columns.desc'] = 'Antallet af kolonner for Jobs'

LANG['f4.model_3d.name'] = '3D Modeller'
LANG['f4.model_3d.desc'] = 'Aktiver realtime rendering for Item/Job ikoner'

LANG['f4.item_show_unavailable.name'] = 'Utilgængelige Items'
LANG['f4.item_show_unavailable.desc'] = 'Vis items der fejlede customCheck'

LANG['f4.job_show_unavailable.name'] = 'Utilgængelige Jobs'
LANG['f4.job_show_unavailable.desc'] = 'Vis jobs der fejlede customCheck'

LANG['f4.job_show_requirejob.name'] = 'Afhængige Jobs'
LANG['f4.job_show_requirejob.desc'] = 'Vis jobs der ikke kan vælges på grund af spillerens forkerte job'

onyx.lang:AddPhrases('danish', LANG)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_admin_stats.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/01/2024

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorTertiary = onyx:Config('colors.tertiary')
local colorLine = Color(75, 75, 75)

local L = function(...) return onyx.lang:Get(...) end

do
    local PANEL = {}

    function PANEL:Init()
        local toolbarPadding = onyx.ScaleTall(5)

        self.container = self:Add('Panel')
        self.container:Dock(FILL)

        self.toolbar = self:Add('DPanel')
        self.toolbar:Dock(TOP)
        self.toolbar:SetTall(onyx.ScaleTall(80))
        self.toolbar:DockMargin(0, 0, 0, onyx.ScaleTall(10))
        self.toolbar.Paint = function(panel, w, h)
            draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
        end
        self.toolbar.PerformLayout = function(panel, w, h)
            self.topRow:SetTall(h / 2)
        end

        self.topRow = self.toolbar:Add('Panel')
        self.topRow:Dock(BOTTOM)
        self.topRow:DockPadding(toolbarPadding, toolbarPadding, toolbarPadding, toolbarPadding)

        self.combo = self.topRow:Add('onyx.ComboBox')
        self.combo:Dock(LEFT)
        self.combo:SetWide(onyx.ScaleWide(200))
        self.combo:AddOption('Today')
        self.combo:AddOption('Week')
        self.combo:AddOption('Month')
        self.combo:ChooseOptionID(1)
        self.combo.OnSelect = function(panel, index)
            local tab = self.navbar:GetActiveTab()
            if (IsValid(tab)) then
                local content = tab.content
                if (IsValid(content)) then
                    content.timeSelected = index
                    content:RequestData()
                end
            end
        end

        self.navbar = self.toolbar:Add('onyx.Navbar')
        self.navbar:Dock(FILL)
        self.navbar:SetContainer(self.container)
        self.navbar:SetKeepTabContent(true)
        self.navbar.Paint = function(panel, w, h)
            draw.RoundedBoxEx(8, 0, 0, w, h, colorTertiary, true, true)
            surface.SetDrawColor(colorLine)
            surface.DrawRect(0, h - 1, w, 1)
        end
        self.navbar.OnTabSelected = function(panel, tab, content)
            content.timeSelected = self.combo.current
            content:RequestData()
        end

        self.navbar:AddTab({
            name = L('f4_jobs_u'),
            class = 'onyx.f4.AdminStatsBase',
            onBuild = function(content)
                content:SetObjectType('job')
                content:LoadObjects(RPExtraTeams, 'command', L('f4_switches'))
            end
        })

        self.navbar:AddTab({
            name = L('f4_entities_u'),
            class = 'onyx.f4.AdminStatsBase',
            onBuild = function(content)
                content:SetObjectType('entity')
                content:LoadObjects(DarkRPEntities, 'ent')
            end
        })

        self.navbar:AddTab({
            name = L('f4_weapons_u'),
            class = 'onyx.f4.AdminStatsBase',
            onBuild = function(content)
                local guns = {}
                for _, shipment in ipairs(CustomShipments) do
                    if (shipment.separate) then
                        table.insert(guns, shipment)
                    end
                end

                content:SetObjectType('gun')
                content:LoadObjects(guns, 'entity')
            end
        })

        self.navbar:AddTab({
            name = L('f4_shipments_u'),
            class = 'onyx.f4.AdminStatsBase',
            onBuild = function(content)
                local shipments = {}
                for _, shipment in ipairs(CustomShipments) do
                    if (not shipment.noship) then
                        table.insert(shipments, shipment)
                    end
                end

                content:SetObjectType('shipment')
                content:LoadObjects(shipments, 'entity')
            end
        })

        self.navbar:ChooseTab(1)
    end

    onyx.gui.Register('onyx.f4.AdminStats', PANEL)
end

do
    local PANEL = {}
    local fontTitle = onyx.Font('Comfortaa Bold@16')
    local colorLabel = color_white

    AccessorFunc(PANEL, 'm_ObjectType', 'ObjectType')

    function PANEL:Init()
        self.cache = {}
        self.objects = {}
        self.smallHeaderHeight = onyx.ScaleTall(25)

        self:InitBlock('List', L('f4_mostpopular_u'), 'onyx.ScrollPanel')
        self:InitBlock('Graph', L('f4_chart_u'), 'onyx.PieChart')

        local phraseLoading = L('f4_loading_u')
        local phraseEmpty = L('f4_empty_u')

        self.divGraph.content:SetDonut(true)
        self.divGraph.content.loading = true
        self.divGraph.content.PostDrawChart = function(panel, w, h)
            if (panel.loading) then
                draw.SimpleText(phraseLoading, fontTitle, w * .5, h * .5, color_white, 1, 1)
            elseif (#panel.m_Data == 0) then
                draw.SimpleText(phraseEmpty, fontTitle, w * .5, h * .5, color_white, 1, 1)
            end
        end

        hook.Add('onyx.f4.StatsReceived', self, function(panel, data)
            if (data.objectType == panel:GetObjectType()) then
                panel:LoadData(data.result)
                panel.cache[panel.timeSelected] = data.result
            end
        end)
    end

    function PANEL:LoadObjects(items, key, label)
        local objectType = self:GetObjectType() or ''
        local scrollPanel = self.divList.content
        for _, item in ipairs(items) do
            local name = item.name
            local model = istable(item.model) and item.model[1] or item.model
            local color = item.color or color_white
            local id = item[key]

            local panel = scrollPanel:Add('onyx.f4.Item')
            panel:SetName(name)
            panel:SetModel(model)
            panel:SetColor(color, .1)
            panel:SetDesc(L('f4_loading') .. '...')
            panel:SetDescLabel(label or L('f4_purchases'))
            panel:SetDescColor(color_white)
            panel:SetTall(onyx.ScaleTall(50))

            if (objectType == 'job') then
                panel:PositionCamera('face')
                panel.uniqueColor = true
            else
                panel:PositionCamera('center')
            end

            self.objects[id] = panel
        end
    end

    function PANEL:PerformLayout(w, h)
        local margin = onyx.ScaleTall(10)

        self.divList:Dock(LEFT)
        self.divList:SetWide(w / 2)
        self.divList:DockMargin(0, 0, onyx.ScaleWide(10), 0)
        self.divList.content:DockMargin(margin, 0, margin, margin)

        self.divGraph:Dock(TOP)
        self.divGraph:SetTall(h / 2)
        self.divGraph.content:DockMargin(margin, 0, margin, margin)
    end

    function PANEL:InitBlock(id, title, class)
        local block = self:Add('Panel')
        block.Paint = function(panel, w, h)
            draw.RoundedBox(8, 0, 0, w, h, colorPrimary)
        end

        local header = block:Add('onyx.Label')
        header:SetText(title)
        header:SetFont(fontTitle)
        header:SetTextColor(colorLabel)
        header:Dock(TOP)
        header:DockMargin(0, 0, 0, onyx.ScaleTall(10))
        header:CenterText()
        header:SetTall(self.smallHeaderHeight)
        header.Paint = function(panel, w, h)
            draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
        end

        local content = block:Add(class or 'Panel')
        content:Dock(FILL)

        block.content = content

        self['div' .. id] = block
    end

    function PANEL:RequestData()
        local timeSelected = self.timeSelected
        if (not self.cache[timeSelected]) then
            net.Start('onyx.f4:RequestStats')
                net.WriteString(self:GetObjectType())
                net.WriteUInt(self.timeSelected - 1, 2)
            net.SendToServer()
        else
            self:LoadData(self.cache[timeSelected])
        end
    end

    function PANEL:LoadData(result)
        local records = #result
        local graph = self.divGraph.content
        local angle = math.Round(360 / records)

        table.sort(result, function(a, b)
            return a.amount > b.amount
        end)

        for _, item in pairs(self.objects) do
            item.found = false
        end

        graph:SetData({})
        for index, record in ipairs(result) do
            local id = record.objectID
            local item = self.objects[id]
            if (IsValid(item)) then
                item:SetZPos(index)
                item:SetDesc(record.amount)
                item.found = true

                if (index < 6) then
                    local uniqueColor = onyx.ColorEditHSV(color_white, angle * (index - 1), .6)
                    if (item.uniqueColor) then
                        graph:AddRecord(item:GetName(), tonumber(record.amount), item.itemColor)
                    else
                        graph:AddRecord(item:GetName(), tonumber(record.amount), uniqueColor)
                    end
                end
            end
        end

        for _, item in pairs(self.objects) do
            if (not item.found) then
                item:SetZPos(records + 1)
                item:SetDesc(0)
            end
        end

        graph.loading = false
    end

    onyx.gui.Register('onyx.f4.AdminStatsBase', PANEL)
end

--[[------------------------------
TEST
--------------------------------]]
-- if (IsValid(DebugPanel)) then
--     DebugPanel:Remove()
-- end
-- DebugPanel = onyx.f4.OpenAdminSettings()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_item.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorOutline = Color(255, 255, 255, 5)
local colorGray = Color(159, 159, 159)
local fontDesc = onyx.Font('Comfortaa@16')
local colorFavoriteIconIdle = Color(235, 235, 235)
local colorFavoriteIconActive = Color(255, 241, 93)

local PANEL = {}

function PANEL:Init()
    self.padding = onyx.ScaleTall(7.5)
    self.itemColor = color_white
    self.itemColorBG = colorPrimary
    self.colorBG = colorSecondary
    self.colorBGGradient = Color(57, 57, 57, 25)
    self.gradientEnabled = onyx.f4:GetOptionValue('colored_items')

    self.iconContainer = self:Add('Panel')
    self.iconContainer:SetMouseInputEnabled(false)
    self.iconContainer.PerformLayout = function(panel, w, h)
        panel.mask = onyx.CalculateCircle(w * .5, h * .5, h * .5 - 2, 24)
    end
    self.iconContainer.Paint = function(panel, w, h)
        local child = panel:GetChild(0)
        if (IsValid(child)) then
            onyx.DrawCircle(w * .5, h * .5, h * .5, self.itemColorBG)

            onyx.DrawWithPolyMask(panel.mask, function()
                child:PaintManual()
            end)

            onyx.DrawOutlinedCircle(w * .5, h * .5, h * .5, 3, self.itemColor)
        end
    end

    if (onyx.f4:GetOptionValue('model_3d')) then
        self.iconModel = self.iconContainer:Add('DModelPanel')
        self.iconModel.LayoutEntity = function() end
        self.iconModel.PreDrawModel = function(panel)
            if (surface.GetAlphaMultiplier() < .5) then
                return false
            end
        end
    else
        self.iconModel = self.iconContainer:Add('SpawnIcon')
    end
    self.iconModel:Dock(FILL)
    self.iconModel:SetPaintedManually(true)
    self.iconModel:DockMargin(2, 2, 2, 2)

    self.lblName = self:Add('onyx.Label')
    self.lblName:SetText('Name')
    self.lblName:Font('Comfortaa Bold@18')
    self.lblName:SetContentAlignment(1)

    self.pnlDesc = self:Add('Panel')
    self.pnlDesc:SetMouseInputEnabled(false)
    self.pnlDesc.label = ''
    self.pnlDesc.text = ''
    self.pnlDesc.color = ''
    self.pnlDesc.Paint = function(panel, w, h)
        local label = panel.label:Trim()
        if (label ~= '') then
            local textW = draw.SimpleText(label .. ': ', fontDesc, 0, 0, colorGray, 0, 0)
            draw.SimpleText(panel.text, fontDesc, textW, 0, panel.color, 0, 0)
        else
            draw.SimpleText(panel.text, fontDesc, 0, 0, panel.color, 0, 0)
        end
    end
end

function PANEL:GetName()
    return self.lblName:GetText()
end

function PANEL:SetDescLabel(label)
    self.pnlDesc.label = label
end

function PANEL:SetDesc(desc)
    self.pnlDesc.text = desc
end

function PANEL:SetDescColor(label)
    self.pnlDesc.color = label
end

function PANEL:SetColor(color, bgFraction)
    self.itemColor = color
    if (bgFraction) then
        self.colorBGGradient = onyx.LerpColor(.05, colorSecondary, self.itemColor)
        self.itemColorBG = onyx.LerpColor(bgFraction, colorSecondary, onyx.CopyColor(self.itemColor))
    end
end

function PANEL:PerformLayout(w, h)
    local padding = self.padding
    local height = h - padding * 2
    local btnFavorite = self.btnFavorite

    self:DockPadding(padding, padding, padding, padding)
    self.mask = onyx.CalculateRoundedBox(8, 1, 1, w - 2, h - 2)

    self.iconContainer:Dock(LEFT)
    self.iconContainer:SetWide(height)
    self.iconContainer:DockMargin(0, 0, onyx.ScaleWide(10), 0)

    self.lblName:Dock(TOP)
    self.lblName:SetTall(height * .5)

    self.pnlDesc:Dock(FILL)

    if (IsValid(btnFavorite) and btnFavorite:IsVisible()) then
        btnFavorite:Dock(RIGHT)
        btnFavorite:SetZPos(-1)
        btnFavorite:SetWide(height)
    end
end

function PANEL:Paint(w, h)
    draw.RoundedBox(8, 0, 0, w, h, colorOutline)
    draw.RoundedBox(8, 1, 1, w - 2, h - 2, self.colorBG)

    if (self.gradientEnabled) then
        onyx.DrawWithPolyMask(self.mask, function()
            onyx.DrawMatGradient(0, 0, w, h, TOP, self.colorBGGradient)
        end)
    end
end

function PANEL:SetModel(modelPath)
    self.iconModel:SetModel(modelPath)
end

function PANEL:SetName(name)
    self.lblName:SetText(name)
end

local AXIS = {'x', 'y', 'z'}
function PANEL:PositionCamera(pos)
    local iconModel = self.iconModel

    if (not IsValid(iconModel)) then return end
    if (iconModel.ClassName ~= 'DModelPanel') then return end

    local ent = iconModel.Entity
    if (not IsValid(ent)) then return end

    if (pos == 'face') then
        local bone = ent:LookupBone('ValveBiped.Bip01_Head1')
        if (not bone) then return end

        local eyepos = ent:GetBonePosition(bone)
        eyepos:Add(Vector(0, 0, 2))

        iconModel:SetLookAt(eyepos)
        iconModel:SetCamPos(eyepos - Vector(-20, 0, 0))
        iconModel:SetFOV(45)

        ent:SetEyeTarget(eyepos - Vector(-20, 0, 0))
    elseif (pos == 'center') then
        local min, max = ent:GetRenderBounds()
        local center = (min + max) / 2
        local distance = 0

        for _, key in ipairs(AXIS) do
            distance = math.max(distance, max[key])
        end

        iconModel:SetLookAt(center)
        iconModel:SetFOV(distance + 10)
    end
end

function PANEL:AddFavoriteButton()
    self.btnFavorite = self:Add('onyx.ImageButton')
    self.btnFavorite.SetState = function(panel, state, ignore)
        panel.bState = state

        if (not ignore and self.objectIdentifier) then
            onyx.f4:SetFavorite(self.objectIdentifier, state)
        end

        local targetColor = state and colorFavoriteIconActive or colorFavoriteIconIdle

        if (state) then
            panel:SetWebImage('favorite_fill', 'smooth mips')
        else
            panel:SetWebImage('favorite_outline', 'smooth mips')
        end

        onyx.anim.Create(panel, .33, {
            index = onyx.anim.ANIM_HOVER,
            target = {
                m_colColor = targetColor
            }
        })

        self:Call('OnFavoriteStateSwitched', nil, state)
    end

    self.btnFavorite.m_Angle = 0
    self.btnFavorite.onyxEvents['OnCursorEntered'] = nil
    self.btnFavorite.onyxEvents['OnCursorExited'] = nil
    self.btnFavorite.onyxEvents['OnRelease'] = nil
    self.btnFavorite.onyxEvents['OnPress'] = nil
    self.btnFavorite:InstallRotationAnim()
    self.btnFavorite.m_iImageScale = .5
    self.btnFavorite.m_iImageScaleInitial = .5

    self.btnFavorite.DoClick = function(panel)
        panel:SetState(not panel.bState)
    end

    self.btnFavorite:SetState(onyx.f4:IsFavorite(self.objectIdentifier), true)
end

onyx.gui.Register('onyx.f4.Item', PANEL)

-- onyx.gui.Test('onyx.f4.Frame', .65, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(3)
-- end)
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_russian.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local LANG = {}

--[[
    .............
    General Words
]]--

LANG[ 'hud_status_wanted' ] = 'В розыске'
LANG[ 'hud_status_speaking' ] = 'Говорит'
LANG[ 'hud_status_typing' ] = 'Печатает'
LANG[ 'props' ] = 'Пропы'
LANG[ 'close' ] = 'Закрыть'
LANG[ 'alert' ] = 'Оповещение'
LANG[ 'message' ] = 'Сообщение'
LANG[ 'unknown' ] = 'Неизвестно'
LANG[ 'accept' ] = 'Принять'
LANG[ 'deny' ] = 'Отклонить'
LANG[ 'none' ] = 'Нет'
LANG[ 'add' ] = 'Добавить'
LANG[ 'remove' ] = 'Удалить'
LANG[ 'jobs' ] = 'Работы'
LANG[ 'door' ] = 'Дверь'
LANG[ 'vehicle' ] = 'Транспорт'
LANG[ 'door_groups' ] = 'Группы дверей'
LANG[ 'display' ] = 'Отображение'
LANG[ 'general' ] = 'Общие'
LANG[ 'speedometer' ] = 'Спидометр'
LANG[ 'fuel' ] = 'Топливо'

--[[
    .......
    Timeout
]]--

LANG[ 'timeout_title' ] = 'СОЕДИНЕНИЕ ПОТЕРЯНО'
LANG[ 'timeout_info' ] = 'Сервер сейчас недоступен, приносим извинения'
LANG[ 'timeout_status' ] = 'Переподключение через %d секунд'

--[[
    ......
    Themes
]]--

LANG[ 'hud.theme.default.name' ] = 'По умолчанию'
LANG[ 'hud.theme.forest.name' ] = 'Лес'
LANG[ 'hud.theme.violet_night.name' ] = 'Фиолетовая ночь'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Тлеющие угли'
LANG[ 'hud.theme.green_apple.name' ] = 'Зеленое яблоко'
LANG[ 'hud.theme.lavender.name' ] = 'Лаванда'
LANG[ 'hud.theme.elegance.name' ] = 'Элегантность'
LANG[ 'hud.theme.mint_light.name' ] = 'Мята'
LANG[ 'hud.theme.gray.name' ] = 'Серый'
LANG[ 'hud.theme.rose_garden.name' ] = 'Розовый сад'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Океанская волна'
LANG[ 'hud.theme.sky_blue.name' ] = 'Небесно-голубой'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Золотой рассвет'

--[[
    ....
    Help
    - Полная фраза: "Введите <command> для открытия настроек"
]]

LANG[ 'hud_help_type' ] = 'Введите'
LANG[ 'hud_help_to' ] = 'для открытия настроек'

--[[
    .............
    3D2D Doors
]]--

LANG[ 'door_purchase' ] = 'Купить {object}'
LANG[ 'door_sell' ] = 'Продать {object}'
LANG[ 'door_addowner' ] = 'Добавить владельца'
LANG[ 'door_rmowner' ] = 'Удалить владельца'
LANG[ 'door_rmowner_help' ] = 'Выберите игрока для удаления'
LANG[ 'door_addowner_help' ] = 'Выберите игрока для добавления'
LANG[ 'door_title' ] = 'Установить название'
LANG[ 'door_title_help' ] = 'Какое название вы хотите установить?'
LANG[ 'door_admin_disallow' ] = 'Запретить владение'
LANG[ 'door_admin_allow' ] = 'Разрешить владение'
LANG[ 'door_admin_edit' ] = 'Редактировать доступ'
LANG[ 'door_owned' ] = 'Частная собственность'
LANG[ 'door_unowned' ] = 'Продается'

LANG[ 'hud_door_help' ] = 'Нажмите {bind}, чтобы купить за {price}'
LANG[ 'hud_door_owner' ] = 'Владелец: {name}'
LANG[ 'hud_door_allowed' ] = 'Допущены к владению'
LANG[ 'hud_door_coowners' ] = 'Совладельцы'
LANG[ 'hud_and_more' ] = 'и другие...'

--[[
    .........
    Верхний регистр
]]--

LANG[ 'reconnect_u' ] = 'ПЕРЕПОДКЛЮЧИТЬСЯ'
LANG[ 'disconnect_u' ] = 'ПОКИНУТЬ СЕРВЕР'
LANG[ 'settings_u' ] = 'НАСТРОЙКИ'
LANG[ 'configuration_u' ] = 'КОНФИГУРАЦИЯ'
LANG[ 'introduction_u' ] = 'ВВЕДЕНИЕ'

--[[
    .........
    Нижний регистр
]]--

LANG[ 'seconds_l' ] = 'секунды'
LANG[ 'minutes_l' ] = 'минуты'

--[[
    .............
    Конфигурация
]]--

LANG[ 'hud.timeout.name' ] = 'Продолжительность таймаута'
LANG[ 'hud.timeout.desc' ] = 'Сколько секунд до автом. переподключения'

LANG[ 'hud.alert_queue.name' ] = 'Очередь оповещений'
LANG[ 'hud.alert_queue.desc' ] = 'Следует ли размещать оповещения в очередь'

LANG[ 'hud.props_counter.name' ] = 'Счетчик пропов'
LANG[ 'hud.props_counter.desc' ] = 'Отображать счетчик пропов'

LANG[ 'hud.main_avatar_mode.name' ] = 'Тип главного аватара'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Выберите тип'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Тип голосового аватара'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Выберите тип'

LANG[ 'hud.restrict_themes.name' ] = 'Ограничение тем'
LANG[ 'hud.restrict_themes.desc' ] = 'Запретить игрокам выбирать темы'

LANG[ 'hud.speedometer_mph.name' ] = 'Использовать мили'
LANG[ 'hud.speedometer_mph.desc' ] = 'Переключить единицы на мили в час'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Максимальная скорость'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'Максимальная скорость для спидометра'

LANG[ 'hud.wpnsel_sounds.name' ] = 'Звуки переключения оружия'
LANG[ 'hud.wpnsel_sounds.desc' ] = 'Включить UI звуки переключения оружия'

LANG[ 'hud_should_draw' ] = 'Отображать элемент'
LANG[ 'hud.main.name' ] = 'Основной HUD'
LANG[ 'hud.ammo.name' ] = 'Боеприпасы'
LANG[ 'hud.agenda.name' ] = 'Повестка дня'
LANG[ 'hud.alerts.name' ] = 'Оповещения'
LANG[ 'hud.pickup_history.name' ] = 'История подбора'
LANG[ 'hud.voice.name' ] = 'Голосовые панели'
LANG[ 'hud.overhead_health.name' ] = '3D2D Здоровье над головой'
LANG[ 'hud.overhead_armor.name' ] = '3D2D Броня над головой'
LANG[ 'hud.vehicle.name' ] = 'HUD Транспорта'
LANG[ 'hud.notifications.name' ] = 'Уведомления'

--[[
    ........
    Настройки
]]--

LANG[ 'hud.theme.name' ] = 'Тема'
LANG[ 'hud.theme.desc' ] = 'Выберите тему HUD'

LANG[ 'hud.scale.name' ] = 'Масштаб'
LANG[ 'hud.scale.desc' ] = 'Отрегулируйте масштаб HUD'

LANG[ 'hud.roundness.name' ] = 'Скругление'
LANG[ 'hud.roundness.desc' ] = 'Настройка скругления HUD'

LANG[ 'hud.margin.name' ] = 'Отступ'
LANG[ 'hud.margin.desc' ] = 'Расстояние между HUD и краями экрана'

LANG[ 'hud.icons_3d.name' ] = '3D модели'
LANG[ 'hud.icons_3d.desc' ] = 'Отображать иконки моделей в 3D'

LANG[ 'hud.compact.name' ] = 'Компактный режим'
LANG[ 'hud.compact.desc' ] = 'Включить компактный режим'

LANG[ 'hud.speedometer_blur.name' ] = 'Размытие спидометра'
LANG[ 'hud.speedometer_blur.desc' ] = 'Включить размытие для спидометра'

LANG[ 'hud.3d2d_max_details.name' ] = 'Макс. детали 3D2D'
LANG[ 'hud.3d2d_max_details.desc' ] = 'Макс. количество отображаемых деталей'

--[[
    ......
    Status
]]--

LANG[ 'hud_lockdown' ] = 'КОМ. ЧАС'
LANG[ 'hud_lockdown_help' ] = 'Вернитесь домой!'

LANG[ 'hud_wanted' ] = 'В РОЗЫСКЕ'
LANG[ 'hud_wanted_help' ] = 'Причина: {reason}'

LANG[ 'hud_arrested' ] = 'АРЕСТОВАН'
LANG[ 'hud_arrested_help' ] = 'Освобождение через {time}'

onyx.lang:AddPhrases( 'russian', LANG )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_icons.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

onyx.wimg.Register( 'hud_microphone', 'https://i.imgur.com/gcM94Fk.png' ) -- 128x128
onyx.wimg.Register( 'hud_chat', 'https://i.imgur.com/q5Lw2qs.png' ) -- 128x128
onyx.wimg.Register( 'hud_connection_lost', 'https://i.imgur.com/EoFpsnf.png' ) -- 128x128

-- 64x64
onyx.wimg.Register( 'hud_wanted', 'https://i.imgur.com/rFyMifb.png' ) 
onyx.wimg.Register( 'hud_license', 'https://i.imgur.com/gltIVYm.png' )
onyx.wimg.Register( 'hud_food', 'https://i.imgur.com/PBZSeVr.png' )
onyx.wimg.Register( 'hud_shield', 'https://i.imgur.com/6Bvc6jX.png' )
onyx.wimg.Register( 'hud_heart', 'https://i.imgur.com/p5Ydzmp.png' )
onyx.wimg.Register( 'hud_lockdown', 'https://i.imgur.com/4K2lTOO.png' )
onyx.wimg.Register( 'hud_arrested', 'https://i.imgur.com/7WVcWRg.png' )

onyx.wimg.Register( 'radial_close', 'https://i.imgur.com/O2fDo4C.png' )
onyx.wimg.Register( 'door_sell', 'https://i.imgur.com/sk1wknE.png' )
onyx.wimg.Register( 'door_title', 'https://i.imgur.com/ShyxozE.png' )
onyx.wimg.Register( 'door_add_user', 'https://i.imgur.com/MMBU6Qg.png' )
onyx.wimg.Register( 'door_remove_user', 'https://i.imgur.com/veLnn9Z.png' )
onyx.wimg.Register( 'door_disable_own', 'https://i.imgur.com/jbItdgJ.png' )
onyx.wimg.Register( 'door_enable_own', 'https://i.imgur.com/B2sTNGW.png' )
onyx.wimg.Register( 'door_own', 'https://i.imgur.com/tCUFyic.png' )
onyx.wimg.Register( 'door_groups', 'https://i.imgur.com/ttokI0C.png' )

--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_scaling.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_agenda.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/08/2024

--]]

local hud = onyx.hud
local agendaWrapped = ''
local lastTitle = ''
local titleFormatted = ''

local function drawAgenda( element, client, scrW, scrH )
    local agendaTable = client:getAgendaTable()
    local agendaText = client:getDarkRPVar( 'agenda' ) or ''
    
    element.active = agendaTable and agendaText ~= ''
    if ( not element.active ) then return end

    local screenPadding = hud.GetScreenPadding()
    local padding = hud.ScaleTall( element.padding )
    local w = hud.ScaleWide( element.width )
    local h = hud.ScaleTall( element.height )
    local fontTitle = hud.fonts.TinyBold
    local fontDesc = hud.fonts.Tiny

    local title = agendaTable.Title
    local titleH = hud.ScaleTall( 25 )

    if ( agendaText ~= agendaWrapped ) then
        agendaWrapped = DarkRP.textWrap( agendaText, fontDesc, w - padding * 2 )
    end

    if ( lastTitle ~= title ) then
        lastTitle = title
        titleFormatted = onyx.utf8.upper( title )
    end

    local x, y = scrW - w - screenPadding, screenPadding
    
    hud.DrawRoundedBox( x, y, w, h, hud:GetColor( 'primary' ) )
    hud.DrawRoundedBoxEx( x, y, w, titleH, hud:GetColor( 'secondary' ), true, true )
    draw.SimpleText( titleFormatted, fontTitle, x + w * .5, y + titleH * .5, hud:GetColor( 'textSecondary' ), 1, 1 )
    draw.DrawText( agendaWrapped, fontDesc, x + padding, y + titleH + padding, hud:GetColor( 'textPrimary' ), 0, 1 )
end

onyx.hud:RegisterElement( 'agenda', { drawFn = drawAgenda, height = 120, width = 250, padding = 10 } )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_alerts.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_main.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

local hud = onyx.hud
local COLOR_BAR = Color( 200, 200, 200, 10 )
local COLOR_GRAY = Color( 183, 183, 183)
local COLOR_XP = Color( 202, 183, 14)

local WIMG_HEART = onyx.wimg.Create( 'hud_heart', 'smooth mips' )
local WIMG_SHIELD = onyx.wimg.Create( 'hud_shield', 'smooth mips' )
local WIMG_FOOD = onyx.wimg.Create( 'hud_food', 'smooth mips' )
local WIMG_LICENSE = onyx.wimg.Create( 'hud_license', 'smooth mips' )
local WIMG_STAR = onyx.wimg.Create( 'hud_wanted', 'smooth mips' )
local WIMG_MICROPHONE = onyx.wimg.Create( 'hud_microphone', 'smooth mips' )
local CONVAR_COMPACT = CreateClientConVar( 'cl_onyx_hud_compact', '0', true, false, '', 0, 1 )
local CONVAR_3D = CreateClientConVar( 'cl_onyx_hud_3d_models', '0', true, false, '', 0, 1 )
local CONVAR_HELP = CreateClientConVar( 'cl_onyx_hud_show_help', '1', true, false, '', 0, 1 )

-- They are scaled after
local UNSCALED_BAR_H = 6
local UNSCALED_BAR_ICON_SIZE = 12
local UNSCALED_ICON_SIZE = 18
local UNSCALED_SPACE = 5

local slowLabels = {}
local lastMaskY
local lerpHealth, lerpArmor, lerpHunger
local lerpMoney

local function formatSalary( salary )
    -- local iters = ( 3600 / GAMEMODE.Config.paydelay )
    -- local full = math.Round( salary * iters )
    -- local formatted = '+' .. DarkRP.formatMoney( full ) .. '/h'
    return '+ ' .. DarkRP.formatMoney( salary )
end

local function drawIndicator( x, y, w, h, material, color, fraction, currentValue, maxValue )
    local iconSize = h
    local iconSpace = hud.ScaleTall( UNSCALED_SPACE )

    local theme = hud:GetCurrentTheme()
    local isDark = theme.isDark
    local colors = theme.colors
    local colorTextPrimary = colors.textPrimary
    local colorTextSecondary = colors.textSecondary

    local rectX, rectW = x + ( iconSize + iconSpace ), w - ( iconSize + iconSpace )
    local rectH = math.min( h, hud.ScaleTall( UNSCALED_BAR_H ) )
    local rectY = math.floor( y + iconSize * .5 - rectH * .5 )

    material:Draw( x, y, iconSize, iconSize, color )
    
    hud.DrawRoundedBox( rectX, rectY, rectW, rectH, ColorAlpha( colorTextPrimary, isDark and 10 or 200 ) )

    render.SetScissorRect( rectX, rectY, rectX + rectW * fraction, rectY + rectH, true )
        hud.DrawRoundedBox( rectX, rectY, rectW, rectH, color )
    render.SetScissorRect( 0, 0, 0, 0, false )
    
    -- Wyświetlanie wartości liczbowej na środku paska
    if (currentValue and maxValue) then
        local valueText = currentValue .. "/" .. maxValue
        local textX = rectX + rectW * 0.5
        local textY = rectY + rectH * 0.5 - 1  -- Lekka korekta pionowa dla lepszego wycentrowania
        
        -- Dodanie cienia dla lepszej widoczności
        draw.SimpleText(valueText, hud.fonts.TinyBold, textX + 1, textY + 1, Color(0, 0, 0, 150), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(valueText, hud.fonts.TinyBold, textX, textY, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    elseif (currentValue) then
        local textX = rectX + rectW * 0.5
        local textY = rectY + rectH * 0.5 - 1  -- Lekka korekta pionowa dla lepszego wycentrowania
        
        -- Dodanie cienia dla lepszej widoczności
        draw.SimpleText(currentValue, hud.fonts.TinyBold, textX + 1, textY + 1, Color(0, 0, 0, 150), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(currentValue, hud.fonts.TinyBold, textX, textY, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end

local function drawStatusIcon( x, y, w, h, material, color )
    material:Draw( x, y, w, h, color or hud:GetColor( 'textTertiary' ) )
end

local function recreateAvatar( self )
    local bUse3DModel = CONVAR_3D:GetBool()
    local bUseModel = hud:GetOptionValue( 'main_avatar_mode' ) == 1
    local client = LocalPlayer()

    if ( IsValid( self.AvatarPanel ) ) then
        self.AvatarPanel:Remove()
    end

    if ( bUseModel ) then
        if ( bUse3DModel ) then
            self.AvatarPanel = vgui.Create( 'DModelPanel' )
            self.AvatarPanel.LayoutEntity = function() end
            self.AvatarPanel.PostUpdateLook = function( panel, model )
                local ent = panel.Entity
    
                if ( IsValid( ent ) ) then
                    local boneID = ent:LookupBone( 'ValveBiped.Bip01_Head1' )
                    if ( boneID ) then       
                        local bonePos = ent:GetBonePosition( boneID )
                        if ( bonePos ) then
                            bonePos:Add( Vector( 0, 0, 2 ) )
                    
                            panel:SetLookAt (bonePos)
                            panel:SetCamPos( bonePos - Vector(-20, 0, 0) )
                            panel:SetFOV( 45 )
                    
                            ent:SetEyeTarget( bonePos - Vector(-20, 0, 0) )
                        end
                    end
                end
            end
        else
            self.AvatarPanel = vgui.Create( 'SpawnIcon' )
        end

        self.AvatarPanel.UpdateLook = function( panel, modelData )
            panel.modelData = modelData

            hud.UpdateModelIcon( panel, modelData )

            if ( panel.PostUpdateLook ) then
                panel:PostUpdateLook()
            end
        end

        local nextComparison = 0
        self.AvatarPanel.Think = function( panel )
            if ( nextComparison <= CurTime() ) then
                nextComparison = CurTime() + 1
            
                local actualData = hud.GetModelData( LocalPlayer() )
                local currentData = panel.modelData
    
                if ( not currentData or not hud.CompareModelData( currentData, actualData ) ) then
                    panel:UpdateLook( actualData )
                end
            end
        end
    else
        self.AvatarPanel = vgui.Create( 'AvatarImage' )
        self.AvatarPanel:SetPlayer( client, 128 )
    end

    self.AvatarPanel:SetPaintedManually( true )
    self.AvatarPanel:ParentToHUD()
end

local updateSlowLabels do
    local nextUpdate = 0
    local thinkRate = 1 / 10

    local function findBestFont( text, maxWidth, ... )
        local bestFont = select( 1, ... )
        assert( bestFont, 'no fonts given' )

        local lastWidth = math.huge
        for _, font in ipairs( { ... } ) do
            local width = onyx.GetTextSize( text, font )
            local isGood = width <= maxWidth

            if ( isGood or width < lastWidth ) then
                bestFont = font
                lastWidth = width

                if ( isGood ) then
                    break
                end
            end
        end

        return bestFont
    end

    function updateSlowLabels( client, maxWidth )
        if ( nextUpdate <= CurTime() ) then
            nextUpdate = CurTime() + thinkRate
            slowLabels = {}

            local name = client:Name()
            local job = ( client:getDarkRPVar( 'job' ) or team.GetName( client:Team() ) )

            slowLabels.name = {
                text = name,
                font = findBestFont( name, maxWidth, hud.fonts.Name, hud.fonts.SmallBold, hud.fonts.TinyBold, hud.fonts.ExtraTinyBold )
            }

            slowLabels.job = {
                text = job,
                font = findBestFont( job, maxWidth, hud.fonts.Small, hud.fonts.Tiny )
            }
        end
    end
end

local function drawMainHUD( self, client, scrW, scrH )
    local showJob = not CONVAR_COMPACT:GetBool()
    local space = hud.GetScreenPadding()
    local padding = hud.ScaleTall( 10 )
    local w, h = hud.ScaleWide( 300 ), hud.ScaleTall( showJob and 120 or 100 )
    local x, y = space, scrH - h - space

    -- Colors
    local theme = hud:GetCurrentTheme()
    local colors = theme.colors

    local colorPrimary = colors.primary
    local colorSecondary = colors.secondary
    local colorTertiary = colors.tertiary
    local colorTextPrimary = colors.textPrimary
    local colorTextSecondary = colors.textSecondary
    local isDark = theme.isDark

    -- Player variables
    local animSpeed = FrameTime() * 16
    local healthFraction = math.Clamp( client:Health() / client:GetMaxHealth(), 0, 1 )
    local armorFraction = math.Clamp( client:Armor() / client:GetMaxArmor(), 0, 1 )
    local money = client:getDarkRPVar( 'money' ) or 0

    lerpHealth = Lerp( animSpeed, lerpHealth or healthFraction, healthFraction )
    lerpArmor = Lerp( animSpeed, lerpArmor or armorFraction, armorFraction )
    lerpMoney = Lerp( animSpeed, lerpMoney or money, money )

    local name = client:Name()
    local teamColor = team.GetColor( client:Team() )
    local moneyFormatted = DarkRP.formatMoney( math.Round( lerpMoney ) )
    local salary = client:getDarkRPVar( 'salary' ) or 0
    local salaryFormatted = formatSalary( salary )
    local hasHunger = not DarkRP.disabledDefaults[ 'modules' ][ 'hungermod' ]
    local hasArmor = math.Round( lerpArmor, 2 ) > 0
    local rectAmount = ( hasHunger or hasArmor ) and 2 or 1
    local rectH = hud.ScaleTall( UNSCALED_BAR_ICON_SIZE )

    -- Increase HUD height if there is multiple bars
    if ( rectAmount > 1 ) then
        local extraHeight = hud.ScaleTall( 10 )
        h = h + extraHeight
        y = y - extraHeight
    end

    local avatarSpaceWidth = hud.ScaleWide( 80 )
    local labelX = x + avatarSpaceWidth + padding
    local labelY = y + padding

    -- Draw background
    hud.DrawRoundedBox( x, y, w, h, colorPrimary )
    hud.DrawRoundedBoxEx( x, y, avatarSpaceWidth, h, colorSecondary, true, false, true )

    -- Draw labels
    local labelMaxW = w - avatarSpaceWidth - padding * 2
    
    updateSlowLabels( client, labelMaxW )
    
    -- Limited render bounds for labels
    render.SetScissorRect( 0, 0, labelX + labelMaxW, ScrH(), true )

    local _, nameHeight = draw.SimpleText( slowLabels.name.text, slowLabels.name.font, labelX, labelY, colorTextPrimary, 0, 0 )

    local teamHeight
    if ( showJob ) then
        _, teamHeight = draw.SimpleText( slowLabels.job.text, slowLabels.job.font, labelX, labelY + nameHeight, teamColor, 0, 0 )
    else
        teamHeight = 0
    end

    local _, moneyHeight = draw.SimpleText( moneyFormatted, hud.fonts.Small, labelX, labelY + nameHeight + teamHeight, colorTextSecondary, 0, 0 )
    draw.SimpleText( salaryFormatted, hud.fonts.Small, x + w - padding, labelY + nameHeight + teamHeight, colorTextSecondary, 2, 0 )

    render.SetScissorRect( 0, 0, 0, 0, false )

    local contentH = nameHeight + teamHeight + moneyHeight
    local topPartH = contentH + padding * 2
    local lineY = labelY + contentH + padding
    local lineW = w - avatarSpaceWidth - padding * 2
    local lineH = math.max( 1, hud.ScaleTall( 2 ) )
    
    -- Prepare a mask for avatar
    local avatarY = y + padding
    local avatarSize = math.min( contentH, avatarSpaceWidth - padding * 2 )
    local circleRadius = math.Round( avatarSize * .5 )
    local circleOutlineThickness = hud.ScaleTall( 2.5 )

    local maskX0 = x + math.Round( avatarSpaceWidth * .5 )
    local maskY0 = avatarY + circleRadius
    local maskX, maskY = maskX0 - circleRadius, avatarY

    if ( not self.AvatarMask or not lastMaskY or lastMaskY ~= maskY0 ) then
        lastMaskY = maskY0
        self.AvatarMask = onyx.CalculateCircle( maskX0, maskY0, circleRadius, 32 )
    end

    -- Draw avatar
    if ( IsValid( self.AvatarPanel ) ) then
        onyx.DrawWithPolyMask( self.AvatarMask, function()
            if ( self.AvatarPanel:GetClassName() ~= 'AvatarImage' ) then
                -- Draw fancy background for model icons
                onyx.DrawCircle( maskX0, maskY0, circleRadius, colorPrimary )
                onyx.DrawMatGradient( maskX, maskY, avatarSize, avatarSize, BOTTOM, ColorAlpha( teamColor, isDark and 25 or 150 )  )
            end

            self.AvatarPanel:SetPos( maskX, maskY )
            self.AvatarPanel:SetSize( avatarSize, avatarSize )
            self.AvatarPanel:PaintManual()

            if ( client:IsSpeaking() ) then
                local micSize = avatarSize * .5

                micSize = micSize + ( micSize * .2 * math.abs( math.sin( CurTime() * 2 ) ) )

                surface.SetDrawColor( 0, 0, 0, 225 )
                surface.DrawRect( maskX, maskY, avatarSize, avatarSize )
                
                WIMG_MICROPHONE:DrawRotated( maskX0, maskY0, micSize, micSize, 0 )
            end
        end )

        onyx.DrawOutlinedCircle( maskX0, maskY0, circleRadius + circleOutlineThickness * .5, circleOutlineThickness, teamColor )
    end

    -- Draw separator
    if ( isDark ) then
        surface.SetDrawColor( 0, 0, 0, 50 )
    else
        surface.SetDrawColor( 100, 100, 100, 100 )
    end
    surface.DrawRect( x, lineY, w, lineH )

    local footerH = h - topPartH
    local footerY0 = lineY + footerH * .5

    -- Draw icons
    local iconSize = hud.ScaleTall( UNSCALED_ICON_SIZE )
    local iconSpace = hud.ScaleTall( UNSCALED_SPACE ) * .75
    local iconX0 = x + avatarSpaceWidth * .5
    local iconY0 = footerY0 - iconSize * .5
    
    drawStatusIcon( iconX0 - iconSize - iconSpace, iconY0, iconSize, iconSize, WIMG_LICENSE, client:getDarkRPVar( 'HasGunlicense' ) and hud:GetColor( 'accent' )  )
    drawStatusIcon( iconX0 + iconSpace, iconY0, iconSize, iconSize, WIMG_STAR, client:getDarkRPVar( 'wanted' ) and hud.GetAnimColor( 0 ) )

    -- Draw indicators
    local rectSpace = hud.ScaleTall( 3 )
    local totalIndictatorsH = rectAmount * rectH + ( rectAmount - 1 ) * rectSpace
    local rectY = footerY0 - totalIndictatorsH * .5
    
    drawIndicator( labelX, rectY, lineW, rectH, WIMG_HEART, Color( 197, 54, 54), lerpHealth, math.Round(client:Health()), math.Round(client:GetMaxHealth()) )

    rectY = rectY + rectH + rectSpace

    if ( hasHunger ) then
        local iconSpace = hud.ScaleTall( UNSCALED_SPACE * 1 )
        local halfLineWidth = lineW * .5 - iconSpace * .5
        local hungerFraction = math.Clamp( client:getDarkRPVar( 'Energy', 0 ) / 100, 0, 1 )

        lerpHunger = Lerp( animSpeed, lerpHunger or hungerFraction, hungerFraction )
        
        drawIndicator( labelX, rectY, halfLineWidth, rectH, WIMG_FOOD, Color( 197, 157, 54), lerpHunger, math.Round(client:getDarkRPVar( 'Energy', 0 )), 100 )
        drawIndicator( labelX + halfLineWidth + iconSpace, rectY, halfLineWidth, rectH, WIMG_SHIELD, Color( 54, 102, 197), lerpArmor, math.Round(client:Armor()), math.Round(client:GetMaxArmor()) )
    elseif ( hasArmor ) then
        drawIndicator( labelX, rectY, lineW, rectH, WIMG_SHIELD, Color( 54, 102, 197), lerpArmor, math.Round(client:Armor()), math.Round(client:GetMaxArmor()) )
    end

    -- Draw help
    local addBlockSpace = hud.ScaleTall( 7.5 )

    if ( CONVAR_HELP:GetBool() ) then
        local addBlockH = hud.ScaleTall( 50 )
        local blockY = y - addBlockH - addBlockSpace
    
        hud.OverrideAlpha( 0.5 + 0.5 * math.abs( math.sin( CurTime() * 2 ) ), function()
            local helpFont = hud.fonts.Small
            local helpText1 = onyx.lang:Get( 'hud_help_type' ) .. ' '
            local helpText2 = '!hud'
            local helpText3 = ' ' .. onyx.lang:Get( 'hud_help_to' )
        
            surface.SetFont( helpFont )
            local helpTextW1 = surface.GetTextSize( helpText1 )
            local helpTextW3 = surface.GetTextSize( helpText3 )
            surface.SetFont( hud.fonts.SmallBold )
            local helpTextW2 = surface.GetTextSize( helpText2 )
            local helpTextTotalW = ( helpTextW1 + helpTextW2 + helpTextW3 )
            local helpTextX = x + w * .5 - helpTextTotalW * .5
            
            hud.DrawRoundedBox( x, blockY, w, addBlockH, colorPrimary )
    
            draw.SimpleText( onyx.lang:Get( 'introduction_u' ), hud.fonts.TinyBold, x + w * .5, blockY + addBlockH * .5, colorTextSecondary, 1, 4 )
    
            draw.SimpleText( helpText1, helpFont, helpTextX, blockY + addBlockH * .5, colorTextPrimary, 0, 0 )
            draw.SimpleText( helpText2, hud.fonts.SmallBold, helpTextX + helpTextW1, blockY + addBlockH * .5, colors.accent, 0, 0 )
            draw.SimpleText( helpText3, helpFont, helpTextX + helpTextW1 + helpTextW2, blockY + addBlockH * .5, colorTextPrimary, 0, 0 )
        end )
    elseif ( onyx.hud:GetOptionValue( 'display_level' ) and onyx.hud.IsLevellingEnabled() ) then
        local addBlockH = hud.ScaleTall( 47.5 )
        local blockY = y - addBlockH - addBlockSpace
        local level, xp, maxXP = onyx.hud.GetLevelData( client )
        local nextLevelFraction = xp / maxXP
        local rectH = math.min( h, hud.ScaleTall( UNSCALED_BAR_H ) )

        hud.DrawRoundedBox( x, blockY, w, addBlockH, colorPrimary )

        local textW = draw.SimpleText( onyx.lang:Get( 'hud.level.name' ) .. ': ', hud.fonts.Tiny, x + padding, blockY + padding, colorTextSecondary, 0, 0 )
        draw.SimpleText( level, hud.fonts.SmallBold, x + padding + textW, blockY + padding, ( isDark and COLOR_XP or colorTextPrimary ), 0, 0 )

        local textW2 = draw.SimpleText( ' / ' .. maxXP, hud.fonts.Tiny, x + w - padding, blockY + padding, colorTextSecondary, 2, 0 )
        draw.SimpleText( xp, hud.fonts.TinyBold, x + w - padding - textW2, blockY + padding, colorTextPrimary, 2, 0 )

        hud.DrawRoundedBox( x + padding, blockY + addBlockH - padding - rectH, w - padding * 2, rectH, ColorAlpha( colorTextPrimary, isDark and 10 or 200 ) )
        onyx.hud.ScissorRect( x + padding, blockY + addBlockH - padding - rectH, ( w - padding * 2 ) * nextLevelFraction, rectH, function()
            hud.DrawRoundedBox( x + padding, blockY + addBlockH - padding - rectH, w - padding * 2, rectH, COLOR_XP )
        end )
    end
end

cvars.AddChangeCallback( 'cl_onyx_hud_3d_models', function()
    recreateAvatar( hud.elements[ 'main' ] )
end, 'hud.internal' )

hook.Add( 'onyx.inconfig.Updated', 'hud.RecreateAvatar', function( id, old, new )
    if ( id and id == 'hud_main_avatar_mode' ) then
        recreateAvatar( hud.elements[ 'main' ] )
    end
end )

hook.Add( 'onyx.inconfig.Synchronized', 'hud.RecreateAvatar', function( id )
    recreateAvatar( hud.elements[ 'main' ] )
end )

hud:RegisterElement( 'main', {
    priority = 100,
    drawFn = drawMainHUD,
    initFunc = recreateAvatar,
    onSizeChanged = function( self )
        self.AvatarMask = nil -- It will force to recalculate the circle mask
    end
} )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_status.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_vehicle_hud.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/ui/cl_choice_wheel.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/ui/cl_choice_wheel.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local SPOLY_ID = 'onyx_hud_wheel_background_3'

do
    onyx.spoly.Generate( SPOLY_ID, function(w, h)
        local scaledThickness = h * .25

        local x = w * .5
        local y = h * .5
        local r = h * .5
        local vertices = 64

        local circleInner = onyx.CalculateCircle(x, y, r - scaledThickness, vertices)
        local circleOuter = onyx.CalculateCircle(x, y, r, vertices)

        onyx.InverseMaskFn(function()
            surface.DrawPoly(circleInner)
        end, function()
            surface.DrawPoly(circleOuter)
        end)
    end )
end

local PANEL = {}

AccessorFunc( PANEL, 'm_bShowLabel', 'ShowLabel' )

function PANEL:Init()
    local colors = onyx.hud:GetCurrentTheme().colors

    self.m_bShowLabel = false
    self.choices = {}
    self.fraction = 0
    self.colors = {
        primary = colors.primary,
        secondary = colors.secondary,
        tertiary = colors.tertiary,
        accent = colors.accent,
        textPrimary = colors.textPrimary,
        textSecondary = colors.textSecondary
    }

    self:Open()

    -- A new hook added in July patch
    -- It is going to replace gui.HideGameUI, so let's prepare to that moment
    -- https://wiki.facepunch.com/gmod/GM:OnPauseMenuShow
    hook.Add( 'OnPauseMenuShow', self, function( this )
        self:Close()
        return false
    end )
end

function PANEL:PerformLayout( w, h )
    self:UpdateSegments()
end

local choiceFont = onyx.Font( 'Comfortaa Bold@16' )
function PANEL:Paint( w, h )
    local colors = self.colors
    local x0, y0 = math.Round( w * .5 ), math.Round( h * .5 )
    local r = h * .5

    local animSpeed = FrameTime() * 8

    -- Draw segments
    for _, choice in ipairs( self.choices ) do
        if ( choice.valid ) then
            local isHovered = choice.isHovered
            local bgColor = isHovered and colors.secondary or colors.primary
            local textColor = isHovered and colors.accent or colors.textSecondary
            local outlineColor = not isHovered and colors.tertiary or colors.accent

            choice.outlineColor = onyx.LerpColor( animSpeed, choice.outlineColor or outlineColor, outlineColor )                                                                                                                                -- 5409e8b9-5bf9-4f0d-8990-ecb0a7db9134
            choice.bgColor = onyx.LerpColor( animSpeed, choice.bgColor or bgColor, bgColor )

            local cos, sin = choice.cos, choice.sin
            local choiceX0 = x0 + cos * r * .75
            local choiceY0 = y0 + sin * r * .75
            local name = choice.name
            local iconSize = math.Round( r * .125 )

            -- Calculate text height
            surface.SetFont( choiceFont )
            local _, textH = surface.GetTextSize( name )

            -- Draw background
            onyx.DrawWithPolyMask( choice.mask, function()
                onyx.spoly.Draw( SPOLY_ID, 0, 0, w, h, choice.bgColor )
                onyx.DrawOutlinedCircle( x0, y0, r, 1, choice.outlineColor )
            end )

            -- Draw content
            if ( choice.wimg ) then
                choice.wimg:DrawRotated( choiceX0, choiceY0, iconSize, iconSize, 0, textColor )
            else 
                draw.DrawText( name, choiceFont, choiceX0, choiceY0 - textH * .5, textColor, 1 )
            end
        end
    end

    -- Draw lines
    for _, choice in ipairs( self.choices ) do
        if ( choice.valid ) then
            local lineRad = math.rad( choice.startAng - 90 )
            local lineCos, lineSin = math.cos( lineRad ), math.sin( lineRad )

            surface.SetDrawColor( colors.tertiary )
            surface.DrawLine( 
                x0 + lineCos * r * .5,
                y0 + lineSin * r * .5,
                x0 + lineCos * r * 1,
                y0 + lineSin * r * 1
             )
        end
    end

    -- Draw label
    local hoveredChoice = self.hoveredChoice
    if ( hoveredChoice and self:GetShowLabel() ) then
        local name = hoveredChoice.name
        
        surface.SetFont( choiceFont )
        local textW, textH = surface.GetTextSize( name )
        local labelPadding = r * .05
        local labelW = textW + labelPadding * 2
        local labelH = textH + labelPadding * 2
        local labelX = x0 - labelW * .5
        local labelY = y0 - labelH * .5

        draw.RoundedBox( 8, labelX, labelY, labelW, labelH, colors.primary )
        draw.DrawText( name, choiceFont, x0, labelY + labelPadding, colors.textPrimary, 1 )
    end
end

function PANEL:Think()
    if ( not self._CLOSED ) then
        self:HandleEscape()
        self:HandleControls()
        if ( self.PostThink ) then
            self:PostThink()
        end
    end
end

function PANEL:HandleEscape()
    if ( input.IsKeyDown( KEY_ESCAPE ) ) then
        if ( gui.HideGameUI ) then gui.HideGameUI() end
        self:Close()
    end
end

function PANEL:HandleControls()
    local w, h = self:GetSize()
    local x, y = input.GetCursorPos()
    local curPos = Vector( x, y )
    local centerPos = Vector( ScrW() * .5, ScrH() * .5 )
    local relX, relY = self:ScreenToLocal( x, y )
    
    relX = relX - ( w * .5 )
    relY = relY - ( h * .5 )

    local ang = ( math.deg( math.atan2( relY, relX ) ) + 90 ) % 360
    local distance = curPos:Distance( centerPos )
    local hoveredChoice

    for _, choice in ipairs( self.choices ) do
        if ( choice.valid ) then
            local startAngle = choice.startAng
            local endAngle = choice.endAng
            local isHovered = ( 
                self:IsHovered()
                and ang > startAngle 
                and ang < endAngle
                and distance > h * .25
                and distance < h * .5
            )
    
            choice.isHovered = isHovered

            if ( isHovered ) then
                hoveredChoice = choice
            end
        end
    end

    self.hoveredChoice = hoveredChoice
end

function PANEL:OnMouseReleased( mouseCode )
    local hoveredChoice = self.hoveredChoice
    if ( mouseCode == MOUSE_LEFT and hoveredChoice ) then
        self:HandleClick( hoveredChoice )
    end
end

function PANEL:HandleClick( choice )
    local clickFn = choice.clickFn or choice.callback
    
    if ( not choice.ignoreClose ) then
        self:Close()
    end

    if ( clickFn ) then
        clickFn( self )
    end
end

function PANEL:UpdateSegments()
    local w, h = self:GetSize()
    if ( w < 1 or h < 1 ) then return end

    local x0, y0 = w * .5, h * .5
    local choices = self.choices
    local amount = #choices

    local segmentAng = ( 360 / amount )

    for index = 1, amount do
        local choice = choices[ index ]
        if ( choice ) then
            local startAng = ( index - 1 ) * segmentAng
            local endAng = startAng + segmentAng
            local betweenAng = startAng + segmentAng * .5
            local rad = math.rad( betweenAng - 90 )
    
            choice.startAng = startAng
            choice.endAng = endAng
            choice.segmentAng = segmentAng
        
            choice.cos = math.cos( rad )
            choice.sin = math.sin( rad )
            choice.mask = onyx.CalculateArc( x0, y0, startAng, segmentAng - 0, math.ceil( h * .5 ) + 1, 24, true )

            choice.valid = true
        end
    end
end

function PANEL:AddChoice( data )
    if ( data.iconURL ) then
        data.wimg = onyx.wimg.Simple( data.iconURL, 'smooth mips' )
    elseif ( data.wimg ) then
        data.wimg = wimg
    elseif ( data.wimgID ) then
        data.wimg = onyx.wimg.Create( data.wimgID, 'smooth mips' )
    end

    table.insert( self.choices, data )
    self:UpdateSegments()
end

function PANEL:Close()
    self._CLOSED = true
    self:SetMouseInputEnabled( false )
    self:SetKeyBoardInputEnabled( false )

    onyx.anim.Create( self, .2, {
        index = 1,
        easing = 'inOutQuad',
        target = { fraction = 0 },
        think = function( _, this )
            this:SetAlpha( this.fraction * 255 )
        end,
        onFinished = function( _, this )
            this:Remove()
        end
    } )
end

function PANEL:Open()
    self:SetAlpha( 0 )

    onyx.anim.Create( self, .2, {
        index = 1,
        easing = 'inOutQuad',
        target = { fraction = 1 },
        think = function( _, this )
            this:SetAlpha( this.fraction * 255 )
        end
    } )
end

onyx.gui.Register( 'onyx.hud.ChoiceWheel', PANEL )

-- DEBUG

-- onyx.gui.oldDebugPanel:Remove()
-- onyx.gui.Test( 'onyx.hud.ChoiceWheel', 1, 1, function( this )
--     this:SetSize( 512, 512 )
--     this:Center()
--     this:MakePopup()
--     for i = 1, 8 do
        
--         this:AddChoice({ name = string.format( 'Button %d', i ), wimgID = 'hud_heart' })
--     end
-- end )
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_german.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_russian.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

07/03/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Скопировано в буфер обмена'
LANG['scoreboard_search'] = 'Поиск... (Имя/SteamID)'
LANG['you'] = 'Вы'
LANG['friend'] = 'Друг'

-- Columns
LANG['scoreboard_col_team'] = 'Команда'
LANG['scoreboard_col_job'] = 'Профессия'
LANG['scoreboard_col_money'] = 'Деньги'
LANG['scoreboard_col_rank'] = 'Ранг'
LANG['scoreboard_col_karma'] = 'Карма'
LANG['scoreboard_col_playtime'] = 'Время'
LANG['scoreboard_col_health'] = 'Здоровье'
LANG['scoreboard_col_level'] = 'Уровень'
LANG['scoreboard_col_none'] = 'Пусто'
LANG['scoreboard_col_gang'] = 'Банда'
LANG['scoreboard_col_ashop_badges'] = 'Значки'
LANG['scoreboard_col_faction'] = 'Фракция'

-- Name Effects
LANG['scoreboard_eff_default'] = 'По умолчанию'
LANG['scoreboard_eff_glow'] = 'Свечение'
LANG['scoreboard_eff_rainbow'] = 'Радуга'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Открыть профиль'
LANG['scoreboard_btn_freeze'] = 'Заморозить'
LANG['scoreboard_btn_goto'] = 'К игроку'
LANG['scoreboard_btn_bring'] = 'К себе'
LANG['scoreboard_btn_return'] = 'Вернуть'
LANG['scoreboard_btn_respawn'] = 'Возродить'
LANG['scoreboard_btn_slay'] = 'Убить'

-- Words
LANG['rank_id'] = 'Идентификатор ранга'
LANG['name'] = 'Название'
LANG['effect'] = 'Эффект'
LANG['color'] = 'Цвет'
LANG['preview'] = 'Предпросмотр'
LANG['creation'] = 'Создание'
LANG['save'] = 'Сохранить'
LANG['dead'] = 'Мертв'
LANG['create_new'] = 'Создать новый'
LANG['column'] = 'Колонна'

-- Settings
LANG['addon_settings_u'] = 'НАСТРОЙКИ'
LANG['scoreboard_ranks_u'] = 'РАНГИ'
LANG['scoreboard_columns_u'] = 'КОЛОНННЫ'

LANG['scoreboard.title.name'] = 'Заголовок'
LANG['scoreboard.title.desc'] = 'Введите заголовок для окна'

LANG['scoreboard.group_teams.name'] = 'Группировка'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Группировать профессии по категориям'

LANG['scoreboard.colored_players.name'] = 'Цветной градиент'
LANG['scoreboard.colored_players.desc'] = 'Отображать цветной градиент'

LANG['scoreboard.blur.name'] = 'Blur тема'
LANG['scoreboard.blur.desc'] = 'Включить размытие заднего фона'

onyx.lang:AddPhrases('russian', LANG)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_turkish.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/integrations/cl_brick_gangs.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/ranks/sh_ranks.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

onyx.scoreboard.ranks = onyx.scoreboard.ranks or {}

function onyx.scoreboard:GetRankData(rank)
    local rankData = onyx.scoreboard.ranks[rank]
    if (rankData) then
        if (CLIENT) then
            local effectID = rankData.effectID
            local effectData, effectIndex = onyx.scoreboard:FindNameEffect(effectID)

            rankData.effect = effectIndex
        end

        return rankData
    end
end
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/cfg/cl_actions.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/cfg/sh_columns.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/cfg/sh_columns.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/03/2024

--]]

--[[------------------------------
**WARNING**
This is an advanced config.
Most of the things you need should be configurable through the game.
Do not edit anything if you do not understand what you are doing.
--------------------------------]]

onyx.scoreboard.columns = {}

--[[------------------------------
Default ones
--------------------------------]]
onyx.scoreboard:RegisterColumn('team', {
    getValue = function(client)
        if (onyx.scoreboard.IsTTT()) then
            return select(2, onyx.scoreboard.GetTeamTTT(client))
        end

        return client:Team()
    end,
    formatValue = function(value)
        if (onyx.scoreboard.IsTTT()) then
            return value
        end

        return team.GetName(value)
    end,
    getColor = function(client)
        if (onyx.scoreboard.IsTTT()) then
            return select(3, onyx.scoreboard.GetTeamTTT(client))
        end

        return onyx.scoreboard.ConvertTeamColor(team.GetColor(client:Team()))
    end
})

onyx.scoreboard:RegisterColumn('rank', {
    getValue = function(client)
        local customrank, customcolor = CustomRank(client)
        if customrank then
			return customrank
		end
        local rank = client:GetUserGroup()
        local data = onyx.scoreboard:GetRankData(rank)
        if (data) then
            return data.name
        end
        return rank
    end,
    getColor = function(client)
        local customrank, customcolor = CustomRank(client)
        if customcolor then
			return customcolor
		end
        local data = onyx.scoreboard:GetRankData(client:GetUserGroup())
        if data and data.color then
            return data.color
        end
        return Color(255, 255, 255)
    end
})

onyx.scoreboard:RegisterColumn('name', {
    getValue = function(client)
        return client:Nick()
    end,
    getColor = function(client)
        if IsDeveloper(client) then
            return DEVELOPER_COLOR
        end
        local rank = client:GetUserGroup()
        local data = onyx.scoreboard:GetRankData(rank)
        if data and data.color then
            return data.color
        end
        return Color(255, 255, 255)
    end,
    formatValue = function(value)
        return value
    end
})

onyx.scoreboard:RegisterColumn('health', {
    getValue = function(client)
        local health = client:Alive() and client:Health() or -1
        return health
    end,
    formatValue = function(value)
        if (value > 0) then
            return string.Comma(value) .. ' HP'
        else
            return onyx.lang:Get('dead')
        end
    end
})

--[[------------------------------
DarkRP
--------------------------------]]
onyx.scoreboard:RegisterColumn('money', {
    getValue = function(client)
        return (client:getDarkRPVar('money') or 0)
    end,
    formatValue = function(value)
        return DarkRP.formatMoney(value)
    end,
    customCheck = function()
        return DarkRP ~= nil
    end
})

--[[------------------------------
TTT
--------------------------------]]
onyx.scoreboard:RegisterColumn('karma', {
    getValue = function(client)
        return client:GetBaseKarma()
    end,
    formatValue = function(value)
        return string.Comma(math.Round(value))
    end,
    customCheck = function()
        return (engine.ActiveGamemode() == 'terrortown')
    end
})

--[[------------------------------
Custom
--------------------------------]]
do
    local handlers = {
        {
            key = 'GlorifiedLeveling',
            func = function(ply)
                return ply:getLevel()
            end
        },
        {
            key = 'LevelSystemConfiguration',
            func = function(ply)
                -- Vrondakis
                if (ply.getDarkRPVar) then
                    return ply:getDarkRPVar('level')
                end
            end
        },
        {
            key = 'levelup',
            func = function(ply)
                return levelup.getLevel(ply)
            end
        }
    }

    onyx.scoreboard:RegisterColumn('level', {
        getValue = function(client)
            for _, data in ipairs(handlers) do
                if (_G[data.key]) then
                    local value = data.func(client)
                    return (value or 0)
                end
            end
            return 0
        end,
        formatValue = function(level)
            return string.Comma(level)
        end,
        customCheck = function()
            for _, data in ipairs(handlers) do
                if (_G[data.key]) then
                    return true
                end
            end

            return false
        end
    })
end

do
    local handlers = {
        {
            -- SAM
            valid = function()
                return sam ~= nil
            end,
            func = function(ply)
                return ply:sam_get_play_time() -- seconds
            end
        },
        {
            -- Utime
            valid = function()
                return Utime ~= nil
            end,
            func = function(ply)
                return ply:GetUTimeTotalTime()
            end
        },
        {
            -- sAdmin
            valid = function()
                return sAdmin ~= nil
            end,
            func = function(ply)
                return sAdmin.getTotalPlaytime( ply )
            end
        },
    }

    onyx.scoreboard:RegisterColumn('playtime', {
        getValue = function(client)
            for _, data in ipairs(handlers) do
                if (data.valid()) then
                    local value = data.func(client)
                    return (value or 0)
                end
            end
            return 0
        end,
        formatValue = function(seconds)
            local minutes = math.Round(seconds / 60)
            local hours = math.Round(minutes / 60)
            if (hours < 1) then
                return string.Comma(minutes) .. 'm'
            else
                return string.Comma(hours) .. 'h'
            end
        end,
        customCheck = function()
            for _, data in ipairs(handlers) do
                if (data.valid()) then
                    return true
                end
            end

            return false
        end
    })
end

-- Ashop
onyx.scoreboard:RegisterColumn('ashop_badges', {
    getValue = function(client)
        local badges = ashop.GetPlayerBadges(client) or {}
        return table.Count(badges)
    end,
    buildFunc = function(columnPanel, ply)
        local badges = ashop.GetPlayerBadges(ply) or {}

        columnPanel.PerformLayout = function(panel, w, h)
            local space = onyx.ScaleTall(5)
            local children = panel:GetChildren()
            local amount = #children
            local size = math.min(h, (w - space * (amount - 1)) / amount)
            local totalWidth = size * amount + space * (amount - 1)
            local x = w * .5 - totalWidth * .5

            for index, child in ipairs(children) do
                if (IsValid(child)) then
                    child:SetSize(size, size)
                    child:SetPos(x, 0)
                    child:CenterVertical()

                    x = x + size + space
                end
            end
        end

        for slot, data in pairs(badges) do
            local badge = vgui.Create("DPanel", columnPanel)
            badge.Paint = function(panel, w, h)
                xpcall(function()
                    local mat = data.mat()
                    if (mat) then
                        surface.SetMaterial(mat)
                        surface.SetDrawColor(color_white)
                        surface.DrawTexturedRect(0, 0, w, h)
                    end
                end, function(errText)
                    onyx.scoreboard:PrintError('(AShop) Error during badge display: #', errText)
                end)
            end
        end
    end,
    customCheck = function()
        return ashop ~= nil
    end
})

-- Brick's Gangs
onyx.scoreboard:RegisterColumn('gang', {
    getValue = function(client)
        local gangID = client:GetGangID()
        local gangName = onyx.scoreboard.GetBricksGangName(gangID)
        return gangName
    end,
    customCheck = function()
        if (BRICKS_SERVER and BRICKS_SERVER.GANGS) then
            return true
        end
        return false
    end
})

-- VoidFactions
onyx.scoreboard:RegisterColumn('faction', {
    getValue = function(client)
        return client:VF_GetFactionName('')
    end,
    getColor = function(client)
        return client:VF_GetFactionColor(color_white)
    end,
    customCheck = function()
        return VoidFactions ~= nil
    end
})
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_column_editor.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_ACCENT = onyx:Config('colors.accent')
local COLOR_BG = onyx.ColorBetween(COLOR_PRIMARY, COLOR_SECONDARY)
local COLOR_NEGATIVE = onyx:Config('colors.negative')

local WIMG_SAVE = onyx.wimg.Simple('https://i.imgur.com/ycSNF3m.png', 'smooth mips')
local PANEL = {}

function PANEL:Init()
    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)

    self.grid = self.list:Add('onyx.Grid')
    self.grid:SetColumnCount(2)
    self.grid:SetSpace(onyx.ScaleTall(5))

    self.columns = {}
    self.default = {}
    self.changes = {}

    hook.Add('onyx.scoreboard.SyncedColumns', self, function(panel)
        panel.grid:Clear()
        panel.columns = {}
        panel.default = {}
        panel.changes = {}
        panel:LoadColumns()
    end)

    self:LoadColumns()
    self:AddSavePopup()
end

function PANEL:AddSavePopup()
    local font0 = onyx.Font('Comfortaa Bold@16')
    local font3 = onyx.Font('Comfortaa@14')

    self.confirmPopup = self:Add('DPanel')
    self.confirmPopup:SetWide(onyx.ScaleWide(225))
    self.confirmPopup:SetTall(onyx.ScaleTall(75))
    self.confirmPopup.Paint = function(panel, w, h)
        local x, y = panel:LocalToScreen(0, 0)

        if (panel.anim == 0 or panel.anim == 1) then
            onyx.bshadows.BeginShadow()
                draw.RoundedBox(8, x, y, w, h, COLOR_SECONDARY)
            onyx.bshadows.EndShadow(1, 2, 2)
        else
            draw.RoundedBox(8, 0, 0, w, h, COLOR_SECONDARY)
        end
    end
    self.confirmPopup.PerformLayout = function(panel, w, h)
        local padding = ScreenScale(2)

        panel:DockPadding(padding, padding, padding, padding)

        panel.info:Dock(FILL)
        panel.info:DockMargin(0, 0, 0, onyx.ScaleTall(5))
        panel.button:Dock(BOTTOM)
        panel.button:SetTall(onyx.ScaleTall(20))
    end

    self.confirmPopup.info = self.confirmPopup:Add('Panel')
    self.confirmPopup.info.text1 = onyx.lang:GetWFallback('unsavedSettings', 'UNSAVED SETTINGS')
    self.confirmPopup.info.text2 = onyx.lang:GetWFallback('confirmSave', 'Confirm to save the changes')
    self.confirmPopup.info.Paint = function(panel, w ,h)
        local size = math.ceil(h * .5)

        WIMG_SAVE:Draw(h * .5 - size * .5, h * .5 - size * .5, size, size, COLOR_NEGATIVE)

        draw.SimpleText(panel.text1, font0, h, h * .5, COLOR_NEGATIVE, 0, 4)
        draw.SimpleText(panel.text2, font3, h, h * .5, color_white, 0, 0)
    end

    self.confirmPopup.button = self.confirmPopup:Add('onyx.Button')
    self.confirmPopup.button:SetText(onyx.lang:GetWFallback('save_u', 'SAVE'))
    self.confirmPopup.button:SetFont(font0)
    self.confirmPopup.button:SetColorIdle(COLOR_NEGATIVE)
    self.confirmPopup.button:SetColorHover(onyx.OffsetColor(COLOR_NEGATIVE, -20))
    self.confirmPopup.button.DoClick = function()
        local changes = self:GetChanges()
        if (changes) then
            local amount = table.Count(changes)
            if (amount > 0) then
                net.Start('onyx.scoreboard:SetColumns')
                    net.WriteUInt(amount, 6)
                    for index, value in pairs(changes) do
                        net.WriteUInt(index, 8)
                        net.WriteString(value)
                    end
                net.SendToServer()
            end
        end
    end
end

function PANEL:GetChanges()
    return self.changes
end

function PANEL:Think()
    if ((self.nextThink or 0) <= CurTime()) then
        local changes = self:GetChanges()
        local anim = table.IsEmpty(changes) and 1 or 0
        local confirmPopup = self.confirmPopup

        if ((confirmPopup.targetAnim or -1) ~= anim) then
            confirmPopup.anim = confirmPopup.anim or anim -- skip first anim

            if (anim < 1) then
                confirmPopup:SetVisible(true)
            end

            onyx.anim.Create(confirmPopup, .33, {
                index = 2,
                easing = 'inQuad',
                target = {
                    anim = anim
                },
                think = function(anim, panel)
                    panel:AlignBottom(panel.anim * -panel:GetTall())
                end,
                onFinished = function(anim, panel)
                    panel:SetVisible(panel.anim < 1)
                end
            })

            confirmPopup.targetAnim = anim
        end

        self.nextThink = CurTime() + .5
    end
end

function PANEL:LoadColumns()
    for index = 1, onyx.scoreboard.columnsMaxAmount do
        self:AddColumn(index)
    end
end

function PANEL:AddColumn(index)
    local padding = onyx.ScaleTall(10)

    local panel = self.grid:Add('Panel')
    panel:SetTall(onyx.ScaleTall(70))
    panel:DockPadding(padding, padding, padding, padding)
    panel.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, COLOR_BG)
    end

    self.grid:AddItem(panel)

    local lblTitle = panel:Add('onyx.Label')
    lblTitle:SetText(onyx.lang:Get('column') .. ' #' .. index)
    lblTitle:Dock(TOP)
    lblTitle:Font('Comfortaa Bold@16')
    lblTitle:SizeToContentsY()
    lblTitle:DockMargin(0, 0, 0, onyx.ScaleTall(5))

    local comboType = panel:Add('onyx.ComboBox')
    comboType:Dock(FILL)
    comboType:AddOption(onyx.lang:Get('scoreboard_col_none'), 'none')
    comboType.OnSelect = function(panel, _, text, data)
        if (not self.default[index] or self.default[index] ~= data) then
            self.changes[index] = data
        else
            self.changes[index] = nil
        end
    end

    for columnID, columnData in pairs(onyx.scoreboard.columns) do
        if (not columnData.customCheck or columnData.customCheck()) then
            comboType:AddOption(onyx.lang:Get(columnData.name), columnID)
        end
    end

    local currentID = onyx.scoreboard.columnsCustomizable[index] or onyx.scoreboard.columnsDefault[index] or 'none'

    if (currentID) then
        local optionData, optionIndex = comboType:FindOptionByData(currentID)
        if (optionIndex) then
            comboType:ChooseOptionID(optionIndex, true)
            self.default[index] = currentID
        else
            comboType:SetCurrentOptionText('invalid : ' .. currentID)
            comboType:Highlight(Color(255, 78, 78))
        end
    end

end

onyx.gui.Register('onyx.scoreboard.ColumnEditor', PANEL)

-- if (IsValid(DebugPanel)) then
--     DebugPanel:Remove()
-- end

-- DebugPanel = onyx.scoreboard.OpenAdminSettings(3)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_frame.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_ACCENT = onyx:Config('colors.accent')
local COLOR_GRAY = Color(149, 149, 149)

--[[------------------------------
// ANCHOR Frame
--------------------------------]]
local PANEL = {}

function PANEL:Init()
    self:SetTitle(onyx.utf8.upper(onyx.scoreboard:GetOptionValue('title')))

    self.blur = onyx.scoreboard.IsBlurActive()

    self.container = self:Add('onyx.Panel')

    self.sidebar = self:Add('onyx.MiniSidebar')
    self.sidebar:SetContainer(self.container)
    self.sidebar:SetWide(onyx.ScaleTall(45)) -- it's important to set width at this point

    self.sidebar:AddTab({
        name = '<PLAYERS>',
        desc = '',
        icon = 'https://i.imgur.com/1dE2q2H.png',
        class = 'onyx.Scoreboard.PlayerList'
    })

    CAMI.PlayerHasAccess(LocalPlayer(), 'onyx_scoreboard_edit', function(bAllowed)
        if (bAllowed) then
            self.sidebar:AddTab({
                name = '<ADMIN>',
                desc = '',
                icon = 'https://i.imgur.com/l4M12dO.png',
                onClick = function()
                    onyx.scoreboard.OpenAdminSettings()
                    self:Remove()
                    return false
                end
            })
        end
    end)
	CAMI.PlayerHasAccess(LocalPlayer(), 'onyx_scoreboard_edit', function(bAllowed)
        if (bAllowed) then
            self.sidebar:AddTab({
                name = '<HIDE>',
                desc = '',
                icon = 'https://static.thenounproject.com/png/1656746-200.png',
                onClick = function()
                    tfres.Global:NetServer("HideScoreboard",{})
                    self:Remove()
                    return false
                end
            })
        end
    end)

    self.sidebar:ChooseTab(1)
end

function PANEL:PerformLayout(w, h)
    local margin = onyx.ScaleTall(10)

    self.BaseClass.PerformLayout(self, w, h)

    self.container:Dock(FILL)
    self.container:DockMargin(margin, margin, margin, margin)

    self.sidebar:Dock(LEFT)
end

function PANEL:Paint(w, h)
    if (self.blur) then
        onyx.DrawBlurExpensive(self, 9)
        draw.RoundedBox(8, 0, 0, w, h, ColorAlpha(onyx.ColorBetween(COLOR_PRIMARY, color_black), 230))
    else
        self.BaseClass.Paint(self, w, h)
    end
end

function PANEL:Think()
    if (self.closeDisabled) then
        local bindButtonName = input.LookupBinding('+showscores', true)
        local bindButtonInt = bindButtonName and input.GetKeyCode(bindButtonName)
        if (not bindButtonInt) then return end

        local newState = input.IsKeyDown(bindButtonInt)
        if (self.oldState == nil) then
            self.oldState = newState
        elseif (self.oldState ~= newState) then
            if (newState) then
                self:Remove()
            end
            self.oldState = newState
        end
    end
end

onyx.gui.Register('onyx.Scoreboard.Frame', PANEL, 'onyx.Frame')

--[[------------------------------
// ANCHOR Debug
--------------------------------]]
-- onyx.gui.Test('onyx.Scoreboard.Frame', .6, .6, function(self)
--     onyx.scoreboard.Frame = self
--     self:Center()
--     self:MakePopup()
-- end)
--PATH lua/openpermissions/thirdparty/pon.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/config/sh_language.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/config/sh_config.lua:
return gluapack()()
--PATH lua/autorun/ppfx_cache.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/autorun/przeszukanie_config.lua:
return gluapack()()
--PATH lua/autorun/rb655_extended_spawnmenu.lua:
return gluapack()()
--PATH lua/reality_development/cl_theme.lua:
return gluapack()()
--PATH lua/reality_development/libs/characters/list/sh_mcs.lua:
local OBJ = RDV.LIBRARY.RegisterCharacter("mcs")

function OBJ:GetCharacterID(p)
    return p:GetCharacter()
end

function OBJ:OnCharacterLoaded(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("PlayerLoadedCharacter", function(player, slot)
        CALLBACK(player, slot)
    end)
end

function OBJ:OnCharacterDeleted(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("CharacterDeleted", function(player, slot)
        CALLBACK(player, slot)
    end)
end

function OBJ:OnCharacterChanged(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("PrePlayerLoadedCharacter", function(client, new, old)
        if not old then
            return
        end
        
        if new ~= old then
            CALLBACK(client, new, old)
        end
    end)
end
--PATH lua/reality_development/libs/currencies/sh_register.lua:
local CURRENCIES = {}

function RDV.LIBRARY.RegisterCurrency(NAME)
    CURRENCIES[NAME] = {}

    return CURRENCIES[NAME]
end

function RDV.LIBRARY.CurrencyExists(NAME)
    if not CURRENCIES[NAME] then
        return false
    else
        return true
    end
end

--[[
    Currency Functions.
--]]

function RDV.LIBRARY.AddMoney(ply, currency, amount)
    if !currency then
        currency = RDV.LIBRARY.GetConfigOption("SAL_curChoose")
    end

    local TAB = CURRENCIES[currency]

    if not TAB or not isfunction(TAB.AddMoney) then
        return false
    end

    TAB:AddMoney(ply, amount)
end

function RDV.LIBRARY.CanAfford(ply, currency, amount)
    if !currency then
        currency = RDV.LIBRARY.GetConfigOption("SAL_curChoose")
    end

    local TAB = CURRENCIES[currency]

    if not TAB or not isfunction(TAB.CanAfford) then
        return false
    end

    return TAB:CanAfford(ply, amount)
end

function RDV.LIBRARY.FormatMoney(currency, amount)
    if !currency then
        currency = RDV.LIBRARY.GetConfigOption("SAL_curChoose")
    end
    
    local TAB = CURRENCIES[currency]

    if not TAB or not isfunction(TAB.FormatMoney) then
        return false
    end

    return TAB:FormatMoney(amount)
end

function RDV.LIBRARY.GetCurrencies()
    local TAB = CURRENCIES

    local NEW = {}

    for k, v in pairs(TAB) do
        table.insert(NEW, k)
    end

    return NEW
end

--[[
    Old Addon Support
--]]

function RDV.AddMoney(ply, currency, amount)
    RDV.LIBRARY.AddMoney(ply, currency, amount)
end

function RDV.CanAfford(ply, currency, amount)
    return RDV.LIBRARY.CanAfford(ply, currency, amount)
end

function RDV.FormatMoney(currency, amount)
    return RDV.LIBRARY.FormatMoney(currency, amount)
end

hook.Add("RDV_LIB_Loaded", "RDV_LIB_MONEY", function()
    local N = {}

    for k, v in pairs(CURRENCIES) do
        table.insert(N, k)
    end

    RDV.LIBRARY.AddConfigOption("SAL_curChoose", {
        TYPE = RDV.LIBRARY.TYPE.SE,
        LIST = N, 
		CATEGORY = "Library", 
        DESCRIPTION = "Currency", 
        DEFAULT = "darkrp",
        SECTION = "Currency",
    })
end )
--PATH lua/reality_development/libs/currencies/list/sh_basewars.lua:
return gluapack()()
--PATH lua/reality_development/libs/currencies/list/sh_blank.lua:
return gluapack()()
--PATH lua/reality_development/libs/currencies/list/sh_darkrp.lua:
local OBJ = RDV.LIBRARY.RegisterCurrency("darkrp")

function OBJ:AddMoney(p, amount)
    p:addMoney(amount)
end

function OBJ:CanAfford(p, amount)
    return p:canAfford(amount)
end

function OBJ:FormatMoney(money)
    return DarkRP.formatMoney(money)
end
--PATH lua/reality_development/libs/currencies/list/sh_gwg.lua:
return gluapack()()
--PATH lua/reality_development/libs/currencies/list/sh_helix.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/libs/sh_pon.lua:
if SAM_LOADED then return end

--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  -		 k,v - pointers
 - strings -		 k,v - pointers
 - numbers -		k,v
 - booleans-		 k,v

 - Vectors -		 k,v
 - Angles  -		k,v
 - Entities-		 k,v
 - Players -		 k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]
local pon = {}
sam.pon = pon

do
	local type = sam.type
	local IsColor = IsColor
	local tonumber = tonumber
	local format = string.format
	local encode = {}
	local cacheSize = 0

	encode['table'] = function(self, tbl, output, cache)
		if cache[tbl] then
			output[#output + 1] = format('(%x)', cache[tbl])

			return
		else
			cacheSize = cacheSize + 1
			cache[tbl] = cacheSize
		end

		local first = next(tbl, nil)
		local predictedNumeric = 1

		-- starts with a numeric dealio
		if first == 1 then
			output[#output + 1] = '{'

			for k, v in next, tbl do
				if k == predictedNumeric then
					predictedNumeric = predictedNumeric + 1
					local tv = type(v)

					if tv == 'string' then
						local pid = cache[v]

						if pid then
							output[#output + 1] = format('(%x)', pid)
						else
							cacheSize = cacheSize + 1
							cache[v] = cacheSize
							self.string(self, v, output, cache)
						end
					elseif IsColor(v) then
						self.Color(self, v, output, cache)
					else
						self[tv](self, v, output, cache)
					end
				else
					break
				end
			end

			predictedNumeric = predictedNumeric - 1
		else
			predictedNumeric = nil
		end

		if predictedNumeric == nil then
			output[#output + 1] = '[' -- no array component
		else
			output[#output + 1] = '~' -- array component came first so shit needs to happen
		end

		for k, v in next, tbl, predictedNumeric do
			local tk, tv = type(k), type(v)
			if not self[tk] or not self[tv] then continue end

			-- WRITE KEY
			if tk == 'string' then
				local pid = cache[k]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[k] = cacheSize
					self.string(self, k, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tk](self, k, output, cache)
			end

			-- WRITE VALUE
			if tv == 'string' then
				local pid = cache[v]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[v] = cacheSize
					self.string(self, v, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tv](self, v, output, cache)
			end
		end

		output[#output + 1] = '}'
	end

	--	ENCODE STRING
	local gsub = string.gsub

	encode['string'] = function(self, str, output)
		--if tryCache(str, output then return end
		local estr, count = gsub(str, ';', "\\;")

		if count == 0 then
			output[#output + 1] = '\'' .. str .. ';'
		else
			output[#output + 1] = '"' .. estr .. '";'
		end
	end

	--	ENCODE NUMBER
	encode['number'] = function(self, num, output)
		if num % 1 == 0 then
			if num < 0 then
				output[#output + 1] = format('x%x;', -num)
			else
				output[#output + 1] = format('X%x;', num)
			end
		else
			output[#output + 1] = tonumber(num) .. ';'
		end
	end

	--	ENCODE BOOLEAN
	encode['boolean'] = function(self, val, output)
		output[#output + 1] = val and 't' or 'f'
	end

	--	ENCODE VECTOR
	encode['Vector'] = function(self, val, output)
		output[#output + 1] = ('v' .. val.x .. ',' .. val.y) .. (',' .. val.z .. ';')
	end

	--	ENCODE ANGLE
	encode['Angle'] = function(self, val, output)
		output[#output + 1] = ('a' .. val.p .. ',' .. val.y) .. (',' .. val.r .. ';')
	end

	encode['Entity'] = function(self, val, output)
		output[#output + 1] = 'E' .. (IsValid(val) and (val:EntIndex() .. ';') or '#')
	end

	encode['Player'] = encode['Entity']
	encode['Vehicle'] = encode['Entity']
	encode['Weapon'] = encode['Entity']
	encode['NPC'] = encode['Entity']
	encode['NextBot'] = encode['Entity']
	encode['PhysObj'] = encode['Entity']

	encode['Color'] = function(self, val, output)
		output[#output + 1] = ('C' .. val.r .. ',' .. val.g .. ',' .. val.b) .. (',' .. val.a .. ';')
	end

	encode['console'] = function(self, val, output)
		output[#output + 1] = 's'
	end

	encode['nil'] = function(self, val, output)
		output[#output + 1] = '?'
	end

	encode.__index = function(key)
		ErrorNoHalt('Type: ' .. key .. ' can not be encoded. Encoded as as pass-over value.')

		return encode['nil']
	end

	do
		local concat = table.concat

		function pon.encode(tbl)
			local output = {nil, nil, nil, nil, nil, nil, nil, nil}
			cacheSize = 0
			encode['table'](encode, tbl, output, {})

			return concat(output)
		end
	end
end

do
	local tonumber = tonumber
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode
	local Vector, Angle, Entity = Vector, Angle, Entity
	local decode = {}

	decode['{'] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tv = sub(str, index, index)

			if not tv or tv == '~' then
				index = index + 1
				break
			end

			if tv == '}' then return index + 1, cur end
			-- READ THE VALUE
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
			k = k + 1
		end

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	decode['['] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			if not k then continue end
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1

			if not self[tv] then
				print('did not find type: ' .. tv)
			end

			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	-- STRING
	decode['"'] = function(self, index, str, cache)
		local finish = find(str, '";', index, true)
		local res = gsub(sub(str, index, finish - 1), '\\;', ';')
		index = finish + 2
		cache[#cache + 1] = res

		return index, res
	end

	-- STRING NO ESCAPING NEEDED
	decode['\''] = function(self, index, str, cache)
		local finish = find(str, ';', index, true)
		local res = sub(str, index, finish - 1)
		index = finish + 1
		cache[#cache + 1] = res

		return index, res
	end

	-- NUMBER
	decode['n'] = function(self, index, str)
		index = index - 1
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, num
	end

	decode['0'] = decode['n']
	decode['1'] = decode['n']
	decode['2'] = decode['n']
	decode['3'] = decode['n']
	decode['4'] = decode['n']
	decode['5'] = decode['n']
	decode['6'] = decode['n']
	decode['7'] = decode['n']
	decode['8'] = decode['n']
	decode['9'] = decode['n']
	decode['-'] = decode['n']

	-- positive hex
	decode['X'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- negative hex
	decode['x'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = -tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- POINTER
	decode['('] = function(self, index, str, cache)
		local finish = find(str, ')', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, cache[num]
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode['t'] = function(self, index) return index, true end
	decode['f'] = function(self, index) return index, false end

	-- VECTOR
	decode['v'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local vecStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', vecStr, false)

		return index, Vector(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ANGLE
	decode['a'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local angStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', angStr, false)

		return index, Angle(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ENTITY
	decode['E'] = function(self, index, str)
		if str[index] == '#' then
			index = index + 1

			return index, NULL
		else
			local finish = find(str, ';', index, true)
			local num = tonumber(sub(str, index, finish - 1))
			index = finish + 1

			return index, Entity(num)
		end
	end

	-- COLOR
	decode['C'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local colStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', colStr, false)

		return index, Color(segs[1], segs[2], segs[3], segs[4])
	end

	-- PLAYER
	decode['P'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, Entity(num) or NULL
	end

	-- NIL
	decode['?'] = function(self, index) return index + 1, nil end
	-- SAM CONSOLE
	decode['s'] = function(self, index) return index, sam.console end

	function pon.decode(data)
		local _, res = decode[sub(data, 1, 1)](decode, 2, data, {})

		return res
	end
end
--PATH addons/[admin] sam-160/lua/sam/libs/sh_netstream.lua:
if SAM_LOADED then return end

--[[
	NetStream - 2.0.1
	https://github.com/alexgrist/NetStream/blob/master/netstream2.lua

	Alexander Grist-Hucker
	http://www.revotech.org
]]--

--[[
	if SERVER then
		netstream.Hook("Hi", function(ply, ...) -- Third argument is called to check if the player has permission to send the net message before decoding
			print(...)
		end, function(ply)
			if not ply:IsAdmin() then
				return false
			end
		end)
		-- OR
		netstream.Hook("Hi", function(ply, ...)
			print(...)
		end)
		netstream.Start(Entity(1), "Hi", "a", 1, {}, true, false, nil, "!") -- First argument player or table of players or any other argument to send to all players
		netstream.Start({Entity(1), Entity(2)}, "Hi", "a", 1, {}, true, false, nil, "!")
		netstream.Start(nil, "Hi", "a", 1, {}, true, false, nil, "!")
	end
	if CLIENT then
		netstream.Hook("Hi", function(...)
			print(...)
		end)
		netstream.Start("Hi", "a", 1, {}, true, false, nil, "!")
	end
]]--

-- Config

local addonName = "SAM"
local mainTable = sam -- _G.netstream = netstream

local sfs = sam.sfs
local encode_array = sfs.encode_array
local decode = sfs.decode

--

local type = sam.type
local unpack = unpack

local net = net
local compress = util.Compress
local decompress = util.Decompress

local netStreamSend = addonName .. ".NetStreamDS.Sending"

local netstream = {}
if istable(mainTable) then
	mainTable.netstream = netstream
end

local checks = {}
local receivers = {}

if SERVER then
	util.AddNetworkString(netStreamSend)

	local player_GetAll = player.GetAll
	function netstream.Start(ply, name, ...)
		if #name > 31 then
			error("netstream.Start name too long")
		end

		local ply_type = type(ply)
		if ply_type ~= "Player" and ply_type ~= "table" then
			ply = player_GetAll()
		end

		local array_length = select("#", ...)
		local encoded_data = encode_array({name, array_length, ...}, array_length + 2)

		net.Start(netStreamSend)
			net.WriteBool(false)
			net.WriteData(encoded_data)
		net.Send(ply)
	end

	function netstream.StartCompressed(ply, name, ...)
		if #name > 31 then
			error("netstream.Start name too long")
		end

		local ply_type = type(ply)
		if ply_type ~= "Player" and ply_type ~= "table" then
			ply = player_GetAll()
		end

		local array_length = select("#", ...)
		local encoded_data = encode_array({name, array_length, ...}, array_length + 2)

		local compressed_data = compress(encoded_data)

		net.Start(netStreamSend)
			net.WriteBool(true)
			net.WriteData(compressed_data)
		net.Send(ply)
	end

	function netstream.Hook(name, callback, check)
		if #name > 31 then
			error("netstream.Hook name too long")
		end

		receivers[name] = callback
		if type(check) == "function" then
			checks[name] = check
		end
	end

	net.Receive(netStreamSend, function(_, ply)
		local name = net.ReadString()

		local callback = receivers[name]
		if not callback then return end

		local length = net.ReadUInt(16)

		local check = checks[name]
		if check and check(ply, length) == false then return end

		local binary_data = net.ReadData(length)

		local decoded_data = decode(binary_data)
		if type(decoded_data) ~= "table" then return end

		local array_length = decoded_data[1]
		if type(array_length) ~= "number" then return end
		if array_length < 0 then return end

		callback(ply, unpack(decoded_data, 2, array_length + 1))
	end)
else
	checks = nil

	function netstream.Start(name, ...)
		if #name > 31 then
			error("netstream.Start name too long")
		end

		local array_length = select("#", ...)
		local encoded_data = encode_array({array_length, ...}, array_length + 1)

		local length = #encoded_data

		net.Start(netStreamSend)
			net.WriteString(name)
			net.WriteUInt(length, 16)
			net.WriteData(encoded_data, length)
		net.SendToServer()
	end

	function netstream.Hook(name, callback)
		receivers[name] = callback
	end

	net.Receive(netStreamSend, function(len)
		local compressed = net.ReadBool()
		local binary_data = net.ReadData((len - 1) / 8)

		if compressed then
			binary_data = decompress(binary_data)
			if not binary_data then return end
		end

		local decoded_data, err, err2 = decode(binary_data)
		if err ~= nil then
			sam.print("NetStream error: " .. err .. err2)
			return
		end

		local name = decoded_data[1]

		local callback = receivers[name]
		if not callback then return end

		callback(unpack(decoded_data, 3, decoded_data[2] + 2))
	end)
end

return netstream

--PATH addons/[admin] sam-160/lua/sam/libs/sh_async_netstream.lua:
if SAM_LOADED then return end

local netstream = sam.netstream
netstream.async = {}

if SERVER then
	local IsValid = IsValid
	function netstream.async.Hook(name, fn, check)
		netstream.Hook(name, function(ply, i, ...)
			if not sam.isnumber(i) then return end
			local res = function(...)
				if IsValid(ply) then
					netstream.Start(ply, name, i, ...)
				end
			end
			fn(res, ply, ...)
		end, check)
	end
else
	local count = 0
	local receivers = {}

	local hook_fn = function(i, ...)
		local receiver = receivers[i]
		if receiver[2] then
			receiver[2]()
		end
		receiver[1]:resolve(...)
		receivers[i] = nil
	end

	function netstream.async.Start(name, func_to_call, ...)
		local promise = sam.Promise.new()
		count = count + 1
		receivers[count] = {promise, func_to_call}
		netstream.Hook(name, hook_fn)
		if func_to_call then
			func_to_call()
		end
		netstream.Start(name, count, ...)
		return promise
	end
end
--PATH addons/[admin] sam-160/lua/sam_languages/english.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/rank.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/steamid.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/sh_restrictions.lua:
if SAM_LOADED then return end

local loaded = false
local load_restrictions = function()
	local sam = sam
	local config = sam.config
	local hook = hook
	local SERVER = SERVER

	if CLIENT then
		local add_setting = function(body, title, key)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:SetLabel(title)

			local enable = setting:Add("SAM.ToggleButton")
			enable:SetConfig(key, true)

			return setting
		end

		config.add_menu_setting("Restrictions", function(body)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:DockMargin(8, 6, 8, 0)
			setting:SetLabel("Restrictions (Check these settings in ranks' permissions)")

			local setting_body = body:Add("Panel")
			setting_body:Dock(TOP)
			setting_body:DockMargin(8, 6, 8, 0)
			setting_body:DockPadding(8, 0, 8, 0)

			add_setting(setting_body, "Tool (Eg. using button tool)", "Restrictions.Tool")
			add_setting(setting_body, "Spawning (Eg. spawning props)", "Restrictions.Spawning")
			add_setting(setting_body, "Limits (Eg. how many props can you spawn)", "Restrictions.Limits")

			function setting_body:PerformLayout()
				setting_body:SizeToChildren(false, true)
			end
		end)
	end

	local tools = weapons.GetStored("gmod_tool")
	if sam.istable(tools) then
		if config.get("Restrictions.Tool", true) then
			for k, v in pairs(tools.Tool) do
				sam.permissions.add(v.Mode, "Tools - " .. (v.Category or "Other"), "user")
			end

			hook.Add("CanTool", "SAM.Module.Restrictions", function(ply, _, tool)
				if not ply:HasPermission(tool) then
					if CLIENT and sam.player.check_cooldown(ply, "ToolNoPermission", 0.1) then
						ply:sam_send_message("You don't have permission to use this tool.")
					end
					return false
				end
			end)
		else
			for k, v in pairs(tools.Tool) do
				sam.permissions.remove(v.Mode)
			end

			hook.Remove("CanTool", "SAM.Module.Restrictions")
		end
	end

	sam.permissions.add("admin_weapons", "Spawning", "superadmin")

	local function no_permission(ply, name)
		ply:sam_play_sound("buttons/button10.wav")
		ply:sam_send_message("You don't have permission to spawn {S Blue}.", {
			S = name
		})
	end

	local spawning = {
		PlayerSpawnProp = {
			name = "props",
			permission = "user",
			call_gm = true,
		},
		PlayerGiveSWEP = {
			name = "give_weapons",
			cb = function(_, ply, _, wep)
				if wep.sam_AdminOnly and not ply:HasPermission("admin_weapons") then
					no_permission(ply, "admin weapons")
					return false
				end
				return true
			end,
			hook = sam.hook_first,
		},
		PlayerSpawnSWEP = {
			name = "spawn_weapons",
			cb = function(_, ply, _, wep)
				if wep.sam_AdminOnly and not ply:HasPermission("admin_weapons") then
					no_permission(ply, "admin weapons")
					return false
				end
				return true
			end,
			hook = sam.hook_first,
		},
		-- PlayerSpawnSENT = {
		-- 	name = "entities",
		-- 	check_limit = "sents"
		-- },
		PlayerSpawnNPC = {
			name = "npcs",
			check_limit = "npcs",
		},
		PlayerSpawnVehicle = {
			name = "vehicles",
			check_limit = "vehicles",
		},
		PlayerSpawnRagdoll = {
			name = "ragdolls",
			permission = "user",
			check_limit = "ragdolls",
		}
	}

	local override_lists = {
		"Weapon",
		-- "SpawnableEntities"
	}

	local function LimitReachedProcess(ply, str)
		if not IsValid(ply) then return true end
		return ply:CheckLimit(str)
	end

	local GAMEMODE = GAMEMODE
	if config.get("Restrictions.Spawning", true) then
		for k, v in pairs(spawning) do
			local name = v
			local permission = "superadmin"
			local check
			local check_limit
			local hook = sam.hook_last
			if istable(v) then
				name = v.name
				permission = v.permission or permission
				if v.call_gm then
					check = GAMEMODE[k]
				elseif v.cb then
					check = v.cb
				end
				hook = v.hook or hook
				check_limit = v.check_limit
			end

			sam.permissions.add(name, "Spawning", permission)

			if SERVER then
				hook(k, "SAM.Spawning." .. k .. name, function(ply, ...)
					if not ply:HasPermission(name) then
						no_permission(ply, name)
						return false
					end

					if check_limit then
						return LimitReachedProcess(ply, check_limit)
					end

					if check then
						return check(GAMEMODE, ply, ...)
					end

					return true
				end)
			end
		end

		for i = 1, #override_lists do
			for k, v in pairs(list.GetForEdit(override_lists[i])) do
				v.sam_AdminOnly = v.sam_AdminOnly or v.AdminOnly
				v.AdminOnly = false
			end
		end
	else
		sam.permissions.add("admin_weapons")

		for k, v in pairs(spawning) do
			sam.permissions.remove(istable(v) and v.name or v)

			if SERVER then
				hook.Remove(k, "SAM.Spawning." .. k)
			end
		end

		for i = 1, #override_lists do
			for k, v in pairs(list.GetForEdit(override_lists[i])) do
				if v.sam_AdminOnly then
					v.AdminOnly = v.sam_AdminOnly
				end
			end
		end
	end

	local PLAYER = FindMetaTable("Player")
	if config.get("Restrictions.Limits", true) then
		local get_limit = sam.ranks.get_limit
		function PLAYER:GetLimit(limit_type)
			return get_limit(self:GetUserGroup(), limit_type)
		end

		sam.hook_first("PlayerCheckLimit", "SAM.PlayerCheckLimit", function(ply, limit_type, count)
			local ply_limit = ply:GetLimit(limit_type)
			if ply_limit < 0 then return true end

			if count > ply_limit - 1 then
				return false
			end

			return true
		end)

		sam.limit_types = {}
		for _, limit_type in SortedPairs(cleanup.GetTable(), true) do
			local cvar = GetConVar("sbox_max" .. limit_type)
			if cvar then
				table.insert(sam.limit_types, limit_type)
			end
		end
	else
		sam.limit_types = nil
		PLAYER.GetLimit = nil
		hook.Remove("PlayerCheckLimit", "SAM.PlayerCheckLimit")
	end

	if not loaded then
		loaded = true
		hook.Call("SAM.LoadedRestrictions")
	end
end

timer.Simple(5, function()
	if GAMEMODE.IsSandboxDerived then
		sam.config.hook({"Restrictions.Tool", "Restrictions.Spawning", "Restrictions.Limits"}, load_restrictions)
	end
end)

--PATH addons/[admin] sam-160/lua/sam/menu/cl_init.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/menu/cl_init.lua:
if SAM_LOADED then return end

local vgui = vgui
local draw = draw

local sam = sam
local sui = sui
local TDLib = sui.TDLib

local config = sam.config

do
	local funcs = {
		["SAM.ComboBox"] = {
			event = "OnSelect",
			function(s, _, value)
				config.set(s.config_key, value)
			end
		},
		["SAM.TextEntry"] = {
			event = "OnEnter",
			function(s)
				local v = s:GetText()
				if s:GetNumeric() then
					v = tonumber(v)
				end
				config.set(s.config_key, v)
			end
		},
		["SAM.ToggleButton"] = {
			event = "OnChange",
			function(s, v)
				config.set(s.config_key, v)
			end
		}
	}

	sam.SUI = sam.SUI or sui.new("SAM", true, {
		SetConfig = function(s, key, default)
			s.config_key = key

			local i = config.hook({key}, function(value, old)
				local v = config.get(key, default)
				s:SetValue(v)
			end)

			local t = funcs[s:GetName()]
			s[t.event] = t[1]

			s:On("OnRemove", function()
				config.remove_hook(i)
			end)
		end
	})
end

local SUI = sam.SUI
local GetColor = SUI.GetColor

sam.menu = {}

local tabs = {}
function sam.menu.add_tab(icon, func, check, pos)
	local tab = {
		icon = icon,
		func = func,
		check = check,
		pos = pos
	}
	for k, v in ipairs(tabs) do
		if v.icon == icon then
			tabs[k] = tab
			return
		end
	end
	table.insert(tabs, tab)
end

function sam.menu.remove_tab(name)
	for k, v in ipairs(tabs) do
		if v.name == name then
			table.remove(tabs, k)
			break
		end
	end
end

SAM_TAB_TITLE_FONT = SUI.CreateFont("TabTitle", "Roboto Bold", 22)
SAM_TAB_DESC_FONT = SUI.CreateFont("TabDesc", "Roboto Medium", 15)

local MENU_LOADING = SUI.CreateFont("MenuLoading", "Roboto", 30)

SUI.AddToTheme("Dark", {
	frame = "#181818",

	scroll_panel = "#181818",

	menu_tabs_title = "#ffffff",

	--=--
	player_list_titles = "#f2f1ef",

	player_list_names = "#eeeeee",
	player_list_names_2 = "#ff6347",
	player_list_data = "#e8e8e8",

	player_list_rank = "#41b9ff",
	player_list_console = "#00c853",
	player_list_rank_text = "#2c3e50",

	player_list_steamid = "#a4a4a4",
	--=--

	--=--
	actions_button = Color(0, 0, 0, 0),
	actions_button_hover = Color(200, 200, 200, 60),

	actions_button_icon = "#aaaaaa",
	actions_button_icon_hover = "#ffffff",
	--=--

	--=--
	page_switch_bg = "#222222",
	--=--
})

SUI.SetTheme("Dark")

function SUI.panels.Frame:Paint(w, h)
	if GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	draw.RoundedBox(8, 0, 0, w, h, GetColor("frame"))
end

function SUI.panels.Frame:HeaderPaint(w, h)
	draw.RoundedBoxEx(8, 0, 0, w, h, GetColor("header"), true, true, false, false)
	draw.RoundedBox(0, 0, h - 1, w, 1, GetColor("line"))
end

do
	function sam.menu.add_loading_panel(parent)
		local is_loading = false

		local loading_panel = parent:Add("Panel")
		loading_panel:SetVisible(false)
		loading_panel:SetZPos(999999)
		loading_panel:SetMouseInputEnabled(false)

		function loading_panel:Paint(w, h)
			draw.RoundedBox(3, 0, 0, w, h, Color(50, 50, 50, 200))
			draw.SimpleText(string.rep(".", (CurTime() * 3) % 3), MENU_LOADING, w/2, h/2, Color(200, 200, 200, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		parent:SUI_TDLib()
		parent:On("PerformLayout", function(s, w, h)
			loading_panel:SetSize(w, h)
		end)

		local first = true
		local toggle_loading = function(bool)
			if not IsValid(loading_panel) then return end

			is_loading = bool or not is_loading
			if is_loading and not first then
				loading_panel:SetVisible(is_loading and true or false)
				loading_panel:SetMouseInputEnabled(is_loading)
			else
				timer.Simple(0.2, function()
					if not IsValid(loading_panel) then return end
					loading_panel:SetVisible(is_loading and true or false)
					loading_panel:SetMouseInputEnabled(is_loading)
				end)
			end

			first = false
		end

		return toggle_loading, function()
			return is_loading
		end
	end
end

local sam_menu
function sam.menu.open_menu()
	if IsValid(sam_menu) then
		return sam_menu:IsVisible() and sam_menu:Hide() or sam_menu:Show()
		-- sam_menu:Remove()
	end

	sam_menu = vgui.Create("SAM.Frame")
	sam_menu:Center()
	sam_menu:MakePopup()
	sam_menu:SetTitle("SAM")

	sam_menu:AddAnimations(800, 600)

	sam_menu.close.DoClick = function()
		sam_menu:Hide()
	end

	local sheet = sam_menu:Add("SAM.ColumnSheet")
	sheet:Dock(FILL)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)
	sheet.Paint = nil

	local tab_scroller = sheet.tab_scroller
	tab_scroller:DockMargin(0, 1, 0, 1)

	function tab_scroller:Paint(w, h)
		draw.RoundedBoxEx(8, 0, 0, w, h, GetColor("column_sheet_bar"), false, false, true, false)
	end

	local sheets = {}
	for _, v in SortedPairsByMemberValue(tabs, "pos") do
		sheets[v.icon] = sheet:AddSheet(v.icon, v.func)
	end

	tab_scroller = tab_scroller:GetCanvas()
	sam_menu:On("Think", function()
		for _, v in ipairs(tabs) do
			local tab = sheets[v.icon]
			if v.check and not v.check() then
				if tab:IsVisible() then
					tab:SetVisible(false)
					if sheet:GetActiveTab() == tab then
						sheet:SetActiveTab(sheet.tabs[1])
					end
					tab_scroller:InvalidateLayout()
				end
			elseif not tab:IsVisible() then
				tab:SetVisible(true)
				tab_scroller:InvalidateLayout()
			end
		end
	end)
end

function sam.menu.get()
	return sam_menu
end

hook.Add("GUIMouseReleased", "SAM.CloseMenu", function(mouse_code)
	local panel = vgui.GetHoveredPanel()
	if mouse_code == MOUSE_LEFT and panel == vgui.GetWorldPanel() and IsValid(sam_menu) and sam_menu:HasHierarchicalFocus() then
		sam_menu:Hide()
	end
end)

for _, f in ipairs(file.Find("sam/menu/tabs/*.lua", "LUA")) do
	sam.load_file("sam/menu/tabs/" .. f, "sh")
end
--PATH addons/[lib] sui/lua/sui/vgui/sui_frame.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_property_sheet.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_slider.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_zcollapse_category.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_zmenu.lua:
local BSHADOWS = sui.BSHADOWS
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local OPTION_FONT = SUI.CreateFont("MenuOption", "Roboto Medium", 15, 500)

local PANEL = {}

AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_SetInternal", "Internal")

PANEL:SetIsMenu(true)
PANEL:SetDeleteSelf(true)

local pad = 4
local max_height = 300

local PerformLayout = function(s)
	local w, h = s:ChildrenSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end
	s:SetSize(math.max(s:GetMinimumWidth(), w), h)
end

function PANEL:Init()
	self:GetCanvas():DockPadding(0, pad, 0, pad)
	self:SetMinimumWidth(SUI.Scale(100))
	self:SetKeyboardInputEnabled(false)
	self:SetTall(pad * 2)
	self:SetAlpha(0)
	self.tall = pad * 2
	RegisterDermaMenuForClose(self)
	self:On("PerformLayoutInternal", PerformLayout)
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
		self:RoundedBox("Background", pad, x, y, w, h, GetColor("menu"))
	BSHADOWS.EndShadow(1, 3, 3)

	self:MoveToFront()
end

function PANEL:Open(x, y)
	self:SizeToChildren(true, false)

	local w, h = self:GetSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end

	local internal = self:GetInternal()
	internal:On("OnRemove", function()
		self:Remove()
	end)
	if not x then
		x, y = internal:LocalToScreen(0, 0)
		y = y + (internal:GetTall() + 2)
	end

	if y + h > ScrH() then
		y = y - h
	end

	if x + w > ScrW() then
		x = x - w
	end

	if y < 1 then
		y = 1
	end

	if x < 1 then
		x = 1
	end

	self:SetPos(x, y)
	self:MakePopup()
	self:AlphaTo(255, 0.23)
	self:SetDrawOnTop(true)
	self:MoveToFront()
end

local option_OnMouseReleased = function(s, mousecode)
	if s.Depressed and mousecode == MOUSE_LEFT then
		CloseDermaMenus()
	end
	DButton.OnMouseReleased(s, mousecode)
end

function PANEL:AddOption(str, callback)
	local option = self:Add("DButton")
	option:Dock(TOP)
	option:SetFont(OPTION_FONT)
	option:SetText(str)
	option:SizeToContentsX(20)
	option:SizeToContentsY(10)
	option:InvalidateLayout(true)
	option.OnMouseReleased = option_OnMouseReleased

	function option:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, self.Hovered and GetColor("menu_option_hover") or GetColor("menu_option"))
		TextColor(self, self.Hovered and GetColor("menu_option_hover_text") or GetColor("menu_option_text"))
	end

	option.DoClick = callback

	self.tall = self.tall + option:GetTall()
	self:SetTall(self.tall)

	return option
end

function PANEL:AddSpacer()
	local spacer = self:Add("Panel")
	spacer:Dock(TOP)
	spacer:DockMargin(0, 1, 0, 1)
	spacer:SetTall(2)

	function spacer:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, GetColor("menu_spacer"))
	end

	spacer:InvalidateLayout(true)
end

sui.register("Menu", PANEL, NAME .. ".ScrollPanel")
--PATH addons/[admin] sam-160/lua/sui/vgui/sam_player_line.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TDLib = sui.TDLib
local draw_material = sui.draw_material
local lerp_color = sui.lerp_color

local GetColor = SUI.GetColor
local RoundedBox = TDLib.RoundedBox
local CircleAvatar = TDLib.LibClasses.CircleAvatar
local CircleClick2 = TDLib.LibClasses.CircleClick2

local PLAYER_LINE_NAME = SUI.CreateFont("PlayerLineName", "Roboto Bold", 17)
local PLAYER_LINE_RANK = SUI.CreateFont("PlayerLineRank", "Roboto Bold", 13)
local PLAYER_LINE_STEAMID = SUI.CreateFont("PlayerLineSteamID", "Roboto Medium", 12)

local PANEL = {}

function PANEL:Init()
	local size = SUI.Scale(34)

	self:Dock(TOP)
	self:SetTall(size)

	self.size = size
end

local rank_Paint = function(s, w, h)
	RoundedBox(s.rect, SUI.Scale(10), 0, 0, w, h, s.col)
end

function PANEL:SetInfo(info)
	local size = self.size

	local container
	do
		local w = SUI.Scale(280) + size

		local _container = self:Add("Panel")
		_container:Dock(LEFT)
		_container:SetMouseInputEnabled(false)
		_container:SetWide(w)

		container = _container:Add("Panel")
		container:SetSize(w, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	do
		local avatar = container:Add("Panel")
		avatar:Dock(LEFT)
		avatar:DockMargin(0, 0, 5, 0)
		avatar:SetWide(size)
		avatar:SetMouseInputEnabled(false)
		CircleAvatar(avatar)

		avatar:SetSteamID(util.SteamIDTo64(info.steamid), size)
	end

	do
		local top_container = container:Add("Panel")
		top_container:Dock(TOP)
		top_container:DockMargin(0, 0, 0, 2)

		local name = top_container:Add("SAM.Label")
		name:Dock(LEFT)
		name:SetFont(PLAYER_LINE_NAME)
		self.name = name

		local pname = info.name
		if not pname or pname == "" then
			name:SetTextColor(GetColor("player_list_names_2"))
			self:SetName("N/A")
		else
			name:SetTextColor(GetColor("player_list_names"))
			self:SetName(pname)
		end

		if info.rank then
			local rank_bg = top_container:Add("Panel")
			rank_bg:Dock(LEFT)
			rank_bg:DockMargin(5, 0, 0, 0)

			rank_bg.rect = {}
			rank_bg.col = info.rank_bg or GetColor("player_list_rank")
			rank_bg.Paint = rank_Paint

			local rank = rank_bg:Add("SAM.Label")
			rank:Dock(FILL)
			rank:DockMargin(SUI.Scale(8), 0, 0, 0)
			rank:SetTextColor(GetColor("player_list_rank_text"))
			rank:SetFont(PLAYER_LINE_RANK)
			rank.bg = rank_bg

			self.rank = rank
			self:SetRank(info.rank)

			rank_bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
		end

		top_container:SizeToChildren(true, true)
	end

	local steamid = container:Add("SAM.Label")
	steamid:Dock(TOP)
	steamid:SetTextColor(GetColor("player_list_steamid"))
	steamid:SetFont(PLAYER_LINE_STEAMID)
	steamid:SetText(info.steamid)
	steamid:SizeToContents()
	steamid:SetAutoStretchVertical(true)

	self.container = container
end

function PANEL:SetName(new_name)
	local name =  self.name
	name:SetText(new_name)
	name:SizeToContents()
	if name:GetWide() > 160 then
		name:SetWide(158)
	end
end

function PANEL:SetRank(new_rank)
	local rank = self.rank
	rank:SetText(new_rank)
	rank:SizeToContents()
	rank.bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
end

function PANEL:Actions()
	local container
		do
		local size = self.size

		local _container = self:Add("Panel")
		_container:Dock(RIGHT)
		_container:SetWide(size)

		container = _container:Add("Panel")
		container:SetSize(size, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	local actions_button = container:Add("SAM.Button")
	actions_button:SetText("")
	actions_button:ClearPaint()

	function container:PerformLayout(w, h)
		actions_button:SetSize(h, h)
		actions_button:Center()
	end

	local image = actions_button:Add("SAM.Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/dots_verticle.png")

	local current_icon_color = Color(GetColor("actions_button_icon"):Unpack())
	function image:Draw(w, h)
		if not h then return end

		if actions_button.Hovered then
			lerp_color(current_icon_color, GetColor("actions_button_icon_hover"))
		else
			lerp_color(current_icon_color, GetColor("actions_button_icon"))
		end

		draw_material(nil, w / 2, h / 2, SUI.ScaleEven(20), current_icon_color)
	end

	CircleClick2(actions_button, Color(62, 62, 62), 10)
	actions_button:Center()

	return actions_button
end

sui.register("PlayerLine", PANEL, "Panel")
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/commands.lua:
if SAM_LOADED then return end
if SERVER then return end

local sam = sam
local SUI = sam.SUI
local type = sam.type

local Line = sui.TDLib.LibClasses.Line

local COMMAND_HELP = SUI.CreateFont("CommandHelp", "Roboto", 14)
local COMMAND_RUN = SUI.CreateFont("CommandRun", "Roboto Medium", 14)

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/command_window.png", function(column_sheet)
	local tab_body = column_sheet:Add("Panel")
	tab_body:Dock(FILL)
	tab_body:DockMargin(0, 1, 0, 0)

	do
		local title = tab_body:Add("SAM.Label")
		title:Dock(TOP)
		title:DockMargin(10, 10, 0, 0)
		title:SetFont(SAM_TAB_TITLE_FONT)
		title:SetText("Commands")
		title:SetTextColor(SUI.GetColor("menu_tabs_title"))
		title:SizeToContents()
	end

	local body = tab_body:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(10, 5, 10, 10)

	Line(body)

	local left_body = body:Add("SAM.Panel")
	left_body:Dock(LEFT)
	left_body:SetWide(148)

	local search_entry = left_body:Add("SAM.TextEntry")
	search_entry:Dock(TOP)
	search_entry:SetNoBar(true)
	search_entry:SetPlaceholder("Search...")
	search_entry:SetRadius(4)
	search_entry:SetTall(27)

	local category_list = left_body:Add("SAM.CollapseCategory")
	category_list:Dock(FILL)
	category_list:DockMargin(0, SUI.Scale(10), 0, 0)

	local canvas = category_list:GetCanvas()

	local commands_refresh = function()
		if not IsValid(category_list) then return end

		canvas:Clear()
		table.Empty(category_list.items)
		table.Empty(category_list.categories)

		for k, v in ipairs(sam.command.get_commands()) do
			if (v.permission and not LocalPlayer():HasPermission(v.permission)) or v.menu_hide then
				continue
			end

			local item = category_list:add_item(v.name, v.category)
			item:InvalidateParent(true)
			item.help = v.help
			item.command = v

			item.names = {v.name:lower()}
			for _, aliase in ipairs(v.aliases) do
				table.insert(item.names, aliase:lower())
			end
		end
	end
	commands_refresh()

	do
		local hooks = {
			"SAM.CommandAdded", "SAM.CommandModified", "SAM.CommandRemoved",
			"SAM.RemovedPermission",
			{"SAM.ChangedPlayerRank", func = function(ply, rank, old_rank)
				if rank == old_rank then return end
				if ply == LocalPlayer() then
					commands_refresh()
				end
			end},
			{
				"SAM.RankPermissionGiven", "SAM.RankPermissionTaken", "SAM.ChangedInheritRank",
				func = function(rank)
					if rank == LocalPlayer():GetUserGroup() then
						commands_refresh()
					end
				end
			},
			{
				"SAM.AddedPermission", "SAM.PermissionModified",
				func = function(_, _, rank)
					if rank == LocalPlayer():GetUserGroup() then
						commands_refresh()
					end
				end
			}
		}
		for _, v in ipairs(hooks) do
			if type(v) == "table" then
				for _, v2 in ipairs(v) do
					hook.Add(v2, "SAM.Menu.RefreshCommands", v.func)
				end
			else
				hook.Add(v, "SAM.Menu.RefreshCommands", commands_refresh)
			end
		end
	end

	function search_entry:OnValueChange(text)
		category_list:Search(text:lower())
	end

	do
		local line = Line(body, LEFT)
		line:DockMargin(10, 0, 10, 0)
		line:SetWide(1)
	end

	local buttons = body:Add("SAM.ScrollPanel")
	buttons:Dock(FILL)

	local childs = {}
	local pos = 0
	buttons:GetCanvas():On("OnChildAdded", function(s, child)
		child:Dock(TOP)
		child:DockMargin(0, 0, 0, 5)
		child:SetAlpha(0)
		child:SetVisible(false)
		table.insert(childs, child)

		pos = pos + 1
		child:SetZPos(pos)
	end)

	local run_command = buttons:Add("SAM.Button")
	run_command:Dock(TOP)
	run_command:SetTall(25)
	run_command:SetFont(COMMAND_RUN)
	run_command:SetZPos(100)
	run_command:SetEnabled(false)

	run_command:On("DoClick", function(self)
		LocalPlayer():ConCommand("sam\"" .. self:GetText() .. "\"\"" .. table.concat(self.input_arguments, "\"\"") .. "\"")
	end)

	local help = buttons:Add("SAM.Label")
	help:Dock(TOP)
	help:SetFont(COMMAND_HELP)
	help:SetZPos(101)
	help:SetWrap(true)
	help:SetAutoStretchVertical(true)

	sam.menu.get():On("OnKeyCodePressed", function(s, key_code)
		if key_code == KEY_ENTER and IsValid(run_command) and run_command:IsEnabled() and run_command:IsMouseInputEnabled() and tab_body:IsVisible() then
			run_command:DoClick()
		end
	end)

	function category_list:item_selected(item)
		local arguments = sam.command.get_arguments()
		local command = item.command
		local command_arguments = command.args
		local input_arguments = {}

		for i = #childs, 3, -1 do
			local v = childs[i]
			if not v.no_change or not command:HasArg(v.no_change) then
				if v.no_remove ~= true then
					v:Remove()
				else
					v:Hide()
				end
			end
		end

		local NIL = {}
		for _, v in ipairs(command_arguments) do
			local func = arguments[v.name]["menu"]
			if not func then continue end

			local i = table.insert(input_arguments, NIL)
			local p = func(function(allow)
				if not IsValid(run_command) then return end
				input_arguments[i] = allow == nil and NIL or allow
				for i_2 = 1, #input_arguments do
					if input_arguments[i_2] == NIL then
						run_command:SetEnabled(false)
						return
					end
				end
				run_command:SetEnabled(true)
			end, body, buttons, v, childs)
			if p then
				p:AnimatedSetVisible(true)
			end
		end

		if #command_arguments == 0 then
			run_command:SetEnabled(true)
		end

		run_command:SetText(command.name)
		run_command:AnimatedSetVisible(true)
		run_command.input_arguments = input_arguments

		if command.help then
			help:SetText(command.help)
			help:AnimatedSetVisible(true)
			help:SizeToContents()
		else
			help:AnimatedSetVisible(false)
		end

		buttons:InvalidateLayout(true)
	end

	return tab_body
end, nil, 1)

--PATH addons/[admin] sam-160/lua/sam/modules/fun.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/fun.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Fun")

do
	local sounds = {}
	for i = 1, 6 do
		sounds[i] = "physics/body/body_medium_impact_hard" .. i .. ".wav"
	end

	local slap = function(ply, damage, admin)
		if not ply:Alive() or ply:sam_get_nwvar("frozen") then return end
		ply:ExitVehicle()

		ply:SetVelocity(Vector(math.random(-100, 100), math.random(-100, 100), math.random(200, 400)))
		ply:EmitSound(sounds[math.random(1, 6)], 60, math.random(80, 120))

		if damage > 0 then
			ply:TakeDamage(damage, admin, DMG_GENERIC)
		end
	end

	command.new("slap")
		:SetPermission("slap", "admin")

		:AddArg("player")
		:AddArg("number", {hint = "damage", round = true, optional = true, min = 0, default = 0})

		:Help("slap_help")

		:OnExecute(function(ply, targets, damage)
			for i = 1, #targets do
				slap(targets[i], damage, ply)
			end

			if damage > 0 then
				sam.player.send_message(nil, "slap_damage", {
					A = ply, T = targets, V = damage
				})
			else
				sam.player.send_message(nil, "slap", {
					A = ply, T = targets
				})
			end
		end)
	:End()
end

command.new("slay")
	:SetPermission("slay", "admin")

	:AddArg("player")

	:Help("slay_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local v = targets[i]
			if not v:sam_get_exclusive(ply) then
				v:Kill()
			end
		end

		sam.player.send_message(nil, "slay", {
			A = ply, T = targets
		})
	end)
:End()

command.new("hp")
	:Aliases("sethp", "health", "sethealth")

	:SetPermission("hp", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 1, max = 2147483647, round = true, optional = true, default = 100})

	:Help("hp_help")

	:OnExecute(function(ply, targets, amount)
		for i = 1, #targets do
			targets[i]:SetHealth(amount)
		end

		sam.player.send_message(nil, "set_hp", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

command.new("armor")
	:Aliases("setarmor")

	:SetPermission("armor", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 1, max = 2147483647, round = true, optional = true, default = 100})

	:Help("armor_help")

	:OnExecute(function(ply, targets, amount)
		for i = 1, #targets do
			targets[i]:SetArmor(amount)
		end

		sam.player.send_message(nil, "set_armor", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

command.new("ignite")
	:SetPermission("ignite", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "seconds", optional = true, default = 60, round = true})

	:Help("ignite_help")

	:OnExecute(function(ply, targets, length)
		for i = 1, #targets do
			local target = targets[i]

			if target:IsOnFire() then
				target:Extinguish()
			end

			target:Ignite(length)
		end

		sam.player.send_message(nil, "ignite", {
			A = ply, T = targets, V = length
		})
	end)
:End()

command.new("unignite")
	:Aliases("extinguish")

	:SetPermission("ignite", "admin")

	:AddArg("player", {optional = true})

	:Help("unignite_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:Extinguish()
		end

		sam.player.send_message(nil, "unignite", {
			A = ply, T = targets
		})
	end)
:End()

command.new("god")
	:Aliases("invincible")

	:SetPermission("god", "admin")

	:AddArg("player", {optional = true})

	:Help("god_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local target = targets[i]
			target:GodEnable()
			target.sam_has_god_mode = true
		end

		sam.player.send_message(nil, "god", {
			A = ply, T = targets
		})
	end)
:End()

command.new("ungod")
	:Aliases("uninvincible")

	:SetPermission("ungod", "admin")

	:AddArg("player", {optional = true})

	:Help("ungod_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local target = targets[i]
			target:GodDisable()
			target.sam_has_god_mode = nil
		end

		sam.player.send_message(nil, "ungod", {
			A = ply, T = targets
		})
	end)
:End()

do
	command.new("freeze")
		:SetPermission("freeze", "admin")

		:AddArg("player")

		:Help("freeze_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v:ExitVehicle()
				if v:sam_get_nwvar("frozen") then
					v:UnLock()
				end
				v:Lock()
				v:sam_set_nwvar("frozen", true)
				v:sam_set_exclusive("frozen")
			end

			sam.player.send_message(nil, "freeze", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unfreeze")
		:SetPermission("unfreeze", "admin")

		:AddArg("player", {optional = true})

		:Help("unfreeze_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v:UnLock()
				v:sam_set_nwvar("frozen", false)
				v:sam_set_exclusive(nil)
			end

			sam.player.send_message(nil, "unfreeze", {
				A = ply, T = targets
			})
		end)
	:End()

	local disallow = function(ply)
		if ply:sam_get_nwvar("frozen") then
			return false
		end
	end

	for _, v in ipairs({"SAM.CanPlayerSpawn", "CanPlayerSuicide", "CanTool"}) do
		hook.Add(v, "SAM.FreezePlayer." .. v, disallow)
	end
end

command.new("cloak")
	:SetPermission("cloak", "admin")

	:AddArg("player", {optional = true})

	:Help("cloak_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:sam_cloak()
		end

		sam.player.send_message(nil, "cloak", {
			A = ply, T = targets
		})
	end)
:End()

command.new("uncloak")
	:SetPermission("uncloak", "admin")

	:AddArg("player", {optional = true})

	:Help("uncloak_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:sam_uncloak()
		end

		sam.player.send_message(nil, "uncloak", {
			A = ply, T = targets
		})
	end)
:End()

do
	local jail_props = {
		Vector(0, 0, -5), Angle(90, 0, 0);
		Vector(0, 0, 97), Angle(90, 0, 0);

		Vector(21, 31, 46), Angle(0, 90, 0);
		Vector(21, -31, 46), Angle(0, 90, 0);
		Vector(-21, 31, 46), Angle(0, 90, 0);
		Vector(-21, -31, 46), Angle(0, 90, 0);

		Vector(-52, 0, 46), Angle(0, 0, 0);
		Vector(52, 0, 46), Angle(0, 0, 0)
	}

	local remove_jail = function(ply_jail_props)
		for _, jail_prop in ipairs(ply_jail_props) do
			if IsValid(jail_prop) then
				jail_prop:Remove()
			end
		end
	end

	local unjail = function(ply)
		if not IsValid(ply) then return end
		if not ply:sam_get_nwvar("jailed") then return end

		remove_jail(ply.sam_jail_props)

		ply.sam_jail_props = nil
		ply.sam_jail_pos = nil

		ply:sam_set_nwvar("jailed", nil)
		ply:sam_set_exclusive(nil)

		timer.Remove("SAM.Unjail." .. ply:SteamID())
		timer.Remove("SAM.Jail.Watch." .. ply:SteamID())
	end

	local return_false = function()
		return false
	end

	local function jail(ply, time)
		if not IsValid(ply) then return end
		if not isnumber(time) or time < 0 then
			time = 0
		end

		if ply:sam_get_nwvar("frozen") then
			RunConsoleCommand("sam", "unfreeze", "#" .. ply:EntIndex())
		end

		if not ply:sam_get_nwvar("jailed") or (not ply.sam_jail_props or not IsValid(ply.sam_jail_props[1])) then
			ply:ExitVehicle()
			ply:SetMoveType(MOVETYPE_WALK)

			ply.sam_jail_pos = ply:GetPos()

			ply:sam_set_nwvar("jailed", true)
			ply:sam_set_exclusive("in jail")

			if ply.sam_jail_props then
				for k, v in ipairs(ply.sam_jail_props) do
					if IsValid(v) then
						v:Remove()
					end
				end
			end

			local ply_jail_props = {}
			for i = 1, #jail_props, 2 do
				local jail_prop = ents.Create("prop_physics")
				jail_prop:SetModel("models/props_building_details/Storefront_Template001a_Bars.mdl")
				jail_prop:SetPos(ply.sam_jail_pos + jail_props[i])
				jail_prop:SetAngles(jail_props[i + 1])
				jail_prop:SetMoveType(MOVETYPE_NONE)
				jail_prop:Spawn()
				jail_prop:GetPhysicsObject():EnableMotion(false)
				jail_prop.CanTool = return_false
				jail_prop.PhysgunPickup = return_false
				jail_prop.jailWall = true
				table.insert(ply_jail_props, jail_prop)
			end
			ply.sam_jail_props = ply_jail_props
		end

		local steamid = ply:SteamID()

		if time == 0 then
			timer.Remove("SAM.Unjail." .. steamid)
		else
			timer.Create("SAM.Unjail." .. steamid, time, 1, function()
				if IsValid(ply) then
					unjail(ply)
				end
			end)
		end

		timer.Create("SAM.Jail.Watch." .. steamid, 0.5, 0, function()
			if not IsValid(ply) then
				return timer.Remove("SAM.Jail.Watch." .. steamid)
			end

			if ply:GetPos():DistToSqr(ply.sam_jail_pos) > 4900 then
				ply:SetPos(ply.sam_jail_pos)
			end

			if not IsValid(ply.sam_jail_props[1]) then
				jail(ply, timer.TimeLeft("SAM.Unjail." .. steamid) or 0)
			end
		end)
	end

	command.new("jail")
		:SetPermission("jail", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("jail_help")

		:OnExecute(function(ply, targets, length, reason)
			for i = 1, #targets do
				jail(targets[i], length * 60)
			end

			sam.player.send_message(nil, "jail", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("unjail")
		:SetPermission("unjail", "admin")

		:AddArg("player", {optional = true})

		:Help("unjail_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				unjail(targets[i])
			end

			sam.player.send_message(nil, "unjail", {
				A = ply, T = targets
			})
		end)
	:End()

	sam.hook_first("CanProperty", "SAM.Jail", function(_, property, ent)
		if ent.jailWall and property == "remover" then
			return false
		end
	end)

	if SERVER then
		hook.Add("PlayerSpawn", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") or ply:sam_get_pdata("jailed") then
				if ply.sam_jail_pos then
					ply:SetPos(ply.sam_jail_pos)
				else
					ply:SetPos(ply:sam_get_pdata("jail_pos"))
					jail(ply, ply:sam_get_pdata("jail_time_left"))

					ply:sam_set_pdata("jailed", nil)
					ply:sam_set_pdata("jail_pos", nil)
					ply:sam_set_pdata("jail_time_left", nil)
				end
			end
		end)

		hook.Add("PlayerEnteredVehicle", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") then
				ply:ExitVehicle()
			end
		end)

		hook.Add("PlayerDisconnected", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") then
				remove_jail(ply.sam_jail_props)

				ply:sam_set_pdata("jailed", true)
				ply:sam_set_pdata("jail_pos", ply.sam_jail_pos)
				ply:sam_set_pdata("jail_time_left", timer.TimeLeft("SAM.Unjail." .. ply:SteamID()) or 0)

				timer.Remove("SAM.Unjail." .. ply:SteamID())
				timer.Remove("SAM.Jail.Watch." .. ply:SteamID())
			end
		end)
	end

	local disallow = function(ply)
		if ply:sam_get_nwvar("jailed") then
			return false
		end
	end

	for _, v in ipairs({"PlayerNoClip", "SAM.CanPlayerSpawn", "CanPlayerEnterVehicle", "CanPlayerSuicide", "CanTool"}) do
		hook.Add(v, "SAM.Jail", disallow)
	end
end

command.new("strip")
	:SetPermission("strip", "admin")

	:AddArg("player")

	:Help("strip_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:StripWeapons()
		end

		sam.player.send_message(nil, "strip", {
			A = ply, T = targets
		})
	end)
:End()

command.new("respawn")
	:SetPermission("respawn", "admin")

	:AddArg("player", {optional = true})

	:Help("respawn_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:Spawn()
		end

		sam.player.send_message(nil, "respawn", {
			A = ply, T = targets
		})
	end)
:End()

command.new("setmodel")
	:SetPermission("setmodel", "superadmin")

	:AddArg("player")
	:AddArg("text", {hint = "model"})

	:Help("setmodel_help")

	:OnExecute(function(ply, targets, model)
		for i = 1, #targets do
			targets[i]:SetModel(model)
		end

		sam.player.send_message(nil, "setmodel", {
			A = ply, T = targets, V = model
		})
	end)
:End()

command.new("giveammo")
	:Aliases("ammo")

	:SetPermission("giveammo", "superadmin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 0, max = 99999})

	:Help("giveammo_help")

	:OnExecute(function(ply, targets, amount)
		if amount == 0 then
			amount = 99999
		end

		for i = 1, #targets do
			local target = targets[i]
			for _, wep in ipairs(target:GetWeapons()) do
				if wep:GetPrimaryAmmoType() ~= -1 then
					target:GiveAmmo(amount, wep:GetPrimaryAmmoType(), true)
				end

				if wep:GetSecondaryAmmoType() ~= -1 then
					target:GiveAmmo(amount, wep:GetSecondaryAmmoType(), true)
				end
			end
		end

		sam.player.send_message(nil, "giveammo", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

do
	command.new("scale")
		:SetPermission("scale", "superadmin")

		:AddArg("player")
		:AddArg("number", {hint = "amount", optional = true, min = 0, max = 2.5, default = 1})

		:Help("scale_help")

		:OnExecute(function(ply, targets, amount)
			for i = 1, #targets do
				local v = targets[i]
				v:SetModelScale(amount)

				-- https://github.com/carz1175/More-ULX-Commands/blob/9b142ee4247a84f16e2dc2ec71c879ab76e145d4/lua/ulx/modules/sh/extended.lua#L313
				v:SetViewOffset(Vector(0, 0, 64 * amount))
				v:SetViewOffsetDucked(Vector(0, 0, 28 * amount))

				v.sam_scaled = true
			end

			sam.player.send_message(nil, "scale", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	hook.Add("PlayerSpawn", "SAM.Scale", function(ply)
		if ply.sam_scaled then
			ply.sam_scaled = nil
			ply:SetViewOffset(Vector(0, 0, 64))
			ply:SetViewOffsetDucked(Vector(0, 0, 28))
		end
	end)
end

sam.command.new("freezeprops")
	:SetPermission("freezeprops", "admin")
	:Help("freezeprops_help")

	:OnExecute(function(ply)
		for _, prop in ipairs(ents.FindByClass("prop_physics")) do
			local physics_obj = prop:GetPhysicsObject()
			if IsValid(physics_obj) then
				physics_obj:EnableMotion(false)
			end
		end

		sam.player.send_message(nil, "freezeprops", {
			A = ply
		})
	end)
:End()
--PATH addons/[admin] sam-160/lua/sam/modules/ttt.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/cl_adverts.lua:
return gluapack()()
--PATH lua/autorun/savage.lua:
player_manager.AddValidModel( "savage", "models/savage.mdl" )
--PATH addons/[chat] scb-29/lua/autorun/scb.lua:
if SCB_LOADED then return end

local types = {
	sv_ = SERVER and include or function() end,
	cl_ = SERVER and AddCSLuaFile or include,
	sh_ = function(name)
		if SERVER then
			AddCSLuaFile(name)
		end
		return include(name)
	end
}

local load_file = function(name, no, type)
	if not no then
		name = "scb/" .. name
	end

	local func = types[type or name:GetFileFromFilename():sub(1, 3)] or types["sh_"]
	if func then
		return func(name)
	end
end

scb = {
	config = {}
}

function scb.print(...)
	MsgC(
		Color(236, 240, 241), "(",
		Color(65, 185, 255), "SCB",
		Color(236, 240, 241), ") ",
		Color(236, 240, 241), ...
	) Msg("\n")
end

scb.print("Loading...")

	file.CreateDir("scb")

	require("sui")
	if CLIENT then
		scb.SUI = sui.new("SCB")
	end

	load_file("libs/sh_types.lua")
	scb.mp = load_file("libs/message_pack/sh_messagepack.lua")

	load_file("sh_scb_config.lua", true)

	for _, permissions in pairs(scb.config.permissions) do
		for k, v in ipairs(permissions) do
			if v ~= true then
				permissions[v], permissions[k] = true, nil
			end
		end
	end

	if SERVER then
		for _, f in ipairs(file.Find("scb/settings/tabs/*.lua", "LUA")) do
			AddCSLuaFile("scb/settings/tabs/" .. f)
		end
	end

	load_file("cl_util.lua")
	load_file("settings/cl_settings.lua")
	load_file("sh_chatbox.lua")
	load_file("sv_chatbox.lua")
	load_file("cl_chatbox.lua")
	load_file("cl_overrides.lua")

	if SERVER then
		AddCSLuaFile("scb/cl_emojis_data.lua", "GAME")

		-- emojis need to be loaded once the player joins, so things like this https://www.gmodstore.com/market/view/4868 could break it
		local AddWorkshop = resource.OldAddWorkshop or resource.AddWorkshop
		AddWorkshop("1998633255")
	end

	for _, f in ipairs(file.Find("scb/vgui/*.lua", "LUA")) do
		load_file("vgui/" .. f, false, "cl_")
	end

scb.print("Loaded!")

SCB_LOADED = true

--PATH addons/[lib] sui/lua/sui/vgui/sui_combobox.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TEXT_FONT = SUI.CreateFont("ComboBox", "Roboto Regular", 16)

local GetColor = SUI.GetColor
local draw_material = sui.draw_material

local PANEL = {}

PANEL.NoOverrideClear = true

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
	self.DropButton:Remove()
	self:SetFont(TEXT_FONT)
	self:SetSize(34, 22)
	self:SetIsMenu(true)

	local image = self:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")
	image.Draw = self.Paint
end

function PANEL:OpenMenu(pControlOpener)
	if pControlOpener and pControlOpener == self.TextEntry then return end
	if #self.Choices == 0 then return end

	if IsValid(self.Menu) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create(NAME .. ".Menu", self)
	self.Menu:SetInternal(self)

	for k, v in ipairs(self.Choices) do
		self.Menu:AddOption(v, function()
			self:ChooseOption(v, k)
		end)
	end

	local x, y = self:LocalToScreen(0, self:GetTall())
	self.Menu:SetMinimumWidth(self:GetWide())
	self.Menu:Open(x, y, false, self)
end

function PANEL:Paint(w, h, from_image)
	local text_color = GetColor("menu_option_hover_text")

	if from_image then
		local size = SUI.ScaleEven(10)
		draw_material(nil, w - (size / 2) - 6, h / 2, size, text_color)
	else
		local col = GetColor("menu")
		self:RoundedBox("Background", 4, 0, 0, w, h, col)
		self:SetTextColor(text_color)
	end
end

function PANEL:PerformLayout()
end

sui.register("ComboBox", PANEL, "DComboBox")
--PATH addons/[lib] sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() / 2 - new_w / 2), self.y + (self:GetTall() / 2 - new_h / 2)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--PATH addons/[lib] sui/lua/sui/vgui/sui_label_panel.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_number_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local NUMBER_SLIDER_FONT = SUI.CreateFont("NumberSlider", "Roboto Regular", 14)

local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()

	local slider = vgui.Create(NAME .. ".Slider", self, "NumberSlider")
	slider:Dock(FILL)

	self.slider = slider

	local label = self:Add(NAME .. ".Label")
	label:Dock(RIGHT)
	label:DockMargin(3, 0, 0, 0)
	label:SetFont(NUMBER_SLIDER_FONT)
	self.label = label

	function label:Think()
		self:SetText(slider:GetValue())

		self:SizeToContents()
	end

	self:SetSize(100, 12)
	self:InvalidateLayout(true)
end

sui.register("NumberSlider", PANEL, "Panel")

--PATH addons/[lib] sui/lua/sui/vgui/sui_scroll_panel.lua:
local math = math
local table = table

local pairs = pairs

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local RoundedBox = sui.TDLib.LibClasses.RoundedBox

local Panel = {}

AccessorFunc(Panel, "m_bFromBottom", "FromBottom", FORCE_BOOL)
AccessorFunc(Panel, "m_bVBarPadding", "VBarPadding", FORCE_NUMBER)

Panel:SetVBarPadding(0)

Panel.NoOverrideClear = true

-- VBar
local starting_scroll_speed = 3

local vbar_OnMouseWheeled = function(s, delta)
	s.scroll_speed = s.scroll_speed + 20 * 0.012 --[[ slowly increase scroll speed ]]
	s:AddScroll(delta * -s.scroll_speed)
end

-- default set scroll clamps amount
local vbar_SetScroll = function(s, amount)
	if not s.Enabled then s.Scroll = 0 return end

	s.scroll_target = amount
	s:InvalidateLayout()
end

-- ¯\_(ツ)_/¯ https://github.com/Facepunch/garrysmod/blob/cd3d894288b847e3d081570129963d4089e36261/garrysmod/lua/vgui/dvscrollbar.lua#L234
local vbar_OnCursorMoved = function(s, _, y)
	if s.Dragging then
		y = y - s.HoldPos
		y = y / (s:GetTall() - s:GetWide() * 2 - s.btnGrip:GetTall())
		s.scroll_target = y * s.CanvasSize
	end
end

local vbar_Think = function(s)
	local frame_time = RealFrameTime() * 17
	local scroll_target = s.scroll_target

	s.Scroll = Lerp(frame_time, s.Scroll, scroll_target)

	if not s.Dragging then
		s.scroll_target = Lerp(frame_time, scroll_target, math.Clamp(scroll_target, 0, s.CanvasSize))
	end

	-- now start slowing it down!!!
	s.scroll_speed = Lerp(frame_time / 10, s.scroll_speed, starting_scroll_speed)
end

local vbar_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll"))
end

local vbarGrip_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll_grip"))
end

local vbar_PerformLayout = function(s, w, h)
	local scroll = s:GetScroll() / s.CanvasSize
	local bar_size = math.max(s:BarScale() * h, 10)

	local track = (h - bar_size) + 1
	scroll = scroll * track

	s.btnGrip.y = scroll
	s.btnGrip:SetSize(w, bar_size)
end
--

function Panel:Init()
	local canvas = self:GetCanvas()
	canvas:SUI_TDLib()

	local children = {}
	function canvas:OnChildAdded(child)
		table.insert(children, child)
	end
	function canvas:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	canvas.GetChildren = function()
		return children
	end
	canvas.children = children

	local vbar = self.VBar
	vbar:SetHideButtons(true)
	vbar.btnUp:SetVisible(false)
	vbar.btnDown:SetVisible(false)

	vbar.vertices = {}
	vbar.scroll_target = 0
	vbar.scroll_speed = starting_scroll_speed

	vbar.OnMouseWheeled = vbar_OnMouseWheeled
	vbar.SetScroll = vbar_SetScroll
	vbar.OnCursorMoved = vbar_OnCursorMoved
	vbar.Think = vbar_Think
	vbar.Paint = vbar_Paint
	vbar.PerformLayout = vbar_PerformLayout

	vbar.btnGrip.vertices = {}
	vbar.btnGrip.Paint = vbarGrip_Paint

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:OnChildAdded(child)
	self:AddItem(child)
	self:ChildAdded(child)
end

function Panel:ChildAdded()
end

function Panel:ScaleChanged()
	local w = SUI.Scale(4)

	self.VBar:SetWide(w)
	self.VBar.btnDown:SetSize(w, 0)
	self.VBar.btnUp:SetSize(w, 0)
end

function Panel:Paint(w, h)
	local outline = SUI.GetColor("scroll_panel_outline")
	if outline then
		TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
	else
		RoundedBox(self, "Background", 3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
	end
end

function Panel:ScrollToBottom()
	local vbar = self.VBar
	for k, anim in pairs(vbar.m_AnimList or {}) do
		anim:Think(vbar, 1)
		vbar.m_AnimList[k] = nil
	end

	self:InvalidateParent(true)
	self:InvalidateChildren(true)

	vbar:SetScroll(vbar.CanvasSize)
end

function Panel:PerformLayoutInternal(w, h)
	w = w or self:GetWide()
	h = h or self:GetTall()

	local canvas = self.pnlCanvas

	self:Rebuild()

	local vbar = self.VBar
	vbar:SetUp(h, canvas:GetTall())

	if vbar.Enabled then
		w = w - vbar:GetWide() - self.m_bVBarPadding
	end

	canvas:SetWide(w)

	self:Rebuild()
end

function Panel:Think()
	local canvas = self.pnlCanvas

	local vbar = self.VBar
	if vbar.Enabled then
		canvas.y = -vbar.Scroll
	else
		if self:GetFromBottom() then
			canvas._y = Lerp(10 * RealFrameTime(), canvas._y or canvas.y, self:GetTall() - canvas:GetTall())
		else
			canvas._y = Lerp(10 * RealFrameTime(), canvas._y or canvas.y, -vbar.Scroll)
		end
		canvas.y = canvas._y
	end
end

sui.register("ScrollPanel", Panel, "DScrollPanel")

--PATH addons/[lib] sui/lua/sui/vgui/sui_text_entry.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
local IsValid = IsValid

local TDLib_Classes = sui.TDLib.LibClasses
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local Panel = {}

function Panel:Init()
	self.tabs = {}

	local tab_scroller = self:Add(NAME .. ".ScrollPanel")
	tab_scroller:Dock(LEFT)

	function tab_scroller:Paint(w, h)
		self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet_bar"))
	end

	self.tabs_wide = 48
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:ScaleChanged()
	local tabs_wide = SUI.Scale(self.tabs_wide)
	self.tab_scroller:SetWide(tabs_wide)

	self:InvalidateLayout(true)

	local tabs = self.tabs
	for i = 1, #self.tabs do
		tabs[i].img:SetMinus(SUI.Scale(20))
	end
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet"))
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local tab_Paint = function(s, w, h)
	local cur_col
	if s.active then
		cur_col = GetColor("column_sheet_tab_active")
	elseif s.Hovered then
		cur_col = GetColor("column_sheet_tab_hover")
	else
		cur_col = GetColor("column_sheet_tab")
	end

	s:RoundedBox("Backgrounds", 0, 0, 0, w, h, cur_col)
end

local tab_OnRemove = function(s)
	table.RemoveByValue(s.parent.tabs, s)
end

function Panel:AddSheet(mat, load_func)
	local tab = self.tab_scroller:Add(NAME .. ".Button")
	tab:Dock(TOP)
	tab:SetText("")
	tab:SetTall(self.tabs_wide)

	tab.On = TDLib_Classes.On

	tab.DoClick = tab_DoClick
	tab.Paint = tab_Paint
	tab:On("OnRemove", tab_OnRemove)

	tab.parent = self
	tab.load_func = load_func

	local img = tab:Add(NAME .. ".Image")
	img:Dock(FILL)
	img:SetImage(mat)
	img:SetMinus(SUI.Scale(20))

	tab.img = img

	self.tab_scroller:AddItem(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function Panel:GetActiveTab()
	return self.active_tab
end

function Panel:SetActiveTab(new_tab)
	if new_tab == self.active_tab then return end

	if not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)
		panel:SetAlpha(0)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	local old_active_tab = self.active_tab
	local delay = 0
	if old_active_tab and IsValid(old_active_tab.panel) then
		old_active_tab.active = false
		delay = 0.2
		old_active_tab.panel:AlphaTo(0, delay, 0, function(_, p)
			if p:IsValid() then
				p:SetVisible(false)
			end
		end)
	end

	new_tab.active = true
	new_tab.panel:SetVisible(true)
	new_tab.panel:AlphaTo(255, 0.2, delay)
	self.active_tab = new_tab
end

sui.register("ColumnSheet", Panel, "EditablePanel")
--PATH addons/[lib] sui/lua/sui/vgui/sui_zmenu.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/settings/tabs/client.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/sh_chatbox.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/vgui/scb_chat_line.lua:
return gluapack()()
--PATH lua/autorun/sck_bone_fix.lua:
return gluapack()()
--PATH lua/autorun/serv_statuseffects.lua:
return gluapack()()
--PATH lua/arc9/common/localization/content_base_en.lua:
L = {}

//////// Folders
L["folder.arc9"] = "ARC9"
L["folder.arc9.community"] = "Community"

L["attachment.sticker"] = "Sticker"

//////// Flat Camo
L["camo_arc9_base_flat_od.printname"] = "Olive Drab"
L["camo_arc9_base_flat_od.compactname"] = "OD"
L["camo_arc9_base_flat_od.description"] = "Standard Olive Drab camouflage."

L["camo_arc9_base_flat_deserttan.printname"] = "Desert Tan"
L["camo_arc9_base_flat_deserttan.compactname"] = "Tan"
L["camo_arc9_base_flat_deserttan.description"] = "Standard Desert Tan camouflage."

L["camo_arc9_base_flat_arctic.printname"] = "Arctic White"
L["camo_arc9_base_flat_arctic.compactname"] = "Arctic"
L["camo_arc9_base_flat_arctic.description"] = "Standard Arctic White camouflage."

L["camo_arc9_base_flat_black.printname"] = "Factory Black"
L["camo_arc9_base_flat_black.compactname"] = "Black"
L["camo_arc9_base_flat_black.description"] = "Standard Factory Issue Black."

L["camo_arc9_base_flat_urbangray.printname"] = "Urban Gray"
L["camo_arc9_base_flat_urbangray.compactname"] = "Urban"
L["camo_arc9_base_flat_urbangray.description"] = "Standard Urban Gray camouflage."

L["camo_arc9_base_flat_forestgreen.printname"] = "Forest Green"
L["camo_arc9_base_flat_forestgreen.compactname"] = "Forest"
L["camo_arc9_base_flat_forestgreen.description"] = "Standard Forest Green camouflage."

L["camo_arc9_base_flat_navy.printname"] = "Navy Blue"
L["camo_arc9_base_flat_navy.compactname"] = "Navy"
L["camo_arc9_base_flat_navy.description"] = "Standard Navy Blue color."

L["camo_arc9_base_flat_mountbattenpink.printname"] = "Mountbatten Pink"
L["camo_arc9_base_flat_mountbattenpink.compactname"] = "MP"
L["camo_arc9_base_flat_mountbattenpink.description"] = "Standard Mountbatten Pink camouflage.\nShockingly effective in desert conditions."

L["camo_arc9_base_flat_fde.printname"] = "Flat Dark Earth"
L["camo_arc9_base_flat_fde.compactname"] = "FDE"
L["camo_arc9_base_flat_fde.description"] = "Standard Flat Dark Earth camouflage."

//////// Flat Colour
L["camo_arc9_base_flat_red.printname"] = "Red"
L["camo_arc9_base_flat_red.compactname"] = "Red"
L["camo_arc9_base_flat_red.description"] = "Basic red color."

L["camo_arc9_base_flat_orange.printname"] = "Orange"
L["camo_arc9_base_flat_orange.compactname"] = "Orange"
L["camo_arc9_base_flat_orange.description"] = "Basic orange color."

L["camo_arc9_base_flat_yellow.printname"] = "Yellow"
L["camo_arc9_base_flat_yellow.compactname"] = "Yellow"
L["camo_arc9_base_flat_yellow.description"] = "Basic yellow color."

L["camo_arc9_base_flat_green.printname"] = "Green"
L["camo_arc9_base_flat_green.compactname"] = "Green"
L["camo_arc9_base_flat_green.description"] = "Basic green color."

L["camo_arc9_base_flat_blue.printname"] = "Blue"
L["camo_arc9_base_flat_blue.compactname"] = "Blue"
L["camo_arc9_base_flat_blue.description"] = "Basic blue color."

L["camo_arc9_base_flat_purple.printname"] = "Purple"
L["camo_arc9_base_flat_purple.compactname"] = "Purple"
L["camo_arc9_base_flat_purple.description"] = "Basic purple color."

L["camo_arc9_base_flat_pink.printname"] = "Pink"
L["camo_arc9_base_flat_pink.compactname"] = "Pink"
L["camo_arc9_base_flat_pink.description"] = "Eye searingly bright pink color."

L["camo_arc9_base_flat_arc9orange.printname"] = "ARC9 Orange"
L["camo_arc9_base_flat_arc9orange.compactname"] = "ARC9 Orange"
L["camo_arc9_base_flat_arc9orange.description"] = "The perfect shade of orange for that cute little ARC9 Logo sticker."

//////// Charms
L["charm_gs_killcounter.printname"] = "Kill Counter"
L["charm_gs_killcounter.compactname"] = "KILL"
L["charm_gs_killcounter.description"] = "Device for tracking your weapon's kill stats."

L["charm_gs_clock.printname"] = "Basic Clock"
L["charm_gs_clock.compactname"] = "CLOCK"
L["charm_gs_clock.description"] = "Device that displays the real-world time."

L["charm_gs_sticker.printname"] = "Sticker Panel"
L["charm_gs_sticker.compactname"] = "STICKER"
L["charm_gs_sticker.description"] = "Device that allows a custom sticker to be applied onto its screen."

//////// Stickers, Base
L["sticker_spray.printname"] = "Player Spray"
L["sticker_spray.compactname"] = "Spray"
L["sticker_spray.description"] = [[Your own spray as a sticker!
You will only be able to see your own and not ones from other players.

Sticker included in the ARC9 Base.]]

L["sticker_arc9.printname"] = "ARC9 Logo (Low Vis.)"
L["sticker_arc9.compactname"] = "ARC9"
L["sticker_arc9.description"] = [[Dark version of the ARC9 logo.
Design by The Villain.

Sticker included in the ARC9 Base.]]

L["sticker_arc9_lowvis.printname"] = "ARC9 Logo"
L["sticker_arc9_lowvis.compactname"] = "ARC9"
L["sticker_arc9_lowvis.description"] = [[Here's to you.
Design by The Villain.

Sticker included in the ARC9 Base.]]

L["sticker_a9k.printname"] = "ARCTICTHRON 9.000 WEAPON BASE"
L["sticker_a9k.compactname"] = "A9K"
L["sticker_a9k.description"] = [[this is what "arc9" actually means

Sticker included in the ARC9 Base.]]

L["sticker_a9cylo.printname"] = "ARC9 Concept logo by CyloWalker"
L["sticker_a9cylo.compactname"] = "A9 Cylo"
L["sticker_a9cylo.description"] = [[One of the first concepts for ARC9 logo/icon by CyloWalker (he's cool!)

Sticker included in the ARC9 Base.]]

L["sticker_sus9.printname"] = "Sus 9"
L["sticker_sus9.compactname"] = "Sus 9"
L["sticker_sus9.description"] = [[The impostor could be anywhere among us...
Design by Darsu.

Sticker included in the ARC9 Base.]]

//////// Stickers, Com. Wave 1
L["sticker_alien_lean.printname"] = "Legalize Alien Lean"
L["sticker_alien_lean.compactname"] = "Alien Lean"
L["sticker_alien_lean.description"] = [[Hop down to Agartha with the white boys for a cup of alien lean and... other things.
Design by Opt1ca.

Sticker included in the ARC9 Base.]]

L["sticker_tomatocat.printname"] = "Tomato Cat"
L["sticker_tomatocat.compactname"] = "Tomato Cat"
L["sticker_tomatocat.description"] = [[Sometimes people ask whether tomatoes are fruits or vegetables... This one might be a tougher question.
Design by Ender2Point0.

Sticker included in the ARC9 Base.]]

L["sticker_actionbird.printname"] = "Action Bird"
L["sticker_actionbird.compactname"] = "Action Bird"
L["sticker_actionbird.description"] = [[This is what Arctic looks like in real life.
Design by CyloWalker.

Sticker included in the ARC9 Base.]]

L["sticker_warcrimes.printname"] = "War Crimes"
L["sticker_warcrimes.compactname"] = "War Crimes"
L["sticker_warcrimes.description"] = [[You're already doing them, so why not shout it out loud? Who's gonna stop you, the UN?
Design by Rimuchii. Made using Project Sekai sticker base.

Sticker included in the ARC9 Base.]]

L["sticker_sillycat.printname"] = "Silly Cat"
L["sticker_sillycat.compactname"] = "Silly Cat"
L["sticker_sillycat.description"] = [[imsillyimsillyimsillyimsillyimsillyimsillyimsillyimsilly
Design by Stan_Jacobs.

Sticker included in the ARC9 Base.]]

L["sticker_muertosskull.printname"] = "Dia De Los Muertos Calavera"
L["sticker_muertosskull.compactname"] = "Los Muertos"
L["sticker_muertosskull.description"] = [["this should be my final version i think, unless anyone gives me suggestions to change it, the name: "Dia de los muertos calavera" the description: i cant think of one, something about day of the dead skull mexico blah blah blah"
Design by rooneyviz.

Sticker included in the ARC9 Base.]]

L["sticker_bandaid.printname"] = "Band-Aid"
L["sticker_bandaid.compactname"] = "Band-Aid"
L["sticker_bandaid.description"] = [[Put it on your boo-boo and kiss it all better.
Design by Itzal.

Sticker included in the ARC9 Base.]]

L["sticker_peacedove.printname"] = "Peace Through Superior Firepower"
L["sticker_peacedove.compactname"] = "PTSF"
L["sticker_peacedove.description"] = [[The dove brings peace, but the gun brings peace through superior firepower.
Design by Xipil.

Sticker included in the ARC9 Base.]]

L["sticker_borntomodify.printname"] = "Born To Modify"
L["sticker_borntomodify.compactname"] = "BTM"
L["sticker_borntomodify.description"] = [[Another sight - another scope - a grenade launcher, here and there...
Design by Duck.

Sticker included in the ARC9 Base.]]

L["sticker_cad.printname"] = "cad"
L["sticker_cad.compactname"] = "cad"
L["sticker_cad.description"] = [[cad
Design by Opt1ca.

Sticker included in the ARC9 Base.]]

L["sticker_fumo.printname"] = "Fumo"
L["sticker_fumo.compactname"] = "Fumo"
L["sticker_fumo.description"] = [[D-don't look at me like that, raifu-kun...
Design by Itzal.

Sticker included in the ARC9 Base.]]

L["sticker_hotlead.printname"] = "Hot Lead"
L["sticker_hotlead.compactname"] = "Hot Lead"
L["sticker_hotlead.description"] = [[Careful! It's hot!
Design by Arqu.

Sticker included in the ARC9 Base.]]

L["sticker_steamhappy.printname"] = ":steamhappy:"
L["sticker_steamhappy.compactname"] = ":steamhappy:"
L["sticker_steamhappy.description"] = [[Happy about it
Design from Steam.

Sticker included in the ARC9 Base.]]

L["sticker_amidstus.printname"] = "Amidstus"
L["sticker_amidstus.compactname"] = "Amidstus"
L["sticker_amidstus.description"] = [[Why settle for the original when you could have a cheap knockoff?!
Design from Optica.

Sticker included in the ARC9 Base.]]

L["sticker_arcglory.printname"] = "Glory!"
L["sticker_arcglory.compactname"] = "Glory!"
L["sticker_arcglory.description"] = [[Took nine brain cells to scribble this
Design from Optica.

Sticker included in the ARC9 Base.]]

L["sticker_wp.printname"] = "World Peace!"
L["sticker_wp.compactname"] = "World Peace!"
L["sticker_wp.description"] = [[A delusion!
Design from Fidget.

Sticker included in the ARC9 Base.]]

L["sticker_tonkr.printname"] = "Send It"
L["sticker_tonkr.compactname"] = "Send It"
L["sticker_tonkr.description"] = [[Yeah, it's that heavy. Yeah, it's that powerful.
Design from CyloWalker.

Sticker included in the ARC9 Base.]]

L["sticker_s6amblem.printname"] = "Section 6"
L["sticker_s6amblem.compactname"] = "Section 6"
L["sticker_s6amblem.description"] = [[Reach for the stars. Forward to Glory!
Design from CyloWalker.

Sticker included in the ARC9 Base.]]

L["sticker_babies.printname"] = "Baby Hazard"
L["sticker_babies.compactname"] = "Baby Hazard"
L["sticker_babies.description"] = [[Children ages 0-3 should be kept away from this.. firearm.
Design from Itzal.

Sticker included in the ARC9 Base.]]

L["sticker_drawberf.printname"] = "Berf"
L["sticker_drawberf.compactname"] = "Berf"
L["sticker_drawberf.description"] = [[Draw Berf.
Design by The Villain.

Sticker included in the ARC9 Base.]]

L["sticker_arcbird.printname"] = "Arc Bird"
L["sticker_arcbird.compactname"] = "Arc Bird"
L["sticker_arcbird.description"] = [[Arc Bird.
Design by Nori/Chewable.

Sticker included in the ARC9 Base.]]

--PATH lua/arc9/common/localization/font_en.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_ru.lua:
return gluapack()()
--PATH lua/arc9/common/attachments_bulk/camos_base_flat_camo.lua:
local ATT = {}

ATT.PrintName = "Olive Drab"
ATT.CompactName = "OD"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_od.png")
ATT.Category = "universal_camo"
ATT.Description = [[Standard Olive Drab camouflage.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_od"
ATT.CustomCamoScale = 1
ATT.SortOrder = 4
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_od")

ATT = {}

ATT.PrintName = "Desert Tan"
ATT.CompactName = "Tan"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_deserttan.png")
ATT.Category = "universal_camo"
ATT.Description = [[Standard Desert Tan camouflage.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_deserttan"
ATT.CustomCamoScale = 1
ATT.SortOrder = 3
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_deserttan")

ATT = {}

ATT.PrintName = "Arctic White"
ATT.CompactName = "Arctic"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_arctic.png")
ATT.Category = "universal_camo"
ATT.Description = [[Standard Arctic White camouflage.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_arctic"
ATT.CustomCamoScale = 1
ATT.SortOrder = 7
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_arctic")

ATT = {}

ATT.PrintName = "Factory Black"
ATT.CompactName = "Black"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_black.png")
ATT.Category = "universal_camo"
ATT.Description = [[Standard Factory Issue Black.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_black"
ATT.CustomCamoScale = 1
ATT.SortOrder = 1
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_black")

ATT = {}

ATT.PrintName = "Urban Gray"
ATT.CompactName = "Urban"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_urbangray.png")
ATT.Category = "universal_camo"
ATT.Description = [[Standard Urban Gray camouflage.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_urbangray"
ATT.CustomCamoScale = 1
ATT.SortOrder = 6
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_urbangray")

ATT = {}

ATT.PrintName = "Forest Green"
ATT.CompactName = "Forest"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_forestgreen.png")
ATT.Category = "universal_camo"
ATT.Description = [[Standard Forest Green camouflage.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_forestgreen"
ATT.CustomCamoScale = 1
ATT.SortOrder = 5
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_forestgreen")

ATT = {}

ATT.PrintName = "Navy Blue"
ATT.CompactName = "Navy"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_navy.png")
ATT.Category = "universal_camo"
ATT.Description = [[Standard Navy Blue color.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_navy"
ATT.CustomCamoScale = 1
ATT.SortOrder = 8
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_navy")

ATT = {}

ATT.PrintName = "Mountbatten Pink"
ATT.CompactName = "Pink"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_mountbattenpink.png")
ATT.Category = "universal_camo"
ATT.Description = [[Standard Mountbatten Pink camouflage. Shockingly effective in desert conditions.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_mountbattenpink"
ATT.CustomCamoScale = 1
ATT.SortOrder = 9
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_mountbattenpink")

ATT = {}

ATT.PrintName = "Flat Dark Earth"
ATT.CompactName = "FDE"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_fde.png")
ATT.Category = "universal_camo"
ATT.Description = [[Standard Flat Dark Earth camouflage.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_fde"
ATT.CustomCamoScale = 1
ATT.SortOrder = 2
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_fde")
--PATH lua/arc9/shared/sh_effects.lua:
return gluapack()()
--PATH lua/arc9/client/cl_favorites.lua:
return gluapack()()
--PATH lua/arc9/client/cl_killicons.lua:
ARC9OLDKilliconDraw = ARC9OLDKilliconDraw or killicon.Render or killicon.Draw
local killicons_cachednames = {}
local killicons_cachedicons = {}
local killicons_cachedtimes = {}
local killiconmat = Material("arc9/arc9_logo.png", "mips smooth")

local arc9_killfeed_enable = GetConVar("arc9_killfeed_enable")
local arc9_killfeed_dynamic = GetConVar("arc9_killfeed_dynamic")
ARC9NEWKillicondraw = function(x, y, name, alpha)
    if !arc9_killfeed_enable:GetBool() then
        return ARC9OLDKilliconDraw(x, y, name, alpha)
    end

    local wpn = weapons.Get(name)

    if wpn and wpn.ARC9 and wpn.NoDynamicKillIcon then
        return ARC9OLDKilliconDraw(x, y, name, alpha)
    end

    if killicons_cachednames[name] == true then
        local w, h = 96, 96
        x = x - (killicon.Render and 25 or 48) -- killiocn render is only on x64 and they changed offsets or something
        y = y - (killicon.Render and 25 or 34)

        cam.Start2D()

        local selecticon = killicons_cachedicons[name]

        if arc9_killfeed_dynamic:GetBool() and (!killicons_cachedtimes[name] or (killicons_cachedtimes[name] and killicons_cachedtimes[name] < CurTime())) then -- dynamic
            killicons_cachedtimes[name] = CurTime() + 5
            killicons_cachedicons[name] = nil
            -- print("RESET")
        end

        if !selecticon then -- not cached
            local filename = ARC9.PresetPath .. name .. "_icon." .. ARC9.PresetIconFormat
            -- local loadedmat = Material("data/" .. filename, "smooth")
            local loadedmat

            -- if !loadedmat or loadedmat:IsError() then -- there is no fucking icon in data folder!!!!
                local found

                if game.SinglePlayer() then -- trying find in your hands
                    local probablythegun = LocalPlayer():GetActiveWeapon()

                    if IsValid(probablythegun) and probablythegun:GetClass() == name then
                        loadedmat = probablythegun:DoIconCapture()
                        found = true
                    end
                end

                if !found then -- nah, bruteforcing all ents until we find gun with same classname
                    for _, v in ipairs(ents.GetAll()) do
                        if v:GetClass() == name then
                            loadedmat = v:DoIconCapture()
                        end
                    end
                end
            -- end

            loadedmat = Material("data/" .. filename, "smooth")

            killicons_cachedicons[name] = loadedmat
            selecticon = loadedmat
        end

        surface.SetDrawColor(255, 255, 255, alpha)
        surface.SetMaterial(selecticon or killiconmat)
        surface.DrawTexturedRectUV( x, y, w, h, 1, 0, 0, 1 ) -- fliping
        cam.End2D()
    else
        if killicons_cachednames[name] == nil then -- not cached yet, checking for arc9
            killicons_cachednames[name] = (weapons.Get(name) and weapons.Get(name).ARC9) or false -- weapons.get() will return nil for any hl2 base gun
        else -- we know it is totally not arc9 gun
            return ARC9OLDKilliconDraw(x, y, name, alpha)
        end
    end
end

timer.Simple(5, function() -- to make Autoicons addon not override our stuff
    killicon.Render = ARC9NEWKillicondraw
    killicon.Draw = ARC9NEWKillicondraw
end)
--PATH lua/arc9/client/cl_singleplayer.lua:
return gluapack()()
--PATH lua/arc9/client/cl_subcategories.lua:
return gluapack()()
--PATH lua/arc9/client/zzz_cl_lualoadcheck.lua:
ARC9.AllLuaFilesLoaded = true
--PATH addons/[misc] szachy/lua/autorun/sh_chess.lua:
return gluapack()()
--PATH addons/[misc] szachy/lua/autorun/sh_chess.lua:

if SERVER then
	AddCSLuaFile()
	AddCSLuaFile( "chess/sh_player_ext.lua" )
	AddCSLuaFile( "chess/cl_top.lua" )
	AddCSLuaFile( "chess/cl_dermaboard.lua" )
	
	include( "chess/sh_player_ext.lua" )
	include( "chess/sv_sql.lua" )
else
	include( "chess/sh_player_ext.lua" )
	include( "chess/cl_top.lua" )
	include( "chess/cl_dermaboard.lua" )
end

if SERVER then
	function ChessBoard_DoOverrides()
		if GAMEMODE.Name=="Cinema" then --Cinema overrides
			hook.Add("CanPlayerEnterVehicle", "EnterSeat", function(ply, vehicle) --Overrides default func
				if vehicle:GetClass() != "prop_vehicle_prisoner_pod" then return end

				if vehicle.Removing then return false end
				return (vehicle:GetOwner() == ply) or vehicle:GetNWBool( "IsChessSeat", false )
			end)
		end
	end
	hook.Add( "Initialize", "ChessBoardOverrides", ChessBoard_DoOverrides )
	
	CreateConVar( "chess_wagers", 1, FCVAR_ARCHIVE, "Set whether players can wager on their chess games." )
	CreateConVar( "chess_darkrp_wager", 1, FCVAR_ARCHIVE, "[DarkRP only] Wagers should use DarkRP wallet." )
	
	CreateConVar( "chess_debug", 0, FCVAR_ARCHIVE, "Debug mode." )
	CreateConVar( "chess_limitmoves", 1, FCVAR_ARCHIVE, "Enable 50 move rule." )
else -- CLIENT
	CreateConVar( "chess_gridletters", 1, FCVAR_ARCHIVE, "Show grid letters." )
end

-- DarkRP --
------------
hook.Add("canArrest", "Chess PreventArrest", function( cop, target )
	if not (IsValid(target) and target:GetNWBool("IsInChess", false)) then return end
	
	local board = target:GetNWEntity( "ActiveChessBoard", nil )
	if not (IsValid(board) and board:GetPlaying()) then return end
	if target~=board:GetWhitePlayer() and target~=board:GetBlackPlayer() then return end
	
	return false,"Cannot arrest players during a game in progress" -- Prevent arrest during Chess
end)

-- Admin Commands --
--------------------
local function SetupCommands()
	if serverguard then
		/////////////////
		// Serverguard //
		/////////////////
		serverguard.permission:Add("Set Chess Elo")
		
		if SERVER then
			// Update function
			local function SGUpdate(player, target, newElo, isDraughts)
				if type(target)=="Player" and IsValid(target) then
					if isDraughts then
						target:SetDraughtsElo( newElo )
					else
						target:SetChessElo( newElo )
					end
					Chess_UpdateElo( target )
					
					serverguard.Notify(nil,
					  SERVERGUARD.NOTIFY.GREEN, serverguard.player:GetName(player), 
					  SERVERGUARD.NOTIFY.WHITE, isDraughts and " has set the Checkers Elo rating of " or " has set the Chess Elo rating of ",
					  SERVERGUARD.NOTIFY.RED,   serverguard.player:GetName(target),
					  SERVERGUARD.NOTIFY.WHITE, " to ",
					  SERVERGUARD.NOTIFY.RED,   tostring(newElo),
					  SERVERGUARD.NOTIFY.WHITE, "."
					)
				elseif (string.SteamID(target)) then
					local success,reason = Chess_SetElo( target, newElo, isDraughts )
					
					local queryObj = serverguard.mysql:Select("serverguard_users");
					queryObj:Where("steam_id", target)
					queryObj:Limit(1)
					queryObj:Callback(function(result, status, lastID)
						local name = target
						if (type(result) == "table" and #result > 0) then
							name = result[1].name or name
						end
						
						if success then
							serverguard.Notify(nil,
							  SERVERGUARD.NOTIFY.GREEN, serverguard.player:GetName(player), 
							  SERVERGUARD.NOTIFY.WHITE, isDraughts and " has set the Checkers Elo rating of " or " has set the Chess Elo rating of ",
							  SERVERGUARD.NOTIFY.RED,   name,
							  SERVERGUARD.NOTIFY.WHITE, " to ",
							  SERVERGUARD.NOTIFY.RED,   tostring(newElo),
							  SERVERGUARD.NOTIFY.WHITE, "."
							)
						else
							serverguard.Notify(player, SERVERGUARD.NOTIFY.RED, ("Could not set elo. (%s)"):format(tostring(reason)) )
						end
					end)
					queryObj:Execute()
				else
					serverguard.Notify(player, SGPF("cant_find_player_with_identifier"))
				end
			end
			
			// Chess command
			local command = {}
			
			command.help        = "Set a player's Chess Elo rating."
			command.command     = "setelo"
			command.arguments   = {"player", "elo"}
			command.permissions = {"Set Chess Elo"}
			command.aliases     = {"setelochess", "chesselo", "setchess", "setchesselo"}
			
			function command:Execute(player, silent, arguments)
				local target = util.FindPlayer(arguments[1], player, true)
				local newElo = tonumber(arguments[2]) or 1400
				
				SGUpdate( player, IsValid(target) and target or arguments[1], newElo, false )
			end
			serverguard.command:Add(command)
			
			// Draughts command
			local command = {}
			
			command.help        = "Set a player's Checkers Elo rating."
			command.command     = "setelocheckers"
			command.arguments   = {"player", "elo"}
			command.permissions = {"Set Chess Elo"}
			command.aliases     = {"setcheckers", "setcheckerselo", "checkerselo", "setelodraughts", "setdraughts", "setdraughtselo", "draughtselo"}
			
			function command:Execute(player, silent, arguments)
				local target = util.FindPlayer(arguments[1], player, true)
				local newElo = tonumber(arguments[2]) or 1400
				
				SGUpdate( player, IsValid(target) and target or arguments[1], newElo, true )
			end
			
			serverguard.command:Add(command)
		end
	end
	if ulx then
		/////////
		// ULX //
		/////////
		
		// Update
		local function ULXUpdate(calling_ply, target, newElo, isDraughts)
			if CLIENT then return end
			
			if type(target)=="Player" and IsValid(target) then
				if isDraughts then
					target:SetDraughtsElo( newElo )
				else
					target:SetChessElo( newElo )
				end
				Chess_UpdateElo( target )
				
				ulx.fancyLogAdmin( calling_ply, "#A set the #s Elo rating of #T to #i.", isDraughts and "Checkers" or "Chess", target, newElo )
			elseif (string.SteamID(target or "")) then
				local success,reason = Chess_SetElo( target, newElo, isDraughts )
				
				if success then
					ulx.fancyLogAdmin( calling_ply, "#A set the #s Elo rating of #s to #i.", isDraughts and "Checkers" or "Chess", target, newElo )
				else
					ULib.tsayError( calling_ply, ("Could not set elo. (%s)"):format(tostring(reason)) )
				end
			else
				ULib.tsayError( calling_ply, "Invalid SteamID or Player." )
			end
		end
		
		// Autocomplete
		local function AutoComplete(...) return ULib.cmds.PlayerArg.complete(ULib.cmds.PlayerArg, ...) end
		
		// Chess command
		local function SetChessElo( calling_ply, steamid, newElo )
			local target = ULib.getUser( steamid or "", true, calling_ply )
			
			ULXUpdate( calling_ply, IsValid(target) and target or steamid, newElo, false )
		end
		local setchess = ulx.command( "Chess", "ulx chesselo", SetChessElo, {"!setelo", "!setelochess", "!chesselo", "!setchess", "!setchesselo"}, false, false, true )
		setchess:addParam{ type=ULib.cmds.StringArg, hint="Player or SteamID", autocomplete_fn=AutoComplete }
		setchess:addParam{ type=ULib.cmds.NumArg, hint="New Elo", min=0, default=1400 }
		setchess:defaultAccess( ULib.ACCESS_SUPERADMIN )
		setchess:help( "Set Chess Elo rating for user." )
		
		// Draughts command
		local function SetDraughtsElo( calling_ply, steamid, newElo )
			local target = ULib.getUser( steamid, true, calling_ply )
			
			ULXUpdate( calling_ply, IsValid(target) and target or steamID, newElo, true )
		end
		local setdraughts = ulx.command( "Chess", "ulx checkerselo", SetDraughtsElo, {"!setelocheckers", "!setcheckers", "!setcheckerselo", "!checkerselo", "!setelodraughts", "!setdraughts", "!setdraughtselo", "!draughtselo"}, false, false, true )
		setdraughts:addParam{ type=ULib.cmds.StringArg, hint="Player or SteamID", autocomplete_fn=AutoComplete }
		setdraughts:addParam{ type=ULib.cmds.NumArg, hint="New Elo", min=0, default=1400 }
		setdraughts:defaultAccess( ULib.ACCESS_SUPERADMIN )
		setdraughts:help( "Set Checkers Elo rating for user." )
	end
end
hook.Add( "Initialize", "ChessBoardPermissions", SetupCommands )

--PATH addons/[misc] szachy/lua/chess/cl_dermaboard.lua:
return gluapack()()
--PATH addons/[misc] szachy/lua/chess/cl_dermaboard.lua:

local PanelCol = {
	Main = Color(0,0,0,200), Hover = Color(0,255,0,50), Selected = Color(150,50,50,170),
	Move = Color(10,25,150,150), HasMoved = Color(50,50,50,100), Text = Color(0,0,0,255),
	
	GridWhite = Color(255, 248, 220), GridBlack = Color(210, 180, 140),
	
	White = Color(180,180,180), Black = Color(0,0,0),
}
-- local ColText = Color(50,50,50,200)
-- local ColBlack,ColWhite = Color(0,0,0,120),Color(255,255,255,10)

local NumToLetter = {"a", "b", "c", "d", "e", "f", "g", "h", ["a"]=1, ["b"]=2, ["c"]=3, ["d"]=4, ["e"]=5, ["f"]=6, ["g"]=7, ["h"]=8} --Used extensively for conversions
surface.CreateFont( "ChessPieces", { font = "Arial", size = 64, weight = 300})

function Chess_Open2DBoard( board )
	if not IsValid(board) then return end
	if IsValid( Chess_2DDermaPanel ) then Chess_2DDermaPanel:Remove() end
	
	Chess_2DDermaPanel = vgui.Create( "DFrame" )
	local frame = Chess_2DDermaPanel
	frame:SetTitle( "2D Game Board" )
	frame:SetSize( 740, 760 )
	frame:SetPos( (ScrW()/2)-370, (ScrH()/2)-380 )
	frame.Paint = function( s,w,h )
		if not IsValid(board) then
			s:Remove()
		end
		
		draw.RoundedBox( 8, 0, 0, w, h, PanelCol.Main )
	end
	frame:MakePopup()
	
	local pnlBoard = vgui.Create( "DPanel", frame )
	pnlBoard:SetSize( 720, 720 )
	pnlBoard:SetPos(10,30)
	
	pnlBoard.Squares = {}
	pnlBoard.Paint = function() end
	
	local function DoTiles(swapped)
		if pnlBoard.Squares then
			for _,v in pairs(pnlBoard.Squares) do
				for _,pnl in pairs(v) do
					pnl:Remove()
				end
			end
		end
		
		for i=0,7 do
			pnlBoard.Squares[i] = {}
			for n=0,7 do
				local pnl = vgui.Create( "DModelPanel", pnlBoard )
				pnlBoard.Squares[i][n] = pnl
				
				pnl:SetPos( (swapped and 7-i or i)*90, (swapped and 7-n or n)*90 )
				pnl:SetSize(90,90)
				pnl.GridCol = (((i+n)%2)==1) and PanelCol.GridBlack or PanelCol.GridWhite
				pnl.GridPos = {i,n}
				pnl.oPaint = pnl.Paint
				pnl.Paint = function(s,w,h)
					surface.SetDrawColor( s.GridCol )
					surface.DrawRect( 0,0, w,h )
					
					if not IsValid(board) then return end
					
					if s:IsHovered() then
						surface.SetDrawColor( PanelCol.Hover )
						surface.DrawRect( 0,0, w,h )
					end
					if board.Selected and board.Selected[1]==s.GridPos[1] and board.Selected[2]==s.GridPos[2] then
						surface.SetDrawColor( PanelCol.Selected )
						surface.DrawRect( 0,0, w,h )
					end
					if board:GetTableGrid( board.Moves, s.GridPos[1], s.GridPos[2]) then
						surface.SetDrawColor( PanelCol.Move )
						surface.DrawRect( 0,0, w,h )
					end
					
					local col,square = board.Pieces[ NumToLetter[s.GridPos[1]+1] ]
					if col then
						square = col[8-s.GridPos[2]]
						if square then
							if not (square.Team and square.Class) then return end
							
							if square.Moving then
								surface.SetDrawColor( PanelCol.HasMoved )
								surface.DrawRect( 0,0, w,h )
							end
							
							if board.Characters then
								draw.SimpleText( board.Characters[square.Team .. square.Class], "ChessPieces", w/2, h/2, PanelCol.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
							else
								s:SetModel( board.Models[square.Team .. square.Class] )
								
								return s.oPaint( s,w,h )
							end
						end
					end
					
					
					if cvars.Bool("chess_gridletters") then
						local str = (NumToLetter[i+1]..tostring(8-n)):upper()
						draw.SimpleText( str, "ChessTextSmall", 5, h-20, PanelCol.Black )
					end
				end
				
				pnl.DoClick = function(s)
					if not IsValid(board) then return end
					
					if board.Selected and board:GetTableGrid( board.Moves, pnl.GridPos[1], pnl.GridPos[2] ) then
						board:RequestMove( board.Selected[1], board.Selected[2], pnl.GridPos[1], pnl.GridPos[2] )
						board:ResetHighlights()
					elseif board.Selected and board.Selected[1]==s.GridPos[1] and board.Selected[2]==s.GridPos[2] then
						board:ResetHighlights()
					else
						board:ResetHighlights()
						board.Selected = {s.GridPos[1],s.GridPos[2]}
						board.Moves = board:GetMove( NumToLetter[s.GridPos[1]+1], 8-s.GridPos[2] )
					end
				end
				pnl.LayoutEntity = function( s, ent )
					ent:SetPos( Vector(20,20,20) )
					ent:SetAngles( Angle(0,-50,0) )
				end
				
				pnl:SetModel( board.Models["WhitePawn"] )
			end
		end
	end
	
	local swap = vgui.Create( "DButton", frame )
	swap:SetImage( "icon16/arrow_rotate_clockwise.png" )
	swap:SetSize( 18,18 )
	swap:SetPos( 620,6 )
	swap:SetText( "" )
	swap.DoClick = function(s)
		s.Swapped = not s.Swapped
		DoTiles( s.Swapped )
	end
	swap.Paint = function() end
	
	local toggleGridLetters = vgui.Create( "DCheckBox", frame )
	toggleGridLetters:SetImage( "icon16/font.png" )
	toggleGridLetters:SetSize( 18,18 )
	toggleGridLetters:SetPos( 600,6 )
	toggleGridLetters:SetText( "" )
	toggleGridLetters:SetConVar( "chess_gridletters" )
	toggleGridLetters.OnChange = function(s,newvalue)
		s:SetAlpha( s:GetChecked() and 255 or 100 )
	end
	toggleGridLetters.Paint = function() end
	toggleGridLetters.PerformLayout = function(s) -- DCheckBox overwrites DButton's PerformLayout, re-apply it
		if IsValid(s.m_Image) then
			s.m_Image:SetPos( 4, ( s:GetTall() - s.m_Image:GetTall() ) * 0.5 )
			s:SetTextInset( s.m_Image:GetWide() + 16, 0 )
		end
		
		DLabel.PerformLayout( s )
	end
	
	swap.Swapped = false
	DoTiles( swap.Swapped )
end

--PATH lua/autorun/sh_mcompass.lua:
-- Shared file.

mCompass_Settings = {}

-- Enables/Disables compass for everyone in the entire server
mCompass_Settings.Compass_Enabled = true
mCompass_Settings.Force_Server_Style = false -- Force the below compass settings on the client.
mCompass_Settings.Use_FastDL = true -- Auto download the nessesary content for clients.

mCompass_Settings.Style_Selected = "squad"
mCompass_Settings.Allow_Player_Spotting = true -- Allow / Disallow players from spotting. (Disabling just allows servers to implement their own method of spotting)
mCompass_Settings.Allow_Entity_Spotting = false -- Not yet working.
mCompass_Settings.Max_Spot_Distance = 15748.03 -- In GMOD units | Default( 15748.03 / 300m )
mCompass_Settings.Spot_Duration = 10 -- In seconds

mCompass_Settings.Spotted_Enemy_Color = Color(255, 0, 0)

mCompass_Settings.Styles = {
	["fortnite"] = {
		heading = true,		-- Whether or not the precise bearing is displayed. (Default: true)
		compassX = 0.5,		-- This value is multiplied by users screen width. (Default: 0.5)
		compassY = 0.05,	-- This value is multiplied by users screen height. (Default: 0.05)
		width = 0.25,		-- This value is multiplied by users screen width. (Default: 0.25)
		height = 0.03,		-- This value is multiplied by users screen height. (Default: 0.03)
		spacing = 2.5,		-- This value changes the spacing between lines. (Default: 2.5)
		ratio = 2,			-- The is the ratio of the size of the letters and numbers text. (Default: 2)
		offset = 0,			-- The number of degrees the compass will offset by. (Default: 0)
		maxMarkerSize = 1,	-- Maximum size of the marker, note that this affects scaling (Default: 1)
		minMarkerSize = 0.5, -- Minimum size of the marker, note that this affects scaling (Default: 0.5)
		color = Color(255, 255, 255) -- The color of the compass.
	},
	["squad"] = {
		heading = true,		-- Whether or not the precise bearing is displayed. (Default: true)
		compassX = 0.5,		-- This value is multiplied by users screen width. (Default: 0.5)
		compassY = 0.9,		-- This value is multiplied by users screen height. (Default: 0.9)
		width = 0.25,		-- This value is multiplied by users screen width. (Default: 0.25)
		height = 0.03,		-- This value is multiplied by users screen height. (Default: 0.03)
		spacing = 2,		-- This value changes the spacing between lines. (Default: 2.5)
		ratio = 1.8,		-- The is the ratio of the size of the letters and numbers text. (Default: 1.8)
		offset = 0,			-- The number of degrees the compass will offset by. (Default: 0)
		maxMarkerSize = 1,	-- Maximum size of the marker, note that this affects scaling (Default: 1)
		minMarkerSize = 0.5, -- Minimum size of the marker, note that this affects scaling (Default: 0.5)
		color = Color(255, 255, 255) -- The color of the compass.
	},
	["pubg"] = {
		heading = true,		-- Whether or not the precise bearing is displayed. (Default: true)
		compassX = 0.5,		-- This value is multiplied by users screen width. (Default: 0.5)
		compassY = 0.05,	-- This value is multiplied by users screen height. (Default: 0.05)
		width = 0.25,		-- This value is multiplied by users screen width. (Default: 0.25)
		height = 0.03,		-- This value is multiplied by users screen height. (Default: 0.03)
		spacing = 2.5,		-- This value changes the spacing between lines. (Default: 2.5)
		ratio = 1.8,		-- The is the ratio of the size of the letters and numbers text. (Default: 1.8)
		offset = 0,			-- The number of degrees the compass will offset by. (Default: 0)
		maxMarkerSize = 1,	-- Maximum size of the marker, note that this affects scaling (Default: 1)
		minMarkerSize = 0.5, -- Minimum size of the marker, note that this affects scaling (Default: 0.5)
		color = Color(255, 255, 255) -- The color of the compass.
	}
}

--------------------------------------------------------------
-- Dont edit anything below this line.
--------------------------------------------------------------

if SERVER then

	util.AddNetworkString("mCompass_AddMarker")
	util.AddNetworkString("mCompass_RemoveMarker")

	local mCompass_MarkerTable = mCompass_MarkerTable or {}

	-- DOCSTRING FOR THE 2 FUNCTIONS BELOW --
	-- ply: player who is currently spotting (used to grab info about players team)
	-- ent: entity that was spotted (used to track ent)
	-- pos: if not tracking ent, can also supply vector to pos
	-- time: amount of time marker is active for
	function mCompass_AddMarker(ply, pos, players, time, color, icon, name)
		name = name or ""
		icon = icon or ""
		color = color or mCompass_Settings.Spotted_Enemy_Color
		players = players or (ply and ply:IsPlayer()) and team.GetPlayers(ply:Team())

		local id = #mCompass_MarkerTable + 1
		if players then
			for k, v in pairs(players) do
				net.Start("mCompass_AddMarker")
					net.WriteInt(id, 4)
					net.WriteBool(false) -- IsEntity
					net.WriteVector(pos)
					net.WriteFloat(time)
					net.WriteColor(color)
					net.WriteString(icon)
					net.WriteString(name)
				net.Send(v)
			end
		else
			net.Start("mCompass_AddMarker")
				net.WriteInt(id, 4)
				net.WriteBool(false) -- IsEntity
				net.WriteVector(pos)
				net.WriteFloat(time)
				net.WriteColor(color)
				net.WriteString(icon)
				net.WriteString(name)
			net.Broadcast()
		end
		table.insert(mCompass_MarkerTable, {id, pos, time, color, icon, name})
		return id
	end

	function mCompass_AddEntityMarker(ply, ent, players, time, color, icon, name)
		name = name or ""
		icon = icon or ""
		color = color or mCompass_Settings.Spotted_Enemy_Color
		players = players or (ply and ply:IsPlayer()) and team.GetPlayers(ply:Team())

		local id = #mCompass_MarkerTable + 1
		if players then
			for k, v in pairs(players) do
				net.Start("mCompass_AddMarker")
					net.WriteInt(id, 4)
					net.WriteBool(true) -- IsEntity
					net.WriteEntity(ent)
					net.WriteFloat(time)
					net.WriteColor(color)
					net.WriteString(icon)
					net.WriteString(name)
				net.Send(v)
			end
		else
			net.Start("mCompass_AddMarker")
				net.WriteInt(id, 4)
				net.WriteBool(true) -- IsEntity
				net.WriteEntity(ent)
				net.WriteFloat(time)
				net.WriteColor(color)
				net.WriteString(icon)
				net.WriteString(name)
			net.Broadcast()
		end
		table.insert(mCompass_MarkerTable, {id, pos, time, color, icon, name})
		return id
	end

	function Adv_Compass_RemoveMarker(markerID)
		for k, v in pairs(mCompass_MarkerTable) do
			if markerID == v[1] then
				net.Start("mCompass_RemoveMarker")
					net.WriteInt(markerID, 4)
				net.Broadcast()
				table.remove(mCompass_MarkerTable, k)
			end
		end
	end

	if mCompass_Settings.Use_FastDL then
		resource.AddFile("materials/compass/compass_marker_01.vmt")
		resource.AddFile("materials/compass/compass_marker_02.vmt")
		resource.AddFile("resource/fonts/exo/Exo-Regular.ttf")
	end

	local function v(arg)
		local arg = tonumber(arg)
		return math.Clamp(arg and arg or 255, 0, 255)
	end

	concommand.Add("mcompass_spot", function(ply, cmd, args)
		if mCompass_Settings.Allow_Player_Spotting then
			local color = string.ToColor(v(args[1]).." "..v(args[2]).." "..v(args[3]).." "..v(args[4]))
			local tr = util.TraceLine({
				start = ply:EyePos(),
				endpos = ply:EyePos() + ply:EyeAngles():Forward() * mCompass_Settings.Max_Spot_Distance,
				filter = ply
			})
			local id
			local t = CurTime() + mCompass_Settings.Spot_Duration
			if tr.Entity and !tr.HitWorld then
				id = mCompass_AddEntityMarker(ply, tr.Entity, nil, t)
			else
				id = mCompass_AddMarker(ply, tr.HitPos, nil, t)
			end
		end
	end)

end

if CLIENT then

	concommand.Add("mcompass_reset", function(ply, cmd, args)
		RunConsoleCommand("mcompass_enabled", "1")
		RunConsoleCommand("mcompass_style", "1")
		RunConsoleCommand("mcompass_heading", "1")
		RunConsoleCommand("mcompass_xposition", "0.5")
		RunConsoleCommand("mcompass_yposition", "0.05")
		RunConsoleCommand("mcompass_width", "0.25")
		RunConsoleCommand("mcompass_height", "0.03")
		RunConsoleCommand("mcompass_spacing", "2.5")
		RunConsoleCommand("mcompass_ratio", "1.8")
		RunConsoleCommand("mcompass_color", "255", "255", "255", "255")
	end)

	-- cvars defined by client
	local cl_cvar_mcompass_enabled, cl_cvar_mcompass_style, cl_cvar_mcompass_heading
	local cl_cvar_mcompass_xposition, cl_cvar_mcompass_yposition, cl_cvar_mcompass_width, cl_cvar_mcompass_height
	local cl_cvar_mcompass_spacing, cl_cvar_mcompass_ratio, cl_cvar_mcompass_color

	local function loadFonts()
		local returnVal = hook.Call("mCompass_loadFonts")
	end
	
	-- not cvars
	local cl_style_selected_str, compass_style

	local function updateCompassSettings()
		-- ternary operators sorry not sorry
		cl_style_selected_str = (cl_cvar_mcompass_style == 1 and "fortnite" or cl_cvar_mcompass_style == 2 and "squad" or cl_cvar_mcompass_style == 3 and "pubg")
		compass_style = mCompass_Settings.Force_Server_Style
			and mCompass_Settings.Styles[mCompass_Settings.Style_Selected]
			or {
				style = cl_style_selected_str,
				heading = cl_cvar_mcompass_heading,
				compassX = cl_cvar_mcompass_xposition,
				compassY = cl_cvar_mcompass_yposition,
				width = cl_cvar_mcompass_width,
				height = cl_cvar_mcompass_height,
				spacing = cl_cvar_mcompass_spacing,
				ratio = cl_cvar_mcompass_ratio,
				offset = mCompass_Settings.Styles[cl_style_selected_str].offset,
				color = cl_cvar_mcompass_color,
				maxMarkerSize = 1,
				minMarkerSize = 0.5
			}
		if mCompass_Settings.Force_Server_Style then
			compass_style.style = mCompass_Settings.Style_Selected
		end
		loadFonts()
	end

	local function v(arg)
		local arg = tonumber(arg)
		return math.Clamp(arg and arg or 255, 0, 255)
	end

	CreateClientConVar("mcompass_enabled", "1", true, false)
	cvars.AddChangeCallback("mcompass_enabled", function(convar, oldValue, newValue)
		if newValue == "1" or newValue == "0" then
			cl_cvar_mcompass_enabled = tobool(newValue)
		end
		updateCompassSettings()
	end, "mcompass_enabled_cvar_callback")
	cl_cvar_mcompass_enabled = tobool(GetConVar("mcompass_enabled"):GetInt())

	CreateClientConVar("mcompass_style", "1", true, false)
	cvars.AddChangeCallback("mcompass_style", function(convar, oldValue, newValue)
		if newValue == "1" or newValue == "2" or newValue == "3" then
			cl_cvar_mcompass_style = tonumber(newValue)
		end
		updateCompassSettings()
	end, "mcompass_style_cvar_callback")
	cl_cvar_mcompass_style = GetConVar("mcompass_style"):GetInt()

	CreateClientConVar("mcompass_heading", "1", true, false)
	cvars.AddChangeCallback("mcompass_heading", function(convar, oldValue, newValue)
		if newValue == "1" or newValue == "0" then
			cl_cvar_mcompass_heading = tobool(newValue)
		end
		updateCompassSettings()
	end, "mcompass_heading_cvar_callback")
	cl_cvar_mcompass_heading = tobool(GetConVar("mcompass_heading"):GetInt())

	CreateClientConVar("mcompass_xposition", "0.5", true, false)
	cvars.AddChangeCallback("mcompass_xposition", function(convar, oldValue, newValue)
		local foo = tonumber(newValue)
		if foo >= 0 and foo <= 1 then
			cl_cvar_mcompass_xposition = newValue
		end
		updateCompassSettings()
	end, "mcompass_xposition_cvar_callback")
	cl_cvar_mcompass_xposition = GetConVar("mcompass_xposition"):GetFloat()

	CreateClientConVar("mcompass_yposition", "0.05", true, false)
	cvars.AddChangeCallback("mcompass_yposition", function(convar, oldValue, newValue)
		local foo = tonumber(newValue)
		if foo >= 0 and foo <= 1 then
			cl_cvar_mcompass_yposition = newValue
		end
		updateCompassSettings()
	end, "mcompass_yposition_cvar_callback")
	cl_cvar_mcompass_yposition = GetConVar("mcompass_yposition"):GetFloat()

	CreateClientConVar("mcompass_width", "0.25", true, false)
	cvars.AddChangeCallback("mcompass_width", function(convar, oldValue, newValue)
		local foo = tonumber(newValue)
		if foo >= 0 and foo <= 1 then
			cl_cvar_mcompass_width = tonumber(newValue)
		end
		updateCompassSettings()
	end, "mcompass_width_cvar_callback")
	cl_cvar_mcompass_width = GetConVar("mcompass_width"):GetFloat()

	CreateClientConVar("mcompass_height", "0.03", true, false)
	cvars.AddChangeCallback("mcompass_height", function(convar, oldValue, newValue)
		local foo = tonumber(newValue)
		if foo >= 0 and foo <= 1 then
			cl_cvar_mcompass_height = tonumber(newValue)
		end
		updateCompassSettings()
	end, "mcompass_height_cvar_callback")
	cl_cvar_mcompass_height = GetConVar("mcompass_height"):GetFloat()

	CreateClientConVar("mcompass_spacing", "2.5", true, false)
	cvars.AddChangeCallback("mcompass_spacing", function(convar, oldValue, newValue)
		local foo = tonumber(newValue)
		if foo > 1 and foo < 10 then
			cl_cvar_mcompass_spacing = foo
		end
		updateCompassSettings()
	end, "mcompass_spacing_cvar_callback")
	cl_cvar_mcompass_spacing = GetConVar("mcompass_spacing"):GetFloat()

	CreateClientConVar("mcompass_ratio", "1.8", true, false)
	cvars.AddChangeCallback("mcompass_ratio", function(convar, oldValue, newValue)
		local foo = tonumber(newValue)
		if foo > 0 and foo < 10 then
			cl_cvar_mcompass_ratio = foo
		end
		updateCompassSettings()
	end, "mcompass_ratio_cvar_callback")
	cl_cvar_mcompass_ratio = GetConVar("mcompass_ratio"):GetFloat()

	CreateClientConVar("mcompass_color", "255 255 255 255", true, false)
	cvars.AddChangeCallback("mcompass_color", function(convar, oldValue, newValue)
		local args = string.Explode(" ", newValue)
		cl_cvar_mcompass_color = string.ToColor(v(args[1]).." "..v(args[2]).." "..v(args[3]).." "..v(args[4]))
		updateCompassSettings()
	end, "mcompass_color_cvar_callback")
	local foo = string.Explode(" ", GetConVar("mcompass_color"):GetString())
	cl_cvar_mcompass_color = string.ToColor(v(foo[1]).." "..v(foo[2]).." "..v(foo[3]).." "..v(foo[4]))

	----====----====----====----====----====----====----====----====----====----====----====----====----====----====----====----====----====----

	displayDistanceFontTable = displayDistanceFontTable or {}

	-- Function that handles fonts for the spot marker.
	local function markerScaleFunc(markerSizeScale)
		local returnVal
		local n = math.Round(markerSizeScale)
		if !oldMarkerSizeScale or oldMarkerSizeScale != n then
			if displayDistanceFontTable[n] then
				returnVal = displayDistanceFontTable[n].name
			else
				local newFontName = tostring("exo_compass_DDN_"..n)
				displayDistanceFontTable[n] = {
					name = newFontName,
					size = n
				}
				surface.CreateFont(newFontName, {
					font = "Exo",
					size = n,
					antialias = true
				})
				returnVal = displayDistanceFontTable[n].name
			end
			oldMarkerSizeScale = n
		else
			return displayDistanceFontTable[oldMarkerSizeScale].name
		end
		return returnVal
	end

	-- This table is just going to hold all of the generated fonts for later use.
	fontRatioChangeTable = fontRatioChangeTable or {}

	-- Doing this just so we could remake fonts and see ratio effects live. Kinda messy, sorry :/
	hook.Add("mCompass_loadFonts", "mCompass_loadFonts_addon", function()
		local h = compass_style.height
		local r = compass_style.ratio
		local ms = ScrH() * (compass_style.maxMarkerSize / 45)
		if r != mCompass_oldFontRatio then
			for k, v in pairs(fontRatioChangeTable) do
				if "exo_compass_Numbers_"..r == v.numberName then
					mCompass_oldFontRatio = r
					return v
				end
			end
			surface.CreateFont("exo_compass_Numbers_"..r, {
				font = "Exo",
				size = math.Round((ScrH() * h) / r),
				antialias = true
			})
			surface.CreateFont("exo_compass_Distance-Display-Numbers_"..r, {
				font = "Exo",
				size = (ScrH() * (h / r)) * compass_style.maxMarkerSize,
				antialias = true
			})
			surface.CreateFont("exo_compass_Letters", {
				font = "Exo",
				size = ScrH() * h,
				antialias = true
			})
			local t = {
				ratio = r,
				numberName = "exo_compass_Numbers_"..r
			}
			table.insert(fontRatioChangeTable, t)
			mCompass_oldFontRatio = r
		end
	end)

	updateCompassSettings()

	----------------------------------------------------------------------------------------------------------------

	local cl_mCompass_MarkerTable = cl_mCompass_MarkerTable or {}

	local mat = Material("compass/compass_marker_01")
	local mat2 = Material("compass/compass_marker_02")

	net.Receive("mCompass_AddMarker", function(len)
		local id = net.ReadInt(4)
		local isEntity = net.ReadBool()
		local pos = (!isEntity and net.ReadVector() or nil)
		local ent = (isEntity and net.ReadEntity() or nil)
		local time = net.ReadFloat()
		local color = net.ReadColor()
		local icon_mat = net.ReadString()
		local icon_name = net.ReadString()
		icon_mat = (icon_mat == "") and mat or Material(icon_mat)
		icon_name = icon_name or ""
		table.insert(cl_mCompass_MarkerTable, {isEntity, (pos or (ent or nil)), time, color, id, icon_mat, icon_name})
	end)

	net.Receive("mCompass_RemoveMarker", function(len)
		local id = net.ReadInt(4)
		for k, v in pairs(cl_mCompass_MarkerTable) do
			if id == v[5] then
				table.remove(cl_mCompass_MarkerTable, k)
			end
		end
	end)

	local function getMetricValue(units)
		local meters = math.Round(units * 0.01905)
		local kilometers = math.Round(meters / 1000, 2)
		return (kilometers > 1) and kilometers.."km" or meters.."m"
	end

	local function getTextSize(font, text)
		surface.SetFont(font)
		local w, h = surface.GetTextSize(text)
		return w, h
	end

	-- Basically draws lines with two masks that limit where the lines can be drawn
	-- Not entirely sure how this affects performance... yolo
	local function custom_compass_DrawLineFunc(mask1, mask2, line, color)
		render.ClearStencil()
		render.SetStencilEnable(true)
			render.SetStencilFailOperation(STENCILOPERATION_KEEP)
			render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
			render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
			render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)

			render.SetStencilWriteMask(1)
			render.SetStencilReferenceValue(1)

			surface.SetDrawColor(Color(0, 0, 0, 1))
			surface.DrawRect(mask1[1], mask1[2], mask1[3], mask1[4]) -- left
			surface.DrawRect(mask2[1], mask2[2], mask2[3], mask2[4]) -- right

			render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
			render.SetStencilTestMask(1)

			surface.SetDrawColor(color)
			surface.DrawLine(line[1], line[2], line[3], line[4])
		render.SetStencilEnable(false)
	end

	local adv_compass_tbl = {
		[0] = "N",
		[45] = "NE",
		[90] = "E",
		[135] = "SE",
		[180] = "S",
		[225] = "SW",
		[270] = "W",
		[315] = "NW",
		[360] = "N"
	}

	hook.Add("HUDPaint", "HUDPaint_Compass", function()
		local ply = LocalPlayer()
		if mCompass_Settings.Compass_Enabled and cl_cvar_mcompass_enabled then

			local ang = ply:GetAngles()
			local compassX, compassY = ScrW() * compass_style.compassX, ScrH() * compass_style.compassY
			local width, height = ScrW() * compass_style.width, ScrH() * compass_style.height
			local cl_spacing = compass_style.spacing
			local ratio = compass_style.ratio
			local color = compass_style.color
			local minMarkerSize = ScrH() * (compass_style.minMarkerSize / 45)
			local maxMarkerSize = ScrH() * (compass_style.maxMarkerSize / 45)
			local heading = compass_style.heading
			local offset = compass_style.offset

			spacing = (width * cl_spacing) / 360
			numOfLines = width / spacing
			fadeDistMultiplier = 1
			fadeDistance = (width / 2) / fadeDistMultiplier

			surface.SetFont("exo_compass_Numbers_"..ratio)

			if compass_style.style == "squad" then
				local text = math.Round(360 - ((ang.y - offset) % 360))
				local font = "exo_compass_Numbers_"..ratio
				compassBearingTextW, compassBearingTextH = getTextSize(font, text)
				surface.SetFont(font)
				surface.SetTextColor(Color(255, 255, 255))
				surface.SetTextPos(compassX - compassBearingTextW / 2, compassY)
				surface.DrawText(text)
			end

			for i = math.Round(-ang.y) % 360, (math.Round(-ang.y) % 360) + numOfLines do
				-- DEBUGGING LINES
				-- local compassStart = compassX - width / 2
				-- local compassEnd = compassX + width / 2
				-- surface.SetDrawColor(Color(0, 255, 0))
				-- surface.DrawLine(compassStart, compassY, compassStart, compassY + height * 2)
				-- surface.DrawLine(compassEnd, compassY, compassEnd, compassY + height * 2)

				local x = ((compassX - (width / 2)) + (((i + ang.y) % 360) * spacing))
				local value = math.abs(x - compassX)
				local calc = 1 - ((value + (value - fadeDistance)) / (width / 2))
				local calculation = 255 * math.Clamp(calc, 0.001, 1)

				local i_offset = -(math.Round(i - offset - (numOfLines / 2))) % 360
				if i_offset % 15 == 0 and i_offset >= 0 then
					local a = i_offset
					local text = adv_compass_tbl[360 - (a % 360)] and adv_compass_tbl[360 - (a % 360)] or 360 - (a % 360)
					local font = type(text) == "string" and "exo_compass_Letters" or "exo_compass_Numbers_"..ratio
					local w, h = getTextSize(font, text)

					surface.SetDrawColor(Color(color.r, color.g, color.b, calculation))
					surface.SetTextColor(Color(color.r, color.g, color.b, calculation))
					surface.SetFont(font)

					if compass_style.style == "pubg" then
						surface.DrawLine(x, compassY, x, compassY + height * 0.2)
						surface.DrawLine(x, compassY, x, compassY + height * 0.5)
						surface.SetTextPos(x - w / 2, compassY + height * 0.6)
						surface.DrawText(text)
					elseif compass_style.style == "fortnite" then
						if font == "exo_compass_Numbers_"..ratio then
							surface.DrawLine(x, compassY, x, compassY + height * 0.2)
							surface.DrawLine(x, compassY, x, compassY + height * 0.3)
							surface.SetTextPos(x - w / 2, compassY + height * 0.5)
							surface.DrawText(text)
						elseif font == "exo_compass_Letters" then
							surface.SetTextPos(x - w / 2, compassY)
							surface.DrawText(text)
						end
					elseif compass_style.style == "squad" then
						local mask1 = {compassX - width/2 - fadeDistance, compassY, width / 2 + fadeDistance - (compassBearingTextW / 1.5), height * 2}
						local mask2 = {compassX + (compassBearingTextW / 1.5), compassY, width / 2 + fadeDistance - (compassBearingTextW / 1.5), height * 2}
						local col = Color(color.r, color.g, color.b, calculation)
						local line = {x, compassY, x, compassY + height * 0.5}
						custom_compass_DrawLineFunc(mask1, mask2, line, col)
						surface.SetTextPos(x - w / 2, compassY + height * 0.55)
						surface.DrawText(text)
					end

					if compass_style.style == "squad" then
						local mask1 = {compassX - width/2 - fadeDistance, compassY, width/2 + fadeDistance - (compassBearingTextW / 1.5), height * 2}
						local mask2 = {compassX + (compassBearingTextW / 1.5), compassY, width/2 + fadeDistance - (compassBearingTextW / 1.5), height * 2}
						local col = Color(color.r, color.g, color.b, calculation)

						local line = {x, compassY, x, compassY + height * 0.5}
						custom_compass_DrawLineFunc(mask1, mask2, line, col)
					end
				end

				if compass_style.style == "squad" then
					if i_offset % 5 == 0 and i_offset % 15 != 0 then
						local mask1 = {compassX - width/2 - fadeDistance, compassY, width/2 + fadeDistance - (compassBearingTextW / 1.5), height}
						local mask2 = {compassX + (compassBearingTextW / 1.5), compassY, width/2 + fadeDistance - (compassBearingTextW / 1.5), height}
						local col = Color(color.r, color.g, color.b, calculation)

						local line = {x, compassY, x, compassY + height * 0.25}
						custom_compass_DrawLineFunc(mask1, mask2, line, col)
					end
				end
			end

			for k, v in pairs(cl_mCompass_MarkerTable) do
				if CurTime() > v[3] or (v[1] and !IsValid(v[2]))  then
					table.remove(cl_mCompass_MarkerTable, k)
					continue
				end

				local spotPos = (v[1] and v[2]:GetPos() or v[2])
				local d = ply:GetPos():Distance(spotPos)
				local currentVar = 1 - (d / (300 / 0.01905)) -- Converting 300m to gmod units
				local markerScale = Lerp(currentVar, minMarkerSize, maxMarkerSize)
				local font = markerScaleFunc(markerScale)

				local yAng = ang.y - (spotPos - ply:GetPos()):GetNormalized():Angle().y
				local markerSpot = math.Clamp(((compassX + (width / 2 * cl_spacing)) - (((-yAng - offset - 180) % 360) * spacing)), compassX - (width / 2), compassX + (width / 2))

				surface.SetMaterial(v[6])
				surface.SetDrawColor(v[4])
				surface.DrawTexturedRect(markerSpot - markerScale/2, compassY - markerScale - markerScale/2, markerScale, markerScale)

				-- Drawing text above markers
				local text = (v[7] != "") and v[7].." - "..getMetricValue(d) or getMetricValue(d)
				local w, h = getTextSize(font, text)

				surface.SetFont(font)
				surface.SetTextColor(Color(255, 255, 255))
				surface.SetTextPos(markerSpot - w/2, compassY - markerScale - markerScale/2 - h)
				surface.DrawText(text)
			end

			if compass_style.heading and compass_style.style != "squad" then
				-- Middle Triangle
				local triangleSize = 8
				local triangleHeight = compassY

				local triangle = {
					{ x = compassX - triangleSize/2, y = triangleHeight - (triangleSize * 2) },
					{ x = compassX + triangleSize/2, y = triangleHeight - (triangleSize * 2) },
					{ x = compassX, y = triangleHeight - triangleSize },
				}
				surface.SetDrawColor(255, 255, 255)
				draw.NoTexture()
				surface.DrawPoly(triangle)

				if heading then
					local text = math.Round(-ang.y - offset) % 360
					local font = "exo_compass_Numbers_"..ratio
					local w, h = getTextSize(font, text)
					surface.SetFont(font)
					surface.SetTextColor(Color(255, 255, 255))
					surface.SetTextPos(compassX - w/2, compassY - h - (triangleSize * 2))
					surface.DrawText(text)
				end
			end
		end
	end)

	hook.Add("PopulateToolMenu", "mCompass_PopulateToolMenu", function()
		spawnmenu.AddToolMenuOption("Options", "mCompass", "Settings", "Settings", "", "", function(panel)
			panel:ClearControls()

			local Label1 = vgui.Create("DLabel", panel)
			Label1:Dock(TOP)
			Label1:SetTextColor(Color(50, 50, 50))
			Label1:SetText("Client Settings")
			Label1:SizeToContents()
			panel:AddItem(Label1)

			----====----====----====----====----====----====----====----

			local box = vgui.Create("DCheckBoxLabel", panel)
			box:SetText("Enabled")
			box:SetTextColor(Color(50, 50, 50))
			box:SetConVar("mcompass_enabled")
			box:SetValue(GetConVar("mcompass_enabled"):GetInt())
			box:SizeToContents()
			panel:AddItem(box)

			local box2 = vgui.Create("DCheckBoxLabel", panel)
			box2:SetText("Show Heading")
			box2:SetTextColor(Color(50, 50, 50))
			box2:SetConVar("mcompass_heading")
			box2:SetValue(GetConVar("mcompass_heading"):GetInt())
			box2:SizeToContents()
			panel:AddItem(box2)

			panel:NumSlider("Style", "mcompass_style", 1, 3, 0)

			panel:NumSlider("X Position", "mcompass_xposition", 0, 1)
			panel:NumSlider("Y Position", "mcompass_yposition", 0, 1)
			panel:NumSlider("Width", "mcompass_width", 0, 1)
			panel:NumSlider("Height", "mcompass_height", 0, 1)

			panel:NumSlider("Spacing", "mcompass_spacing", 1, 10, 2)
			panel:NumSlider("Ratio (font size)", "mcompass_ratio", 0.1, 10)

			local mixercolor = string.ToColor(GetConVar("mcompass_color"):GetString())

			local mixer = vgui.Create("DColorMixer", panel)
			mixer:SizeToContents()
			mixer:SetColor(mixercolor)
			panel:AddItem(mixer)

			local but1 = vgui.Create("DButton", panel)
			but1:SetText("Set Color")
			but1.DoClick = function(self)
				local c = mixer:GetColor()
				RunConsoleCommand("mcompass_color", tostring(c.r).." "..tostring(c.g).." "..tostring(c.b).." "..tostring(c.a))
			end
			panel:AddItem(but1)

			local but2 = vgui.Create("DButton", panel)
			but2:SetText("Reset Settings")
			but2.DoClick = function(self)
				RunConsoleCommand("mcompass_reset")
			end
			panel:AddItem(but2)
		end)
	end)

end
--PATH lua/pixelui/sh_config.lua:
return gluapack()()
--PATH lua/pixelui/drawing/cl_outlined_box.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_check_box.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

function PANEL:Init()
    self:SetIsToggle(true)

    local boxSize = PIXEL.Scale(20)
    self:SetSize(boxSize, boxSize)

    self:SetImageURL("https://pixel-cdn.lythium.dev/i/7u6uph3x6g")

    self:SetNormalColor(PIXEL.Colors.Transparent)
    self:SetHoverColor(PIXEL.Colors.PrimaryText)
    self:SetClickColor(PIXEL.Colors.PrimaryText)
    self:SetDisabledColor(PIXEL.Colors.Transparent)

    self:SetImageSize(.8)

    self.BackgroundCol = PIXEL.CopyColor(PIXEL.Colors.Primary)
end

function PANEL:PaintBackground(w, h)
    if not self:IsEnabled() then
        PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, PIXEL.Colors.Disabled)
        self:PaintExtra(w, h)
        return
    end

    local bgCol = PIXEL.Colors.Primary

    if self:IsDown() or self:GetToggle() then
        bgCol = PIXEL.Colors.Positive
    end

    local animTime = FrameTime() * 12
    self.BackgroundCol = PIXEL.LerpColor(animTime, self.BackgroundCol, bgCol)

    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)
end

vgui.Register("PIXEL.Checkbox", PANEL, "PIXEL.ImageButton")
--PATH lua/pixelui/elements/cl_combo_box.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_combo_box.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

Derma_Install_Convar_Functions(PANEL)

AccessorFunc(PANEL, "bSizeToText", "SizeToText", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDoSort", "SortItems", FORCE_BOOL)

function PANEL:Init()
    self:SetSizeToText(true)

    self:Clear()

    self:SetTextAlign(TEXT_ALIGN_LEFT)
    self:SetSortItems(true)
end

function PANEL:PerformLayout(w, h)
    if not self:GetSizeToText() then return end
    self:SizeToText()
    self:SetWide(self:GetWide() + PIXEL.Scale(14))
end

function PANEL:Clear()
    self:SetText("")
    self.Choices = {}
    self.Data = {}
    self.ChoiceIcons = {}
    self.selected = nil

    if not self.Menu then return end
    self.Menu:Remove()
    self.Menu = nil
end

function PANEL:GetOptionText(id)
    return self.Choices[id]
end

function PANEL:GetOptionData(id)
    return self.Data[id]
end

function PANEL:GetOptionTextByData(data)
    for id, dat in pairs(self.Data) do
        if dat == data then
            return self:GetOptionText(id)
        end
    end

    for id, dat in pairs(self.Data) do
        if dat == tonumber(data) then
            return self:GetOptionText(id)
        end
    end

    return data
end

function PANEL:ChooseOption(value, index)
    if self.Menu then
        self.Menu:Remove()
        self.Menu = nil
    end

    self:SetText(value)

    self.selected = index
    self:OnSelect(index, value, self.Data[index])

    if not self:GetSizeToText() then return end
    self:SizeToText()
    self:SetWide(self:GetWide() + PIXEL.Scale(10))
end

function PANEL:ChooseOptionID(index)
    local value = self:GetOptionText(index)
    self:ChooseOption(value, index)
end

function PANEL:GetSelectedID()
    return self.selected
end

function PANEL:GetSelected()
    if not self.selected then return end
    return self:GetOptionText(self.selected), self:GetOptionData(self.selected)
end

function PANEL:OnSelect(index, value, data) end

function PANEL:AddChoice(value, data, select, icon)
    local i = table.insert(self.Choices, value)

    if data then
        self.Data[i] = data
    end

    if icon then
        self.ChoiceIcons[i] = icon
    end

    if select then
        self:ChooseOption(value, i)
    end

    return i
end

function PANEL:IsMenuOpen()
    return IsValid(self.Menu) and self.Menu:IsVisible()
end

function PANEL:OpenMenu(pControlOpener)
    if pControlOpener and pControlOpener == self.TextEntry then return end

    if #self.Choices == 0 then return end

    if IsValid(self.Menu) then
        self.Menu:Remove()
        self.Menu = nil
    end

    CloseDermaMenus()
    self.Menu = vgui.Create("PIXEL.Menu", self)

    if self:GetSortItems() then
        local sorted = {}
        for k, v in pairs(self.Choices) do
            local val = tostring(v)
            if string.len(val) > 1 and not tonumber(val) and val:StartWith("#") then val = language.GetPhrase(val:sub(2)) end
            table.insert(sorted, {id = k, data = v, label = val})
        end

        for k, v in SortedPairsByMemberValue(sorted, "label") do
            local option = self.Menu:AddOption(v.data, function() self:ChooseOption(v.data, v.id) end)
            if self.ChoiceIcons[v.id] then
                option:SetIcon(self.ChoiceIcons[v.id])
            end
        end
    else
        for k, v in pairs(self.Choices) do
            local option = self.Menu:AddOption(v, function() self:ChooseOption(v, k) end)
            if self.ChoiceIcons[k] then
                option:SetIcon(self.ChoiceIcons[k])
            end
        end
    end

    local x, y = self:LocalToScreen(0, self:GetTall())
    self.Menu:SetMinimumWidth(self:GetWide())
    self.Menu:Open(x, y + PIXEL.Scale(6), false, self)

    self:SetToggle(true)

    self.Menu.OnRemove = function(s)
        if not IsValid(self) then return end
        self:SetToggle(false)
    end
end

function PANEL:CloseMenu()
    if not IsValid(self.Menu) then return end
    self.Menu:Remove()
end

function PANEL:CheckConVarChanges()
    if not self.m_strConVar then return end

    local strValue = GetConVar(self.m_strConVar):GetString()
    if self.m_strConVarValue == strValue then return end

    self.m_strConVarValue = strValue
    self:SetValue(self:GetOptionTextByData(self.m_strConVarValue))
end

function PANEL:Think()
    self:CheckConVarChanges()
end

function PANEL:SetValue(strValue)
    self:SetText(strValue)
end

function PANEL:DoClick()
    if self:IsMenuOpen() then return self:CloseMenu() end
    self:OpenMenu()
end

function PANEL:PaintOver(w, h)
    local dropBtnSize = PIXEL.Scale(8)
    PIXEL.DrawImage(w - dropBtnSize - PIXEL.Scale(8), h / 2 - dropBtnSize / 2, dropBtnSize, dropBtnSize, "https://pixel-cdn.lythium.dev/i/5r7ovslav", PIXEL.Colors.PrimaryText)
end

vgui.Register("PIXEL.ComboBox", PANEL, "PIXEL.TextButton")
--PATH lua/pixelui/elements/cl_menu.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "m_bBorder", "DrawBorder")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_bDrawColumn", "DrawColumn")
AccessorFunc(PANEL, "m_iMaxHeight", "MaxHeight")
AccessorFunc(PANEL, "m_pOpenSubMenu", "OpenSubMenu")

function PANEL:Init()
    self:SetIsMenu(true)
    self:SetDrawBorder(true)
    self:SetPaintBackground(true)
    self:SetMinimumWidth(PIXEL.Scale(100))
    self:SetDrawOnTop(true)
    self:SetMaxHeight(ScrH() * 0.3)
    self:SetDeleteSelf(true)
    self:SetBarDockShouldOffset(true)

    self:SetPadding(0)

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 10)

    RegisterDermaMenuForClose(self)
end

function PANEL:AddPanel(pnl)
    self:AddItem(pnl)
    pnl.ParentMenu = self
end

function PANEL:AddOption(strText, funcFunction)
    local pnl = vgui.Create("PIXEL.MenuOption", self)
    pnl:SetMenu(self)
    pnl:SetText(strText)
    if funcFunction then pnl.DoClick = funcFunction end

    self:AddPanel(pnl)

    return pnl
end

function PANEL:AddCVar(strText, convar, on, off, funcFunction)
    local pnl = vgui.Create("PIXEL.MenuOptionCVar", self)
    pnl:SetMenu(self)
    pnl:SetText(strText)
    if funcFunction then pnl.DoClick = funcFunction end

    pnl:SetConVar(convar)
    pnl:SetValueOn(on)
    pnl:SetValueOff(off)

    self:AddPanel(pnl)

    return pnl
end

function PANEL:AddSpacer(text, func)
    local pnl = vgui.Create("Panel", self)

    local spacerCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 6)
    pnl.Paint = function(p, w, h)
        surface.SetDrawColor(spacerCol)
        surface.DrawRect(0, 0, w, h)
    end

    pnl:SetTall(PIXEL.Scale(3))
    self:AddPanel(pnl)

    return pnl
end

function PANEL:AddSubMenu(strText, funcFunction)
    local pnl = vgui.Create("PIXEL.MenuOption", self)
    local subMenu = pnl:AddSubMenu(strText, funcFunction)

    pnl:SetText(strText)
    if funcFunction then pnl.DoClick = funcFunction end

    self:AddPanel(pnl)

    return subMenu, pnl
end

function PANEL:Hide()
    local openmenu = self:GetOpenSubMenu()
    if openmenu then
        openmenu:Hide()
    end

    self:SetVisible(false)
    self:SetOpenSubMenu(nil)
end

function PANEL:OpenSubMenu(item, menu)
    local openmenu = self:GetOpenSubMenu()
    if IsValid(openmenu) and openmenu:IsVisible() then
        if menu and openmenu == menu then return end

        self:CloseSubMenu(openmenu)
    end

    if not IsValid(menu) then return end

    local x, y = item:LocalToScreen(self:GetWide(), 0)
    menu:Open(x, y, false, item)

    self:SetOpenSubMenu(menu)
end

function PANEL:CloseSubMenu(menu)
    menu:Hide()
    self:SetOpenSubMenu(nil)
end

function PANEL:Paint(w, h)
    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)
end

function PANEL:ChildCount()
    return #self:GetCanvas():GetChildren()
end

function PANEL:GetChild(num)
    return self:GetCanvas():GetChildren()[num]
end

function PANEL:LayoutContent(w, h)
    w = self:GetMinimumWidth()

    local children = self:GetCanvas():GetChildren()
    for k, pnl in pairs(children) do
        pnl:InvalidateLayout(true)
        w = math.max(w, pnl:GetWide())
    end

    self:SetWide(w)

    local y = 0
    for k, pnl in pairs(children) do
        pnl:SetWide(w)
        pnl:SetPos(0, y)
        pnl:InvalidateLayout(true)

        y = y + pnl:GetTall()
    end

    y = math.min(y, self:GetMaxHeight())

    self:SetTall(y)

    local overlap = select(2, self:LocalToScreen(0, y)) - ScrH()
    if overlap > 0 then
        self:SetPos(self:GetPos(), select(2, self:GetPos()) - overlap)
    end
end

function PANEL:Open(x, y, skipanimation, ownerpanel)
    RegisterDermaMenuForClose(self)

    local maunal = x and y
    x = x or gui.MouseX()
    y = y or gui.MouseY()

    local ownerHeight = 0
    if ownerpanel then ownerHeight = ownerpanel:GetTall() end

    self:InvalidateLayout(true)

    local w, h = self:GetWide(), self:GetTall()

    self:SetSize(w, h)

    if y + h > ScrH() then y = ((maunal and ScrH()) or (y + ownerHeight)) - h end
    if x + w > ScrW() then x = ((maunal and ScrW()) or x) - w end
    if y < 1 then y = 1 end
    if x < 1 then x = 1 end

    self:SetPos(x, y)

    self:MakePopup()
    self:SetVisible(true)
    self:SetKeyboardInputEnabled(false)
end

function PANEL:OptionSelectedInternal(option)
    self:OptionSelected(option, option:GetText())
end

function PANEL:OptionSelected(option, text) end

function PANEL:ClearHighlights()
    for k, pnl in pairs(self:GetCanvas():GetChildren()) do
        pnl.Highlight = nil
    end
end

function PANEL:HighlightItem(item)
    for k, pnl in pairs(self:GetCanvas():GetChildren()) do
        if pnl == item then
            pnl.Highlight = true
        end
    end
end

vgui.Register("PIXEL.Menu", PANEL, "PIXEL.ScrollPanel")
--PATH lua/pixelui/elements/cl_menu_option.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]
local PANEL = {}

AccessorFunc(PANEL, "m_pMenu", "Menu")
AccessorFunc(PANEL, "m_bChecked", "Checked")
AccessorFunc(PANEL, "m_bCheckable", "IsCheckable")

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "TextAlign", "TextAlign", FORCE_NUMBER)
AccessorFunc(PANEL, "Font", "Font", FORCE_STRING)

PIXEL.RegisterFont("UI.MenuOption", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetTextAlign(TEXT_ALIGN_LEFT)
    self:SetFont("UI.MenuOption")
    self:SetChecked(false)

    self.NormalCol = PIXEL.Colors.Transparent
    self.HoverCol = PIXEL.Colors.Scroller

    self.BackgroundCol = PIXEL.CopyColor(self.NormalCol)
end

function PANEL:SetIcon() end

function PANEL:SetSubMenu(menu)
    self.SubMenu = menu
end

function PANEL:AddSubMenu()
    local subMenu = vgui.Create("PIXEL.Menu", self)
    subMenu:SetVisible(false)
    subMenu:SetParent(self)

    self:SetSubMenu(subMenu)

    return subMenu
end

function PANEL:OnCursorEntered()
    local parent = self.ParentMenu
    if not IsValid(parent) then parent = self:GetParent() end
    if not IsValid(parent) then return end

    if not parent.OpenSubMenu then return end
    parent:OpenSubMenu(self, self.SubMenu)
end

function PANEL:OnCursorExited() end

function PANEL:Paint(w, h)
    self.BackgroundCol = PIXEL.LerpColor(FrameTime() * 12, self.BackgroundCol, self:IsHovered() and self.HoverCol or self.NormalCol)

    surface.SetDrawColor(self.BackgroundCol)
    surface.DrawRect(0, 0, w, h)

    PIXEL.DrawSimpleText(self:GetText(), self:GetFont(), PIXEL.Scale(14), h / 2, PIXEL.Colors.PrimaryText, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    if not self.SubMenu then return end
    local dropBtnSize = PIXEL.Scale(8)
    PIXEL.DrawImage(w - dropBtnSize - PIXEL.Scale(6), h / 2 - dropBtnSize / 2, dropBtnSize, dropBtnSize, "https://pixel-cdn.lythium.dev/i/ce2kyfb88", PIXEL.Colors.PrimaryText)
end

function PANEL:OnPressed(mousecode)
    self.m_MenuClicking = true
end

function PANEL:OnReleased(mousecode)
    if not self.m_MenuClicking and mousecode == MOUSE_LEFT then return end
    self.m_MenuClicking = false
    CloseDermaMenus()
end

function PANEL:DoRightClick()
    if self:GetIsCheckable() then
        self:ToggleCheck()
    end
end

function PANEL:DoClickInternal()
    if self:GetIsCheckable() then
        self:ToggleCheck()
    end

    if not self.m_pMenu then return end
    self.m_pMenu:OptionSelectedInternal(self)
end

function PANEL:ToggleCheck()
    self:SetChecked(not self:GetChecked())
    self:OnChecked(self:GetChecked())
end

function PANEL:OnChecked(enabled) end

function PANEL:CalculateWidth()
    PIXEL.SetFont(self:GetFont())
    return PIXEL.GetTextSize(self:GetText()) + PIXEL.Scale(34)
end

function PANEL:PerformLayout(w, h)
    self:SetSize(math.max(self:CalculateWidth(), self:GetWide()), PIXEL.Scale(32))
end

vgui.Register("PIXEL.MenuOption", PANEL, "PIXEL.Button")

PANEL = {}

AccessorFunc(PANEL, "ConVar", "ConVar")
AccessorFunc(PANEL, "ValueOn", "ValueOn")
AccessorFunc(PANEL, "ValueOff", "ValueOff")

function PANEL:Init()
    self:SetChecked(false)
    self:SetIsCheckable(true)
    self:SetValueOn("1")
    self:SetValueOff("0")
end

function PANEL:Think()
    if not self.ConVar then return end
    self:SetChecked(GetConVar(self.ConVar):GetString() == self.ValueOn)
end

function PANEL:OnChecked(checked)
    if not self.ConVar then return end
    RunConsoleCommand(self.ConVar, checked and self.ValueOn or self.ValueOff)
end

vgui.Register("PIXEL.MenuOptionCVar", PANEL, "PIXEL.MenuOption")
--PATH lua/pixelui/elements/cl_property_sheet.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "m_sText", "Text")
AccessorFunc(PANEL, "m_pPropertySheet", "PropertySheet")
AccessorFunc(PANEL, "m_pPanel", "Panel")

PIXEL.RegisterFont("UI.Tab", "Open Sans Bold", 16)

function PANEL:Init()
	self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, -4)
	self.SelectedCol = PIXEL.Colors.Primary
	self.UnselectedTextCol = PIXEL.Colors.SecondaryText
	self.SelectedTextCol = PIXEL.Colors.PrimaryText

	self.Color = PIXEL.CopyColor(self.BackgroundCol)
	self.TextColor = PIXEL.CopyColor(self.UnselectedTextCol)
end

function PANEL:Setup(text, propertySheet, panel)
	self:SetText(text)
	self:SetPropertySheet(propertySheet)
	self:SetPanel(panel)

	PIXEL.SetFont("UI.Tab")
	self:SetWide(PIXEL.GetTextSize(text) + PIXEL.Scale(16))
end

function PANEL:IsActive()
	return self:GetPropertySheet():GetActiveTab() == self
end

function PANEL:DoClick()
	self:GetPropertySheet():SetActiveTab(self)
end

function PANEL:GetTabHeight()
	return PIXEL.Scale(24)
end

function PANEL:DragHoverClick(hoverTime)
	self:DoClick()
end

function PANEL:DoRightClick()
	if not IsValid(self:GetPropertySheet()) then return end

	local tabs = vgui.Create("PIXEL.Menu", self)

	for k, v in pairs(self:GetPropertySheet().Items) do
		if not v or not IsValid(v.Tab) or not v.Tab:IsVisible() then continue end

		tabs:AddOption(v.Tab:GetText(), function()
			if not v or not IsValid(v.Tab) or not IsValid(self:GetPropertySheet()) or not IsValid(self:GetPropertySheet().tabScroller) then return end
			v.Tab:DoClick()
			self:GetPropertySheet().tabScroller:ScrollToChild(v.Tab)
		end)
	end

	tabs:Open()
end

function PANEL:Paint(w, h)
	self.Color = PIXEL.LerpColor(FrameTime() * 12, self.Color, (self:IsActive() or self:IsHovered()) and self.SelectedCol or self.BackgroundCol)
	self.TextColor = PIXEL.LerpColor(FrameTime() * 12, self.TextColor, (self:IsActive() or self:IsHovered()) and self.SelectedTextCol or self.UnselectedTextCol)

	PIXEL.DrawRoundedBoxEx(PIXEL.Scale(6), 0, 0, w, h, self.Color, true, true)
	PIXEL.DrawSimpleText(self:GetText(), "UI.Tab", w * .5, h * .5, self.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

vgui.Register("PIXEL.Tab", PANEL, "PIXEL.Button")


PANEL = {}

AccessorFunc(PANEL, "m_pActiveTab", "ActiveTab")
AccessorFunc(PANEL, "m_iPadding", "Padding")
AccessorFunc(PANEL, "m_fFadeTime", "FadeTime")

function PANEL:Init()
	self.tabScroller = vgui.Create("DHorizontalScroller", self)
	self.tabScroller:SetOverlap(PIXEL.Scale(5))
	self.tabScroller:Dock(TOP)
	self.tabScroller:DockMargin(PIXEL.Scale(3), 0, PIXEL.Scale(3), 0)

	self:SetFadeTime(0.1)
	self:SetPadding(PIXEL.Scale(8))

	self.animFade = Derma_Anim("Fade", self, self.CrossFade)

	self.Items = {}

	self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 2)
end

function PANEL:AddSheet(label, panel, material, noStretchX, noStretchY, tooltip)
	if not IsValid(panel) then
		ErrorNoHalt("PIXEL.PropertySheet:AddSheet tried to add invalid panel!")
		debug.Trace()
		return
	end

	local sheet = {}

	sheet.Name = label

	sheet.Tab = vgui.Create("PIXEL.Tab", self)
	sheet.Tab:SetTooltip(tooltip)
	sheet.Tab:Setup(label, self, panel, material)

	sheet.Panel = panel
	sheet.Panel.NoStretchX = noStretchX
	sheet.Panel.NoStretchY = noStretchY
	sheet.Panel:SetPos(self:GetPadding(), PIXEL.Scale(24) + self:GetPadding())
	sheet.Panel:SetVisible(false)

	panel:SetParent(self)

	table.insert(self.Items, sheet)

	if not self:GetActiveTab() then
		self:SetActiveTab(sheet.Tab)
		sheet.Panel:SetVisible(true)
	end

	self.tabScroller:AddPanel(sheet.Tab)

	return sheet
end

function PANEL:SetActiveTab(active)
	if not IsValid(active) or self.m_pActiveTab == active then return end

	if IsValid(self.m_pActiveTab) then
		self:OnActiveTabChanged(self.m_pActiveTab, active)

		if self:GetFadeTime() > 0 then
			self.animFade:Start(self:GetFadeTime(), {OldTab = self.m_pActiveTab, NewTab = active})
		else
			self.m_pActiveTab:GetPanel():SetVisible(false)
		end
	end

	self.m_pActiveTab = active
	self:InvalidateLayout()
end

function PANEL:OnActiveTabChanged(old, new) end

function PANEL:Think()
	self.animFade:Run()
end

function PANEL:GetItems()
	return self.Items
end

function PANEL:CrossFade(anim, delta, data)
	if not data or not IsValid(data.OldTab) or not IsValid(data.NewTab) then return end

	local old = data.OldTab:GetPanel()
	local new = data.NewTab:GetPanel()

	if not IsValid(old) and not IsValid(new) then return end

	if anim.Finished then
		if IsValid(old) then
			old:SetAlpha(255)
			old:SetZPos(0)
			old:SetVisible(false)
		end

		if IsValid(new) then
			new:SetAlpha(255)
			new:SetZPos(0)
			new:SetVisible(true)
		end

		return
	end

	if anim.Started then
		if IsValid(old) then
			old:SetAlpha(255)
			old:SetZPos(0)
		end

		if IsValid(new) then
			new:SetAlpha(0)
			new:SetZPos(1)
		end
	end

	if IsValid(old) then
		old:SetVisible(true)
		if not IsValid(new) then old:SetAlpha(255 * (1 - delta)) end
	end

	if IsValid(new) then
		new:SetVisible(true)
		new:SetAlpha(255 * delta)
	end
end

function PANEL:PerformLayout()
	local activeTab = self:GetActiveTab()
	local padding = self:GetPadding()

	if not IsValid(activeTab) then return end

	activeTab:InvalidateLayout(true)

	self.tabScroller:SetTall(activeTab:GetTall())

	local activePanel = activeTab:GetPanel()

	for k, v in pairs(self.Items) do
		if v.Tab:GetPanel() == activePanel then
			if IsValid(v.Tab:GetPanel()) then v.Tab:GetPanel():SetVisible(true) end
			v.Tab:SetZPos(100)
		else
			if IsValid(v.Tab:GetPanel()) then v.Tab:GetPanel():SetVisible(false) end
			v.Tab:SetZPos(1)
		end
	end

	if IsValid(activePanel) then
		if not activePanel.NoStretchX then
			activePanel:SetWide(self:GetWide() - padding * 2)
		else
			activePanel:CenterHorizontal()
		end

		if not activePanel.NoStretchY then
			local _, y = activePanel:GetPos()
			activePanel:SetTall(self:GetTall() - y - padding)
		else
			activePanel:CenterVertical()
		end

		activePanel:InvalidateLayout()
	end

	self.animFade:Run()
end

function PANEL:SizeToContentWidth()
	local wide = 0

	for k, v in pairs(self.Items) do
		if IsValid(v.Panel) then
			v.Panel:InvalidateLayout(true)
			wide = math.max(wide, v.Panel:GetWide() + self:GetPadding() * 2)
		end
	end

	self:SetWide(wide)
end

function PANEL:SwitchToName(name)
	for k, v in pairs(self.Items) do
		if v.Name == name then
			v.Tab:DoClick()
			return true
		end
	end

	return false
end

function PANEL:CloseTab(tab, removePanelToo)
	for k, v in pairs(self.Items) do
		if v.Tab ~= tab then continue end
		table.remove(self.Items, k)
	end

	for k, v in pairs(self.tabScroller.Panels) do
		if v ~= tab then continue end
		table.remove(self.tabScroller.Panels, k)
	end

	self.tabScroller:InvalidateLayout(true)

	if tab == self:GetActiveTab() then
		self.m_pActiveTab = self.Items[#self.Items].Tab
	end

	local pnl = tab:GetPanel()
	if removePanelToo then
		pnl:Remove()
	end

	tab:Remove()

	self:InvalidateLayout(true)

	return pnl
end

function PANEL:Paint(w, h)
	local activeTab = self:GetActiveTab()
	local offset = activeTab and activeTab:GetTall() or 0

	PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, offset, w, h - offset, self.BackgroundCol)
end

vgui.Register("PIXEL.PropertySheet", PANEL, "Panel")
--PATH lua/pixelui/menus/cl_message_popup.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_ssearchbar.lua:
local PANEL = {}

local maincolor_15, accentcolor, margin = slib.getTheme("maincolor", 15), slib.getTheme("accentcolor"), slib.getTheme("margin")

function PANEL:Init()
    self:Dock(TOP)
    self:SetTall(slib.getScaledSize(25, "y"))
    self.font = slib.createFont("Roboto", 15)
    self.material = Material("slib/icons/search32.png", "noclamp smooth")
    self.bg = maincolor_15

    self.entry = vgui.Create( "STextEntry", self )
    self.entry:Dock(FILL)

    slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "SetWide", nil, function() return self end, true)
end

function PANEL:addIcon()
    self.icon = true
    self.entry:DockMargin(slib.getScaledSize(25, "y") + margin,0,0,0)
    self.entry:AccentSideLine(true)
    
    return self
end

function PANEL:SetPlaceholder(str)
    self.entry:SetPlaceholder(str)
end

function PANEL:Paint(w,h)
    local size = h * .65
    local pos = h * .5 - (size * .5)

    if self.bg then
        surface.SetDrawColor(self.bg)
        surface.DrawRect(0, 0, w, h)
    end

    local wantedcolor = accentcolor
    wantedcolor.a = self.entry:HasFocus() and 120 or 20

    surface.SetDrawColor(slib.lerpColor(self, wantedcolor))
    surface.DrawRect(h - 1, margin, 1, h - (margin * 2))

    if self.icon then
        surface.SetDrawColor(color_white)
        surface.SetMaterial(self.material)
        surface.DrawTexturedRect(pos, pos, size, size)
    end
end

vgui.Register("SSearchBar", PANEL, "EditablePanel")
--PATH lua/slib/vgui/cl_stextentry.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_gprotect_config.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_gprotect.lua:
gProtect = gProtect or {}
gProtect.language = gProtect.language or {}

gProtect.PropClasses = {
	["prop_physics"] = true,
	["prop_physics_multiplayer"] = true,
	["prop_static"] = true
}

local cachedSID = {}

local function getBySteamID(sid)
	if cachedSID[sid] and IsValid(cachedSID[sid]) then return cachedSID[sid] end
	for k,v in ipairs(player.GetAll()) do
		if !IsValid(v) then continue end
		if v:SteamID() == sid then
			cachedSID[sid] = v
			return v
		end
	end
end

gProtect.GetOwner = function(ent)
	if !IsValid(ent) then return end
	
	local result = ent.gPOwner or ""
	local foundply = getBySteamID(result)
	
	foundply = !isstring(foundply) and (IsValid(foundply) and foundply:IsPlayer() and foundply) or foundply

	return (foundply and foundply) or nil
end

gProtect.GetHighestTargetPlayerOwnerPropsGroupLevel = function(ply)
    local groupLevels = gProtect.TouchPermission and gProtect.TouchPermission["targetPlayerOwnedPropsGroupLevel"] and gProtect.TouchPermission["targetPlayerOwnedPropsGroupLevel"]["weapon_physgun"] or {}
    local usergroup = ply:GetUserGroup()
    local secondaryUsergroup = ply.GetSecondaryUserGroup and ply:GetSecondaryUserGroup()

	local userGroupLevel = tonumber(groupLevels[usergroup])
	local secondaryUserGroupLevel = tonumber(groupLevels[secondaryUsergroup])

    if table.IsEmpty(groupLevels) or (!userGroupLevel and !secondaryUserGroupLevel) then return 0 end

	if !secondaryUserGroupLevel then return userGroupLevel end
	if !userGroupLevel then return secondaryUserGroupLevel end

    return math.max(userGroupLevel, secondaryUserGroupLevel)
end

gProtect.GetOwnerString = function(ent)
	return IsValid(ent) and ent.gPOwner or ""
end

gProtect.HasPermission = function(ply, perm)
	local usergroup, result = ply:GetUserGroup(), false

	if gProtect.config.Permissions[perm][usergroup] then return true end

	if CAMI and isfunction(CAMI.PlayerHasAccess) then
		if CAMI.PlayerHasAccess(ply, perm, function(cbResult)
			result = cbResult
		end) then
			return true
		end
	end

	return result
end

gProtect.HandlePermissions = function(ply, ent, permission)
	if (!IsValid(ent) and !ent:IsWorld()) or !IsValid(ply) or !ply:IsPlayer() then return false end

	local owner = gProtect.GetOwner(ent)
	local weapon = permission and permission or IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() or "weapon_physgun"
	local ownsid = isstring(owner) and owner or IsValid(owner) and owner:SteamID() or ""

	if gProtect.IsBuddyWithOwner(ent, ply, weapon) then
		return true
	end
	
	if ent:IsWorld() then return nil end

	if gProtect.TouchPermission then
		local isProp = gProtect.PropClasses[ent:GetClass()]
		local isOwnerValidPlayer = owner and IsValid(owner) and owner:IsPlayer()
		local touchTable

		if isOwnerValidPlayer then
			touchTable = isProp and gProtect.TouchPermission["targetPlayerOwnedProps"] or gProtect.TouchPermission["targetPlayerOwned"]
		else
			touchTable = gProtect.TouchPermission["targetWorld"]
		end

		if touchTable and touchTable[weapon] then
			touchTable = touchTable[weapon]
		end

		if !touchTable then return false end

		local hasTargetPerms = touchTable and touchTable["*"] or touchTable[ply:GetUserGroup()]
		local passesGroupLevelCheck = true

		if hasTargetPerms and isProp and isOwnerValidPlayer then
			local highestGroupLevel = gProtect.GetHighestTargetPlayerOwnerPropsGroupLevel(ply)
			local ownerHighestGroupLevel = gProtect.GetHighestTargetPlayerOwnerPropsGroupLevel(owner)

			if highestGroupLevel < ownerHighestGroupLevel then
				passesGroupLevelCheck = false
			end
		end

		if hasTargetPerms and passesGroupLevelCheck then return true end
	end
	
	return false, true
end

gProtect.IsBuddyWithOwner = function(ent, ply, permission)
    local owner = gProtect.GetOwner(ent)

    if !owner then return false end

    if ply == owner then return true end

    local ownsid = isstring(owner) and owner or IsValid(owner) and owner:SteamID()

    if !ownsid then return false end
    
    if gProtect.TouchPermission[ownsid] and gProtect.TouchPermission[ownsid][permission] and istable(gProtect.TouchPermission[ownsid][permission]) and gProtect.TouchPermission[ownsid][permission][ply:SteamID()] then
        return true
    end
end

local cfg = SERVER and gProtect.getConfig(nil, "physgunsettings") or {}

hook.Add("PhysgunPickup", "gP:PhysgunPickupLogic", function(ply, ent, norun)
	if SERVER and !cfg.enabled or ent:IsPlayer() then return nil end
	if TCF and TCF.Config and ent:GetClass() == "cocaine_cooking_pot" and IsValid( ent:GetParent() ) then return nil end --- Compatibilty with "The Cocaine Factory".

	--- This checks for config options that only the server can access.
	if SERVER and gProtect.HandlePhysgunPermission(ply, ent) == false then return false end

	return gProtect.HandlePermissions(ply, ent, "weapon_physgun")
end )

hook.Add("gP:ConfigUpdated", "gP:UpdatePhysgunSH", function(updated)
	if updated ~= "physgunsettings" or CLIENT then return end
	cfg = gProtect.getConfig(nil, "physgunsettings")
end)

local function registerPerm(name)
	if CAMI and isfunction(CAMI.RegisterPrivilege) then CAMI.RegisterPrivilege({Name = name, hasAccess = false, callback = function() end}) end
end

registerPerm("gProtect_Settings")
registerPerm("gProtect_StaffNotifications")
registerPerm("gProtect_DashboardAccess")
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_polish.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/cl_main.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/cl_main.lua:
//
/*
	Smart Spawn Manager Clientside Main 
	5/12/2018
	Author: Smart ( Badass Development )
*/

include("cl_menu.lua");
local notify = include("plugins/sh_notify.lua");

local main = {};
main.playerSpawnPoints = {};
main.entitySpawnPoints = {};
main.modelCache	= {}; // stores model paths 
main.clientModelCache = {}; // stores clientside models 
main.bRenderActive	= false;

/*
	Receives a net message from the server for spawn data 
	This allows the client to render such data 
*/

function main.ReceiveSpawnData(len)

	local dataBuffer = net.ReadTable();
	main.bRenderActive = dataBuffer.bActive;

	main.playerSpawnPoints = dataBuffer.playerSpawnPoints;
	main.entitySpawnPoints = dataBuffer.entitySpawnPoints;
	main.modelCache = dataBuffer.modelCache;
	
	for class,model in next, main.modelCache do 
	
		main.clientModelCache[class] = ClientsideModel(model);
		main.clientModelCache[class]:SetNoDraw(true);
		main.clientModelCache[class]:SetMaterial("models/wireframe");
	end
end
net.Receive("smartspawn_spawndata", main.ReceiveSpawnData);

/*
	Renders spawn locations 
*/

local playerModel = ClientsideModel("models/Humans/Group03/Male_05.mdl");
playerModel:SetNoDraw(true);
playerModel:SetMaterial("models/wireframe");

function main.RenderSpawns()

	if (!main.bRenderActive) then return end

	local ang = EyeAngles() - Angle(0,90,0);
	ang.p = 0;
	ang.r = 90;
	
	local myPos = LocalPlayer():GetPos();
	
	for teamName, spawnTable in next, main.playerSpawnPoints do 
	
		for uniqueID, spawnPos in next, spawnTable do 
			
			if (spawnPos:Distance(myPos) > smartspawn_config.spawnRenderRadius) then continue end
			
			playerModel:SetPos(spawnPos);
			playerModel:SetupBones();
			playerModel:DrawModel();
			
			cam.Start3D2D(spawnPos + Vector(0, 0, 80), ang, 0.3);
			
				draw.SimpleTextOutlined(teamName .. " | " .. uniqueID, "smartspawn_font_large", 0, 0, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, color_black);
			cam.End3D2D();	
		end
	end
	
	for class, spawnTable in next, main.entitySpawnPoints do 
		if (main.clientModelCache[class] == nil) then continue end 
		for uniqueID, spawn in next, spawnTable do 
		
			if (spawn.pos:Distance(myPos) > smartspawn_config.spawnRenderRadius) then continue end
		
			main.clientModelCache[class]:SetPos(spawn.pos);
			main.clientModelCache[class]:SetAngles(spawn.ang || Angle(0, 0, 0));
			main.clientModelCache[class]:SetupBones();
			main.clientModelCache[class]:DrawModel();
						
			cam.Start3D2D(spawn.pos + Vector(0, 0, 40), ang, 0.2);
			 
				draw.SimpleTextOutlined(class  .. " | " .. uniqueID, "smartspawn_font_large", 0, 0, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, color_black);
				draw.SimpleTextOutlined("Delay: " .. spawn.delay .. "s", "smartspawn_font_large", 0, 25, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, color_black);
				draw.SimpleTextOutlined("Limit: " .. spawn.limit, "smartspawn_font_large", 0, 50, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, color_black);
			cam.End3D2D();	
		end 
	end
end 
hook.Add("PostDrawTranslucentRenderables", "smartspawn_renderspawns", main.RenderSpawns);

--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/cl_menu.lua:
return gluapack()()
--PATH lua/autorun/snx_statuseffects.lua:
if SERVER then AddCSLuaFile() end

GMSNX = {}
GMSNX.StatusEffects = {
	["heal"] = {
		["string"] = "Healing",
		["function"] =
			function(target, dealer, effect, duration, amount)
				local mult
				if target == dealer then
					mult = 0.25
				else
					mult = 1
				end
				local hpam = amount*mult
				local hpdur = duration
				local hptick = (amount/duration)*mult

				local HealAmount
				for i = 1, hpdur*hptick do
					timer.Simple(i/hptick, function()
						if !target:IsValid() then return end
						local futureheal = ( hpam/hpdur )/hptick

						if (target:GetMaxHealth()*2) - target:Health() >= futureheal then
							HealAmount = futureheal
						else
							HealAmount = ((target:GetMaxHealth()*2) - target:Health())
						end

						target:SetHealth( target:Health() + HealAmount )
					end)
				end

				if effect then
					local ED_Heal = EffectData()
					ED_Heal:SetOrigin( target:GetPos() )
					ED_Heal:SetEntity( target )
					ED_Heal:SetMagnitude( hpam )
					ED_Heal:SetScale( hpdur )
					util.Effect("snx_passive_heal", ED_Heal, true, true)
				end
			end
		},
	["stun"] = {
		["string"] = "Stun",
		["function"] =
			function(target, dealer, effect, duration)
				local function RemoveFrozen(target)
					if target:IsValid() then
						target.SNXStatFrozen = false

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.IN, Color( 0, 0, 0, 0 ), 0.4, 0.2 )
							target:Freeze( false )
						elseif target:IsNPC() then
							target:SetCondition( 68 )
							if target:Health() < 1 then
								target:SetNPCState(7)
							end
						end
					end
				end

				if ((target:IsPlayer() and target ~= dealer) or target:IsNPC()) then
					if target.SNXStatFrozen then
						if target:Health() < 1 then
							RemoveFrozen(target)
						end
					else
						target.SNXStatFrozen = true

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.OUT, Color( 0, 200, 255, 0 ), 0.2, 2.5 )
							target:Freeze( true ) 
						elseif target:IsNPC() then
							target:SetSchedule( SCHED_NPC_FREEZE )
							target:StopMoving()
						end

						timer.Simple( duration, function()
							RemoveFrozen(target)
						end )
					end

					if effect then
						local ED_Stun = EffectData()
						ED_Stun:SetOrigin( target:GetPos() )
						ED_Stun:SetEntity( target )
						ED_Stun:SetScale( duration )
						util.Effect("snx_passive_stun", ED_Stun, true, true)
					end
				end
			end
		},
	["poison"] = {
		["string"] = "Poison",
		["function"] =
			function(target, dealer, effect, duration, damage)
				if !(target:IsPlayer() or target:IsNPC()) then return false end
				local tick = damage/duration
				if target:IsPlayer() then
					local playerdead = false
				end
				for i = 1, duration do
					timer.Simple(i-1, function()
						if target:IsPlayer() then
							if !target:Alive() then 
								playerdead = true
							end
							if playerdead then return end
						end
						if !target:IsValid() then return end
						local futdmg = ( damage/duration )
						target:TakeDamage(futdmg, dealer, dealer)
					end)
				end

				if effect then
					local ED_Poison = EffectData()
					ED_Poison:SetOrigin( target:GetPos() )
					ED_Poison:SetEntity( target )
					ED_Poison:SetMagnitude( damage )
					ED_Poison:SetScale( duration )
					util.Effect("snx_passive_poison", ED_Poison, true, true)
				end

			end
		},
}

function GMSNX:AddStatus(target, dealer, type, a, b, c)
	if target:IsPlayer() or target:IsNPC() then
		GMSNX.StatusEffects[type]["function"](target, dealer, c, a, b)
	end
end
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/sh_sreward_config.lua:
-- Discord Tutorial:
-- 1. https://discord.com/developers/applications - Create a new application!
-- 2. Copy and fill in client_id [sh_config]
-- 3. Copy and fill in client_secret [sv_config]
-- 4. Enable Developer Mode in discord [Enabling Developer Mode is easy. Open your Discord settings (the next to your name at the bottom left) and click on Appearance. There you will find Developer Mode. Click the toggle to enable it.] - https://discordia.me/en/developer-mode
-- 5. Right Click Discord Server and press Copy ID and fill that into the guild_id [sh_config]
-- 6. Create a permanent invite link and add the end of the url into invite_id [sh_config]
-- 7. Enter the bot tab in your discord application and copy token into the bot_token [sv_config]
-- 8. Go into OAuth2 tab of the discord application and add a redirect link, example commuinity website
-- 9. Invite the bot to the server by using this link! [https://discordapp.com/api/oauth2/authorize?client_id=CLIENTIDHERE&permissions=8&response_type=code&scope=bot%20guilds]

-- Steam Tutorial:
-- 1. Add group_name, you can find it in the end of group link! Example: https://steamcommunity.com/groups/*GROUP_NAME* [sh_config]
-- 2. Setup a name tag, can be anything you see suited. [sh_config]
-- 3. Add steam api_key, you can find it here [https://steamcommunity.com/dev/apikey] [sv_config]
-- 4. Add steam group_id, to find it you need to press edit on your steam group.
-- Link: https://steamcommunity.com/groups/*GROUP_NAME*/edit then near the top it will say ID.
-- Copy and paste this ID into group_id [sv_config]

sReward = sReward or {}
sReward.config = sReward.config or {}
sReward.config["discord"] = sReward.config["discord"] or {} -- There is more to do in the sv_sreward_config file!
sReward.config["steam"] = sReward.config["steam"] or {} -- There is more to do in the sv_sreward_config file!

--  _______       _          _______              ___ _       
-- (_______)     (_)        (_______)            / __|_)      
--  _  _  _ _____ _ ____     _       ___  ____ _| |__ _  ____ 
-- | ||_|| (____ | |  _ \   | |     / _ \|  _ (_   __) |/ _  |
-- | |   | / ___ | | | | |  | |____| |_| | | | || |  | ( (_| |
-- |_|   |_\_____|_|_| |_|   \______)___/|_| |_||_|  |_|\___ |
--                                                     (_____|

sReward.config["language"] = "pl"

sReward.config["prefix"] = "[sReward] "

sReward.config["size"] = { -- Size of the reward menu
    w = 670, -- Width (def. 670)
    h = 520 -- Height (def. 520)
}

sReward.config["steam"]["group_name"] = "" -- Custom URL
sReward.config["steam"]["name_tag"] = {"example.gg"} -- You can add multiple in here!

sReward.config["discord"]["client_id"] = "1351279894465876070"  -- Look uptop for information!
sReward.config["discord"]["invite_id"] = "pixelmod"
sReward.config["discord"]["guild_id"] = "692520877664763995"

sReward.config["max_referrals"] = 1

sReward.config["open_on_join"] = true

sReward.config["receive_referral_reward"] = { -- This is what you receive for referring someone.
    ["sr_tokens"] = 150,
    ["darkrp_money"] = 400
}

sReward.config["give_referral_reward"] = { -- This is what you receive for referring.
    ["sr_tokens"] = 100,
    ["darkrp_money"] = 200
}

sReward.config["permissions"] = {
    ["sReward_AdminMenu"] = {
        ["superadmin"] = true,
        ["owner"] = true,
    },
    ["sReward_AddTokenCommand"] = {
        ["superadmin"] = false,
        ["owner"] = false,
    }
}

sReward.config["enabled_tabs"] = { -- You can disable/enable tabs in here.
    ["tasks"] = true,
    ["referral"] = false,
    ["shop"] = false,
    ["leaderboard"] = true
}


--  ______                             _      
-- (_____ \                           | |     
--  _____) )_____ _ _ _ _____  ____ __| | ___ 
-- |  __  /| ___ | | | (____ |/ ___) _  |/___)
-- | |  \ \| ____| | | / ___ | |  ( (_| |___ |
-- |_|   |_|_____)\___/\_____|_|   \____(___/ 

sReward.config["rewards"] = { -- This is where you can configure your rewards.
    {
        enabled = false,
        name = "Steam Group",
        instruction = "Join our steamgroup, press this button to get redirected to our steam group!",
        funcname = "VerifySteamGroup",
        instructionFunc = function() gui.OpenURL("https://steamcommunity.com/groups/"..sReward.config["steam"]["group_name"]) end,
        maxuse = 1,
        cooldown = 0,
        net_cd = 5,
        reward = {
            ["sr_tokens"] = 150,
            ["darkrp_money"] = 30000,
        },
        -- custom = function(ply)
        --     Anything custom in here!
        -- end
    },
    {
        enabled = false,
        name = "Steam Name",
        instruction = "Add our tag to your steam name, press this button to copy the tag to clipboard!",
        funcname = "VerifySteamNameTag",
        instructionFunc = function()
            SetClipboardText(sReward.config["steam"]["name_tag"][1])
            slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "copied_clipboard"))
        end,
        maxuse = 0, -- Lets allow them to use it daily!
        cooldown = 86400, -- One day!
        net_cd = 3,
        reward = {
            ["sr_tokens"] = 20,
            ["darkrp_money"] = 15000,
        }
    },
    {
        enabled = true,
        name = "Join Discord",
        funcname = "VerifyDiscordJoin",
        instruction = "Join our discord, press this button to get redirected to discord!",
        instructionFunc = function() gui.OpenURL("https://discord.gg/"..sReward.config["discord"]["invite_id"]) end,
        maxuse = 0, -- Lets allow them to use it daily!
        cooldown = 86400, -- One day!
        net_cd = 5,
        reward = {
            ["sr_tokens"] = 150,
            ["darkrp_money"] = 40000,
        }
    },
    {
        enabled = true,
        name = "Discord Boost",
        funcname = "VerifyDiscordBoost",
        instruction = "Boost our discord, then verify!",
        instructionFunc = function() gui.OpenURL("https://discord.gg/"..sReward.config["discord"]["invite_id"]) end,
        maxuse = 0, -- Lets allow them to use it daily!
        cooldown = 86400, -- One day!
        net_cd = 5,
        reward = {
            ["sr_tokens"] = 50,
            ["darkrp_money"] = 30000,
        }
    },
    {
        enabled = true,
        name = "Daily Login",
        instruction = "Come back daily to receive some rewards!",
        maxuse = 0, -- Lets allow them to use it daily!
        cooldown = 86400, -- One day!
        net_cd = 5,
        reward = {
            ["sr_tokens"] = 10,
            ["darkrp_money"] = 30000,
        }
    },
    {
        enabled = true,
        name = "1 Week Playtime",
        auto_claim = true,
        instruction = "Get rewarded for spending time on the server!",
        maxuse = 1,
        customCheck = function(ply)
            return sReward.CheckAllPlaytimes(ply, 604800) -- The number behind is 
        end,
        customCheckMsg = "You need atleast 1 week playtime to claim this reward!",
        net_cd = .5,
        reward = {
            ["sr_tokens"] = 20,
            ["darkrp_money"] = 50000,
        }
    },
}


--   ______ _                 
--  / _____) |                
-- ( (____ | |__   ___  ____  
--  \____ \|  _ \ / _ \|  _ \ 
--  _____) ) | | | |_| | |_| |
-- (______/|_| |_|\___/|  __/ 
--                     |_|    

sReward.config["shop"] = { -- These are examples, also you dont really need these as you can add items from the admin menu!
    [1] = {
        enabled = true,
        name = "VIP Rank",
        imgurid = "kMut76q",
        price = 200,
        reward = {
            ["reward_rank"] = "vip"
        }
    },
    [2] = {
        enabled = false,
        name = "20$ Gift Card",
        imgurid = "2YVOI55",
        price = 500,
        reward = {
            ["reward_rank"] = "vip"
        }
    },
    [3] = {
        enabled = true,
        name = "Spotify - 1 Month",
        imgurid = "GsS6Vg0",
        price = 400,
        reward = {
            ["coupon"] = "Spotify - 1 Month"
        }
    },
    [4] = {
        enabled = false,
        name = "Rocket League - Steam",
        imgurid = "hFIWT0u",
        price = 400,
        reward = {
            ["reward_rank"] = "vip"
        }
    },
    [5] = {
        enabled = false,
        name = "Minecraft - Mojang",
        imgurid = "F9hk4y9",
        price = 300,
        reward = {
            ["reward_rank"] = "vip"
        }
    },
    [6] = {
        enabled = false,
        name = "GTA V - Steam",
        imgurid = "TW38boy",
        price = 500,
        reward = {
            ["reward_rank"] = "vip"
        }
    },
    [7] = {
        enabled = false,
        name = "Cyberpunk 2077 - GOG",
        imgurid = "toU6qwS",
        price = 1300,
        reward = {
            ["reward_rank"] = "vip"
        }
    }
}
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/core/cl_admin_menu.lua:
sReward = sReward or {}
sReward.data = sReward.data or {}
sReward.data["referral"] = sReward.data["referral"] or {}
sReward.data["coupons"] = sReward.data["coupons"] or {}
sReward.data["rewards"] = sReward.data["rewards"] or {}
sReward.data["shop"] = sReward.data["shop"] or {}

sReward.couponNameToKey = sReward.couponNameToKey or {}

local sreward_menu

local white, textcolor, sidebarbttncolor, textcolor_min10, textcolor_min50, accentcolor, maincolor, maincolor_5, maincolor_7, maincolor_10, maincolor_15, successcolor, margin = Color(255,255,255), slib.getTheme("textcolor"), slib.getTheme("sidebarbttncolor"), slib.getTheme("textcolor", -10), slib.getTheme("textcolor", -50), slib.getTheme("accentcolor"), slib.getTheme("maincolor"), slib.getTheme("maincolor", 5), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", 15), slib.getTheme("successcolor"), slib.getTheme("margin")
local failcolor = slib.getTheme("failcolor")

local maincolor_a100 = table.Copy(maincolor)
maincolor_a100.a = 100

local outline = Color(255,255,255,3)

local overlineFont = slib.createFont("Roboto", 13)

local hovercolor = slib.getTheme("hovercolor")
local reward_ico, task_ico, tokens_ico, referral_ico, copy_ico, coupon_ico, smiley_ico, buy_ico, admin_ico, return_ico = Material("sreward/giftbox.png", "smooth"), Material("sreward/checklist.png", "smooth"), Material("sreward/tokens.png", "smooth"), Material("sreward/affiliate.png", "smooth"), Material("sreward/copy.png", "smooth"), Material("sreward/coupon.png", "smooth"), Material("sreward/smiley.png", "smooth"), Material("sreward/buy.png", "smooth"), Material("sreward/admin.png", "smooth"), Material("sreward/back.png", "smooth")
local settings_ico, delete_ico = Material("sreward/gear.png", "smooth"), Material("sreward/delete.png", "smooth")


local function addIconButton(selcol, icon, func, parent)
    local bttn = vgui.Create("SButton", parent)
    bttn.DoClick = function()
        func()
    end

    local hovcol = table.Copy(selcol or white)
    hovcol.a = hovercolor.a

    bttn.Paint = function(s,w,h)
        local icosize = h * .7
        local wantedCol = s:IsHovered() and (selcol or white) or hovcol

        surface.SetDrawColor(slib.lerpColor(s, wantedCol))
        surface.SetMaterial(icon)
        surface.DrawTexturedRect(w * .5 - icosize * .5, h * .5 - icosize * .5, icosize, icosize)
    end

    return bttn
end

local function adminAction(ply, title, placeholder, func)
    local close = vgui.Create("SButton")
    close:MakePopup()
    close:SetSize(ScrW(), ScrH())
    close.Paint = function() end
    close.DoClick = function()
        close:Remove()
    end

    local popup = vgui.Create("SFrame", close)
    :SetSize(slib.getScaledSize(250, "x"),slib.getScaledSize(30 + 20 + 20 , "y") + (margin * 3))
    :setTitle(title)
    :Center()
    :addCloseButton()
    :MakePopup()
    :setBlur(true)

    local wide = popup:GetWide()

    popup.OnRemove = function()
        close:Remove()
    end

    local inputTypes = {
        ["int"] = "STextEntry",
        ["dropdown"] = "SDropDown"
    }

    popup.addInput = function(type)
        local element = vgui.Create(inputTypes[type], popup.frame)
        element:Dock(TOP)
        element:DockMargin(margin, margin, margin, 0)
        element:SetTall(slib.getScaledSize(20, "y"))
        element.placeholder = placeholder
        element.bg = maincolor_10

        if type == "int" then
            element:SetNumeric(true)
            element:SetRefreshRate(0)
        end

        element:SetPlaceholder(placeholder)

        return element
    end


    local submit = vgui.Create("SButton", popup.frame)
    submit:setTitle("Submit")
    submit:SetTall(slib.getScaledSize(20, "y"))
    submit:Dock(BOTTOM)
    submit:DockMargin(margin, margin, margin, margin)
    submit.bg = maincolor_10

    local spaceleft = popup.frame:GetTall() - submit:GetTall() - margin

    submit.DoClick = function()
        func(popup.value)
        popup:Remove()
    end

    return popup
end

local function doAdminAction(target, type, val)
    if !val or val == "" then return end
    net.Start("sR:NetworkingHandeler")
    net.WriteUInt(4,3)
    net.WriteBit(1)
    net.WriteUInt(target:EntIndex(), 16)
    net.WriteUInt(type, 2)
    net.WriteUInt(math.abs(tonumber(val)), 20)
    net.SendToServer()
end

local function addBasicsPage(parent)
    local canvas = vgui.Create("SScrollPanel", parent)
    canvas:Dock(FILL)
    canvas:GetCanvas():DockPadding(margin,0,margin,margin)

    local search = vgui.Create("SSearchBar", parent)
    search:Dock(TOP)
    search:DockMargin(margin,margin,margin,0)
    search:addIcon()
    search.bg = maincolor_7
    search.entry.onValueChange = function(newval)
        for k,v in pairs(canvas:GetCanvas():GetChildren()) do
            if !v.name then continue end
            if !string.find(string.lower(v.name), string.lower(newval)) then
                v:SetVisible(false)
            else
                v:SetVisible(true)
            end

            canvas:GetCanvas():InvalidateLayout(true)
        end
    end

    return canvas, search
end

local intToStorage = {
    [1] = "coupons",
    [2] = "shop"
}

local function networkAdminData(type, key)
    local data = sReward.data[intToStorage[type]][key] and table.Copy(sReward.data[intToStorage[type]][key]) or {}

    net.Start("sR:NetworkingHandeler")
    net.WriteUInt(4, 3)
    net.WriteBit(0)
    net.WriteUInt(type, 2)
    net.WriteString(util.TableToJSON(data))
    net.SendToServer()
end

local function addCoupon(parent, val, new)
    if !val then return end
    local key = sReward.couponNameToKey[val]
    
    local couponData = {name = val, data = {}}
    
    if new then
        key = table.insert(sReward.data["coupons"], couponData)
        sReward.couponNameToKey[val] = key
    end

    if parent[val] and IsValid(parent[val]) then return end

    local coupon = sReward.addMultibox(parent, {
        [1] = {
            title = slib.getLang("sreward", sReward.config["language"], "name"), 
            val = val,
            offset = 0
        },
        [2] = {
            title = slib.getLang("sreward", sReward.config["language"], "coupons"), 
            val = function() return sReward.data["coupons"][key] and sReward.data["coupons"][key].data and table.Count(sReward.data["coupons"][key].data) or 0 end,
            offset = 0.45
        }
    })

    coupon.addButton(slib.getLang("sreward", sReward.config["language"], "delete"), function()
        local popup = vgui.Create("SPopupBox")
        :setTitle(slib.getLang("sreward", sReward.config["language"], "are_you_sure"))
        :setBlur(true)
        :addChoise(slib.getLang("sreward", sReward.config["language"], "no"))
        :addChoise(slib.getLang("sreward", sReward.config["language"], "yes"), function()
            coupon:Remove()
            sReward.data["coupons"][key] = sReward.data["coupons"][key] or {}
            sReward.data["coupons"][key].delete = "confirmed"

            networkAdminData(1, key)
        end)
        :setText(slib.getLang("sreward", sReward.config["language"], "coupon_delete_confirm", val))
    end)

    coupon.addButton(slib.getLang("sreward", sReward.config["language"], "manage"), function()
        local close = vgui.Create("SButton")
        close:MakePopup()
        close:SetSize(ScrW(), ScrH())
        close.Paint = function(s,w,h) end
        close.DoClick = function()
            close:Remove()
        end

        local table_viewer = vgui.Create("STableViewer", close)
        :setTable(sReward.data["coupons"][key].data)
        :addEntry()

        table_viewer:addSearch(table_viewer.viewbox, table_viewer.viewer)
        :MakePopup()

        table_viewer.OnRemove = function()
            if table_viewer.modified then
                sReward.data["coupons"][val] = table_viewer.viewer.tbl
                networkAdminData(1, key)
            end

            if !IsValid(close) then return end
            close:Remove()
        end
    end)

    parent[val] = coupon

    if new then
        networkAdminData(1, key)
    end

    return coupon
end

local function addLabel(parent, txt)
    local font = slib.createFont("Roboto", 14)
    
    surface.SetFont(font)
    local height = select(2, surface.GetTextSize(txt))
    
    local label = vgui.Create("EditablePanel", parent)
    label:Dock(TOP)
    label:DockMargin(0,0,0,margin)
    label:SetTall(height)

    label.Paint = function(s,w,h)
        draw.SimpleText(txt, font, 0, h, textcolor_min50, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
    end

    return label
end

local function manageStoreItem(id)
    local key = id
    local data = {name = "", imgurid = "", price = 0, reward = {}, enabled = true}
    local new = true

    if id then
        data = table.Copy(sReward.data["shop"][id])
        data.oldname = data.name
        new = false
    end

    if new then
        key = table.insert(sReward.data["shop"], data)
        data = sReward.data["shop"][key]
    end

    local close = vgui.Create("SButton")
    close:MakePopup()
    close:SetSize(ScrW(), ScrH())
    close.Paint = function(s,w,h) end
    close.DoClick = function()
        close:Remove()
    end

    local store_management = vgui.Create("SFrame", close)
    :SetSize(slib.getScaledSize(230, "x"), 0)
    :setTitle(slib.getLang("sreward", sReward.config["language"], "manage_item"))
    :Center()
    :addCloseButton()
    :MakePopup()
    :setBlur(true)

    store_management.OnRemove = function()
        if !IsValid(close) then return end
        close:Remove()
    end

    store_management.frame:DockPadding(margin, margin, margin, margin)

    addLabel(store_management.frame, slib.getLang("sreward", sReward.config["language"], "name"))

    local name = vgui.Create("STextEntry", store_management.frame)
    :Dock(TOP)
    :DockMargin(0,0,0,margin * 2)

    name.bg = maincolor_7
    name:SetPlaceholder(slib.getLang("sreward", sReward.config["language"], "insert_name"))

    name.onValueChange = function(val)
        data.name = val
    end

    if data.name ~= "" then
        name:SetValue(data.name)
    end

    addLabel(store_management.frame, slib.getLang("sreward", sReward.config["language"], "price"))

    local price = vgui.Create("STextEntry", store_management.frame)
    :Dock(TOP)
    :DockMargin(0,0,0,margin * 2)

    price.bg = maincolor_7
    price:SetPlaceholder(slib.getLang("sreward", sReward.config["language"], "insert_price"))
    price:SetNumeric(true)

    price.onValueChange = function(val)
        data.price = val
    end

    if data.price ~= "" then
        price:SetValue(data.price)
    end

    addLabel(store_management.frame, slib.getLang("sreward", sReward.config["language"], "imgur_id"))

    local imgurid = vgui.Create("STextEntry", store_management.frame)
    :Dock(TOP)
    :DockMargin(0,0,0,margin)

    imgurid.bg = maincolor_7
    imgurid:SetPlaceholder(slib.getLang("sreward", sReward.config["language"], "insert_imgur_id"))

    local imgur_id = ""

    imgurid.onValueChange = function(val)
        imgur_id = val
        data.imgurid = val
    end

    if data.imgurid ~= "" then
        imgurid:SetValue(data.imgurid)
        imgur_id = data.imgurid
    end

    local imgur_prev = vgui.Create("EditablePanel", store_management.frame)
    imgur_prev:Dock(TOP)
    imgur_prev:SetTall(slib.getScaledSize(90, "y"))
    imgur_prev.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_7)
        surface.DrawRect(0,0,w,h)
        
        local ico, loading = slib.ImgurGetMaterial(imgur_id)
        
        if !loading then
            surface.SetDrawColor(white)
            surface.SetMaterial(ico)
            surface.DrawTexturedRect(margin, margin, h - margin - margin, h - margin - margin)
        else
            s.rotation = s.rotation or 0
            s.rotation = s.rotation + 1

            local icosize = h * .6

            surface.SetDrawColor(white)
            surface.SetMaterial(ico)
            surface.DrawTexturedRectRotated(h * .5, h * .5, icosize, icosize, -s.rotation)
        end
    end

    addLabel(store_management.frame, slib.getLang("sreward", sReward.config["language"], "rewards")):DockMargin(0,margin * 2,0,margin)

    local edit_rewards = vgui.Create("SButton", store_management.frame)
    :Dock(TOP)
    :setTitle(slib.getLang("sreward", sReward.config["language"], "edit_rewards"))

    edit_rewards:SetTall(slib.getScaledSize(20, "y"))
    edit_rewards.font = slib.createFont("Roboto", 14)
    edit_rewards.bg = maincolor_7

    local suggestions = {}

    for k,v in pairs(sReward.Rewards) do
        suggestions[k] = true
    end

    edit_rewards.DoClick = function()
        local close = vgui.Create("SButton")
        close:MakePopup()
        close:SetSize(ScrW(), ScrH())
        close.Paint = function(s,w,h) end
        close.DoClick = function()
            close:Remove()
        end

        local table_viewer = vgui.Create("STableViewer", close)
        :setTable(data.reward)
        :addSuggestions(suggestions)
        :setCustomValues(slib.getLang("sreward", sReward.config["language"], "submit"), "Input type/amount")


        table_viewer:addSearch(table_viewer.viewbox, table_viewer.viewer)
        :addSearch(table_viewer.suggestionbox, table_viewer.suggestions)
        :MakePopup()
        :sortValues(table_viewer.viewer)
		:sortValues(table_viewer.suggestions)

        table_viewer.OnRemove = function()
            if table_viewer.modified then
                data.reward = table_viewer.viewer.tbl
            end

            if !IsValid(close) then return end
            close:Remove()
        end
    end

    local save_item = vgui.Create("SButton", store_management.frame)
    :Dock(TOP)
    :DockMargin(0,margin,0,0)
    :setTitle(slib.getLang("sreward", sReward.config["language"], "save"))

    save_item.DoClick = function()
        sReward.data["shop"][key] = data
        networkAdminData(2, key)
        store_management:Remove()
    end

    save_item:SetTall(slib.getScaledSize(20, "y"))
    save_item.font = slib.createFont("Roboto", 14)
    save_item.bg = maincolor_7

    for k,v in pairs(store_management.frame:GetChildren()) do
        local h = v:GetTall()
        local l, t, r, b = v:GetDockMargin()

        h = h + b

        store_management.frame:SetTall(store_management.frame:GetTall() + h + t)
    end

    store_management.frame:SetTall(store_management.frame:GetTall() + (margin * 2))

    store_management:SetTall(store_management.frame:GetTall() + store_management.topbarheight)

    store_management:Center()
end

sReward.openAdminmenu = function(sreward_menu)
    local x, y
    if IsValid(sreward_menu) then
        x, y = sreward_menu:GetPos()
        sreward_menu:Remove()
    end
    
    sreward_admin = vgui.Create("SFrame")
    :SetSize(slib.getScaledSize(sReward.config["size"].w, "x"),slib.getScaledSize(sReward.config["size"].h, "y"))
    :setTitle(slib.getLang("sreward", sReward.config["language"], "title_admin"))
    :Center()
    :addCloseButton()
    :MakePopup()
    :addTab(slib.getLang("sreward", sReward.config["language"], "general"), "sreward/tabs/general.png")
    :addTab(slib.getLang("sreward", sReward.config["language"], "shop"), "sreward/tabs/product.png")
    :addTab(slib.getLang("sreward", sReward.config["language"], "coupons"), "sreward/tabs/coupon.png")
    :setActiveTab(slib.getLang("sreward", sReward.config["language"], "general"))
    :SetPos(x, y)

    sreward_admin.OnRemove = function()
        if sreward_admin.changing then return end
        net.Start("sR:NetworkingHandeler")
        net.WriteUInt(0,3)
        net.WriteBool(false)
        net.SendToServer()
    end

    local topbttnsize = sreward_admin.close:GetTall()
    local bttngap = sreward_admin.topbar:GetTall() - topbttnsize

    sreward_admin.topbar:DockPadding(0,0,topbttnsize * .85,0)

    local returnbttn = vgui.Create("SButton", sreward_admin.topbar)
    returnbttn:Dock(RIGHT)
    returnbttn:DockMargin(0, bttngap / 2, margin / 2, bttngap / 2)
    returnbttn:SetWide(topbttnsize)
    
    returnbttn.DoClick = function()
        sreward_admin.changing = true
        sReward.openRewards(sreward_admin:GetPos())
        sreward_admin:Remove()
    end

    returnbttn.Paint = function(s,w,h)
        local icosize = h * .5
        local wantedCol = s:IsHovered() and white or hovercolor

        surface.SetDrawColor(slib.lerpColor(s, wantedCol))
        surface.SetMaterial(return_ico)
        surface.DrawTexturedRect(w * .5 - icosize * .5, h * .5 - icosize * .5, icosize, icosize)
    end

    local generalcanvas = addBasicsPage(sreward_admin.tab[slib.getLang("sreward", sReward.config["language"], "general")])
    local shopcanvas, shops_search = addBasicsPage(sreward_admin.tab[slib.getLang("sreward", sReward.config["language"], "shop")])
    local couponscanvas, coupons_search = addBasicsPage(sreward_admin.tab[slib.getLang("sreward", sReward.config["language"], "coupons")])

    local rewardNameIndex = {}

    for k,v in pairs(sReward.config["rewards"]) do
        rewardNameIndex[v.name] = k
    end

    for k,v in ipairs(player.GetAll()) do
        local ply = sReward.addMultibox(generalcanvas, {
            [1] = {
                title = slib.getLang("sreward", sReward.config["language"], "name"), 
                val = v:Nick(),
                offset = 0
            }
        })
        ply.addAvatar(v)
        ply.addButton(slib.getLang("sreward", sReward.config["language"], "take_tokens"), function()
            local val
            local popup = adminAction(v, slib.getLang("sreward", sReward.config["language"], "take_tokens"), slib.getLang("sreward", sReward.config["language"], "number"), function()
                doAdminAction(v, 2, val)
            end)
            local textbox = popup.addInput("int")
            textbox.onValueChange = function(newval)
                val = newval
            end
        end)

        ply.addButton(slib.getLang("sreward", sReward.config["language"], "give_tokens"), function()
            local val
            local popup = adminAction(v, slib.getLang("sreward", sReward.config["language"], "give_tokens"), slib.getLang("sreward", sReward.config["language"], "number"), function()
                doAdminAction(v, 1, val)
            end)

            local textbox = popup.addInput("int")

            textbox.onValueChange = function(newval)
                val = newval
            end
        end)

        ply.addButton(slib.getLang("sreward", sReward.config["language"], "give_reward"), function()
            local val
            local dropdown
            local popup = adminAction(v, slib.getLang("sreward", sReward.config["language"], "give_reward"), slib.getLang("sreward", sReward.config["language"], "select_reward"), function()
                doAdminAction(v, 3, rewardNameIndex[dropdown.title])
            end)
            
            dropdown = popup.addInput("dropdown") 

            for k,v in pairs(sReward.config["rewards"]) do
                dropdown:addOption(v.name)
            end
        end)

        ply.PaintOver = function(s,w,h)
            draw.SimpleText(slib.getLang("sreward", sReward.config["language"], "tokens"), overlineFont, w * .45, margin, textcolor_min50, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
            draw.SimpleText(string.Comma(sReward.GetTokens(v)), slib.createFont("Roboto", 15), w * .45, h - margin, isFriend and successcolor or textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
        end
    end

    sreward_admin.RebuildCoupons = function()
        for k,v in ipairs(couponscanvas:GetCanvas():GetChildren()) do
            v:Remove()
        end

        for k,v in SortedPairs(sReward.data["coupons"]) do
            if !istable(v) then continue end
            local coupon = addCoupon(couponscanvas, v.name)
        end
    end

    sreward_admin.RebuildCoupons()

    local store_canvas
    sreward_admin.rebuildStore = function(str)
        table.sort(sReward.data["shop"], function(a, b) return (istable(a) and istable(b)) and tonumber(a and a.price or 0) > tonumber(b and b.price or 0) end)

        local shopcanvas = shopcanvas:GetCanvas()
        store_canvas = shopcanvas

        local iteration = 0
        local yiteration = 0
        for k,v in ipairs(shopcanvas:GetChildren()) do
            v:Remove()
        end

        for k,v in SortedPairs(sReward.data["shop"]) do
            if !istable(v) then continue end
            if str and !string.find(string.lower(v.name), string.lower(str)) then continue end
            yiteration = iteration > 2 and yiteration + 1 or yiteration
            iteration = iteration > 2 and 0 or iteration

            local item = sReward.addStoreItem(shopcanvas, sReward.data["shop"][k], yiteration, iteration)
            item.addButton(failcolor, delete_ico, function()
                local popup = vgui.Create("SPopupBox")
                :setTitle(slib.getLang("sreward", sReward.config["language"], "are_you_sure"))
                :setBlur(true)
                :addChoise(slib.getLang("sreward", sReward.config["language"], "no"))
                :addChoise(slib.getLang("sreward", sReward.config["language"], "yes"), function()
                    sReward.data["shop"][k] = sReward.data["shop"][k] or {}
                    sReward.data["shop"][k].delete = "confirmed"
        
                    item:Remove()
                    networkAdminData(2, k)
                end)
                :setText(slib.getLang("sreward", sReward.config["language"], "this_delete", item.data.name))
            end)
            item.addButton(nil, settings_ico, function()
                manageStoreItem(k)
            end, true)

            iteration = iteration + 1
        end

        ignoreResize = false
    end

    sreward_admin.rebuildStore()

    shopcanvas:GetCanvas().OnSizeChanged = function()
        local width = store_canvas:GetWide()
        if store_canvas.oldWide == width then return end
        store_canvas.oldWide = width

        if !IsValid(store_canvas) then return end
        for k,v in ipairs(store_canvas:GetChildren()) do
            v.InvalidateLayout()
        end
    end

    shops_search.entry.onValueChange = function(newval)
        sreward_admin.rebuildStore(newval)
    end


    local add_shopitem = vgui.Create("SButton", shops_search)
    add_shopitem:Dock(RIGHT)
    add_shopitem:DockMargin(margin * 2,margin * 2,margin * 2,margin * 2)
    add_shopitem:SetWide(shops_search:GetTall() - (margin * 4))
    add_shopitem.Paint = function(s,w,h)
        local icosize, width = h * .7, 2
        local centerPos = h * .15
        local wantedCol = s:IsHovered() and white or hovercolor

        surface.SetDrawColor(slib.lerpColor(s, wantedCol))
        surface.DrawRect(w * .5 - width * .5, 0, width, h)
        surface.DrawRect(0, h * .5 - width * .5, w, width)
    end

    add_shopitem.DoClick = function()
        manageStoreItem(id)
    end

    local add_coupon = vgui.Create("SButton", coupons_search)
    add_coupon:Dock(RIGHT)
    add_coupon:DockMargin(margin * 2,margin * 2,margin * 2,margin * 2)
    add_coupon:SetWide(coupons_search:GetTall() - (margin * 4))
    add_coupon.Paint = function(s,w,h)
        local icosize, width = h * .7, 2
        local centerPos = h * .15
        local wantedCol = s:IsHovered() and white or hovercolor

        surface.SetDrawColor(slib.lerpColor(s, wantedCol))
        surface.DrawRect(w * .5 - width * .5, 0, width, h)
        surface.DrawRect(0, h * .5 - width * .5, w, width)
    end

    add_coupon.DoClick = function()
        local val
        local popup = adminAction(v, slib.getLang("sreward", sReward.config["language"], "create_coupon"), slib.getLang("sreward", sReward.config["language"], "coupon_name"), function()
            addCoupon(couponscanvas, val, true)
        end)
        local textbox = popup.addInput("int")
        textbox:SetNumeric(false)
        textbox.onValueChange = function(newval)
            val = newval
        end
    end
end
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/languages/sh_german.lua:
if CLIENT then
    slib.setLang("sreward", "de", "general", "Allgemein")
    slib.setLang("sreward", "de", "tasks", "Aufgaben")
    slib.setLang("sreward", "de", "referral", "Empfehlungen")
    slib.setLang("sreward", "de", "shop", "Shop")
    slib.setLang("sreward", "de", "leaderboard", "Bestenliste")
    slib.setLang("sreward", "de", "coupons", "Gutscheine")

    slib.setLang("sreward", "de", "main_title", "Server-Name - Belohnungs-System")
    slib.setLang("sreward", "de", "title_admin", "Server-Name - Admin")

    slib.setLang("sreward", "de", "rewards_title", "%s - Belohnungen")
    slib.setLang("sreward", "de", "coupon_title", "Gutscheine")

    slib.setLang("sreward", "de", "coupon_receive_title", "Neuer Gutschein!")
    slib.setLang("sreward", "de", "coupon_receive", "Sie haben einen neuen Gutschein erhalten, \n    Überprüfen Sie Ihren Coupon-Bestand!") --- Had to fine tune like that :(

    slib.setLang("sreward", "de", "copied_clipboard", "In die Zwischenablage kopiert!")
    slib.setLang("sreward", "de", "no_coupons", "Sie haben keine Gutscheine!")
    slib.setLang("sreward", "de", "no_rewards", "Es gibt keine Belohnungen!")

    slib.setLang("sreward", "de", "delete", "Löschen")
    slib.setLang("sreward", "de", "yes", "Ja")
    slib.setLang("sreward", "de", "no", "Nein")

    slib.setLang("sreward", "de", "top_3", "Top 3")

    slib.setLang("sreward", "de", "you", "Du")
    slib.setLang("sreward", "de", "friend", "Freund")

    slib.setLang("sreward", "de", "referr_with_code", "Mit Code empfehlen")

    slib.setLang("sreward", "de", "are_you_sure", "Bist du dir sicher?")
    slib.setLang("sreward", "de", "manage", "Verwalten")

    slib.setLang("sreward", "de", "tokens", "Tokens")
    slib.setLang("sreward", "de", "select_reward", "Wählen Sie Belohnung aus")
    slib.setLang("sreward", "de", "number", "Nummer")

    slib.setLang("sreward", "de", "submit", "Einreichen")
    slib.setLang("sreward", "de", "name", "Name")
    slib.setLang("sreward", "de", "uses", "Verwendungen")
    slib.setLang("sreward", "de", "used", "Eingelöst")
    slib.setLang("sreward", "de", "task", "Aufgabe")
    slib.setLang("sreward", "de", "verify", "Verifizieren")
    slib.setLang("sreward", "de", "total_tokens", "Token insgesamt")
    slib.setLang("sreward", "de", "referrals", "Empfehlungen")

    slib.setLang("sreward", "de", "rewards", "Belohnung")
    slib.setLang("sreward", "de", "price", "Preis")
    slib.setLang("sreward", "de", "imgur_id", "Imgur ID")

    slib.setLang("sreward", "de", "edit_rewards", "Belohnungen bearbeiten")
    slib.setLang("sreward", "de", "save", "Speichern")

    slib.setLang("sreward", "de", "insert_imgur_id", "Imgur ID Einfügen")
    slib.setLang("sreward", "de", "insert_name", "Namen eingeben")
    slib.setLang("sreward", "de", "insert_price", "Preis einfügen")

    slib.setLang("sreward", "de", "create_coupon", "Gutschein erstellen")
    slib.setLang("sreward", "de", "coupon_name", "Gutscheinname")

    slib.setLang("sreward", "de", "create_shopitem", "Shop-Artikel erstellen")
    slib.setLang("sreward", "de", "item_name", "Artikelname")

    slib.setLang("sreward", "de", "this_will_cost", "'%s' wird dich: %s tokens kosten!")
    slib.setLang("sreward", "de", "coupon_delete_confirm", "Dadurch wird der Gutschein gelöscht: '%s'?")
    slib.setLang("sreward", "de", "this_delete", "Dies wird gelöscht: '%s'")
    slib.setLang("sreward", "de", "no_data", "Keine Daten")

    slib.setLang("sreward", "de", "manage_item", "Artikel verwalten")

    slib.setLang("sreward", "de", "discord_failed_application_com", "Die Kommunikation mit Ihrer Discord-Anwendung ist fehlgeschlagen. Stellen Sie sicher, dass sie ausgeführt wird!")
    slib.setLang("sreward", "de", "discord_error_retrieving_data", "Beim Abrufen von Daten aus Discord ist ein Problem aufgetreten. Bitte informieren Sie die Teammitglieder darüber!")
else
    slib.setLang("sreward", "de", "cooldown", "Sie befinden sich in einer Verifizierungsabklingzeit, bitte warten Sie: %s Sekunden!")

    slib.setLang("sreward", "de", "added_queue", "Sie wurden zur Warteschlange hinzugefügt für: '%s' du erhälst eine Antwort in: %s Sekunden!")

    slib.setLang("sreward", "de", "added_steamgroup_queue", "Sie wurden der Warteschlange für die Überprüfung der Steamgruppe hinzugefügt. Sie erhalten innerhalb dieser Frist eine Antwort: %s Sekunden!")
    slib.setLang("sreward", "de", "didnt_find_steamgroup", "Wir konnten Sie in der Steamgruppe nicht finden, bitte versuchen Sie es erneut!")
    slib.setLang("sreward", "de", "failed_verification", "Anscheinend konnten wir die Prämie nicht verifizieren: '%s', Stellen Sie sicher, dass Sie die Aufgabe ordnungsgemäß ausführen.")
    
    slib.setLang("sreward", "de", "discord_error_retrieving_data", "Wir konnten Discord nicht kontaktieren, bitte versuchen Sie es später erneut!")
    slib.setLang("sreward", "de", "checking_wait", "Bitte warten Sie, während wir die Prämie überprüfen: '%s' für dich!")

    slib.setLang("sreward", "de", "steam_unsuccessfull", "Wir konnten Steam nicht kontaktieren, bitte versuchen Sie es später erneut!")
    slib.setLang("sreward", "de", "steam_private", "Die Überprüfung Ihrer Steam-Gruppen ist fehlgeschlagen. Stellen Sie sicher, dass Ihr Profil öffentlich ist, damit wir dies überprüfen können!")
    slib.setLang("sreward", "de", "success_reward", "Sie haben die: '%s' Belohnung erhalten!")

    slib.setLang("sreward", "de", "already_referred", "Sie haben diese Person bereits geworben!")
    slib.setLang("sreward", "de", "referral_limit", "Sie haben das maximale Empfehlungslimit erreicht!")
    slib.setLang("sreward", "de", "referred_person", "Sie haben eine Belohnung für das anwerben erhalten: %s")
    slib.setLang("sreward", "de", "referred_by", "Sie haben eine Belohnung für die Empfehlung erhalten %s!")
    slib.setLang("sreward", "de", "referring_person", "Sie haben eine Belohnung für die Empfehlung einer Person erhalten!")
    slib.setLang("sreward", "de", "cannot_referr_again", "Sie können diese Person nicht erneut empfehlen!")
    slib.setLang("sreward", "de", "raferring_ratelimit", "Ihre Rate wurde begrenzt, warten Sie, bis Ihre erste Empfehlungsanfrage abgeschlossen ist!")

    slib.setLang("sreward", "de", "mysql_successfull", "Wir haben uns erfolgreich mit der Datenbank verbunden!")
    slib.setLang("sreward", "de", "mysql_failed", "Die Verbindung zur Datenbank ist fehlgeschlagen!")
    slib.setLang("sreward", "de", "cannot_afford", "Du kannst dir das nicht leisten!")
    slib.setLang("sreward", "de", "successfull_purchase", "Sie haben erfolgreich: '%s' gekauft!")

    slib.setLang("sreward", "de", "taken_tokens", "jemand hat: %s tokens von dir genommen, dein guthaben ist: %s!")
    slib.setLang("sreward", "de", "given_tokens", "Jemand hat dir: %s tokens gegeben, dein guthaben ist: %s!")
    slib.setLang("sreward", "de", "given_reward", "Jemand hat dir die Belohnung gegeben: '%s'!")
    slib.setLang("sreward", "de", "you_got_tokens", "Du hast %s Tokens erhalten, dein neues Guthaben beträgt: %s!")

    slib.setLang("sreward", "de", "performed_admin_action", "Sie haben eine Administratoraktion ausgeführt für: '%s' mit dem Wert von '%s'")
    slib.setLang("sreward", "de", "coupon_out_of_stock", "Wir sind derzeit nicht vorrätig für '%s' Coupons, wenden Sie sich bitte an die Teammitglieder, damit wir diese auffüllen können!")
end

slib.setLang("sreward", "de", "on_cooldown", "Sie befinden sich in einer Abklingzeit: %s Sekunden, um diese Belohnung erneut zu verwenden!")

slib.setLang("sreward", "de", "max_use_reached", "Sie haben das maximale Verwendungslimit dieser Belohnung erreicht!")

slib.setLang("sreward", "de", "sr_tokens", "sR Tokens")

slib.setLang("sreward", "de", "darkrp_money", "DarkRP Geld")

slib.setLang("sreward", "de", "reward_rank", "Rang")

slib.setLang("sreward", "de", "coupon", "Gutschein")

slib.setLang("sreward", "de", "give_weapon", "Waffe geben")

slib.setLang("sreward", "de", "basewars_money", "Basewars Geld")
slib.setLang("sreward", "de", "basewars_level", "Basewars Level")

slib.setLang("sreward", "de", "vrondakis_level", "Level")
slib.setLang("sreward", "de", "vrondakis_xp", "XP")

slib.setLang("sreward", "de", "glorified_level", "Level")
slib.setLang("sreward", "de", "glorified_xp", "XP")

slib.setLang("sreward", "de", "essentials_level", "Level")
slib.setLang("sreward", "de", "essentials_xp", "XP")

slib.setLang("sreward", "de", "elite_xp", "XP")
slib.setLang("sreward", "de", "elevel_xp", "XP")

slib.setLang("sreward", "de", "elevel_xp", "XP")

slib.setLang("sreward", "de", "wos_level", "wOS Level")
slib.setLang("sreward", "de", "wos_xp", "wOS XP")
slib.setLang("sreward", "de", "wos_points", "wOS Punkte")
slib.setLang("sreward", "de", "wos_giveitem", "wOS item geben")

slib.setLang("sreward", "de", "ps1_points", "PS1 Punkte")

slib.setLang("sreward", "de", "ps2_standard_points", "PS2 Standard Punkte")
slib.setLang("sreward", "de", "ps2_premium_points", "PS2 Premium Punkte")

slib.setLang("sreward", "de", "sh_ps_standard_points", "SH PS Standard Punkte")
slib.setLang("sreward", "de", "sh_ps_premium_points", "SH PS Premium Punkte")

slib.setLang("sreward", "de", "give_tokens", "Gebe Tokens")
slib.setLang("sreward", "de", "give_reward", "Gebe Belohnung")
slib.setLang("sreward", "de", "take_tokens", "Nehme Tokens")

slib.setLang("sreward", "de", "invalid_sid64", "Ungültige SteamID64")
slib.setLang("sreward", "de", "cannot_referr_yourself", "Du kannst dich nicht selbst Empfehlen!!")
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_customcommand.lua:
local replacements = {
    ["{sid64}"] = function(ply) return ply:SteamID64() end,
    ["{sid}"] = function(ply) return ply:SteamID() end,
    ["{name}"] = function(ply) return ply:Nick() end
}

sReward.RegisterReward("custom_command", function(ply, str)
    for k,v in pairs(replacements) do
        str = string.Replace(str, k, v(ply))
    end

    local packed = string.Explode(" ", str)

    RunConsoleCommand(unpack(packed))
end)

--PATH lua/streamradio_core/string_accents.lua:
local StreamRadioLib = StreamRadioLib

local LIB = StreamRadioLib.String

--[[
Used rulesets:
    custom
    default
    custom-fonts
    austrian
    azerbaijani
    croatian
    czech
    danish
    esperanto
    estonian
    finnish
    french
    german
    hungarian
    italian
    latvian
    lithuanian
    norwegian
    polish
    portuguese-brazil
    romanian
    slovak
    swedish
    turkish
    turkmen
    vietnamese
]]

local g_accentMap = {
	[0x000040] = "a",     -- @
	[0x0000A1] = "i",     -- ¡
	[0x0000A7] = "S",     -- §
	[0x0000A9] = "C",     -- ©
	[0x0000AA] = "a",     -- ª
	[0x0000AE] = "R",     -- ®
	[0x0000AF] = "-",     -- ¯
	[0x0000B0] = "o",     -- °
	[0x0000B2] = "2",     -- ²
	[0x0000B3] = "3",     -- ³
	[0x0000B7] = ".",     -- ·
	[0x0000B9] = "1",     -- ¹
	[0x0000BA] = "o",     -- º
	[0x0000C0] = "A",     -- À
	[0x0000C1] = "A",     -- Á
	[0x0000C2] = "A",     -- Â
	[0x0000C3] = "A",     -- Ã
	[0x0000C4] = "A",     -- Ä
	[0x0000C5] = "A",     -- Å
	[0x0000C6] = "AE",    -- Æ
	[0x0000C7] = "C",     -- Ç
	[0x0000C8] = "E",     -- È
	[0x0000C9] = "E",     -- É
	[0x0000CA] = "E",     -- Ê
	[0x0000CB] = "E",     -- Ë
	[0x0000CC] = "I",     -- Ì
	[0x0000CD] = "I",     -- Í
	[0x0000CE] = "I",     -- Î
	[0x0000CF] = "I",     -- Ï
	[0x0000D0] = "Dj",    -- Ð
	[0x0000D1] = "N",     -- Ñ
	[0x0000D2] = "O",     -- Ò
	[0x0000D3] = "O",     -- Ó
	[0x0000D4] = "O",     -- Ô
	[0x0000D5] = "O",     -- Õ
	[0x0000D6] = "O",     -- Ö
	[0x0000D8] = "OE",    -- Ø
	[0x0000D9] = "U",     -- Ù
	[0x0000DA] = "U",     -- Ú
	[0x0000DB] = "U",     -- Û
	[0x0000DC] = "U",     -- Ü
	[0x0000DD] = "Y",     -- Ý
	[0x0000DE] = "TH",    -- Þ
	[0x0000DF] = "ss",    -- ß
	[0x0000E0] = "a",     -- à
	[0x0000E1] = "a",     -- á
	[0x0000E2] = "a",     -- â
	[0x0000E3] = "a",     -- ã
	[0x0000E4] = "a",     -- ä
	[0x0000E5] = "a",     -- å
	[0x0000E6] = "ae",    -- æ
	[0x0000E7] = "c",     -- ç
	[0x0000E8] = "e",     -- è
	[0x0000E9] = "e",     -- é
	[0x0000EA] = "e",     -- ê
	[0x0000EB] = "e",     -- ë
	[0x0000EC] = "i",     -- ì
	[0x0000ED] = "i",     -- í
	[0x0000EE] = "i",     -- î
	[0x0000EF] = "i",     -- ï
	[0x0000F0] = "dj",    -- ð
	[0x0000F1] = "n",     -- ñ
	[0x0000F2] = "o",     -- ò
	[0x0000F3] = "o",     -- ó
	[0x0000F4] = "o",     -- ô
	[0x0000F5] = "o",     -- õ
	[0x0000F6] = "o",     -- ö
	[0x0000F8] = "oe",    -- ø
	[0x0000F9] = "u",     -- ù
	[0x0000FA] = "u",     -- ú
	[0x0000FB] = "u",     -- û
	[0x0000FC] = "u",     -- ü
	[0x0000FD] = "y",     -- ý
	[0x0000FE] = "th",    -- þ
	[0x0000FF] = "y",     -- ÿ
	[0x000100] = "A",     -- Ā
	[0x000101] = "a",     -- ā
	[0x000102] = "A",     -- Ă
	[0x000103] = "a",     -- ă
	[0x000104] = "A",     -- Ą
	[0x000105] = "a",     -- ą
	[0x000106] = "C",     -- Ć
	[0x000107] = "c",     -- ć
	[0x000108] = "C",     -- Ĉ
	[0x000109] = "c",     -- ĉ
	[0x00010A] = "C",     -- Ċ
	[0x00010B] = "c",     -- ċ
	[0x00010C] = "C",     -- Č
	[0x00010D] = "c",     -- č
	[0x00010E] = "D",     -- Ď
	[0x00010F] = "d",     -- ď
	[0x000110] = "D",     -- Đ
	[0x000111] = "d",     -- đ
	[0x000112] = "E",     -- Ē
	[0x000113] = "e",     -- ē
	[0x000114] = "E",     -- Ĕ
	[0x000115] = "e",     -- ĕ
	[0x000116] = "E",     -- Ė
	[0x000117] = "e",     -- ė
	[0x000118] = "E",     -- Ę
	[0x000119] = "e",     -- ę
	[0x00011A] = "E",     -- Ě
	[0x00011B] = "e",     -- ě
	[0x00011C] = "G",     -- Ĝ
	[0x00011D] = "g",     -- ĝ
	[0x00011E] = "G",     -- Ğ
	[0x00011F] = "g",     -- ğ
	[0x000120] = "G",     -- Ġ
	[0x000121] = "g",     -- ġ
	[0x000122] = "G",     -- Ģ
	[0x000123] = "g",     -- ģ
	[0x000124] = "H",     -- Ĥ
	[0x000125] = "h",     -- ĥ
	[0x000126] = "H",     -- Ħ
	[0x000127] = "h",     -- ħ
	[0x000128] = "I",     -- Ĩ
	[0x000129] = "i",     -- ĩ
	[0x00012A] = "I",     -- Ī
	[0x00012B] = "i",     -- ī
	[0x00012C] = "I",     -- Ĭ
	[0x00012D] = "i",     -- ĭ
	[0x00012E] = "I",     -- Į
	[0x00012F] = "i",     -- į
	[0x000130] = "I",     -- İ
	[0x000131] = "i",     -- ı
	[0x000132] = "IJ",    -- Ĳ
	[0x000133] = "ij",    -- ĳ
	[0x000134] = "J",     -- Ĵ
	[0x000135] = "j",     -- ĵ
	[0x000136] = "K",     -- Ķ
	[0x000137] = "k",     -- ķ
	[0x000139] = "L",     -- Ĺ
	[0x00013A] = "l",     -- ĺ
	[0x00013B] = "L",     -- Ļ
	[0x00013C] = "l",     -- ļ
	[0x00013D] = "L",     -- Ľ
	[0x00013E] = "l",     -- ľ
	[0x00013F] = "L",     -- Ŀ
	[0x000140] = "l",     -- ŀ
	[0x000141] = "L",     -- Ł
	[0x000142] = "l",     -- ł
	[0x000143] = "N",     -- Ń
	[0x000144] = "n",     -- ń
	[0x000145] = "N",     -- Ņ
	[0x000146] = "n",     -- ņ
	[0x000147] = "N",     -- Ň
	[0x000148] = "n",     -- ň
	[0x000149] = "n",     -- ŉ
	[0x00014C] = "O",     -- Ō
	[0x00014D] = "o",     -- ō
	[0x00014E] = "O",     -- Ŏ
	[0x00014F] = "o",     -- ŏ
	[0x000150] = "O",     -- Ő
	[0x000151] = "o",     -- ő
	[0x000152] = "OE",    -- Œ
	[0x000153] = "oe",    -- œ
	[0x000154] = "R",     -- Ŕ
	[0x000155] = "r",     -- ŕ
	[0x000156] = "R",     -- Ŗ
	[0x000157] = "r",     -- ŗ
	[0x000158] = "R",     -- Ř
	[0x000159] = "r",     -- ř
	[0x00015A] = "S",     -- Ś
	[0x00015B] = "s",     -- ś
	[0x00015C] = "S",     -- Ŝ
	[0x00015D] = "s",     -- ŝ
	[0x00015E] = "S",     -- Ş
	[0x00015F] = "s",     -- ş
	[0x000160] = "S",     -- Š
	[0x000161] = "s",     -- š
	[0x000162] = "T",     -- Ţ
	[0x000163] = "t",     -- ţ
	[0x000164] = "T",     -- Ť
	[0x000165] = "t",     -- ť
	[0x000166] = "T",     -- Ŧ
	[0x000167] = "t",     -- ŧ
	[0x000168] = "U",     -- Ũ
	[0x000169] = "u",     -- ũ
	[0x00016A] = "U",     -- Ū
	[0x00016B] = "u",     -- ū
	[0x00016C] = "U",     -- Ŭ
	[0x00016D] = "u",     -- ŭ
	[0x00016E] = "U",     -- Ů
	[0x00016F] = "u",     -- ů
	[0x000170] = "U",     -- Ű
	[0x000171] = "u",     -- ű
	[0x000172] = "U",     -- Ų
	[0x000173] = "u",     -- ų
	[0x000174] = "W",     -- Ŵ
	[0x000175] = "w",     -- ŵ
	[0x000176] = "Y",     -- Ŷ
	[0x000177] = "y",     -- ŷ
	[0x000178] = "Y",     -- Ÿ
	[0x000179] = "Z",     -- Ź
	[0x00017A] = "z",     -- ź
	[0x00017B] = "Z",     -- Ż
	[0x00017C] = "z",     -- ż
	[0x00017D] = "Z",     -- Ž
	[0x00017E] = "z",     -- ž
	[0x00017F] = "s",     -- ſ
	[0x000183] = "g",     -- ƃ
	[0x00018F] = "E",     -- Ə
	[0x000192] = "f",     -- ƒ
	[0x0001A0] = "O",     -- Ơ
	[0x0001A1] = "o",     -- ơ
	[0x0001AF] = "U",     -- Ư
	[0x0001B0] = "u",     -- ư
	[0x0001CD] = "A",     -- Ǎ
	[0x0001CE] = "a",     -- ǎ
	[0x0001CF] = "I",     -- Ǐ
	[0x0001D0] = "i",     -- ǐ
	[0x0001D1] = "O",     -- Ǒ
	[0x0001D2] = "o",     -- ǒ
	[0x0001D3] = "U",     -- Ǔ
	[0x0001D4] = "u",     -- ǔ
	[0x0001D5] = "U",     -- Ǖ
	[0x0001D6] = "u",     -- ǖ
	[0x0001D7] = "U",     -- Ǘ
	[0x0001D8] = "u",     -- ǘ
	[0x0001D9] = "U",     -- Ǚ
	[0x0001DA] = "u",     -- ǚ
	[0x0001DB] = "U",     -- Ǜ
	[0x0001DC] = "u",     -- ǜ
	[0x0001DD] = "e",     -- ǝ
	[0x0001EB] = "q",     -- ǫ
	[0x0001FA] = "A",     -- Ǻ
	[0x0001FB] = "a",     -- ǻ
	[0x0001FC] = "AE",    -- Ǽ
	[0x0001FD] = "ae",    -- ǽ
	[0x0001FE] = "O",     -- Ǿ
	[0x0001FF] = "o",     -- ǿ
	[0x000218] = "S",     -- Ș
	[0x000219] = "s",     -- ș
	[0x00021A] = "T",     -- Ț
	[0x00021B] = "t",     -- ț
	[0x000250] = "a",     -- ɐ
	[0x000254] = "c",     -- ɔ
	[0x000259] = "e",     -- ə
	[0x00025F] = "f",     -- ɟ
	[0x000262] = "g",     -- ɢ
	[0x000265] = "h",     -- ɥ
	[0x00026A] = "i",     -- ɪ
	[0x00026F] = "m",     -- ɯ
	[0x000274] = "n",     -- ɴ
	[0x000279] = "r",     -- ɹ
	[0x00027E] = "j",     -- ɾ
	[0x000280] = "r",     -- ʀ
	[0x000285] = "S",     -- ʅ
	[0x000287] = "t",     -- ʇ
	[0x00028C] = "v",     -- ʌ
	[0x00028D] = "w",     -- ʍ
	[0x00028E] = "y",     -- ʎ
	[0x00028F] = "y",     -- ʏ
	[0x000299] = "b",     -- ʙ
	[0x00029C] = "h",     -- ʜ
	[0x00029E] = "k",     -- ʞ
	[0x00029F] = "l",     -- ʟ
	[0x0003BC] = "u",     -- μ
	[0x00043E] = "o",     -- о
	[0x000493] = "f",     -- ғ
	[0x001430] = "A",     -- ᐰ
	[0x001D00] = "a",     -- ᴀ
	[0x001D04] = "c",     -- ᴄ
	[0x001D05] = "d",     -- ᴅ
	[0x001D07] = "e",     -- ᴇ
	[0x001D09] = "i",     -- ᴉ
	[0x001D0A] = "j",     -- ᴊ
	[0x001D0B] = "k",     -- ᴋ
	[0x001D0D] = "m",     -- ᴍ
	[0x001D0F] = "o",     -- ᴏ
	[0x001D18] = "p",     -- ᴘ
	[0x001D1B] = "t",     -- ᴛ
	[0x001D1C] = "u",     -- ᴜ
	[0x001D20] = "v",     -- ᴠ
	[0x001D21] = "w",     -- ᴡ
	[0x001D22] = "z",     -- ᴢ
	[0x001E9E] = "SS",    -- ẞ
	[0x001EA0] = "A",     -- Ạ
	[0x001EA1] = "a",     -- ạ
	[0x001EA2] = "A",     -- Ả
	[0x001EA3] = "a",     -- ả
	[0x001EA4] = "A",     -- Ấ
	[0x001EA5] = "a",     -- ấ
	[0x001EA6] = "A",     -- Ầ
	[0x001EA7] = "a",     -- ầ
	[0x001EA8] = "A",     -- Ẩ
	[0x001EA9] = "a",     -- ẩ
	[0x001EAA] = "A",     -- Ẫ
	[0x001EAB] = "a",     -- ẫ
	[0x001EAC] = "A",     -- Ậ
	[0x001EAD] = "a",     -- ậ
	[0x001EAE] = "A",     -- Ắ
	[0x001EAF] = "a",     -- ắ
	[0x001EB0] = "A",     -- Ằ
	[0x001EB1] = "a",     -- ằ
	[0x001EB2] = "A",     -- Ẳ
	[0x001EB3] = "a",     -- ẳ
	[0x001EB4] = "A",     -- Ẵ
	[0x001EB5] = "a",     -- ẵ
	[0x001EB6] = "A",     -- Ặ
	[0x001EB7] = "a",     -- ặ
	[0x001EB8] = "E",     -- Ẹ
	[0x001EB9] = "e",     -- ẹ
	[0x001EBA] = "E",     -- Ẻ
	[0x001EBB] = "e",     -- ẻ
	[0x001EBC] = "E",     -- Ẽ
	[0x001EBD] = "e",     -- ẽ
	[0x001EBE] = "E",     -- Ế
	[0x001EBF] = "e",     -- ế
	[0x001EC0] = "E",     -- Ề
	[0x001EC1] = "e",     -- ề
	[0x001EC2] = "E",     -- Ể
	[0x001EC3] = "e",     -- ể
	[0x001EC4] = "E",     -- Ễ
	[0x001EC5] = "e",     -- ễ
	[0x001EC6] = "E",     -- Ệ
	[0x001EC7] = "e",     -- ệ
	[0x001EC8] = "I",     -- Ỉ
	[0x001EC9] = "i",     -- ỉ
	[0x001ECA] = "I",     -- Ị
	[0x001ECB] = "i",     -- ị
	[0x001ECC] = "O",     -- Ọ
	[0x001ECD] = "o",     -- ọ
	[0x001ECE] = "O",     -- Ỏ
	[0x001ECF] = "o",     -- ỏ
	[0x001ED0] = "O",     -- Ố
	[0x001ED1] = "o",     -- ố
	[0x001ED2] = "O",     -- Ồ
	[0x001ED3] = "o",     -- ồ
	[0x001ED4] = "O",     -- Ổ
	[0x001ED5] = "o",     -- ổ
	[0x001ED6] = "O",     -- Ỗ
	[0x001ED7] = "o",     -- ỗ
	[0x001ED8] = "O",     -- Ộ
	[0x001ED9] = "o",     -- ộ
	[0x001EDA] = "O",     -- Ớ
	[0x001EDB] = "o",     -- ớ
	[0x001EDC] = "O",     -- Ờ
	[0x001EDD] = "o",     -- ờ
	[0x001EDE] = "O",     -- Ở
	[0x001EDF] = "o",     -- ở
	[0x001EE0] = "O",     -- Ỡ
	[0x001EE1] = "o",     -- ỡ
	[0x001EE2] = "O",     -- Ợ
	[0x001EE3] = "o",     -- ợ
	[0x001EE4] = "U",     -- Ụ
	[0x001EE5] = "u",     -- ụ
	[0x001EE6] = "U",     -- Ủ
	[0x001EE7] = "u",     -- ủ
	[0x001EE8] = "U",     -- Ứ
	[0x001EE9] = "u",     -- ứ
	[0x001EEA] = "U",     -- Ừ
	[0x001EEB] = "u",     -- ừ
	[0x001EEC] = "U",     -- Ử
	[0x001EED] = "u",     -- ử
	[0x001EEE] = "U",     -- Ữ
	[0x001EEF] = "u",     -- ữ
	[0x001EF0] = "U",     -- Ự
	[0x001EF1] = "u",     -- ự
	[0x001EF2] = "Y",     -- Ỳ
	[0x001EF3] = "y",     -- ỳ
	[0x001EF4] = "Y",     -- Ỵ
	[0x001EF5] = "y",     -- ỵ
	[0x001EF6] = "Y",     -- Ỷ
	[0x001EF7] = "y",     -- ỷ
	[0x001EF8] = "Y",     -- Ỹ
	[0x001EF9] = "y",     -- ỹ
	[0x002013] = "-",     -- –
	[0x002014] = "-",     -- —
	[0x002020] = "t",     -- †
	[0x002025] = "..",    -- ‥
	[0x002026] = "...",   -- …
	[0x00203C] = "!!",    -- ‼
	[0x00203E] = "-",     -- ‾
	[0x002074] = "4",     -- ⁴
	[0x002075] = "5",     -- ⁵
	[0x002076] = "6",     -- ⁶
	[0x002077] = "7",     -- ⁷
	[0x002078] = "8",     -- ⁸
	[0x002079] = "9",     -- ⁹
	[0x00207F] = "n",     -- ⁿ
	[0x002081] = "1",     -- ₁
	[0x002082] = "2",     -- ₂
	[0x002083] = "3",     -- ₃
	[0x002084] = "4",     -- ₄
	[0x002085] = "5",     -- ₅
	[0x002086] = "6",     -- ₆
	[0x002087] = "7",     -- ₇
	[0x002088] = "8",     -- ₈
	[0x002089] = "9",     -- ₉
	[0x0020AC] = "E",     -- €
	[0x002102] = "C",     -- ℂ
	[0x002103] = "C",     -- ℃
	[0x002109] = "F",     -- ℉
	[0x00210C] = "H",     -- ℌ
	[0x00210D] = "H",     -- ℍ
	[0x00210E] = "h",     -- ℎ
	[0x002111] = "I",     -- ℑ
	[0x002115] = "N",     -- ℕ
	[0x002117] = "P",     -- ℗
	[0x002119] = "P",     -- ℙ
	[0x00211A] = "Q",     -- ℚ
	[0x00211C] = "R",     -- ℜ
	[0x00211D] = "R",     -- ℝ
	[0x002122] = "tm",    -- ™
	[0x002124] = "Z",     -- ℤ
	[0x002128] = "Z",     -- ℨ
	[0x00212D] = "C",     -- ℭ
	[0x00216C] = "L",     -- Ⅼ
	[0x002203] = "3",     -- ∃
	[0x002208] = "E",     -- ∈
	[0x00220B] = "3",     -- ∋
	[0x00220F] = "N",     -- ∏
	[0x002210] = "U",     -- ∐
	[0x002211] = "E",     -- ∑
	[0x00221E] = "oo",    -- ∞
	[0x00222B] = "S",     -- ∫
	[0x0022C0] = "A",     -- ⋀
	[0x0022C1] = "V",     -- ⋁
	[0x0022C2] = "U",     -- ⋂
	[0x0022C3] = "U",     -- ⋃
	[0x0024B6] = "A",     -- Ⓐ
	[0x0024B7] = "B",     -- Ⓑ
	[0x0024B8] = "C",     -- Ⓒ
	[0x0024B9] = "D",     -- Ⓓ
	[0x0024BA] = "E",     -- Ⓔ
	[0x0024BB] = "F",     -- Ⓕ
	[0x0024BC] = "G",     -- Ⓖ
	[0x0024BD] = "H",     -- Ⓗ
	[0x0024BE] = "I",     -- Ⓘ
	[0x0024BF] = "J",     -- Ⓙ
	[0x0024C0] = "K",     -- Ⓚ
	[0x0024C1] = "L",     -- Ⓛ
	[0x0024C2] = "M",     -- Ⓜ
	[0x0024C3] = "N",     -- Ⓝ
	[0x0024C4] = "O",     -- Ⓞ
	[0x0024C5] = "P",     -- Ⓟ
	[0x0024C6] = "Q",     -- Ⓠ
	[0x0024C7] = "R",     -- Ⓡ
	[0x0024C8] = "S",     -- Ⓢ
	[0x0024C9] = "T",     -- Ⓣ
	[0x0024CA] = "U",     -- Ⓤ
	[0x0024CB] = "V",     -- Ⓥ
	[0x0024CC] = "W",     -- Ⓦ
	[0x0024CD] = "X",     -- Ⓧ
	[0x0024CE] = "Y",     -- Ⓨ
	[0x0024CF] = "Z",     -- Ⓩ
	[0x0024D0] = "a",     -- ⓐ
	[0x0024D1] = "b",     -- ⓑ
	[0x0024D2] = "c",     -- ⓒ
	[0x0024D3] = "d",     -- ⓓ
	[0x0024D4] = "e",     -- ⓔ
	[0x0024D5] = "f",     -- ⓕ
	[0x0024D6] = "g",     -- ⓖ
	[0x0024D7] = "h",     -- ⓗ
	[0x0024D8] = "i",     -- ⓘ
	[0x0024D9] = "j",     -- ⓙ
	[0x0024DA] = "k",     -- ⓚ
	[0x0024DB] = "l",     -- ⓛ
	[0x0024DC] = "m",     -- ⓜ
	[0x0024DD] = "n",     -- ⓝ
	[0x0024DE] = "o",     -- ⓞ
	[0x0024DF] = "p",     -- ⓟ
	[0x0024E0] = "q",     -- ⓠ
	[0x0024E1] = "r",     -- ⓡ
	[0x0024E2] = "s",     -- ⓢ
	[0x0024E3] = "t",     -- ⓣ
	[0x0024E4] = "u",     -- ⓤ
	[0x0024E5] = "v",     -- ⓥ
	[0x0024E6] = "w",     -- ⓦ
	[0x0024E7] = "x",     -- ⓧ
	[0x0024E8] = "y",     -- ⓨ
	[0x0024E9] = "z",     -- ⓩ
	[0x01D400] = "A",     -- 𝐀
	[0x01D401] = "B",     -- 𝐁
	[0x01D402] = "C",     -- 𝐂
	[0x01D403] = "D",     -- 𝐃
	[0x01D404] = "E",     -- 𝐄
	[0x01D405] = "F",     -- 𝐅
	[0x01D406] = "G",     -- 𝐆
	[0x01D407] = "H",     -- 𝐇
	[0x01D408] = "I",     -- 𝐈
	[0x01D409] = "J",     -- 𝐉
	[0x01D40A] = "K",     -- 𝐊
	[0x01D40B] = "L",     -- 𝐋
	[0x01D40C] = "M",     -- 𝐌
	[0x01D40D] = "N",     -- 𝐍
	[0x01D40E] = "O",     -- 𝐎
	[0x01D40F] = "P",     -- 𝐏
	[0x01D410] = "Q",     -- 𝐐
	[0x01D411] = "R",     -- 𝐑
	[0x01D412] = "S",     -- 𝐒
	[0x01D413] = "T",     -- 𝐓
	[0x01D414] = "U",     -- 𝐔
	[0x01D415] = "V",     -- 𝐕
	[0x01D416] = "W",     -- 𝐖
	[0x01D417] = "X",     -- 𝐗
	[0x01D418] = "Y",     -- 𝐘
	[0x01D419] = "Z",     -- 𝐙
	[0x01D41A] = "a",     -- 𝐚
	[0x01D41B] = "b",     -- 𝐛
	[0x01D41C] = "c",     -- 𝐜
	[0x01D41D] = "d",     -- 𝐝
	[0x01D41E] = "e",     -- 𝐞
	[0x01D41F] = "f",     -- 𝐟
	[0x01D420] = "g",     -- 𝐠
	[0x01D421] = "h",     -- 𝐡
	[0x01D422] = "i",     -- 𝐢
	[0x01D423] = "j",     -- 𝐣
	[0x01D424] = "k",     -- 𝐤
	[0x01D425] = "l",     -- 𝐥
	[0x01D426] = "m",     -- 𝐦
	[0x01D427] = "n",     -- 𝐧
	[0x01D428] = "o",     -- 𝐨
	[0x01D429] = "p",     -- 𝐩
	[0x01D42A] = "q",     -- 𝐪
	[0x01D42B] = "r",     -- 𝐫
	[0x01D42C] = "s",     -- 𝐬
	[0x01D42D] = "t",     -- 𝐭
	[0x01D42E] = "u",     -- 𝐮
	[0x01D42F] = "v",     -- 𝐯
	[0x01D430] = "w",     -- 𝐰
	[0x01D431] = "x",     -- 𝐱
	[0x01D432] = "y",     -- 𝐲
	[0x01D433] = "z",     -- 𝐳
	[0x01D434] = "A",     -- 𝐴
	[0x01D435] = "B",     -- 𝐵
	[0x01D436] = "C",     -- 𝐶
	[0x01D437] = "D",     -- 𝐷
	[0x01D438] = "E",     -- 𝐸
	[0x01D439] = "F",     -- 𝐹
	[0x01D43A] = "G",     -- 𝐺
	[0x01D43B] = "H",     -- 𝐻
	[0x01D43C] = "I",     -- 𝐼
	[0x01D43D] = "J",     -- 𝐽
	[0x01D43E] = "K",     -- 𝐾
	[0x01D43F] = "L",     -- 𝐿
	[0x01D440] = "M",     -- 𝑀
	[0x01D441] = "N",     -- 𝑁
	[0x01D442] = "O",     -- 𝑂
	[0x01D443] = "P",     -- 𝑃
	[0x01D444] = "Q",     -- 𝑄
	[0x01D445] = "R",     -- 𝑅
	[0x01D446] = "S",     -- 𝑆
	[0x01D447] = "T",     -- 𝑇
	[0x01D448] = "U",     -- 𝑈
	[0x01D449] = "V",     -- 𝑉
	[0x01D44A] = "W",     -- 𝑊
	[0x01D44B] = "X",     -- 𝑋
	[0x01D44C] = "Y",     -- 𝑌
	[0x01D44D] = "Z",     -- 𝑍
	[0x01D44E] = "a",     -- 𝑎
	[0x01D44F] = "b",     -- 𝑏
	[0x01D450] = "c",     -- 𝑐
	[0x01D451] = "d",     -- 𝑑
	[0x01D452] = "e",     -- 𝑒
	[0x01D453] = "f",     -- 𝑓
	[0x01D454] = "g",     -- 𝑔
	[0x01D456] = "i",     -- 𝑖
	[0x01D457] = "j",     -- 𝑗
	[0x01D458] = "k",     -- 𝑘
	[0x01D459] = "l",     -- 𝑙
	[0x01D45A] = "m",     -- 𝑚
	[0x01D45B] = "n",     -- 𝑛
	[0x01D45C] = "o",     -- 𝑜
	[0x01D45D] = "p",     -- 𝑝
	[0x01D45E] = "q",     -- 𝑞
	[0x01D45F] = "r",     -- 𝑟
	[0x01D460] = "s",     -- 𝑠
	[0x01D461] = "t",     -- 𝑡
	[0x01D462] = "u",     -- 𝑢
	[0x01D463] = "v",     -- 𝑣
	[0x01D464] = "w",     -- 𝑤
	[0x01D465] = "x",     -- 𝑥
	[0x01D466] = "y",     -- 𝑦
	[0x01D467] = "z",     -- 𝑧
	[0x01D49C] = "A",     -- 𝒜
	[0x01D49E] = "C",     -- 𝒞
	[0x01D49F] = "D",     -- 𝒟
	[0x01D4A2] = "G",     -- 𝒢
	[0x01D4A5] = "J",     -- 𝒥
	[0x01D4A6] = "K",     -- 𝒦
	[0x01D4A9] = "N",     -- 𝒩
	[0x01D4AA] = "O",     -- 𝒪
	[0x01D4AB] = "P",     -- 𝒫
	[0x01D4AC] = "Q",     -- 𝒬
	[0x01D4AE] = "S",     -- 𝒮
	[0x01D4AF] = "T",     -- 𝒯
	[0x01D4B0] = "U",     -- 𝒰
	[0x01D4B1] = "V",     -- 𝒱
	[0x01D4B2] = "W",     -- 𝒲
	[0x01D4B3] = "X",     -- 𝒳
	[0x01D4B4] = "Y",     -- 𝒴
	[0x01D4B5] = "Z",     -- 𝒵
	[0x01D4B6] = "a",     -- 𝒶
	[0x01D4B7] = "b",     -- 𝒷
	[0x01D4B8] = "c",     -- 𝒸
	[0x01D4B9] = "d",     -- 𝒹
	[0x01D4BB] = "f",     -- 𝒻
	[0x01D4BD] = "h",     -- 𝒽
	[0x01D4BE] = "i",     -- 𝒾
	[0x01D4BF] = "j",     -- 𝒿
	[0x01D4C0] = "k",     -- 𝓀
	[0x01D4C1] = "l",     -- 𝓁
	[0x01D4C2] = "m",     -- 𝓂
	[0x01D4C3] = "n",     -- 𝓃
	[0x01D4C5] = "p",     -- 𝓅
	[0x01D4C6] = "q",     -- 𝓆
	[0x01D4C7] = "r",     -- 𝓇
	[0x01D4C8] = "s",     -- 𝓈
	[0x01D4C9] = "t",     -- 𝓉
	[0x01D4CA] = "u",     -- 𝓊
	[0x01D4CB] = "v",     -- 𝓋
	[0x01D4CC] = "w",     -- 𝓌
	[0x01D4CD] = "x",     -- 𝓍
	[0x01D4CE] = "y",     -- 𝓎
	[0x01D4CF] = "z",     -- 𝓏
	[0x01D504] = "A",     -- 𝔄
	[0x01D505] = "B",     -- 𝔅
	[0x01D507] = "D",     -- 𝔇
	[0x01D508] = "E",     -- 𝔈
	[0x01D509] = "F",     -- 𝔉
	[0x01D50A] = "G",     -- 𝔊
	[0x01D50D] = "J",     -- 𝔍
	[0x01D50E] = "K",     -- 𝔎
	[0x01D50F] = "L",     -- 𝔏
	[0x01D510] = "M",     -- 𝔐
	[0x01D511] = "N",     -- 𝔑
	[0x01D512] = "O",     -- 𝔒
	[0x01D513] = "P",     -- 𝔓
	[0x01D514] = "Q",     -- 𝔔
	[0x01D516] = "S",     -- 𝔖
	[0x01D517] = "T",     -- 𝔗
	[0x01D518] = "U",     -- 𝔘
	[0x01D519] = "V",     -- 𝔙
	[0x01D51A] = "W",     -- 𝔚
	[0x01D51B] = "X",     -- 𝔛
	[0x01D51C] = "Y",     -- 𝔜
	[0x01D51E] = "a",     -- 𝔞
	[0x01D51F] = "b",     -- 𝔟
	[0x01D520] = "c",     -- 𝔠
	[0x01D521] = "d",     -- 𝔡
	[0x01D522] = "e",     -- 𝔢
	[0x01D523] = "f",     -- 𝔣
	[0x01D524] = "g",     -- 𝔤
	[0x01D525] = "h",     -- 𝔥
	[0x01D526] = "i",     -- 𝔦
	[0x01D527] = "j",     -- 𝔧
	[0x01D528] = "k",     -- 𝔨
	[0x01D529] = "l",     -- 𝔩
	[0x01D52A] = "m",     -- 𝔪
	[0x01D52B] = "n",     -- 𝔫
	[0x01D52C] = "o",     -- 𝔬
	[0x01D52D] = "p",     -- 𝔭
	[0x01D52E] = "q",     -- 𝔮
	[0x01D52F] = "r",     -- 𝔯
	[0x01D530] = "s",     -- 𝔰
	[0x01D531] = "t",     -- 𝔱
	[0x01D532] = "u",     -- 𝔲
	[0x01D533] = "v",     -- 𝔳
	[0x01D534] = "w",     -- 𝔴
	[0x01D535] = "x",     -- 𝔵
	[0x01D536] = "y",     -- 𝔶
	[0x01D537] = "z",     -- 𝔷
	[0x01D538] = "A",     -- 𝔸
	[0x01D539] = "B",     -- 𝔹
	[0x01D53B] = "D",     -- 𝔻
	[0x01D53C] = "E",     -- 𝔼
	[0x01D53D] = "F",     -- 𝔽
	[0x01D53E] = "G",     -- 𝔾
	[0x01D540] = "I",     -- 𝕀
	[0x01D541] = "J",     -- 𝕁
	[0x01D542] = "K",     -- 𝕂
	[0x01D543] = "L",     -- 𝕃
	[0x01D544] = "M",     -- 𝕄
	[0x01D546] = "O",     -- 𝕆
	[0x01D54A] = "S",     -- 𝕊
	[0x01D54B] = "T",     -- 𝕋
	[0x01D54C] = "U",     -- 𝕌
	[0x01D54D] = "V",     -- 𝕍
	[0x01D54E] = "W",     -- 𝕎
	[0x01D54F] = "X",     -- 𝕏
	[0x01D550] = "Y",     -- 𝕐
	[0x01D552] = "a",     -- 𝕒
	[0x01D553] = "b",     -- 𝕓
	[0x01D554] = "c",     -- 𝕔
	[0x01D555] = "d",     -- 𝕕
	[0x01D556] = "e",     -- 𝕖
	[0x01D557] = "f",     -- 𝕗
	[0x01D558] = "g",     -- 𝕘
	[0x01D559] = "h",     -- 𝕙
	[0x01D55A] = "i",     -- 𝕚
	[0x01D55B] = "j",     -- 𝕛
	[0x01D55C] = "k",     -- 𝕜
	[0x01D55D] = "l",     -- 𝕝
	[0x01D55E] = "m",     -- 𝕞
	[0x01D55F] = "n",     -- 𝕟
	[0x01D560] = "o",     -- 𝕠
	[0x01D561] = "p",     -- 𝕡
	[0x01D562] = "q",     -- 𝕢
	[0x01D563] = "r",     -- 𝕣
	[0x01D564] = "s",     -- 𝕤
	[0x01D565] = "t",     -- 𝕥
	[0x01D566] = "u",     -- 𝕦
	[0x01D567] = "v",     -- 𝕧
	[0x01D568] = "w",     -- 𝕨
	[0x01D569] = "x",     -- 𝕩
	[0x01D56A] = "y",     -- 𝕪
	[0x01D56B] = "z",     -- 𝕫
}

function LIB.StripAccents(str, alsoStripHighUnicode)
	str = utf8.force(str)

	local stripped = {}

	for _, codepoint in utf8.codes(str) do
		local char = g_accentMap[codepoint]

		if not char then
			if alsoStripHighUnicode and codepoint > 0x7F then
				continue;
			end

			char = utf8.char(codepoint)
		end

		table.insert(stripped, char)
	end

	stripped = table.concat(stripped)

	return stripped
end

return true


--PATH lua/streamradio_core/url.lua:
return gluapack()()
--PATH lua/streamradio_core/json.lua:
return gluapack()()
--PATH lua/streamradio_core/http.lua:
return gluapack()()
--PATH lua/streamradio_core/models/cs_office_tv.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- CS:S Office Plasma TV
RADIOMDL.model = "models/props/cs_office/tv_plasma.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(6.20, 0, 17.10)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)


RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,      R,     U
RADIOMDL.DisplayOffset    = Vector(6.20, -27.90, 35.25) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(6.20,  27.95,  2.55) -- Bottom Right

RADIOMDL.DisplayWidth = 2048
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {50,	1000},
	Default	= {44,	700},
	Tooltip	= {44,	1000},
	Big		= {60,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 125)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 100)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 100)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 100)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 12
	local padding = 12
	local margin = 12

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/csgo_italy_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- CS:GO Wooden Oldschool Radio
RADIOMDL.model = "models/props/cs_italy/radio_wooden.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(4.3, 0, 10.6)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(4.80, -2.53, 5.50) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(4.80,  2.65, 0.50) -- Bottom Right

RADIOMDL.DisplayWidth = 450
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)


RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {25,	1000},
	Small	= {18,	700},
	Default	= {23,	700},
	Tooltip	= {23,	800},
	Big		= {25,	700},
	Button	= {20,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Small)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Button)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Button)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Button)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 50)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 1, y = 7})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 1, y = 7})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 25)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 50)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 16)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 3
	local padding = 2
	local margin = 2

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/kankan_radio.lua:
return gluapack()()
--PATH lua/streamradio_core/models/kankan_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Unitra DIORA - Radiowerk Dzierzoniow: KanKan Radio II
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=2891337724
RADIOMDL.model = "models/radio/kankan/kankan.mdl"

RADIOMDL.SpawnAng = Angle(0, 90, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(-8.55, -3, 7.80)
RADIOMDL.SoundAngOffset = Angle(0, -90, 0)

RADIOMDL.DisplayAngles = Angle(0, 0, 82.0)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(-3, -5.00, 10.65) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(-19.00,  -5.00, 5.50) -- Bottom Right

RADIOMDL.DisplayWidth = 1024
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(
	RADIOMDL.DisplayOffset,
	RADIOMDL.DisplayOffsetEnd,
	RADIOMDL.DisplayWidth,
	RADIOMDL.DISPLAY_POS_RIGHT
)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {21,	1000},
	Default	= {20,	700},
	Tooltip	= {18,	800},
	Big		= {22,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 16)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/nm_screen.lua:
return gluapack()()
--PATH lua/streamradio_core/models/wire_speaker3.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Wire Speaker 3
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=160250458
RADIOMDL.model = "models/killa-x/speakers/speaker_small.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false

return true


--PATH lua/streamradio_core/models/wire_subwoofer_big.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Filesystem = StreamRadioLib.Filesystem or {}

local LIB = StreamRadioLib.Filesystem
table.Empty(LIB)

local LIBString = StreamRadioLib.String
local LIBUtil = StreamRadioLib.Util

local g_playlistdir = LIBUtil.GetMainDirectory("playlists")
local g_luaFilesystemDirectory = "streamradio_core/filesystem"
local g_Filesystem = {}
local g_FilesystemBlacklist = {}

local g_emptyFunction = function() end

local g_FolderID = 1
local g_VirtualFolderID = 250
local g_GenericID = ":generic"

local g_VirtualFolderIcon = StreamRadioLib.GetPNGIcon("folder_link")

StreamRadioLib.TYPE_FOLDER = g_FolderID
StreamRadioLib.TYPE_DEFAULT = nil
StreamRadioLib.VALID_FORMATS_EXTENSIONS_LIST = ""

local function getFS(id)
	if not g_Filesystem then return nil end
	if not g_Filesystem.id then return nil end
	if not g_Filesystem.type then return nil end
	if not g_Filesystem.name then return nil end

	if not id then return nil end

	local fs = g_Filesystem.id[id] or g_Filesystem.type[id] or g_Filesystem.name[id]
	if not fs then return nil end

	if fs.type ~= g_GenericID then
		if g_FilesystemBlacklist[fs.id] then return nil end
		if g_FilesystemBlacklist[fs.type] then return nil end
		if g_FilesystemBlacklist[fs.name] then return nil end
	end

	if isfunction(fs.IsInstalled) and not fs:IsInstalled() then
		return nil
	end

	return fs
end

local g_pathLevelsCache = {}

local function AddCommonFunctions(fs)
	if not fs then return end

	function fs:Find(globalpath, vfolder, callback)
		local files = file.Find(globalpath .. "/*_" .. self.type .. ".txt", "DATA", "nameasc")

		files = LIB.FilterInvalidFilesnames(files)

		callback(true, files, nil)
		return true
	end

	function fs:Delete(globalpath, vpath, callback)
		file.Delete(globalpath)
		local deleted = not file.Exists(globalpath, "DATA")
		callback(deleted)

		return deleted
	end

	function fs:Exists(globalpath, vpath)
		if not file.Exists(globalpath, "DATA") then
			return false
		end

		return true
	end

	function fs:CreateDirectoryForFile(globalpath)
		return LIBUtil.CreateDirectoryForFile(globalpath)
	end

	function fs:IsType(globalpath, vpath)
		local ext = string.lower(string.GetExtensionFromFilename(vpath) or "")
		if ext == self.type then
			return true
		end

		return false
	end

	function fs:SavePCall(func, ...)
		if not isfunction(func) then
			return nil
		end

		return pcall(func, ...)
	end

	function fs:GetPathLevels(vpath)
		vpath = string.Trim(vpath or "")

		g_pathLevelsCache = g_pathLevelsCache or {}

		if g_pathLevelsCache[vpath] then
			return g_pathLevelsCache[vpath]
		end

		g_pathLevelsCache[vpath] = nil

		local levels = string.Explode("/", vpath, false) or {}
		local out = {}

		for i, v in ipairs(levels) do
			v = string.Trim(v, "/")
			if v == "" then continue end

			table.insert(out, v)
		end

		if table.IsEmpty(out) then
			return out
		end

		g_pathLevelsCache[vpath] = out
		return out
	end
end

local function loadFilesystem(script)
	script = script or ""
	if script == "" then return nil end

	local scriptpath = g_luaFilesystemDirectory .. "/"
	local scriptfile = scriptpath .. script

	RADIOFS = nil
	RADIOFS = {}

	RADIOFS.scriptpath = scriptpath
	RADIOFS.scriptfile = scriptfile

	AddCommonFunctions(RADIOFS)

	StreamRadioLib.LoadSH(scriptfile, true)

	local name = string.Trim(RADIOFS.name or "")
	local type = string.Trim(RADIOFS.type or "")

	RADIOFS.priority = tonumber(RADIOFS.priority or 0) or 0

	if name == "" then
		RADIOFS = nil
		return nil
	end

	if type == "" then
		RADIOFS = nil
		return nil
	end

	if RADIOFS.disabled then
		RADIOFS = nil
		return nil
	end

	local fs = RADIOFS
	RADIOFS = nil

	return fs
end

local function SetupPath(folder1, folder2)
	folder1 = folder1 or ""
	folder2 = folder2 or ""

	if folder1 == "" then return end
	if folder2 == "" then return end

	return folder1 .. "/" .. folder2
end


local function ConvertVirtualFilename(filename)
	filename = filename or ""

	local ext = string.GetExtensionFromFilename(filename) or ""
	if ext == "txt" then
		return filename
	end

	local validext = getFS(ext)
	if not validext then
		return filename
	end

	local noext = string.sub(filename, 0, -(2 + #ext))
	filename = noext .. "_" .. ext .. ".txt"

	return filename
end

local function ConvertGlobalFilename(filename)
	local ext = string.GetExtensionFromFilename(filename) or ""
	if ext ~= "txt" then
		return filename
	end

	local noext = string.StripExtension(filename)

	local vext_tbl = string.Explode("_", noext, false)
	if not vext_tbl then
		return filename
	end

	local vext = vext_tbl[#vext_tbl]
	vext_tbl[#vext_tbl] = nil

	noext = table.concat(vext_tbl, "_")

	local validext = getFS(vext)
	if not validext then
		return filename
	end

	return noext .. "." .. vext
end

local function VirtualPathToGlobal(path, asfolder)
	path = path or ""
	path = SetupPath(g_playlistdir, path) or g_playlistdir

	if not asfolder then
		path = ConvertVirtualFilename(path)
	end

	return path
end

local function SanitizeData(data)
	local tmp = {}
	for k, v in pairs(data) do
		local url = string.Trim(tostring(v.url or v.uri or v.link or v.source or v.path or ""))
		local name = string.Trim(tostring(v.name or v.title or ""))

		if url == "" then
			continue
		end

		if name == "" then
			name = url
		end

		table.insert(tmp, {
			order = tonumber(k or 0) or 0,
			name = name,
			url = url,
		})
	end

	table.SortByMember(tmp, "order", true)

	for i, v in ipairs(tmp) do
		tmp[i].order = nil
	end

	return tmp
end

function LIB.Load()
	local files = file.Find(g_luaFilesystemDirectory .. "/*", "LUA")

	local filesystems = {};

	for _, f in ipairs(files or {}) do
		local fs = loadFilesystem(f)
		if not fs then
			continue
		end

		table.insert(filesystems, fs)
	end

	g_Filesystem = {}
	g_Filesystem.id = {}
	g_Filesystem.type = {}
	g_Filesystem.name = {}

	table.SortByMember(filesystems, "priority", false)

	local index = g_FolderID -- first is folder
	local formats = {}

	for _, fs in ipairs(filesystems) do
		fs.id = index

		local id = fs.id
		local type = fs.type
		local name = fs.name
		local extension = fs.extension or ""

		g_Filesystem.id[id] = fs
		g_Filesystem.type[type] = fs
		g_Filesystem.name[name] = fs

		index = index + 1

		local isDefault = false

		if fs.default and not StreamRadioLib.TYPE_DEFAULT then
			isDefault = true
			StreamRadioLib.TYPE_DEFAULT = id
		end

		if extension ~= "" then
			extension = "*." .. extension

			if isDefault then
				extension = extension .. " (default)"
			end

			table.insert(formats, extension)
		end
	end

	StreamRadioLib.VALID_FORMATS_EXTENSIONS_LIST = table.concat(formats, ", ")
end

function LIB.FilterInvalidFilesnames(filenames)
	if not istable(filenames) then
		filenames = {filenames}
	end

	local results = {}

	for i, filename in ipairs(filenames) do
		if not LIBString.IsValidFilename(filename) then
			continue
		end

		table.insert(results, filename)
	end

	return results
end

function LIB.FilterInvalidFilepaths(filepaths)
	if not istable(filepaths) then
		filepaths = {filepaths}
	end

	local results = {}

	for i, filepath in ipairs(filepaths) do
		if not LIBString.IsValidFilepath(filepath) then
			continue
		end

		table.insert(results, filepath)
	end

	return results
end

function LIB.IsFolder(filetype)
	if not filetype then
		return false
	end

	if filetype == g_FolderID then
		return true
	end

	if filetype == g_VirtualFolderID then
		return true
	end

	filetype = LIB.GetTypeID(filetype)

	if filetype == g_FolderID then
		return true
	end

	if filetype == g_VirtualFolderID then
		return true
	end

	return false
end

function LIB.GetIcon(filetype)
	if not filetype then
		return LIB.GetIcon(g_GenericID)
	end

	if filetype == g_VirtualFolderID then
		return g_VirtualFolderIcon
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetIcon(g_GenericID)
	end

	if not fs.icon then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetIcon(g_GenericID)
	end

	return fs.icon
end

function LIB.GetTypeID(filetype)
	if not filetype then
		return LIB.GetTypeID(g_GenericID)
	end

	if filetype == g_VirtualFolderID then
		return g_VirtualFolderID
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetTypeID(g_GenericID)
	end

	return fs.id
end

function LIB.GetTypeName(filetype)
	if not filetype then
		return LIB.GetTypeName(g_GenericID)
	end

	if filetype == g_VirtualFolderID then
		return "Virtual Folder"
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetTypeName(g_GenericID)
	end

	return fs.name
end

function LIB.GetTypeExt(filetype)
	if not filetype then
		return LIB.GetTypeExt(g_GenericID)
	end

	if filetype == g_VirtualFolderID then
		return "Virtual Folder"
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return nil
		end

		return LIB.GetTypeExt(g_GenericID)
	end

	return fs.type
end

function LIB.CanLoadToWhitelist(filetype)
	if not filetype then
		return LIB.CanLoadToWhitelist(g_GenericID)
	end

	local fs = getFS(filetype)

	if not fs then
		if filetype == g_GenericID then
			return true
		end

		return LIB.CanLoadToWhitelist(g_GenericID)
	end

	return fs.loadToWhitelist or false
end

function LIB.IsEnabledFilesystem(fsid)
	local fs = getFS(fsid)

	if not fs then
		return false
	end

	return true
end

function LIB.CreateFolder(vpath, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false)
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" then
		callback(false)
		return false
	end

	if LIBString.IsVirtualPath(vpath) then
		callback(false)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false)
		return false
	end

	local globalpath = VirtualPathToGlobal(vpath, true)

	if LIB.Exists(vpath, g_FolderID) then
		callback(true)
		return true
	end

	file.CreateDir(globalpath)

	if not LIB.Exists(vpath, g_FolderID) then
		callback(false)
		return false
	end

	callback(true)
	return true
end

function LIB.CanReadFormat(filetype)
	if LIB.IsFolder(filetype) then
		return false
	end

	local fs = getFS(filetype)

	if not fs then
		return false
	end

	if not fs.Read then
		return false
	end

	return true
end

function LIB.CanWriteFormat(filetype)
	if LIB.IsFolder(filetype) then
		return false
	end

	local fs = getFS(filetype)

	if not fs then
		return false
	end

	if not fs.Write then
		return false
	end

	return true
end

function LIB.CanCreateFormat(filetype)
	if LIB.IsFolder(filetype) then
		return false
	end

	if not LIB.CanWriteFormat(filetype) then
		return false
	end

	local fs = getFS(filetype)

	if fs.nocreate then
		return false
	end

	return true
end

function LIB.CanDeleteFormat(filetype)
	if LIB.IsFolder(filetype) then
		if LIBString.IsVirtualPath(vpath) then
			return false
		end

		return true
	end

	local fs = getFS(filetype)

	if not fs then
		return false
	end

	if not fs.Delete then
		return false
	end

	return true
end

function LIB.Read(vpath, filetype, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false, nil)
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" then
		callback(false, nil)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false, nil)
		return false
	end

	local globalpath = VirtualPathToGlobal(vpath)

	local fs = getFS(filetype)

	if not fs then
		callback(false, nil)
		return false
	end

	if not fs.Read then
		callback(false, nil)
		return false
	end

	if not fs.Exists then
		callback(false, nil)
		return false
	end

	if not fs:Exists(globalpath, vpath) then
		callback(false, nil)
		return false
	end

	return fs:Read(globalpath, vpath, function(success, data)
		if not success then
			callback(false, nil)
			return
		end

		if not data then
			callback(false, nil)
			return
		end

		data = SanitizeData(data)

		if SERVER then
			local urls = table.MemberValuesFromKey(data, "url")
			StreamRadioLib.Whitelist.UpdateFromPlaylist(vpath, urls)
		end

		callback(success, data)
	end)
end

function LIB.Write(vpath, filetype, data, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false)
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" then
		callback(false)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false)
		return false
	end

	local globalpath = VirtualPathToGlobal(vpath)

	if not data then
		callback(false)
		return false
	end

	data = SanitizeData(data)
	local fs = getFS(filetype)

	if not fs then
		callback(false)
		return false
	end

	if not fs.Write then
		callback(false)
		return false
	end

	return fs:Write(globalpath, vpath, data, function(success, ...)
		if SERVER and success then
			local urls = table.MemberValuesFromKey(data, "url")
			StreamRadioLib.Whitelist.UpdateFromPlaylist(vpath, urls)
			StreamRadioLib.Whitelist.InvalidateCache()
		end

		callback(success, ...)
	end)
end

function LIB.Delete(vpath, filetype, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false)
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" then
		callback(false)
		return false
	end

	if not LIBString.IsValidFilepath(vpath) then
		callback(false)
		return false
	end

	local globalpath = VirtualPathToGlobal(vpath, LIB.IsFolder(filetype))

	local fs = getFS(filetype)

	if not fs then
		callback(false)
		return false
	end

	if not fs.Delete then
		callback(false)
		return false
	end

	return fs:Delete(globalpath, vpath, function(success, ...)
		if SERVER and success then
			StreamRadioLib.Whitelist.RemoveByPlaylist(vpath)
			StreamRadioLib.Whitelist.InvalidateCache()
		end

		callback(success, ...)
	end)
end

function LIB.Exists(vpath, filetype)
	if not StreamRadioLib.DataDirectory then
		return false
	end

	vpath = string.lower(vpath or "")

	if vpath == "" or vpath == "/" or vpath == "./" then
		return LIB.IsFolder(filetype)
	end

	local globalpath = VirtualPathToGlobal(vpath, LIB.IsFolder(filetype))

	local fs = getFS(filetype)

	if not fs then
		return false
	end

	if not fs.Exists then
		return false
	end

	return fs:Exists(globalpath, vpath)
end

local isvname = LIBString.IsVirtualPath
local lower = string.lower

local function sorter(a, b)
	local a_name = lower(a.file or "")
	local b_name = lower(b.file or "")

	local a_virtual = isvname(a_name)
	local b_virtual = isvname(b_name)

	if a_virtual == b_virtual then
		return a_name < b_name
	end

	if a_virtual then
		return true
	end

	if b_virtual then
		return false
	end

	return a_name < b_name
end

function LIB.Find(vfolder, callback)
	callback = callback or g_emptyFunction

	if not StreamRadioLib.DataDirectory then
		callback(false, nil)
		return false
	end

	vfolder = string.lower(vfolder or "")
	if not LIBString.IsValidFilepath(vfolder) then
		callback(false, nil)
		return false
	end

	local globalpath = SetupPath(g_playlistdir, vfolder) or g_playlistdir

	local wait = {}

	local folderlist = {}
	local filelist = {}
	local nodouble_folder = {}
	local nodouble_files = {}

	for id, fs in ipairs(g_Filesystem.id or {}) do
		if not fs then continue end
		if not getFS(id) then continue end
		if not fs.Find then continue end

		wait[id] = true

		local started = fs:Find(globalpath, vfolder, function(success, files, folders)
			files = files or {}
			folders = folders or {}

			wait[id] = nil

			for i, name in ipairs(folders) do
				local filepath = SetupPath(vfolder, name) or name
				if nodouble_folder[filepath] then continue end

				local typeid = vfolder == "" and g_VirtualFolderID or g_FolderID

				if id == g_FolderID then
					typeid = g_FolderID
				end

				local item = {
					isfolder = true,
					type = typeid,
					fsid = id,
					file = name,
					path = filepath,
				}

				table.insert(folderlist, item)

				nodouble_folder[filepath] = true
			end

			for i, name in ipairs(files) do
				local name = ConvertGlobalFilename(name)

				local filepath = SetupPath(vfolder, name) or name

				if nodouble_files[filepath] then continue end

				local item = {
					isfolder = false,
					type = id,
					fsid = id,
					file = name,
					path = filepath,
				}

				table.insert(filelist, item)

				nodouble_files[filepath] = true
			end
		end)

		if not started then
			wait[id] = nil
		end
	end

	local callcallback = function()
		table.sort(folderlist, sorter)
		table.sort(filelist, sorter)

		local outlist = {}
		table.Add(outlist, folderlist)
		table.Add(outlist, filelist)

		callback(true, outlist)
	end

	StreamRadioLib.Timer.Until("Filesystem_Find_" .. tostring({}), 0.2, function()
		local done = table.IsEmpty(wait)

		if not done then
			return false
		end

		callcallback()
		return true
	end)

	return true
end

function LIB.GuessType(vpath)
	if not StreamRadioLib.DataDirectory then return nil end

	vpath = string.lower(vpath or "")
	if vpath == "" then
		return nil
	end

	if not LIBString.IsValidFilepath(vpath) then
		return nil
	end

	local globalpath = VirtualPathToGlobal(vpath)

	for id, fs in ipairs(g_Filesystem.id or {}) do
		if not fs then continue end
		if not getFS(id) then continue end
		if not fs.IsType then continue end
		if not fs:IsType(globalpath, vpath) then continue end

		return id
	end

	return nil
end

do
	local function ListFS()
		MsgN("List of loaded filesystem")

		local lineFormat = "%5s | %25s | %10s | %7s"
		local topLine = string.format(lineFormat, "ID", "Name", "Type", "Active")

		MsgN(string.format(lineFormat, "ID", "Name", "Type", "Active"))
		MsgN(string.rep("-", #topLine))

		for id, fs in ipairs(g_Filesystem.id or {}) do
			if not fs then continue end
			if fs.id == g_GenericID then continue end
			if fs.type == g_GenericID then continue end


			local isActive = getFS(id) ~= nil
			local line = string.format(lineFormat, fs.id, fs.name, fs.type, isActive and "yes" or "no")

			MsgN(line)
		end
	end

	concommand.Add( "info_streamradio_playlist_filesystem_list", ListFS)
end

local function updateBlacklistFromString(backlist)
	backlist = tostring(backlist or "")
	backlist = string.Explode("[%,%;%|]", backlist, true)

	g_FilesystemBlacklist = {}

	for i, v in ipairs(backlist) do
		v = string.Trim(v)
		g_FilesystemBlacklist[v] = true
	end
end

local flags = bit.bor(FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_GAMEDLL, FCVAR_SERVER_CAN_EXECUTE)

if SERVER then
	flags = bit.bor(flags, FCVAR_ARCHIVE)
end

local CVBacklist = CreateConVar( "sv_streamradio_playlist_filesystem_blacklist", "", flags, "Set the list playlist filesystems to be disabled by type, name or id. Entries are seperated by pipe ('|') or comma (','). See info_streamradio_playlist_filesystem_list for details. Default: ''" )

local oldCVValue = CVBacklist:GetString()
updateBlacklistFromString(oldCVValue)

StreamRadioLib.Hook.Add("Think", "Playlist_Filesystem", function()
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end
	if not CVBacklist then return end

	local CVvalue = CVBacklist:GetString()
	if oldCVValue == CVvalue then
		return
	end

	oldCVValue = CVvalue
	updateBlacklistFromString(CVvalue)
end)

return true


--PATH lua/streamradio_core/classes/base_listener.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/image.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/textview.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/list_files.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/radio/gui_browser.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/radio/gui_player.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_help.lua:
return gluapack()()
--PATH lua/streamradio_core/client/settings/admin.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Settings = StreamRadioLib.Settings or {}
local LIB = StreamRadioLib.Settings

local LIBMenu = StreamRadioLib.Menu

local g_lastThink = 0
local g_panel = nil
local g_lastIsAdmin = false

LIB.g_CV_List["admin"] = {}

local function AddDangerMenuPanel(CPanel)
	local subpanel = vgui.Create("DForm")

	subpanel:SetName("Playlists rebuild setting")

	CPanel:AddPanel(subpanel)
	subpanel:SetCookieName("streamradio_admin_playlists_rebuild")

	subpanel:AddItem(LIBMenu.GetWarnLabel("CAUTION: Be careful what you in this section!\nUnanticipated loss of CUSTOM playlist files can be caused by mistakes!"))

	subpanel:AddItem(LIBMenu.GetSpacerLine())

	subpanel:AddItem(LIBMenu.GetLabel("Rebuild mode for playlists in 'community'.\nEffective with server restarts."))

	local rebuildplaylistsCombobox, rebuildplaylistsLabel = subpanel:ComboBox(
		"Rebuild mode",
		"sv_streamradio_rebuildplaylists_community_auto"
	)
	StreamRadioLib.Menu.PatchComboBox(rebuildplaylistsCombobox, rebuildplaylistsLabel)

	rebuildplaylistsCombobox:SetSortItems(false)
	rebuildplaylistsCombobox:AddChoice("Off", 0, false, "3dstreamradio/icon16/arrow_not_refresh.png")
	rebuildplaylistsCombobox:AddSpacer()
	rebuildplaylistsCombobox:AddChoice("Auto rebuild", 1, false, "icon16/arrow_merge.png")
	rebuildplaylistsCombobox:AddChoice("Auto reset & rebuild (default)", 2, false, "icon16/arrow_refresh.png")

	subpanel:AddItem(LIBMenu.GetSpacerLine())

	subpanel:AddItem(LIBMenu.GetLabel("You may want to use this regularly to fix issues with broken playlists."))

	subpanel:AddItem(LIBMenu.GetSpacer())
	subpanel:AddItem(
		LIBMenu.AddDangerButton(
			"Rebuild community playlists",
			{
				message = "Do you really want to rebuild stock community playlists?\nThis overwrites default playlists and their changes in 'community'!",
				cmd = "sv_streamradio_rebuildplaylists_community",
			}
		)
	)
	subpanel:AddItem(LIBMenu.GetLabel("Reverts stock playlist files in 'community' to default.\nThis overwrites default playlists and their changes in 'community'!"))

	subpanel:AddItem(LIBMenu.GetSpacer())
	subpanel:AddItem(
		LIBMenu.AddDangerButton(
			"Factory reset community playlists",
			{
				message = "Do you really want to reset ALL community playlists to defaults?\nThis removes ALL custom playlists and changes in 'community'!",
				cmd = "sv_streamradio_resetplaylists_community",
			}
		)
	)
	subpanel:AddItem(LIBMenu.GetLabel("Reverts ALL playlist files in 'community' to default.\nThis removes ALL custom playlists and changes in 'community'!"))

	subpanel:AddItem(LIBMenu.GetSpacerLine())

	subpanel:AddItem(LIBMenu.GetWarnLabel("CAUTION: This section affects ALL playlists on your server!"))
	subpanel:AddItem(LIBMenu.GetLabel("Only use this if want clean up or reset nall playlist files."))

	subpanel:AddItem(LIBMenu.GetSpacer())
	subpanel:AddItem(
		LIBMenu.AddDangerButton(
			"Rebuild ALL playlists",
			{
				message = "Do you really want to rebuild stock playlists?\nThis overwrites the default playlists and their changes globally!",
				cmd = "sv_streamradio_rebuildplaylists",
				icon = "icon16/exclamation.png",
			}
		)
	)
	subpanel:AddItem(LIBMenu.GetLabel("Reverts stock playlist files to default.\nThis overwrites the default playlists and their changes globally!"))

	subpanel:AddItem(LIBMenu.GetSpacer())
	subpanel:AddItem(
		LIBMenu.AddDangerButton(
			"Factory reset ALL playlists",
			{
				message = "Do you really want to reset ALL playlists to defaults?\nThis removes ALL custom playlists and changes globally!",
				cmd = "sv_streamradio_resetplaylists",
				icon = "icon16/exclamation.png",
			}
		)
	)
	subpanel:AddItem(LIBMenu.GetLabel("Reverts ALL playlist files to default.\nThis removes ALL custom playlists and changes globally!"))

	return subpanel
end

local function AddSecurityMenuPanel(CPanel)
	local subpanel = vgui.Create("DForm")

	subpanel:SetName("Security Options")

	CPanel:AddPanel(subpanel)
	subpanel:SetCookieName("streamradio_admin_playlists_rebuild")

	subpanel:AddItem(LIBMenu.GetWarnLabel("CAUTION: This affects the server security of this addon.\nOnly disable the whitelist if you know what you are doing!\nBetter you never turn this off!"))

	subpanel:AddItem(LIBMenu.GetSpacerLine())

	local urlLogCombobox, urlLogLabel = subpanel:ComboBox(
		"Log stream URLs to console",
		"sv_streamradio_url_log_mode"
	)
	StreamRadioLib.Menu.PatchComboBox(urlLogCombobox, urlLogLabel)

	urlLogCombobox:SetSortItems(false)
	urlLogCombobox:AddChoice("No logging", 0, false, "icon16/collision_off.png")
	urlLogCombobox:AddSpacer()
	urlLogCombobox:AddChoice("Log online URLs only", 1, false, "icon16/page_world.png")
	urlLogCombobox:AddChoice("Log all URLs", 2, false, "icon16/world.png")

	local urlWhitelistCombobox, urlWhitelistLabel = subpanel:ComboBox(
		"URL Whitelist",
		"sv_streamradio_url_whitelist_enable"
	)
	StreamRadioLib.Menu.PatchComboBox(urlWhitelistCombobox, urlWhitelistLabel)

	urlWhitelistCombobox:SetSortItems(false)
	urlWhitelistCombobox:AddChoice("Enable Stream URL whitelist (recommended)", 1, false, "icon16/shield.png")
	urlWhitelistCombobox:AddChoice("Disable Stream URL whitelist (dangerous)", 0, false, "icon16/exclamation.png")

	subpanel:AddItem(LIBMenu.GetLabel("The whitelist is based of the installed playlists. Edit them to change the whitelist or use the quick whitelist options on a radio entity."))
	subpanel:AddItem(LIBMenu.GetLabel("It is always disabled on single player."))

	subpanel:CheckBox(
		"Always trust radios owned by admins (skips whitelist)",
		"sv_streamradio_url_whitelist_trust_admin_radios"
	)

	subpanel:AddItem(LIBMenu.GetSpacer())

	subpanel:AddItem(LIBMenu.GetWhitelistFAQButton())

	subpanel:AddItem(LIBMenu.GetSpacerLine())

	subpanel:AddItem(LIBMenu.GetLabel("If the server has the addon 'CFC Client HTTP Whitelist' installed, the built-in whitelist is disabled automatically for better useability."))
	subpanel:AddItem(LIBMenu.GetLabel("If the box is checked, the built-in whitelist will be always active. Both options are safe to use."))

	subpanel:CheckBox(
		"Enable the build-in whitelist even if CFC Whitelist is installed",
		"sv_streamradio_url_whitelist_enable_on_cfcwhitelist"
	)

	subpanel:AddItem(LIBMenu.GetSpacer())

	subpanel:AddItem(LIBMenu.GetCFCWhitelistFAQButton())

	subpanel:AddItem(LIBMenu.GetSpacerLine())

	subpanel:Button(
		"Reload URL Whitelist",
		"sv_streamradio_url_whitelist_reload"
	)

	subpanel:AddItem(LIBMenu.GetLabel("Press this button to reload the whitelist. It is rebuilt from server's playlist files."))
	subpanel:AddItem(LIBMenu.GetLabel("You can safely use it anytime you want."))

	return subpanel
end

local function AddBassMenuPanel(CPanel)
	local subpanel = vgui.Create("DForm")

	subpanel:SetName("GM_BASS3 Options")

	CPanel:AddPanel(subpanel)
	subpanel:SetCookieName("streamradio_admin_bass3")

	local hasBass = StreamRadioLib.Bass.IsInstalledOnServer()

	subpanel:CheckBox(
		"Use GM_BASS3 on the server if available",
		"sv_streamradio_bass3_enable"
	)

	subpanel:CheckBox(
		"Allow clients to use GM_BASS3 if available",
		"sv_streamradio_bass3_allow_client"
	)

	subpanel:AddItem(LIBMenu.GetSpacerLine())

	if not hasBass then
		subpanel:AddItem(LIBMenu.GetWarnLabel("Install GM_BASS3 on the server to unlock the options below."))
	end

	local infoLabel = LIBMenu.GetLabel("Maximum count of radios with Advanced Wire Outputs.")
	infoLabel:SetEnabled(hasBass)

	subpanel:AddItem(infoLabel)

	subpanel:NumSlider(
		"Maximum count",
		"sv_streamradio_max_spectrums",
		0,
		50,
		0
	):SetEnabled(hasBass)

	subpanel:Button(
		"Clear server stream cache",
		"sv_streamradio_cacheclear"
	):SetEnabled(hasBass)

	return subpanel
end

local function BuildMenuPanel(CPanel)
	if not IsValid(CPanel) then return end

	CPanel._UpdateAdminLayout = function(CPanel)
		CPanel:Clear()

		local toplabel = vgui.Create("DLabel")
		toplabel:SetText("3D Stream Radio admin settings")
		toplabel:SetDark(true)
		toplabel:SizeToContents()
		CPanel:AddPanel(toplabel)

		local StreamRadioLib = StreamRadioLib or {}

		if not StreamRadioLib.Loaded then
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This menu could not be loaded.")
			end

			return
		end

		if not StreamRadioLib.Util.IsAdmin() then
			CPanel:AddPanel(LIBMenu.GetWarnLabel("You need to be an admin to access this panel."))

			CPanel:AddPanel(LIBMenu.GetSpacer())

			CPanel:AddPanel(LIBMenu.GetFAQButton())
			CPanel:AddPanel(LIBMenu.GetCreditsPanel())
			return
		end

		AddBassMenuPanel(CPanel)

		CPanel:AddPanel(LIBMenu.GetSpacer())

		AddDangerMenuPanel(CPanel)

		CPanel:AddPanel(LIBMenu.GetSpacer())

		AddSecurityMenuPanel(CPanel)

		CPanel:AddPanel(LIBMenu.GetSpacer())

		CPanel:AddPanel(LIBMenu.GetOpenToolButton())
		CPanel:AddPanel(LIBMenu.GetOpenSettingsButton())
		CPanel:AddPanel(LIBMenu.GetPlaylistEditorButton())

		CPanel:AddPanel(LIBMenu.GetSpacer(5))
		CPanel:AddPanel(LIBMenu.GetFAQButton())
		CPanel:AddPanel(LIBMenu.GetCreditsPanel())
	end

	if IsValid(g_panel) then
		g_panel:Remove()
		g_panel = nil
	end

	g_panel = CPanel
	g_panel:_UpdateAdminLayout()
end

LIB.AddBuildMenuPanelHook("admin", "Admin Settings", BuildMenuPanel)

StreamRadioLib.Hook.Add("Think", "AdminSettingsUpdate", function()
	local now = RealTime()

	if g_lastThink < now then
		local isAdmin = StreamRadioLib.Util.IsAdmin()
		local adminChange = g_lastIsAdmin ~= isAdmin

		g_lastIsAdmin = isAdmin

		if adminChange and IsValid(g_panel) and g_panel._UpdateAdminLayout then
			g_panel:_UpdateAdminLayout()
		end

		g_lastThink = now + 1 + math.random()
	end
end)

return true


--PATH lua/streamradio_core/client/settings/general.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Settings = StreamRadioLib.Settings or {}
local LIB = StreamRadioLib.Settings

local LIBMenu = StreamRadioLib.Menu

local g_drawdistance = 0
local g_hidespectrumbars = false
local g_spectrumdistance = 0
local g_spectrumbars = 0
local g_rendertarget = true
local g_rendertarget_fps = 10
local g_3dsound = true
local g_key = 0
local g_key_vehicle = 0
local g_volume = 1
local g_coveredvolume = 0

local g_lastThink = 0

LIB.g_CV_List["general"] = {}

LIB.AddConVar("general", "mute", "cl_streamradio_mute", "0", {
	label = "Mute all radios",
	help = "Mutes all radios when set to 1. Default: 0",
	type = "bool",
	userdata = true,
})

LIB.AddConVar("general", "mute_foreign", "cl_streamradio_mute_foreign", "0", {
	label = "Mute all radios from other players",
	help = "Mutes all radios from other players when set to 1. Default: 0",
	type = "bool",
	userdata = true,
})

LIB.AddConVar("general", "muteunfocused", "cl_streamradio_muteunfocused", "0", {
	label = "Mute radios on game unfocus",
	help = "Mutes all radios when the game is not in focus if set to 1. Default: 0",
	type = "bool",
	userdata = true,
})

LIB.AddConVar("general", "mutedistance", "cl_streamradio_mutedistance", "2000", {
	label = "Mute at distance",
	help = "Mutes all radios which are further away than the given units. Min: 500, Max: 5000, Default: 2000",
	type = "int",
	userdata = true,
	min = 500,
	max = 5000,
})

LIB.AddConVar("general", "hidegui", "cl_streamradio_hidegui", "0", {
	label = "Hide GUIs",
	help = "Disables the drawing of GUIs for all radios when set to 1. Default: 0",
	type = "bool",
	userdata = true,
})

LIB.AddConVar("general", "drawdistance", "cl_streamradio_drawdistance", "1000", {
	label = "GUI draw distance",
	help = "Stops GUIs drawing on radios which are further away than the given distance units. Min: 400, Max: 4000, Default: 1000",
	type = "int",
	userdata = true,
	min = 400,
	max = 4000,
})

LIB.AddConVar("general", "hidespectrumbars", "cl_streamradio_hidespectrumbars", "0", {
	label = "Hide spectrum bars",
	help = "Disables the drawing of FFT spectrums for all radios when set to 1. Default: 0",
	type = "bool",
})

LIB.AddConVar("general", "spectrumdistance", "cl_streamradio_spectrumdistance", "500", {
	label = "Spectrum draw distance",
	help = "Stops FFT spectrum drawing on radios which are further away than the given distance units. Min: 250, Max: 2500, Default: 500",
	type = "int",
	min = 250,
	max = 2500,
})

LIB.AddConVar("general", "spectrumbars", "cl_streamradio_spectrumbars", "128", {
	label = "Spectrum bars",
	help = "Sets the max count of FFT spectrum bars on radios. Higher amounts can decrease performance. Min: 8, Max: 2048, Default: 128",
	type = "int",
	min = 8,
	max = 2048,
})

LIB.AddConVar("general", "rendertarget", "cl_streamradio_rendertarget", "1", {
	label = "Enable rendertargets",
	help = "Enable rendertargets for drawing radio GUIs when set to 1. Disable this if you see graphics glitches. Default: 1",
	type = "bool",
})

LIB.AddConVar("general", "rendertarget_fps", "cl_streamradio_rendertarget_fps", "40", {
	label = "Rendertarget FPS",
	help = "Sets the max FPS of rendertargets. Higher amounts can decrease performance. Min: 5, Max: 300, Default: 40",
	type = "int",
	min = 5,
	max = 300,
})

LIB.AddConVar("general", "key", "cl_streamradio_key", KEY_E, {
	label = "Radio control/use key",
	help = "",
	type = "numpad",
})

LIB.AddConVar("general", "key_vehicle", "cl_streamradio_key_vehicle", MOUSE_LEFT, {
	label = "Radio control/use key while in vehicles",
	help = "",
	type = "numpad",
})

LIB.AddConVar("general", "volume", "cl_streamradio_volume", "1", {
	label = "Global volume",
	help = "Set the global volume factor for all radios. Default: 1, Min: 0, Max: 1 or 10",
	type = "float",
	userdata = true,
	min = 0,
	max = 10,
})

LIB.AddConVar("general", "coveredvolume", "cl_streamradio_coveredvolume", "0.33", {
	label = "Volume factor of radios behind walls",
	help = "Set the volume factor of radios that are behind walls. Default: 0.33, Min: 0, Max: 1",
	type = "float",
	min = 0,
	max = 1,
})

LIB.AddConVar("general", "enable_cursor", "cl_streamradio_enable_cursor", "1", {
	label = "Show cursor",
	help = "Shows the cursor on radio GUIs when set to 1. Default: 1",
	type = "bool",
})

LIB.AddConVar("general", "no3dsound", "cl_streamradio_no3dsound", "0", {
	label = "Disable 3D Sound",
	help = "Disables 3D sound for all radios when set to 1. Default: 0",
	type = "bool",
})

LIB.AddConVar("general", "bass3_enable", "cl_streamradio_bass3_enable", "1", {
	label = "Use GM_BASS3 if installed",
	help = "When set to 1, it uses GM_BASS3 if installed on client and allowed on the server. Default: 1",
	type = "bool",
})

local function BuildMenuPanel(CPanel)
	if not IsValid(CPanel) then return end

	local toplabel = vgui.Create("DLabel")
	toplabel:SetText("3D Stream Radio general settings")
	toplabel:SetDark(true)
	toplabel:SizeToContents()
	CPanel:AddPanel(toplabel)

	local StreamRadioLib = StreamRadioLib or {}

	if not StreamRadioLib.Loaded then
		if StreamRadioLib.Loader_CreateErrorPanel then
			StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This menu could not be loaded.")
		end

		return
	end

	local cvBass3Enable = LIB.GetConVar("bass3_enable")
	cvBass3Enable:SetDisabled(not StreamRadioLib.Bass.IsInstalled())

	CPanel:Button(
		"Clear client stream cache",
		"cl_streamradio_cacheclear"
	)

	CPanel:AddPanel(LIBMenu.GetSpacer())

	for i, v in ipairs(LIB.GetConVarListByNamespace("general")) do
		if not IsValid(v) then continue end

		local p = v:BuildPanel(CPanel)
		if not IsValid(p) then continue end

		p:SetTooltip(v:GetPanellabel())
	end

	CPanel:AddPanel(LIBMenu.GetSpacer())

	CPanel:AddPanel(LIBMenu.GetOpenToolButton())
	CPanel:AddPanel(LIBMenu.GetOpenAdminSettingsButton())
	CPanel:AddPanel(LIBMenu.GetPlaylistEditorButton())

	CPanel:AddPanel(LIBMenu.GetSpacer(5))
	CPanel:AddPanel(LIBMenu.GetFAQButton())
	CPanel:AddPanel(LIBMenu.GetCreditsPanel())
end

LIB.AddBuildMenuPanelHook("general", "General Settings", BuildMenuPanel)

function StreamRadioLib.GetDrawDistance()
	return g_drawdistance
end

function StreamRadioLib.IsSpectrumHidden()
	return g_hidespectrumbars
end

function StreamRadioLib.GetSpectrumDistance()
	return g_spectrumdistance
end

function StreamRadioLib.GetSpectrumBars()
	return g_spectrumbars
end

function StreamRadioLib.IsRenderTarget()
	return g_rendertarget
end

function StreamRadioLib.GetRenderTargetFPS()
	return g_rendertarget_fps
end

function StreamRadioLib.Is3DSound()
	return g_3dsound
end

function StreamRadioLib.GetControlKey()
	return g_key
end

function StreamRadioLib.GetControlKeyVehicle()
	return g_key_vehicle
end

function StreamRadioLib.GetGlobalVolume()
	return g_volume
end

function StreamRadioLib.GetCoveredVolume()
	return g_coveredvolume
end

local function calcRendertargetFps()
	if StreamRadioLib.IsGUIHidden() then
		-- When we have no GUIs, limit FPS that also affects g_fastlistenfunc think in base_listener.lua
		return 5
	end

	local fps = LIB.GetConVarValue("rendertarget_fps")

	fps = math.max(fps, 2)

	return fps
end

local function calcIsRendertarget()
	if ScrW() < 1024 then
		return false
	end

	if ScrH() < 512 then
		return false
	end

	return LIB.GetConVarValue("rendertarget")
end

StreamRadioLib.Hook.Add("Think", "SettingsUpdate", function()
	local now = RealTime()

	if g_lastThink < now then
		g_drawdistance = LIB.GetConVarValue("drawdistance")
		g_hidespectrumbars = LIB.GetConVarValue("hidespectrumbars")
		g_spectrumdistance = LIB.GetConVarValue("spectrumdistance")
		g_spectrumbars = LIB.GetConVarValue("spectrumbars")
		g_rendertarget = calcIsRendertarget()
		g_rendertarget_fps = calcRendertargetFps()
		g_3dsound = not LIB.GetConVarValue("no3dsound")

		g_lastThink = now + 1 + math.random()
	end

	g_key = LIB.GetConVarValue("key")
	g_key_vehicle = LIB.GetConVarValue("key_vehicle")
	g_volume = LIB.GetConVarValue("volume")
	g_coveredvolume = LIB.GetConVarValue("coveredvolume")
end)

return true


--PATH lua/streamradio_core/client/settings/vr.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Settings = StreamRadioLib.Settings or {}
local LIB = StreamRadioLib.Settings

local LIBMenu = StreamRadioLib.Menu

LIB.g_CV_List["vr"] = {}

LIB.AddConVar("vr", "vr_enable_touch", "cl_streamradio_vr_enable_touch", "1", {
	label = "Enable VR Touch Control",
	help = "Enable Radio controlling via touch in VR when set to 1. Default: 1",
	type = "bool",
	userdata = true,
})

LIB.AddConVar("vr", "vr_enable_trigger", "cl_streamradio_vr_enable_trigger", "1", {
	label = "Enable VR Trigger Control",
	help = "Enable Radio controlling via trigger in VR when set to 1. Default: 1",
	type = "bool",
	userdata = true,
})

LIB.AddConVar("vr", "vr_enable_cursor", "cl_streamradi_vr_enable_cursor", "1", {
	label = "Show cursor in VR",
	help = "Shows the cursor on radio GUIs in VR when set to 1. Default: 1",
	type = "bool",
})

local function BuildMenuPanel(CPanel)
	if not IsValid(CPanel) then return end

	local toplabel = vgui.Create("DLabel")
	toplabel:SetText("3D Stream Radio VR settings")
	toplabel:SetDark(true)
	toplabel:SizeToContents()
	CPanel:AddPanel(toplabel)

	local StreamRadioLib = StreamRadioLib or {}

	if not StreamRadioLib.Loaded then
		if StreamRadioLib.Loader_CreateErrorPanel then
			StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This menu could not be loaded.")
		end

		return
	end

	if not StreamRadioLib.VR.IsInstalled() then
		CPanel:AddPanel(LIBMenu.GetVRErrorPanel())

		CPanel:AddPanel(LIBMenu.GetSpacer())

		CPanel:AddPanel(LIBMenu.GetVRAddonButton())
		CPanel:AddPanel(LIBMenu.GetVRFAQButton())
		return
	end

	CPanel:AddPanel(LIBMenu.GetVRInfoPanel())
	CPanel:AddPanel(LIBMenu.GetSpacer(5))

	for i, v in ipairs(LIB.GetConVarListByNamespace("vr")) do
		if not IsValid(v) then continue end

		local p = v:BuildPanel(CPanel)
		if not IsValid(p) then continue end

		p:SetTooltip(v:GetPanellabel())
	end

	CPanel:AddPanel(LIBMenu.GetSpacer(5))
	CPanel:AddPanel(LIBMenu.GetVRAddonPanelButton())
	CPanel:AddPanel(LIBMenu.GetSpacer(5))
	CPanel:AddPanel(LIBMenu.GetVRFAQButton())
	CPanel:AddPanel(LIBMenu.GetCreditsPanel())
end

LIB.AddBuildMenuPanelHook("vr", "VR Settings", BuildMenuPanel)

return true


--PATH lua/streamradio_core/client/cl_skin.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Skin = StreamRadioLib.Skin or {}

local LIB = StreamRadioLib.Skin

local LIBUtil = StreamRadioLib.Util

local g_mainPath = LIBUtil.GetMainDirectory("skin")

local function IsValidFile(filename)
	return not file.IsDir(filename, "DATA") and file.Exists(filename, "DATA")
end

function LIB.SanitizeName(name)
	name = tostring(name or "")
	name = string.lower(name or "")
	name = string.Trim(name)

	name = string.gsub(name, "[%.%\"%'%:%?%/%\\%*%<%>%|]", "_" )
	name = string.gsub(name, "[%s]", "_" )

	name = string.Trim(name)
	return name
end

function LIB.GetPath(name)
	name = tostring(name or "")

	if name == "" then
		return g_mainPath .. "/"
	end

	local filepath = g_mainPath .. "/" .. name .. ".txt"
	return filepath
end

function LIB.IsValidSkinFile(name)
	local filepath = LIB.GetPath(name)

	if name == "default" then
		return true
	end

	return IsValidFile(filepath)
end

function LIB.Open(name)
	name = LIB.SanitizeName(name)
	if name == "" then
		name = "default"
	end

	if name == "default" then
		local skindata = LIB.GetDefaultSkin()
		if not skindata then return end

		skindata.name = name
		return skindata
	end

	local filepath = LIB.GetPath(name)
	if not IsValidFile(filepath) then
		return nil
	end

	local skinjson = file.Read(filepath, "DATA") or ""
	if skinjson == "" then return end

	local skindata = StreamRadioLib.JSON.Decode(skinjson)
	if not skindata then return end

	skindata.name = name
	return skindata
end

function LIB.Save(name, skindata)
	name = LIB.SanitizeName(name)
	if name == "" then
		name = "default"
	end

	if name == "default" then
		return false
	end

	skindata = skindata or {}
	skindata.name = nil

	local skinjson = StreamRadioLib.JSON.Encode(skindata, true) or ""
	local filepath = LIB.GetPath(name)

	if not LIBUtil.CreateDirectoryForFile(filepath) then return false end
	file.Write(filepath, skinjson)

	return IsValidFile(filepath)
end

function LIB.Delete(name)
	name = LIB.SanitizeName(name)
	if name == "" then
		name = "default"
	end

	if name == "default" then
		return false
	end

	local filepath = LIB.GetPath(name)

	file.Delete(filepath)
	return not IsValidFile(filepath)
end

function LIB.GetList()
	local files = file.Find(g_mainPath .. "/*.txt", "DATA", "nameasc")

	table.insert(files, 1, "default.txt")

	local found = {}
	local nodouble = {}

	for i, v in ipairs(files or {}) do
		local name = string.StripExtension(v)
		name = LIB.SanitizeName(name)

		if not LIB.IsValidSkinFile(name) then
			continue
		end

		if nodouble[name] then
			continue
		end

		nodouble[name] = true
		table.insert(found, name)
	end

	return found
end

return true


--PATH lua/streamradio_core/interfaces/youtube.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/_generic.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/pls.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/shoutcast.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

local LIBShoutcast = StreamRadioLib.Shoutcast
local LIBWhitelist = StreamRadioLib.Whitelist
local LIBFilesystem = StreamRadioLib.Filesystem

RADIOFS.name = "SHOUTcast"
RADIOFS.type = "shoutcast"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("sound")

RADIOFS.priority = 50000
RADIOFS.nocreate = true
RADIOFS.loadToWhitelist = false

local g_playlistfile = "> Browse Stations <"

function RADIOFS:GetGenreHierarchy(vpath)
	if not self:IsInFolder(vpath) then
		return nil
	end

	local levels = self:GetPathLevels(vpath)
	local mainGenre = levels[2] or ""
	local subGenre = levels[3] or ""

	if mainGenre == "" or self:LevelIsPlaylistFile(mainGenre) then
		return {}
	end

	if subGenre == "" or self:LevelIsPlaylistFile(subGenre) then
		return {mainGenre}
	end

	return {mainGenre, subGenre}
end

function RADIOFS:LevelIsPlaylistFile(level)
	level = tostring(level or "")

	if level == string.lower(g_playlistfile) then
		return true
	end

	return false
end

function RADIOFS:IsPlaylistFile(vpath)
	if not self:IsInFolder(vpath) then
		return false
	end

	local levels = self:GetPathLevels(vpath)
	local level2 = levels[2] or ""
	local level3 = levels[3] or ""
	local level4 = levels[4] or ""

	if self:LevelIsPlaylistFile(level2) then
		return true
	end

	if self:LevelIsPlaylistFile(level3) then
		return true
	end

	if self:LevelIsPlaylistFile(level4) then
		return true
	end

	return false
end

function RADIOFS:IsInFolder(vpath)
	local levels = self:GetPathLevels(vpath)
	local firstlevel = levels[1] or ""

	if firstlevel ~= ":shoutcast" then
		return false
	end

	return true
end

function RADIOFS:IsType(globalpath, vpath)
	return self:IsInFolder(vpath)
end

function RADIOFS:Find(globalpath, vfolder, callback)
	if vfolder == "" then
		callback(true, nil, {":shoutcast"})
		return true
	end

	if not self:IsInFolder(vfolder) then
		callback(false, nil, nil)
		return false
	end

	if self:IsPlaylistFile(vfolder) then
		callback(false, nil, nil)
		return false
	end

	local hierarchy = self:GetGenreHierarchy(vfolder)
	if not hierarchy then
		callback(false, nil, nil)
		return false
	end

	local genre = LIBShoutcast.GetGenre(hierarchy)
	if not genre then
		callback(false, nil, nil)
		return false
	end

	local subGenres = genre.childrenTitles

	if genre.isRoot then
		callback(true, nil, subGenres)
		return true
	end

	callback(true, {g_playlistfile}, subGenres)
	return true
end

function RADIOFS:Exists(globalpath, vpath)
	if self:IsPlaylistFile(vpath) then
		return true
	end

	local hierarchy = self:GetGenreHierarchy(vpath)
	if not hierarchy then
		return false
	end

	if not LIBShoutcast.GenreExists(hierarchy) then
		return false
	end

	return true
end

RADIOFS.Delete = nil

function RADIOFS:Read(globalpath, vpath, callback)
	if not self:IsPlaylistFile(vpath) then
		callback(false, nil)
		return false
	end

	local hierarchy = self:GetGenreHierarchy(vpath)
	if not hierarchy then
		callback(false, nil)
		return false
	end

	LIBShoutcast.GetListOfGenre(hierarchy, function(success, items)
		if not success then
			callback(false, nil)
			return
		end

		local playlist = {}

		for i, v in ipairs(items) do
			local item = {
				name = v.name,
				url = v.streamUrl,
			}

			table.insert(playlist, item)
		end

		callback(true, playlist)
		return
	end)

	return true
end

LIBWhitelist.AddCheckFunction("shoutcast", function(url)
	if not LIBFilesystem.IsEnabledFilesystem("shoutcast") then
		return nil
	end

	if not LIBShoutcast.IsShoutcastUrl(url) then
		return nil
	end

	--[[
		Shoutcast gets a spacial treatment to avoid its auto/dynamic playlist needing to be iterated.
		This would cause like 100+ HTTP calls on every server start up otherwise.
	]]

	return true
end)

return true


--PATH lua/autorun/swrc_autorun.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_languages.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
TalkModes = TalkModes || {}
TalkModes.Languages = TalkModes.Languages || {}
TalkModes.Languages.Available = TalkModes.Languages.Available || {}
TalkModes.Languages.Active = TalkModes.Languages.Active || "English" -- Don't touch this line, change language using the in-game admin menu

function TalkModes.Languages:Register(strLanguage, tblPhrases)
    self.Available[strLanguage] = tblPhrases
end

function TalkModes.Languages:GetPhrase(strPhrase)
    return self.Available[TalkModes.Config:GetSetting("General", "Language")][strPhrase] || "phrase_not_found"
end
--PATH addons/[chat] talk-modes/lua/talk_modes/networking/cl_net.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
TalkModes.Client = TalkModes.Client || {}
TalkModes.Client.ActiveTheme = TalkModes.Client.ActiveTheme || {
    ["Background"] = Color(30, 30, 30), 
    ["Foreground"] = Color(40, 40, 40),
    ["Gray"] = Color(160, 160, 160),
    ["Hover"] = Color(192, 57, 43),
    ["White"] = Color(230, 230, 230)
}

function TalkModes.Client.OpenAdminMenu()
    local pMenu = vgui.Create("TalkModes.AdminMenu")
    pMenu:SetAlpha(0)
    pMenu:AlphaTo(255, 0.2)
end
net.Receive("TalkModes.OpenAdminMenu", TalkModes.Client.OpenAdminMenu)

net.Receive("TalkModes.Notify", function()  
    local strMessage = net.ReadString()

    chat.AddText(TalkModes.Client.ActiveTheme["Hover"] || Color(255, 0, 0), "[Talk Modes] ", color_white, strMessage)
end)

net.Receive("TalkModes.WelcomeMessage", function()
    chat.AddText(TalkModes.Client.ActiveTheme["Hover"] || Color(255, 0, 0), "[Talk Modes] ", color_white, string.format(TalkModes.Languages:GetPhrase("WelcomeMessage"), string.upper(input.GetKeyName(TalkModes.Config:GetSetting("General", "Selection Key")))))
end)

net.Receive("TalkModes.Config.Network", function()
	local tblConfig = net.ReadTable()

	TalkModes.Config.Client = tblConfig || {}

    -- This will convert the color values to a color vector. 
    -- It'll make it much easier for the UI. 
    if TalkModes.Client.ActiveTheme != tblConfig["UI"] then 
        for i, v in pairs(tblConfig["UI"]) do 
            TalkModes.Client.ActiveTheme[i] = Color(v.r, v.g, v.b, v.a)
        end
    end
end)

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_spheres.lua:
local color_mask2 = Color(0, 0, 0, 0)

local function drawStencilSphere( pos, ref, compare_func, radius, color, detail )
    render.SetStencilReferenceValue( ref )
    render.SetStencilCompareFunction( compare_func )
    render.DrawSphere(pos, radius, detail, detail, color)
end

function render.StartWorldRings()
    render.WORLD_RINGS = {}
    cam.IgnoreZ(false)
    render.SetStencilEnable(true)
    render.SetStencilTestMask(255)
    render.SetStencilWriteMask(255)
    render.ClearStencil()
    render.SetColorMaterial()
end

function render.AddWorldRing(pos, radius, thicc, detail)
    detail = detail or 25
    thicc = thicc or 10
    local z = {detail=detail, thicc=thicc, pos=pos, outer_r=radius, inner_r=math.max(radius-thicc,0)}
    table.insert(render.WORLD_RINGS, z)
end

function render.FinishWorldRings(color)
    local ply = LocalPlayer()
    local zones = render.WORLD_RINGS
   
    render.SetStencilZFailOperation( STENCILOPERATION_REPLACE )
   
    for i, zone in ipairs(zones) do
        local outer_r = zone.radius
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, -zone.outer_r, color_mask2, zone.detail ) -- big, inside-out
    end
    render.SetStencilZFailOperation( STENCILOPERATION_DECR )
    for i, zone in ipairs(zones) do
        local outer_r = zone.radius
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, zone.outer_r, color_mask2, zone.detail ) -- big
    end
    render.SetStencilZFailOperation( STENCILOPERATION_INCR )
    for i, zone in ipairs(zones) do
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, -zone.inner_r, color_mask2, zone.detail ) -- small, inside-out
    end
    render.SetStencilZFailOperation( STENCILOPERATION_DECR )
    for i, zone in ipairs(zones) do
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, zone.inner_r, color_mask2, zone.detail ) -- small
    end
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
   
    local cam_pos = ply:EyePos()
    local cam_angle = ply:EyeAngles()
    local cam_normal = cam_angle:Forward()
    cam.IgnoreZ(true)
    render.SetStencilReferenceValue( 1 )
    render.DrawQuadEasy(cam_pos + cam_normal * 10, -cam_normal, 10000, 10000, color, cam_angle.roll)
    cam.IgnoreZ(false)
    render.SetStencilEnable(false)
end
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_previewslider.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
local _R = debug.getregistry()
if (_R.Circles) then return _R.Circles end

local BlurMat = Material("pp/blurscreen")

local rad = math.rad
local cos = math.cos
local sin = math.sin
local min = math.min
local max = math.max

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local function New(type, radius, x, y, ...)
	local circle = setmetatable({}, CIRCLE)

	circle:SetType(tonumber(type))
	circle:SetRadius(tonumber(radius))
	circle:SetPos(tonumber(x), tonumber(y))

	if (type == CIRCLE_OUTLINED) then
		local outline_width = ({...})[1]
		circle:SetOutlineWidth(tonumber(outline_width))
	elseif (type == CIRCLE_BLURRED) then
		local blur_density, blur_quality = unpack({...})
		circle:SetBlurDensity(tonumber(blur_density))
		circle:SetBlurQuality(tonumber(blur_quality))
	end

	return circle
end

local function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
	rotation = rad(rotation)

	local c = cos(rotation)
	local s = sin(rotation)

	for i = 1, #vertices do
		local vertex = vertices[i]
		local vx, vy = vertex.x, vertex.y

		vx = vx - ox
		vy = vy - oy

		vertex.x = ox + (vx * c - vy * s)
		vertex.y = oy + (vx * s + vy * c)

		if (not rotate_uv) then
			local u, v = vertex.u, vertex.v
			u, v = u - 0.5, v - 0.5

			vertex.u = 0.5 + (u * c - v * s)
			vertex.v = 0.5 + (u * s + v * c)
		end
	end
end

local function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
	x = tonumber(x) or 0
	y = tonumber(y) or 0
	radius = tonumber(radius) or 16
	rotation = tonumber(rotation) or 0
	start_angle = tonumber(start_angle) or 0
	end_angle = tonumber(end_angle) or 360
	distance = tonumber(distance) or 10

	if (start_angle > end_angle) then
		local tmp = start_angle
		start_angle = end_angle
		end_angle = tmp
	end

	local vertices = {}
	local step = (distance * 360) / (2 * math.pi * radius)

	for a = start_angle, end_angle + step, step do
		a = max(start_angle, min(end_angle, a))
		a = rad(a)

		local c = cos(a)
		local s = sin(a)

		local vertex = {
			x = x + c * radius,
			y = y + s * radius,

			u = 0.5 + c / 2,
			v = 0.5 + s / 2,
		}

		table.insert(vertices, vertex)
	end

	if (end_angle - start_angle ~= 360) then
		table.insert(vertices, 1, {
			x = x, y = y,
			u = 0.5, v = 0.5,
		})
	else
		table.remove(vertices)
	end

	if (rotation ~= 0) then
		RotateVertices(vertices, x, y, rotation, rotate_uv)
	end

	return vertices
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local rotate_uv = self:GetRotateMaterial()
	local x, y = self:GetPos()
	local radius = self:GetRadius()
	local rotation = self:GetRotation()
	local start_angle = self:GetStartAngle()
	local end_angle = self:GetEndAngle()
	local distance = self:GetDistance()

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if (self:GetType() == CIRCLE_OUTLINED) then
		local inner = self:GetChildCircle() or self:Copy()

		inner:SetType(CIRCLE_FILLED)
		inner:SetRadius(self:GetRadius() - self:GetOutlineWidth())
		inner:SetAngles(0, 360)

		inner:SetColor(false)
		inner:SetMaterial(false)
		inner:SetDisableClipping(false)

		self:SetChildCircle(inner)
	end

	self:SetDirty(false)
end

function CIRCLE:__call()
	if (self:GetDirty()) then
		self:Calculate()
	end

	if (IsColor(self:GetColor())) then surface.SetDrawColor(self:GetColor()) end
	if (TypeID(self:GetMaterial()) == TYPE_MATERIAL) then surface.SetMaterial(self:GetMaterial()) end

	local clip = self:GetDisableClipping()
	if (clip) then surface.DisableClipping(true) end

	if (self:GetType() == CIRCLE_OUTLINED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self:GetChildCircle()()

			render.SetStencilCompareFunction(STENCIL_GREATER)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.DrawPoly(self:GetVertices())
		render.SetStencilEnable(false)
	elseif (self:GetType() == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self:GetVertices())

			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.SetMaterial(BlurMat)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self:GetBlurQuality() do
				BlurMat:SetFloat("$blur", (i / self:GetBlurQuality()) * self:GetBlurDensity())
				BlurMat:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self:GetVertices())
	end

	if (clip) then surface.DisableClipping(false) end
end

function CIRCLE:Translate(x, y)
	self.m_X = self:GetX() + x
	self.m_Y = self:GetY() + y

	if (self:GetDirty()) then return end

	x = tonumber(x) or 0
	y = tonumber(y) or 0

	for i, v in ipairs(self:GetVertices()) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Translate(x, y)
	end
end

function CIRCLE:Scale(scale)
	self.m_Radius = self:GetRadius() * scale

	if (self:GetDirty()) then return end

	local x, y = self:GetPos()
	scale = tonumber(scale) or 1

	for i, vertex in ipairs(self:GetVertices()) do
		vertex.x = x + ((vertex.x - x) * scale)
		vertex.y = y + ((vertex.y - y) * scale)
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Scale(scale)
	end
end

function CIRCLE:Rotate(degrees)
	self.m_Rotation = self:GetRotation() + degrees

	if (self:GetDirty()) then return end

	local vertices = self:GetVertices()
	local x, y = self:GetPos()
	local rotate_uv = self:GetRotateMaterial()
	degrees = tonumber(degrees) or 0

	RotateVertices(vertices, x, y, degrees, rotate_uv)

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Rotate(degrees)
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if (default ~= nil and value == nil) then
				value = default
			end

			if (self[varname] ~= value) then
				if (dirty) then
					self[dirty] = true
				end

				if (isfunction(callback)) then
					value = callback(self, self[varname], value) or value
				end
			end

			self[varname] = value
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.x = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesX(circle:GetChildCircle(), old, new)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.y = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesY(circle:GetChildCircle(), old, new)
		end
	end

	local function UpdateRotation(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		local vertices = circle:GetVertices()
		local x, y = circle:GetPos()
		local rotation = new - old
		local rotate_uv = circle:GetRotateMaterial()

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if (circle:GetType() == CIRCLE_OUTLINED) then
			UpdateRotation(circle:GetChildCircle(), old, new)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.
	AccessorFunc("DisableClipping", false)				-- Sets whether or not to disable clipping when the circle is rendered. Useful for circles that go out of the render bounds.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty") 		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX) 		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY) 		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty") 				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty") 			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurDensity", 3)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurQuality", 2)						-- The circle's blur quality if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		self:SetX(x)
		self:SetY(y)
	end

	function CIRCLE:SetAngles(s, e)
		self:SetStartAngle(s)
		self:SetEndAngle(e)
	end

	function CIRCLE:GetPos()
		return self:GetX(), self:GetY()
	end

	function CIRCLE:GetAngles()
		return self:GetStartAngle(), self:GetEndAngle()
	end
end

_R.Circles = {
	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
local _R = debug.getregistry()
if (_R.Circles) then return _R.Circles end

local BlurMat = Material("pp/blurscreen")

local rad = math.rad
local cos = math.cos
local sin = math.sin
local min = math.min
local max = math.max

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local function New(type, radius, x, y, ...)
	local circle = setmetatable({}, CIRCLE)

	circle:SetType(tonumber(type))
	circle:SetRadius(tonumber(radius))
	circle:SetPos(tonumber(x), tonumber(y))

	if (type == CIRCLE_OUTLINED) then
		local outline_width = ({...})[1]
		circle:SetOutlineWidth(tonumber(outline_width))
	elseif (type == CIRCLE_BLURRED) then
		local blur_density, blur_quality = unpack({...})
		circle:SetBlurDensity(tonumber(blur_density))
		circle:SetBlurQuality(tonumber(blur_quality))
	end

	return circle
end

local function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
	rotation = rad(rotation)

	local c = cos(rotation)
	local s = sin(rotation)

	for i = 1, #vertices do
		local vertex = vertices[i]
		local vx, vy = vertex.x, vertex.y

		vx = vx - ox
		vy = vy - oy

		vertex.x = ox + (vx * c - vy * s)
		vertex.y = oy + (vx * s + vy * c)

		if (not rotate_uv) then
			local u, v = vertex.u, vertex.v
			u, v = u - 0.5, v - 0.5

			vertex.u = 0.5 + (u * c - v * s)
			vertex.v = 0.5 + (u * s + v * c)
		end
	end
end

local function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
	x = tonumber(x) or 0
	y = tonumber(y) or 0
	radius = tonumber(radius) or 16
	rotation = tonumber(rotation) or 0
	start_angle = tonumber(start_angle) or 0
	end_angle = tonumber(end_angle) or 360
	distance = tonumber(distance) or 10

	if (start_angle > end_angle) then
		local tmp = start_angle
		start_angle = end_angle
		end_angle = tmp
	end

	local vertices = {}
	local step = (distance * 360) / (2 * math.pi * radius)

	for a = start_angle, end_angle + step, step do
		a = max(start_angle, min(end_angle, a))
		a = rad(a)

		local c = cos(a)
		local s = sin(a)

		local vertex = {
			x = x + c * radius,
			y = y + s * radius,

			u = 0.5 + c / 2,
			v = 0.5 + s / 2,
		}

		table.insert(vertices, vertex)
	end

	if (end_angle - start_angle ~= 360) then
		table.insert(vertices, 1, {
			x = x, y = y,
			u = 0.5, v = 0.5,
		})
	else
		table.remove(vertices)
	end

	if (rotation ~= 0) then
		RotateVertices(vertices, x, y, rotation, rotate_uv)
	end

	return vertices
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local rotate_uv = self:GetRotateMaterial()
	local x, y = self:GetPos()
	local radius = self:GetRadius()
	local rotation = self:GetRotation()
	local start_angle = self:GetStartAngle()
	local end_angle = self:GetEndAngle()
	local distance = self:GetDistance()

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if (self:GetType() == CIRCLE_OUTLINED) then
		local inner = self:GetChildCircle() or self:Copy()

		inner:SetType(CIRCLE_FILLED)
		inner:SetRadius(self:GetRadius() - self:GetOutlineWidth())
		inner:SetAngles(0, 360)

		inner:SetColor(false)
		inner:SetMaterial(false)
		inner:SetDisableClipping(false)

		self:SetChildCircle(inner)
	end

	self:SetDirty(false)
end

function CIRCLE:__call()
	if (self:GetDirty()) then
		self:Calculate()
	end

	if (IsColor(self:GetColor())) then surface.SetDrawColor(self:GetColor()) end
	if (TypeID(self:GetMaterial()) == TYPE_MATERIAL) then surface.SetMaterial(self:GetMaterial()) end

	local clip = self:GetDisableClipping()
	if (clip) then surface.DisableClipping(true) end

	if (self:GetType() == CIRCLE_OUTLINED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self:GetChildCircle()()

			render.SetStencilCompareFunction(STENCIL_GREATER)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.DrawPoly(self:GetVertices())
		render.SetStencilEnable(false)
	elseif (self:GetType() == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self:GetVertices())

			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.SetMaterial(BlurMat)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self:GetBlurQuality() do
				BlurMat:SetFloat("$blur", (i / self:GetBlurQuality()) * self:GetBlurDensity())
				BlurMat:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self:GetVertices())
	end

	if (clip) then surface.DisableClipping(false) end
end

function CIRCLE:Translate(x, y)
	self.m_X = self:GetX() + x
	self.m_Y = self:GetY() + y

	if (self:GetDirty()) then return end

	x = tonumber(x) or 0
	y = tonumber(y) or 0

	for i, v in ipairs(self:GetVertices()) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Translate(x, y)
	end
end

function CIRCLE:Scale(scale)
	self.m_Radius = self:GetRadius() * scale

	if (self:GetDirty()) then return end

	local x, y = self:GetPos()
	scale = tonumber(scale) or 1

	for i, vertex in ipairs(self:GetVertices()) do
		vertex.x = x + ((vertex.x - x) * scale)
		vertex.y = y + ((vertex.y - y) * scale)
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Scale(scale)
	end
end

function CIRCLE:Rotate(degrees)
	self.m_Rotation = self:GetRotation() + degrees

	if (self:GetDirty()) then return end

	local vertices = self:GetVertices()
	local x, y = self:GetPos()
	local rotate_uv = self:GetRotateMaterial()
	degrees = tonumber(degrees) or 0

	RotateVertices(vertices, x, y, degrees, rotate_uv)

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Rotate(degrees)
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if (default ~= nil and value == nil) then
				value = default
			end

			if (self[varname] ~= value) then
				if (dirty) then
					self[dirty] = true
				end

				if (isfunction(callback)) then
					value = callback(self, self[varname], value) or value
				end
			end

			self[varname] = value
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.x = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesX(circle:GetChildCircle(), old, new)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.y = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesY(circle:GetChildCircle(), old, new)
		end
	end

	local function UpdateRotation(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		local vertices = circle:GetVertices()
		local x, y = circle:GetPos()
		local rotation = new - old
		local rotate_uv = circle:GetRotateMaterial()

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if (circle:GetType() == CIRCLE_OUTLINED) then
			UpdateRotation(circle:GetChildCircle(), old, new)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.
	AccessorFunc("DisableClipping", false)				-- Sets whether or not to disable clipping when the circle is rendered. Useful for circles that go out of the render bounds.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty") 		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX) 		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY) 		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty") 				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty") 			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurDensity", 3)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurQuality", 2)						-- The circle's blur quality if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		self:SetX(x)
		self:SetY(y)
	end

	function CIRCLE:SetAngles(s, e)
		self:SetStartAngle(s)
		self:SetEndAngle(e)
	end

	function CIRCLE:GetPos()
		return self:GetX(), self:GetY()
	end

	function CIRCLE:GetAngles()
		return self:GetStartAngle(), self:GetEndAngle()
	end
end

_R.Circles = {
	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
local _R = debug.getregistry()
if (_R.Circles) then return _R.Circles end

local BlurMat = Material("pp/blurscreen")

local rad = math.rad
local cos = math.cos
local sin = math.sin
local min = math.min
local max = math.max

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local function New(type, radius, x, y, ...)
	local circle = setmetatable({}, CIRCLE)

	circle:SetType(tonumber(type))
	circle:SetRadius(tonumber(radius))
	circle:SetPos(tonumber(x), tonumber(y))

	if (type == CIRCLE_OUTLINED) then
		local outline_width = ({...})[1]
		circle:SetOutlineWidth(tonumber(outline_width))
	elseif (type == CIRCLE_BLURRED) then
		local blur_density, blur_quality = unpack({...})
		circle:SetBlurDensity(tonumber(blur_density))
		circle:SetBlurQuality(tonumber(blur_quality))
	end

	return circle
end

local function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
	rotation = rad(rotation)

	local c = cos(rotation)
	local s = sin(rotation)

	for i = 1, #vertices do
		local vertex = vertices[i]
		local vx, vy = vertex.x, vertex.y

		vx = vx - ox
		vy = vy - oy

		vertex.x = ox + (vx * c - vy * s)
		vertex.y = oy + (vx * s + vy * c)

		if (not rotate_uv) then
			local u, v = vertex.u, vertex.v
			u, v = u - 0.5, v - 0.5

			vertex.u = 0.5 + (u * c - v * s)
			vertex.v = 0.5 + (u * s + v * c)
		end
	end
end

local function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
	x = tonumber(x) or 0
	y = tonumber(y) or 0
	radius = tonumber(radius) or 16
	rotation = tonumber(rotation) or 0
	start_angle = tonumber(start_angle) or 0
	end_angle = tonumber(end_angle) or 360
	distance = tonumber(distance) or 10

	if (start_angle > end_angle) then
		local tmp = start_angle
		start_angle = end_angle
		end_angle = tmp
	end

	local vertices = {}
	local step = (distance * 360) / (2 * math.pi * radius)

	for a = start_angle, end_angle + step, step do
		a = max(start_angle, min(end_angle, a))
		a = rad(a)

		local c = cos(a)
		local s = sin(a)

		local vertex = {
			x = x + c * radius,
			y = y + s * radius,

			u = 0.5 + c / 2,
			v = 0.5 + s / 2,
		}

		table.insert(vertices, vertex)
	end

	if (end_angle - start_angle ~= 360) then
		table.insert(vertices, 1, {
			x = x, y = y,
			u = 0.5, v = 0.5,
		})
	else
		table.remove(vertices)
	end

	if (rotation ~= 0) then
		RotateVertices(vertices, x, y, rotation, rotate_uv)
	end

	return vertices
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local rotate_uv = self:GetRotateMaterial()
	local x, y = self:GetPos()
	local radius = self:GetRadius()
	local rotation = self:GetRotation()
	local start_angle = self:GetStartAngle()
	local end_angle = self:GetEndAngle()
	local distance = self:GetDistance()

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if (self:GetType() == CIRCLE_OUTLINED) then
		local inner = self:GetChildCircle() or self:Copy()

		inner:SetType(CIRCLE_FILLED)
		inner:SetRadius(self:GetRadius() - self:GetOutlineWidth())
		inner:SetAngles(0, 360)

		inner:SetColor(false)
		inner:SetMaterial(false)
		inner:SetDisableClipping(false)

		self:SetChildCircle(inner)
	end

	self:SetDirty(false)
end

function CIRCLE:__call()
	if (self:GetDirty()) then
		self:Calculate()
	end

	if (IsColor(self:GetColor())) then surface.SetDrawColor(self:GetColor()) end
	if (TypeID(self:GetMaterial()) == TYPE_MATERIAL) then surface.SetMaterial(self:GetMaterial()) end

	local clip = self:GetDisableClipping()
	if (clip) then surface.DisableClipping(true) end

	if (self:GetType() == CIRCLE_OUTLINED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self:GetChildCircle()()

			render.SetStencilCompareFunction(STENCIL_GREATER)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.DrawPoly(self:GetVertices())
		render.SetStencilEnable(false)
	elseif (self:GetType() == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self:GetVertices())

			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.SetMaterial(BlurMat)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self:GetBlurQuality() do
				BlurMat:SetFloat("$blur", (i / self:GetBlurQuality()) * self:GetBlurDensity())
				BlurMat:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self:GetVertices())
	end

	if (clip) then surface.DisableClipping(false) end
end

function CIRCLE:Translate(x, y)
	self.m_X = self:GetX() + x
	self.m_Y = self:GetY() + y

	if (self:GetDirty()) then return end

	x = tonumber(x) or 0
	y = tonumber(y) or 0

	for i, v in ipairs(self:GetVertices()) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Translate(x, y)
	end
end

function CIRCLE:Scale(scale)
	self.m_Radius = self:GetRadius() * scale

	if (self:GetDirty()) then return end

	local x, y = self:GetPos()
	scale = tonumber(scale) or 1

	for i, vertex in ipairs(self:GetVertices()) do
		vertex.x = x + ((vertex.x - x) * scale)
		vertex.y = y + ((vertex.y - y) * scale)
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Scale(scale)
	end
end

function CIRCLE:Rotate(degrees)
	self.m_Rotation = self:GetRotation() + degrees

	if (self:GetDirty()) then return end

	local vertices = self:GetVertices()
	local x, y = self:GetPos()
	local rotate_uv = self:GetRotateMaterial()
	degrees = tonumber(degrees) or 0

	RotateVertices(vertices, x, y, degrees, rotate_uv)

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Rotate(degrees)
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if (default ~= nil and value == nil) then
				value = default
			end

			if (self[varname] ~= value) then
				if (dirty) then
					self[dirty] = true
				end

				if (isfunction(callback)) then
					value = callback(self, self[varname], value) or value
				end
			end

			self[varname] = value
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.x = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesX(circle:GetChildCircle(), old, new)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.y = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesY(circle:GetChildCircle(), old, new)
		end
	end

	local function UpdateRotation(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		local vertices = circle:GetVertices()
		local x, y = circle:GetPos()
		local rotation = new - old
		local rotate_uv = circle:GetRotateMaterial()

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if (circle:GetType() == CIRCLE_OUTLINED) then
			UpdateRotation(circle:GetChildCircle(), old, new)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.
	AccessorFunc("DisableClipping", false)				-- Sets whether or not to disable clipping when the circle is rendered. Useful for circles that go out of the render bounds.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty") 		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX) 		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY) 		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty") 				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty") 			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurDensity", 3)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurQuality", 2)						-- The circle's blur quality if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		self:SetX(x)
		self:SetY(y)
	end

	function CIRCLE:SetAngles(s, e)
		self:SetStartAngle(s)
		self:SetEndAngle(e)
	end

	function CIRCLE:GetPos()
		return self:GetX(), self:GetY()
	end

	function CIRCLE:GetAngles()
		return self:GetStartAngle(), self:GetEndAngle()
	end
end

_R.Circles = {
	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--PATH lua/autorun/tarkin.lua:
return gluapack()()
--PATH lua/tfa/enums/animation.lua:
-- luacheck: globals ACT_VM_FIDGET_EMPTY ACT_VM_FIDGET_SILENCED ACT_VM_BLOWBACK ACT_VM_HOLSTER_SILENCED
TFA.Enum.ANIMATION_ACT = 0
TFA.Enum.ANIMATION_SEQ = 1
ACT_VM_FIDGET_EMPTY = ACT_VM_FIDGET_EMPTY or ACT_CROSSBOW_FIDGET_UNLOADED
ACT_VM_FIDGET_SILENCED = ACT_VM_FIDGET_SILENCED or ACT_RPG_FIDGET_UNLOADED
ACT_VM_HOLSTER_SILENCED = ACT_VM_HOLSTER_SILENCED or ACT_CROSSBOW_HOLSTER_UNLOADED
ACT_VM_BLOWBACK = ACT_VM_BLOWBACK or -2

-- luacheck: globals ACT_VM_RELOAD_ADS ACT_VM_RELOAD_EMPTY_ADS ACT_VM_RELOAD_SILENCED_ADS ACT_SHOTGUN_RELOAD_START_ADS ACT_SHOTGUN_RELOAD_FINISH_ADS
ACT_VM_RELOAD_ADS = ACT_VM_RELOAD_ADS or ACT_IDLE_AIM_RIFLE_STIMULATED
ACT_VM_RELOAD_EMPTY_ADS = ACT_VM_RELOAD_EMPTY_ADS or ACT_WALK_AIM_RIFLE_STIMULATED
ACT_VM_RELOAD_SILENCED_ADS = ACT_VM_RELOAD_SILENCED_ADS or ACT_RUN_AIM_RIFLE_STIMULATED
ACT_SHOTGUN_RELOAD_START_ADS = ACT_SHOTGUN_RELOAD_START_ADS or ACT_IDLE_SHOTGUN_RELAXED
ACT_SHOTGUN_RELOAD_FINISH_ADS = ACT_SHOTGUN_RELOAD_FINISH_ADS or ACT_IDLE_SHOTGUN_STIMULATED

--PATH lua/tfa/modules/tfa_effects.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_functions.lua:
local gas_cl_enabled = GetConVar("cl_tfa_fx_gasblur")
local oldshell_cl_enabled = GetConVar("cl_tfa_legacy_shells")

local ScrW, ScrH = ScrW, ScrH

local BindToKeyTBL = {
	["ctrl"] = KEY_LCONTROL,
	["rctrl"] = KEY_LCONTROL,
	["alt"] = KEY_LALT,
	["ralt"] = KEY_RALT,
	["space"] = KEY_SPACE,
	["caps"] = KEY_CAPSLOCK,
	["capslock"] = KEY_CAPSLOCK,
	["tab"] = KEY_TAB,
	["back"] = KEY_BACKSPACE,
	["backspace"] = KEY_BACKSPACE,
	[0] = KEY_0,
	[1] = KEY_1,
	[2] = KEY_2,
	[3] = KEY_3,
	[4] = KEY_4,
	[5] = KEY_5,
	[6] = KEY_6,
	[7] = KEY_7,
	[8] = KEY_8,
	[9] = KEY_9
}

local alphabet = "abcdefghijklmnopqrstuvwxyz"

for i = 1, string.len(alphabet) do
	local sstr = string.sub( alphabet, i, i )
	BindToKeyTBL[ sstr ] =  string.byte( sstr ) - 86
end


local SoundChars = {
	["*"] = "STREAM",--Streams from the disc and rapidly flushed; good on memory, useful for music or one-off sounds
	["#"] = "DRYMIX",--Skip DSP, affected by music volume rather than sound volume
	["@"] = "OMNI",--Play the sound audible everywhere, like a radio voiceover or surface.PlaySound
	[">"] = "DOPPLER",--Left channel for heading towards the listener, Right channel for heading away
	["<"] = "DIRECTIONAL",--Left channel = front facing, Right channel = read facing
	["^"] = "DISTVARIANT",--Left channel = close, Right channel = far
	["("] = "SPATIALSTEREO_LOOP",--Position a stereo sound in 3D space; broken
	[")"] = "SPATIALSTEREO",--Same as above but actually useful
	["}"] = "FASTPITCH",--Low quality pitch shift
	["$"] = "CRITICAL",--Keep it around in memory
	["!"] = "SENTENCE",--NPC dialogue
	["?"] = "USERVOX"--Fake VOIP data; not that useful
}
local DefaultSoundChar = ")"

local SoundChannels = {
	["shoot"] = CHAN_WEAPON,
	["shootwrap"] = CHAN_STATIC,
	["misc"] = CHAN_AUTO
}


--Scope

local cv_rt

function TFA.RTQuality()
	if not cv_rt then
		cv_rt = GetConVar("cl_tfa_3dscope_quality")
	end

	return math.Clamp(cv_rt:GetInt(), cv_rt:GetMin(), cv_rt:GetMax())
end

--Sensitivity

local ss, fov_og, resrat, fov_cv

fov_cv = GetConVar("fov_desired")
function TFA.CalculateSensitivtyScale( fov_target, fov_src, screenscale )
	if not LocalPlayer():IsValid() then return 1 end
	resrat = ScrW() / ScrH()
	fov_og = fov_src or TFADUSKFOV or fov_cv:GetFloat()
	ss = screenscale or 1
	return math.Clamp(math.atan( resrat * math.tan(math.rad( fov_target / 2  ) ) ) / math.atan( resrat * math.tan( math.rad( fov_og / 2) ) ) / ss, 0, 1)
end

--Ammo

local AmmoTypesByName = {}
local AmmoTypesAdded = {}

function TFA.AddAmmo(id, name)
	if not AmmoTypesAdded[id] then
		AmmoTypesAdded[id] = true

		game.AddAmmoType({
			name = id
		})
	end

	if name and language then
		language.Add(id .. "_ammo", name)
	end

	if name then
		AmmoTypesByName[name] = AmmoTypesByName[name] or id

		return AmmoTypesByName[name]
	end

	return id
end

--Particles

function TFA.ParticleTracer( name,startPos,endPos,doWhiz,ent,att)
	if type(ent) ~= "number" and IsValid(ent) and ent.EntIndex then
		ent = ent:EntIndex()
	end
	if ent then
		att = att or -1
		return util.ParticleTracerEx(name,startPos,endPos,doWhiz,ent,att)
	else
		return util.ParticleTracerEx(name,startPos,endPos,doWhiz,0,-1)
	end
end

--Binds

function TFA.BindToKey( bind, default )
	return BindToKeyTBL[ string.lower( bind ) ] or default or KEY_C
end

--Sounds

function TFA.PatchSound( path, kind )
	local pathv
	local c = string.sub(path,1,1)

	if SoundChars[c] then
		pathv = string.sub( path, 2, string.len(path) )
	else
		pathv = path
	end

	local kindstr = kind
	if not kindstr then
		kindstr = DefaultSoundChar
	end
	if string.len(kindstr) > 1 then
		local found = false
		for k,v in pairs( SoundChars ) do
			if v == kind then
				kindstr = k
				found = true
				break
			end
		end
		if not found then
			kindstr = DefaultSoundChar
		end
	end

	return kindstr .. pathv
end

function TFA.AddSound( name, channel, volume, level, pitch, wave, char )
	char = char or ""

	local SoundData = {
		name = name,
		channel = channel or CHAN_AUTO,
		volume = volume or 1,
		level = level or 75,
		pitch = pitch or 100
	}

	if char ~= "" then
		if type(wave) == "string" then
			wave = TFA.PatchSound(wave, char)
		elseif type(wave) == "table" then
			local patchWave = table.Copy(wave)

			for k, v in pairs(patchWave) do
				patchWave[k] = TFA.PatchSound(v, char)
			end

			wave = patchWave
		end
	end

	SoundData.sound = wave

	sound.Add(SoundData)
end

function TFA.AddFireSound( id, path, wrap, kindv )
	kindv = kindv or ")"

	TFA.AddSound(id, wrap and SoundChannels.shootwrap or SoundChannels.shoot, 1, 120, {97, 103}, path, kindv)
end

function TFA.AddWeaponSound( id, path, kindv )
	kindv = kindv or ")"

	TFA.AddSound(id, SoundChannels.misc, 1, 80, {97, 103}, path, kindv)
end

--Frametime

--CVar Mediators
function TFA.GetGasEnabled()
	local enabled = false

	if gas_cl_enabled then
		enabled = gas_cl_enabled:GetBool()
	end

	return enabled
end

function TFA.GetLegacyShellsEnabled()
	local enabled = false

	if oldshell_cl_enabled then
		enabled = oldshell_cl_enabled:GetBool()
	end

	return enabled
end

local ejectionsmoke_cl_enabled = GetConVar("cl_tfa_fx_ejectionsmoke")
local muzzlesmoke_cl_enabled = GetConVar("cl_tfa_fx_muzzlesmoke")

function TFA.GetMZSmokeEnabled()
	local enabled = false

	if muzzlesmoke_cl_enabled then
		enabled = muzzlesmoke_cl_enabled:GetBool()
	end

	return enabled
end

function TFA.GetEJSmokeEnabled()
	local enabled = false

	if ejectionsmoke_cl_enabled then
		enabled = ejectionsmoke_cl_enabled:GetBool()
	end

	return enabled
end

local muzzleflashsmoke_cl_enabled = GetConVar("cl_tfa_fx_muzzleflashsmoke")

function TFA.GetMZFSmokeEnabled()
	local enabled = false

	if muzzleflashsmoke_cl_enabled then
		enabled = muzzleflashsmoke_cl_enabled:GetBool()
	end

	return enabled
end

local ricofx_cl_enabled = GetConVar("cl_tfa_fx_impact_ricochet_enabled")

function TFA.GetRicochetEnabled()
	local enabled = false

	if ricofx_cl_enabled then
		enabled = ricofx_cl_enabled:GetBool()
	end

	return enabled
end

--Local function for detecting TFA Base weapons.
function TFA.PlayerCarryingTFAWeapon(ply)
	if not ply then
		if CLIENT then
			if LocalPlayer():IsValid() then
				ply = LocalPlayer()
			else
				return false, nil, nil
			end
		elseif game.SinglePlayer() then
			ply = Entity(1)
		else
			return false, nil, nil
		end
	end

	if not (IsValid(ply) and ply:IsPlayer() and ply:Alive()) then return end
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) then
		if (wep.IsTFAWeapon) then return true, ply, wep end

		return false, ply, wep
	end

	return false, ply, nil
end

local sv_cheats = GetConVar("sv_cheats")
local host_timescale = GetConVar("host_timescale")

function TFA.FrameTime()
	return engine.TickInterval() * game.GetTimeScale() * (sv_cheats:GetBool() and host_timescale:GetFloat() or 1)
end

local buffer = {}

function TFA.tbezier(t, values, amount)
	assert(isnumber(t), 't is not a number')
	assert(t >= 0 and t <= 1, '0 <= t <= 1!')
	assert(#values >= 2, 'at least two values must be provided')
	amount = amount or #values
	local a, b = values[1], values[2]

	-- linear
	if amount == 2 then
		return a + (b - a) * t
	-- square
	elseif amount == 3 then
		return (1 - t) * (1 - t) * a + 2 * t * (1 - t) * b + t * t * values[3]
	-- cube
	elseif amount == 4 then
		return (1 - t) * (1 - t) * (1 - t) * a + 3 * t * (1 - t) * (1 - t) * b + 3 * t * t * (1 - t) * values[3] + t * t * t * values[4]
	end

	for point = 1, amount do
		local point1 = values[point]
		local point2 = values[point + 1]
		if not point2 then break end
		buffer[point] = point1 + (point2 - point1) * t
	end

	return TFA.tbezier(t, buffer, amount - 1)
end

if DLib and math.tbezier and isfunction(math.tbezier) then
	TFA.tbezier = math.tbezier
end

function TFA.Quintic(t)
	return t * t * t * (t * (t * 6 - 15) + 10)
end

function TFA.Cosine(t)
	return (1 - math.cos(t * math.pi)) / 2
end

function TFA.Sinusine(t)
	return (1 - math.sin(t * math.pi)) / 2
end

function TFA.Cubic(t)
	return -2 * t * t * t + 3 * t * t
end

function TFA.UnfoldBaseClass(tableInput, tableOutput)
	if tableOutput == nil then tableOutput = tableInput end
	if not istable(tableInput) or not istable(tableOutput) then return tableOutput end

	if tableInput ~= tableOutput then
		for k, v in pairs(tableInput) do
			if tableOutput[k] == nil then
				tableOutput[k] = v
			end
		end
	end

	if istable(tableInput.BaseClass) then
		TFA.UnfoldBaseClass(tableInput.BaseClass, tableOutput)
	end

	return tableOutput
end

if CLIENT then
	local cvar_scale = GetConVar("cl_tfa_hud_scale")
	local sscache = {}

	function TFA.ScaleH(num)
		if not sscache[num] then
			sscache[num] = num * (ScrH() / 1080) * cvar_scale:GetFloat()
		end

		return sscache[num]
	end

	local function EmptyCache()
		sscache = {}
	end

	cvars.AddChangeCallback("cl_tfa_hud_scale", EmptyCache, "TFA_ClearSScaleCache")
	hook.Add("OnScreenSizeChanged", "_TFA_DropSScaleCache", EmptyCache)

	local color_black = Color(0, 0, 0, 255)
	function TFA.DrawTextShadowed(text, font, x, y, color, shadowlength, shadowcolor)
		shadowlength = shadowlength or 2
		shadowcolor = shadowcolor or ColorAlpha(color_black, color.a)

		surface.SetFont(font)

		surface.SetTextPos(x + shadowlength, y + shadowlength)
		surface.SetTextColor(shadowcolor.r, shadowcolor.g, shadowcolor.b, shadowcolor.a)
		surface.DrawText(text)

		surface.SetTextPos(x, y)
		surface.SetTextColor(color.r, color.g, color.b, color.a)
		surface.DrawText(text)
	end
end

--PATH lua/tfa/modules/tfa_hooks.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_keyvalues.lua:
local CHAR_STRING = {
	["\""] = true,
	["'"] = true
}

local CHAR_TABLE_OPEN = {
	["{"] = true,
	["["] = true
}

local CHAR_TABLE_CLOSE = {
	["}"] = true,
	["]"] = true
}

local CHAR_WHITESPACE = {
	[" "] = true,
	["\t"] = true,
	["\r"] = true,
	["\n"] = true
}

local CHAR_NEWLINE = {
	["\r"] = true,
	["\n"] = true
}

local CHAR_COMMENT = {
	["/"] = true,
	["-"] = true
}

local KEY_CASE = true
local ORDERED = false

local buffer = ""
local tbl = {}
local tbl_focus
local tbl_tmp
local value, lastvalue
local ignore_next_pop
local escape
local stringtype
local is_comment = false
local f

local strsub = string.sub
local strlow = string.lower

local fread = file.Read

local function strchar( strv, ind )
	return strsub( strv, ind, ind)
end

local function ResetValues()
	lastvalue = nil
	value = nil
end

local function FlushBuffer(write)
	if buffer ~= "" or stringtype then
		lastvalue = value
		if lastvalue and not KEY_CASE then
			lastvalue = strlow(lastvalue)
		end
		value = buffer
		buffer = ""

		if tbl_focus and (write == nil or write) and lastvalue and value then
			if ORDERED then
				tbl_focus[ #tbl_focus + 1 ] = { ["key"] = lastvalue, ["value"] = value }
			else
				tbl_focus[lastvalue] = value
			end
			ResetValues()
		end
	end
end

local function PushTable()
	FlushBuffer(true)
	if value and not KEY_CASE then
		value = strlow(value)
	end
	if value and value ~= "" then
		if ORDERED then
			tbl_focus[ #tbl_focus + 1 ] = { ["key"] = value, ["value"] = {} }
			tbl_focus[ #tbl_focus ].value.__par = tbl_focus
			tbl_focus = tbl_focus[ #tbl_focus ].value
		else
			tbl_focus[value] = istable(tbl_focus[value]) and tbl_focus[value] or {}
			tbl_focus[value].__par = tbl_focus
			tbl_focus = tbl_focus[value]
		end
		ignore_next_pop = false
	else
		ignore_next_pop = true
	end

	ResetValues()
end

local function PopTable()
	if not ignore_next_pop then
		FlushBuffer(true)

		if tbl_focus.__par then
			tbl_tmp = tbl_focus.__par
			tbl_focus.__par = nil
			tbl_focus = tbl_tmp
		end
	end

	ignore_next_pop = false
	ResetValues()
end

function TFA.ParseKeyValues(fn, path, use_escape, keep_key_case, invalid_escape_addslash, ordered )
	if use_escape == nil then
		use_escape = true
	end
	if keep_key_case == nil then
		keep_key_case = true
	end
	KEY_CASE = keep_key_case
	if invalid_escape_addslash == nil then
		invalid_escape_addslash = true
	end
	if ordered then
		ORDERED = true
	else
		ORDERED = false
	end
	tbl = {}
	tbl_focus = tbl
	tbl_tmp = nil
	value = nil
	lastvalue = nil
	escape = false
	is_comment = false
	stringtype = nil
	f = fread(fn, path)
	if not f then return tbl end
	for i = 1, #f do
		local char = strchar(f,i)

		if not char then
			FlushBuffer()
			break
		end

		if is_comment then
			if CHAR_NEWLINE[char] then
				is_comment = false
			end
		elseif escape then
			if char == "t" then
				buffer = buffer .. "\t"
			elseif char == "n" then
				buffer = buffer .. "\n"
			elseif char == "r" then
				buffer = buffer
			else
				if invalid_escape_addslash then
					buffer = buffer .. "\\"
				end
				buffer = buffer .. char
			end

			escape = false
		elseif char == "\\" and use_escape then
			escape = true
		elseif CHAR_STRING[char] then
			if not stringtype then
				FlushBuffer()
				stringtype = char
			elseif stringtype == char then
				FlushBuffer()
				stringtype = nil
			elseif stringtype then
				buffer = buffer .. char
			end
		elseif stringtype then
			buffer = buffer .. char
		elseif CHAR_COMMENT[char] then
			if CHAR_COMMENT[ strchar(f,i + 1,i + 1 ) ] then
				is_comment = true
			else
				buffer = buffer .. char
			end
		elseif CHAR_WHITESPACE[char] then
			if buffer ~= "" then
				FlushBuffer()
			end
		elseif CHAR_TABLE_OPEN[char] then
			PushTable()
		elseif CHAR_TABLE_CLOSE[char] then
			PopTable()
		else
			buffer = buffer .. char
		end
	end
	return tbl
end
--PATH lua/tfa/modules/cl_tfa_attachment_panel.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_changelog.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_fonts.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_fonts.lua:
TFA.Fonts = TFA.Fonts or {}

local ScaleH = TFA.ScaleH

local function GetFontHeight(fontname) -- UNCACHED!
	surface.SetFont(fontname)

	local _, h = surface.GetTextSize("W")

	return h
end

local function CreateFonts()
	local fontdata = {}

	fontdata.font = "Inter"
	fontdata.shadow = false
	fontdata.extended = true
	fontdata.weight = 400
	fontdata.size = ScaleH(36)
	surface.CreateFont("TFASleek", fontdata)
	TFA.Fonts.SleekHeight = GetFontHeight("TFASleek")

	fontdata.size = ScaleH(30)
	surface.CreateFont("TFASleekMedium", fontdata)
	TFA.Fonts.SleekHeightMedium = GetFontHeight("TFASleekMedium")

	fontdata.size = ScaleH(24)
	surface.CreateFont("TFASleekSmall", fontdata)
	TFA.Fonts.SleekHeightSmall = GetFontHeight("TFASleekSmall")

	fontdata.size = ScaleH(18)
	surface.CreateFont("TFASleekTiny", fontdata)
	TFA.Fonts.SleekHeightTiny = GetFontHeight("TFASleekTiny")

	fontdata = {}

	fontdata.font = "Inter"
	fontdata.extended = true
	fontdata.weight = 500
	fontdata.size = ScaleH(64)
	surface.CreateFont("TFA_INSPECTION_TITLE", fontdata)
	TFA.Fonts.InspectionHeightTitle = GetFontHeight("TFA_INSPECTION_TITLE")

	fontdata.size = ScaleH(32)
	surface.CreateFont("TFA_INSPECTION_DESCR", fontdata)
	TFA.Fonts.InspectionHeightDescription = GetFontHeight("TFA_INSPECTION_DESCR")

	fontdata.size = ScaleH(24)
	fontdata.weight = 400
	surface.CreateFont("TFA_INSPECTION_SMALL", fontdata)
	TFA.Fonts.InspectionHeightSmall = GetFontHeight("TFA_INSPECTION_SMALL")

	fontdata = {}
	fontdata.extended = true
	fontdata.weight = 400

	fontdata.font = "Inter"
	fontdata.size = ScaleH(12)
	surface.CreateFont("TFAAttachmentIconFont", fontdata)
	fontdata.size = ScaleH(10)
	surface.CreateFont("TFAAttachmentIconFontTiny", fontdata)

	fontdata.font = "Inter"
	fontdata.weight = 500
	fontdata.size = ScaleH(24)
	surface.CreateFont("TFAAttachmentTTHeader", fontdata)

	fontdata.font = "Inter"
	fontdata.weight = 300
	fontdata.size = ScaleH(18)
	surface.CreateFont("TFAAttachmentTTBody", fontdata)

	surface.CreateFont("TFASleekDebug", { font = "Roboto", size = 24, extended = true })
	TFA.Fonts.SleekHeightDebug = 24

	hook.Run("TFA_FontsLoaded")
end

CreateFonts()

hook.Add("OnScreenSizeChanged", "TFA_Fonts_Regenerate", CreateFonts)
cvars.AddChangeCallback("cl_tfa_hud_scale", CreateFonts, "TFA_RecreateFonts")
--PATH lua/tfa/modules/cl_tfa_particles_lua.lua:
local vector_origin = Vector()

TFA.Particles = TFA.Particles or {}
TFA.Particles.FlareParts = {}
TFA.Particles.VMAttachments = {}

local VMAttachments = TFA.Particles.VMAttachments
local FlareParts = TFA.Particles.FlareParts

local ply, vm, wep

local IsValid_ = FindMetaTable("Entity").IsValid
local GetModel = FindMetaTable("Entity").GetModel
local lastVMModel, lastVMAtts

local lastRequired = 0
local RealTime = RealTime
local FrameTime = FrameTime
local LocalPlayer = LocalPlayer
local ipairs = ipairs
local istable = istable
local isfunction = isfunction
local WorldToLocal = WorldToLocal
local table = table

local thinkAttachments = {}
local slowThinkers = 0

hook.Add("PreDrawEffects", "TFAMuzzleUpdate", function()
	if lastRequired < RealTime() then return end

	if not ply then
		ply = LocalPlayer()
	end

	if not IsValid_(vm) then
		vm = ply:GetViewModel()
		if not IsValid_(vm) then return end
	end

	local vmmodel = GetModel(vm)

	if vmmodel ~= lastVMModel then
		lastVMModel = vmmodel
		lastVMAtts = vm:GetAttachments()
	end

	if not lastVMAtts then return end

	if slowThinkers == 0 then
		for i in pairs(thinkAttachments) do
			VMAttachments[i] = vm:GetAttachment(i)
		end
	else
		for i = 1, #lastVMAtts do
			VMAttachments[i] = vm:GetAttachment(i)
		end
	end

	for _, v in ipairs(FlareParts) do
		if v and v.ThinkFunc then
			v:ThinkFunc()
		end
	end
end)

function TFA.Particles.RegisterParticleThink(particle, partfunc)
	if not particle or not isfunction(partfunc) then return end

	if not ply then
		ply = LocalPlayer()
	end

	if not IsValid_(vm) then
		vm = ply:GetViewModel()
		if not IsValid_(vm) then return end
	end

	particle.ThinkFunc = partfunc

	if IsValid(particle.FollowEnt) and particle.Att then
		local angpos = particle.FollowEnt:GetAttachment(particle.Att)

		if angpos then
			particle.OffPos = WorldToLocal(particle:GetPos(), particle:GetAngles(), angpos.Pos, angpos.Ang)
		end
	end

	local att = particle.Att

	local isFast = partfunc == TFA.Particles.FollowMuzzle and att ~= nil
	local isVM = particle.FollowEnt == vm

	if isFast then
		if isVM then
			thinkAttachments[att] = (thinkAttachments[att] or 0) + 1
		end
	else
		slowThinkers = slowThinkers + 1
	end

	table.insert(FlareParts, particle)

	timer.Simple(particle:GetDieTime(), function()
		if particle then
			table.RemoveByValue(FlareParts, particle)
		end

		if not isFast then
			slowThinkers = slowThinkers - 1
		elseif isVM and att then
			thinkAttachments[att] = thinkAttachments[att] - 1
			if thinkAttachments[att] <= 0 then thinkAttachments[att] = nil end
		end
	end)

	lastRequired = RealTime() + 0.5
end

function TFA.Particles.FollowMuzzle(self, first)
	if lastRequired < RealTime() then
		lastRequired = RealTime() + 0.5
		return
	end

	lastRequired = RealTime() + 0.5

	if self.isfirst == nil then
		self.isfirst = false
		first = true
	end

	if not IsValid_(ply) or not IsValid_(vm) then return end
	wep = ply:GetActiveWeapon()
	if IsValid(wep) and wep.IsCurrentlyScoped and wep:IsCurrentlyScoped() then return end

	if not IsValid(self.FollowEnt) then return end
	local owent = self.FollowEnt:GetOwner() or self.FollowEnt
	if not IsValid(owent) then return end

	local firvel

	if first then
		firvel = owent:GetVelocity() * FrameTime() * 1.1
	else
		firvel = vector_origin
	end

	if not self.Att or not self.OffPos then return end

	if self.FollowEnt == vm then
		local angpos = VMAttachments[self.Att]

		if angpos then
			local tmppos = LocalToWorld(self.OffPos, self:GetAngles(), angpos.Pos, angpos.Ang)
			local npos = tmppos + self:GetVelocity() * FrameTime()
			self.OffPos = WorldToLocal(npos + firvel, self:GetAngles(), angpos.Pos, angpos.Ang)
			self:SetPos(npos + firvel)
		end

		return
	end

	local angpos = self.FollowEnt:GetAttachment(self.Att)

	if angpos then
		local tmppos = LocalToWorld(self.OffPos, self:GetAngles(), angpos.Pos, angpos.Ang)
		local npos = tmppos + self:GetVelocity() * FrameTime()
		self.OffPos = WorldToLocal(npos + firvel * 0.5, self:GetAngles(), angpos.Pos, angpos.Ang)
		self:SetPos(npos + firvel)
	end
end

--PATH lua/tfa/modules/cl_tfa_vgui.lua:
local DLIB_IS_PRESENT = DLib ~= nil

local function AddColorMixer(panel, label, cvar_r, cvar_g, cvar_b, cvar_a)
	local colorMixer = vgui.Create(DLIB_IS_PRESENT and "DLibColorMixer" or "DColorMixer")

	if DLIB_IS_PRESENT and colorMixer.EnableTallLayout then
		colorMixer:EnableTallLayout()
	end

	if label then
		if colorMixer.SetLabel then
			colorMixer:SetLabel(label)
		else
			panel:Help(label)
		end
	end

	colorMixer:SetConVarR(cvar_r)
	colorMixer:SetConVarG(cvar_g)
	colorMixer:SetConVarB(cvar_b)
	if cvar_a then
		colorMixer:SetConVarA(cvar_a)
	else
		colorMixer:SetAlphaBar(false)
	end

	panel:AddItem(colorMixer)

	return colorMixer
end
TFA.AddColorMixer = AddColorMixer

local function AddFoldedColorMixer(panel, label, cvar_r, cvar_g, cvar_b, cvar_a)
	local form = vgui.Create("DForm", panel)
	form:SetName(label)
	panel:AddItem(form)

	return AddColorMixer(form, "", cvar_r, cvar_g, cvar_b, cvar_a), form
end
TFA.AddFoldedColorMixer = AddFoldedColorMixer

local function tfaOptionServer(panel)
	--Here are whatever default categories you want.
	local tfaOptionSV = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_server"
	}

	tfaOptionSV.Options["#preset.default"] = {
		sv_tfa_ironsights_enabled = "1",
		sv_tfa_sprint_enabled = "1",
		sv_tfa_weapon_strip = "0",
		sv_tfa_allow_dryfire = "1",
		sv_tfa_damage_multiplier = "1",
		sv_tfa_damage_multiplier_npc = "1",
		sv_tfa_damage_mult_min = "0.95",
		sv_tfa_damage_mult_max = "1.05",
		sv_tfa_default_clip = "-1",
		sv_tfa_arrow_lifetime = "30",
		sv_tfa_force_multiplier = "1",
		sv_tfa_bullet_penetration_power_mul = "1",
		sv_tfa_dynamicaccuracy = "1",
		sv_tfa_range_modifier = "0.5",
		sv_tfa_spread_multiplier = "1",
		sv_tfa_bullet_penetration = "1",
		sv_tfa_bullet_ricochet = "0",
		sv_tfa_bullet_doordestruction = "1",
		sv_tfa_melee_doordestruction = "1",
		sv_tfa_bullet_randomseed = "0",
		sv_tfa_reloads_legacy = "0",
		sv_tfa_fixed_crosshair = "0",
		sv_tfa_crosshair_showplayer = "1",
		sv_tfa_crosshair_showplayerteam = engine.ActiveGamemode() == "terrortown" and "0" or "1",
		sv_tfa_reloads_enabled = "1",
		sv_tfa_cmenu = "1",
		sv_tfa_penetration_hardlimit = "100",
		sv_tfa_jamming = "1",
		sv_tfa_jamming_mult = "1",
		sv_tfa_jamming_factor = "1",
		sv_tfa_jamming_factor_inc = "1",
		sv_tfa_door_respawn = "-1",
		sv_tfa_attachments_enabled = "1",
		sv_tfa_npc_randomize_atts = "1",
		sv_tfa_fov_sprintmod = "1",
		sv_tfa_recoil_multiplier = "1",
		sv_tfa_knockback_multiplier = "1",
		sv_tfa_first_draw_anim_enabled = "1",
	}

	tfaOptionSV.CVars = table.GetKeys(tfaOptionSV.Options["#preset.default"])

	panel:AddControl("ComboBox", tfaOptionSV)

	--These are the panel controls.  Adding these means that you don't have to go into the console.
	TFA.CheckBoxNet(panel, "#tfa.svsettings.dryfire", "sv_tfa_allow_dryfire")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.dynaccuracy", "sv_tfa_dynamicaccuracy")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.stripempty", "sv_tfa_weapon_strip")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.ironsight", "sv_tfa_ironsights_enabled")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.sprint", "sv_tfa_sprint_enabled")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.attachments", "sv_tfa_attachments_enabled")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.randomizenpcatts", "sv_tfa_npc_randomize_atts")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.cmenu", "sv_tfa_cmenu")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.penetration", "sv_tfa_bullet_penetration")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.ricochet", "sv_tfa_bullet_ricochet")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.doorbust", "sv_tfa_bullet_doordestruction")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.doorbash", "sv_tfa_melee_doordestruction")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.reloads", "sv_tfa_reloads_enabled")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.jamming", "sv_tfa_jamming")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.nearlyempty", "sv_tfa_nearlyempty")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.legacyreloads", "sv_tfa_reloads_legacy")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.firstdrawanim", "sv_tfa_first_draw_anim_enabled")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.fixedcrosshair", "sv_tfa_fixed_crosshair")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.crosshairshowplayer", "sv_tfa_crosshair_showplayer")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.crosshairshowplayerteam", "sv_tfa_crosshair_showplayerteam")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.fov.sprintmod", "sv_tfa_fov_sprintmod")

	TFA.CheckBoxNet(panel, "#tfa.svsettings.randomseed", "sv_tfa_bullet_randomseed")
	panel:Help("#tfa.svsettings.randomseed_tip")

	TFA.NumSliderNet(panel, "#tfa.svsettings.damagemult", "sv_tfa_damage_multiplier", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.damagemultnpc", "sv_tfa_damage_multiplier_npc", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.damagemultrand_min", "sv_tfa_damage_mult_min", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.damagemultrand_max", "sv_tfa_damage_mult_max", 0, 10, 2)
	panel:Help("#tfa.svsettings.damagemultrand_tip")

	TFA.NumSliderNet(panel, "#tfa.svsettings.doorrespawntime", "sv_tfa_door_respawn", -1, 120, 0)

	TFA.NumSliderNet(panel, "#tfa.svsettings.jamchance", "sv_tfa_jamming_mult", 0.01, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.jamfactormult", "sv_tfa_jamming_factor", 0.01, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.jamfactorinc", "sv_tfa_jamming_factor_inc", 0.01, 10, 2)

	TFA.NumSliderNet(panel, "#tfa.svsettings.forcemult", "sv_tfa_force_multiplier", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.penpowermul", "sv_tfa_bullet_penetration_power_mul", 0, 40, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.spreadmult", "sv_tfa_spread_multiplier", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.penetrationlimit", "sv_tfa_penetration_hardlimit", 0, 200)
	TFA.NumSliderNet(panel, "#tfa.svsettings.defaultclip", "sv_tfa_default_clip", -1, 10, 0)
	TFA.NumSliderNet(panel, "#tfa.svsettings.rangemod", "sv_tfa_range_modifier", 0, 1, 3)
	TFA.NumSliderNet(panel, "#tfa.svsettings.recoilmult", "sv_tfa_recoil_multiplier", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.knockbackmult", "sv_tfa_knockback_multiplier", 0, 10, 2)
end

local function tfaOptionSights(panel)
	--Here are whatever default categories you want.
	local tfaOptionCL = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_sights"
	}

	tfaOptionCL.Options["#preset.default"] = {
		cl_tfa_3dscope_overlay = "1",
		cl_tfa_3dscope_quality = "0",
		cl_tfa_fx_rtscopeblur_passes = "3",
		cl_tfa_fx_rtscopeblur_intensity = "4",
		cl_tfa_fx_rtscopeblur_mode = "1",
		cl_tfa_scope_sensitivity_3d = "2",
		cl_tfa_scope_sensitivity_autoscale = "1",
		cl_tfa_scope_sensitivity = "100",
		cl_tfa_ironsights_toggle = "0",
		cl_tfa_ironsights_resight = "1",
		cl_tfa_ironsights_responsive = "0",
		cl_tfa_ironsights_responsive_timer = "0.175",
	}

	tfaOptionCL.CVars = table.GetKeys(tfaOptionCL.Options["#preset.default"])

	panel:AddControl("ComboBox", tfaOptionCL)

	panel:CheckBox("#tfa.sightsettings.3dscopeshadows", "cl_tfa_3dscope_overlay")

	local tfaOption3DSM = {
		Options = {},
		CVars = {},
		Label = "#tfa.sightsettings.3dsm",
		MenuButton = "0",
		Folder = "TFA 3D Scope Sens."
	}

	tfaOption3DSM.Options["#tfa.sightsettings.3dsm.nc"] = {
		cl_tfa_scope_sensitivity_3d = "0"
	}

	tfaOption3DSM.Options["#tfa.sightsettings.3dsm.sc"] = {
		cl_tfa_scope_sensitivity_3d = "1"
	}

	tfaOption3DSM.Options["#tfa.sightsettings.3dsm.3d"] = {
		cl_tfa_scope_sensitivity_3d = "2"
	}

	tfaOption3DSM.Options["#tfa.sightsettings.3dsm.rt"] = {
		cl_tfa_scope_sensitivity_3d = "3"
	}

	tfaOption3DSM.CVars = table.GetKeys(tfaOption3DSM.Options["#tfa.sightsettings.3dsm.3d"])
	panel:AddControl("ComboBox", tfaOption3DSM)

	local tfaOption3DSQ = {
		Options = {},
		CVars = {},
		Label = "#tfa.sightsettings.3dsq",
		MenuButton = "0",
		Folder = "TFA 3D Scope Sens."
	}

	tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.ul"] = {
		cl_tfa_3dscope_quality = "0"
	}

	tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.hq"] = {
		cl_tfa_3dscope_quality = "1"
	}

	tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.mq"] = {
		cl_tfa_3dscope_quality = "2"
	}

	tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.lq"] = {
		cl_tfa_3dscope_quality = "3"
	}

	tfaOption3DSQ.CVars = table.GetKeys(tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.ul"])
	panel:AddControl("ComboBox", tfaOption3DSQ)

	local tfaOption3DSB = {
		Options = {},
		CVars = {},
		Label = "#tfa.sightsettings.3dsb",
		MenuButton = "0",
		Folder = "TFA 3D Scope Blur."
	}

	tfaOption3DSB.Options["#tfa.sightsettings.3dsb.nb"] = {
		cl_tfa_fx_rtscopeblur_mode = "0"
	}

	tfaOption3DSB.Options["#tfa.sightsettings.3dsb.sb"] = {
		cl_tfa_fx_rtscopeblur_mode = "1"
	}

	tfaOption3DSB.Options["#tfa.sightsettings.3dsb.bb"] = {
		cl_tfa_fx_rtscopeblur_mode = "2"
	}

	tfaOption3DSB.CVars = table.GetKeys(tfaOption3DSB.Options["#tfa.sightsettings.3dsb.bb"])
	panel:AddControl("ComboBox", tfaOption3DSB)

	panel:NumSlider("#tfa.sightsettings.rtbgblurpasses", "cl_tfa_fx_rtscopeblur_passes", 1, 5, 0)
	panel:NumSlider("#tfa.sightsettings.rtbgblurintensity", "cl_tfa_fx_rtscopeblur_intensity", 0.01, 10, 2)
	panel:CheckBox("#tfa.sightsettings.adstoggle", "cl_tfa_ironsights_toggle")
	panel:CheckBox("#tfa.sightsettings.adsresight", "cl_tfa_ironsights_resight")
	panel:CheckBox("#tfa.sightsettings.responsive", "cl_tfa_ironsights_responsive")
	panel:NumSlider("#tfa.sightsettings.responsive_timer", "cl_tfa_ironsights_responsive_timer", 0.01, 2, 3)
	panel:CheckBox("#tfa.sightsettings.scopesensscale", "cl_tfa_scope_sensitivity_autoscale")
	panel:NumSlider("#tfa.sightsettings.scopesenspct", "cl_tfa_scope_sensitivity", 0.01, 100, 2)
end

local function tfaOptionVM(panel)
	--Here are whatever default categories you want.
	local tfaOptionCL = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_viewmodel"
	}

	tfaOptionCL.Options["#preset.default"] = {
		cl_tfa_viewbob_animated = "0",
		cl_tfa_viewbob_intensity = "1",
		cl_tfa_gunbob_intensity = "1",
		cl_tfa_gunbob_custom = "1",
		cl_tfa_gunbob_invertsway = "0",
		cl_tfa_viewmodel_offset_x = "0",
		cl_tfa_viewmodel_offset_y = "0",
		cl_tfa_viewmodel_offset_z = "0",
		cl_tfa_viewmodel_offset_fov = "0",
		cl_tfa_viewmodel_multiplier_fov = "1",
		cl_tfa_viewmodel_flip = "0",
		cl_tfa_viewmodel_centered = "0",
		cl_tfa_viewmodel_nearwall = "1",
		cl_tfa_laser_trails = "1"
	}

	tfaOptionCL.CVars = table.GetKeys(tfaOptionCL.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionCL)

	panel:CheckBox("#tfa.vmsettings.viewbobanim", "cl_tfa_viewbob_animated")
	panel:NumSlider("#tfa.vmsettings.viewbobmult", "cl_tfa_viewbob_intensity", 0, 2, 2)
	panel:CheckBox("#tfa.vmsettings.gunbobcustom", "cl_tfa_gunbob_custom")
	panel:CheckBox("#tfa.vmsettings.gunswayinvert", "cl_tfa_gunbob_invertsway")
	panel:NumSlider("#tfa.vmsettings.gunbobmult", "cl_tfa_gunbob_intensity", 0, 2, 2)

	panel:NumSlider("#tfa.vmsettings.offset.x", "cl_tfa_viewmodel_offset_x", -2, 2, 2)
	panel:NumSlider("#tfa.vmsettings.offset.y", "cl_tfa_viewmodel_offset_y", -2, 2, 2)
	panel:NumSlider("#tfa.vmsettings.offset.z", "cl_tfa_viewmodel_offset_z", -2, 2, 2)
	panel:NumSlider("#tfa.vmsettings.offset.fov", "cl_tfa_viewmodel_offset_fov", -5, 5, 2)
	panel:NumSlider("#tfa.vmsettings.fovmult", "cl_tfa_viewmodel_multiplier_fov", 0.75, 2, 2)

	panel:CheckBox("#tfa.vmsettings.centered", "cl_tfa_viewmodel_centered")
	panel:CheckBox("#tfa.vmsettings.flip", "cl_tfa_viewmodel_flip")

	panel:CheckBox("#tfa.vmsettings.laserdottrail", "cl_tfa_laser_trails")
	panel:CheckBox("#tfa.vmsettings.nearwall", "cl_tfa_viewmodel_nearwall")
end

local function tfaOptionPerformance(panel)
	--Here are whatever default categories you want.
	local tfaOptionPerf = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_performance"
	}

	tfaOptionPerf.Options["#preset.default"] = {
		sv_tfa_fx_penetration_decal = "1",
		cl_tfa_fx_impact_enabled = "1",
		cl_tfa_fx_impact_ricochet_enabled = "1",
		cl_tfa_fx_impact_ricochet_sparks = "20",
		cl_tfa_fx_impact_ricochet_sparklife = "2",
		cl_tfa_fx_gasblur = "1",
		cl_tfa_fx_muzzlesmoke = "1",
		cl_tfa_fx_muzzlesmoke_limited = "1",
		cl_tfa_fx_muzzleflashsmoke = "1",
		cl_tfa_fx_ejectionlife = "15",
		cl_tfa_legacy_shells = "0",
		cl_tfa_fx_ads_dof = "0",
		cl_tfa_fx_ads_dof_hd = "0"
	}

	tfaOptionPerf.CVars = table.GetKeys(tfaOptionPerf.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionPerf)

	panel:Help("#tfa.settings.client")
	panel:CheckBox("#tfa.perfsettings.gasblur", "cl_tfa_fx_gasblur")
	panel:CheckBox("#tfa.perfsettings.mzsmoke", "cl_tfa_fx_muzzleflashsmoke")
	panel:CheckBox("#tfa.perfsettings.mztrail", "cl_tfa_fx_muzzlesmoke")
	panel:CheckBox("#tfa.perfsettings.mztrail.limit", "cl_tfa_fx_muzzlesmoke_limited")
	panel:CheckBox("#tfa.perfsettings.ejsmoke", "cl_tfa_fx_ejectionsmoke")
	panel:CheckBox("#tfa.perfsettings.impactfx", "cl_tfa_fx_impact_enabled")
	panel:CheckBox("#tfa.perfsettings.ricochetfx", "cl_tfa_fx_impact_ricochet_enabled")

	panel:CheckBox("#tfa.perfsettings.oldshells", "cl_tfa_legacy_shells")

	panel:CheckBox("#tfa.perfsettings.adsdof", "cl_tfa_fx_ads_dof")
	panel:CheckBox("#tfa.perfsettings.adsdof.hd", "cl_tfa_fx_ads_dof_hd")

	panel:NumSlider("#tfa.perfsettings.ejlife", "cl_tfa_fx_ejectionlife", 0, 60, 0)

	panel:NumSlider("#tfa.perfsettings.ricochetspark.amount", "cl_tfa_fx_impact_ricochet_sparks", 0, 50, 0)
	panel:AddControl("Slider", {
		Label = "Ricochet Spark Amount",
		Command = "cl_tfa_fx_impact_ricochet_sparks",
		Type = "Integer",
		Min = "0",
		Max = "50"
	})

	panel:NumSlider("#tfa.perfsettings.ricochetspark.life", "cl_tfa_fx_impact_ricochet_sparklife", 0, 5, 2)

	panel:Help("#tfa.settings.server")
	TFA.CheckBoxNet(panel, "#tfa.perfsettings.penetrationdecal", "sv_tfa_fx_penetration_decal")
end

local function tfaOptionHUD(panel)
	--Here are whatever default categories you want.
	local tfaTBLOptionHUD = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_hud"
	}

	tfaTBLOptionHUD.Options["#preset.default"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "225",
		cl_tfa_hud_crosshair_color_g = "225",
		cl_tfa_hud_crosshair_color_b = "225",
		cl_tfa_hud_crosshair_color_a = "225",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.2",
		cl_tfa_hud_hangtime = "1",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "1",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "1",
		cl_tfa_hud_crosshair_outline_enabled = "1",
		cl_tfa_hud_crosshair_outline_width = "1",
		cl_tfa_hud_crosshair_outline_color_r = "5",
		cl_tfa_hud_crosshair_outline_color_g = "5",
		cl_tfa_hud_crosshair_outline_color_b = "5",
		cl_tfa_hud_crosshair_outline_color_a = "225",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "1",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.cross"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "255",
		cl_tfa_hud_crosshair_color_g = "255",
		cl_tfa_hud_crosshair_color_b = "255",
		cl_tfa_hud_crosshair_color_a = "200",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.2",
		cl_tfa_hud_hangtime = "1",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "0.75",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "0",
		cl_tfa_hud_crosshair_outline_enabled = "1",
		cl_tfa_hud_crosshair_outline_width = "1",
		cl_tfa_hud_crosshair_outline_color_r = "154",
		cl_tfa_hud_crosshair_outline_color_g = "152",
		cl_tfa_hud_crosshair_outline_color_b = "175",
		cl_tfa_hud_crosshair_outline_color_a = "255",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "1",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.dot"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "72",
		cl_tfa_hud_crosshair_color_g = "72",
		cl_tfa_hud_crosshair_color_b = "72",
		cl_tfa_hud_crosshair_color_a = "85",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.1",
		cl_tfa_hud_hangtime = "0.5",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "0",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "0",
		cl_tfa_hud_crosshair_outline_enabled = "1",
		cl_tfa_hud_crosshair_outline_width = "1",
		cl_tfa_hud_crosshair_outline_color_r = "225",
		cl_tfa_hud_crosshair_outline_color_g = "225",
		cl_tfa_hud_crosshair_outline_color_b = "225",
		cl_tfa_hud_crosshair_outline_color_a = "85",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "0",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "0",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.rockstar"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "225",
		cl_tfa_hud_crosshair_color_g = "225",
		cl_tfa_hud_crosshair_color_b = "225",
		cl_tfa_hud_crosshair_color_a = "85",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.1",
		cl_tfa_hud_hangtime = "0.5",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "0",
		cl_tfa_hud_crosshair_width = "2",
		cl_tfa_hud_crosshair_gap_scale = "0",
		cl_tfa_hud_crosshair_outline_enabled = "1",
		cl_tfa_hud_crosshair_outline_width = "1",
		cl_tfa_hud_crosshair_outline_color_r = "30",
		cl_tfa_hud_crosshair_outline_color_g = "30",
		cl_tfa_hud_crosshair_outline_color_b = "30",
		cl_tfa_hud_crosshair_outline_color_a = "85",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "0",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "8",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.hl2"] = {
		cl_tfa_hud_crosshair_enable_custom = "0",
		cl_tfa_hud_crosshair_color_r = "255",
		cl_tfa_hud_crosshair_color_g = "255",
		cl_tfa_hud_crosshair_color_b = "255",
		cl_tfa_hud_crosshair_color_a = "225",
		cl_tfa_hud_crosshair_color_team = "0",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.01",
		cl_tfa_hud_hangtime = "0",
		cl_tfa_hud_crosshair_length_use_pixels = "1",
		cl_tfa_hud_crosshair_length = "0.5",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "1",
		cl_tfa_hud_crosshair_outline_enabled = "0",
		cl_tfa_hud_crosshair_outline_width = "0",
		cl_tfa_hud_crosshair_outline_color_r = "5",
		cl_tfa_hud_crosshair_outline_color_g = "5",
		cl_tfa_hud_crosshair_outline_color_b = "5",
		cl_tfa_hud_crosshair_outline_color_a = "0",
		cl_tfa_hud_crosshair_dot = "1",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "0",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "0",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.hl2plus"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "255",
		cl_tfa_hud_crosshair_color_g = "255",
		cl_tfa_hud_crosshair_color_b = "255",
		cl_tfa_hud_crosshair_color_a = "225",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.2",
		cl_tfa_hud_hangtime = "1",
		cl_tfa_hud_crosshair_length_use_pixels = "1",
		cl_tfa_hud_crosshair_length = "0.5",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "1",
		cl_tfa_hud_crosshair_outline_enabled = "0",
		cl_tfa_hud_crosshair_outline_width = "0",
		cl_tfa_hud_crosshair_outline_color_r = "5",
		cl_tfa_hud_crosshair_outline_color_g = "5",
		cl_tfa_hud_crosshair_outline_color_b = "5",
		cl_tfa_hud_crosshair_outline_color_a = "0",
		cl_tfa_hud_crosshair_dot = "1",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "1",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.crysis2"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "231",
		cl_tfa_hud_crosshair_color_g = "255",
		cl_tfa_hud_crosshair_color_b = "255",
		cl_tfa_hud_crosshair_color_a = "255",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "204",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "38",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "38",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.2",
		cl_tfa_hud_hangtime = "1",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "1",
		cl_tfa_hud_crosshair_width = "2",
		cl_tfa_hud_crosshair_gap_scale = "1",
		cl_tfa_hud_crosshair_outline_enabled = "0",
		cl_tfa_hud_crosshair_outline_width = "0",
		cl_tfa_hud_crosshair_outline_color_r = "0",
		cl_tfa_hud_crosshair_outline_color_g = "0",
		cl_tfa_hud_crosshair_outline_color_b = "0",
		cl_tfa_hud_crosshair_outline_color_a = "0",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "1",
		cl_tfa_hud_crosshair_pump = "1",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "1",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1.5",
		cl_tfa_hud_hitmarker_color_r = "231",
		cl_tfa_hud_hitmarker_color_g = "255",
		cl_tfa_hud_hitmarker_color_b = "255",
		cl_tfa_hud_hitmarker_color_a = "255",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.CVars = table.GetKeys(tfaTBLOptionHUD.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaTBLOptionHUD)

	panel:NumSlider("#tfa.hudsettings.scalemul", "cl_tfa_hud_scale", 0.25, 4, 3)

	local hudpnl = vgui.Create("DForm", panel)
	hudpnl:SetName("#tfa.hudsettings.label")
	panel:AddItem(hudpnl)

	hudpnl:CheckBox("#tfa.hudsettings.enabled", "cl_tfa_hud_enabled")
	hudpnl:NumSlider("#tfa.hudsettings.fadein", "cl_tfa_hud_ammodata_fadein", 0.01, 1, 2)
	hudpnl:NumSlider("#tfa.hudsettings.hangtime", "cl_tfa_hud_hangtime", 0, 5, 2)

	hudpnl:Help("")
	hudpnl:CheckBox("#tfa.hudsettings.fallback", "cl_tfa_hud_fallback_enabled")
	hudpnl:Help("#tfa.hudsettings.fallback.desc")

	local xhairpnl = vgui.Create("DForm", panel)
	xhairpnl:SetName("#tfa.hudsettings.crosshair.label")
	panel:AddItem(xhairpnl)

	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.enabled", "cl_tfa_hud_crosshair_enable_custom")
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.dot", "cl_tfa_hud_crosshair_dot")
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.triangular", "cl_tfa_hud_crosshair_triangular")
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.pump", "cl_tfa_hud_crosshair_pump")
	xhairpnl:NumSlider("#tfa.hudsettings.crosshair.length", "cl_tfa_hud_crosshair_length", 0, 10, 2)
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.length.usepixels", "cl_tfa_hud_crosshair_length_use_pixels")
	xhairpnl:NumSlider("#tfa.hudsettings.crosshair.gapscale", "cl_tfa_hud_crosshair_gap_scale", 0, 2, 2)
	xhairpnl:NumSlider("#tfa.hudsettings.crosshair.width", "cl_tfa_hud_crosshair_width", 0, 3, 0)
	AddFoldedColorMixer(xhairpnl, "#tfa.hudsettings.crosshair.color", "cl_tfa_hud_crosshair_color_r", "cl_tfa_hud_crosshair_color_g", "cl_tfa_hud_crosshair_color_b", "cl_tfa_hud_crosshair_color_a")
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.teamcolor", "cl_tfa_hud_crosshair_color_team")
	AddFoldedColorMixer(xhairpnl, "#tfa.hudsettings.crosshair.teamcolor.enemy", "cl_tfa_hud_crosshair_color_enemy_r", "cl_tfa_hud_crosshair_color_enemy_g", "cl_tfa_hud_crosshair_color_enemy_b")
	AddFoldedColorMixer(xhairpnl, "#tfa.hudsettings.crosshair.teamcolor.friendly", "cl_tfa_hud_crosshair_color_friendly_r", "cl_tfa_hud_crosshair_color_friendly_g", "cl_tfa_hud_crosshair_color_friendly_b")

	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.outline.enabled", "cl_tfa_hud_crosshair_outline_enabled")
	xhairpnl:NumSlider("#tfa.hudsettings.crosshair.outline.width", "cl_tfa_hud_crosshair_outline_width", 0, 3, 0)
	AddFoldedColorMixer(xhairpnl, "#tfa.hudsettings.crosshair.outline.color", "cl_tfa_hud_crosshair_outline_color_r", "cl_tfa_hud_crosshair_outline_color_g", "cl_tfa_hud_crosshair_outline_color_b", "cl_tfa_hud_crosshair_outline_color_a")

	local hmpnl = vgui.Create("DForm", panel)
	hmpnl:SetName("#tfa.hudsettings.hitmarker.label")
	panel:AddItem(hmpnl)

	hmpnl:CheckBox("#tfa.hudsettings.hitmarker.enabled", "cl_tfa_hud_hitmarker_enabled")
	hmpnl:CheckBox("#tfa.hudsettings.hitmarker.3d.shotguns", "cl_tfa_hud_hitmarker_3d_shotguns")
	hmpnl:CheckBox("#tfa.hudsettings.hitmarker.3d.all", "cl_tfa_hud_hitmarker_3d_all")
	hmpnl:NumSlider("#tfa.hudsettings.hitmarker.solidtime", "cl_tfa_hud_hitmarker_solidtime", 0, 3, 3)
	hmpnl:NumSlider("#tfa.hudsettings.hitmarker.fadetime", "cl_tfa_hud_hitmarker_fadetime", 0, 3, 3)
	hmpnl:NumSlider("#tfa.hudsettings.hitmarker.scale", "cl_tfa_hud_hitmarker_scale", 0, 5, 2)
	AddFoldedColorMixer(hmpnl, "#tfa.hudsettings.hitmarker.color", "cl_tfa_hud_hitmarker_color_r", "cl_tfa_hud_hitmarker_color_g", "cl_tfa_hud_hitmarker_color_b", "cl_tfa_hud_hitmarker_color_a")

	local kbhpnl = vgui.Create("DForm", panel)
	kbhpnl:SetName("#tfa.hudsettings.keybindhints.label")
	panel:AddItem(kbhpnl)

	kbhpnl:CheckBox("#tfa.hudsettings.keybindhints.enabled", "cl_tfa_hud_keybindhints_enabled")
	kbhpnl:NumSlider("#tfa.hudsettings.keybindhints.solidtime", "cl_tfa_hud_keybindhints_solidtime", 0, 15, 3)
	kbhpnl:NumSlider("#tfa.hudsettings.keybindhints.fadeintime", "cl_tfa_hud_keybindhints_fadeintime", 0.01, 10, 3)
	kbhpnl:NumSlider("#tfa.hudsettings.keybindhints.fadeouttime", "cl_tfa_hud_keybindhints_fadeouttime", 0.01, 10, 3)
end

local function tfaOptionDeveloper(panel)
	--Here are whatever default categories you want.
	local tfaOptionPerf = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_debug"
	}

	tfaOptionPerf.Options["#preset.default"] = {
		["cl_tfa_debug_crosshair"] = 0,
		["cl_tfa_debug_animations"] = 0,
		["cl_tfa_debug_rt"] = 0,
		["cl_tfa_debug_cache"] = 0
	}

	tfaOptionPerf.CVars = table.GetKeys(tfaOptionPerf.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionPerf)

	panel:Help("#tfa.devsettings.adminonly")

	panel:CheckBox("#tfa.devsettings.debug.crosshair", "cl_tfa_debug_crosshair")
	panel:CheckBox("#tfa.devsettings.debug.animations", "cl_tfa_debug_animations")
	panel:CheckBox("#tfa.devsettings.debug.rtshadow", "cl_tfa_debug_rt")
	panel:CheckBox("#tfa.devsettings.debug.cache", "cl_tfa_debug_cache")

	panel:Help("")

	panel:Help("#tfa.devsettings.documentation.label")
	local btnDocumentation = panel:Button("#tfa.devsettings.documentation.btn.github")
	btnDocumentation.DoClick = function()
		gui.OpenURL("https://github.com/YuRaNnNzZZ/TFA-SWEP-Base-Documentation")
	end

	local sdpnl = vgui.Create("DForm", panel)
	sdpnl:SetName("#tfa.devsettings.statmigrator.label")
	panel:AddItem(sdpnl)

	sdpnl:Help("#tfa.devsettings.statmigrator.help")
	sdpnl:Help(language.GetPhrase("tfa.devsettings.statmigrator.dataversion"):format("TFADataVersion", TFA.LatestDataVersion))

	local stat_old = sdpnl:TextEntry("#tfa.devsettings.statmigrator.old_name")

	local stat_new = sdpnl:TextEntry("#tfa.devsettings.statmigrator.new_name")
	stat_new:SetEditable(false)

	local copy_new = sdpnl:Button("#tfa.devsettings.statmigrator.copy_btn.label")
	copy_new.DoClick = function(self)
		SetClipboardText(stat_new:GetValue())
	end

	stat_old.OnChange = function(self)
		local stat = self:GetValue()

		if string.StartsWith(stat, "SWEP.") or string.StartsWith(stat, "self.") then
			stat = string.sub(stat, 6)
		end

		local _, path, _ = TFA.GetStatPath(stat, 0, TFA.LatestDataVersion)

		stat_new:SetValue(path)
	end
end

local function tfaOptionColors(panel)
	local tfaOptionCO = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_colors"
	}

	tfaOptionCO.Options["#preset.default"] = {
		cl_tfa_laser_color_r = "255",
		cl_tfa_laser_color_g = "0",
		cl_tfa_laser_color_b = "0",
		cl_tfa_reticule_color_r = "255",
		cl_tfa_reticule_color_g = "100",
		cl_tfa_reticule_color_b = "0"
	}

	tfaOptionCO.CVars = table.GetKeys(tfaOptionCO.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionCO)

	AddFoldedColorMixer(panel, "#tfa.colorsettings.laser", "cl_tfa_laser_color_r", "cl_tfa_laser_color_g", "cl_tfa_laser_color_b")
	AddFoldedColorMixer(panel, "#tfa.colorsettings.reticule", "cl_tfa_reticule_color_r", "cl_tfa_reticule_color_g", "cl_tfa_reticule_color_b")
end

local function tfaOptionBallistics(panel)
	--Here are whatever default categories you want.
	local tfaOptionPerf = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_ballistics"
	}

	tfaOptionPerf.Options["#preset.default"] = {
		["sv_tfa_ballistics_enabled"] = nil,
		["sv_tfa_ballistics_mindist"] = -1,
		["sv_tfa_ballistics_bullet_life"] = 10,
		["sv_tfa_ballistics_bullet_damping_air"] = 1,
		["sv_tfa_ballistics_bullet_damping_water"] = 3,
		["sv_tfa_ballistics_bullet_velocity"] = 1,
		["sv_tfa_ballistics_bullet_substeps"] = 3,
		["sv_tfa_ballistics_custom_gravity"] = 0,
		["sv_tfa_ballistics_custom_gravity_value"] = 0,
		["cl_tfa_ballistics_mp"] = 1,
		["cl_tfa_ballistics_fx_bullet"] = 1,
		["cl_tfa_ballistics_fx_tracers_style"] = 1,
		["cl_tfa_ballistics_fx_tracers_mp"] = 1,
		["cl_tfa_ballistics_fx_tracers_adv"] = 1
	}

	tfaOptionPerf.CVars = table.GetKeys(tfaOptionPerf.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionPerf)

	panel:Help("#tfa.settings.server")
	TFA.CheckBoxNet(panel, "#tfa.ballisticsettings.enabled", "sv_tfa_ballistics_enabled")
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.mindist", "sv_tfa_ballistics_mindist", -1, 100, 0)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.bullet.life", "sv_tfa_ballistics_bullet_life", 0, 20, 2)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.bullet.damping.air", "sv_tfa_ballistics_bullet_damping_air", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.bullet.damping.water", "sv_tfa_ballistics_bullet_damping_water", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.bullet.velocity", "sv_tfa_ballistics_bullet_velocity", 0, 2, 3)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.substeps", "sv_tfa_ballistics_substeps", 1, 5, 0)
	TFA.CheckBoxNet(panel, "#tfa.ballisticsettings.customgravity", "sv_tfa_ballistics_custom_gravity")
	TFA.CheckBoxNet(panel, "#tfa.ballisticsettings.customgravityvalue", "sv_tfa_ballistics_custom_gravity_value")

	panel:Help("#tfa.settings.client")

	panel:CheckBox("#tfa.ballisticsettings.fx.bullet", "cl_tfa_ballistics_fx_bullet")
	panel:CheckBox("#tfa.ballisticsettings.fx.hq", "cl_tfa_ballistics_fx_tracers_adv")
	panel:CheckBox("#tfa.ballisticsettings.fx.mp", "cl_tfa_ballistics_mp")
	panel:CheckBox("#tfa.ballisticsettings.fx.mptracer", "cl_tfa_ballistics_fx_tracers_mp")

	local tfaOptionTracerStyle = {
		Options = {},
		CVars = {"cl_tfa_ballistics_fx_tracers_style"},
		Label = "#tfa.ballisticsettings.tracer",
		MenuButton = "1",
		Folder = "TFASSBallTracerStyle"
	}

	tfaOptionTracerStyle.Options["#tfa.ballisticsettings.tracer.di"] = {
		["cl_tfa_ballistics_fx_tracers_style"] = 0
	}

	tfaOptionTracerStyle.Options["#tfa.ballisticsettings.tracer.sm"] = {
		["cl_tfa_ballistics_fx_tracers_style"] = 1
	}

	tfaOptionTracerStyle.Options["#tfa.ballisticsettings.tracer.re"] = {
		["cl_tfa_ballistics_fx_tracers_style"] = 2
	}

	panel:AddControl("ComboBox", tfaOptionTracerStyle)
end

local contributors = {
	"INCONCEIVABLE!",
	"Generic Default",
	"Clavus",
	"Nemole/Scotch",
	"Daniel Stevens",
	"code_gs",
	"Juckey",
	"RalphORama",
	"Iamgoofball",
	"Alexander Grist-Hucker",
	"Zombine",
	"FlorianLeChat",
	"Global",
	"TheAsian EggrollMaker",
	"Kris",
	"DaNike_"
}

local function tfaOptionAbout(panel)
	panel:Help("TFA Base")
	panel:Help(language.GetPhrase("tfa.about.version"):format(TFA_BASE_VERSION_STRING or TFA_BASE_VERSION))
	panel:Help(language.GetPhrase("tfa.about.author"):format("The Forgotten Architect"))
	panel:Help(language.GetPhrase("tfa.about.maintain"):format("YuRaNnNzZZ", "DBotThePony"))
	panel:Help(language.GetPhrase("tfa.about.contributors"):format(table.concat(contributors, ", ")))

	panel:Help("")

	panel:Help("#tfa.about.font")
	panel:Help("Inter by The Inter Project Authors")
	local fontBtn = panel:Button("https://github.com/rsms/inter")
	fontBtn.DoClick = function()
		gui.OpenURL("https://github.com/rsms/inter")
	end

	panel:Help("")

	panel:Help("#tfa.about.changelog.label")
	panel:Help(TFA_BASE_VERSION_CHANGES)
	local btnChangelog = panel:Button("#tfa.about.changelog.btn.github")
	btnChangelog.DoClick = function()
		gui.OpenURL("https://github.com/YuRaNnNzZZ/TFA-SWEP-Base-Documentation/blob/master/CHANGELOG.md")
	end
	local btnSteamChangeNotes = panel:Button("#tfa.about.changelog.btn.steam")
	btnSteamChangeNotes.DoClick = function()
		gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/changelog/2840031720")
	end
end

local function tfaOptionInspect(panel)
	local presetTable = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_inspect"
	}

	presetTable.Options["#preset.default"] = {
		cl_tfa_inspection_bokeh = "0",
		cl_tfa_inspection_bokeh_radius = "0.1",
		cl_tfa_inspect_hide = "0",
		cl_tfa_inspect_hide_hud = "0",
		cl_tfa_inspect_hide_in_screenshots = "0",
		cl_tfa_inspect_newbars = "0",
		cl_tfa_inspect_spreadinmoa = "0",
		cl_tfa_attachments_persist_enabled = "1"
	}

	presetTable.CVars = table.GetKeys(presetTable.Options["#preset.default"])
	panel:AddControl("ComboBox", presetTable)

	panel:CheckBox("#tfa.inspectsettings.inspectdof.enabled", "cl_tfa_inspection_bokeh")
	panel:NumSlider("#tfa.inspectsettings.inspectdof.radius", "cl_tfa_inspection_bokeh_radius", 0.01, 1, 3)

	panel:CheckBox("#tfa.inspectsettings.hide", "cl_tfa_inspect_hide")
	if DLib then
		panel:CheckBox("#tfa.inspectsettings.hidehud", "cl_tfa_inspect_hide_hud")
	end
	panel:CheckBox("#tfa.inspectsettings.hideinscreenshots", "cl_tfa_inspect_hide_in_screenshots")
	panel:CheckBox("#tfa.inspectsettings.newbars", "cl_tfa_inspect_newbars")
	panel:CheckBox("#tfa.inspectsettings.spreadinmoa", "cl_tfa_inspect_spreadinmoa")

	panel:Help("")
	panel:CheckBox("#tfa.attsettings.persist", "cl_tfa_attachments_persist_enabled")

	-- these two are not concommands by design
	local btnResetWep = panel:Button("#tfa.attsettings.resetsaved.current.btn")
	btnResetWep.DoClick = function()
		local ply = LocalPlayer()
		if not IsValid(ply) or not ply:Alive() then return end

		local wep = ply:GetActiveWeapon()
		if not IsValid(wep) or not wep.IsTFAWeapon then return end

		local class = wep:GetClass()
		Derma_Query("#tfa.attsettings.resetsaved.current.text", string.format(language.GetPhrase("tfa.attsettings.resetsaved.current.title"), wep:GetPrintName()), "#GameUI_Yes", function()
			sql.Query(string.format([[DELETE FROM tfa_savedattachments WHERE class = '%s']], sql.SQLStr(class, true)))
		end, "#GameUI_No", function() end)
	end

	local btnResetAll = panel:Button("#tfa.attsettings.resetsaved.all.btn")
	btnResetAll.DoClick = function()
		Derma_Query("#tfa.attsettings.resetsaved.all.text", "#tfa.attsettings.resetsaved.all.title", "#GameUI_Yes", function()
			sql.Query([[DELETE FROM tfa_savedattachments]])
		end, "#GameUI_No", function() end)
	end
end

local function tfaAddOption()
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "tfaOptionVM", "#tfa.smsettings.viewmodel", "", "", tfaOptionVM)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "tfaOptionSights", "#tfa.smsettings.sights", "", "", tfaOptionSights)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "tfaOptionPerformance", "#tfa.smsettings.perf", "", "", tfaOptionPerformance)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseCrosshair", "#tfa.smsettings.hud", "", "", tfaOptionHUD)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseDeveloper", "#tfa.smsettings.dev", "", "", tfaOptionDeveloper)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseColor", "#tfa.smsettings.color", "", "", tfaOptionColors)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseBallistics", "#tfa.smsettings.ballistics", "", "", tfaOptionBallistics)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseServer", "#tfa.smsettings.server", "", "", tfaOptionServer)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseAbout", "#tfa.smsettings.about", "", "", tfaOptionAbout)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseInspect", "#tfa.smsettings.inspect", "", "", tfaOptionInspect)
end

hook.Add("PopulateToolMenu", "tfaAddOption", tfaAddOption)

--PATH lua/autorun/venator_hdrenabler.lua:
return gluapack()()
--PATH lua/autorun/vj_files_language.lua:
/*--------------------------------------------------
	=============== Language Files ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
include('autorun/vj_controls.lua')

/*
	How it works:
		* Looks for the current set language and translates all the strings that are given.
		* If a string isn't translated, it will automatically default to English.
		* When a updated while in a map, it will try to refresh some of the menus, but many menus requires a map restart!
	
	How to edit & contribute:
		* Make any edits in any language you would like.
		* If a line doesn't exist in your language, then copy & paste it from the default (English) list.
		* Once you are done translating or editing, you can push the edited file on GitHub.
		* Once the file is pushed, I will review it and merge it with the base, it will then be included with the next update on Workshop.
		* NOTE: Over time more lines will be added in the default (English) list. You are welcome to check back whenever and copy & paste any new lines that added and translate it.
	
	Q: I would like to translate and my language isn't listed below =(
	A: No worries! Just simply contact me (DrVrej) and I will set up the profile for your language!
	
	Q: Someone has already translated my language, how can I contribute now?
	A: You can go over the translated lines and fix any errors. You can also compare it with the English version and make sure all lines are translated!
	
	Thank you to all of your contributions everyone!
*/

VJ.AddClientConVar("vj_language", "english", "The current VJ Base Language") -- The current VJ Base Language
VJ.AddClientConVar("vj_language_auto", 1, "Automatically Set Language")

if CLIENT then
	local function add(name, str) -- Aveli tirountsnelou hamar e
		language.Add(name, str)
	end
	
	local tblGModtoVJ = {
		["en"] = "english",
		["ru"] = "russian",
		["de"] = "german",
		["fr"] = "french",
		["lt"] = "lithuanian",
		["es-ES"] = "spanish_lt",
		["pt-BR"] = "portuguese_br",
		["zh-CN"] = "schinese"
	}
	
	function VJ_REFRESH_LANGUAGE()
		local conv = GetConVar("vj_language"):GetString()
		
		-- Automatically set VJ Base to whatever GMod's language is set to
			-- Based on: https://wiki.facepunch.com/gmod/Addon_Localization
			-- Skip if VJ Base is set to a language unsupported by Garry's Mod
		if GetConVar("vj_language_auto"):GetInt() == 1 && conv != "armenian" then
			local gmod_conv = GetConVar("gmod_language"):GetString()
			local converted = tblGModtoVJ[gmod_conv]
			if converted then
				RunConsoleCommand("vj_language", converted)
				conv = converted
			end
		end
		
		-- DEFAULT (English) LIST | Copy & paste any of the lines below to your preferred language to translate it.
		add("vjbase.menugeneral.default", "Default") -- DO NOT TRANSLATE. (Deprecated)
		// add("vjbase.general.print.runningvj", "Notice: This server is running VJ Base.") -- DO NOT TRANSLATE.
		
		-- Spawn Menu
		add("vjbase.spawn.menu.npc.disablethinking", "AI Disable Thinking")
		add("vjbase.spawn.menu.npc.ignoreplayers", "AI Ignore Players")
		add("vjbase.spawn.menu.npc.keepcorpses", "NPC Corpses Collide/Keep")
		add("vjbase.spawn.menu.npc.guard", "NPCs Spawn as Guards")
		
		-- General Menu (Used everywhere)
		add("vjbase.menu.general.default", "Default")
		add("vjbase.menu.general.admin.only", "Notice: Only admins can use this menu.")
		add("vjbase.menu.general.admin.not", "You are not a admin!")
		add("vjbase.menu.general.reset.everything", "Reset To Default")
		add("vjbase.menu.general.snpc.warnfuture", "WARNING: Only future spawned NPCs will be affected!")
		add("vjbase.menu.general.snpc.creaturesettings", "Creature Settings:")
		add("vjbase.menu.general.snpc.humansettings", "Human Settings:")
		
		-- Menu Tabs
		add("vjbase.menu.tabs.mainmenu", "Main Menu")
		add("vjbase.menu.tabs.settings.snpc", "SNPC Settings")
		add("vjbase.menu.tabs.settings.weapon", "Weapon Settings")
		add("vjbase.menu.tabs.settings.hud", "HUD Settings")
		add("vjbase.menu.tabs.tools", "Tools")
		add("vjbase.menu.tabs.configures.snpc", "SNPC Configures")
		
		-- Main Menu
		add("vjbase.menu.cleanup", "Clean Up")
		add("vjbase.menu.cleanup.all", "Clean Up Everything")
		add("vjbase.menu.cleanup.stopsounds", "Stop all Sounds")
		add("vjbase.menu.cleanup.remove.vjnpcs", "Remove all VJ NPCs")
		add("vjbase.menu.cleanup.remove.npcs", "Remove all NPCs")
		add("vjbase.menu.cleanup.remove.spawners", "Remove all Spawners")
		add("vjbase.menu.cleanup.remove.corpses", "Remove all Corpses")
		add("vjbase.menu.cleanup.remove.vjgibs", "Remove all VJ Gibs")
		add("vjbase.menu.cleanup.remove.groundweapons", "Remove all Ground Weapons")
		add("vjbase.menu.cleanup.remove.props", "Remove all Props")
		add("vjbase.menu.cleanup.remove.decals", "Remove all Decals")
		add("vjbase.menu.cleanup.remove.allweapons", "Remove all of your Weapons")
		add("vjbase.menu.cleanup.remove.allammo", "Remove all of your Ammo")
		
		add("vjbase.menu.helpsupport", "Contact and Support")
		add("vjbase.menu.helpsupport.incompatibleaddons", "Incompatible Addons")
		add("vjbase.menu.helpsupport.reportbug", "Report a Bug")
		add("vjbase.menu.helpsupport.suggestion", "Suggest Something")
		add("vjbase.menu.helpsupport.discord", "Join me on Discord!")
		add("vjbase.menu.helpsupport.steam", "Join me on Steam!")
		add("vjbase.menu.helpsupport.youtube", "Subscribe me on YouTube!")
		add("vjbase.menu.helpsupport.twitter", "Follow me on Twitter!")
		add("vjbase.menu.helpsupport.patreon", "Donate me on Patreon!")
		add("vjbase.menu.helpsupport.label1", "Follow one of these links to get updates about my addons!")
		add("vjbase.menu.helpsupport.label2", "Donations help and encourage me to continue making/updating addons! Thank you!")
		add("vjbase.menu.helpsupport.thanks", "Thanks for your support!")
		
		add("vjbase.menu.svsettings", "Admin Server Settings")
		add("vjbase.menu.svsettings.label", "WARNING: SOME SETTINGS NEED CHEATS ENABLED!")
		add("vjbase.menu.svsettings.admin.npcproperties", "Restrict NPC Properties to Admins Only")
		add("vjbase.menu.svsettings.noclip", "Allow NoClip")
		add("vjbase.menu.svsettings.weapons", "Allow Weapons")
		add("vjbase.menu.svsettings.pvp", "Allow PvP")
		add("vjbase.menu.svsettings.godmode", "God Mode (Everyone)")
		add("vjbase.menu.svsettings.bonemanip.npcs", "Bone Manipulate NPCs")
		add("vjbase.menu.svsettings.bonemanip.players", "Bone Manipulate Players")
		add("vjbase.menu.svsettings.bonemanip.others", "Bone Manipulate Others")
		add("vjbase.menu.svsettings.timescale.general", "General TimeScale")
		add("vjbase.menu.svsettings.timescale.physics", "Physics TimeScale")
		add("vjbase.menu.svsettings.gravity", "General Gravity")
		add("vjbase.menu.svsettings.maxentsprops", "Max Props/Entities:")
		
		add("vjbase.menu.clsettings", "Client Settings")
		add("vjbase.menu.clsettings.label", "Use this menu to customize your client settings, servers can't change these settings!")
		add("vjbase.menu.clsettings.labellang", "Language Selection...")
		add("vjbase.menu.clsettings.notify.lang", "VJ Base Language Set To:")
		add("vjbase.menu.clsettings.lang.auto", "Automatically Set Language")
		add("vjbase.menu.clsettings.lang.auto.label", "Ignored if VJ Base is set to a language unsupported by GMod")
		
		add("vjbase.menu.info", "Information")
		
		add("vjbase.menu.plugins", "Installed Plugins")
		add("vjbase.menu.plugins.label", "List of installed VJ Base plugins.")
		add("vjbase.menu.plugins.version", "Version:")
		add("vjbase.menu.plugins.totalplugins", "Total Plugins:")
		add("vjbase.menu.plugins.header1", "Name")
		add("vjbase.menu.plugins.header2", "Type")
		add("vjbase.menu.plugins.notfound", "No Plugins Found.")
		add("vjbase.menu.plugins.changelog", "Changelog")
		add("vjbase.menu.plugins.makeaddon", "Want to make an addon?")
		
		-- SNPC Menus
		add("vjbase.menu.snpc.options", "Options")
		add("vjbase.menu.snpc.options.difficulty.header", "Select the Difficulty:")
		add("vjbase.menu.snpc.options.difficulty.neanderthal", "[-3] Neanderthal | -99% Health and Damage")
		add("vjbase.menu.snpc.options.difficulty.childs_play", "[-2] Child's Play | -75% Health and Damage")
		add("vjbase.menu.snpc.options.difficulty.easy", "[-1] Easy | -50% Health and Damage")
		add("vjbase.menu.snpc.options.difficulty.normal", "[0] Normal | Original Health and Damage")
		add("vjbase.menu.snpc.options.difficulty.hard", "[1] Hard | +50% Health and Damage")
		add("vjbase.menu.snpc.options.difficulty.insane", "[2] Insane | +100% Health and Damage")
		add("vjbase.menu.snpc.options.difficulty.impossible", "[3] Impossible | +150% Health and Damage")
		add("vjbase.menu.snpc.options.difficulty.nightmare", "[4] Nightmare | +250% Health and Damage")
		add("vjbase.menu.snpc.options.difficulty.hell_on_earth", "[5] Hell On Earth | +350% Health and Damage")
		add("vjbase.menu.snpc.options.difficulty.total_annihilation", "[6] Total Annihilation | +500% Health and Damage")
		add("vjbase.menu.snpc.options.label1", "Relationship Options:")
		add("vjbase.menu.snpc.options.togglefriendlyantlion", "Antlion Friendly")
		add("vjbase.menu.snpc.options.togglefriendlycombine", "Combine Friendly")
		add("vjbase.menu.snpc.options.togglefriendlyplayer", "Player Friendly")
		add("vjbase.menu.snpc.options.togglefriendlyzombie", "Zombie Friendly")
		add("vjbase.menu.snpc.options.togglefriendlyvj", "VJ Base Friendly")
		add("vjbase.menu.snpc.options.label2", "All VJ NPCs will be allied!")
		add("vjbase.menu.snpc.options.label3", "Corpse, Dismemberment, & Health Options:")
		add("vjbase.menu.snpc.options.collision.header", "Corpse Collision:")
		add("vjbase.menu.snpc.options.collision.default", "Default | Excludes: Players, NPCs, Weapons, Ragdolls")
		add("vjbase.menu.snpc.options.collision.everything", "No exclusions | Everything!")
		add("vjbase.menu.snpc.options.collision.onlyworld", "Only World")
		add("vjbase.menu.snpc.options.collision.excludedebris", "Excludes: Corpses, Debris")
		add("vjbase.menu.snpc.options.collision.excludeplynpcs", "Excludes: Players, NPCs")
		add("vjbase.menu.snpc.options.collision.excludeply", "Excludes: Players")
		add("vjbase.menu.snpc.options.corpselimit", "Corpse Limit, Def:32")
		add("vjbase.menu.snpc.options.label4", "Corpse Limit when 'Keep Corpses' is off")
		add("vjbase.menu.snpc.options.toggleundocorpses", "Undoable Corpses (Undo Key)")
		add("vjbase.menu.snpc.options.togglecorpsefade", "Fade Corpses")
		add("vjbase.menu.snpc.options.corpsefadetime", "Corpse Fade Time")
		add("vjbase.menu.snpc.options.label5", "Total: 600 seconds (10 Minutes)")
		add("vjbase.menu.snpc.options.togglegibcollision", "Collidable Gibs")
		add("vjbase.menu.snpc.options.togglefadegibs", "Fade Gibs")
		add("vjbase.menu.snpc.options.gibfadetime", "Gib Fade Time")
		add("vjbase.menu.snpc.options.label6", "Default: 30 | Total: 600 seconds (10 Minutes)")
		add("vjbase.menu.snpc.options.togglesnpcgodmode", "God Mode (They won't take any damage)")
		add("vjbase.menu.snpc.options.health", "Health:")
		add("vjbase.menu.snpc.options.defaulthealth", "0 = Default Health (9 digits max!)")
		add("vjbase.menu.snpc.options.label7", "AI Options:")
		add("vjbase.menu.snpc.options.toggleknowenemylocation", "Always Know Enemy Location")
		add("vjbase.menu.snpc.options.sightdistance", "Sight Distance:")
		add("vjbase.menu.snpc.options.label8", "Each NPC has its own distance, but this will make them all the same, so use it cautiously! (0 = Original | Average: 10k)")
		add("vjbase.menu.snpc.options.processtime", "Process Time")
		add("vjbase.menu.snpc.options.whatisprocesstime", "What is Process Time?")
		add("vjbase.menu.snpc.options.label9", "Default: 1 | Lower number causes more lag!")
		add("vjbase.menu.snpc.options.label10", "Miscellaneous Options:")
		add("vjbase.menu.snpc.options.togglegmoddecals", "Use Garry's Mod's Current Blood Decals")
		add("vjbase.menu.snpc.options.label11", "Only for Yellow and Red colors!")
		add("vjbase.menu.snpc.options.toggleitemdrops", "Item Drops On Death")
		add("vjbase.menu.snpc.options.toggleaddfrags", "Add points to the player's scoreboard when killed")
		add("vjbase.menu.snpc.options.togglecreatureopendoor", "Creatures Can Open Doors")
		add("vjbase.menu.snpc.options.togglehumansdropweapon", "Humans Drop Weapon On Death")
		add("vjbase.menu.snpc.options.togglehumanscanjump", "Humans Can Jump")
		add("vjbase.menu.snpc.options.toggleplydroppedweapons", "Players Can Pick Up Dropped Weapons")
		
		add("vjbase.menu.snpc.settings", "Settings")
		add("vjbase.menu.snpc.settings.label1", "AI Settings:")
		add("vjbase.menu.snpc.settings.togglewandering", "Disable Wandering When Idle")
		add("vjbase.menu.snpc.settings.togglechasingenemy", "Disable Chasing Enemy")
		add("vjbase.menu.snpc.settings.label2", "WARNING: This can break parts of the AI!")
		add("vjbase.menu.snpc.settings.togglemedics", "Disable Medic NPCs")
		add("vjbase.menu.snpc.settings.togglefollowplayer", "Disable Following Player")
		add("vjbase.menu.snpc.settings.label3", "Example: When you press 'E' on a NPC and they follow you")
		add("vjbase.menu.snpc.settings.toggleallies", "Disable Alliance (No Allies!)")
		add("vjbase.menu.snpc.settings.togglebecomeenemytoply", "Disable Allies Becoming Enemy")
		add("vjbase.menu.snpc.settings.togglecallhelp", "Disable Calling for Help")
		add("vjbase.menu.snpc.settings.toggleproppush", "Disable Prop Pushing (Creatures)")
		add("vjbase.menu.snpc.settings.togglepropattack", "Disable Prop Attacking (Creatures)")
		add("vjbase.menu.snpc.settings.toggledangersight", "Disable Detecting Dangers & Grenades (Humans)")
		add("vjbase.menu.snpc.settings.togglereloading", "Disable Weapon Reloading")
		add("vjbase.menu.snpc.settings.toggleeating", "Disable Eating (EX: Corpses or gibs)")
		add("vjbase.menu.snpc.settings.label4", "Attack Settings:")
		add("vjbase.menu.snpc.settings.togglemelee", "Disable Melee Attacks")
		add("vjbase.menu.snpc.settings.togglerange", "Disable Range Attacks")
		add("vjbase.menu.snpc.settings.toggleleap", "Disable Leap Attacks (Creatures)")
		add("vjbase.menu.snpc.settings.togglethrownade", "Disable Grenade Attacks (Humans)")
		add("vjbase.menu.snpc.settings.toggleweapons", "Disable Weapons (Humans)")
		add("vjbase.menu.snpc.settings.label5", "Humans will not be able to use weapons!")
		add("vjbase.menu.snpc.settings.togglemeleedsp", "Disable DSP Effect On Heavy Melee Damages")
		add("vjbase.menu.snpc.settings.toggleslowplayer", "Disable Players Slowing Down on Melee Attack")
		add("vjbase.menu.snpc.settings.togglebleedonmelee", "Disable Players/NPCs Bleeding on Melee Attack")
		add("vjbase.menu.snpc.settings.label6", "Miscellaneous Settings:")
		add("vjbase.menu.snpc.settings.toggleidleparticles", "Disable Idle Particles and Effects")
		add("vjbase.menu.snpc.settings.label7", "Disabling this can help with performance")
		add("vjbase.menu.snpc.settings.togglesnpcchat", "Disable NPC Chat Prints")
		add("vjbase.menu.snpc.settings.label8", "For example: 'Scientist is now following you'")
		add("vjbase.menu.snpc.settings.label9", "Damage & Corpse Settings:")
		add("vjbase.menu.snpc.settings.toggleflinching", "Disable Flinching")
		add("vjbase.menu.snpc.settings.togglebleeding", "Disable Bleeding")
		add("vjbase.menu.snpc.settings.label10", "Disables blood particles, decals, pools etc.")
		add("vjbase.menu.snpc.settings.togglebloodpool", "Disable Blood Pools (On Death)")
		add("vjbase.menu.snpc.settings.togglegib", "Disable Gibbing")
		add("vjbase.menu.snpc.settings.label11", "Disabling this can help with performance")
		add("vjbase.menu.snpc.settings.togglegibdeathvfx", "Disable Gib/Death VFX (particles, decals, etc.)")
		add("vjbase.menu.snpc.settings.toggledeathanim", "Disable Death Animation")
		add("vjbase.menu.snpc.settings.togglecorpses", "Disable Corpses")
		add("vjbase.menu.snpc.settings.label12", "Passive Settings:")
		add("vjbase.menu.snpc.settings.togglerunontouch", "Disable Running on Touch")
		add("vjbase.menu.snpc.settings.togglerunonhit", "Disable Running on Damage")
		
		add("vjbase.menu.snpc.sdsettings", "Sound Settings")
		add("vjbase.menu.snpc.sdsettings.toggleallsounds", "Disable All Sounds")
		add("vjbase.menu.snpc.sdsettings.togglesoundtrack", "Disable Sound Tracks / Music")
		add("vjbase.menu.snpc.sdsettings.toggleidle", "Disable Idle Sounds")
		add("vjbase.menu.snpc.sdsettings.togglebreathing", "Disable Breathing Sounds")
		add("vjbase.menu.snpc.sdsettings.togglefootsteps", "Disable Footstep Sounds")
		add("vjbase.menu.snpc.sdsettings.toggleattacksounds", "Disable Melee Attack Sounds")
		add("vjbase.menu.snpc.sdsettings.togglemeleemiss", "Disable Melee Miss Sounds")
		add("vjbase.menu.snpc.sdsettings.togglerangeattack", "Disable Range Attack Sounds")
		add("vjbase.menu.snpc.sdsettings.togglealert", "Disable Alert Sounds")
		add("vjbase.menu.snpc.sdsettings.togglepain", "Disable Pain Sounds")
		add("vjbase.menu.snpc.sdsettings.toggledeath", "Disable Death Sounds")
		add("vjbase.menu.snpc.sdsettings.togglegibbing", "Disable Gibbing Sounds")
		add("vjbase.menu.snpc.sdsettings.label1", "Also applies to the sounds that play when a gib collides with something")
		add("vjbase.menu.snpc.sdsettings.togglemedic", "Disable Medic Sounds")
		add("vjbase.menu.snpc.sdsettings.togglefollowing", "Disable Following Sounds")
		add("vjbase.menu.snpc.sdsettings.togglecallhelp", "Disable Calling for Help Sounds")
		add("vjbase.menu.snpc.sdsettings.togglereceiveorder", "Disable Receiving Order Sounds")
		add("vjbase.menu.snpc.sdsettings.togglebecomeenemy", "Disable Become Enemy to Player Sounds")
		add("vjbase.menu.snpc.sdsettings.toggleplayersight", "Disable Player Sighting Sounds")
		add("vjbase.menu.snpc.sdsettings.label2", "Special sounds that play when an NPC sees a player")
		add("vjbase.menu.snpc.sdsettings.toggledmgbyplayer", "Disable Damage By Player Sounds")
		add("vjbase.menu.snpc.sdsettings.label3", "When a player shoots at an NPC, usually friendly NPCs")
		add("vjbase.menu.snpc.sdsettings.toggleleap", "Disable Leap Attack Sounds")
		add("vjbase.menu.snpc.sdsettings.toggleslowedplayer", "Disable Slowed Player Sounds")
		add("vjbase.menu.snpc.sdsettings.label4", "Sounds that play when the player is slowed down by melee attack")
		add("vjbase.menu.snpc.sdsettings.togglegrenade", "Disable Grenade Attack Sounds")
		add("vjbase.menu.snpc.sdsettings.toggledangersight", "Disable Grenade & Danger Sight Sounds")
		add("vjbase.menu.snpc.sdsettings.togglesuppressing", "Disable Suppressing Call Out Sounds")
		add("vjbase.menu.snpc.sdsettings.togglereload", "Disable Reload Call Out Sounds")
		
		add("vjbase.menu.snpc.devsettings", "Developer Settings")
		add("vjbase.menu.snpc.devsettings.label1", "These settings are used when developing SNPCs.")
		add("vjbase.menu.snpc.devsettings.label2", "WARNING: Some of these options cause lag!")
		add("vjbase.menu.snpc.devsettings.toggledev", "Enable Developer Mode?")
		add("vjbase.menu.snpc.devsettings.label3", "This option must be enabled from here or through the context menu! (Required for the options below)")
		add("vjbase.menu.snpc.devsettings.printtouch", "Print On Touch (Console)")
		add("vjbase.menu.snpc.devsettings.printcurenemy", "Print Current Enemy (Console)")
		add("vjbase.menu.snpc.devsettings.printlastseenenemy", "Print 'LastSeenEnemy' time (Chat)")
		add("vjbase.menu.snpc.devsettings.printonreset", "Print On Reset Enemy (Console)")
		add("vjbase.menu.snpc.devsettings.printonstopattack", "Print On Stopped Attacks (Console)")
		add("vjbase.menu.snpc.devsettings.printtakingcover", "Print Taking Cover (Console)")
		add("vjbase.menu.snpc.devsettings.printondamage", "Print On Damage (Console)")
		add("vjbase.menu.snpc.devsettings.printondeath", "Print On Death (Console)")
		add("vjbase.menu.snpc.devsettings.printweaponinfo", "Print Weapon Information (Console)")
		add("vjbase.menu.snpc.devsettings.cachedmodels", "Print Cached Models (Console)")
		add("vjbase.menu.snpc.devsettings.numofnpcs", "Print Number of NPCs (Chat)")
		add("vjbase.menu.snpc.devsettings.label4", "Reload Buttons:")
		add("vjbase.menu.snpc.devsettings.reloadsounds", "Reload Sounds")
		add("vjbase.menu.snpc.devsettings.reloadmaterials", "Reload Materials (VMTs)")
		add("vjbase.menu.snpc.devsettings.reloadtextures", "Reload Textures (VTFs)")
		add("vjbase.menu.snpc.devsettings.reloadmodels", "Reload Models")
		add("vjbase.menu.snpc.devsettings.reloadspawnmenu", "Reload Spawn Menu")
		
		add("vjbase.menu.snpc.consettings", "Controller Settings")
		add("vjbase.menu.snpc.consettings.label1", "Notice: These are client-side settings only!")
		add("vjbase.menu.snpc.consettings.label2", "How far or close the zoom changes every click.")
		add("vjbase.menu.snpc.consettings.displayhud", "Display HUD")
		add("vjbase.menu.snpc.consettings.camzoomdistance", "Camera Move Distance")
		add("vjbase.menu.snpc.consettings.camspeed", "Camera Speed")
		add("vjbase.menu.snpc.consettings.camzoomspeed", "Camera Zoom Speed" )
		add("vjbase.menu.snpc.consettings.diewithnpc", "Controller Dies With The NPC (Requires respawn!)")
		add("vjbase.menu.snpc.consettings.displaydev", "Display Developer Entities")
		add("vjbase.menu.snpc.consettings.label3", "Key Bindings:")
		add("vjbase.menu.snpc.consettings.bind.header1", "Control")
		add("vjbase.menu.snpc.consettings.bind.header2", "Description")
		add("vjbase.menu.snpc.consettings.bind.clickmsg1", "Selected Key:")
		add("vjbase.menu.snpc.consettings.bind.clickmsg2", "Description:")
		add("vjbase.menu.snpc.consettings.bind.movement", "Movement (Supports 8-Way)")
		add("vjbase.menu.snpc.consettings.bind.exitcontrol", "Exit the Controller")
		add("vjbase.menu.snpc.consettings.bind.meleeattack", "Melee Attack")
		add("vjbase.menu.snpc.consettings.bind.rangeattack", "Range / Weapon Attack")
		add("vjbase.menu.snpc.consettings.bind.leaporgrenade", "Leap / Grenade Attack")
		add("vjbase.menu.snpc.consettings.bind.reloadweapon", "Reload Weapon")
		add("vjbase.menu.snpc.consettings.bind.togglebullseye", "Toggle Bullseye Tracking")
		add("vjbase.menu.snpc.consettings.bind.cameramode", "Change Camera Mode")
		add("vjbase.menu.snpc.consettings.bind.movementjump", "Toggle Movement Jumping")
		add("vjbase.menu.snpc.consettings.bind.camerazoom", "Zoom In & Out")
		add("vjbase.menu.snpc.consettings.bind.cameraup", "Move Camera Up")
		add("vjbase.menu.snpc.consettings.bind.cameradown", "Move Camera Down")
		add("vjbase.menu.snpc.consettings.bind.cameraforward", "Move Camera Forward")
		add("vjbase.menu.snpc.consettings.bind.camerabackward", "Move Camera Backward")
		add("vjbase.menu.snpc.consettings.bind.cameraleft", "Move Camera Left")
		add("vjbase.menu.snpc.consettings.bind.cameraright", "Move Camera Right")
		add("vjbase.menu.snpc.consettings.bind.resetzoom", "Reset Camera Position")
		
		-- Weapon Client Settings
		add("vjbase.menu.clweapon", "Client Settings")
		add("vjbase.menu.clweapon.notice", "Notice: These settings are client, meaning it won't change for other people!")
		add("vjbase.menu.clweapon.togglemuzzle", "Disable Muzzle Flash")
		add("vjbase.menu.clweapon.togglemuzzlelight", "Disable Muzzle Flash Dynamic Light")
		add("vjbase.menu.clweapon.togglemuzzle.label", "Disabling muzzle flash will also disable this")
		add("vjbase.menu.clweapon.togglemuzzlebulletshells", "Disable Bullet Shells")
		
		-- NPC Properties (C Menu)
		add("vjbase.menuproperties.control", "TAKE CONTROL")
		add("vjbase.menuproperties.guard", "Toggle Guarding")
		add("vjbase.menuproperties.wander", "Toggle Wandering")
		add("vjbase.menuproperties.medic", "Make Medic (Toggle)")
		add("vjbase.menuproperties.allyme", "Ally To Me")
		add("vjbase.menuproperties.hostileme", "Hostile To Me")
		add("vjbase.menuproperties.slay", "Slay")
		add("vjbase.menuproperties.gib", "Gib (If Valid)")
		add("vjbase.menuproperties.devmode", "Toggle Developer Mode")
		add("vjbase.menuproperties.print.adminonly", "These options are restricted to Admin only!")
		
		-- Tools
		add("tool.vjstool.menu.tutorialvideo", "Tutorial Video")
		add("tool.vjstool.menu.label.recommendation", "Recommended to use this tool only for VJ Base SNPCs.")
		
		add("tool.vjstool_bullseye.name", "NPC Bullseye")
		add("tool.vjstool_bullseye.desc", "Creates a bullseye that NPCs will target")
		add("tool.vjstool_bullseye.left", "Create a bullseye")
		add("tool.vjstool_bullseye.menu.help1", "Press USE on the entity to activate/deactivate.")
		add("tool.vjstool_bullseye.menu.help2", "When deactivated, NPCs will no longer target it.")
		add("tool.vjstool_bullseye.menu.label1", "Select Movement Type")
		add("tool.vjstool_bullseye.menu.label2", "Model Directory")
		add("tool.vjstool_bullseye.menu.toggleusestatus", "Use Status Colors (Activated/Deactivated)")
		add("tool.vjstool_bullseye.menu.togglestartactivated", "Start Activated")
		
		add("tool.vjstool_entityscanner.name", "Entity Scanner")
		add("tool.vjstool_entityscanner.desc", "Get information about an entity")
		add("tool.vjstool_entityscanner.left", "Print information about the entity in console")
		add("tool.vjstool_entityscanner.label", "Prints information about any selected entity, it's printed in the console.")
		
		add("tool.vjstool_healthmodifier.name", "Health Modifier")
		add("tool.vjstool_healthmodifier.desc", "Modify the health of an entity")
		add("tool.vjstool_healthmodifier.left", "Set health")
		add("tool.vjstool_healthmodifier.right", "Set health & max health")
		add("tool.vjstool_healthmodifier.reload", "Heal the entity to its max health")
		add("tool.vjstool_healthmodifier.adminonly", "Only admins can modify or heal another player's health.")
		add("tool.vjstool_healthmodifier.sliderhealth", "Health")
		add("tool.vjstool_healthmodifier.label1", "Following are only for VJ Base SNPCs:")
		add("tool.vjstool_healthmodifier.togglegodmode", "God Mode (invincible)")
		add("tool.vjstool_healthmodifier.togglehealthregen", "Enable Health Regeneration")
		add("tool.vjstool_healthmodifier.sliderhealthregenamt", "Regeneration Amount")
		add("tool.vjstool_healthmodifier.sliderhealthregendelay", "Regeneration Delay")
		
		add("tool.vjstool_notarget.name", "No Target")
		add("tool.vjstool_notarget.desc", "Setting no target will make all NPCs not see a certain entity")
		add("tool.vjstool_notarget.left", "Toggle no target to yourself")
		add("tool.vjstool_notarget.right", "Toggle no target to an NPC or player")
		add("tool.vjstool_notarget.label", "When a no target is enabled on an entity, NPCs will not target it!")
		add("tool.vjstool_notarget.print.yourselfon", "Set no target to yourself: ON")
		add("tool.vjstool_notarget.print.yourselfoff", "Set no target to yourself: OFF")
		
		add("tool.vjstool_npcequipment.name", "NPC Equipment")
		add("tool.vjstool_npcequipment.desc", "Modifies an NPC's equipment")
		add("tool.vjstool_npcequipment.left", "Change the NPC's equipment")
		add("tool.vjstool_npcequipment.right", "Remove the NPC's equipment")
		add("tool.vjstool_npcequipment.label", "Changes or removes an NPC's equipment.")
		add("tool.vjstool_npcequipment.selectedequipment", "Selected Equipment")
		add("tool.vjstool_npcequipment.print.doubleclick", "Double click to select a weapon.")
		add("tool.vjstool_npcequipment.print.weaponselected1", "Weapon")
		add("tool.vjstool_npcequipment.print.weaponselected2", "selected!")
		add("tool.vjstool_npcequipment.header1", "Name")
		add("tool.vjstool_npcequipment.header2", "Class")
		
		add("tool.vjstool_npcmover.name", "NPC Mover")
		add("tool.vjstool_npcmover.desc", "Move NPC(s), an NPC must first be selected")
		add("tool.vjstool_npcmover.left", "Select an NPC")
		add("tool.vjstool_npcmover.right", "Run to the location")
		add("tool.vjstool_npcmover.reload", "Walk to the location")
		add("tool.vjstool_npcmover.header1", "Name")
		add("tool.vjstool_npcmover.header2", "Class")
		add("tool.vjstool_npcmover.header3", "Information")
		add("tool.vjstool_npcmover.buttonunselectall", "Unselect All NPCs")
		add("tool.vjstool_npcmover.print.unselectedall", "Unselected all NPCs!")
		add("tool.vjstool_npcmover.print.unselectedall.error", "Nothing to unselect!")
		
		add("tool.vjstool_npcrelationship.name", "NPC Relationship Modifier")
		add("tool.vjstool_npcrelationship.desc", "Modify the relationship of entities")
		add("tool.vjstool_npcrelationship.left", "Apply the relationship table")
		add("tool.vjstool_npcrelationship.right", "Obtain the current classes")
		add("tool.vjstool_npcrelationship.reload", "Apply the relationship table to yourself")
		add("tool.vjstool_npcrelationship.label1", "Modifies the relationship of an NPC, basically how it feels towards another entity.")
		add("tool.vjstool_npcrelationship.header", "Class")
		add("tool.vjstool_npcrelationship.label2", "Press return to add the class.")
		add("tool.vjstool_npcrelationship.button.combine", "Insert Combine Class")
		add("tool.vjstool_npcrelationship.button.antlion", "Insert Antlion Class")
		add("tool.vjstool_npcrelationship.button.zombie", "Insert Zombie Class")
		add("tool.vjstool_npcrelationship.button.player", "Insert Player Class")
		add("tool.vjstool_npcrelationship.togglealliedply", "Allied with all player allies?")
		add("tool.vjstool_npcrelationship.label3", "Only applies for VJ Base SNPCs and requires the SNPC to have")
		add("tool.vjstool_npcrelationship.print.applied", "Applied the relationship class table on")
		
		add("tool.vjstool_npcspawner.name", "NPC Spawner")
		add("tool.vjstool_npcspawner.desc", "Creates a customizable spawner")
		add("tool.vjstool_npcspawner.left", "Create a spawner")
		add("tool.vjstool_npcspawner.right", "Create the entities once")
		add("tool.vjstool_npcspawner.selectednpc", "Selected NPC")
		add("tool.vjstool_npcspawner.spawnpos.forward", "Position | Forward")
		add("tool.vjstool_npcspawner.spawnpos.right", "Position | Right")
		add("tool.vjstool_npcspawner.spawnpos.up", "Position | Up")
		add("tool.vjstool_npcspawner.selectweapon", "Selected Weapon")
		add("tool.vjstool_npcspawner.spawnnpclass", "Relation Class Override")
		add("tool.vjstool_npcspawner.fritoplyallies", "Friendly To Player Allies")
		add("tool.vjstool_npcspawner.label.fritoplyallies", "Must have relation class (CLASS_PLAYER_ALLY)!")
		add("tool.vjstool_npcspawner.button.updatelist", "Update List")
		add("tool.vjstool_npcspawner.label1", "Double click on an item to remove it.")
		add("tool.vjstool_npcspawner.header1", "Name")
		add("tool.vjstool_npcspawner.header2", "Position")
		add("tool.vjstool_npcspawner.header3", "Equipment")
		add("tool.vjstool_npcspawner.label2", "Extra Options")
		add("tool.vjstool_npcspawner.toggle.spawnsound", "Play NPC Spawning Sound?")
		add("tool.vjstool_npcspawner.nextspawntime", "Next Spawn Time")
		add("tool.vjstool_npcspawner.popup.header1", "Name")
		add("tool.vjstool_npcspawner.popup.header2", "Class")
		add("tool.vjstool_npcspawner.popup.header3", "Category")
		add("tool.vjstool_npcspawner.title1", "Double click to select an NPC.")
		add("tool.vjstool_npcspawner.title2", "Double click to select a weapon.")
		add("tool.vjstool_npcspawner.print.nothingspawn", "Nothing to spawn!")
		
		add("tool.vjstool_npcfollower.name", "NPC Follower")
		add("tool.vjstool_npcfollower.desc", "Select an NPC and make it follow an entity")
		add("tool.vjstool_npcfollower.left", "Select an NPC")
		add("tool.vjstool_npcfollower.right", "Make the selected NPC follow an entity")
		add("tool.vjstool_npcfollower.reload", "Unfollow any entity an NPC is following")
		add("tool.vjstool_npcfollower.print.noselection", "No NPC selected!")
		add("tool.vjstool_npcfollower.print.reset", "Unfollowed any entity it was following!")
		
		-- Miscellaneous (Prints)
		add("vjbase.print.bullseye.activated", "Activated NPC Bullseye.")
		add("vjbase.print.bullseye.deactivated", "Deactivated NPC Bullseye.")
		
		add("vjbase.print.npccontroller.entrance", "For controls, check \"Controller Settings\" under \"DrVrej\" tab")
		add("vjbase.print.npccontroller.tracking.activated", "Bullseye tracking activated!")
		add("vjbase.print.npccontroller.tracking.deactivated", "Bullseye tracking deactivated!")
		add("vjbase.print.npccontroller.movementjump.enable", "Movement Jumping enabled!")
		add("vjbase.print.npccontroller.movementjump.disable", "Movement Jumping disabled!")
		
		add("vjbase.print.adminhealth.pickup", "You have picked up 1,000,000 health!")
		
		add("vjbase.print.fireplace.activated", "You turned on the fireplace.")
		add("vjbase.print.fireplace.deactivated", "You turned off the fireplace.")
		
		add("vjbase.print.plyspawnpoint.activated", "Activated this spawnpoint!")
		add("vjbase.print.plyspawnpoint.deactivated", "Deactivated this spawnpoint!")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ ///// WARNING: Don't touch anything above this line! \\\\\ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		if conv == "armenian" then ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			
		elseif conv == "russian" then ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			-- Spawn Menu
		    add("vjbase.spawn.menu.npc.disablethinking", "Выключить ИИ")
	        add("vjbase.spawn.menu.npc.ignoreplayers", "ИИ игнорирует игроков")
		    add("vjbase.spawn.menu.npc.keepcorpses", "Оставлять/столкновения трупы(ов) NPC")
	        add("vjbase.spawn.menu.npc.guard", "Создавать NPC в качестве телохранителя")
			
			 -- General Menu (Used everywhere)
			add("vjbase.menu.general.default", "По умолчанию")
			add("vjbase.menu.general.admin.only", "Примечание: только администраторы могут использовать это меню.")
			add("vjbase.menu.general.admin.not", "Вы не являетесь администратором!")
			add("vjbase.menu.general.reset.everything", "Сбросить всё")
			add("vjbase.menu.general.snpc.warnfuture", "Предупреждение: будут затронуты только будущие созданные NPC!")
			add("vjbase.menu.general.snpc.creaturesettings", "Настройки создания:")
			add("vjbase.menu.general.snpc.humansettings", "Настройки людей:")
			
			-- Menu Tabs
			add("vjbase.menu.tabs.mainmenu", "Главное меню")
			add("vjbase.menu.tabs.settings.snpc", "Настройки SNPC")
			add("vjbase.menu.tabs.settings.weapon", "Настройки оружия")
			add("vjbase.menu.tabs.settings.hud", "Настройки интерфейса")
			add("vjbase.menu.tabs.tools", "Инструменты")
			add("vjbase.menu.tabs.configures.snpc", "Конфигурации SNPC")
		    add("vjbase.menu.tabs.default", "По молчанию")
			
			-- Main Menu
			add("vjbase.menu.cleanup", "Очистка")
			add("vjbase.menu.cleanup.all", "Очистить всё")
			add("vjbase.menu.cleanup.stopsounds", "Остановить все звуки")
			add("vjbase.menu.cleanup.remove.vjnpcs", "Убрать все VJ NPCs")
			add("vjbase.menu.cleanup.remove.npcs", "Убрать все NPCs")
			add("vjbase.menu.cleanup.remove.spawners", "Убрать все спавнеры")
			add("vjbase.menu.cleanup.remove.corpses", "Убрать все тела")
			add("vjbase.menu.cleanup.remove.vjgibs", "Убрать все VJ Gibs")
			add("vjbase.menu.cleanup.remove.groundweapons", "Убрать всё оружие на земле")
			add("vjbase.menu.cleanup.remove.props", "Убрать все объекты")
			add("vjbase.menu.cleanup.remove.decals", "Убрать все декали")
			add("vjbase.menu.cleanup.remove.allweapons", "Убрать всё своё оружие")
			add("vjbase.menu.cleanup.remove.allammo", "Убрать все свои боеприпасы")
			
			add("vjbase.menu.helpsupport", "Контакты и поддержка")
			add("vjbase.menu.helpsupport.incompatibleaddons", "Несовместимые дополнения")
			add("vjbase.menu.helpsupport.reportbug", "Сообщить о проблеме")
			add("vjbase.menu.helpsupport.suggestion", "Предложить что-нибудь")
			add("vjbase.menu.helpsupport.discord", "Discord создателя!")
			add("vjbase.menu.helpsupport.steam", "Steam создателя!")
			add("vjbase.menu.helpsupport.youtube", "Подписка на YouTube!")
			add("vjbase.menu.helpsupport.twitter", "Подписка на Твиттер!")
			add("vjbase.menu.helpsupport.patreon", "Поддержите меня на Patron!")
			add("vjbase.menu.helpsupport.label1", "Перейдите по одной из этих ссылок, чтобы получить информацию об обновлениях моих дополнений!")
			add("vjbase.menu.helpsupport.label2", "Пожертвования помогают и поощряют меня продолжать делать/обновлять дополнения! Спасибо!")
			add("vjbase.menu.helpsupport.thanks", "Спасибо за вашу поддержку!")
			
			add("vjbase.menu.svsettings", "Административные настройки")
			add("vjbase.menu.svsettings.label", "ВНИМАНИЕ: НЕКОТОРЫЕ НАСТРОЙКИ ЯВЛЯЮТСЯ ЧИТЕРСКИМИ!")
			add("vjbase.menu.svsettings.admin.npcproperties", "Свойства SNPC только для администраторов")
			add("vjbase.menu.svsettings.noclip", "Позволить режим полёта")
			add("vjbase.menu.svsettings.weapons", "Позволить оружие")
			add("vjbase.menu.svsettings.pvp", "Урон между игроками")
			add("vjbase.menu.svsettings.godmode", "Неуязвимость (у всех)")
			add("vjbase.menu.svsettings.bonemanip.npcs", "Манипулировать костями NPCs")
			add("vjbase.menu.svsettings.bonemanip.players", "Манипулировать костями моделей игроков")
			add("vjbase.menu.svsettings.bonemanip.others", "Манипулировать костями иных объектов")
			add("vjbase.menu.svsettings.timescale.general", "Общее время игры")
			add("vjbase.menu.svsettings.timescale.physics", "Физическое время игры")
			add("vjbase.menu.svsettings.gravity", "Общая гравитация")
			add("vjbase.menu.svsettings.maxentsprops", "Максимум объектов/энтити:")
			
			add("vjbase.menu.clsettings", "Настройки клиента")
			add("vjbase.menu.clsettings.label", "Используйте это меню для настройки параметров клиента, администраторы сервера не могут изменить эти параметры!")
			add("vjbase.menu.clsettings.labellang", "Выбор языка...")
			add("vjbase.menu.clsettings.notify.lang", "Язык VJ Base установлен на:")
			add("vjbase.menu.clsettings.lang.auto", "Автонастройка языка")
		    add("vjbase.menu.clsettings.lang.auto.label", "Игнорируется, если в VJ Base установлен на язык, не поддерживаемый игрой")
			
			add("vjbase.menu.info", "Информация")
			
			add("vjbase.menu.plugins", "Установленные плагины")
			add("vjbase.menu.plugins.label", "Список установленных плагинов VJ Base.")
			add("vjbase.menu.plugins.version", "Версия:")
			add("vjbase.menu.plugins.totalplugins", "Всего плагинов:")
			add("vjbase.menu.plugins.header1", "Название")
			add("vjbase.menu.plugins.header2", "Тип")
			add("vjbase.menu.plugins.notfound", "Плагины не найдены.")
			add("vjbase.menu.plugins.changelog", "Список изменений")
			add("vjbase.menu.plugins.makeaddon", "Хотите создать дополнение?")
			
			-- SNPC Menus
			add("vjbase.menu.snpc.options", "Опции")
			add("vjbase.menu.snpc.options.difficulty.header", "Сложность:")
			add("vjbase.menu.snpc.options.difficulty.neanderthal", "[-3] Неандерталец | -99% здоровья и урона")
			add("vjbase.menu.snpc.options.difficulty.childs_play", "[-2] Детская игра | -75% здоровья и урона")
			add("vjbase.menu.snpc.options.difficulty.easy", "[-1] Легко | -50% здоровья и урона")
			add("vjbase.menu.snpc.options.difficulty.normal", "[0] Нормально | стандартное здоровье и урон")
			add("vjbase.menu.snpc.options.difficulty.hard", "[1] Трудно | +50% здоровья и урона")
			add("vjbase.menu.snpc.options.difficulty.insane", "[2] Безумие | +100% здоровья и урона")
			add("vjbase.menu.snpc.options.difficulty.impossible", "[3] Невозможно | +150% здоровья и урона")
			add("vjbase.menu.snpc.options.difficulty.nightmare", "[4] Кошмар | +250% здоровья и урона")
			add("vjbase.menu.snpc.options.difficulty.hell_on_earth", "[5] Ад на Земле | +350% здоровья и урона")
			add("vjbase.menu.snpc.options.difficulty.total_annihilation", "[6] Полное уничтожение | +500% здоровья и урона")
			add("vjbase.menu.snpc.options.label1", "Настройки отношений:")
			add("vjbase.menu.snpc.options.togglefriendlyantlion", "Дружелюбные муравьиные львы")
			add("vjbase.menu.snpc.options.togglefriendlycombine", "Дружелюбные комбайны")
			add("vjbase.menu.snpc.options.togglefriendlyplayer", "Дружелюбные игроки")
			add("vjbase.menu.snpc.options.togglefriendlyzombie", "Дружелюбные зомби")
			add("vjbase.menu.snpc.options.togglefriendlyvj", "Дружелюбный VJ Base")
			add("vjbase.menu.snpc.options.label2", "Все NPC VJ будут союзниками!")
			add("vjbase.menu.snpc.options.label3", "Опции трупов, расчленения и здоровья:")
		    add("vjbase.menu.snpc.options.collision.header", "Столкн-ние трупов:")
		    add("vjbase.menu.snpc.options.collision.default", "По умолчанию | Исключение: игроки, NPC, оружие, рэгдоллы")
		    add("vjbase.menu.snpc.options.collision.everything", "Без исключений | Все!")
		    add("vjbase.menu.snpc.options.collision.onlyworld", "Только мир")
		    add("vjbase.menu.snpc.options.collision.excludedebris", "Исключение: Трупы, обломки")
		    add("vjbase.menu.snpc.options.collision.excludeplynpcs", "Исключение: Игроки, NPC")
		    add("vjbase.menu.snpc.options.collision.excludeply", "Исключение: Игроки")
			add("vjbase.menu.snpc.options.corpselimit", "Лимит трупов")
			add("vjbase.menu.snpc.options.label4", "Лимит трупов, когда \"Оставлять трупы\" выключено")
			add("vjbase.menu.snpc.options.toggleundocorpses", "Трупы можно отменить (клавиша undo)")
			add("vjbase.menu.snpc.options.togglecorpsefade", "Исчезновение трупов")
			add("vjbase.menu.snpc.options.corpsefadetime", "Время исчезновения")
			add("vjbase.menu.snpc.options.label5", "(Трупов) Итого: 600 секунд (10 минут)")
			add("vjbase.menu.snpc.options.togglegibcollision", "Столкновения ошмётков")
			add("vjbase.menu.snpc.options.togglefadegibs", "Исчезновение ошмётков")
			add("vjbase.menu.snpc.options.gibfadetime", "Время исчезновения")
			add("vjbase.menu.snpc.options.label6", "(Ошмётков) По умолчанию: 30 | всего: 600 секунд (10 минут)")
			add("vjbase.menu.snpc.options.togglesnpcgodmode", "Неуязвимость (Они не получат урона)")
			add("vjbase.menu.snpc.options.health", "Здоровье:")
			add("vjbase.menu.snpc.options.defaulthealth", "0 = Здоровье по умолчанию (максимум 9 цифр!)")
			add("vjbase.menu.snpc.options.label7", "Опции ИИ:")
			add("vjbase.menu.snpc.options.toggleknowenemylocation", "Всегда знать расположение врага")
			add("vjbase.menu.snpc.options.sightdistance", "Видимость:")
			add("vjbase.menu.snpc.options.label8", "У каждого NPC есть своя дистанция видимости, но это сделает их всех одинаковыми, так что используйте её осторожно! (0 = Оригинал | среднее значение: 10тыс.)")
			add("vjbase.menu.snpc.options.processtime", "Время процесса")
			add("vjbase.menu.snpc.options.whatisprocesstime", "Что такое \"Время процесса\"?")
			add("vjbase.menu.snpc.options.label9", "По умолчанию: 1 | меньшее число вызывает большую задержку игры!")
			add("vjbase.menu.snpc.options.label10", "Другие опции:")
			add("vjbase.menu.snpc.options.togglegmoddecals", "Текущие декали крови игры")
			add("vjbase.menu.snpc.options.label11", "Только для жёлтых или красных цветов!")
			add("vjbase.menu.snpc.options.toggleitemdrops", "Выпадение предметов при смерти")
			add("vjbase.menu.snpc.options.toggleaddfrags", "Прибавлять очки за убийство в таблицу счёта")
			add("vjbase.menu.snpc.options.togglecreatureopendoor", "Существа могут открывать двери")
			add("vjbase.menu.snpc.options.togglehumansdropweapon", "Люди бросают оружие при смерти")
			add("vjbase.menu.snpc.options.togglehumanscanjump", "Люди могут прыгать")
			add("vjbase.menu.snpc.options.toggleplydroppedweapons", "Игроки могут подбирать упавшее оружие")
			
			add("vjbase.menu.snpc.settings", "Настройки")
			add("vjbase.menu.snpc.settings.label1", "Настройки ИИ:")
			add("vjbase.menu.snpc.settings.togglewandering", "Отключить блуждание в режиме ожидания")
			add("vjbase.menu.snpc.settings.togglechasingenemy", "Отключить преследование врага")
			add("vjbase.menu.snpc.settings.label2", "ВНИМАНИЕ: Это может привести к поломке частей искусственного интеллекта!")
			add("vjbase.menu.snpc.settings.togglemedics", "Отключить медиков NPC")
			add("vjbase.menu.snpc.settings.togglefollowplayer", "Отключить следование за игроком")
			add("vjbase.menu.snpc.settings.label3", "Пример: когда вы нажимаете \"У\" на NPC, они следуют за вами")
			add("vjbase.menu.snpc.settings.toggleallies", "Отключить альянс (Без союзников!)")
			add("vjbase.menu.snpc.settings.togglebecomeenemytoply", "Отключить союзников, став врагом")
			add("vjbase.menu.snpc.settings.togglecallhelp", "Отключить вызов помощи")
			add("vjbase.menu.snpc.settings.toggleproppush", "Отключить толкание объектов (Существа)")
			add("vjbase.menu.snpc.settings.togglepropattack", "Отключить атаку объектов (Существа)")
			add("vjbase.menu.snpc.settings.toggledangersight", "Отключить обнаружение опасностей и гранат (Люди)")
			add("vjbase.menu.snpc.settings.togglereloading", "Отключить перезарядку оружия")
		    add("vjbase.menu.snpc.settings.toggleeating", "Отключить поедание (Например: трупы или ошмётки)")
			add("vjbase.menu.snpc.settings.label4", "Настройки атаки:")
			add("vjbase.menu.snpc.settings.togglemelee", "Выключить атаку в ближнем бою")
			add("vjbase.menu.snpc.settings.togglerange", "Выключить атаку в дальнем бою")
			add("vjbase.menu.snpc.settings.toggleleap", "Отключить атаку в прыжке (Существа)")
			add("vjbase.menu.snpc.settings.togglethrownade", "Отключить атаку гранатами (Люди)")
			add("vjbase.menu.snpc.settings.toggleweapons", "Отключить оружие (Люди)")
			add("vjbase.menu.snpc.settings.label5", "Люди не смогут использовать оружие!")
			add("vjbase.menu.snpc.settings.togglemeleedsp", "Эффект DSP от тяжёлых атак в ближнем бою")
			add("vjbase.menu.snpc.settings.toggleslowplayer", "Замедление игроков от атак в ближнем бою")
			add("vjbase.menu.snpc.settings.togglebleedonmelee", "Истекание кровью от атак в ближнем бою")
			add("vjbase.menu.snpc.settings.label6", "Прочие настройки:")
			add("vjbase.menu.snpc.settings.toggleidleparticles", "Отключить неработающие частицы и эффекты")
			add("vjbase.menu.snpc.settings.label7", "Отключение этого пункта может увеличить производительность")
			add("vjbase.menu.snpc.settings.togglesnpcchat", "Выключить сообщения NPC в чате")
			add("vjbase.menu.snpc.settings.label8", "Например: \"Учёный теперь следует за вами\".")
			add("vjbase.menu.snpc.settings.label9", "Настройки тел и урона:")
			add("vjbase.menu.snpc.settings.toggleflinching", "Отключить вздрагивание")
			add("vjbase.menu.snpc.settings.togglebleeding", "Отключить кровотечение")
			add("vjbase.menu.snpc.settings.label10", "Отключает частицы крови, декали, лужи и т.д.")
			add("vjbase.menu.snpc.settings.togglebloodpool", "Отключить лужи крови (при смерти)")
			add("vjbase.menu.snpc.settings.togglegib", "Отключить ошмётки")
			add("vjbase.menu.snpc.settings.label11", "Отключение этого может увеличить производительность")
			add("vjbase.menu.snpc.settings.togglegibdeathvfx", "Отключить эффекты ошмётков/смерти (частицы, декали и т.д.)")
			add("vjbase.menu.snpc.settings.toggledeathanim", "Выключить анимацию смерти")
			add("vjbase.menu.snpc.settings.togglecorpses", "Выключить тела")
			add("vjbase.menu.snpc.settings.label12", "Пассивные настройки:")
			add("vjbase.menu.snpc.settings.togglerunontouch", "Выключить избегание при касании")
			add("vjbase.menu.snpc.settings.togglerunonhit", "Избегание при получении урона")
			
			add("vjbase.menu.snpc.sdsettings", "Настройки звука")
			add("vjbase.menu.snpc.sdsettings.toggleallsounds", "Отключить все звуки")
			add("vjbase.menu.snpc.sdsettings.togglesoundtrack", "Отключить звуковые дорожки / музыку")
			add("vjbase.menu.snpc.sdsettings.toggleidle", "Отключить звуки повреждений")
			add("vjbase.menu.snpc.sdsettings.togglebreathing", "Отключить звуки дыхания")
			add("vjbase.menu.snpc.sdsettings.togglefootsteps", "Отключить звуки шагов")
			add("vjbase.menu.snpc.sdsettings.toggleattacksounds", "Отключить звуки атаки в ближнем бою")
			add("vjbase.menu.snpc.sdsettings.togglemeleemiss", "Отключить звуки промахов в ближнем бою")
			add("vjbase.menu.snpc.sdsettings.togglerangeattack", "Отключить звуки атак в дальнем бою")
			add("vjbase.menu.snpc.sdsettings.togglealert", "Отключить звуки оповещения")
			add("vjbase.menu.snpc.sdsettings.togglepain", "Отключить звуки боли")
			add("vjbase.menu.snpc.sdsettings.toggledeath", "Отключить звуки смерти")
			add("vjbase.menu.snpc.sdsettings.togglegibbing", "Отключить звуки ошмётков")
			add("vjbase.menu.snpc.sdsettings.label1", "Также относится к звукам, которые воспроизводятся, когда ошмётки сталкивается с чем-то")
			add("vjbase.menu.snpc.sdsettings.togglemedic", "Отключить звуки медицины")
			add("vjbase.menu.snpc.sdsettings.togglefollowing", "Отключить звуки следования")
			add("vjbase.menu.snpc.sdsettings.togglecallhelp", "Отключить звуки просьб о помощи")
			add("vjbase.menu.snpc.sdsettings.togglereceiveorder", "Отключить звуки получения приказов")
			add("vjbase.menu.snpc.sdsettings.togglebecomeenemy", "Отключить звуки становления врагом для игрока")
			add("vjbase.menu.snpc.sdsettings.toggleplayersight", "Отключить звуки прицеливания игрока")
			add("vjbase.menu.snpc.sdsettings.label2", "Специальные звуки, которые воспроизводятся, когда NPC видит игрока")
			add("vjbase.menu.snpc.sdsettings.toggledmgbyplayer", "Отключить звуки урона от игрока")
			add("vjbase.menu.snpc.sdsettings.label3", "Когда игрок стреляет в NPC, обычно дружественные NPC")
			add("vjbase.menu.snpc.sdsettings.toggleleap", "Отключить звуки атаки в прыжке")
			add("vjbase.menu.snpc.sdsettings.toggleslowedplayer", "Отключить звуки замедления игрока")
			add("vjbase.menu.snpc.sdsettings.label4", "Звуки, которые воспроизводятся, когда игрок замедляется в рукопашной атаке")
			add("vjbase.menu.snpc.sdsettings.togglegrenade", "Отключить звуки атаки гранатой")
			add("vjbase.menu.snpc.sdsettings.toggledangersight", "Отключить звуки обнаружения гранаты и опасности")
			add("vjbase.menu.snpc.sdsettings.togglesuppressing", "Отключить подавление звуков взрыва")
			add("vjbase.menu.snpc.sdsettings.togglereload", "Отключить перезагрузку звуков вызова")
			
			add("vjbase.menu.snpc.devsettings", "Настройки разработчика")
			add("vjbase.menu.snpc.devsettings.label1", "Эти настройки используются при разработке SNPC.")
			add("vjbase.menu.snpc.devsettings.label2", "Предупреждение: некоторые из этих опций вызывают задержку игры!")
			add("vjbase.menu.snpc.devsettings.toggledev", "Включить режим разработчика?")
			add("vjbase.menu.snpc.devsettings.label3", "Эта опция должна быть включена здесь или через контекстное меню! (Требуется для следующих опций)")
			add("vjbase.menu.snpc.devsettings.printtouch", "Вывод на табло (Консоль)")
			add("vjbase.menu.snpc.devsettings.printcurenemy", "Вывод текущего врага (Консоль)")
			add("vjbase.menu.snpc.devsettings.printlastseenenemy", "Вывод времени \"LastSeenEnemy\" (Чат)")
			add("vjbase.menu.snpc.devsettings.printonreset", "Вывод на сброс противника (Консоль)")
			add("vjbase.menu.snpc.devsettings.printonstopattack", "Вывод на остановку атаки (Консоль)")
			add("vjbase.menu.snpc.devsettings.printtakingcover", "Вывод укрытия (Консоль)")
			add("vjbase.menu.snpc.devsettings.printondamage", "Вывод о повреждениях (Консоль)")
			add("vjbase.menu.snpc.devsettings.printondeath", "Вывод о смерти (Консоль)")
			add("vjbase.menu.snpc.devsettings.printweaponinfo", "Вывод информации об оружии(Консоль)")
			add("vjbase.menu.snpc.devsettings.cachedmodels", "Вывод кэшированных моделей (Консоль)")
			add("vjbase.menu.snpc.devsettings.numofnpcs", "Вывод количества NPC (Чат)")
			add("vjbase.menu.snpc.devsettings.label4", "Перезагрузить кнопки:")
		    add("vjbase.menu.snpc.devsettings.reloadsounds", "Перезагрузить звуки")
		    add("vjbase.menu.snpc.devsettings.reloadmaterials", "Перезагрузить материалы (VMT)")
		    add("vjbase.menu.snpc.devsettings.reloadtextures", "Перезагрузить текстуры (VTF)")
		    add("vjbase.menu.snpc.devsettings.reloadmodels", "Перезагрузить модели")
		    add("vjbase.menu.snpc.devsettings.reloadspawnmenu", "Перезагрузить меню создания")
			
			add("vjbase.menu.snpc.consettings", "Настройки контроллера")
			add("vjbase.menu.snpc.consettings.label1", "Обратите внимание : это настройки только на стороне клиента!")
			add("vjbase.menu.snpc.consettings.label2", "Как далеко или близко масштаб изменяется с каждым щелчком мыши.")
			add("vjbase.menu.snpc.consettings.displayhud", "Отображать интерфейс")
			add("vjbase.menu.snpc.consettings.camzoomdistance", "Дист-ция приближения камеры")
			add("vjbase.menu.snpc.consettings.camspeed", "Скорость камеры")
		    add("vjbase.menu.snpc.consettings.camzoomspeed", "Скор-сть приближения камеры")
			add("vjbase.menu.snpc.consettings.diewithnpc", "Контроллер погибает вместе с NPC (После возрождения!)")
			add("vjbase.menu.snpc.consettings.displaydev", "Отображение энтити разработчика")
			add("vjbase.menu.snpc.consettings.label3", "Привязка клавиш:")
			add("vjbase.menu.snpc.consettings.bind.header1", "Контроль")
			add("vjbase.menu.snpc.consettings.bind.header2", "Описание")
			add("vjbase.menu.snpc.consettings.bind.clickmsg1", "Выбранная кнопка:")
			add("vjbase.menu.snpc.consettings.bind.clickmsg2", "Описание:")
			add("vjbase.menu.snpc.consettings.bind.movement", "Движение")
			add("vjbase.menu.snpc.consettings.bind.exitcontrol", "Выход из контроллера")
			add("vjbase.menu.snpc.consettings.bind.meleeattack", "Атака в ближнем бою")
			add("vjbase.menu.snpc.consettings.bind.rangeattack", "Атака в дальнем бою")
			add("vjbase.menu.snpc.consettings.bind.leaporgrenade", "Прыжок/атака гранатой")
			add("vjbase.menu.snpc.consettings.bind.reloadweapon", "Перезарядка")
			add("vjbase.menu.snpc.consettings.bind.togglebullseye", "Отслеж-ние зоны прицеливания")
			add("vjbase.menu.snpc.consettings.bind.cameramode", "Сменить режим камеры")
			add("vjbase.menu.snpc.consettings.bind.movementjump", "Переключение прыжка во время движения")
		    add("vjbase.menu.snpc.consettings.bind.camerazoom", "Приблизить и отдалить")
			add("vjbase.menu.snpc.consettings.bind.cameraup", "Сдвинуть камеру вверх")
			add("vjbase.menu.snpc.consettings.bind.cameradown", "Сдвинуть камеру вниз")
			add("vjbase.menu.snpc.consettings.bind.cameraforward", "Сдвинуть камеру вперёд")
			add("vjbase.menu.snpc.consettings.bind.camerabackward", "Сдвинуть камеру назад")
			add("vjbase.menu.snpc.consettings.bind.cameraleft", "Сдвинуть камеру влево")
			add("vjbase.menu.snpc.consettings.bind.cameraright", "Сдвинуть камеру вправо")
			add("vjbase.menu.snpc.consettings.bind.resetzoom", "Сбросить позицию камеры")
			
			-- Weapon Client Settings
			add("vjbase.menu.clweapon", "Настройки клиента")
			add("vjbase.menu.clweapon.notice", "Обратите внимание : эти настройки являются клиентскими, то есть они не изменятся для других людей!")
			add("vjbase.menu.clweapon.togglemuzzle", "Отключить дульную вспышку")
			add("vjbase.menu.clweapon.togglemuzzlelight", "Отключить динамический свет дульной вспышки")
			add("vjbase.menu.clweapon.togglemuzzle.label", "Отключение дульной вспышки также отключит это")
			add("vjbase.menu.clweapon.togglemuzzlebulletshells", "Отключить дымку от выстрелов")
			
			-- NPC Properties (C Menu)
			add("vjbase.menuproperties.control", "Взять под контроль")
			add("vjbase.menuproperties.guard", "Назначить телохранителем")
			add("vjbase.menuproperties.wander", "Назначить патрульным")
			add("vjbase.menuproperties.medic", "Назначить медиком")
			add("vjbase.menuproperties.allyme", "Назначить союзником")
			add("vjbase.menuproperties.hostileme", "Назначить противником")
			add("vjbase.menuproperties.slay", "Убить")
			add("vjbase.menuproperties.gib", "Разорвать в ошмётки (Если допустимо)")
			add("vjbase.menuproperties.devmode", "Переключить на режим разработчика")
			add("vjbase.menuproperties.print.adminonly", "Эти опции доступны только администратору!")
			
			-- Tools
			add("tool.vjstool.menu.tutorialvideo", "Обучающее видео")
			add("tool.vjstool.menu.label.recommendation", "Рекомендуется использовать этот инструмент только для VJ Base SNPC.")
			
			add("tool.vjstool_bullseye.name", "Зона прицеливания NPC")
			add("tool.vjstool_bullseye.desc", "Создает зону прицеливания, куда будут целиться NPC")
			add("tool.vjstool_bullseye.left", "ЛКМ для создания зоны прицеливания")
			add("tool.vjstool_bullseye.menu.help1", "Нажмите ИСПОЛЬЗОВАТЬ, чтобы активировать/деактивировать.")
			add("tool.vjstool_bullseye.menu.help2", "Когда она деактивирована, NPC больше не будет нацеливаться в неё.")
			add("tool.vjstool_bullseye.menu.label1", "Выбрать тип движения")
			add("tool.vjstool_bullseye.menu.label2", "Каталог моделей")
			add("tool.vjstool_bullseye.menu.toggleusestatus", "Цвета состояния (активирована/деактивирована)")
			add("tool.vjstool_bullseye.menu.togglestartactivated", "Создать \"Активированной\"")
			
			add("tool.vjstool_entityscanner.name", "Сканер энтити")
			add("tool.vjstool_entityscanner.desc", "Получить информацию про энтити")
			add("tool.vjstool_entityscanner.left", "Щёлкните левой кнопкой мыши, чтобы вывести информацию об энтити в консоли")
			add("tool.vjstool_entityscanner.label", "Выводит информацию о любом выбранном объекте, она выводится в консоли.")
			
			add("tool.vjstool_healthmodifier.name", "Модификатор здоровья")
			add("tool.vjstool_healthmodifier.desc", "Изменение здоровья объекта")
			add("tool.vjstool_healthmodifier.left", "Щёлкните левой кнопкой мыши, чтобы установить показатель здоровья")
			add("tool.vjstool_healthmodifier.right", "Щёлкните правой кнопкой мыши, чтобы установить здоровье и максимальное здоровье")
			add("tool.vjstool_healthmodifier.reload", "Клавиша перезарядки для исцеления сущности до её максимального здоровья")
			add("tool.vjstool_healthmodifier.adminonly", "Только администраторы могут изменять или лечить здоровье другого игрока.")
			add("tool.vjstool_healthmodifier.sliderhealth", "Здоровье")
			add("tool.vjstool_healthmodifier.label1", "Следующие пункты предназначены только для VJ Base SNPC:")
			add("tool.vjstool_healthmodifier.togglegodmode", "Неуязвимость (Непобедимый)")
	        add("tool.vjstool_healthmodifier.togglehealthregen", "Включить регенерацию здоровья")
	        add("tool.vjstool_healthmodifier.sliderhealthregenamt", "Здоровья при реген.")
	    	add("tool.vjstool_healthmodifier.sliderhealthregendelay", "Задержка реген.")
			
			add("tool.vjstool_notarget.name", "Режим \"Вне цели\"")
			add("tool.vjstool_notarget.desc", "Режим \"Вне цели\" приведёт к тому, что все NPC не увидят определенного игрока или NPC")
			add("tool.vjstool_notarget.left", "Щёлкните левой кнопкой мыши, чтобы переключить режим \"Вне цели\" для себя")
			add("tool.vjstool_notarget.right", "Щёлкните правой кнопкой мыши, чтобы переключить режим \"Вне цели\" на текущего игрока или NPC")
			add("tool.vjstool_notarget.label", "Если на объекте включена функция \"Вне цели\", то NPC не будут её атаковать!")
			add("tool.vjstool_notarget.print.yourselfon", "Включено игнорирование NPC для себя")
			add("tool.vjstool_notarget.print.yourselfoff", "Отключено игнорирование NPC для себя")
			
			add("tool.vjstool_npcequipment.name", "Снаряжение NPC")
			add("tool.vjstool_npcequipment.desc", "Меняет снаряжение NPC")
			add("tool.vjstool_npcequipment.left", "Щёлкните левой кнопкой мыши, чтобы изменить снаряжение NPC")
			add("tool.vjstool_npcequipment.right", "Щёлкните правой кнопкой мыши, чтобы удалить снаряжение NPC")
			add("tool.vjstool_npcequipment.label", "Изменить или удалить снаряжение NPC.")
			add("tool.vjstool_npcequipment.selectedequipment", "Выбрать снаряжение")
			add("tool.vjstool_npcequipment.print.doubleclick", "Двойной клик для выбора оружия.")
			add("tool.vjstool_npcequipment.print.weaponselected1", "Оружие")
			add("tool.vjstool_npcequipment.print.weaponselected2", "выбрано!")
			add("tool.vjstool_npcequipment.header1", "Название")
			add("tool.vjstool_npcequipment.header2", "Классификация")
			
			add("tool.vjstool_npcmover.name", "Управление движением NPC")
			add("tool.vjstool_npcmover.desc", "Передвижение NPC или группы NPC")
			add("tool.vjstool_npcmover.left", "Щёлкните левой кнопкой мыши, чтобы выбрать")
			add("tool.vjstool_npcmover.right", "Щёлкните правой кнопкой мыши, чтобы переместить(бегом)")
			add("tool.vjstool_npcmover.reload", "Щёлкните кнопку перезарядки, чтобы переместить(шагом)")
			add("tool.vjstool_npcmover.header1", "Имя")
			add("tool.vjstool_npcmover.header2", "Классификация")
			add("tool.vjstool_npcmover.header3", "Информация")
			add("tool.vjstool_npcmover.buttonunselectall", "Отменить выбор всех NPC")
			add("tool.vjstool_npcmover.print.unselectedall", "Выбор всех NPC отменён!")
			add("tool.vjstool_npcmover.print.unselectedall.error", "Ничего не нужно снимать (нечего)!")
			
			add("tool.vjstool_npcrelationship.name", "Модификатор отношений NPC")
			add("tool.vjstool_npcrelationship.desc", "Изменить отношения NPC")
			add("tool.vjstool_npcrelationship.left", "Щёлкните левой кнопкой мыши, чтобы применить отношение")
			add("tool.vjstool_npcrelationship.right", "Щёлкните правой кнопкой мыши, чтобы получить текущие классы")
			add("tool.vjstool_npcrelationship.reload", "Нажмите Перезарядку, чтобы применить к себе")
			add("tool.vjstool_npcrelationship.label1", "Изменяет отношение NPC, в основном то, как он чувствует себя по отношению к другому объекту.")
			add("tool.vjstool_npcrelationship.header", "Класс")
			add("tool.vjstool_npcrelationship.label2", "Нажмите кнопку Return, чтобы добавить класс.")
			add("tool.vjstool_npcrelationship.button.combine", "Вставить класс: Комбайн")
			add("tool.vjstool_npcrelationship.button.antlion", "Вставить класс: Муравьиный лев")
			add("tool.vjstool_npcrelationship.button.zombie", "Вставить класс: Зомби")
			add("tool.vjstool_npcrelationship.button.player", "Вставить класс: Игрок")
			add("tool.vjstool_npcrelationship.togglealliedply", "Союз со всеми союзниками игроков?")
			add("tool.vjstool_npcrelationship.label3", "Применяется только для VJ Base SNPC и требуется, чтобы SNPC имелся")
			add("tool.vjstool_npcrelationship.print.applied", "Применить таблицу классов отношений на")
			
			add("tool.vjstool_npcspawner.name", "Спавнер (создатель) NPC")
			add("tool.vjstool_npcspawner.desc", "Создать спавнер")
			add("tool.vjstool_npcspawner.left", "Щёлкните левой кнопкой мыши, чтобы создать спавнер")
			add("tool.vjstool_npcspawner.right", "Щёлкните правой кнопкой мыши, чтобы создать NPC один раз")
			add("tool.vjstool_npcspawner.selectednpc", "Выбранный NPC")
			add("tool.vjstool_npcspawner.spawnpos.forward", "Позиция | Вперёд")
			add("tool.vjstool_npcspawner.spawnpos.right", "Позиция | Вправо")
			add("tool.vjstool_npcspawner.spawnpos.up", "Позиция | Вверх")
			add("tool.vjstool_npcspawner.selectweapon", "Выбранное оружие")
			add("tool.vjstool_npcspawner.spawnnpclass", "Переопределение класса отношений")
		    add("tool.vjstool_npcspawner.fritoplyallies", "Дружественные к игроку союзники")
		    add("tool.vjstool_npcspawner.label.fritoplyallies", "Обязательно наличие класса отношений (CLASS_PLAYER_ALLY)!")
			add("tool.vjstool_npcspawner.button.updatelist", "Обновить список")
			add("tool.vjstool_npcspawner.label1", "Дважды щёлкните, чтобы удалить элемент.")
			add("tool.vjstool_npcspawner.header1", "Имя")
			add("tool.vjstool_npcspawner.header2", "Позиция")
			add("tool.vjstool_npcspawner.header3", "Снаряжение")
			add("tool.vjstool_npcspawner.label2", "Дополнительные опции")
			add("tool.vjstool_npcspawner.toggle.spawnsound", "Проигрывать звук появления NPC?")
			add("tool.vjstool_npcspawner.nextspawntime", "Время появления")
			add("tool.vjstool_npcspawner.popup.header1", "Название")
			add("tool.vjstool_npcspawner.popup.header2", "Класс")
			add("tool.vjstool_npcspawner.popup.header3", "Категория")
			add("tool.vjstool_npcspawner.title1", "Дважды щёлкните, чтобы выбрать NPC.")
			add("tool.vjstool_npcspawner.title2", "Дважды щёлкните, чтобы выбрать оружие.")
		    add("tool.vjstool_npcspawner.print.nothingspawn", "Нечего создать!")
			
		    add("tool.vjstool_npcfollower.name", "Следующий за объектом NPC")
	     	add("tool.vjstool_npcfollower.desc", "Выберите NPC и заставьте его следовать за объектом")
	     	add("tool.vjstool_npcfollower.left", "Выбрать NPC")
	    	add("tool.vjstool_npcfollower.right", "Заставить выбранного NPC следовать за объектом")
	    	add("tool.vjstool_npcfollower.reload", "Снять с следования любой объект, за которым следует NPC")
			add("tool.vjstool_npcfollower.print.noselection", "NPC не выбран!")
		    add("tool.vjstool_npcfollower.print.reset", "Снято следование за объектом, за которым тот следовал!")
		
		    add("entity.vjfeature.admin_health_kit_message", "Вы подобрали 1,000,000 единиц здоровья!")
			add("entity.vjfeature.fireplace_turnedon", "Вы разожгли костёр.")
		    add("entity.vjfeature.fireplace_turnedoff", "Вы потушили костёр.")
	        add("entity.vjfeature.player_spawnpoint_activated", "Точка возрождения активирована!")
	        add("entity.vjfeature.player_spawnpoint_deactivated", "Точка возрождения деактивирована!")
			
			-- Miscellaneous (Prints)
			add("vjbase.print.bullseye.activated", "Активирована зона прицеливания NPC.")
			add("vjbase.print.bullseye.deactivated", "Деактивирована зона прицеливания NPC.")
			
			add("vjbase.print.npccontroller.entrance", "Для управления проверьте \"Настройки контроллера\" в вкладке \"DrVrej\"")
			add("vjbase.print.npccontroller.tracking.activated", "Активировано отслеживание зоны прицеливания!")
			add("vjbase.print.npccontroller.tracking.deactivated", "Деактивировано отслеживание зоны прицеливания!")
		    add("vjbase.print.npccontroller.movementjump.enable", "Прыжки во время движения включены!")
		    add("vjbase.print.npccontroller.movementjump.disable", "Прыжки во время движения отключены!")
			
			add("vjbase.print.adminhealth.pickup", "Вы подобрали 1,000,000 единиц здоровья!")
		
			add("vjbase.print.fireplace.activated", "Вы разожгли костёр.")
			add("vjbase.print.fireplace.deactivated", "Вы потушили костёр.")
			
			add("vjbase.print.plyspawnpoint.activated", "Точка возрождения активирована!")
			add("vjbase.print.plyspawnpoint.deactivated", "Точка возрождения деактивирована!")
		elseif conv == "german" then ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			
		elseif conv == "french" then ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			
		elseif conv == "lithuanian" then ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			-- General Menu (Used everywhere)
			add("vjbase.menu.general.default", "Numatytas")
			add("vjbase.menu.general.admin.only", "Dėmesio: tik administratoriai gali naudotis šiuo meniu.")
			add("vjbase.menu.general.admin.not", "Jūs neesate administratorius!")
			add("vjbase.menu.general.reset.everything", "Nustatyti į numatytuosius nustatymus")
			add("vjbase.menu.general.snpc.warnfuture", "DĖMESIO: paveikti bus tik vėliau atspawn'inti veikėjai!")
			add("vjbase.menu.general.snpc.creaturesettings", "Būtybių nustatymai:")
			add("vjbase.menu.general.snpc.humansettings", "Žmonių nustatymai")
			-- Menu Tabs
			add("vjbase.menu.tabs.mainmenu", "Pagrindinis meniu")
			add("vjbase.menu.tabs.settings.snpc", "Kompiuterinių veikėjų nustatymai")
			add("vjbase.menu.tabs.settings.weapon", "Ginklų nustatymai")
			add("vjbase.menu.tabs.settings.hud", "HUD nustatymai")
			add("vjbase.menu.tabs.tools", "Įrankiai")
			add("vjbase.menu.tabs.configures.snpc", "Veikėjų konfiguracija")
			
			-- Main Menu
			add("vjbase.menu.cleanup", "Išvalyti")
			add("vjbase.menu.cleanup.all", "Išvalyti viską")
			add("vjbase.menu.cleanup.stopsounds", "Sustabdyti visus garsus")
			add("vjbase.menu.cleanup.remove.vjnpcs", "Pašalinti tik „VJ“ kompiuterinius veikėjus")
			add("vjbase.menu.cleanup.remove.npcs", "Pašalinti visus kompiuterinius veikėjus")
			add("vjbase.menu.cleanup.remove.spawners", "Pašalinti spawner'ius")
			add("vjbase.menu.cleanup.remove.corpses", "Pašalinti visus lavonus")
			add("vjbase.menu.cleanup.remove.vjgibs", "Pašalinti ištaškytus vidaus organus")
			add("vjbase.menu.cleanup.remove.groundweapons", "Pašalinti visus gulinčius ginklus")
			add("vjbase.menu.cleanup.remove.props", "Pašalinti visus daiktus")
			add("vjbase.menu.cleanup.remove.decals", "Pašalinti aplinkos teršalus")
			add("vjbase.menu.cleanup.remove.allweapons", "Pašalinti visus savo ginklus")
			add("vjbase.menu.cleanup.remove.allammo", "Pašalinti visą savo amuniciją")
			
			add("vjbase.menu.helpsupport", "Kontaktai ir pagalba")
			add("vjbase.menu.helpsupport.reportbug", "Pranešti apie klaidas")
			add("vjbase.menu.helpsupport.suggestion", "Pasiūlyti ką nors")
			add("vjbase.menu.helpsupport.discord", "Prisijunkite prie mano Discord!")
			add("vjbase.menu.helpsupport.steam", "Prisijunkite prie mano Steam grupės!")
			add("vjbase.menu.helpsupport.youtube", "Prenumeruokite mane ant YouTube!")
			add("vjbase.menu.helpsupport.twitter", "Sekite mane ant Twitter!")
			add("vjbase.menu.helpsupport.patreon", "Aukokite mano Patreon!")
			add("vjbase.menu.helpsupport.label1", "Spūstelėkite vienas iš šių nuorodų, kad žinotumėte apie mano priedų atnaujinimus!")
			add("vjbase.menu.helpsupport.label2", "Aukos padeda ir skatina mane tęsti kurti/naujinti priedus! Ačiū!")
			add("vjbase.menu.helpsupport.thanks", "Ačiū už Jūsų palaikymą!")
			
			add("vjbase.menu.svsettings", "Administraciniai serverio nustatymai")
			add("vjbase.menu.svsettings.label", "DĖMESIO: KAI KURIEM NUSTATYMAM REIKALINGAS SV_CHEATS 1!")
			add("vjbase.menu.svsettings.admin.npcproperties", "Apriboti kompiuterinių veikėjų savybių keitimą tik administratoriams")
			add("vjbase.menu.svsettings.noclip", "Leisti NoClip'ą")
			add("vjbase.menu.svsettings.weapons", "Leisti ginklus")
			add("vjbase.menu.svsettings.pvp", "Leisti PvP")
			add("vjbase.menu.svsettings.godmode", "Nemirtingumas (visiem)")
			add("vjbase.menu.svsettings.bonemanip.npcs", "Veikėjų kaulų manipuliacija")
			add("vjbase.menu.svsettings.bonemanip.players", "Žaidėjų kaulų manipuliacija")
			add("vjbase.menu.svsettings.bonemanip.others", "Kitų kaulų manipuliacija")
			add("vjbase.menu.svsettings.timescale.general", "Bendroji laiko skalė")
			add("vjbase.menu.svsettings.timescale.physics", "Fizikinė laiko skalė")
			add("vjbase.menu.svsettings.gravity", "Bendra gravitacija")
			add("vjbase.menu.svsettings.maxentsprops", "Maksimalus daiktų/objektų skaičius:")
			
			add("vjbase.menu.clsettings", "Klientų nustatymai")
			add("vjbase.menu.clsettings.label", "Naudokites šiuo meniu, kad nustatytumet savo nustatymus. Serveriai jų pakeisti negali.")
			add("vjbase.menu.clsettings.labellang", "Kalbos pasirinkimas...")
			add("vjbase.menu.clsettings.notify.lang", "„VJ Base“ kalba nustatyta į:")
			
			add("vjbase.menu.info", "Informacija")
			
			add("vjbase.menu.plugins", "Instaliuoti priedai")
			add("vjbase.menu.plugins.label", "Instaliuotų „VJ Base“ priedų sąrašas")
			add("vjbase.menu.plugins.version", "Versija:")
			add("vjbase.menu.plugins.totalplugins", "Priedų skaičius:")
			add("vjbase.menu.plugins.header1", "Pavadinimas")
			add("vjbase.menu.plugins.header2", "Tipas")
			add("vjbase.menu.plugins.notfound", "Nerasta jokių priedų.")
			add("vjbase.menu.plugins.changelog", "Pakeitimų sąrašas")
			add("vjbase.menu.plugins.makeaddon", "Norite sukurti priedą?")
			
			-- SNPC Menus
			add("vjbase.menu.snpc.options", "Pasirenkami parametrai")
			add("vjbase.menu.snpc.options.difficulty.header", "Pasirinkite sunkumą:")
			add("vjbase.menu.snpc.options.difficulty.neanderthal", "[-3] Neandertaliečių | -99% sveikatos ir žalos")
			add("vjbase.menu.snpc.options.difficulty.childs_play", "[-2] Vaikų žaidimas | -75% sveikatos ir žalos")
			add("vjbase.menu.snpc.options.difficulty.easy", "[-1] Lengvas | -50% sveikatos ir žalos")
			add("vjbase.menu.snpc.options.difficulty.normal", "[0] Numatytas | Originali sveikata ir žala")
			add("vjbase.menu.snpc.options.difficulty.hard", "[1] Sunkus | +50% sveikatos ir žalos")
			add("vjbase.menu.snpc.options.difficulty.insane", "[2] Beprotiškas | +100% sveikatos ir žalos")
			add("vjbase.menu.snpc.options.difficulty.impossible", "[3] Neįmanomas | +150% sveikatos ir žalos")
			add("vjbase.menu.snpc.options.difficulty.nightmare", "[4] Košmaras | +250% sveikatos ir žalos")
			add("vjbase.menu.snpc.options.difficulty.hell_on_earth", "[5] Pragaras Žemėje | +350% sveikatos ir žalos")
			add("vjbase.menu.snpc.options.difficulty.total_annihilation", "[6] Visiškas sunaikinimas | +500% sveikatos ir žalos")
			add("vjbase.menu.snpc.options.label1", "Santykių nustatymai:")
			add("vjbase.menu.snpc.options.togglefriendlyantlion", "Draugiški antlionams")
			add("vjbase.menu.snpc.options.togglefriendlycombine", "Draugiški „Combine“ imperijai")
			add("vjbase.menu.snpc.options.togglefriendlyplayer", "Draugiški žaidėjam")
			add("vjbase.menu.snpc.options.togglefriendlyzombie", "Draugiški zombiam")
			add("vjbase.menu.snpc.options.togglefriendlyvj", "Draugiški „VJ Base“ veikėjam")
			add("vjbase.menu.snpc.options.label2", "Visi „VJ“ veikėjai viens kito nepuls!")
			add("vjbase.menu.snpc.options.label3", "Lavonų ir sveikatos nustatymai:")
			add("vjbase.menu.snpc.options.corpselimit", "Lavonų limitas, numatytas sk.:32")
			add("vjbase.menu.snpc.options.label4", "Lavonų limitas kai lavonų išlaikymas yra išjungtas")
			add("vjbase.menu.snpc.options.toggleundocorpses", "Panaikinami lavonai (Panaikinimo mygtukas)")
			add("vjbase.menu.snpc.options.togglecorpsefade", "Išnykstantys lavonai")
			add("vjbase.menu.snpc.options.corpsefadetime", "Lavonų išnykimo laikas")
			add("vjbase.menu.snpc.options.label5", "Maks.: 600 sekundžių (10 minučių)")
			add("vjbase.menu.snpc.options.togglegibcollision", "Prisilietimai prie vidaus organų")
			add("vjbase.menu.snpc.options.togglefadegibs", "Išnykstantys vidaus organai")
			add("vjbase.menu.snpc.options.gibfadetime", "Vidaus organų išnykimo laikas")
			add("vjbase.menu.snpc.options.label6", "Numatytas sk.: 30 | Maks.: 600 sekundžių (10 minučių)")
			add("vjbase.menu.snpc.options.togglesnpcgodmode", "Nemirtingumas (Negaus jokios žalos)")
			add("vjbase.menu.snpc.options.health", "Sveikata:")
			add("vjbase.menu.snpc.options.defaulthealth", "0 = Numatytas sk. (Maks. 9 skaičiai!)")
			add("vjbase.menu.snpc.options.label7", "Mąstymo nustatymai:")
			add("vjbase.menu.snpc.options.toggleknowenemylocation", "Visą laiką žino priešo vietą")
			add("vjbase.menu.snpc.options.sightdistance", "Regėjimo distancija:")
			add("vjbase.menu.snpc.options.label8", "Kiekvienas kompiuterinis veikėjas turi tam tikrą numatytą regėjimo distancija, bet šis nustatymas juos padarys vienodus. (0 = Originalus | Vid.: 10 tūkst.)")
			add("vjbase.menu.snpc.options.processtime", "Galvojimo laikas")
			add("vjbase.menu.snpc.options.whatisprocesstime", "Kas yra galvojimo laikas")
			add("vjbase.menu.snpc.options.label9", "Numatytas: 1 | Mažesnis skaičius lemia didesnį žaidimo trūkčiojimą!")
			add("vjbase.menu.snpc.options.label10", "Įvairūs kiti nustatymai:")
			add("vjbase.menu.snpc.options.togglegmoddecals", "Naudoti numatytą „Garry's Mod“ kraują")
			add("vjbase.menu.snpc.options.label11", "Spalvos, kurios nėra geltonos arba raudonos, nepasikeis!")
			add("vjbase.menu.snpc.options.toggleitemdrops", "Daiktų išmetimas mirties atveju")
			add("vjbase.menu.snpc.options.toggleaddfrags", "Pridėti taškų žaidėjam į švieslentę, kai nužudomi veikėjai")
			add("vjbase.menu.snpc.options.togglecreatureopendoor", "Būtybės gali atidaryti duris")
			add("vjbase.menu.snpc.options.togglehumansdropweapon", "Žmonės mirties atveju išmeta turimą ginklą")
			add("vjbase.menu.snpc.options.togglehumanscanjump", "Žmonės gali pašokti")
			add("vjbase.menu.snpc.options.toggleplydroppedweapons", "Žaidėjai gali paimti išmestus ginklus")
			
			add("vjbase.menu.snpc.settings", "Nustatymai")
			add("vjbase.menu.snpc.settings.label1", "Papildomi veikėjų logikos nustatymai:")
			add("vjbase.menu.snpc.settings.togglewandering", "Išjungti klaidžiojimą ramybės būsenoje")
			add("vjbase.menu.snpc.settings.togglechasingenemy", "Išjungti priešo gaudymą")
			add("vjbase.menu.snpc.settings.label2", "Naudokite šį nustatymą atsargiai, nes tai gali sugadinti funkcionalumą!")
			add("vjbase.menu.snpc.settings.togglemedics", "Išjungti veikėjų medicininę funkciją")
			add("vjbase.menu.snpc.settings.togglefollowplayer", "Išjungti žaidėjų sekimą")
			add("vjbase.menu.snpc.settings.label3", "Pavyzdžiui: Kai nuspaudžiate klavišą 'E' ant veikėjo, jis jūs seks")
			add("vjbase.menu.snpc.settings.toggleallies", "Išjungti aljansą (Visi tampa priešais)")
			add("vjbase.menu.snpc.settings.togglebecomeenemytoply", "Išjungti saviškių virtimą priešais")
			add("vjbase.menu.snpc.settings.toggleproppush", "Išjungti daiktų stumdymą (Būtybės)")
			add("vjbase.menu.snpc.settings.togglepropattack", "Išjungti daiktų puolimą (Būtybės)")
			add("vjbase.menu.snpc.settings.toggledangersight", "Išjungti paniką nuo granatų")
			add("vjbase.menu.snpc.settings.togglereloading", "Išjungti ginklų užtaisymą")
			add("vjbase.menu.snpc.settings.label4", "Puolimų nustatymai:")
			add("vjbase.menu.snpc.settings.togglemelee", "Išjungti artimąsias atakas")
			add("vjbase.menu.snpc.settings.togglerange", "Išjungti tolimąsias atakas")
			add("vjbase.menu.snpc.settings.toggleleap", "Išjungti šuolio atakas (Būtybės)")
			add("vjbase.menu.snpc.settings.togglethrownade", "Išjungti granatų mėtymą (Žmonės)")
			add("vjbase.menu.snpc.settings.toggleweapons", "Išjungti ginklus (Žmonės)")
			add("vjbase.menu.snpc.settings.label5", "Žmonės nebegalės naudotis ginklais!")
			add("vjbase.menu.snpc.settings.togglemeleedsp", "Išjungti DSP efektą kai artimoji ataka duoda daug žalos")
			add("vjbase.menu.snpc.settings.toggleslowplayer", "Išjungti žaidėjų sulėtėjimą nuo artimųjų atakų")
			add("vjbase.menu.snpc.settings.togglebleedonmelee", "Išjungti žaidėjų/veikėjų kraujavimą nuo artimųjų atakų")
			add("vjbase.menu.snpc.settings.label6", "Įvairūs kiti nustatymai:")
			add("vjbase.menu.snpc.settings.toggleidleparticles", "Išjungti ramybės būsenos efektus")
			add("vjbase.menu.snpc.settings.label7", "Išjungiant tai gali padėti numalšinti lag'ą")
			add("vjbase.menu.snpc.settings.togglesnpcchat", "Išjungti veikėjų chat'ą")
			add("vjbase.menu.snpc.settings.label8", "Pavyzdžiui: 'Scientist is now following you'")
			add("vjbase.menu.snpc.settings.label9", "Žalos bei lavonų nustatymai:")
			add("vjbase.menu.snpc.settings.toggleflinching", "Išjungti krūptelėjimus")
			add("vjbase.menu.snpc.settings.togglebleeding", "Išjungti kraują")
			add("vjbase.menu.snpc.settings.label10", "Išjungia kraujo efektus, kraujo balas ir t.t.")
			add("vjbase.menu.snpc.settings.togglebloodpool", "Išjungti kraujos balas")
			add("vjbase.menu.snpc.settings.togglegib", "Išjungti vidaus organų/dalių išsitaškymus")
			add("vjbase.menu.snpc.settings.label11", "Išjungiant tai gali padėti numalšinti lag'ą")
			add("vjbase.menu.snpc.settings.toggledeathanim", "Išjungti mirties animaciją")
			add("vjbase.menu.snpc.settings.togglecorpses", "Išjungti lavonus")
			add("vjbase.menu.snpc.settings.label12", "Pasyvojo mąstymo nustatymai:")
			add("vjbase.menu.snpc.settings.togglerunontouch", "Išjungti panikavimą nuo prisilietimo")
			add("vjbase.menu.snpc.settings.togglerunonhit", "Išjungti panikavimą nuo žalos")
			
			add("vjbase.menu.snpc.sdsettings", "Garso nustatymai")
			add("vjbase.menu.snpc.sdsettings.toggleallsounds", "Išjungti visus garsus")
			add("vjbase.menu.snpc.sdsettings.togglesoundtrack", "Išjungti muziką")
			add("vjbase.menu.snpc.sdsettings.toggleidle", "Išjungti ramybės būsenos garsus")
			add("vjbase.menu.snpc.sdsettings.togglebreathing", "Išjungti kvėpavimo garsus")
			add("vjbase.menu.snpc.sdsettings.togglefootsteps", "Išjungti vaikščiojimo garsus")
			add("vjbase.menu.snpc.sdsettings.toggleattacksounds", "Išjungti artimųjų atakų garsus")
			add("vjbase.menu.snpc.sdsettings.togglemeleemiss", "Išjungti artimosios atakos nepataikymo garsus")
			add("vjbase.menu.snpc.sdsettings.togglerangeattack", "Išjungti tolimųjų atakų garsus")
			add("vjbase.menu.snpc.sdsettings.togglealert", "Išjungti budrumo garsus")
			add("vjbase.menu.snpc.sdsettings.togglepain", "Išjungti skausmo garsus")
			add("vjbase.menu.snpc.sdsettings.toggledeath", "Išjungti mirties garsus")
			add("vjbase.menu.snpc.sdsettings.togglegibbing", "Išjungti išsitaškymo garsus")
			add("vjbase.menu.snpc.sdsettings.label1", "Taip pat galioja ir tiem garsam, kai dalis/organas liečiasi su kažkuo")
			add("vjbase.menu.snpc.sdsettings.togglemedic", "Išjungti medicinos garsus")
			add("vjbase.menu.snpc.sdsettings.togglefollowing", "Išjungti sekimo garsus")
			add("vjbase.menu.snpc.sdsettings.togglecallhelp", "Išjungti pagalbos šaukimo garsus")
			add("vjbase.menu.snpc.sdsettings.togglereceiveorder", "Išjungti gautų įsakymų garsus")
			add("vjbase.menu.snpc.sdsettings.togglebecomeenemy", "Išjungti saviškių virtimą priešais garsus")
			add("vjbase.menu.snpc.sdsettings.toggleplayersight", "Išjungti žaidėjų pamatymo garsus")
			add("vjbase.menu.snpc.sdsettings.label2", "Groja, kai veikėjas (saviškis) pamato žaidėją")
			add("vjbase.menu.snpc.sdsettings.toggledmgbyplayer", "Išjungti žalos nuo žaidėjo garsus")
			add("vjbase.menu.snpc.sdsettings.label3", "Groja, kai žaidėjas sužaloja veikėją, paprastai saviškį.")
			add("vjbase.menu.snpc.sdsettings.toggleleap", "Išjungti šuolio atakos garyss")
			add("vjbase.menu.snpc.sdsettings.toggleslowedplayer", "Išjungti sulėtėjimo garsus")
			add("vjbase.menu.snpc.sdsettings.label4", "Groja, kai žaidėjas yra sulėtinamas artimosios atakos")
			add("vjbase.menu.snpc.sdsettings.togglegrenade", "Išjungti granatų mėtymo garsus")
			add("vjbase.menu.snpc.sdsettings.toggledangersight", "Išjungti panikos nuo granatų garsus")
			add("vjbase.menu.snpc.sdsettings.togglesuppressing", "Išjungti nuslopinimo sušukimo garsus")
			add("vjbase.menu.snpc.sdsettings.togglereload", "Išjungti ginklo užtaisymo sušukimo garsus")
			
			add("vjbase.menu.snpc.devsettings", "Programuotojo nustatymai")
			add("vjbase.menu.snpc.devsettings.label1", "Šie nustatymai naudojami kai kūriami nauji „VJ“ veikėjai.")
			add("vjbase.menu.snpc.devsettings.label2", "DĖMESIO: Šie nustatymai gali sukelti lag'ą!")
			add("vjbase.menu.snpc.devsettings.toggledev", "Įjungti programuotojo rėžimą?")
			add("vjbase.menu.snpc.devsettings.label3", "Šis nustatymas turi būti įjungtas iš šio meniu arba per kontekstinį meniu! (Reikalingas nustatymam žemiau)")
			add("vjbase.menu.snpc.devsettings.printtouch", "Spausdinti On Touch (Konsolė)")
			add("vjbase.menu.snpc.devsettings.printcurenemy", "Spausdinti užfiksuotą priešą (Konsolė)")
			add("vjbase.menu.snpc.devsettings.printlastseenenemy", "Spausdinti 'LastSeenEnemy' laiką (Chat'as)")
			add("vjbase.menu.snpc.devsettings.printonreset", "Spausdinti On Reset Enemy (Konsolė)")
			add("vjbase.menu.snpc.devsettings.printonstopattack", "Spausdinti On Stopped Attacks (Konsolė)")
			add("vjbase.menu.snpc.devsettings.printtakingcover", "Spausdinti Taking Cover (Konsolė)")
			add("vjbase.menu.snpc.devsettings.printondamage", "Spausdinti On Damage (Konsolė)")
			add("vjbase.menu.snpc.devsettings.printondeath", "Spausdinti On Death (Konsolė)")
			add("vjbase.menu.snpc.devsettings.cachedmodels", "Talpykloje esantys modeliai (Konsolė)")
			
			add("vjbase.menu.snpc.consettings", "Valdiklio nustatymai")
			add("vjbase.menu.snpc.consettings.label1", "Pastaba: Šie nustatymai veikia tik klieno pusėje!")
			add("vjbase.menu.snpc.consettings.label2", "Ant kiek toli ar arti priartėjimas pasikeičia kiekviena spūstelėjimą")
			add("vjbase.menu.snpc.consettings.displayhud", "Rodyti HUD")
			add("vjbase.menu.snpc.consettings.camzoomdistance", "Priartėjimo distancija")
			add("vjbase.menu.snpc.consettings.displaydev", "Rodyti programavimo objektus")
			add("vjbase.menu.snpc.consettings.label3", "Klavišai:")
			add("vjbase.menu.snpc.consettings.bind.header1", "Kontrolė")
			add("vjbase.menu.snpc.consettings.bind.header2", "Aprašymas")
			add("vjbase.menu.snpc.consettings.bind.clickmsg1", "Pasirinktas klavišas:")
			add("vjbase.menu.snpc.consettings.bind.clickmsg2", "Aprašymas:")
			add("vjbase.menu.snpc.consettings.bind.movement", "Judėjimas (Palaiko ir aštuonių krypčių)")
			add("vjbase.menu.snpc.consettings.bind.exitcontrol", "Išeiti iš Valdiklio")
			add("vjbase.menu.snpc.consettings.bind.meleeattack", "Artimoji ataka")
			add("vjbase.menu.snpc.consettings.bind.rangeattack", "Tolimoji / Ginklo ataka")
			add("vjbase.menu.snpc.consettings.bind.leaporgrenade", "Šuolio / Granatos ataka")
			add("vjbase.menu.snpc.consettings.bind.reloadweapon", "Užtaisyti ginklą")
			add("vjbase.menu.snpc.consettings.bind.togglebullseye", "Perjungti taikinio sekimą")
			add("vjbase.menu.snpc.consettings.bind.cameraup", "Pakelti kamerą aukščiau")
			add("vjbase.menu.snpc.consettings.bind.cameradown", "Nuleisti kamerą žemiau")
			add("vjbase.menu.snpc.consettings.bind.cameraforward", "Pastumti kamerą į priekį")
			add("vjbase.menu.snpc.consettings.bind.camerabackward", "Pastumti kamerą atgal")
			add("vjbase.menu.snpc.consettings.bind.cameraleft", "Pastumti kamerą į kairę")
			add("vjbase.menu.snpc.consettings.bind.cameraright", "Pastumti kamerą į dešinę")
			add("vjbase.menu.snpc.consettings.bind.resetzoom", "Atstatyti priartinimą")
			
			-- Weapon Client Settings
			add("vjbase.menu.clweapon", "Kliento nustatymai")
			add("vjbase.menu.clweapon.notice", "Pastaba: šie nustatymai yra klientų, reiškia, jie nesikeis kitiem žmonėm!")
			add("vjbase.menu.clweapon.togglemuzzle", "Išjungti vamzdžio liepsną")
			add("vjbase.menu.clweapon.togglemuzzlelight", "Išjungti vamzdžio liepsnos dinaminę šviesą")
			add("vjbase.menu.clweapon.togglemuzzle.label", "Išjungiant vamzdžio liepsną taip pat išjungs ir susijusius nustatymus")
			add("vjbase.menu.clweapon.togglemuzzlebulletshells", "Išjungti apvalkalines kulkas")
			
			-- NPC Properties (C Menu)
			add("vjbase.menuproperties.control", "KONTROLIUOTI")
			add("vjbase.menuproperties.guard", "Perjungti teritorijos saugojimą")
			add("vjbase.menuproperties.wander", "Perjungti klaidžiojimą")
			add("vjbase.menuproperties.medic", "Paversti mediku")
			add("vjbase.menuproperties.allyme", "Paversti saviškiu man")
			add("vjbase.menuproperties.hostileme", "Paversti priešu man")
			add("vjbase.menuproperties.slay", "Nužudyti")
			add("vjbase.menuproperties.gib", "Ištaškyti (jei galima)")
			add("vjbase.menuproperties.devmode", "Įjungti programuotojo rėžimą")
			
			-- Tools
			add("tool.vjstool.menu.tutorialvideo", "Mokomasis vaizdo įrašas (anglų kalba)")
			add("tool.vjstool.menu.label.recommendation", "Rekomenduojama naudoti šį įrankį tik „VJ Base“ veikėjams.")
			
			add("tool.vjstool_bullseye.name", "Veikėjo taikinys")
			add("tool.vjstool_bullseye.desc", "Sukuria taikinį kuri veikėjai puls")
			add("tool.vjstool_bullseye.left", "Sukurti taikinį")
			add("tool.vjstool_bullseye.menu.help1", "Spauskite USE klavišą ant taikinio kad aktyvuotumėte/deaktyvuotumėte.")
			add("tool.vjstool_bullseye.menu.help2", "Kai deaktyvuotas, veikėjai taikinio nepuola.")
			add("tool.vjstool_bullseye.menu.label1", "Pasirinkite judėjimo tipą")
			add("tool.vjstool_bullseye.menu.label2", "Modelių katalogas")
			add("tool.vjstool_bullseye.menu.toggleusestatus", "Naudoti būsenos spalvas (Aktyvuotas/Deaktyvuotas)")
			add("tool.vjstool_bullseye.menu.togglestartactivated", "Iškarto suaktyvintas")
			
			add("tool.vjstool_entityscanner.name", "Objektų skaneris")
			add("tool.vjstool_entityscanner.desc", "Gauna informaciją apie objektą")
			add("tool.vjstool_entityscanner.left", "Išspausdinti informaciją apie objektą konsolėje")
			add("tool.vjstool_entityscanner.label", "Išspausdina informaciją apie bet kokį pasirinktą objektą konsolėje.")
			
			add("tool.vjstool_healthmodifier.name", "Sveikatos modifikatorius")
			add("tool.vjstool_healthmodifier.desc", "Pakeiskite objekto sveikatą")
			add("tool.vjstool_healthmodifier.left", "Nustatykite sveikatą")
			add("tool.vjstool_healthmodifier.right", "Nustatykite sveikatą ir maks. sveikatą")
			add("tool.vjstool_healthmodifier.reload", "Pagydyti objektą iki maksimalaus sveikatos procento")
			add("tool.vjstool_healthmodifier.adminonly", "Tik administratoriai gali keisti sveikatą arba gydyti kitus žaidėjus.")
			add("tool.vjstool_healthmodifier.sliderhealth", "Sveikata")
			add("tool.vjstool_healthmodifier.togglegodmode", "Nemirtingumas")
			add("tool.vjstool_healthmodifier.label1", "Šiuo metu veikia tik ant „VJ Base“ veikėjų")
			
			add("tool.vjstool_notarget.name", "Nematomumas")
			add("tool.vjstool_notarget.desc", "Nustatant nematomumą, visi veikėjai negalės „matyti“ tam tikro objekto")
			add("tool.vjstool_notarget.left", "Uždėti nematomumą ant savęs")
			add("tool.vjstool_notarget.right", "Uždėti nematomumą ant veikėjo arba žaidėjo")
			add("tool.vjstool_notarget.label", "Kai nematomumas yra įjungtas and objekto, kiti veikėjai jo nematys.")
			
			add("tool.vjstool_npcequipment.name", "Veikėjų ginklai")
			add("tool.vjstool_npcequipment.desc", "Keičia veikėjų ginklus")
			add("tool.vjstool_npcequipment.left", "Pakeisti veikėjo ginklą")
			add("tool.vjstool_npcequipment.right", "Pašalinti veikėjo ginklą")
			add("tool.vjstool_npcequipment.label", "Pakeičia arba pašalina veikėjo ginklą")
			add("tool.vjstool_npcequipment.selectedequipment", "Pasirinktas ginklas")
			add("tool.vjstool_npcequipment.print.doubleclick", "Spūstelėkite du kartus kad pasirinktumėte ginklą.")
			add("tool.vjstool_npcequipment.print.weaponselected1", "Ginklas")
			add("tool.vjstool_npcequipment.print.weaponselected2", "pasirinktas!")
			add("tool.vjstool_npcequipment.header1", "Pavadinimas")
			add("tool.vjstool_npcequipment.header2", "Klasė")
			
			add("tool.vjstool_npcmover.name", "Veikėjų judinimas")
			add("tool.vjstool_npcmover.desc", "Judina veikėjus, pirmiausia veikėjas turi būti pažymėtas")
			add("tool.vjstool_npcmover.left", "Pažymėkite veikėją")
			add("tool.vjstool_npcmover.right", "Bėgti į nurodytą vietą")
			add("tool.vjstool_npcmover.reload", "Eiti į nurodytą vietą")
			add("tool.vjstool_npcmover.header1", "Pavadinimas")
			add("tool.vjstool_npcmover.header2", "Klasė")
			add("tool.vjstool_npcmover.header3", "Informacija")
			add("tool.vjstool_npcmover.buttonunselectall", "Panaikinti visų veikėjų žymėjimą")
			add("tool.vjstool_npcmover.print.unselectedall", "Atžymėti visi veikėjai!")
			add("tool.vjstool_npcmover.print.unselectedall.error", "Niekas nebuvo atžymėtas")
			
			add("tool.vjstool_npcrelationship.name", "Veikėjų santykių modifikatorius")
			add("tool.vjstool_npcrelationship.desc", "Modifikuoja veikėjų/objektų santykius")
			add("tool.vjstool_npcrelationship.left", "Taikyti santykių lentelę")
			add("tool.vjstool_npcrelationship.right", "Gauti dabartines klases")
			add("tool.vjstool_npcrelationship.reload", "Taikyti santykių lentelę ant savęs")
			add("tool.vjstool_npcrelationship.label1", "Keičia veikėjo santykį su kitais objektais")
			add("tool.vjstool_npcrelationship.header", "Klasifikacija")
			add("tool.vjstool_npcrelationship.label2", "Spūstelėkite „return“ kad pridėti klasifikaciją")
			add("tool.vjstool_npcrelationship.button.combine", "Įdėti „Combine“ imperijos klasifikaciją")
			add("tool.vjstool_npcrelationship.button.antlion", "Įdėti antlionų klasifikaciją")
			add("tool.vjstool_npcrelationship.button.zombie", "Įdėti zombių klasifikaciją")
			add("tool.vjstool_npcrelationship.button.player", "Įdėti žaidėjo klasifikaciją")
			add("tool.vjstool_npcrelationship.togglealliedply", "Draugiškas visiem žaidėjam?")
			add("tool.vjstool_npcrelationship.label3", "Taikomas tik „VJ Base“ veikėjams ir reikia, kad veikėjas turėtų")
			add("tool.vjstool_npcrelationship.print.applied", "Pritaikyta santykių lentelę ant")
			
			add("tool.vjstool_npcspawner.name", "Veikėjų spawner'is")
			add("tool.vjstool_npcspawner.desc", "Sukuria spawner'į")
			add("tool.vjstool_npcspawner.left", "Sukurti spawner'į")
			add("tool.vjstool_npcspawner.right", "Sukurti objektus vieną kartą")
			add("tool.vjstool_npcspawner.selectednpc", "Pasirinktas veikėjas")
			add("tool.vjstool_npcspawner.spawnpos.forward", "Pozicija | Į priekį")
			add("tool.vjstool_npcspawner.spawnpos.right", "Pozicija | Atgal")
			add("tool.vjstool_npcspawner.spawnpos.up", "Pozicija | Į viršų")
			add("tool.vjstool_npcspawner.selectweapon", "Pasirinktas ginklas")
			add("tool.vjstool_npcspawner.button.updatelist", "Atnaujinti sąrašą")
			add("tool.vjstool_npcspawner.label1", "Du kartus spūstelėkite ant punkto, kad jį pašalinti.")
			add("tool.vjstool_npcspawner.header1", "Pavadinimas")
			add("tool.vjstool_npcspawner.header2", "Pozicija")
			add("tool.vjstool_npcspawner.header3", "Ginklas")
			add("tool.vjstool_npcspawner.label2", "Papildomi nustatymai")
			add("tool.vjstool_npcspawner.toggle.spawnsound", "Groti veikėjo sukurimo garsą?")
			add("tool.vjstool_npcspawner.nextspawntime", "Kitas spawn'o laikas")
			add("tool.vjstool_npcspawner.popup.header1", "Pavadinimas")
			add("tool.vjstool_npcspawner.popup.header2", "Klasė")
			add("tool.vjstool_npcspawner.popup.header3", "Kategorija")
			add("tool.vjstool_npcspawner.title1", "Du kartus spūstelėkite, kad pasirinktumėte veikėją.")
			add("tool.vjstool_npcspawner.title2", "Du kartus spūstelėkite, kad pasirinktumėte ginklą.")
		elseif conv == "spanish_lt" then ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		-- General Menu (Used everywhere)
			add("vjbase.menu.general.default", "Predeterminado")
			add("vjbase.menu.general.admin.only", "Nota: Solo admins pueden usar este menú.")
			add("vjbase.menu.general.admin.not", "¡No eres un admin!")
			add("vjbase.menu.general.reset.everything", "Resetear a predeterminado")
			add("vjbase.menu.general.snpc.warnfuture", "ADVERTENCIA: ¡Solamente SNPCs aparecidos en el futuro serán afectados!")
			add("vjbase.menu.general.snpc.creaturesettings", "Opciones de creatura:")
			add("vjbase.menu.general.snpc.humansettings", "Opciones de humano:")
		-- Menu Tabs			
			add("vjbase.menu.tabs.mainmenu", "Menú Principal")
			add("vjbase.menu.tabs.settings.snpc", "Opciones de SNPC")
			add("vjbase.menu.tabs.settings.weapon", "Opciones de Arma")
			add("vjbase.menu.tabs.settings.hud", "Opciones de HUD")
			add("vjbase.menu.tabs.tools", "Herramientas")
			add("vjbase.menu.tabs.configures.snpc", "Configuraciones de SNPC")
		-- Main Menu			
			add("vjbase.menu.cleanup", "Limpiar")
			add("vjbase.menu.cleanup.all", "Limpiar Todo")
			add("vjbase.menu.cleanup.stopsounds", "Parar Todos los Sonidos")
			add("vjbase.menu.cleanup.remove.vjnpcs", "Remover todos los NPCs de VJ")
			add("vjbase.menu.cleanup.remove.npcs", "Remover todos los NPCs")
			add("vjbase.menu.cleanup.remove.spawners", "Remover todos los Creadores")
			add("vjbase.menu.cleanup.remove.corpses", "Remover todos los Cadaveres")
			add("vjbase.menu.cleanup.remove.vjgibs", "Remover todos los Gibs VJ")
			add("vjbase.menu.cleanup.remove.groundweapons", "Remover Todas las Armas del suelo")
			add("vjbase.menu.cleanup.remove.props", "Remover todos los Props")
			add("vjbase.menu.cleanup.remove.decals", "Remover todos los Sprays")
			add("vjbase.menu.cleanup.remove.allweapons", "Remover todas tus Armas")
			add("vjbase.menu.cleanup.remove.allammo", "Remover toda tu Munición")
			
			add("vjbase.menu.helpsupport", "Contacto y Apoyo")
			add("vjbase.menu.helpsupport.reportbug", "Reportar un Bug")
			add("vjbase.menu.helpsupport.suggestion", "Sugerir Algo")
			add("vjbase.menu.helpsupport.discord", "¡Unete a mi servidor de Discord!")
			add("vjbase.menu.helpsupport.steam", "¡Unete a mi grupo de Steam!")
			add("vjbase.menu.helpsupport.youtube", "¡Suscribete a mi canal de YouTube!")
			add("vjbase.menu.helpsupport.twitter", "¡Sigueme en Twitter!")
			add("vjbase.menu.helpsupport.patreon", "¡Doname en Patreon!")
			add("vjbase.menu.helpsupport.label1", "¡Sigueme en uno de estos links para estar al pendiente de mis addons!")
			add("vjbase.menu.helpsupport.label2", "¡Las donaciones me ayudan y me motivan a crear/actualizar addons! Gracias!")
			add("vjbase.menu.helpsupport.thanks", "¡Gracias por el apoyo!")
					
			add("vjbase.menu.svsettings", "Ajustes del Servidor Admin")
			add("vjbase.menu.svsettings.label", "ADVERTENCIA: ¡ALGUNOS AJUSTES NECESITAN TENER LOS CHEATS ACTIVADOS!")
			add("vjbase.menu.svsettings.admin.npcproperties", "Restringir Propiedades de SNPCs a solamente Admins")
			add("vjbase.menu.svsettings.noclip", "Permitir NoClip")
			add("vjbase.menu.svsettings.weapons", "Permitir Armas")
			add("vjbase.menu.svsettings.pvp", "Permitir PvP")
			add("vjbase.menu.svsettings.godmode", "Modo Dios (Todos)")
			add("vjbase.menu.svsettings.bonemanip.npcs", "Manipular los huesos de NPCs")
			add("vjbase.menu.svsettings.bonemanip.players", "Manipular los huesos de los Jugadores")
			add("vjbase.menu.svsettings.bonemanip.others", "Manipular los huesos de los Otros")
			add("vjbase.menu.svsettings.timescale.general", "TimeScale General")
			add("vjbase.menu.svsettings.timescale.physics", "TimeScale de Físicas")
			add("vjbase.menu.svsettings.gravity", "Gravedad General")
			add("vjbase.menu.svsettings.maxentsprops", "Máximo de Props/Entidades")
					
			add("vjbase.menu.clsettings", "Ajustes del Cliente")
			add("vjbase.menu.clsettings.label", "Utiliza este menú para personalizar tus ajustes del Cliente, ¡los servidores no pueden cambiar estos ajustes!")
			add("vjbase.menu.clsettings.labellang", "Selección de Idioma")
			add("vjbase.menu.clsettings.notify.lang", "Idioma De VJ Base Establecido Al:")
					
			add("vjbase.menu.info", "Información")
					
			add("vjbase.menu.label", "Plugins Instalados")
			add("vjbase.menu.plugins.label", "Lista de plugins de VJ Base instalados.")
			add("vjbase.menu.plugins.version", "Versión:")
			add("vjbase.menu.plugins.totalplugins", "Total de Plugins:")
			add("vjbase.menu.plugins.header1", "Nombre")
			add("vjbase.menu.plugins.header2", "Tipo")
			add("vjbase.menu.plugins.notfound", "No Se Encontraron Plugins.")
			add("vjbase.menu.plugins.changelog", "Registro de Cambios")
			add("vjbase.menu.plugins.makeaddon", "¿Quieres hacer un addon?")
		elseif conv == "schinese" then ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			-- Spawn Menu
			add("vjbase.spawn.menu.npc.disablethinking", "AI 停止思考")
			add("vjbase.spawn.menu.npc.ignoreplayers", "AI 无视玩家")
			add("vjbase.spawn.menu.npc.keepcorpses", "NPC 尸体碰撞/保留")
			add("vjbase.spawn.menu.npc.guard", "NPC 作为守卫生成")
			
			-- General Menu (Used everywhere)
			add("vjbase.menu.general.default", "默认")
			add("vjbase.menu.general.admin.only", "注意：只有管理员可以使用此菜单。")
			add("vjbase.menu.general.admin.not", "你不是管理员！")
			add("vjbase.menu.general.reset.everything", "重置为默认值")
			add("vjbase.menu.general.snpc.warnfuture", "警告：只对之后生成的 SNPC 有效！")
			add("vjbase.menu.general.snpc.creaturesettings", "生物设置：")
			add("vjbase.menu.general.snpc.humansettings", "人类设置：")
			
			-- Menu Tabs
			add("vjbase.menu.tabs.mainmenu", "主菜单")
			add("vjbase.menu.tabs.settings.snpc", "SNPC 设置")
			add("vjbase.menu.tabs.settings.weapon", "武器设置")
			add("vjbase.menu.tabs.settings.hud", "HUD 设置")
			add("vjbase.menu.tabs.tools", "工具")
			add("vjbase.menu.tabs.configures.snpc", "SNPC 配置")
			
			-- Main Menu
			add("vjbase.menu.cleanup", "清除")
			add("vjbase.menu.cleanup.all", "清除全部")
			add("vjbase.menu.cleanup.stopsounds", "停止所有音效")
			add("vjbase.menu.cleanup.remove.vjnpcs", "移除所有 VJ NPC")
			add("vjbase.menu.cleanup.remove.npcs", "移除所有 NPC")
			add("vjbase.menu.cleanup.remove.spawners", "移除所有生成器")
			add("vjbase.menu.cleanup.remove.corpses", "移除所有尸体")
			add("vjbase.menu.cleanup.remove.vjgibs", "移除所有 VJ 碎块")
			add("vjbase.menu.cleanup.remove.groundweapons", "移除所有地上的武器")
			add("vjbase.menu.cleanup.remove.props", "移除所有物品")
			add("vjbase.menu.cleanup.remove.decals", "移除所有贴图")
			add("vjbase.menu.cleanup.remove.allweapons", "移除你所有的武器")
			add("vjbase.menu.cleanup.remove.allammo", "移除你所有的弹药")
			
			add("vjbase.menu.helpsupport", "联系和支持")
			add("vjbase.menu.helpsupport.incompatibleaddons", "不兼容的插件")
			add("vjbase.menu.helpsupport.reportbug", "报告错误")
			add("vjbase.menu.helpsupport.suggestion", "提一些建议")
			add("vjbase.menu.helpsupport.discord", "在 Discord 上加我！")
			add("vjbase.menu.helpsupport.steam", "在 Steam 上加我！")
			add("vjbase.menu.helpsupport.youtube", "在 YouTube 上订阅我！")
			add("vjbase.menu.helpsupport.twitter", "在 Twitter 上关注我！")
			add("vjbase.menu.helpsupport.patreon", "在 Patreon 上赞助我！")
			add("vjbase.menu.helpsupport.label1", "通过以下链接之一来获取有关我的插件的更新！")
			add("vjbase.menu.helpsupport.label2", "赞助会帮助和鼓励我继续制作/更新插件！非常感谢你的支持。")
			add("vjbase.menu.helpsupport.thanks", "感谢你的支持！")
			
			add("vjbase.menu.svsettings", "管理员服务器设置")
			add("vjbase.menu.svsettings.label", "警告：部分设置需要启用作弊！")
			add("vjbase.menu.svsettings.admin.npcproperties", "将 SNPC 属性限制为仅限管理员")
			add("vjbase.menu.svsettings.noclip", "允许穿墙")
			add("vjbase.menu.svsettings.weapons", "出生武器配给")
			add("vjbase.menu.svsettings.pvp", "允许 PvP")
			add("vjbase.menu.svsettings.godmode", "无敌模式（所有人）")
			add("vjbase.menu.svsettings.bonemanip.npcs", "NPC 骨骼编辑")
			add("vjbase.menu.svsettings.bonemanip.players", "玩家骨骼编辑")
			add("vjbase.menu.svsettings.bonemanip.others", "其他骨骼编辑")
			add("vjbase.menu.svsettings.timescale.general", "全局时间倍率")
			add("vjbase.menu.svsettings.timescale.physics", "物理时间倍率")
			add("vjbase.menu.svsettings.gravity", "全局重力")
			add("vjbase.menu.svsettings.maxentsprops", "最大道具/实体数量：")
			
			add("vjbase.menu.clsettings", "客户端设置")
			add("vjbase.menu.clsettings.label", "使用此菜单来自定义你的客户端设置，服务器无法更改这里的设置！")
			add("vjbase.menu.clsettings.labellang", "选择语言...")
			add("vjbase.menu.clsettings.notify.lang", "VJ Base 的语言设置为：")
			add("vjbase.menu.clsettings.lang.auto", "自动设置语言")
			add("vjbase.menu.clsettings.lang.auto.label", "如果 VJ Base 设置为 GMod 不支持的语言，则忽略")

			add("vjbase.menu.info", "信息")
			
			add("vjbase.menu.plugins", "已安装的插件")
			add("vjbase.menu.plugins.label", "已安装的 VJ Base 插件列表。")
			add("vjbase.menu.plugins.version", "版本：")
			add("vjbase.menu.plugins.totalplugins", "插件总数：")
			add("vjbase.menu.plugins.header1", "名称")
			add("vjbase.menu.plugins.header2", "类型")
			add("vjbase.menu.plugins.notfound", "未发现插件。")
			add("vjbase.menu.plugins.changelog", "更新日志")
			add("vjbase.menu.plugins.makeaddon", "想要制作一个模组？")
			
			-- SNPC Menus
			add("vjbase.menu.snpc.options", "选项")
			add("vjbase.menu.snpc.options.difficulty.header", "选择难度：")
			add("vjbase.menu.snpc.options.difficulty.neanderthal", "[-3] 原始人 | -99% 的生命值和伤害")
			add("vjbase.menu.snpc.options.difficulty.childs_play", "[-2] 儿童游戏 | -75% 的生命值和伤害")
			add("vjbase.menu.snpc.options.difficulty.easy", "[-1] 简单 | -50% 的生命值和伤害")
			add("vjbase.menu.snpc.options.difficulty.normal", "[0] 正常 | 默认的生命值和伤害")
			add("vjbase.menu.snpc.options.difficulty.hard", "[1] 困难 | +50% 的生命值和伤害")
			add("vjbase.menu.snpc.options.difficulty.insane", "[2] 疯狂 | +100% 的生命值和伤害")
			add("vjbase.menu.snpc.options.difficulty.impossible", "[3] 不可能 | +150% 的生命值和伤害")
			add("vjbase.menu.snpc.options.difficulty.nightmare", "[4] 噩梦 | +250% 的生命值和伤害")
			add("vjbase.menu.snpc.options.difficulty.hell_on_earth", "[5] 炼狱 | +350% 的生命值和伤害")
			add("vjbase.menu.snpc.options.difficulty.total_annihilation", "[6] 横扫千军 | +500% 的生命值和伤害")
			add("vjbase.menu.snpc.options.label1", "关系设置：")
			add("vjbase.menu.snpc.options.togglefriendlyantlion", "对蚁狮友好")
			add("vjbase.menu.snpc.options.togglefriendlycombine", "对联合军友好")
			add("vjbase.menu.snpc.options.togglefriendlyplayer", "对玩家友好")
			add("vjbase.menu.snpc.options.togglefriendlyzombie", "对僵尸友好")
			add("vjbase.menu.snpc.options.togglefriendlyvj", "对 VJ Base 实体友好")
			add("vjbase.menu.snpc.options.label2", "所有的 VJ SNPC 彼此之间会变得友好！")
			add("vjbase.menu.snpc.options.label3", "尸体，分尸，生命值选项：")
			add("vjbase.menu.snpc.options.collision.header", "尸体碰撞选项：")
			add("vjbase.menu.snpc.options.collision.default", "默认 | 不包括：玩家，NPC，武器，布娃娃")
			add("vjbase.menu.snpc.options.collision.everything", "与一切碰撞！")
			add("vjbase.menu.snpc.options.collision.onlyworld", "仅与世界碰撞")
			add("vjbase.menu.snpc.options.collision.excludedebris", "不包括：尸体，碎片")
			add("vjbase.menu.snpc.options.collision.excludeplynpcs", "不包括：玩家，NPC")
			add("vjbase.menu.snpc.options.collision.excludeply", "不包括：玩家")
			add("vjbase.menu.snpc.options.corpselimit", "尸体上限，默认：32")
			add("vjbase.menu.snpc.options.label4", "当“保留尸体”关闭时，尸体的存在上限")
			add("vjbase.menu.snpc.options.toggleundocorpses", "可撤销的尸体（撤销键）")
			add("vjbase.menu.snpc.options.togglecorpsefade", "尸体消失")
			add("vjbase.menu.snpc.options.corpsefadetime", "尸体消失时间")
			add("vjbase.menu.snpc.options.label5", "最高：600 秒（10 分钟）")
			add("vjbase.menu.snpc.options.togglegibcollision", "碎块可碰撞")
			add("vjbase.menu.snpc.options.togglefadegibs", "碎块消失")
			add("vjbase.menu.snpc.options.gibfadetime", "碎块消失时间")
			add("vjbase.menu.snpc.options.label6", "默认：30 | 最高：600 秒（10 分钟）")
			add("vjbase.menu.snpc.options.togglesnpcgodmode", "无敌模式（不会受到任何伤害）")
			add("vjbase.menu.snpc.options.health", "生命值：")
			add("vjbase.menu.snpc.options.defaulthealth", "0 = 默认生命值（最高 9 位数！）")
			add("vjbase.menu.snpc.options.label7", "AI 选项：")
			add("vjbase.menu.snpc.options.toggleknowenemylocation", "总是知道敌人的位置")
			add("vjbase.menu.snpc.options.sightdistance", "视野距离：")
			add("vjbase.menu.snpc.options.label8", "每个 NPC 都有自己的距离，但这个选项会使它们的视野距离变得一样，所以要谨慎使用！(0 = 默认值 | 平均：10k）")
			add("vjbase.menu.snpc.options.processtime", "处理时间")
			add("vjbase.menu.snpc.options.whatisprocesstime", "什么是处理时间？")
			add("vjbase.menu.snpc.options.label9", "默认：1 | 越低的数字会导致更多的卡顿！")
			add("vjbase.menu.snpc.options.label10", "其他选项：")
			add("vjbase.menu.snpc.options.togglegmoddecals", "使用 Garry's Mod 当前的血迹贴图")
			add("vjbase.menu.snpc.options.label11", "不是黄色或红色的血迹贴图不会改变！")
			add("vjbase.menu.snpc.options.toggleitemdrops", "死亡时掉落物品")
			add("vjbase.menu.snpc.options.toggleaddfrags", "死亡时在玩家的计分板上添加击杀数")
			add("vjbase.menu.snpc.options.togglecreatureopendoor", "生物可以打开门")
			add("vjbase.menu.snpc.options.togglehumansdropweapon", "人类在死亡时掉落武器")
			add("vjbase.menu.snpc.options.togglehumanscanjump", "人类可以跳跃")
			add("vjbase.menu.snpc.options.toggleplydroppedweapons", "玩家可以捡起掉落的武器")
			
			add("vjbase.menu.snpc.settings", "设置")
			add("vjbase.menu.snpc.settings.label1", "AI 设置：")
			add("vjbase.menu.snpc.settings.togglewandering", "禁止空闲时四处游荡")
			add("vjbase.menu.snpc.settings.togglechasingenemy", "禁止追寻敌人")
			add("vjbase.menu.snpc.settings.label2", "小心使用这个设置，它可以破坏很多东西！")
			add("vjbase.menu.snpc.settings.togglemedics", "禁用医疗兵 SNPC")
			add("vjbase.menu.snpc.settings.togglefollowplayer", "禁止跟随玩家")
			add("vjbase.menu.snpc.settings.label3", "例如：你对着一个 SNPC 按下“E”键，它们就会跟着你")
			add("vjbase.menu.snpc.settings.toggleallies", "禁止联盟（不可成为队友！）")
			add("vjbase.menu.snpc.settings.togglebecomeenemytoply", "禁止队友成为敌人")
			add("vjbase.menu.snpc.settings.togglecallhelp", "禁止呼救")
			add("vjbase.menu.snpc.settings.toggleproppush", "禁用物品推动（生物）")
			add("vjbase.menu.snpc.settings.togglepropattack", "禁用物品攻击（生物）")
			add("vjbase.menu.snpc.settings.toggledangersight", "禁止人类检测危险和手雷")
			add("vjbase.menu.snpc.settings.togglereloading", "禁用武器装填弹药")
			add("vjbase.menu.snpc.settings.label4", "攻击设置：")
			add("vjbase.menu.snpc.settings.togglemelee", "禁用近战攻击")
			add("vjbase.menu.snpc.settings.togglerange", "禁用远程攻击")
			add("vjbase.menu.snpc.settings.toggleleap", "禁用跳跃攻击（生物）")
			add("vjbase.menu.snpc.settings.togglethrownade", "禁用手雷攻击（人类）")
			add("vjbase.menu.snpc.settings.toggleweapons", "禁用武器（人类）")
			add("vjbase.menu.snpc.settings.label5", "人类将不能使用武器！")
			add("vjbase.menu.snpc.settings.togglemeleedsp", "禁用重型近战攻击的 DSP 效果")
			add("vjbase.menu.snpc.settings.toggleslowplayer", "禁用玩家受到近战攻击时减速")
			add("vjbase.menu.snpc.settings.togglebleedonmelee", "禁用玩家/NPC受到近战攻击时流血")
			add("vjbase.menu.snpc.settings.label6", "其他设置：")
			add("vjbase.menu.snpc.settings.toggleidleparticles", "禁用空闲时的粒子效果和特效")
			add("vjbase.menu.snpc.settings.label7", "启用此选项可以提高性能")
			add("vjbase.menu.snpc.settings.togglesnpcchat", "禁用 SNPC 聊天框信息")
			add("vjbase.menu.snpc.settings.label8", "例如：“科学家 现在正跟着你”")
			add("vjbase.menu.snpc.settings.label9", "伤害和尸体设置：")
			add("vjbase.menu.snpc.settings.toggleflinching", "禁用受到伤害时后靠")
			add("vjbase.menu.snpc.settings.togglebleeding", "禁用流血")
			add("vjbase.menu.snpc.settings.label10", "禁用血液粒子效果，贴图，血泊等。")
			add("vjbase.menu.snpc.settings.togglebloodpool", "禁用血泊（死亡时）")
			add("vjbase.menu.snpc.settings.togglegib", "禁用碎尸")
			add("vjbase.menu.snpc.settings.label11", "启用此选项可以提高性能")
			add("vjbase.menu.snpc.settings.toggledeathanim", "禁用死亡动画")
			add("vjbase.menu.snpc.settings.togglecorpses", "禁用尸体")
			add("vjbase.menu.snpc.settings.label12", "被动设置：")
			add("vjbase.menu.snpc.settings.togglerunontouch", "禁用被触碰时奔跑")
			add("vjbase.menu.snpc.settings.togglerunonhit", "禁用被击中时奔跑")
			
			add("vjbase.menu.snpc.sdsettings", "声音设置")
			add("vjbase.menu.snpc.sdsettings.toggleallsounds", "禁用所有声音")
			add("vjbase.menu.snpc.sdsettings.togglesoundtrack", "禁用音轨/音乐")
			add("vjbase.menu.snpc.sdsettings.toggleidle", "禁用空闲音效")
			add("vjbase.menu.snpc.sdsettings.togglebreathing", "禁用呼吸音效")
			add("vjbase.menu.snpc.sdsettings.togglefootsteps", "禁用脚步音效")
			add("vjbase.menu.snpc.sdsettings.toggleattacksounds", "禁用近战攻击音效")
			add("vjbase.menu.snpc.sdsettings.togglemeleemiss", "禁用近战攻击未击中音效")
			add("vjbase.menu.snpc.sdsettings.togglerangeattack", "禁用远程攻击音效")
			add("vjbase.menu.snpc.sdsettings.togglealert", "禁用警戒音效")
			add("vjbase.menu.snpc.sdsettings.togglepain", "禁用疼痛音效")
			add("vjbase.menu.snpc.sdsettings.toggledeath", "禁用死亡音效")
			add("vjbase.menu.snpc.sdsettings.togglegibbing", "禁用碎尸音效")
			add("vjbase.menu.snpc.sdsettings.label1", "同时也禁用碎块与其他东西碰撞时的音效")
			add("vjbase.menu.snpc.sdsettings.togglemedic", "禁用医疗兵音效")
			add("vjbase.menu.snpc.sdsettings.togglefollowing", "禁用跟随音效")
			add("vjbase.menu.snpc.sdsettings.togglecallhelp", "禁用寻求帮助音效")
			add("vjbase.menu.snpc.sdsettings.togglereceiveorder", "禁用接受命令音效")
			add("vjbase.menu.snpc.sdsettings.togglebecomeenemy", "禁用成为玩家敌人音效")
			add("vjbase.menu.snpc.sdsettings.toggleplayersight", "禁用发现玩家音效")
			add("vjbase.menu.snpc.sdsettings.label2", "当 SNPC 看到玩家时播放的特殊音效")
			add("vjbase.menu.snpc.sdsettings.toggledmgbyplayer", "禁用受到玩家攻击音效")
			add("vjbase.menu.snpc.sdsettings.label3", "当玩家攻击一名 SNPC 时的音效，通常用于友方 SNPC。")
			add("vjbase.menu.snpc.sdsettings.toggleleap", "禁用跳跃攻击音效")
			add("vjbase.menu.snpc.sdsettings.toggleslowedplayer", "禁用玩家减速音效")
			add("vjbase.menu.snpc.sdsettings.label4", "当玩家被近战攻击减速时播放的音效")
			add("vjbase.menu.snpc.sdsettings.togglegrenade", "禁用手雷攻击音效")
			add("vjbase.menu.snpc.sdsettings.toggledangersight", "禁用发现手雷和危险音效")
			add("vjbase.menu.snpc.sdsettings.togglesuppressing", "禁用压制敌人时呼喊音效")
			add("vjbase.menu.snpc.sdsettings.togglereload", "禁用换弹时呼喊音效")
			
			add("vjbase.menu.snpc.devsettings", "开发者设置")
			add("vjbase.menu.snpc.devsettings.label1", "这些设置用于调试 SNPC。")
			add("vjbase.menu.snpc.devsettings.label2", "警告：部分选项会导致卡顿！")
			add("vjbase.menu.snpc.devsettings.toggledev", "启用开发者模式？")
			add("vjbase.menu.snpc.devsettings.label3", "必须从此处或通过关联菜单启用此选项(以下选项需要）")
			add("vjbase.menu.snpc.devsettings.printtouch", "被触碰时输出（控制台）")
			add("vjbase.menu.snpc.devsettings.printcurenemy", "输出当前的敌人（控制台）")
			add("vjbase.menu.snpc.devsettings.printlastseenenemy", "输出“最后一次看见敌人”的时间（聊天框）")
			add("vjbase.menu.snpc.devsettings.printonreset", "重置敌人时输出（控制台）")
			add("vjbase.menu.snpc.devsettings.printonstopattack", "停止攻击时输出（控制台）")
			add("vjbase.menu.snpc.devsettings.printtakingcover", "寻找掩护时输出（控制台）")
			add("vjbase.menu.snpc.devsettings.printondamage", "受到伤害时输出（控制台）")
			add("vjbase.menu.snpc.devsettings.printondeath", "死亡时输出（控制台）")
			add("vjbase.menu.snpc.devsettings.printweaponinfo", "输出武器相关信息（控制台）")
			add("vjbase.menu.snpc.devsettings.cachedmodels", "已缓存的模型（控制台）")
			add("vjbase.menu.snpc.devsettings.numofnpcs", "当前 NPC 数量（聊天框）")
			add("vjbase.menu.snpc.devsettings.reloadsounds", "重新加载音效")
			add("vjbase.menu.snpc.devsettings.reloadmaterials", "重新加载材质（VMT）")
			add("vjbase.menu.snpc.devsettings.reloadtextures", "重新加载贴图（VTF）")
			add("vjbase.menu.snpc.devsettings.reloadmodels", "重新加载模型")
			add("vjbase.menu.snpc.devsettings.reloadspawnmenu", "重新加载生成菜单")
			
			add("vjbase.menu.snpc.consettings", "控制器设置")
			add("vjbase.menu.snpc.consettings.label1", "注意：这仅是客户端设置！")
			add("vjbase.menu.snpc.consettings.label2", "每次单击时缩放的距离远近。")
			add("vjbase.menu.snpc.consettings.displayhud", "显示 HUD")
			add("vjbase.menu.snpc.consettings.camzoomdistance", "视角移动距离")
			add("vjbase.menu.snpc.consettings.camspeed", "视角速度")
			add("vjbase.menu.snpc.consettings.camzoomspeed", "视角缩放速度" )
			add("vjbase.menu.snpc.consettings.diewithnpc", "NPC 死亡时，控制器也失效（需要重生！）")
			add("vjbase.menu.snpc.consettings.displaydev", "显示开发者模式的实体")
			add("vjbase.menu.snpc.consettings.label3", "按键绑定：")
			add("vjbase.menu.snpc.consettings.bind.header1", "按键")
			add("vjbase.menu.snpc.consettings.bind.header2", "描述")
			add("vjbase.menu.snpc.consettings.bind.clickmsg1", "已选中的按键：")
			add("vjbase.menu.snpc.consettings.bind.clickmsg2", "描述：")
			add("vjbase.menu.snpc.consettings.bind.movement", "移动（支持 8 个方向）")
			add("vjbase.menu.snpc.consettings.bind.exitcontrol", "退出控制器")
			add("vjbase.menu.snpc.consettings.bind.meleeattack", "近战攻击")
			add("vjbase.menu.snpc.consettings.bind.rangeattack", "远程/武器攻击")
			add("vjbase.menu.snpc.consettings.bind.leaporgrenade", "跳跃/手雷攻击")
			add("vjbase.menu.snpc.consettings.bind.reloadweapon", "装填武器")
			add("vjbase.menu.snpc.consettings.bind.togglebullseye", "开/关靶子跟踪")
			add("vjbase.menu.snpc.consettings.bind.cameramode", "更改视角")
			add("vjbase.menu.snpc.consettings.bind.movementjump", "切换移动/跳跃")
			add("vjbase.menu.snpc.consettings.bind.camerazoom", "视角缩放")
			add("vjbase.menu.snpc.consettings.bind.cameraup", "视角向上")
			add("vjbase.menu.snpc.consettings.bind.cameradown", "视角向下")
			add("vjbase.menu.snpc.consettings.bind.cameraforward", "视角向前")
			add("vjbase.menu.snpc.consettings.bind.camerabackward", "视角向后")
			add("vjbase.menu.snpc.consettings.bind.cameraleft", "视角向左")
			add("vjbase.menu.snpc.consettings.bind.cameraright", "视角向右")
			add("vjbase.menu.snpc.consettings.bind.resetzoom", "恢复视角位置")
			
			-- Weapon Client Settings
			add("vjbase.menu.clweapon", "客户端设置")
			add("vjbase.menu.clweapon.notice", "注意：这些设置是客户端设置，这意味着它不会被其他人更改！")
			add("vjbase.menu.clweapon.togglemuzzle", "禁用枪口火焰")
			add("vjbase.menu.clweapon.togglemuzzlelight", "禁用枪口火焰动态光照")
			add("vjbase.menu.clweapon.togglemuzzle.label", "禁用枪口火焰的同时也会禁用此选项")
			add("vjbase.menu.clweapon.togglemuzzlebulletshells", "禁用弹壳")
			
			-- NPC Properties (C Menu)
			add("vjbase.menuproperties.control", "操控")
			add("vjbase.menuproperties.guard", "开始/停止守卫")
			add("vjbase.menuproperties.wander", "开始/停止游荡")
			add("vjbase.menuproperties.medic", "变成医疗兵（切换）")
			add("vjbase.menuproperties.allyme", "成为我的队友")
			add("vjbase.menuproperties.hostileme", "成为我的敌人")
			add("vjbase.menuproperties.slay", "杀死")
			add("vjbase.menuproperties.gib", "碎尸（如果可用）")
			add("vjbase.menuproperties.devmode", "打开/关闭开发者模式")
			add("vjbase.menuproperties.print.adminonly", "这些选项仅限于管理员！")
			
			-- Tools
			add("tool.vjstool.menu.tutorialvideo", "教程视频")
			add("tool.vjstool.menu.label.recommendation", "建议仅对 VJ Base 的 SNPC 使用此工具。")
			
			add("tool.vjstool_bullseye.name", "NPC 靶子")
			add("tool.vjstool_bullseye.desc", "创建一个 NPC 会瞄准的靶子")
			add("tool.vjstool_bullseye.left", "创建一个靶子")
			add("tool.vjstool_bullseye.menu.help1", "按下使用键来激活/禁用实体。")
			add("tool.vjstool_bullseye.menu.help2", "禁用时，NPC 将不会瞄准它。")
			add("tool.vjstool_bullseye.menu.label1", "选择移动类型")
			add("tool.vjstool_bullseye.menu.label2", "模型路径")
			add("tool.vjstool_bullseye.menu.toggleusestatus", "按照状态改变颜色（激活/禁用）")
			add("tool.vjstool_bullseye.menu.togglestartactivated", "开始时激活")
			
			add("tool.vjstool_entityscanner.name", "实体扫描器")
			add("tool.vjstool_entityscanner.desc", "获取一个实体的信息")
			add("tool.vjstool_entityscanner.left", "输出实体的信息到控制台")
			add("tool.vjstool_entityscanner.label", "输出任意选中的实体的信息到控制台。")
			
			add("tool.vjstool_healthmodifier.name", "生命值设置")
			add("tool.vjstool_healthmodifier.desc", "设置一个实体的生命值")
			add("tool.vjstool_healthmodifier.left", "设置生命值")
			add("tool.vjstool_healthmodifier.right", "设置生命值和最高生命值")
			add("tool.vjstool_healthmodifier.reload", "回复实体的生命值到最高值")
			add("tool.vjstool_healthmodifier.adminonly", "只有管理员可以修改或治疗其他玩家的生命值。")
			add("tool.vjstool_healthmodifier.sliderhealth", "生命值")
			add("tool.vjstool_healthmodifier.label1", "以下选项仅适用于 VJ Base SNPC：")
			add("tool.vjstool_healthmodifier.togglegodmode", "无敌模式")
			add("tool.vjstool_healthmodifier.togglehealthregen", "启用生命回复")
			add("tool.vjstool_healthmodifier.sliderhealthregenamt", "回复量")
			add("tool.vjstool_healthmodifier.sliderhealthregendelay", "回复间隔")
			
			add("tool.vjstool_notarget.name", "无目标")
			add("tool.vjstool_notarget.desc", "对一个实体使用“无目标”会让 NPC 无法看见此实体")
			add("tool.vjstool_notarget.left", "对自己开启/关闭无目标")
			add("tool.vjstool_notarget.right", "对一个 NPC 或玩家开启/关闭无目标")
			add("tool.vjstool_notarget.label", "当一个实体启用了“无目标”，NPC 将不会把此实体视为目标！")
			add("tool.vjstool_notarget.print.yourselfon", "对自己开启无目标")
			add("tool.vjstool_notarget.print.yourselfoff", "对自己关闭无目标")
			
			add("tool.vjstool_npcequipment.name", "NPC 装备")
			add("tool.vjstool_npcequipment.desc", "修改一个 NPC 的装备")
			add("tool.vjstool_npcequipment.left", "更改 NPC 的装备")
			add("tool.vjstool_npcequipment.right", "移除 NPC 的装备")
			add("tool.vjstool_npcequipment.label", "更改或移除一个 NPC 的装备。")
			add("tool.vjstool_npcequipment.selectedequipment", "已选中的装备")
			add("tool.vjstool_npcequipment.print.doubleclick", "双击来选择一个武器。")
			add("tool.vjstool_npcequipment.print.weaponselected1", "武器")
			add("tool.vjstool_npcequipment.print.weaponselected2", "已选中！")
			add("tool.vjstool_npcequipment.header1", "名称")
			add("tool.vjstool_npcequipment.header2", "实体类别")
			
			add("tool.vjstool_npcmover.name", "NPC 移动器")
			add("tool.vjstool_npcmover.desc", "移动 NPC 到指定地点，必须先选中一个 NPC")
			add("tool.vjstool_npcmover.left", "选择一个 NPC")
			add("tool.vjstool_npcmover.right", "奔跑到指定地点")
			add("tool.vjstool_npcmover.reload", "步行到指定地点")
			add("tool.vjstool_npcmover.header1", "名称")
			add("tool.vjstool_npcmover.header2", "实体类别")
			add("tool.vjstool_npcmover.header3", "信息")
			add("tool.vjstool_npcmover.buttonunselectall", "取消选中所有 NPC")
			add("tool.vjstool_npcmover.print.unselectedall", "已取消选中所有 NPC！")
			add("tool.vjstool_npcmover.print.unselectedall.error", "没有可以取消选中的东西！")
			
			add("tool.vjstool_npcrelationship.name", "NPC 关系编辑器")
			add("tool.vjstool_npcrelationship.desc", "修改实体之间的关系")
			add("tool.vjstool_npcrelationship.left", "应用关系表")
			add("tool.vjstool_npcrelationship.right", "获取当前类别")
			add("tool.vjstool_npcrelationship.reload", "应用关系表到自己")
			add("tool.vjstool_npcrelationship.label1", "修改一个 NPC 的关系，即它对另一个实体的感觉。")
			add("tool.vjstool_npcrelationship.header", "实体类别")
			add("tool.vjstool_npcrelationship.label2", "按下回车键来添加类别。")
			add("tool.vjstool_npcrelationship.button.combine", "插入联合军类别")
			add("tool.vjstool_npcrelationship.button.antlion", "插入蚁狮类别")
			add("tool.vjstool_npcrelationship.button.zombie", "插入僵尸类别")
			add("tool.vjstool_npcrelationship.button.player", "插入玩家类别")
			add("tool.vjstool_npcrelationship.togglealliedply", "与玩家的队友联盟？")
			add("tool.vjstool_npcrelationship.label3", "仅适用于 VJ Base SNPC 并且需要 SNPC 拥有")
			add("tool.vjstool_npcrelationship.print.applied", "将关系表应用于")
			
			add("tool.vjstool_npcspawner.name", "NPC 生成器")
			add("tool.vjstool_npcspawner.desc", "创建一个可设置的生成器")
			add("tool.vjstool_npcspawner.left", "创建一个生成器")
			add("tool.vjstool_npcspawner.right", "立刻生成实体")
			add("tool.vjstool_npcspawner.selectednpc", "已选中的 NPC")
			add("tool.vjstool_npcspawner.spawnpos.forward", "方位 | 前")
			add("tool.vjstool_npcspawner.spawnpos.right", "方位 | 右")
			add("tool.vjstool_npcspawner.spawnpos.up", "方位 | 上")
			add("tool.vjstool_npcspawner.selectweapon", "已选中的武器")
			add("tool.vjstool_npcspawner.spawnnpclass", "类别关系覆盖")
			add("tool.vjstool_npcspawner.fritoplyallies", "对玩家阵营友好")
			add("tool.vjstool_npcspawner.label.fritoplyallies", "必须拥有关系类别（CLASS_PLAYER_ALLY）！")
			add("tool.vjstool_npcspawner.button.updatelist", "更新列表")
			add("tool.vjstool_npcspawner.label1", "双击一个条目来将其移除。")
			add("tool.vjstool_npcspawner.header1", "名称")
			add("tool.vjstool_npcspawner.header2", "方位")
			add("tool.vjstool_npcspawner.header3", "装备")
			add("tool.vjstool_npcspawner.label2", "额外选项")
			add("tool.vjstool_npcspawner.toggle.spawnsound", "播放 NPC 生成音效？")
			add("tool.vjstool_npcspawner.nextspawntime", "生成间隔")
			add("tool.vjstool_npcspawner.popup.header1", "名称")
			add("tool.vjstool_npcspawner.popup.header2", "实体类别")
			add("tool.vjstool_npcspawner.popup.header3", "分组")
			add("tool.vjstool_npcspawner.title1", "双击来选择一个 NPC。")
			add("tool.vjstool_npcspawner.title2", "双击来选择一个武器。")
			add("tool.vjstool_npcspawner.print.nothingspawn", "没有要生成的东西！")
			
			add("tool.vjstool_npcfollower.name", "NPC 跟随器")
			add("tool.vjstool_npcfollower.desc", "选择一个 NPC 并且让它跟随某个实体")
			add("tool.vjstool_npcfollower.left", "选择一个 NPC")
			add("tool.vjstool_npcfollower.right", "选择要让 NPC 跟随的实体")
			add("tool.vjstool_npcfollower.reload", "取消跟随任何 NPC 正在跟随的实体")
			add("tool.vjstool_npcfollower.print.noselection", "未选中 NPC！")
			add("tool.vjstool_npcfollower.print.reset", "已取消跟随任何 NPC 正在跟随的实体！")
		
			-- Miscellaneous (Prints)
			add("vjbase.print.bullseye.activated", "已激活 NPC 靶子。")
			add("vjbase.print.bullseye.deactivated", "已禁用 NPC 靶子。")
			
			add("vjbase.print.npccontroller.entrance", "要查看按键，请前往“DrVrej”页面下的“控制器设置”")
			add("vjbase.print.npccontroller.tracking.activated", "靶子追踪已激活！")
			add("vjbase.print.npccontroller.tracking.deactivated", "靶子追踪已禁用！")
			add("vjbase.print.npccontroller.movementjump.enable", "已启用移动跳跃！")
			add("vjbase.print.npccontroller.movementjump.disable", "已禁用移动跳跃！")
			
			add("vjbase.print.adminhealth.pickup", "你已经获得 1,000,000 点生命值！")
			
			add("vjbase.print.fireplace.activated", "你点燃了篝火。")
			add("vjbase.print.fireplace.deactivated", "你扑灭了篝火。")
			
			add("vjbase.print.plyspawnpoint.activated", "已激活此出生点！")
			add("vjbase.print.plyspawnpoint.deactivated", "已禁用此出生点！")
		end
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ ///// WARNING: Don't touch anything below this line! \\\\\ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
		print("VJ Base Language Set To: "..conv)
	end
	VJ_REFRESH_LANGUAGE() -- Arachin ankam ganch e, garevor e asiga!
end

--PATH lua/autorun/vj_controls.lua:
return gluapack()()
--PATH lua/autorun/vj_menu_spawn.lua:
/*--------------------------------------------------
	=============== VJ Spawn Menu ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

AddCSLuaFile()
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Hooks ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	hook.Add("PopulateVJBaseHome","AddVJBaseSpawnMenu_Home",function(pnlContent,tree,node)
		local hometree = tree:AddNode("Home", "icon16/monkey.png")
		hometree.PropPanel = vgui.Create("ContentContainer", pnlContent)
		hometree.PropPanel:SetVisible(false)
		hometree.PropPanel:SetTriggerSpawnlistChange(false)
		//hometree.PropPanel:MoveToFront()
		
		function hometree:DoClick()
			pnlContent:SwitchPanel(self.PropPanel)
		end
		
		local Header1 = vgui.Create("DLabel")
		Header1:SetPos(40, 40)
		Header1:SetSize(200, 70)
		Header1:SetTextColor(Color(255, 102, 0, 255))
		Header1:SetText("Welcome to VJ Base!")
		hometree.PropPanel:Add(Header1)
		
		local Text1 = vgui.Create("DLabel")
		Header1:SetPos(80, 80)
		Text1:SetSize(100, 35)
		Text1:SetTextColor(Color(102, 204, 255, 255))
		Text1:SetText("By: DrVrej")
		hometree.PropPanel:Add(Text1)
		
		hometree:InternalDoClick()
	end)
	--[-------------------------------------------------------]--
	local function VJ_PopulateTrees(pnlContent, tree, node, vjTreeName, vjIcon, vjList)
		local roottree = tree:AddNode(vjTreeName, vjIcon)
		if vjTreeName == "SNPCs" then
			roottree:MoveToFront() -- Make this the main tree
		end
		roottree.PropPanel = vgui.Create("ContentContainer", pnlContent)
		roottree.PropPanel:SetVisible(false)
		roottree.PropPanel:SetTriggerSpawnlistChange(false)
		
		function roottree:DoClick()
			pnlContent:SwitchPanel(self.PropPanel)
		end
		
		local EntList = list.Get(vjList)
		local CatInfoList = list.Get("VJBASE_CATEGORY_INFO")
		
		-- Categorize them
		local Categories = {}
		for k, v in pairs(EntList) do
			local Category = v.Category or "Uncategorized"
			if Category == "VJ Base" then Category = "Default" end
			local Tab = Categories[Category] or {}
			Tab[k] = v
			Categories[Category] = Tab
		end
		
		-- Create an icon for each one and put them on the panel
		for CategoryName, v in SortedPairs(Categories) do
			
			-- Category icon
			local icon = vjIcon -- Make the default icon the category icon
			if list.HasEntry("VJBASE_CATEGORY_INFO", CategoryName) then
				icon = CatInfoList[CategoryName].icon
			elseif CategoryName == "Default" then
				icon = "vj_base/icons/vrejgaming.png"
			end
			
			local node = roottree:AddNode(CategoryName, icon)
			local CatPropPanel = vgui.Create("ContentContainer", pnlContent)
			CatPropPanel:SetVisible(false)
			
			-- Write the name of the categories in both the general menu and in its own menu
			local generalHeader = vgui.Create("ContentHeader", roottree.PropPanel)
			generalHeader:SetText(CategoryName)
			roottree.PropPanel:Add(generalHeader)
			local catHeader = vgui.Create("ContentHeader", CatPropPanel)
			catHeader:SetText(CategoryName)
			CatPropPanel:Add(catHeader)
			
			if vjTreeName == "SNPCs" then
				for name, ent in SortedPairsByMemberValue(v, "Name") do
					local t = {
						nicename	= ent.Name or name,
						spawnname	= name,
						material	= "entities/" .. name .. ".png",
						weapon		= ent.Weapons,
						admin		= ent.AdminOnly
					}
					spawnmenu.CreateContentIcon("npc", CatPropPanel, t)
					spawnmenu.CreateContentIcon("npc", roottree.PropPanel, t)
				end
			elseif vjTreeName == "Weapons" then
				for _, ent in SortedPairsByMemberValue(v, "PrintName") do
					local t = { 
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.ClassName,
						material	= "entities/" .. ent.ClassName .. ".png",
						admin		= ent.AdminOnly
					}
					spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", CatPropPanel, t)
					spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", roottree.PropPanel, t)
				end
			elseif vjTreeName == "Entities" then
				for _, ent in SortedPairsByMemberValue(v, "PrintName") do
					local t = { 
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.ClassName,
						material	= "entities/" .. ent.ClassName .. ".png",
						admin		= ent.AdminOnly
					}
					spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "entity", CatPropPanel, t)
					spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "entity", roottree.PropPanel, t)
				end
			end
			function node:DoClick()
				pnlContent:SwitchPanel(CatPropPanel)
			end
		end
		roottree:SetExpanded(true)
		if vjTreeName == "SNPCs" then
			roottree:InternalDoClick() -- Automatically select this folder when the menu first opens
		end
	end
	--[-------------------------------------------------------]--
	hook.Add("PopulateVJBaseNPC", "AddVJBaseSpawnMenu_NPC", function(pnlContent, tree, node)
		VJ_PopulateTrees(pnlContent, tree, node, "SNPCs", "icon16/monkey.png", "VJBASE_SPAWNABLE_NPC")
	end)
	--[-------------------------------------------------------]--
	hook.Add("PopulateVJBaseWeapons","AddVJBaseSpawnMenu_Weapon", function(pnlContent, tree, node)
		VJ_PopulateTrees(pnlContent, tree, node, "Weapons", "icon16/gun.png", "VJBASE_SPAWNABLE_WEAPON")
	end)
	--[-------------------------------------------------------]--
	hook.Add("PopulateVJBaseEntities","AddVJBaseSpawnMenu_Entity",function(pnlContent,tree,node)
		VJ_PopulateTrees(pnlContent, tree, node, "Entities", "icon16/bricks.png", "VJBASE_SPAWNABLE_ENTITIES")
	end)
	--[-------------------------------------------------------]--
	hook.Add("PopulateVJBaseTools","AddVJBaseSpawnMenu_Tool",function(pnlContent,tree,node)
		local tooltree = tree:AddNode("Tools", "icon16/bullet_wrench.png")
		tooltree.PropPanel = vgui.Create("ContentContainer", pnlContent)
		tooltree.PropPanel:SetVisible(false)
		tooltree.PropPanel:SetTriggerSpawnlistChange(false)

		function tooltree:DoClick()
			pnlContent:SwitchPanel(self.PropPanel)
		end
		
		local ToolList = spawnmenu.GetTools()
		if (ToolList) then
			for _, nv in pairs(ToolList) do
				if nv.Name == "DrVrej" then
					for _, nv2 in pairs(nv.Items) do
						if nv2.ItemName == "Tools" then
							//local node = tooltree:AddNode("Default", "icon16/bullet_wrench.png")
							local CatPropPanel = vgui.Create("ContentContainer", pnlContent)
							CatPropPanel:SetVisible(false)
							local Header = vgui.Create("ContentHeader", tooltree.PropPanel)
							Header:SetText("Tools")
							tooltree.PropPanel:Add(Header)
							for _, nv3 in pairs(nv2) do
								if !istable(nv3) then continue end
									local t = { 
										nicename	= nv3.Text,
										spawnname	= nv3.ItemName,
										//material	= "entities/" .. ent.ClassName .. ".png",
										//admin		= ent.AdminOnly
									}
									spawnmenu.CreateContentIcon("tool", CatPropPanel, t)
									spawnmenu.CreateContentIcon("tool", tooltree.PropPanel, t)
								end
							function tooltree:DoClick()	
								pnlContent:SwitchPanel(CatPropPanel)
							end
						end
					end
				end
			end
		end
		tooltree:SetExpanded(true)
	end)
	
	--[-------------------------------------------------------]--
	-- Adds the searching functionality for the VJ Base spawn menu. Note: This algorithm is based on the base GMod algorithm.
	search.AddProvider(function(str)
		local results = {}
		local entities = {}
		
		local function searchList(lname, lctype)
			for k, v in pairs(list.Get(lname)) do
				v.ClassName = k
				v.PrintName = v.PrintName or v.Name
				v.ScriptedEntityType = lctype
				table.insert(entities, v)
			end
		end
		searchList("VJBASE_SPAWNABLE_NPC", "npc")
		searchList("VJBASE_SPAWNABLE_WEAPON", "weapon")
		searchList("VJBASE_SPAWNABLE_ENTITIES", "entity")
		// searchList("VJBASE_SPAWNABLE_VEHICLES", "vehicle") -- vehicle (Not yet lol)

		for _, v in pairs(entities) do
			local name = v.PrintName
			local name_c = v.ClassName
			if (!name && !name_c) then continue end
			
			if ((name && name:lower():find(str, nil, true)) or (name_c && name_c:lower():find(str, nil, true))) then
				local entry = {
					text = v.PrintName or v.ClassName,
					icon = spawnmenu.CreateContentIcon(v.ScriptedEntityType or "entity", nil, {
						nicename = v.PrintName or v.ClassName,
						spawnname = v.ClassName,
						material = "entities/" .. v.ClassName .. ".png",
						admin = v.AdminOnly
					}),
					words = {v}
				}

				table.insert(results, entry)
			end
		end
		table.SortByMember(results, "text", true)
		return results
	end, "vjbase_npcs")

	--[-------------------------------------------------------]--
	spawnmenu.AddCreationTab("VJ Base", function()
		local ctrl = vgui.Create("SpawnmenuContentPanel")
		ctrl:EnableSearch("vjbase_npcs", "PopulateVJBaseNPC")
		//ctrl:CallPopulateHook("PopulateVJBaseHome")
		ctrl:CallPopulateHook("PopulateVJBaseNPC")
		ctrl:CallPopulateHook("PopulateVJBaseWeapons")
		ctrl:CallPopulateHook("PopulateVJBaseEntities")
		ctrl:CallPopulateHook("PopulateVJBaseTools")
		
		local sidebar = ctrl.ContentNavBar
		sidebar.Options = vgui.Create( "VJ_SpawnmenuNPCSidebarToolbox", sidebar )
	
		return ctrl
	end, "vj_base/icons/vrejgaming.png", 60, "All VJ Base entities are located here!") // icon16/plugin.png
	
	--[-------------------------------------------------------]--
	-- Based on GMod's SpawnmenuNPCSidebarToolbox but with some changes
	local PANEL = {}
	Derma_Hook(PANEL, "Paint", "Paint", "Tree")
	PANEL.m_bBackground = true -- Hack for above

	function PANEL:AddCheckbox(text, cvar)
		local DermaCheckbox = self:Add("DCheckBoxLabel", self)
		DermaCheckbox:Dock(TOP)
		DermaCheckbox:SetText(text)
		DermaCheckbox:SetDark(true)
		DermaCheckbox:SetConVar(cvar)
		DermaCheckbox:SizeToContents()
		DermaCheckbox:DockMargin(0, 5, 0, 0)
	end

	function PANEL:Init()
		self:SetOpenSize(150)
		self:DockPadding(15, 10, 15, 10)

		self:AddCheckbox("#vjbase.spawn.menu.npc.disablethinking", "ai_disabled")
		self:AddCheckbox("#vjbase.spawn.menu.npc.ignoreplayers", "ai_ignoreplayers")
		self:AddCheckbox("#vjbase.spawn.menu.npc.keepcorpses", "ai_serverragdolls")
		self:AddCheckbox("#vjbase.spawn.menu.npc.guard", "vj_npc_spawn_guard")
		
		local label = vgui.Create("DLabel", self)
		label:Dock(TOP)
		label:DockMargin(0, 5, 0, 0)
		label:SetDark(true)
		label:SetText("#menubar.npcs.weapon")

		local DComboBox = vgui.Create( "DComboBox", self )
		DComboBox:Dock( TOP )
		DComboBox:DockMargin(0, 0, 0, 0)
		DComboBox:SetConVar("gmod_npcweapon")
		DComboBox:SetSortItems(false)

		DComboBox:AddChoice("#menubar.npcs.defaultweapon", "")
		DComboBox:AddChoice("#menubar.npcs.noweapon", "none")
		DComboBox:AddSpacer()

			-- Sort the items by name, and group by category
		local groupedWeps = {}
		for _, v in pairs( list.Get( "VJBASE_SPAWNABLE_NPC_WEAPON" ) ) do
			local cat = (v.category or ""):lower()
			groupedWeps[ cat ] = groupedWeps[ cat ] or {}
			groupedWeps[ cat ][ v.class ] = language.GetPhrase( v.title )
		end

		for _, items in SortedPairs( groupedWeps ) do
			DComboBox:AddSpacer()
			for class, title in SortedPairsByValue( items ) do
				DComboBox:AddChoice( title, class )
			end
		end

		function DComboBox:OnSelect( index, value )
			self:ConVarChanged( self.Data[ index ] )
		end

		self:Open()
	end
	vgui.Register("VJ_SpawnmenuNPCSidebarToolbox", PANEL, "DDrawer")
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Spawn Functions ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local function CreateInternal_NPC(Player, Position, Normal, Class, Equipment, SpawnFlagsSaved)
	if CLIENT then return end
	print("Running VJ Base NPC duplicator internal...")
	local NPCList = list.Get("NPC") //VJBASE_SPAWNABLE_NPC
	local NPCData = NPCList[Class]
	if NPCData == nil then print("ERROR! VJ Base NPC duplicator internal failed, NPC not listed in the NPC menu!") return end
	//PrintTable(NPCData)
	//if !IsValid(NPCData) then print("VJ Base NPC Internal was unable to spawn the NPC, it didn't find any NPC Data to use") return end
	print("VJ Base NPC duplicator internal creating: " .. NPCData.Name .. " ( ".. NPCData.Class .. " ) --> ".. NPCData.Category)

	-- Don't let them spawn this entity if it isn't in our NPC Spawn list.
	/*if (!NPCData) then 
		if (!IsValid(Player)) then
			Player:SendLua("Derma_Message(\"Hey, stop trying to spawn it, your not allowed to!\")")
		end
	return end*/

	local isValidPly = IsValid(Player)

	if ( NPCData.AdminOnly && isValidPly && !Player:IsAdmin() ) then return end

	local bDropToFloor = false
	if ( NPCData.OnCeiling && Vector( 0, 0, -1 ):Dot( Normal ) < 0.95 ) then -- This NPC has to be spawned on a ceiling (Barnacle)
		return nil
	end
	if ( NPCData.OnFloor && Vector( 0, 0, 1 ):Dot( Normal ) < 0.95 ) then -- This NPC has to be spawned on a floor (Turrets)
		return nil
	else
		bDropToFloor = true
	end
	if ( NPCData.NoDrop ) then bDropToFloor = false end

	-- Offset the position
	local Offset = NPCData.Offset or 32
	Position = Position + Normal * Offset

	-- Create NPC
	local NPC = ents.Create(NPCData.Class)
	if (!IsValid(NPC)) then print("ERROR! VJ Base NPC duplicator internal failed, NPC class does not exist!") return end
	NPC:SetPos(Position)
	
	-- Rotate to face player (expected behavior)
	local Angles = Angle( 0, 0, 0 )
		if ( isValidPly ) then
			Angles = Player:GetAngles()
		end
		Angles.pitch = 0
		Angles.roll = 0
		Angles.yaw = Angles.yaw + 180
	if ( NPCData.Rotate ) then Angles = Angles + NPCData.Rotate end
	NPC:SetAngles( Angles )

	-- This NPC has a special model we want to define
	if ( NPCData.Model ) then NPC:SetModel( NPCData.Model ) end

	-- This NPC has a special texture we want to define
	if ( NPCData.Material ) then NPC:SetMaterial( NPCData.Material ) end

	-- Spawn Flags
	local SpawnFlags = bit.bor( SF_NPC_FADE_CORPSE, SF_NPC_ALWAYSTHINK )
	if ( NPCData.SpawnFlags ) then SpawnFlags = bit.bor( SpawnFlags, NPCData.SpawnFlags ) end
	if ( NPCData.TotalSpawnFlags ) then SpawnFlags = NPCData.TotalSpawnFlags end
	if ( SpawnFlagsSaved ) then SpawnFlags = SpawnFlagsSaved end
	NPC:SetKeyValue( "spawnflags", SpawnFlags )

	-- Optional Key Values
	if ( NPCData.KeyValues ) then
		for k, v in pairs( NPCData.KeyValues ) do
			NPC:SetKeyValue( k, v )
		end		
	end

	-- This NPC has a special skin we want to define
	if ( NPCData.Skin ) then NPC:SetSkin( NPCData.Skin ) end
	
	-- Body groups
	if (NPCData.BodyGroups) then
		for k, v in pairs(NPCData.BodyGroups) do
			NPC:SetBodygroup(k, v)
		end
	end

	-- Check if this is a valid entity from the list, or the user is trying to fool us.
	local valid = false
	for _, v in pairs( list.Get( "NPCUsableWeapons" ) ) do
		if v.class == Equipment then valid = true break end
	end

	if ( Equipment && Equipment != "none" && valid ) then
		NPC:SetKeyValue( "additionalequipment", Equipment )
		NPC.Equipment = Equipment 
	end

	DoPropSpawnedEffect(NPC)
	NPC:Spawn()
	NPC:Activate()
	
	if ( bDropToFloor && !NPCData.OnCeiling ) then NPC:DropToFloor() end
	print("VJ Base NPC duplicator internal successfully created the NPC!")
	return NPC
end
-------------------------------------------------------------------------------------------------------------------------
if !VJ then VJ = {} end -- If VJ isn't initialized, initialize it!
--
local vecZ1 = Vector(0, 0, 1)
--
VJ.CreateDupe_NPC = function(ply, class, equipment, spawnflags, data) -- Based on the GMod NPCs, had to recreate it here because it's not a global function
	//PrintTable(data)
	if IsValid(ply) && !gamemode.Call("PlayerSpawnNPC", ply, class, equipment) then return end -- Don't create if this player isn't allowed to spawn NPCs!

	local normal = vecZ1
	local NPCList = list.Get("NPC")
	local NPCData = NPCList[class]
	if (NPCData && NPCData.OnCeiling) then normal = Vector(0, 0, -1) end

	local ent = CreateInternal_NPC(ply, data.Pos, normal, class, equipment, spawnflags)
	if (IsValid(ent)) then
		local pos = ent:GetPos() -- Prevents the NPCs from falling through the floor
		duplicator.DoGeneric(ent, data) -- Applies generic every-day entity stuff for ent from table data (wiki)
		if (!NPCData.OnCeiling && !NPCData.NoDrop) then
			ent:SetPos(pos)
			ent:DropToFloor()
		end
		if (IsValid(ply)) then
			gamemode.Call("PlayerSpawnedNPC", ply, ent)
			ply:AddCleanup("npcs", ent)
		end
		table.Add(ent:GetTable(), data)
	end
	return ent
end
--PATH addons/[fix] wiltos_animation_fix/lua/autorun/wiltos_animbase_loader.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_ahl.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_customtaunt.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\extensions\\wos_customtaunt.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Custom Taunt" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Custom Taunt\n" )
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_famdance.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_famdance.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\extensions\\wos_famdance.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Familiar Dances" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Familiar Dances\n" )
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_l4d.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/bladedancer.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/defensive.lua:
local DATA = {}
DATA.Name = "[LSCS] HoldType Defensive"
DATA.HoldType = "wos_defensive_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "walk_knife", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "wos_judge_h_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/dynamic.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/elegant.lua:
local DATA = {}
DATA.Name = "melee5"
DATA.HoldType = "wos-meleeelegant-type"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "wos_phalanx_r_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "h_jump", Weight = 1 },
}


wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================
--PATH lua/wos/anim_extension/holdtypes/form4.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_rollright.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_rollright.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_rollright"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "rollright" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "rollright" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/greater_melee.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/holdtypes/melee_combo.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/holdtypes/melee_combo.lua:
local DATA = {}

DATA.Name = "Melee Combination"
DATA.HoldType = "melee-combo"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

--DATA.Translations[ ACT_MP_STAND_IDLE ]					= 2680
--DATA.Translations[ ACT_MP_WALK ]						= 2683
--DATA.Translations[ ACT_MP_RUN ]							= 2685
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= ACT_HL2MP_IDLE_CROUCH_KNIFE 
DATA.Translations[ ACT_MP_CROUCHWALK ]					= ACT_HL2MP_WALK_CROUCH_KNIFE
--DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= 2688
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_JUMP ]						= 3160
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
--DATA.Translations[ ACT_LAND ]							= ACT_LAND

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/anim_extension/holdtypes/slashready.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "slashready"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "slashready" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "slashready" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/anim_extension/holdtypes/slashuph.lua:
return gluapack()()
--PATH lua/wos/dynabase/core/sh_core.lua:
// That's right, x64 won't work with .dat in this trick. Special thanks to 8Z
WOS_DYNABASE_FILE_EXTENSION = ".dat"
-- if jit.arch == "x64" then
-- 	WOS_DYNABASE_FILE_EXTENSION = ".txt"
-- end

wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}
wOS.DynaBase.DataCachePass = 0
wOS.DynaBase.InitCompleted = false

wOS.DynaBase.Registers = {}
wOS.DynaBase.RegisterCount = 0

wOS.DynaBase.EnforcedOrder = {}
wOS.DynaBase.EnforceCount = 1

wOS.DynaBase.PlayerOrder = {}
wOS.DynaBase.PlayerCount = 1

WOS_DYNABASE = WOS_DYNABASE or {}
WOS_DYNABASE.SHARED = 1
WOS_DYNABASE.MALE = 2
WOS_DYNABASE.FEMALE = 3
WOS_DYNABASE.ZOMBIE = 4
WOS_DYNABASE.MAXCACHE = 1

WOS_DYNABASE.EXTENSION = 1
WOS_DYNABASE.REANIMATION = 2

wOS.DynaBase.DefaultTable = {}
wOS.DynaBase.DefaultTable.Male = { "data/wos/dynabase/local_male" .. WOS_DYNABASE_FILE_EXTENSION, "models/m_wos.mdl" }
wOS.DynaBase.DefaultTable.Female = { "data/wos/dynabase/local_female" .. WOS_DYNABASE_FILE_EXTENSION, "models/f_wos.mdl" }
wOS.DynaBase.DefaultTable.Zombie = { "data/wos/dynabase/local_zombie" .. WOS_DYNABASE_FILE_EXTENSION, "models/z_wos.mdl" }
wOS.DynaBase.DefaultTable.Shared = { "data/wos/dynabase/local_shared" .. WOS_DYNABASE_FILE_EXTENSION }

wOS.DynaBase.FilteredLoadOrder = {}
wOS.DynaBase.FilteredPlayerOrder = {}

wOS.DynaBase.FilteredBlacklist = {}
wOS.DynaBase.FilteredPlayerBlacklist = {}

local flags = {FCVAR_REPLICATED, FCVAR_PROTECTED, FCVAR_ARCHIVE}
WOS_DYNABASE_ENFORCECONTENT_CVAR = CreateConVar( "wos_dynabase_restrict_client_content", "0", flags, "Prevents usage of custom content (animations) that are not registered on the server.\n \t0 = No Restrictions\n \t1 = Registered Addons\n \t2 = Registered and Mounted Addons" )
WOS_DYNABASE_ENFORCEREANIMATE_CVAR = CreateConVar( "wos_dynabase_restrict_client_reanimation", "1", flags, "Prevents clients from being able to customize what re-animations are locally enabled" )
WOS_DYNABASE_ENFORCEEXTENDERS_CVAR = CreateConVar( "wos_dynabase_restrict_client_extension", "1", flags, "Prevents clients from being able to customize what animation extensions are locally enabled" )
WOS_DYNABASE_LOADORDERENFORCE_CVAR = CreateConVar( "wos_dynabase_restrict_server_loadorder", "1", flags, "Enforces the order of animations as registered by the order of wos_dynabase_mountaddon command executions. Addons not specified will be mounted after the initial list" )
WOS_DYNABASE_MOUNTORDERLIST_CVAR = CreateConVar( "wos_dynabase_mountorder", "", flags, "Enforces the order of animations as comma seperated names of registered addons. Addons not specified will be mounted after the initial list unless content enforcement is set to 2. Any addons not installed are simply skipped" )
WOS_DYNABASE_MOUNTBLACKLIST_CVAR = CreateConVar( "wos_dynabase_blacklist", "", flags, "A comma seperated list of the names of blacklisted registered sources" )
WOS_DYNABASE_SHOULDHOTLOAD_CVAR = CreateConVar( "wos_dynabase_live_reload", "1", {FCVAR_ARCHIVE}, "Should animations reload in-game when changes are made automatically? If you are experiencing crashing issues, disable this" )

local function InitializeBase()
	if not wOS.DynaBase.InitCompleted then
		hook.Call( "InitLoadAnimations" )
	end
    wOS.DynaBase:ProcessLoadOrder()
	wOS.DynaBase:ReloadAnimations()

	if SERVER then
		if wOS.DynaBase.InitCompleted and not WOS_DYNABASE_SHOULDHOTLOAD_CVAR:GetBool() then return end
		RunConsoleCommand( "r_flushlod" )
	end

	wOS.DynaBase.InitCompleted = true
end

local function HandleMountOrderList( args )
    if not args or #args < 1 then 
		wOS.DynaBase.EnforceCount = 0
		wOS.DynaBase.EnforcedOrder = nil 
		return 
	end

	wOS.DynaBase.EnforcedOrder = {}
    wOS.DynaBase.EnforceCount = 0

	local tbl = string.Explode( ",", args )
	for _, arg in ipairs( tbl ) do
		if table.HasValue( wOS.DynaBase.EnforcedOrder, arg ) then continue end
		wOS.DynaBase.EnforceCount = wOS.DynaBase.EnforceCount + 1
		wOS.DynaBase.EnforcedOrder[ wOS.DynaBase.EnforceCount ] = arg
	end
end

cvars.AddChangeCallback("wos_dynabase_mountorder", function(_, oldargs, args)

	if SERVER then
		net.Start( "wOS.DynaBase.ForceMountCallback" )
			net.WriteString( oldargs )
			net.WriteString( args )
		net.Broadcast()
	end

	HandleMountOrderList( args )

    if not WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() then return end
	InitializeBase()
    wOS.DynaBase.InitCompleted = true
end)

hook.Add( "CreateTeams", "wOS.DynaBase.InitLoadAnimations", function()
	if wOS.DynaBase.InitCompleted then return end
	if WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() then
		HandleMountOrderList( WOS_DYNABASE_MOUNTORDERLIST_CVAR:GetString() )
	end
	InitializeBase()
end )

function wOS.DynaBase:RegisterSource( data )
	if not data then return end
	if not data.Name then return end
	self.Registers[ data.Name ] = data
	self.RegisterCount = self.RegisterCount + 1

	print( "[wOS-DynaBase] Registered new animation source: " .. data.Name )

	if data.PreventActivities then
		self:FixActivities( data )
	end

	if CLIENT then
		if data.IconOverwrite then
			self.Registers[ data.Name ].IconOverwrite = Material( data.IconOverwrite, "unlitgeneric" )
		end
		return
	end

	if not self.InitCompleted then return end
	net.Start( "wOS.DynaBase.SendRegister" )
		net.WriteString( data.Name )
	net.Broadcast()
end

function wOS.DynaBase:ProcessLoadOrder()
	if self.EnforceCount < 1 then self.FilteredLoadOrder = {} return end

	// Initialize it here so it can fail later
	self.FilteredLoadOrder[ WOS_DYNABASE.MALE ] = {}
	self.FilteredLoadOrder[ WOS_DYNABASE.FEMALE ] = {}
	self.FilteredLoadOrder[ WOS_DYNABASE.ZOMBIE ] = {}
	self.FilteredLoadOrder[ WOS_DYNABASE.SHARED ] = {}

	for _, name in ipairs( self.EnforcedOrder ) do
		local data = self:GetSource( name )
		if not data then continue end

		if data.Shared then
			table.insert( self.FilteredLoadOrder[ WOS_DYNABASE.SHARED ], data.Shared )
		end

		if data.Male then
			table.insert( self.FilteredLoadOrder[ WOS_DYNABASE.MALE ], data.Male )
		end

		if data.Female then
			table.insert( self.FilteredLoadOrder[ WOS_DYNABASE.FEMALE ], data.Female )
		end

		if data.Zombie then
			table.insert( self.FilteredLoadOrder[ WOS_DYNABASE.ZOMBIE ], data.Zombie )
		end
	end
end

function wOS.DynaBase:ProcessPlayerOrder()
	if self.PlayerCount < 1 then 
		self.FilteredPlayerBlacklist = {} 
		self.FilteredPlayerOrder = {} 
		return 
	end

	// Initialize it here so it can fail later
	self.FilteredPlayerOrder[ WOS_DYNABASE.MALE ] = {}
	self.FilteredPlayerOrder[ WOS_DYNABASE.FEMALE ] = {}
	self.FilteredPlayerOrder[ WOS_DYNABASE.ZOMBIE ] = {}
	self.FilteredPlayerOrder[ WOS_DYNABASE.SHARED ] = {}

	self.FilteredPlayerBlacklist[ WOS_DYNABASE.MALE ] = {}
	self.FilteredPlayerBlacklist[ WOS_DYNABASE.FEMALE ] = {}
	self.FilteredPlayerBlacklist[ WOS_DYNABASE.ZOMBIE ] = {}
	self.FilteredPlayerBlacklist[ WOS_DYNABASE.SHARED ] = {}

	for _, dt in ipairs( self.PlayerOrder ) do
		local name = dt.Name
		local data = self:GetSource( name )
		if not data then continue end

		if data.Shared then
			table.insert( ( !dt.Toggled and self.FilteredPlayerBlacklist[ WOS_DYNABASE.SHARED ] ) or self.FilteredPlayerOrder[ WOS_DYNABASE.SHARED ], data.Shared )
		end

		if data.Male then
			table.insert( ( !dt.Toggled and self.FilteredPlayerBlacklist[ WOS_DYNABASE.MALE ] ) or self.FilteredPlayerOrder[ WOS_DYNABASE.MALE ], data.Male )
		end

		if data.Female then
			table.insert( ( !dt.Toggled and self.FilteredPlayerBlacklist[ WOS_DYNABASE.FEMALE ] ) or self.FilteredPlayerOrder[ WOS_DYNABASE.FEMALE ], data.Female )
		end

		if data.Zombie then
			table.insert( ( !dt.Toggled and self.FilteredPlayerBlacklist[ WOS_DYNABASE.ZOMBIE ] ) or self.FilteredPlayerOrder[ WOS_DYNABASE.ZOMBIE ], data.Zombie )
		end
	end
end

function wOS.DynaBase:GetSourceCount()
	return self.RegisterCount
end

function wOS.DynaBase:GetAllSources()
	return self.Registers
end

function wOS.DynaBase:GetSource( name )
	return self.Registers[ name ]
end


// Need to register the base stuff LMAO
wOS.DynaBase:RegisterSource({
	Name = "Base Animations",
	Type = WOS_DYNABASE.REANIMATION,
	IconOverwrite = "wos/dynabase/gmod.png",
	Core = true,
	Male = "models/m_wos.mdl",
	Female = "models/f_wos.mdl",
	Zombie = "models/z_wos.mdl",
})

wOS.DynaBase:RegisterSource({
	Name = "Local Player Animations",
	Type = WOS_DYNABASE.REANIMATION,
	IconOverwrite = "wos/dynabase/local.png",
	Core = true,
	Male = "data/wos/dynabase/local_male" .. WOS_DYNABASE_FILE_EXTENSION,
	Female = "data/wos/dynabase/local_female" .. WOS_DYNABASE_FILE_EXTENSION,
	Zombie = "data/wos/dynabase/local_zombie" .. WOS_DYNABASE_FILE_EXTENSION,
	Shared = "data/wos/dynabase/local_shared" .. WOS_DYNABASE_FILE_EXTENSION,
})

--PATH lua/wos/dynabase/core/cl_local_copy.lua:
return gluapack()()
--PATH lua/wos/dynabase/registers/bs_register.lua:
return gluapack()()
--PATH lua/wos/dynabase/registers/wos_legacy_registers.lua:
return gluapack()()
--PATH lua/xeninui/libs/v0n_sh.lua:
local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable
local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next





function d_findVariable(s, i, len, lastType, jobstate)
	local i, c, typeRead, val = i or 1


	while true do

		if i > len then
			error("vON: Reached end of string, cannot form proper variable.")
		end


		c = sub(s, i, i)


		if typeRead then

			val, i = _deserialize[lastType](s, i, len, false, jobstate)

			return val, i, lastType


		elseif c == "@" then
			return nil, i, lastType


		elseif c == "$" then
			lastType = "table_reference"
			typeRead = true


		elseif c == "n" then
			lastType = "number"
			typeRead = true


		elseif c == "b" then
			lastType = "boolean"
			typeRead = true


		elseif c == "'" then
			lastType = "string"
			typeRead = true


		elseif c == "\"" then
			lastType = "oldstring"
			typeRead = true


		elseif c == "{" then
			lastType = "table"
			typeRead = true





		elseif c == "e" then
			lastType = "Entity"
			typeRead = true





		elseif c == "p" then
			lastType = "Entity"
			typeRead = true


		elseif c == "v" then
			lastType = "Vector"
			typeRead = true


		elseif c == "a" then
			lastType = "Angle"
			typeRead = true





		elseif lastType then
			val, i = _deserialize[lastType](s, i, len, false, jobstate)
			return val, i, lastType


		else
			error("vON: Malformed data... Can't find a proper type definition. Char#" .. i .. ":" .. c)
		end


		i = i + 1
	end
end



function s_anyVariable(data, lastType, isNumeric, isKey, isLast, jobstate)
	local tp = type(data)

	if jobstate[1] and jobstate[2][data] then
		tp = "table_reference"
	end


	if lastType ~= tp then

		lastType = tp

		if _serialize[lastType] then


			return _serialize[lastType](data, true, isNumeric, isKey, isLast, false, jobstate), lastType
		else
			error("vON: No serializer defined for type \"" .. lastType .. "\"!")
		end
	end


	return _serialize[lastType](data, false, isNumeric, isKey, isLast, false, jobstate), lastType
end





_deserialize = {


	["table"] = function(s, i, len, unnecessaryEnd, jobstate)
		local ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1, nil, nil, nil, 1


		if sub(s, i, i) == "#" then
			local e = find(s, "#", i + 2, true)

			if e then
				local id = tonumber(sub(s, i + 1, e - 1))

				if id then
					if jobstate[1][id] and not jobstate[2] then
						error("vON: There already is a table of reference #" .. id .. "! Missing an option maybe?")
					end

					jobstate[1][id] = ret

					i = e + 1
				else
					error("vON: Malformed table! Reference ID starting at char #" .. i .. " doesn't contain a number!")
				end
			else
				error("vON: Malformed table! Cannot find end of reference ID start at char #" .. i .. "!")
			end
		end


		while true do

			if i > len then

				if unnecessaryEnd then
					return ret, i


				else
					error("vON: Reached end of string, incomplete table definition.")
				end
			end


			c = sub(s, i, i)



			if c == "}" then
				return ret, i


			elseif c == "~" then
				numeric = false

			elseif c == ";" then elseif numeric then

				val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)

				ret[ind] = val

				ind = ind + 1


			else

				if expectValue then

					val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)

					ret[key] = val

					expectValue, key = false, nil


				elseif c == ":" then

					expectValue = true


				elseif key then

					error("vON: Malformed table... Two keys declared successively? Char#" .. i .. ":" .. c)


				else

					key, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
				end
			end

			i = i + 1
		end

		return nil, i
	end,


	["table_reference"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1


		a = find(s, "[;:}~]", i)

		if a then
			local n = tonumber(sub(s, i, a - 1))

			if n then
				return jobstate[1][n] or error("vON: Table reference does not point to a (yet) known table!"), a - 1
			else
				error("vON: Table reference definition does not contain a valid number!")
			end
		end



		error("vON: Number definition started... Found no end.")
	end,





	["number"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1


		a = find(s, "[;:}~]", i)

		if a then
			return tonumber(sub(s, i, a - 1)) or error("vON: Number definition does not contain a valid number!"), a - 1
		end



		error("vON: Number definition started... Found no end.")
	end,




	["boolean"] = function(s, i, len, unnecessaryEnd, jobstate)
		local c = sub(s, i, i)



		if c == "1" then
			return true, i


		elseif c == "0" then
			return false, i
		end


		error("vON: Invalid value on boolean type... Char#" .. i .. ": " .. c)
	end,



	["oldstring"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1


		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 2), a
				end
			else
				error("vON: Old string definition started... Found no end.")
			end
		end
	end,


	["string"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1


		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 1), a
				end
			else
				error("vON: String definition started... Found no end.")
			end
		end
	end
}



_serialize = {




	["table"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)


		local result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0




		for k, v in next, data do

			if type(k) ~= "number" or k < 1 or k > len or (k % 1 ~= 0) then
				keyvals[#keyvals + 1] = k
			end
		end

		keyvalsLen = #keyvals


		if not first then
			result[#result + 1] = "{"
		end

		if jobstate[1] and jobstate[1][data] then
			if jobstate[2][data] then
				error("vON: Table #" .. jobstate[1][data] .. " written twice..?")
			end

			result[#result + 1] = "#"
			result[#result + 1] = jobstate[1][data]
			result[#result + 1] = "#"

			jobstate[2][data] = true
		end


		if len > 0 then
			for i = 1, len do
				val, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, jobstate)
				result[#result + 1] = val
			end
		end


		if keyvalsLen > 0 then

			result[#result + 1] = "~"


			for _i = 1, keyvalsLen do
				keyvalsProgress = keyvalsProgress + 1

				val, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, jobstate)

				result[#result + 1] = val .. ":"

				val, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, jobstate)

				result[#result + 1] = val
			end
		end


		if not first then
			result[#result + 1] = "}"
		end

		return concat(result)
	end,


	["table_reference"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		data = jobstate[1][data]


		if mustInitiate then
			if isKey or isLast then
				return "$" .. data
			else
				return "$" .. data .. ";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data .. ";"
		end
	end,




	["number"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)

		if mustInitiate then
			if isKey or isLast then
				return "n" .. data
			else
				return "n" .. data .. ";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data .. ";"
		end
	end,



	["string"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		if sub(data, #data, #data) == "\\" then
			return "\"" .. gsub(data, "\"", "\\\"") .. "v\""
		end

		return "'" .. gsub(data, "\"", "\\\"") .. "\""
	end,



	["boolean"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)

		if mustInitiate then
			if data then
				return "b1"
			else
				return "b0"
			end
		end

		if data then
			return "1"
		else
			return "0"
		end
	end,



	["nil"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		return "@"
	end
}





if gmod then
	local Entity = Entity



	local extra_deserialize = {


		["Entity"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a = i or 1


			a = find(s, "[;:}~]", i)

			if a then
				return Entity(tonumber(sub(s, i, a - 1))), a - 1
			end

			error("vON: Entity ID definition started... Found no end.")
		end,



		["Vector"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, x, y, z = i or 1


			a = find(s, ",", i)

			if a then
				x = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				z = tonumber(sub(s, i, a - 1))
			end

			if x and y and z then
				return Vector(x, y, z), a - 1
			end

			error("vON: Vector definition started... Found no end.")
		end,



		["Angle"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, p, y, r = i or 1


			a = find(s, ",", i)

			if a then
				p = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				r = tonumber(sub(s, i, a - 1))
			end

			if p and y and r then
				return Angle(p, y, r), a - 1
			end

			error("vON: Angle definition started... Found no end.")
		end
	}

	local extra_serialize = {

		["Entity"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			data = data:EntIndex()

			if mustInitiate then
				if isKey or isLast then
					return "e" .. data
				else
					return "e" .. data .. ";"
				end
			end

			if isKey or isLast then
				return data
			else
				return data .. ";"
			end
		end,



		["Vector"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "v" .. data.x .. "," .. data.y .. "," .. data.z
				else
					return "v" .. data.x .. "," .. data.y .. "," .. data.z .. ";"
				end
			end

			if isKey or isLast then
				return data.x .. "," .. data.y .. "," .. data.z
			else
				return data.x .. "," .. data.y .. "," .. data.z .. ";"
			end
		end,



		["Angle"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "a" .. data.p .. "," .. data.y .. "," .. data.r
				else
					return "a" .. data.p .. "," .. data.y .. "," .. data.r .. ";"
				end
			end

			if isKey or isLast then
				return data.p .. "," .. data.y .. "," .. data.r
			else
				return data.p .. "," .. data.y .. "," .. data.r .. ";"
			end
		end
	}

	for k, v in pairs(extra_serialize) do
		_serialize[k] = v
	end

	for k, v in pairs(extra_deserialize) do
		_deserialize[k] = v
	end

	local extraEntityTypes = {
		"Vehicle",
		"Weapon",
		"NPC",
		"Player",
		"NextBot"
	}

	for i = 1, #extraEntityTypes do
		_serialize[extraEntityTypes[i]] = _serialize.Entity
	end
end





local function checkTableForRecursion(tab, checked, assoc)
	local id = checked.ID

	if not checked[tab] and not assoc[tab] then
		assoc[tab] = id
		checked.ID = id + 1
	else
		checked[tab] = true
	end

	for k, v in pairs(tab) do
		if type(k) == "table" and not checked[k] then
			checkTableForRecursion(k, checked, assoc)
		end

		if type(v) == "table" and not checked[v] then
			checkTableForRecursion(v, checked, assoc)
		end
	end
end



local _s_table = _serialize.table
local _d_table = _deserialize.table

_d_meta = {
__call = function(self, str, allowIdRewriting)
	if type(str) == "string" then
		return _d_table(str, nil, #str, true, {
			{},
			allowIdRewriting
		})
	end

	error("vON: You must deserialize a string, not a " .. type(str))
end
}
_s_meta = {
__call = function(self, data, checkRecursion)
	if type(data) == "table" then
		if checkRecursion then
			local assoc, checked = {}, {
			ID = 1 }

			checkTableForRecursion(data, checked, assoc)

			return _s_table(data, nil, nil, nil, nil, true, {
				assoc,
				{}
			})
		end

		return _s_table(data, nil, nil, nil, nil, true, {
		false })
	end

	error("vON: You must serialize a table, not a " .. type(data))
end
}



von = {
	version = "1.3.4",
	versionNumber = 1003004,

	deserialize = setmetatable(_deserialize, _d_meta),
	serialize = setmetatable(_serialize, _s_meta)
}



return von

--PATH lua/xeninui/libs/scripts/main.lua:
local Scripts
do
  local _class_0
  local _base_0 = {
    __name = "Scripts",
    checkScriptVersions = function(self, tbl)
      local scripts = self:getAll()
      local needUpdate = {}

      for i, v in pairs(scripts) do
        if (!v.versionCheck) then continue end

        local tblVersion = tbl[v.id]
        local version = tonumber(v.version)
        if (!isnumber(version)) then continue end
        if (!isnumber(tblVersion)) then continue end

        if (tblVersion and version < tblVersion) then
          needUpdate[v.id] = {
            name = v.name,
            version = tblVersion,
            currentVersion = v.version
          }
        end
      end

      local msgs = {}
      for i, v in pairs(needUpdate) do
        table.insert(msgs, {
          XeninUI.Theme.Accent,
          "[Xenin " .. tostring(v.name) .. "] ",
          Color(255, 255, 255),
          "Please update to ",
          XeninUI.Theme.Green,
          "version " .. tostring(v.version),
          Color(255, 255, 255),
          " you are on ",
          XeninUI.Theme.Red,
          "version " .. tostring(v.currentVersion)
        })
      end
      local targets = {}
      for i, v in ipairs(player.GetAll()) do
        if (XeninUI.Permissions:canAccessFramework(v) or XeninUI.Permissions:isAdmin(v)) then
          table.insert(targets, v)
        end
      end

      XeninUI.ScriptsNetwork:sendUpdateMessage(targets, msgs)

      for i, v in ipairs(msgs) do
        table.insert(v, "\n")

        MsgC(unpack(v))
      end
    end,
    register = function(self, id, name, version, author, tbl)
      if tbl == nil then tbl = {}
      end
      local script = {
        id = id,
        name = name,
        author = author,
        version = version
      }

      table.Merge(script, tbl)

      self.scripts[id] = script
    end,
    setAll = function(self, tbl)
      self.scripts = tbl
    end,
    get = function(self, id)
      return self.scripts[id]
    end,
    getAll = function(self)
      return self.scripts
    end,
    getByName = function(self, name)
      for i, v in pairs(self.scripts) do
        if (v.name != name) then continue end

        return name
      end
    end,
    __type = function(self)
      return "XeninUI.Scripts"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.scripts = {}
      if (CLIENT) then return end

      timer.Create("Xenin.Framework.Version", 600, 0, function()
        http.Fetch("https://gitlab.com/sleeppyy/xenin-version-tracker/-/raw/master/versions.json", function(body, size, headers, code)
          if (code >= 400) then return end
          if (size == 0) then return end
          local tbl = util.JSONToTable(body)
          if (!tbl) then return end

          self:checkScriptVersions(tbl)
        end)
      end)
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Scripts = _class_0
end

XeninUI.Scripts = Scripts()

--PATH lua/xeninui/libs/scripts/network/client.lua:
local ScriptsNetwork
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "ScriptsNetwork",
    __base = XeninUI.Network.__base,
    receiveScripts = function(self, ply)
      local scripts = self:decompress()
      XeninUI.Scripts:setAll(scripts)

      hook.Run("Xenin.Framework.ReceivedScripts", scripts)
    end,
    receiveUpdateScripts = function(self, ply)
      local tbl = self:decompress()
      for i, v in ipairs(tbl) do
        chat.AddText(unpack(v))
      end
    end,
    requestScripts = function(self)
      if self.SentScriptsRequest then
        hook.Run("Xenin.Framework.ReceivedScripts", XeninUI.Scripts:getAll())

        return
      end

      self.SentScriptsRequest = true

      self:sendRequestScripts()
    end,
    sendRequestScripts = function(self)
      self:send("Xenin.Framework.Scripts", function(self) end)
    end,
    __type = function(self)
      return "XeninUI.ScriptsNetwork"end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self)
      ScriptsNetwork.__parent.__init(self)

      self:receiver("Xenin.Framework.Scripts", self.receiveScripts)
      self:receiver("Xenin.Framework.UpdateScriptsMessage", self.receiveUpdateScripts)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  ScriptsNetwork = _class_0
end

XeninUI.ScriptsNetwork = ScriptsNetwork()

--PATH lua/xeninui/libs/configurator/classes/entities.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/entities/entity_list.lua:
local PANEL = {}

local matArrow = Material("xenin/next.png", "smooth")

XeninUI:CreateFont("Xenin.Configurator.Row.Title", 20)
XeninUI:CreateFont("Xenin.Configurator.Row.Subtitle", 14)

function PANEL:Init()
  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)

  self.Body = self.Scroll:Add("Panel")

  self.Save.DoClick = function(pnl)
    for _, row in pairs(self.Rows) do
      row.Entity:save(true)
    end
  end
end

function PANEL:SetData(tbl)
  assert(tbl ~= nil, "cannot destructure nil value")
  local __entity, name, script = tbl.__entity, tbl.name, tbl.script

  self:SetScript(script)
  self.Entity = __entity
  self:SetTitle(name)

  self.Navbar:SetVisible(false)
  self.Template = XeninUI.Configurator.Entities:get(self.Entity)
  self.BaseEnt = XeninUI.Configurator.Entities:create(self.Entity)

  if (!self.Template.getListView) then
    error("To use a list you need to implement a static getListView function for your model")
  end

  self.New = self.Body:Add("DButton")
  self.New:Dock(TOP)
  self.New:DockMargin(0, 0, 0, 12)
  self.New:SetText("")
  self.New:SetTall(48)
  self.New.Color = XeninUI.Theme.Background
  self.New.OutlineColor = XeninUI.Theme.Primary
  self.New.TextColor = Color(174, 174, 174)
  self.New.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Color)

    XeninUI:MaskInverse(function()
      XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, pnl.OutlineColor)
    end, function()
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.OutlineColor)
    end)

    draw.SimpleText("Create New", "Xenin.Configurator.Row.Title", w / 2, h / 2, pnl.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  end
  self.New.OnCursorEntered = function(pnl)
    pnl:LerpColor("OutlineColor", XeninUI.Theme.Green)
    pnl:LerpColor("TextColor", color_white)
  end
  self.New.OnCursorExited = function(pnl)
    pnl:LerpColor("OutlineColor", XeninUI.Theme.Primary)
    pnl:LerpColor("TextColor", Color(174, 174, 174))
  end
  self.New.DoClick = function(pnl)
    self.Body.Alpha = self.Body.Alpha || 255
    self.Body:LerpAlpha(0, 0.15, function()
      self.Body:SetAlpha(0)
      self:CreateNew(self.Template)
    end)
  end

  self.ToDelete = {}

  local rows = self.Template.getAllEntities()
  self.Rows = {}
  self.RowsIds = {}
  for i, v in pairs(rows) do
    self:CreateRow(v, i)
  end
end

function PANEL:CreateNew()
  local entity = XeninUI.Configurator.Entities:create(self.Entity)

  for i, v in pairs(self.Rows) do
    if (!IsValid(v)) then continue end

    v:SetVisible(false)
  end
  self.New:SetVisible(false)

  if IsValid(self.ListBody) then self.ListBody:Remove()end

  self.Body:LerpAlpha(255, 0.15, function()
    self.Body:SetAlpha(255)
  end)

  self.ListBody = self.Body:Add("Panel")
  self.ListBody.Alpha = 0
  self.ListBody:LerpAlpha(255, nil, function()
    self.ListBody:SetAlpha(255)
  end)
  self.ListBody:Dock(TOP)
  self.ListBody.Rows = {}

  self.ListBody.Header = self.ListBody:Add("Panel")
  self.ListBody.Header:Dock(TOP)
  self.ListBody.Header:DockMargin(0, 0, 0, 8)
  self.ListBody.Header:SetTall(32)
  self.ListBody.Header.Paint = function(pnl, w, h)
    draw.SimpleText(self.Template.selectRowString or "Select a row", "Xenin.Configurator.Row.Title", 8, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end

  self.ListBody.Header.Back = self.ListBody.Header:Add("XeninUI.ButtonV2")
  self.ListBody.Header.Back:Dock(RIGHT)
  self.ListBody.Header.Back:DockMargin(0, 6, 6, 0)
  self.ListBody.Header.Back:SetText("")
  self.ListBody.Header.Back:SetSolidColor(XeninUI.Theme.Primary)
  self.ListBody.Header.Back:SetRoundness(6)
  self.ListBody.Header.Back.Text = "Go Back"
  self.ListBody.Header.Back.PaintOver = function(pnl, w, h)
    surface.SetMaterial(matArrow)
    surface.SetDrawColor(color_white)
    local size = h - 14
    surface.DrawTexturedRectRotated(size, h / 2, size, size, 180)

    draw.SimpleText(pnl.Text, "Xenin.Configurator.Row.Subtitle", size * 1.75, h / 2, Color(174, 174, 174), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  surface.SetFont("Xenin.Configurator.Row.Subtitle")
  local tw = surface.GetTextSize(self.ListBody.Header.Back.Text)
  self.ListBody.Header.Back:SetWide((14 * 1.75) + tw + 8)
  self.ListBody.Header.Back.HasClicked = false
  self.ListBody.Header.Back.DoClick = function(pnl)
    if (pnl.HasClicked) then return end
    pnl.HasClicked = true

    self.ListBody:LerpAlpha(0, 0.15, function()
      self.ListBody:Remove()
      self.Body.Alpha = 0
      self.Body:LerpAlpha(255, 0.15)

      for i, v in pairs(self.Rows) do
        if (!IsValid(v)) then continue end

        v:SetVisible(true)
      end
      self.New:SetVisible(true)
      self:InvalidateLayout(true)
    end)
  end

  for i, v in ipairs(self.Template.getGridContent()) do
    local data = self.Template.getGridData(v)
    if (!data) then continue end
    local ent = XeninUI.Configurator.Entities:create(self.Entity)
    self.Template.gridSetDefaultData(ent, data, i)
    if (self.RowsIds[ent:getId()]) then continue end
    local search = self.Template.getListView(ent).search

    local row = self.ListBody:Add("Xenin.Configurator.Admin.EntityList.Row")
    row:Dock(TOP)
    row:DockMargin(0, 0, 0, 4)
    row:SetTall(56)
    row.DeleteDisabled = true
    row:SetEntity(ent, self.Template, true)
    row.Search = search or function(pnl, text)
      return pnl.Entity:getId():lower():find(text)
    end

    row.Edit:SetText("Select")
    row.Edit:SetSolidColor(XeninUI.Theme.OrangeRed)
    row.Edit.DoClick = function(pnl)
      self.ListBody:LerpAlpha(0, 0.15, function()
        self.ListBody:Remove()
        local newId = #self.Rows + 1
        self:CreateRow(row.Entity, newId)
        self:SwitchToEdit(row.Entity, self.Rows[newId], true)
        self:InvalidateLayout(true)
      end)
    end

    table.insert(self.ListBody.Rows, row)
  end

  self.ListBody.PerformLayout = function(pnl, w, h)
    pnl:SizeToChildren(false, true)
  end

  self:InvalidateLayout(true)
end

function PANEL:SwitchToEdit(entity, parent, isNew)
  local copy = table.Copy(entity)

  for i, v in pairs(self.Rows) do
    if (!IsValid(v)) then continue end

    v:SetVisible(false)
  end
  self.New:SetVisible(false)

  if IsValid(self.SettingsPanel) then self.SettingsPanel:Remove()end

  self.Body:LerpAlpha(255, 0.15, function()
    self.Body:SetAlpha(255)
  end)

  self.SettingsPanel = self.Body:Add("Xenin.Configurator.Admin.Entity.Row.Settings")
  self.SettingsPanel:DockMargin(0, 0, 0, 0)
  self.SettingsPanel.FadeOut = function(pnl)
    self.Body:LerpAlpha(0, 0.15, function()
      self.Body:SetAlpha(0)
      self.SettingsPanel:Remove()

      self.Body:LerpAlpha(255, 0.15, function()
        self.Body:SetAlpha(255)
      end)
      for i, v in pairs(self.Rows) do
        if (!IsValid(v)) then continue end

        v:SetVisible(true)
      end
      self.New:SetVisible(true)
      self:InvalidateLayout(true)
    end)
  end

  self.SettingsPanel.Header = self.SettingsPanel:Add("Panel")
  self.SettingsPanel.Header:Dock(TOP)
  self.SettingsPanel.Header:DockMargin(0, 0, 0, 8)
  self.SettingsPanel.Header:SetTall(32)
  self.SettingsPanel.Header.Text = isNew and "Creating New Object" or "Editing Object"
  self.SettingsPanel.Header.Paint = function(pnl, w, h)
    draw.SimpleText(pnl.Text, "Xenin.Configurator.Row.Title", 8, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end

  self.SettingsPanel.Header.Back = self.SettingsPanel.Header:Add("XeninUI.ButtonV2")
  self.SettingsPanel.Header.Back:Dock(RIGHT)
  self.SettingsPanel.Header.Back:DockMargin(0, 6, 6, 0)
  self.SettingsPanel.Header.Back:SetText("")
  self.SettingsPanel.Header.Back:SetSolidColor(XeninUI.Theme.Primary)
  self.SettingsPanel.Header.Back:SetRoundness(6)
  self.SettingsPanel.Header.Back.Text = isNew and "Cancel" or "Go Back"
  self.SettingsPanel.Header.Back.PaintOver = function(pnl, w, h)
    surface.SetMaterial(matArrow)
    surface.SetDrawColor(color_white)
    local size = h - 14
    surface.DrawTexturedRectRotated(size, h / 2, size, size, 180)

    draw.SimpleText(pnl.Text, "Xenin.Configurator.Row.Subtitle", size * 1.75, h / 2, Color(174, 174, 174), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  surface.SetFont("Xenin.Configurator.Row.Subtitle")
  local tw = surface.GetTextSize(self.SettingsPanel.Header.Back.Text)
  self.SettingsPanel.Header.Back:SetWide((14 * 1.75) + tw + 8)
  self.SettingsPanel.Header.Back.DoClick = function(pnl)
    if isNew then
      local foundAt
      for i, v in ipairs(self.Rows) do
        if (v.Id != parent.Id) then continue end

        v:Remove()

        foundAt = i
      end
      if foundAt then
        table.remove(self.Rows, foundAt)

        parent:Remove()
      end

      self.SettingsPanel:LerpAlpha(0, 0.15, function()
        self.SettingsPanel:Remove()
        self:CreateNew()
        self:InvalidateLayout(true)
      end)
    else
      self.SettingsPanel:FadeOut()
    end
  end

  self.SettingsPanel.Top = self.SettingsPanel:Add("Xenin.Configurator.Admin.EntityList.Row")
  self.SettingsPanel.Top:Dock(TOP)
  self.SettingsPanel.Top:DockMargin(0, 0, 0, 4)
  self.SettingsPanel.Top:SetTall(56)
  self.SettingsPanel.Top.DeleteDisabled = true
  self.SettingsPanel.Top:SetEntity(entity, self.Template)

  self.SettingsPanel.Top.Edit:SetText(isNew and "Create" or "Save")
  self.SettingsPanel.Top.Edit.DoClick = function(pnl, w, h)
    parent:SetEntity(copy, self.Template)


    self.SettingsPanel:FadeOut()
  end

  self.SettingsPanel:AddSettings(entity)
  self.SettingsPanel.OnValueChanged = function(pnl)
    local settings = pnl:GetSettings()
    for i, v in pairs(settings) do
      copy["set" .. tostring(i)](copy, v)
    end

    pnl.Top:SetEntity(copy, self.Template)
    pnl.Top:InvalidateLayout(true)

  end

  self.SettingsPanel:Dock(TOP)
  self.SettingsPanel.GetChildSize = function(pnl)
    local height = 0
    local size = 0
    for i, v in ipairs(pnl.Settings) do
      if (!v:IsVisible()) then continue end

      size = size + 1
      height = height + v:GetTall()
    end
    height = height - (size * 3)

    return height + 8 + pnl.Top:GetTall() + 8 + 40
  end

  self:InvalidateLayout(true)
end

function PANEL:CreateRow(entity, index)
  local listView = self.Template.getListView(entity)
  if (!listView) then return end
  assert(listView ~= nil, "cannot destructure nil value")
  local height, search = listView.height, listView.search

  self.RowsIds[entity:getId()] = true

  local row = self.Body:Add("Xenin.Configurator.Admin.EntityList.Row")
  row:Dock(TOP)
  row:DockMargin(0, 0, 0, 4)
  row:SetTall(height or 56)
  row.Id = index
  row:SetEntity(entity, self.Template)
  row.DoClick = function(pnl)
    self.Body.Alpha = 255
    self.Body:LerpAlpha(0, 0.15, function()
      self.Body:SetAlpha(0)
      self:SwitchToEdit(pnl.Entity, pnl)
    end)
  end
  row.OnRemove = function(pnl)
    self.RowsIds[pnl.Entity:getId()] = nil end
  row.OnDelete = function(pnl)
    XeninUI:SimpleQuery("Delete", "Are you sure you want to delete this?", "Yes", function()
      local foundAt
      for i, v in ipairs(self.Rows) do
        if (v.Id != pnl.Id) then continue end

        v:Remove()

        foundAt = i
      end
      if (!foundAt) then return end

      table.remove(self.Rows, foundAt)

      self.RowsIds[pnl.Entity:getId()] = nil
      pnl.Entity:delete(true)

      pnl:Remove()
    end, "No", function() end)
  end
  row.Search = search or function(pnl, text)
    return pnl.Entity:getId():lower():find(text)
  end

  table.insert(self.Rows, row)
end

function PANEL:OnSearch(text)
  text = text:lower()

  local panels = self.Rows
  if IsValid(self.ListBody) then
    panels = self.ListBody.Rows
  end
  if (IsValid(self.SettingsPanel)) then return end

  for i, v in pairs(panels) do
    local result = v:Search(text)
    v:SetVisible(result)
  end

  self:InvalidateLayout(true)

  if IsValid(self.ListBody) then
    self.ListBody:InvalidateLayout(true)
    self.ListBody:SizeToChildren(false, true)
  end
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  self.Body:SetWide(math.min(600, w))
  self.Body:CenterHorizontal()
  self.Body:SizeToChildren(false, true)

  if (!IsValid(self.SettingsPanel)) then return end

  self.SettingsPanel:SetTall(self.SettingsPanel:GetChildSize())
end

vgui.Register("Xenin.Configurator.Admin.EntityList", PANEL, "Xenin.Configurator.Admin.Panel")

--PATH lua/xeninui/libs/configurator/ui/entities/row_settings.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/entities/settings_base.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/entities/settings_base.lua:
local PANEL = {}

XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting", 18)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting.Italic", 18, nil, {
italic = true
})

function PANEL:Init()
  self:Dock(TOP)
  self:DockMargin(0, 48, 0, 0)
  self:DockPadding(0, 0, 0, 0)

  self.Settings = {}
end

function PANEL:AddSettings() end

function PANEL:AddSetting(id, name, type, tbl)
  if tbl == nil then tbl = {}
  end
  tbl.data = tbl.data or {}

  local panel = self:Add("DPanel")
  panel.Id = id
  panel:Dock(TOP)
  panel:SetTall(48)
  panel:DockMargin(0, 0, 0, -4)
  panel.Paint = function(pnl, w, h)
    draw.SimpleText(name, "Xenin.Configurator.Admin.Panel.Setting", 8, 48 / 2, Color(145, 145, 145), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  panel.PerformLayout = function(pnl, w, h)
    if IsValid(panel.Overlay) then
      panel.Overlay:SetSize(w, h)
    end
  end

  if tbl.readOnly then
    panel.Overlay = panel:Add("DPanel")
    panel.Overlay:SetZPos(2)
    panel.Overlay.Color = ColorAlpha(XeninUI.Theme.Navbar, 150)
    panel.Overlay.Paint = function(pnl, w, h)
      XeninUI:DrawRoundedBox(6, 0, 8, w, h - 16, pnl.Color)

      if (!pnl:IsHovered()) then return end

      draw.SimpleText("Read only", "Xenin.Configurator.Admin.Panel.Setting", w / 2, h / 2, XeninUI.Theme.Red, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
  end
  if tbl.hide then
    panel:SetVisible(false)
  end

  local input = XeninUI.Configurator:CreateInputPanel(type, self, tbl, {
    id = id,
    name = name,
    type = type,
    parent = panel
  })
  input:Dock(RIGHT)
  input:SetParent(panel)
  if (input.SetData and tbl.data) then
    input:SetData(tbl.data)
  end
  if (input.SetInput and tbl.value) then
    input:SetInput(tbl.value)
  end
  if tbl.func then
    tbl.func(input)
  end
  if tbl.fetch then
    tbl.fetch(input)
  end
  input.onChange = function(pnl, ...)
    if (!isfunction(tbl.onChange)) then return end

    tbl.onChange(pnl, ...)
  end
  panel.Input = input

  table.insert(self.Settings, panel)
end

function PANEL:GetSettings()
  local tbl = {}
  for i, v in ipairs(self.Settings) do
    tbl[v.Id] = v.Input:GetSettingValue()
  end

  return tbl
end

function PANEL:Paint(w, h)
  surface.SetDrawColor(100, 100, 100)
  surface.DrawLine(1, h - 1, w - 1, h - 1)
end

vgui.Register("Xenin.Configurator.Admin.SettingsBase", PANEL, "DPanel")

--PATH lua/xeninui/libs/configurator/ui/inputs/color.lua:
local x

--PATH lua/xeninui/libs/configurator/ui/inputs/popup.lua:
local x

--PATH lua/xeninui/libs/configurator/ui/inputs/range.lua:
local x

--PATH lua/xeninui/libs/configurator/ui/inputs/sliderpad.lua:
return gluapack()()
--PATH lua/xeninui/libs/players/notification.lua:
return gluapack()()
--PATH lua/xeninui/libs/players/notification.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
local Types
do
  local _class_0
  local _base_0 = {
    __name = "Types",
    _getId = function(self, scriptId, typeId)
      return scriptId .. "_" .. typeId
    end,
    set = function(self, scriptId, typeId, data)
      self.cache[self:_getId(scriptId, typeId)] = data
    end,
    get = function(self, scriptId, typeId)
      return self.cache[self:_getId(scriptId, typeId)]
    end,
    getAll = function(self)
      return self.cache
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.cache = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Types = _class_0
end
local Builder
do
  local _class_0
  local _base_0 = {
    __name = "Builder",
    setSteamID64 = function(self, sid64)
      self.sid64 = sid64

      return self
    end,
    setPlayer = function(self, ply)
      self:setSteamID64(ply:SteamID64())

      return self
    end,
    setScript = function(self, scriptId)
      self.scriptId = scriptId

      return self
    end,
    setType = function(self, typeId)
      self.type = typeId

      return self
    end,
    setContent = function(self, content)
      self.content = content

      return self
    end,
    setData = function(self, data)
      self.data = data

      return self
    end,
    send = function(self)
      self.parent:addNotification(__laux_concat_0(self))

      return self
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, parent)
      self.parent = parent
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Builder = _class_0
end
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Notification",
    builder = function(self)
      return Builder(self)
    end,
    addType = function(self, scriptId, id, data)
      if data == nil then data = {}
      end
      self.types:set(scriptId, id, data)
    end,
    getType = function(self, scriptId, id)
      return self.types:get(scriptId, id)
    end,
    addNotification = function(self, notification)
      if SERVER then
        local db = XeninUI.Players.Database
        db:insertNotification(notification.sid64, notification.scriptId, notification.type, notification.content, notification.data)

        local ply = player.GetBySteamID64(notification.sid64)
        XeninUI.Players.Network:sendNotification(ply, notification)
      else
        error("missing impl")
      end
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.types = Types()
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Notification = _class_0()
end

--PATH lua/xeninui/libs/players/network/client.lua:
return gluapack()()
--PATH lua/xeninui/elements/category.lua:
XeninUI:CreateFont("XeninUI.Category.Title", 20)

XENINUI_LAYOUT_GRID = 1
XENINUI_LAYOUT_ROW = 2

local PANEL = {}

AccessorFunc(PANEL, "m_topHeight", "TopHeight")
AccessorFunc(PANEL, "m_expanded", "Expanded")
AccessorFunc(PANEL, "m_topColor", "TopColor")
AccessorFunc(PANEL, "m_topColorHover", "TopColorHover")
AccessorFunc(PANEL, "m_topColorActive", "TopColorActive")
AccessorFunc(PANEL, "m_topTextColor", "TopTextColor")
AccessorFunc(PANEL, "m_topTextColorHover", "TopTextColorHover")
AccessorFunc(PANEL, "m_topTextColorActive", "TopTextColorActive")
AccessorFunc(PANEL, "m_rounded", "Rounded")
AccessorFunc(PANEL, "m_icon", "Icon")
AccessorFunc(PANEL, "m_iconSize", "IconSize")
AccessorFunc(PANEL, "m_iconOffset", "IconOffset")
AccessorFunc(PANEL, "m_xOffset", "XOffset")
AccessorFunc(PANEL, "m_name", "Name")
AccessorFunc(PANEL, "m_font", "Font")
AccessorFunc(PANEL, "m_background", "BackgroundColor")
AccessorFunc(PANEL, "m_layoutType", "LayoutType")
AccessorFunc(PANEL, "m_columns", "Columns")
AccessorFunc(PANEL, "m_layoutX", "LayoutX")
AccessorFunc(PANEL, "m_layoutY", "LayoutY")
AccessorFunc(PANEL, "m_layoutPanel", "LayoutPanel")
AccessorFunc(PANEL, "m_columnHeight", "ColumnHeight")
AccessorFunc(PANEL, "m_columnGridHeight", "GridColumnHeight")
AccessorFunc(PANEL, "m_bAnimateChanges", "AnimateChanges", FORCE_BOOL)
AccessorFunc(PANEL, "m_fAnimTime", "AnimTime")
AccessorFunc(PANEL, "m_InstantExpandWidth", "InstantExpandWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_categoryColor", "CategoryColor")
AccessorFunc(PANEL, "m_border", "Border", FORCE_NUMBER)

function PANEL:Init()
  self:SetExpanded(false)
  self:SetTopHeight(48)
  self:SetTopColor(XeninUI.Theme.Primary)
  self:SetTopColorHover(Color(54, 54, 54))
  self:SetTopColorActive(Color(60, 60, 60))
  self:SetTopTextColor(Color(180, 180, 180))
  self:SetTopTextColorHover(Color(210, 210, 210))
  self:SetTopTextColorActive(color_white)
  self:SetRounded(6)
  self:SetXOffset(16)
  self:SetName("UNNAMED CATEGORY")
  self:SetFont("XeninUI.Category.Title")
  self:SetIcon(nil)
  self:SetIconSize(32)
  self:SetIconOffset(8)
  self:SetBackgroundColor(XeninUI.Theme.Navbar)
  self:SetBorder(8)
  self:SetLayoutType(XENINUI_LAYOUT_ROW)
  self:SetColumns(1)
  self:SetColumnHeight(48)
  self:SetLayoutX(8)
  self:SetLayoutY(8)
  self:SetLayoutPanel("DButton")
  self:SetInstantExpandWidth(0)

  self.Top = self:Add("DButton")
  self.Top:Dock(TOP)
  self.Top:SetText("")
  self.Top.textColor = self:GetTopTextColor()
  self.Top.background = self:GetTopColor()
  XeninUI:DownloadIcon(self.Top, "2QGKAd6")
  self.Top.rotation = 0
  self.Top.OnCursorEntered = function(pnl)
    if self:GetExpanded() then return end

    pnl:Lerp("rotation", 180)
    pnl:LerpColor("textColor", self:GetTopTextColorHover())
    pnl:LerpColor("background", self:GetTopColorHover())
  end
  self.Top.OnCursorExited = function(pnl)
    if self:GetExpanded() then return end

    pnl:Lerp("rotation", 0)
    pnl:LerpColor("textColor", self:GetTopTextColor())
    pnl:LerpColor("background", self:GetTopColor())
  end
  self.Top.Paint = function(pnl, w, h)
    local roundedBottom = self:GetTall() <= self:GetTopHeight()

    local col = self:GetCategoryColor()
    local xOffset = col and 4 or 0
    if (xOffset > 0) then
      XeninUI:DrawRoundedBoxEx(self:GetRounded(), 0, 0, w * 0.4, h, col, true, true, roundedBottom, roundedBottom)
    end
    if col then
      XeninUI:DrawRoundedBoxEx(self:GetRounded(), xOffset, 0, w - xOffset, h, pnl.background, !col, true, !col, roundedBottom)
    else
      XeninUI:DrawRoundedBoxEx(self:GetRounded(), xOffset, 0, w - xOffset, h, pnl.background, !col, true, roundedBottom, roundedBottom)
    end
    local x = self:GetXOffset()
    if self:GetIcon() then
      local iconSize = self:GetIconSize()
      surface.SetMaterial(self:GetIcon())
      surface.SetDrawColor(pnl.textColor)
      surface.DrawTexturedRect(self:GetIconOffset(), self:GetIconOffset(), iconSize, iconSize)

      x = h
    end

    draw.SimpleText(self:GetName(), self:GetFont(), x, h / 2, pnl.textColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    local size = h / 3
    XeninUI:DrawIconRotated(w - size / 2 - 16, h / 2, size, size, pnl.rotation, pnl, pnl.textColor)
  end
  self.Top.DoClick = function(pnl)
    self:Expand(!self:GetExpanded())
  end

  self:SetAnimTime(0.3)
  self:SetAnimateChanges(false)
  self:SetTall(self.Top:GetTall())
  self.animSlide = Derma_Anim("Anim", self, self.AnimSlide)
end

function PANEL:AnimSlide(anim, delta, data)
  self:InvalidateLayout()
  self:InvalidateParent()

  if anim.Started then
    if (IsValid(self.Layout) and self:GetExpanded()) then
      self.Layout:SetVisible(false)
    end

    if self:GetExpanded() then
      self:SizeToChildren(false, true)
    else
      self:SetTall(self.Top:GetTall())
    end

    data.to = self:GetTall()
  end

  self:SetTall(XeninUI:Ease(delta, data.from, data.to - data.from, 1))

  if anim.Finished then
    if (IsValid(self.Layout) and !self:GetExpanded()) then
      self.Layout:SetVisible(false)
    end

    return
  end
end

function PANEL:SetLayoutType(type)
  if IsValid(self.Layout) then
    self.Layout:Remove()
  end

  local panel = type == XENINUI_LAYOUT_GRID and "DIconLayout" or "DListLayout"
  self.Layout = self:Add(panel)
  self.Layout:Dock(FILL)
  self.Layout:DockPadding(self:GetBorder(), self:GetBorder(), self:GetBorder(), self:GetBorder())

  if (panel == "DIconLayout") then
    self.Layout:SetBorder(8)
    self.Layout:SetSpaceY(self:GetLayoutX())
    self.Layout:SetSpaceX(self:GetLayoutY())
    self.Layout.PerformLayout = function(pnl, w, h)
      local children = pnl:GetChildren()
      local count = self:GetColumns()
      local amount = math.max(1, math.floor(#children / count)) * 276
      local width = w / math.min(count, #children)

      local x = 0
      local y = 0

      local spacingX = pnl:GetSpaceX()
      local spacingY = pnl:GetSpaceY()
      local border = pnl:GetBorder()
      local innerWidth = w - border * 2 - spacingX * (count - 1)

      for i, child in ipairs(children) do
        if (!IsValid(child)) then continue end

        child:SetPos(border + x * innerWidth / count + spacingX * x, border + y * child:GetTall() + spacingY * y)
        child:SetSize(innerWidth / count, self:GetGridColumnHeight() or innerWidth / count)

        x = x + 1
        if (x >= count) then
          x = 0
          y = y + 1
        end
      end

      pnl:SizeToChildren(false, true)
    end
  else
    self.Layout:SetTall(self:GetColumnHeight())
  end

  self.m_layoutType = type
end

function PANEL:Expand(state)
  self.Top:LerpColor("textColor", state and self:GetTopTextColorActive() or self:GetTopTextColorHover())
  self.Top:LerpColor("background", state and self:GetTopColorActive() or self:GetTopColorHover())

  local height = state and 48 + self.Layout:GetTall() or 48
  self:SetExpanded(state)

  self.Top.NextHeight = state and self.Top:GetTall() or self:GetTall()
  self.Top:Lerp("NextHeight", height)
  self.invalidateLayout = true

  self:OnToggle(self:GetExpanded())
end

function PANEL:OnToggle(state) end

function PANEL:CalculateHeight(childrenModifier)
  childrenModifier = childrenModifier or 0
  local children = #self.Layout:GetChildren() + childrenModifier
  local columns = self:GetColumns()
  local spacingX = self.Layout:GetSpaceX()
  local spacingY = self.Layout:GetSpaceY()
  local border = self.Layout:GetBorder()
  local innerWidth = (self:GetInstantExpandWidth() > 0 and self:GetInstantExpandWidth() or self:GetWide()) - border * 2 - spacingX * (columns - 1)
  local columnHeight = innerWidth / columns
  local height = math.ceil(children / columns) * (self:GetLayoutY() + columnHeight) + spacingY

  return 48 + height, children
end

function PANEL:FeedData(tbl, index, expand)
  self.DataTbl = tbl

  for i, v in pairs(tbl) do
    local panel = self.Layout:Add(self:GetLayoutPanel())

    if (self:GetLayoutType() == XENINUI_LAYOUT_ROW) then
      panel:Dock(TOP)
      panel:DockMargin(0, 0, 0, self:GetLayoutY())
      panel:SetTall(self:GetColumnHeight())
    end

    if panel.HandleData then
      panel:HandleData(v, i)
    end
  end

  if expand then
    self.Top.textColor = self:GetTopTextColorActive()
    self.Top.background = self:GetTopColorActive()
    self.Top.rotation = 180

    local height = 48
    if (self:GetLayoutType() == XENINUI_LAYOUT_GRID) then
      local columns = self:GetColumns()
      local spacingX = self.Layout:GetSpaceX()
      local spacingY = self.Layout:GetSpaceY()
      local border = self.Layout:GetBorder()
      local innerWidth = (self:GetInstantExpandWidth() > 0 and self:GetInstantExpandWidth() or self:GetWide()) - border * 2 - spacingX * (columns - 1)
      local columnHeight = innerWidth / columns

      height = height + math.ceil(#tbl / columns) * (self:GetLayoutY() + columnHeight) + spacingY
    elseif (self:GetLayoutType() == XENINUI_LAYOUT_ROW) then
      local columns = #tbl
      local y = self:GetLayoutY()
      local columnHeight = self:GetColumnHeight()

      height = height + self:GetBorder() + (columns * columnHeight) + (y * (columns - 1)) + self:GetBorder()
    end

    self:SetExpanded(true)
    self.Top.NextHeight = height
    self:InvalidateLayout(true)

    self:OnToggle(true)
  end

  self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
  draw.RoundedBoxEx(self:GetRounded(), 0, self.Top:GetTall(), w, h - self.Top:GetTall(), self:GetBackgroundColor(), false, false, true, true)
end

function PANEL:Think()
  if self.invalidateLayout then
    self:InvalidateLayout()
  end
end

function PANEL:PerformLayout(w, h)
  self.Top:SetTall(self:GetTopHeight())
  self:SetTall(self.Top.NextHeight or self.Top:GetTall())
end

vgui.Register("XeninUI.Category", PANEL)

--PATH lua/xeninui/elements/dropdown_popup.lua:
XeninUI:CreateFont("XeninUI.DropdownPopup", 19)

local PANEL = {}

AccessorFunc(PANEL, "m_backgroundColor", "BackgroundColor")
AccessorFunc(PANEL, "m_textColor", "TextColor")
AccessorFunc(PANEL, "m_accentColor", "AccentColor")
AccessorFunc(PANEL, "m_iconColor", "IconColor")

function PANEL:Init()
  self.choices = {}

  self.Alpha = 0
  self:LerpAlpha(255, 0.15)
  self:SetBackgroundColor(XeninUI.Theme.Primary)
  self:SetTextColor(color_white)
  self:SetAccentColor(XeninUI.Theme.Accent)
  self:SetIconColor(color_white)
  self:DockPadding(0, 8, 0, 8)
end

function PANEL:Paint(w, h)
  local aX, aY = self:LocalToScreen()

  BSHADOWS.BeginShadow()
  draw.RoundedBox(6, aX, aY, w, h, self:GetBackgroundColor())
  BSHADOWS.EndShadow(1, 2, 2)
end

function PANEL:AddChoice(name, onClick, textColor, accentColor, icon, iconColor)
  onClick = onClick or function()
    return true end

  local panel = vgui.Create("DButton", self)
  panel:Dock(TOP)
  panel:SetTall(48)
  panel:SetText(name)
  panel:SetFont("XeninUI.DropdownPopup")
  panel:SetTextInset(icon and 64 or 16, 0)
  panel:SetContentAlignment(4)
  panel:SetTextColor(textColor or self:GetTextColor())
  panel.alpha = 0
  panel.Paint = function(pnl, w, h)
    surface.SetDrawColor(ColorAlpha(accentColor or self:GetAccentColor(), pnl.alpha))
    surface.DrawRect(0, 0, w, h)
  end
  panel.OnCursorEntered = function(pnl)
    pnl:Lerp("alpha", 200)
  end
  panel.OnCursorExited = function(pnl)
    pnl:Lerp("alpha", 0)
  end
  panel.DoClick = function(pnl)
    onClick(pnl)

    self:Remove()
  end

  if icon then
    panel.icon = panel:Add("Panel")
    panel.icon:SetMouseInputEnabled(false)
    panel.icon.icon = icon
    panel.icon.CalculatePoly = function(self, w, h, vertices)
      local poly = {}

      local x = w / 2
      local y = h / 2
      local radius = h / 2

      table.insert(poly, {
        x = x,
        y = y
      })

      for i = 0, vertices do
        local a = math.rad((i / vertices) * -360)
        table.insert(poly, {
          x = x + math.sin(a) * radius,
          y = y + math.cos(a) * radius
        })
      end

      local a = math.rad(0)
      table.insert(poly, {
        x = x + math.sin(a) * radius,
        y = y + math.cos(a) * radius
      })
      self.data = poly
    end
    panel.icon.DrawPoly = function(self, w, h, vertices)
      if (!self.data) then
        self:CalculatePoly(w, h, vertices)
      end

      surface.DrawPoly(self.data)
    end
    panel.icon.Paint = function(pnl, w, h)
      render.ClearStencil()
      render.SetStencilEnable(true)

      render.SetStencilWriteMask(1)
      render.SetStencilTestMask(1)

      render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
      render.SetStencilPassOperation(STENCILOPERATION_ZERO)
      render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
      render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
      render.SetStencilReferenceValue(1)

      draw.NoTexture()
      surface.SetDrawColor(color_white)
      pnl:DrawPoly(w, h, 90)

      render.SetStencilFailOperation(STENCILOPERATION_ZERO)
      render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
      render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
      render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
      render.SetStencilReferenceValue(1)

      if pnl.icon then
        surface.SetDrawColor(iconColor or self:GetIconColor())
        surface.SetMaterial(pnl.icon)
        surface.DrawTexturedRect(0, 0, w, h)
      end

      render.SetStencilEnable(false)
      render.ClearStencil()
    end
    panel.PerformLayout = function(pnl, w, h)
      pnl.icon:SetPos(16, 6)
      pnl.icon:SetSize(h - 12, h - 12)
    end
  end

  local i = table.insert(self.choices, {
    panel = panel,
    str = name
  })

  self:InvalidateLayout()

  return panel
end

function PANEL:PerformLayout(w, h)
  local longest = 0

  surface.SetFont("XeninUI.DropdownPopup")
  for i, v in pairs(self.choices) do
    local tw = surface.GetTextSize(v.str)
    tw = tw + 16
    tw = tw + 16
    if v.panel.icon then
      tw = tw + 48
    end

    if (tw > longest) then
      longest = math.max(112, tw)
    end
  end

  self:SetWide(longest)
  self:SetTall(8 + #self.choices * 48 + 8)
end

function PANEL:OnFocusChanged(gained)
  if (!IsValid(self)) then return end
  if gained then return end
  if self.ignore then return end

  self:Remove()
end

function PANEL:Think()
  local w, h = self:GetSize()
  local x, y = self.x, self.y
  x = math.Clamp(x, 0, ScrW() - w)
  y = math.Clamp(y, 0, ScrH() - h)

  self:SetPos(x, y)
end

vgui.Register("XeninUI.DropdownPopup", PANEL, "EditablePanel")

function XeninUI:DropdownPopup(x, y)
  local panel = vgui.Create("XeninUI.DropdownPopup", vgui.GetWorldPanel())
  panel:SetDrawOnTop(true)
  panel:SetPos(x + 12, y + 12)
  panel:MakePopup()

  return panel
end

XeninUI:CreateFont("XeninUI.QueryPopup.Title", 19, 800)
XeninUI:CreateFont("XeninUI.QueryPopup.Subtitle", 16, 800)
XeninUI:CreateFont("XeninUI.QueryPopup.Button", 18, 800)

local PANEL = {}

AccessorFunc(PANEL, "m_title", "Title")
AccessorFunc(PANEL, "m_subtitle", "Subtitle")
AccessorFunc(PANEL, "m_subtitleColor", "SubtitleColor")

function PANEL:Init()
  self:DockPadding(8, 8, 8, 8)
  self:SetTall(96)

  self.onCancel = function() end
  self.onAccept = function() end

  self.title = vgui.Create("DLabel", self)
  self.title:Dock(TOP)
  self.title:SetText("Equip this booster?")
  self.title:SetFont("XeninUI.QueryPopup.Title")
  self.title:SetTextColor(color_black)

  self.subtitle = vgui.Create("DLabel", self)
  self.subtitle:Dock(TOP)
  self.subtitle:DockMargin(0, -2, 0, 0)
  self.subtitle:SetTextColor(Color(75, 75, 75))
  self.subtitle:SetFont("XeninUI.QueryPopup.Subtitle")

  self.bottom = vgui.Create("Panel", self)
  self.bottom:Dock(BOTTOM)
  self.bottom:SetTall(32)

  self.cancel = vgui.Create("DButton", self.bottom)
  self.cancel:Dock(RIGHT)
  self.cancel:DockMargin(8, 0, 0, 0)
  self.cancel:SetText("Cancel")
  self.cancel:SetTextColor(XeninUI.Theme.Red)
  self.cancel:SetFont("XeninUI.QueryPopup.Button")
  self.cancel.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, Color(220, 220, 220))
  end
  self.cancel.DoClick = function(pnl)
    self:onCancel()

    self:Remove()
  end
  local tw, th = surface.GetTextSize(self.cancel:GetText())
  self.cancel:SetWide(tw + 24)

  self.unlock = vgui.Create("DButton", self.bottom)
  self.unlock:Dock(RIGHT)
  self.unlock:SetText("Accept")
  self.unlock:SetTextColor(XeninUI.Theme.Green)
  self.unlock:SetFont("XeninUI.QueryPopup.Button")
  self.unlock.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, Color(220, 220, 220))
  end
  self.unlock.DoClick = function(pnl)
    self:onAccept()

    self:Remove()
  end
  surface.SetFont(self.unlock:GetFont())
  local tw, th = surface.GetTextSize(self.unlock:GetText())
  self.unlock:SetWide(tw + 16)

  surface.SetFont(self.title:GetFont())
  local tw, th = surface.GetTextSize(self.title:GetText())
  self:SetWide(tw + 16)
end

function PANEL:Paint(w, h)
  draw.RoundedBox(6, 0, 0, w, h, color_white)
end

function PANEL:OnFocusChanged(gained)
  if (!IsValid(self)) then return end
  if gained then return end
  if self.ignore then return end

  self:Remove()
end

vgui.Register("XeninUI.QueryPopup", PANEL, "EditablePanel")

function XeninUI:Popup(x, y, title, subtitle, onUnlock, onCancel, hideUnlock, titleColor, subtitleColor, acceptText)
  local panel = vgui.Create("XeninUI.QueryPopup")
  panel:SetDrawOnTop(true)
  panel:SetMouseInputEnabled(true)
  panel:SetPos(x + 12, y + 12 - 12)
  panel.title:SetText(title or "Title")
  panel.subtitle:SetText(subtitle or "Subtitle")

  if subtitleColor then
    panel.subtitle:SetTextColor(subtitleColor)
  end

  if titleColor then
    panel.title:SetTextColor(titleColor)
  end

  if acceptText then
    panel.unlock:SetText(acceptText)
  end

  if onUnlock then
    panel.onAccept = onUnlock

    local tw, th = surface.GetTextSize(panel.unlock:GetText())
    panel.unlock:SetWide(tw + 16)
  end
  if onCancel then
    panel.onCancel = onCancel

    local tw, th = surface.GetTextSize(panel.cancel:GetText())
    panel.cancel:SetWide(tw + 24)
  end
  if hideUnlock then
    panel.unlock:Remove()
    panel:InvalidateLayout()
  end

  surface.SetFont(panel.unlock:GetFont())
  local tw, th = surface.GetTextSize(panel.unlock:GetText())
  panel.unlock:SetWide(tw + 16)

  surface.SetFont(panel.title:GetFont())
  local tw, th = surface.GetTextSize(panel.title:GetText())
  panel:SetWide(math.max(192, tw + 16))

  return panel
end

--PATH lua/xeninui/elements/sidebar_animated.lua:
return gluapack()()
--PATH lua/xeninui/elements/slider.lua:
local PANEL = {}

AccessorFunc(PANEL, "m_sliderColor", "Color")
AccessorFunc(PANEL, "m_max", "Max")
AccessorFunc(PANEL, "m_min", "Min")
AccessorFunc(PANEL, "m_sliderHeight", "Height")

function PANEL:Init()
  self:SetText("")

  self:SetMin(0)
  self:SetMax(10)
  self:SetHeight(2)
  self:SetColor(XeninUI.Theme.Accent)
  self.fraction = 0

  self.grip = vgui.Create("DButton", self)
  self.grip:SetText("")
  self.grip:NoClipping(true)
  self.grip.xOffset = 0
  self.grip.startSize = self:GetHeight() * 4
  self.grip.size = self.grip.startSize
  self.grip.outlineSize = self.grip.startSize
  self.grip.Paint = function(pnl, w, h)
    XeninUI:DrawCircle(pnl.startSize, h / 2, pnl.outlineSize, 45, ColorAlpha(self:GetColor(), 30), 0)

    XeninUI:DrawCircle(pnl.startSize, h / 2, pnl.size, 45, self:GetColor(), 0)
  end
  self.grip.OnCursorEntered = function(pnl)
    pnl:Lerp("outlineSize", pnl.startSize * 2)
  end
  self.grip.OnCursorExited = function(pnl)
    pnl:Lerp("outlineSize", pnl.startSize)
  end
  self.grip.OnMousePressed = function(pnl)
    pnl.Depressed = true

    pnl:MouseCapture(true)

    pnl:LerpWidth(pnl:GetTall() * 2)
  end
  self.grip.OnMouseReleased = function(pnl)
    pnl.Depressed = nil



    pnl:LerpWidth(pnl.startSize * 2)
    pnl:MouseCapture(false)
  end
  self.grip.OnCursorMoved = function(pnl, x, y)
    if (!pnl.Depressed) then return end

    local x, y = pnl:LocalToScreen(x, y)
    x, y = self:ScreenToLocal(x, y)

    local w = self:GetWide()
    local newX = math.Clamp(x / w, 0, 1)
    self.fraction = newX

    self:OnValueChanged(self.fraction)
    self:InvalidateLayout()
  end
  self.grip:SetWide(self.grip.startSize * 2)
end

function PANEL:OnMousePressed()
  local x, y = self:CursorPos()
  local w = self:GetWide() + (self:GetHeight() * 2)
  local newX = math.Clamp(x / w, 0, 1)

  self.fraction = newX
  self:OnValueChanged(self.fraction)
  self:InvalidateLayout()
end

function PANEL:OnValueChanged(fraction) end

function PANEL:Paint(w, h)
  local height = self:GetHeight()
  local y = h / 2 - height / 2

  surface.SetDrawColor(ColorAlpha(self:GetColor(), 50))
  surface.DrawRect(height, y, w - (height * 2), height)

  local width = self.fraction * (w - (self:GetHeight() / 2))
  surface.SetDrawColor(self:GetColor())
  surface.DrawRect(height, y, width, height)
end

function PANEL:PerformLayout(w, h)
  self.grip:SetTall(h)
  self.grip:SetPos(self.fraction * (w - self.grip.size - (self:GetHeight() / 2)))
end

vgui.Register("XeninUI.Slider", PANEL, "DButton")

--PATH lua/xeninui/elements/tooltip.lua:
return gluapack()()
--PATH lua/advdupe2/file_browser.lua:
--[[
	Title: Adv. Dupe 2 File Browser

	Desc: Displays and interfaces with duplication files.

	Author: TB

	Version: 1.0
]]

local History = {}
local Narrow = {}

local switch = true
local count = 0

local function AddHistory(txt)
	txt = string.lower(txt)
	local char1 = txt[1]
	local char2
	for i = 1, #History do
		char2 = History[i][1]
		if (char1 == char2) then
			if (History[i] == txt) then
				return
			end
		elseif (char1 < char2) then
			break
		end
	end

	table.insert(History, txt)
	table.sort(History, function(a, b) return a < b end)
end

local function NarrowHistory(txt, last)
	txt = string.lower(txt)
	local temp = {}
	if (last <= #txt and last ~= 0 and #txt ~= 1) then
		for i = 1, #Narrow do
			if (Narrow[i][last + 1] == txt[last + 1]) then
				table.insert(temp, Narrow[i])
			elseif (Narrow[i][last + 1] ~= '') then
				break
			end
		end
	else
		local char1 = txt[1]
		local char2
		for i = 1, #History do
			char2 = History[i][1]
			if (char1 == char2) then
				if (#txt > 1) then
					for k = 2, #txt do
						if (txt[k] ~= History[i][k]) then
							break
						end
						if (k == #txt) then
							table.insert(temp, History[i])
						end
					end
				else
					table.insert(temp, History[i])
				end
			elseif (char1 < char2) then
				break
			end
		end
	end

	Narrow = temp
end

local function tableSortNodes(tbl)
    for k, v in ipairs(tbl) do tbl[k] = {string.lower(v.Label:GetText()), v} end
    table.sort(tbl, function(a,b) return a[1]<b[1] end)
    for k, v in ipairs(tbl) do tbl[k] = v[2] end
end

local BROWSERPNL = {}
AccessorFunc(BROWSERPNL, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(BROWSERPNL, "m_bgColor", "BackgroundColor")
Derma_Hook(BROWSERPNL, "Paint", "Paint", "Panel")
Derma_Hook(BROWSERPNL, "PerformLayout", "Layout", "Panel")

local setbrowserpnlsize
local function SetBrowserPnlSize(self, x, y)
	setbrowserpnlsize(self, x, y)
	self.pnlCanvas:SetWide(x)
	self.pnlCanvas.VBar:SetUp(y, self.pnlCanvas:GetTall())
end

function BROWSERPNL:Init()
	setbrowserpnlsize = self.SetSize
	self.SetSize = SetBrowserPnlSize
	self.pnlCanvas = vgui.Create("advdupe2_browser_tree", self)

	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self:SetBackgroundColor(self:GetSkin().text_bright)
end

function BROWSERPNL:OnVScroll(iOffset)
	self.pnlCanvas:SetPos(0, iOffset)
end

derma.DefineControl("advdupe2_browser_panel", "AD2 File Browser", BROWSERPNL, "Panel")

local BROWSER = {}
AccessorFunc(BROWSER, "m_pSelectedItem", "SelectedItem")
Derma_Hook(BROWSER, "Paint", "Paint", "Panel")

local origSetTall
local function SetTall(self, val)
	origSetTall(self, val)
	self.VBar:SetUp(self:GetParent():GetTall(), self:GetTall())
end

function BROWSER:Init()
	self:SetTall(0)
	origSetTall = self.SetTall
	self.SetTall = SetTall

	self.VBar = vgui.Create("DVScrollBar", self:GetParent())
	self.VBar:Dock(RIGHT)
	self.Nodes = 0
	self.ChildrenExpanded = {}
	self.ChildList = self
	self.m_bExpanded = true
	self.Folders = {}
	self.Files = {}
	self.LastClick = CurTime()
end

local function GetNodePath(node)
	local path = node.Label:GetText()
	local area = 0
	local name = ""
	node = node.ParentNode
	if (not node.ParentNode) then
		if (path == "-Public-") then
			area = 1
		elseif (path == "-Advanced Duplicator 1-") then
			area = 2
		end
		return "", area
	end

	while (true) do

		name = node.Label:GetText()
		if (name == "-Advanced Duplicator 2-") then
			break
		elseif (name == "-Public-") then
			area = 1
			break
		elseif (name == "-Advanced Duplicator 1-") then
			area = 2
			break
		end
		path = name .. "/" .. path
		node = node.ParentNode
	end

	return path, area
end

function BROWSER:DoNodeLeftClick(node)
	if (self.m_pSelectedItem == node and CurTime() - self.LastClick <= 0.25) then -- Check for double click
		if (node.Derma.ClassName == "advdupe2_browser_folder") then
			if (node.Expander) then
				node:SetExpanded() -- It's a folder, expand/collapse it
			end
		else
			AdvDupe2.UploadFile(GetNodePath(node))
		end
	else
		self:SetSelected(node) -- A node was clicked, select it
	end
	self.LastClick = CurTime()
end

local function AddNewFolder(node)
	local Controller = node.Control:GetParent():GetParent()
	local name = Controller.FileName:GetValue()
	local char = string.match(name, "[^%w_ ]")
	if char then
		AdvDupe2.Notify("Name contains invalid character ("..char..")!", NOTIFY_ERROR)
		Controller.FileName:SelectAllOnFocus(true)
		Controller.FileName:OnGetFocus()
		Controller.FileName:RequestFocus()
		return
	end
	if (name == "" or name == "Folder_Name...") then
		AdvDupe2.Notify("Name is blank!", NOTIFY_ERROR)
		Controller.FileName:SelectAllOnFocus(true)
		Controller.FileName:OnGetFocus()
		Controller.FileName:RequestFocus()
		return
	end
	local path, area = GetNodePath(node)
	if (area == 0) then
		path = AdvDupe2.DataFolder .. "/" .. path .. "/" .. name
	elseif (area == 1) then
		path = AdvDupe2.DataFolder .. "/=Public=/" .. path .. "/" .. name
	else
		path = "adv_duplicator/" .. path .. "/" .. name
	end

	if (file.IsDir(path, "DATA")) then
		AdvDupe2.Notify("Folder name already exists.", NOTIFY_ERROR)
		Controller.FileName:SelectAllOnFocus(true)
		Controller.FileName:OnGetFocus()
		Controller.FileName:RequestFocus()
		return
	end
	file.CreateDir(path)

	local Folder = node:AddFolder(name)
	node.Control:Sort(node)

	if (not node.m_bExpanded) then
		node:SetExpanded()
	end

	node.Control:SetSelected(Folder)
	if (Controller.Expanded) then
		AdvDupe2.FileBrowser:Slide(false)
	end
end

local function CollapseChildren(node)
	node.m_bExpanded = false
	if (node.Expander) then
		node.Expander:SetExpanded(false)
		node.ChildList:SetTall(0)
		for i = 1, #node.ChildrenExpanded do
			CollapseChildren(node.ChildrenExpanded[i])
		end
		node.ChildrenExpanded = {}
	end
end

local function CollapseParentsComplete(node)
	if (not node.ParentNode.ParentNode) then
		node:SetExpanded(false)
		return
	end
	CollapseParentsComplete(node.ParentNode)
end

function AdvDupe2.GetFilename(path, overwrite)
	if not overwrite and file.Exists(path .. ".txt", "DATA") then
		for i = 1, AdvDupe2.FileRenameTryLimit do
			local p = string.format("%s_%03d.txt", path, i)
			if not file.Exists(p, "DATA") then
				return p
			end
		end
		return false
	end
	return path .. ".txt"
end

local function GetFullPath(node)
	local path, area = GetNodePath(node)
	if (area == 0) then
		path = AdvDupe2.DataFolder .. "/" .. path .. "/"
	elseif (area == 1) then

	else
		path = "adv_duplicator/" .. path .. "/"
	end
	return path
end

local function GetNodeRoot(node)
	local Root
	while (true) do
		if (not node.ParentNode.ParentNode) then
			Root = node
			break
		end
		node = node.ParentNode
	end
	return Root
end

local function RenameFileCl(node, name)
	local path, area = GetNodePath(node)
	local File, FilePath, tempFilePath = "", "", ""
	if (area == 0) then
		tempFilePath = AdvDupe2.DataFolder .. "/" .. path
	elseif (area == 1) then
		tempFilePath = AdvDupe2.DataFolder .. "/=Public=/" .. path
	elseif (area == 2) then
		tempFilePath = "adv_duplicator/" .. path
	end

	File = file.Read(tempFilePath .. ".txt")
	FilePath = AdvDupe2.GetFilename(
		string.sub(tempFilePath, 1, #tempFilePath - #node.Label:GetText()) .. name)

	if (not FilePath) then
		AdvDupe2.Notify("Rename limit exceeded, could not rename.", NOTIFY_ERROR)
		return
	end
	file.Write(FilePath, File)
	if (file.Exists(FilePath, "DATA")) then
		file.Delete(tempFilePath .. ".txt")
		local NewName = string.Explode("/", FilePath)
		NewName = string.sub(NewName[#NewName], 1, -5)
		node.Label:SetText(NewName)
		node.Label:SizeToContents()
		AdvDupe2.Notify("File renamed to " .. NewName)
	else
		AdvDupe2.Notify("File was not renamed.", NOTIFY_ERROR)
	end

	node.Control:Sort(node.ParentNode)
end

local function MoveFileClient(node)
	if (not node) then
		AdvDupe2.Notify("Select a folder to move the file to.", NOTIFY_ERROR)
		return
	end
	if (node.Derma.ClassName == "advdupe2_browser_file") then
		AdvDupe2.Notify("You muse select a folder as a destination.", NOTIFY_ERROR)
		return
	end
	local base = AdvDupe2.DataFolder
	local ParentNode

	local node2 = node.Control.ActionNode
	local path, area = GetNodePath(node2)
	local path2, area2 = GetNodePath(node)

	if (area ~= area2 or path == path2) then
		AdvDupe2.Notify("Cannot move files between these directories.", NOTIFY_ERROR)
		return
	end
	if (area == 2) then base = "adv_duplicator" end

	local savepath = AdvDupe2.GetFilename(
						 base .. "/" .. path2 .. "/" .. node2.Label:GetText())
	local OldFile = base .. "/" .. path .. ".txt"

	local ReFile = file.Read(OldFile)
	file.Write(savepath, ReFile)
	file.Delete(OldFile)
	local name2 = string.Explode("/", savepath)
	name2 = string.sub(name2[#name2], 1, -5)
	node2.Control:RemoveNode(node2)
	node2 = node:AddFile(name2)
	node2.Control:Sort(node)
	AdvDupe2.FileBrowser:Slide(false)
	AdvDupe2.FileBrowser.Info:SetVisible(false)
end

local function DeleteFilesInFolders(path)
	local files, folders = file.Find(path .. "*", "DATA")

	for k, v in pairs(files) do file.Delete(path .. v) end

	for k, v in pairs(folders) do DeleteFilesInFolders(path .. v .. "/") end

	file.Delete(path)
end

local function SearchNodes(node, name)
	local tab = {}
	for k, v in pairs(node.Files) do
		if (string.find(string.lower(v.Label:GetText()), name)) then
			table.insert(tab, v)
		end
	end

	for k, v in pairs(node.Folders) do
		for i, j in pairs(SearchNodes(v, name)) do
			table.insert(tab, j)
		end
	end

	return tab
end

local function Search(node, name)
	local pnFileBr = AdvDupe2.FileBrowser
	pnFileBr.Search = vgui.Create("advdupe2_browser_panel", pnFileBr)
	pnFileBr.Search:SetPos(pnFileBr.Browser:GetPos())
	pnFileBr.Search:SetSize(pnFileBr.Browser:GetSize())
	pnFileBr.Search.pnlCanvas.Search = true
	pnFileBr.Browser:SetVisible(false)
	local Files = SearchNodes(node, name)
	tableSortNodes(Files)
	for k, v in pairs(Files) do
		pnFileBr.Search.pnlCanvas:AddFile(v.Label:GetText()).Ref = v
	end
end

function BROWSER:DoNodeRightClick(node)
	self:SetSelected(node)

	local parent = self:GetParent():GetParent()
	parent.FileName:KillFocus()
	parent.Desc:KillFocus()
	local Menu = DermaMenu()
	local root = GetNodeRoot(node).Label:GetText()
	if (node.Derma.ClassName == "advdupe2_browser_file") then
		if (node.Control.Search) then
			Menu:AddOption("Open", function()
				AdvDupe2.UploadFile(GetNodePath(node.Ref))
			end)
			Menu:AddOption("Preview", function()
				local ReadPath, ReadArea = GetNodePath(node.Ref)
				if (ReadArea == 0) then
					ReadPath = AdvDupe2.DataFolder .. "/" .. ReadPath .. ".txt"
				elseif (ReadArea == 1) then
					ReadPath = AdvDupe2.DataFolder .. "/-Public-/" .. ReadPath .. ".txt"
				else
					ReadPath = "adv_duplicator/" .. ReadPath .. ".txt"
				end
				if (not file.Exists(ReadPath, "DATA")) then
					AdvDupe2.Notify("File does not exist", NOTIFY_ERROR)
					return
				end

				local read = file.Read(ReadPath)
				local name = string.Explode("/", ReadPath)
				name = name[#name]
				name = string.sub(name, 1, #name - 4)
				local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
				if (success) then
					AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, true)
				end
			end)
		else
			Menu:AddOption("Open", function()
				AdvDupe2.UploadFile(GetNodePath(node))
			end)
			Menu:AddOption("Preview", function()
				local ReadPath, ReadArea = GetNodePath(node)
				if (ReadArea == 0) then
					ReadPath = AdvDupe2.DataFolder .. "/" .. ReadPath .. ".txt"
				elseif (ReadArea == 1) then
					ReadPath = AdvDupe2.DataFolder .. "/-Public-/" .. ReadPath .. ".txt"
				else
					ReadPath = "adv_duplicator/" .. ReadPath .. ".txt"
				end
				if (not file.Exists(ReadPath, "DATA")) then
					AdvDupe2.Notify("File does not exist", NOTIFY_ERROR)
					return
				end

				local read = file.Read(ReadPath)
				local name = string.Explode("/", ReadPath)
				name = name[#name]
				name = string.sub(name, 1, #name - 4)
				local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
				if (success) then
					AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, true)
				end
			end)
			Menu:AddSpacer()
			Menu:AddOption("Rename", function()
				if (parent.Expanding) then return end
				parent.Submit:SetMaterial("icon16/page_edit.png")
				parent.Submit:SetTooltip("Rename File")
				parent.Desc:SetVisible(false)
				parent.Info:SetVisible(false)
				parent.FileName.FirstChar = true
				parent.FileName.PrevText = parent.FileName:GetValue()
				parent.FileName:SetVisible(true)
				parent.FileName:SetText(node.Label:GetText())
				parent.FileName:SelectAllOnFocus(true)
				parent.FileName:OnMousePressed()
				parent.FileName:RequestFocus()
				parent.Expanding = true
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local name = parent.FileName:GetValue()
					if (name == "") then
						AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
						parent.FileName:SelectAllOnFocus(true)
						parent.FileName:OnGetFocus()
						parent.FileName:RequestFocus()
						return
					end
					AddHistory(name)
					RenameFileCl(node, name)
					AdvDupe2.FileBrowser:Slide(false)
				end
				parent.FileName.OnEnter = parent.Submit.DoClick
			end)
			Menu:AddOption("Move File", function()
				parent.Submit:SetMaterial("icon16/page_paste.png")
				parent.Submit:SetTooltip("Move File")
				parent.FileName:SetVisible(false)
				parent.Desc:SetVisible(false)
				parent.Info:SetText(
					"Select the folder you want to move \nthe File to.")
				parent.Info:SizeToContents()
				parent.Info:SetVisible(true)
				AdvDupe2.FileBrowser:Slide(true)
				node.Control.ActionNode = node
				parent.Submit.DoClick = function()
					MoveFileClient(node.Control.m_pSelectedItem)
				end
			end)
			Menu:AddOption("Delete", function()
				parent.Submit:SetMaterial("icon16/bin_empty.png")
				parent.Submit:SetTooltip("Delete File")
				parent.FileName:SetVisible(false)
				parent.Desc:SetVisible(false)
				if (#node.Label:GetText() > 22) then
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FILE, "' ..
							node.Label:GetText() .. '" \nfrom your CLIENT?')
				else
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FILE, "' ..
							node.Label:GetText() .. '" from your CLIENT?')
				end
				parent.Info:SizeToContents()
				parent.Info:SetVisible(true)
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local path, area = GetNodePath(node)
					if (area == 1) then
						path = "-Public-/" .. path
					end
					if (area == 2) then
						path = "adv_duplicator/" .. path .. ".txt"
					else
						path = AdvDupe2.DataFolder .. "/" .. path .. ".txt"
					end
					node.Control:RemoveNode(node)
					file.Delete(path)
					AdvDupe2.FileBrowser:Slide(false)
				end
			end)
		end
	else
		if (root ~= "-Advanced Duplicator 1-") then
			Menu:AddOption("Save", function()
				if (parent.Expanding) then return end
				parent.Submit:SetMaterial("icon16/page_save.png")
				parent.Submit:SetTooltip("Save Duplication")
				if (parent.FileName:GetValue() == "Folder_Name...") then
					parent.FileName:SetText("File_Name...")
				end
				parent.Desc:SetVisible(true)
				parent.Info:SetVisible(false)
				parent.FileName.FirstChar = true
				parent.FileName.PrevText = parent.FileName:GetValue()
				parent.FileName:SetVisible(true)
				parent.FileName:SelectAllOnFocus(true)
				parent.FileName:OnMousePressed()
				parent.FileName:RequestFocus()
				node.Control.ActionNode = node
				parent.Expanding = true
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local name = parent.FileName:GetValue()
					if (name == "" or name == "File_Name...") then
						AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
						parent.FileName:SelectAllOnFocus(true)
						parent.FileName:OnGetFocus()
						parent.FileName:RequestFocus()
						return
					end
					local desc = parent.Desc:GetValue()
					if (desc == "Description...") then
						desc = ""
					end
					AdvDupe2.SavePath = GetFullPath(node) .. name
					AddHistory(name)
					if (game.SinglePlayer()) then
						RunConsoleCommand("AdvDupe2_SaveFile", name, desc, GetNodePath(node))
					else
						RunConsoleCommand("AdvDupe2_SaveFile", name)
					end
					AdvDupe2.FileBrowser:Slide(false)
				end
				parent.FileName.OnEnter =
					function()
						parent.FileName:KillFocus()
						parent.Desc:SelectAllOnFocus(true)
						parent.Desc.OnMousePressed()
						parent.Desc:RequestFocus()
					end
				parent.Desc.OnEnter = parent.Submit.DoClick
			end)
		end
		Menu:AddOption("New Folder", function()
			if (parent.Expanding) then return end
			parent.Submit:SetMaterial("icon16/folder_add.png")
			parent.Submit:SetTooltip("Add new folder")
			if (parent.FileName:GetValue() == "File_Name...") then
				parent.FileName:SetText("Folder_Name...")
			end
			parent.Desc:SetVisible(false)
			parent.Info:SetVisible(false)
			parent.FileName.FirstChar = true
			parent.FileName.PrevText = parent.FileName:GetValue()
			parent.FileName:SetVisible(true)
			parent.FileName:SelectAllOnFocus(true)
			parent.FileName:OnMousePressed()
			parent.FileName:RequestFocus()
			parent.Expanding = true
			AdvDupe2.FileBrowser:Slide(true)
			parent.Submit.DoClick = function() AddNewFolder(node) end
			parent.FileName.OnEnter = parent.Submit.DoClick
		end)
		Menu:AddOption("Search", function()
			parent.Submit:SetMaterial("icon16/find.png")
			parent.Submit:SetTooltip("Search Files")
			if (parent.FileName:GetValue() == "Folder_Name...") then
				parent.FileName:SetText("File_Name...")
			end
			parent.Desc:SetVisible(false)
			parent.Info:SetVisible(false)
			parent.FileName.FirstChar = true
			parent.FileName.PrevText = parent.FileName:GetValue()
			parent.FileName:SetVisible(true)
			parent.FileName:SelectAllOnFocus(true)
			parent.FileName:OnMousePressed()
			parent.FileName:RequestFocus()
			parent.Expanding = true
			AdvDupe2.FileBrowser:Slide(true)
			parent.Submit.DoClick = function()
				Search(node, string.lower(parent.FileName:GetValue()))
				AddHistory(parent.FileName:GetValue())
				parent.FileName:SetVisible(false)
				parent.Submit:SetMaterial("icon16/arrow_undo.png")
				parent.Submit:SetTooltip("Return to Browser")
				parent.Info:SetVisible(true)
				parent.Info:SetText(#parent.Search.pnlCanvas.Files ..
										' files found searching for, "' ..
										parent.FileName:GetValue() .. '"')
				parent.Info:SizeToContents()
				parent.Submit.DoClick = function()
					parent.Search:Remove()
					parent.Search = nil
					parent.Browser:SetVisible(true)
					AdvDupe2.FileBrowser:Slide(false)
					parent.Cancel:SetVisible(true)
				end
				parent.Cancel:SetVisible(false)
			end
			parent.FileName.OnEnter = parent.Submit.DoClick
		end)
		if (node.Label:GetText()[1] ~= "-") then
			Menu:AddOption("Delete", function()
				parent.Submit:SetMaterial("icon16/bin_empty.png")
				parent.Submit:SetTooltip("Delete Folder")
				parent.FileName:SetVisible(false)
				parent.Desc:SetVisible(false)
				if (#node.Label:GetText() > 22) then
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FOLDER, "' ..
							node.Label:GetText() .. '" \nfrom your CLIENT?')
				else
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FOLDER, "' ..
							node.Label:GetText() .. '" from your CLIENT?')
				end
				parent.Info:SizeToContents()
				parent.Info:SetVisible(true)
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local path, area = GetNodePath(node)
					if (area == 1) then
						path = "-Public-/" .. path
					end
					if (area == 2) then
						path = "adv_duplicator/" .. path .. "/"
					else
						path = AdvDupe2.DataFolder .. "/" .. path .. "/"
					end
					node.Control:RemoveNode(node)
					DeleteFilesInFolders(path)
					AdvDupe2.FileBrowser:Slide(false)
				end
			end)
		end
	end
	if (not node.Control.Search) then
		Menu:AddSpacer()
		Menu:AddOption("Collapse Folder", function()
			if (node.ParentNode.ParentNode) then
				node.ParentNode:SetExpanded(false)
			end
		end)
		Menu:AddOption("Collapse Root", function() CollapseParentsComplete(node) end)
		if (parent.Expanded) then
			Menu:AddOption("Cancel Action", function() parent.Cancel:DoClick() end)
		end
	end

	Menu:Open()
end

local function CollapseParents(node, val)
	if (not node) then return end
	node.ChildList:SetTall(node.ChildList:GetTall() - val)
	CollapseParents(node.ParentNode, val)
end

function BROWSER:RemoveNode(node)
	local parent = node.ParentNode
	parent.Nodes = parent.Nodes - 1
	if (node.IsFolder) then
		if (node.m_bExpanded) then
			CollapseParents(parent, node.ChildList:GetTall() + 20)
			for i = 1, #parent.ChildrenExpanded do
				if (node == parent.ChildrenExpanded[i]) then
					table.remove(parent.ChildrenExpanded, i)
					break
				end
			end
		elseif (parent.m_bExpanded) then
			CollapseParents(parent, 20)
		end
		for i = 1, #parent.Folders do
			if (node == parent.Folders[i]) then
				table.remove(parent.Folders, i)
			end
		end
		node.ChildList:Remove()
		node:Remove()
	else
		for i = 1, #parent.Files do
			if (node == parent.Files[i]) then
				table.remove(parent.Files, i)
			end
		end
		CollapseParents(parent, 20)
		node:Remove()
		if (#parent.Files == 0 and #parent.Folders == 0) then
			parent.Expander:Remove()
			parent.Expander = nil
			parent.m_bExpanded = false
		end
	end
	if (self.VBar.Scroll > self.VBar.CanvasSize) then
		self.VBar:SetScroll(self.VBar.Scroll)
	end
	if (self.m_pSelectedItem) then
		self.m_pSelectedItem = nil
	end
end

function BROWSER:OnMouseWheeled(dlta)
	return self.VBar:OnMouseWheeled(dlta)
end

function BROWSER:AddFolder(text)
	local node = vgui.Create("advdupe2_browser_folder", self)
	node.Control = self

	node.Offset = 0
	node.ChildrenExpanded = {}
	node.Icon:SetPos(18, 1)
	node.Label:SetPos(44, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.ParentNode = self
	node.IsFolder = true
	self.Nodes = self.Nodes + 1
	node.Folders = {}
	node.Files = {}
	table.insert(self.Folders, node)
	self:SetTall(self:GetTall() + 20)

	return node
end

function BROWSER:AddFile(text)
	local node = vgui.Create("advdupe2_browser_file", self)
	node.Control = self
	node.Offset = 0
	node.Icon:SetPos(18, 1)
	node.Label:SetPos(44, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.ParentNode = self
	self.Nodes = self.Nodes + 1
	table.insert(self.Files, node)
	self:SetTall(self:GetTall() + 20)

	return node
end

function BROWSER:Sort(node)
	tableSortNodes(node.Folders)
	tableSortNodes(node.Files)

	for i = 1, #node.Folders do
		node.Folders[i]:SetParent(nil)
		node.Folders[i]:SetParent(node.ChildList)
		node.Folders[i].ChildList:SetParent(nil)
		node.Folders[i].ChildList:SetParent(node.ChildList)
	end
	for i = 1, #node.Files do
		node.Files[i]:SetParent(nil)
		node.Files[i]:SetParent(node.ChildList)
	end
end

function BROWSER:SetSelected(node)
	if (IsValid(self.m_pSelectedItem)) then
		self.m_pSelectedItem:SetSelected(false)
	end
	self.m_pSelectedItem = node
	if (node) then node:SetSelected(true) end
end

local function ExpandParents(node, val)
	if (not node) then return end
	node.ChildList:SetTall(node.ChildList:GetTall() + val)
	ExpandParents(node.ParentNode, val)
end

function BROWSER:Expand(node)
	node.ChildList:SetTall(node.Nodes * 20)
	table.insert(node.ParentNode.ChildrenExpanded, node)
	ExpandParents(node.ParentNode, node.Nodes * 20)
end

local function ExtendParents(node)
	if (not node) then return end
	node.ChildList:SetTall(node.ChildList:GetTall() + 20)
	ExtendParents(node.ParentNode)
end

function BROWSER:Extend(node)
	node.ChildList:SetTall(node.ChildList:GetTall() + 20)
	ExtendParents(node.ParentNode)
end

function BROWSER:Collapse(node)
	CollapseParents(node.ParentNode, node.ChildList:GetTall())

	for i = 1, #node.ParentNode.ChildrenExpanded do
		if (node.ParentNode.ChildrenExpanded[i] == node) then
			table.remove(node.ParentNode.ChildrenExpanded, i)
			break
		end
	end
	CollapseChildren(node)
end

function BROWSER:RenameNode(name)
	self.ActionNode.Label:SetText(name)
	self.ActionNode.Label:SizeToContents()
	self:Sort(self.ActionNode.ParentNode)
end

function BROWSER:MoveNode(name)
	self:RemoveNode(self.ActionNode)
	self.ActionNode2:AddFile(name)
	self:Sort(self.ActionNode2)
end

function BROWSER:DeleteNode()
	self:RemoveNode(self.ActionNode)
end

derma.DefineControl("advdupe2_browser_tree", "AD2 File Browser", BROWSER, "Panel")

local FOLDER = {}

AccessorFunc(FOLDER, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(FOLDER, "m_bgColor", "BackgroundColor")

Derma_Hook(FOLDER, "Paint", "Paint", "Panel")

function FOLDER:Init()
	self:SetMouseInputEnabled(true)

	self:SetTall(20)
	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self:SetBackgroundColor(Color(0, 0, 0, 0))

	self.Icon = vgui.Create("DImage", self)
	self.Icon:SetImage("icon16/folder.png")

	self.Icon:SizeToContents()

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetDark(true)

	self.m_bExpanded = false
	self.Nodes = 0
	self.ChildrenExpanded = {}

	self:Dock(TOP)

	self.ChildList = vgui.Create("Panel", self:GetParent())
	self.ChildList:Dock(TOP)
	self.ChildList:SetTall(0)
end

local function ExpandNode(self)
	self:GetParent():SetExpanded()
end

function FOLDER:AddFolder(text)
	if (self.Nodes == 0) then
		self.Expander = vgui.Create("DExpandButton", self)
		self.Expander.DoClick = ExpandNode
		self.Expander:SetPos(self.Offset, 2)
	end

	local node = vgui.Create("advdupe2_browser_folder", self.ChildList)
	node.Control = self.Control

	node.Offset = self.Offset + 20

	node.Icon:SetPos(18 + node.Offset, 1)
	node.Label:SetPos(44 + node.Offset, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.Label:SetDark(true)
	node.ParentNode = self
	node.IsFolder = true
	node.Folders = {}
	node.Files = {}

	self.Nodes = self.Nodes + 1
	table.insert(self.Folders, node)

	if (self.m_bExpanded) then
		self.Control:Extend(self)
	end

	return node
end

function FOLDER:AddFile(text)
	if (self.Nodes == 0) then
		self.Expander = vgui.Create("DExpandButton", self)
		self.Expander.DoClick = ExpandNode
		self.Expander:SetPos(self.Offset, 2)
	end

	local node = vgui.Create("advdupe2_browser_file", self.ChildList)
	node.Control = self.Control
	node.Offset = self.Offset + 20
	node.Icon:SetPos(18 + node.Offset, 1)
	node.Label:SetPos(44 + node.Offset, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.Label:SetDark(true)
	node.ParentNode = self

	self.Nodes = self.Nodes + 1
	table.insert(self.Files, node)

	if (self.m_bExpanded) then
		self.Control:Extend(self)
	end

	return node
end

function FOLDER:SetExpanded(bool)
	if (not self.Expander) then return end
	if (bool == nil) then
		self.m_bExpanded = not self.m_bExpanded
	else
		self.m_bExpanded = bool
	end
	self.Expander:SetExpanded(self.m_bExpanded)
	if (self.m_bExpanded) then
		self.Control:Expand(self)
	else
		self.Control:Collapse(self)
	end
end

function FOLDER:SetSelected(bool)
	if (bool) then
		self:SetBackgroundColor(self:GetSkin().bg_color_bright)
	else
		self:SetBackgroundColor(Color(0, 0, 0, 0))
	end
end

function FOLDER:OnMousePressed(code)
	if (code == 107) then
		self.Control:DoNodeLeftClick(self)
	elseif (code == 108) then
		self.Control:DoNodeRightClick(self)
	end
end

derma.DefineControl("advdupe2_browser_folder", "AD2 Browser Folder node", FOLDER, "Panel")

local FILE = {}

AccessorFunc(FILE, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(FILE, "m_bgColor", "BackgroundColor")
Derma_Hook(FILE, "Paint", "Paint", "Panel")

function FILE:Init()
	self:SetMouseInputEnabled(true)

	self:SetTall(20)
	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self:SetBackgroundColor(Color(0, 0, 0, 0))

	self.Icon = vgui.Create("DImage", self)
	self.Icon:SetImage("icon16/page.png")

	self.Icon:SizeToContents()

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetDark(true)

	self:Dock(TOP)
end

function FILE:SetSelected(bool)
	if (bool) then
		self:SetBackgroundColor(self:GetSkin().bg_color_bright)
	else
		self:SetBackgroundColor(Color(0, 0, 0, 0))
	end
end

function FILE:OnMousePressed(code)
	if (code == 107) then
		self.Control:DoNodeLeftClick(self)
	elseif (code == 108) then
		self.Control:DoNodeRightClick(self)
	end
end

derma.DefineControl("advdupe2_browser_file", "AD2 Browser File node", FILE, "Panel")

local PANEL = {}
AccessorFunc(PANEL, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(PANEL, "m_bgColor", "BackgroundColor")
Derma_Hook(PANEL, "Paint", "Paint", "Panel")
Derma_Hook(PANEL, "PerformLayout", "Layout", "Panel")

function PANEL:PerformLayout()
	if (self:GetWide() == self.LastX) then return end
	local x = self:GetWide()

	if (self.Search) then
		self.Search:SetWide(x)
	end

	self.Browser:SetWide(x)
	local x2, y2 = self.Browser:GetPos()
	local BtnX = x - self.Help:GetWide() - 5
	self.Help:SetPos(BtnX, 3)
	BtnX = BtnX - self.Refresh:GetWide() - 5
	self.Refresh:SetPos(BtnX, 3)

	BtnX = x - self.Submit:GetWide() - 15
	self.Cancel:SetPos(BtnX, self.Browser:GetTall() + 20)
	BtnX = BtnX - self.Submit:GetWide() - 5
	self.Submit:SetPos(BtnX, self.Browser:GetTall() + 20)

	self.FileName:SetWide(BtnX - 10)
	self.FileName:SetPos(5, self.Browser:GetTall() + 20)
	self.Desc:SetWide(x - 10)
	self.Desc:SetPos(5, self.Browser:GetTall() + 39)
	self.Info:SetPos(5, self.Browser:GetTall() + 20)

	self.LastX = x
end

local pnlorigsetsize
local function PanelSetSize(self, x, y)
	if (not self.LaidOut) then
		pnlorigsetsize(self, x, y)

		self.Browser:SetSize(x, y - 20)
		self.Browser:SetPos(0, 20)

		if (self.Search) then
			self.Search:SetSize(x, y - 20)
			self.Search:SetPos(0, 20)
		end

		self.LaidOut = true
	else
		pnlorigsetsize(self, x, y)
	end

end

local function PurgeFiles(path, curParent)
	local files, directories = file.Find(path .. "*", "DATA")
	if (directories) then
		for k, v in pairs(directories) do
			curParent = curParent:AddFolder(v)
			PurgeFiles(path .. v .. "/", curParent)
			curParent = curParent.ParentNode
		end
	end

	if (files) then
		for k, v in pairs(files) do
			curParent:AddFile(string.sub(v, 1, #v - 4))
		end
	end
end

local function UpdateClientFiles()

	local pnlCanvas = AdvDupe2.FileBrowser.Browser.pnlCanvas

	for i = 1, 2 do
		if (pnlCanvas.Folders[1]) then
			pnlCanvas:RemoveNode(pnlCanvas.Folders[1])
		end
	end

	PurgeFiles("advdupe2/", pnlCanvas:AddFolder("-Advanced Duplicator 2-"))

	PurgeFiles("adv_duplicator/", pnlCanvas:AddFolder("-Advanced Duplicator 1-"))

	if (pnlCanvas.Folders[2]) then
		if (#pnlCanvas.Folders[2].Folders == 0 and #pnlCanvas.Folders[2].Files == 0) then
			pnlCanvas:RemoveNode(pnlCanvas.Folders[2])
		end

		pnlCanvas.Folders[1]:SetParent(nil)
		pnlCanvas.Folders[1]:SetParent(pnlCanvas.ChildList)
		pnlCanvas.Folders[1].ChildList:SetParent(nil)
		pnlCanvas.Folders[1].ChildList:SetParent(pnlCanvas.ChildList)
	end

end

function PANEL:Init()

	AdvDupe2.FileBrowser = self
	self.Expanded = false
	self.Expanding = false
	self.LastX = 0
	self.LastY = 0
	pnlorigsetsize = self.SetSize
	self.SetSize = PanelSetSize

	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetBackgroundColor(self:GetSkin().bg_color_bright)

	self.Browser = vgui.Create("advdupe2_browser_panel", self)
	UpdateClientFiles()
	self.Refresh = vgui.Create("DImageButton", self)
	self.Refresh:SetMaterial("icon16/arrow_refresh.png")
	self.Refresh:SizeToContents()
	self.Refresh:SetTooltip("Refresh Files")
	self.Refresh.DoClick = function(button) UpdateClientFiles() end

	self.Help = vgui.Create("DImageButton", self)
	self.Help:SetMaterial("icon16/help.png")
	self.Help:SizeToContents()
	self.Help:SetTooltip("Help Section")
	self.Help.DoClick = function(btn)
		local Menu = DermaMenu()
		Menu:AddOption("Bug Reporting", function()
			gui.OpenURL("https://github.com/wiremod/advdupe2/issues")
		end)
		Menu:AddOption("Controls", function()
			gui.OpenURL("https://github.com/wiremod/advdupe2/wiki/Controls")
		end)
		Menu:AddOption("Commands", function()
			gui.OpenURL(
				"https://github.com/wiremod/advdupe2/wiki/Server-settings")
		end)
		Menu:Open()
	end

	self.Submit = vgui.Create("DImageButton", self)
	self.Submit:SetMaterial("icon16/page_save.png")
	self.Submit:SizeToContents()
	self.Submit:SetTooltip("Confirm Action")
	self.Submit.DoClick = function()
		self.Expanding = true
		AdvDupe2.FileBrowser:Slide(false)
	end

	self.Cancel = vgui.Create("DImageButton", self)
	self.Cancel:SetMaterial("icon16/cross.png")
	self.Cancel:SizeToContents()
	self.Cancel:SetTooltip("Cancel Action")
	self.Cancel.DoClick = function()
		self.Expanding = true
		AdvDupe2.FileBrowser:Slide(false)
	end

	self.FileName = vgui.Create("DTextEntry", self)
	self.FileName:SetAllowNonAsciiCharacters(true)
	self.FileName:SetText("File_Name...")
	self.FileName.Last = 0

	self.FileName.OnEnter = function()
		self.FileName:KillFocus()
		self.Desc:SelectAllOnFocus(true)
		self.Desc.OnMousePressed()
		self.Desc:RequestFocus()
	end
	self.FileName.OnMousePressed = function()
		self.FileName:OnGetFocus()
		if (self.FileName:GetValue() == "File_Name..." or
			self.FileName:GetValue() == "Folder_Name...") then
			self.FileName:SelectAllOnFocus(true)
		end
	end
	self.FileName:SetUpdateOnType(true)
	self.FileName.OnTextChanged = function()

		if (self.FileName.FirstChar) then
			if (string.lower(self.FileName:GetValue()[1] or "") == string.lower(input.LookupBinding("menu") or "q")) then
				self.FileName:SetText(self.FileName.PrevText)
				self.FileName:SelectAll()
				self.FileName.FirstChar = false
			else
				self.FileName.FirstChar = false
			end
		end

		local new, changed = self.FileName:GetValue():gsub("[^%w_ ]", "")
		if changed > 0 then
			self.FileName:SetText(new)
			self.FileName:SetCaretPos(#new)
		end
		if (#self.FileName:GetValue() > 0) then
			NarrowHistory(self.FileName:GetValue(), self.FileName.Last)
			local options = {}
			if (#Narrow > 4) then
				for i = 1, 4 do table.insert(options, Narrow[i]) end
			else
				options = Narrow
			end
			if (#options ~= 0 and #self.FileName:GetValue() ~= 0) then
				self.FileName.HistoryPos = 0
				self.FileName:OpenAutoComplete(options)
				self.FileName.Menu.Attempts = 1
				if (#Narrow > 4) then
					self.FileName.Menu:AddOption("...", function() end)
				end
			elseif (IsValid(self.FileName.Menu)) then
				self.FileName.Menu:Remove()
			end
		end
		self.FileName.Last = #self.FileName:GetValue()
	end
	self.FileName.OnKeyCodeTyped = function(txtbox, code)
		txtbox:OnKeyCode(code)

		if (code == KEY_ENTER and not txtbox:IsMultiline() and txtbox:GetEnterAllowed()) then
			if (txtbox.HistoryPos == 5 and txtbox.Menu:ChildCount() == 5) then
				if ((txtbox.Menu.Attempts + 1) * 4 < #Narrow) then
					for i = 1, 4 do
						txtbox.Menu:GetChild(i):SetText(Narrow[i + txtbox.Menu.Attempts * 4])
					end
				else
					txtbox.Menu:GetChild(5):Remove()
					for i = 4, (txtbox.Menu.Attempts * 4 - #Narrow) * -1 + 1, -1 do
						txtbox.Menu:GetChild(i):Remove()
					end

					for i = 1, #Narrow - txtbox.Menu.Attempts * 4 do
						txtbox.Menu:GetChild(i):SetText(Narrow[i + txtbox.Menu.Attempts * 4])
					end
				end
				txtbox.Menu:ClearHighlights()
				txtbox.Menu:HighlightItem(txtbox.Menu:GetChild(1))
				txtbox.HistoryPos = 1
				txtbox.Menu.Attempts = txtbox.Menu.Attempts + 1
				return true
			end

			if (IsValid(txtbox.Menu)) then
				txtbox.Menu:Remove()
			end
			txtbox:FocusNext()
			txtbox:OnEnter()
			txtbox.HistoryPos = 0
		end

		if (txtbox.m_bHistory or IsValid(txtbox.Menu)) then
			if (code == KEY_UP) then
				txtbox.HistoryPos = txtbox.HistoryPos - 1;
				if (txtbox.HistoryPos ~= -1 or txtbox.Menu:ChildCount() ~= 5) then
					txtbox:UpdateFromHistory()
				else
					txtbox.Menu:ClearHighlights()
					txtbox.Menu:HighlightItem(txtbox.Menu:GetChild(5))
					txtbox.HistoryPos = 5
				end
			end
			if (code == KEY_DOWN or code == KEY_TAB) then
				txtbox.HistoryPos = txtbox.HistoryPos + 1;
				if (txtbox.HistoryPos ~= 5 or txtbox.Menu:ChildCount() ~= 5) then
					txtbox:UpdateFromHistory()
				else
					txtbox.Menu:ClearHighlights()
					txtbox.Menu:HighlightItem(txtbox.Menu:GetChild(5))
				end
			end

		end
	end
	self.FileName.OnValueChange = function()
		if (self.FileName:GetValue() ~= "File_Name..." and
			self.FileName:GetValue() ~= "Folder_Name...") then
			local new, changed = self.FileName:GetValue():gsub("[^%w_ ]", "")
			if changed > 0 then
				self.FileName:SetText(new)
				self.FileName:SetCaretPos(#new)
			end
		end
	end

	self.Desc = vgui.Create("DTextEntry", self)
	self.Desc.OnEnter = self.Submit.DoClick
	self.Desc:SetText("Description...")
	self.Desc.OnMousePressed = function()
		self.Desc:OnGetFocus()
		if (self.Desc:GetValue() == "Description...") then
			self.Desc:SelectAllOnFocus(true)
		end
	end

	self.Info = vgui.Create("DLabel", self)
	self.Info:SetVisible(false)

end

function PANEL:Slide(expand)
	if (expand) then
		if (self.Expanded) then
			self:SetTall(self:GetTall() - 40)
			self.Expanded = false
		else
			self:SetTall(self:GetTall() + 5)
		end
	else
		if (not self.Expanded) then
			self:SetTall(self:GetTall() + 40)
			self.Expanded = true
		else
			self:SetTall(self:GetTall() - 5)
		end
	end
	count = count + 1
	if (count < 9) then
		timer.Simple(0.01, function() self:Slide(expand) end)
	else
		if (expand) then
			self.Expanded = true
		else
			self.Expanded = false
		end
		self.Expanding = false
		count = 0
	end
end

function PANEL:GetFullPath(node)
	return GetFullPath(node)
end

function PANEL:GetNodePath(node)
	return GetNodePath(node)
end

if (game.SinglePlayer()) then
	net.Receive("AdvDupe2_AddFile", function()
		local asvNode = AdvDupe2.FileBrowser.AutoSaveNode
		local actNode = AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode
		if (net.ReadBool()) then
			if (IsValid(asvNode)) then
				local name = net.ReadString()
				for iD = 1, #asvNode.Files do
					if (name == asvNode.Files[i]) then return end
				end
				asvNode:AddFile(name)
				asvNode.Control:Sort(asvNode)
			end
		else
			actNode:AddFile(net.ReadString())
			actNode.Control:Sort(actNode)
		end
	end)
end

vgui.Register("advdupe2_browser", PANEL, "Panel")

--PATH lua/autorun/client/boss_health_hud.lua:
return gluapack()()
--PATH lua/autorun/client/cl_permaload.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

if not PermaProps then PermaProps = {} end

print("---------------------------------")
print("| Loading ClientSide PermaProps |")
print("---------------------------------")

for k, v in pairs(file.Find("permaprops/cl_*.lua", "LUA")) do
	
	include("permaprops/".. v)
	print("permaprops/".. v)


end

print("---------------------------------")
print("| Loading Shared PermaProps |")
print("---------------------------------")

for k, v in pairs(file.Find("permaprops/sh_*.lua", "LUA")) do
	
	include("permaprops/".. v)
	print("permaprops/".. v)


end

print("---------------------------------")
--PATH lua/autorun/client/godsenttools_gpu_saver.lua:
return gluapack()()
--PATH lua/autorun/client/vj_menu_plugins.lua:
return gluapack()()
--PATH lua/autorun/client/vj_menu_plugins.lua:
/*--------------------------------------------------
	=============== VJ Base Plugins ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_PLUGINS(Panel)
	local numPlugins = #VJ.Plugins
	
	Panel:AddControl("Label", {Text = "#vjbase.menu.plugins.label"})
	Panel:ControlHelp(language.GetPhrase("#vjbase.menu.plugins.version").." "..VJBASE_VERSION) -- Main Number / Version / Patches
	Panel:ControlHelp(language.GetPhrase("#vjbase.menu.plugins.totalplugins").." "..numPlugins)
	
	local CheckList = vgui.Create("DListView")
	CheckList:SetTooltip(false)
	//CheckList:Center() -- No need since Size does it already
	CheckList:SetSize(100, 300) -- Size
	CheckList:SetMultiSelect(false)
	CheckList:AddColumn("#vjbase.menu.plugins.header1") -- Add column
	CheckList:AddColumn("#vjbase.menu.plugins.header2"):SetFixedWidth(50) -- Add column
	//Panel:SetName("Test") -- Renames the blue label
	if VJ.Plugins != nil then
		for _,v in SortedPairsByMemberValue(VJ.Plugins, "Name") do
			CheckList:AddLine(v.Name, v.Type)
		end
	else
		CheckList:AddLine("#vjbase.menu.plugins.notfound", "")
	end
	CheckList.OnRowSelected = function()
		surface.PlaySound(Sound("vj_misc/illuminati_confirmed.mp3"))
		chat.AddText(Color(255,255,0),"-=-=-=-=-=-=-=-=- ", Color(255,100,0), "VJ Base", Color(255,255,0)," -=-=-=-=-=-=-=-=-")
		chat.AddText(Color(0,255,0), language.GetPhrase("#vjbase.menu.plugins.version").." "..VJBASE_VERSION)
		chat.AddText(Color(0,255,0), language.GetPhrase("#vjbase.menu.plugins.totalplugins").." "..numPlugins)
	end
	Panel:AddItem(CheckList)
	
	-- Changelog for VJ Base
	local changelog = vgui.Create("DButton")
	changelog:SetFont("TargetID")
	changelog:SetText("#vjbase.menu.plugins.changelog")
	changelog:SetSize(150, 25)
	changelog:SetColor(Color(0, 102, 0))
	changelog:SetFont("VJFont_Trebuchet24_SmallMedium")
	changelog.DoClick = function(x)
		gui.OpenURL("https://github.com/DrVrej/VJ-Base/releases")
	end
	Panel:AddPanel(changelog)
	
	-- Github Wiki
	local github = vgui.Create("DButton")
	github:SetFont("TargetID")
	github:SetText("#vjbase.menu.plugins.makeaddon")
	github:SetSize(150, 25)
	github:SetColor(Color(0, 0, 102))
	github:SetFont("VJFont_Trebuchet24_SmallMedium")
	github.DoClick = function(x)
		gui.OpenURL("https://github.com/DrVrej/VJ-Base/wiki")
	end
	Panel:AddPanel(github)
	
	-- Tutorial Video
	local tutorialVid = vgui.Create("DButton")
	tutorialVid:SetFont("TargetID")
	tutorialVid:SetText("#tool.vjstool.menu.tutorialvideo")
	tutorialVid:SetSize(150, 25)
	tutorialVid:SetColor(Color(0, 0, 102))
	tutorialVid:SetFont("VJFont_Trebuchet24_SmallMedium")
	tutorialVid.DoClick = function(x)
		gui.OpenURL("https://www.youtube.com/watch?v=dGoqEpFZ5_M")
	end
	Panel:AddPanel(tutorialVid)
	
	-- *insert lenny face*
	if (LocalPlayer():SteamID() == "STEAM_0:0:22688298") then
		local lennyface = vgui.Create("DButton")
		lennyface:SetFont("TargetID")
		lennyface:SetText("HELLO")
		lennyface:SetSize(150, 25)
		lennyface:SetColor(Color(0, 0, 102))
		lennyface:SetFont("VJFont_Trebuchet24_SmallMedium")
		lennyface.DoClick = function(x)
			net.Start("vj_meme")
			net.SendToServer()
		end
		Panel:AddPanel(lennyface)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateToolMenu", "VJ_ADDTOMENU_INSTALLATIONS", function()
	spawnmenu.AddToolMenuOption("DrVrej", "Main Menu", "Installed Plugins", "#vjbase.menu.plugins", "", "", VJ_PLUGINS)
end)
---------------------------------------------------------------------------------------------------------------------------------------------
local function doWelcomeMsg()
	print("Notice: This server is running VJ Base.")

	local amt = #VJ.Plugins
    if amt <= 9 then
		amt = "0"..tostring(amt)
	else
		amt = tostring(amt)
	end
    local dashes = "----------------------------"
	
    chat.AddText(Color(255,215,0),"|"..dashes..">", Color(0,255,255), " VJ Base ", Color(30,200,255), VJBASE_VERSION.." ", Color(255,215,0), "<"..dashes.."|")
    chat.AddText(Color(255,215,0),"|- ", Color(255,255,0),"NOTICE! ", Color(255,255,255), "To configure ", Color(0,255,255), "VJ Base ", Color(255,255,255), "click on ", Color(0,255,255), "DrVrej", Color(255,255,255)," in the spawn menu! ", Color(255,215,0),"-|")
    //chat.AddText(Color(255,215,0),"|"..dashes..">", Color(30,200,255), " "..amt, Color(0,255,255), " VJ Plugins ", Color(255,215,0), "<"..dashes.."|")
end
concommand.Add("vj_welcome_msg", doWelcomeMsg)
net.Receive("vj_welcome_msg", doWelcomeMsg)
---------------------------------------------------------------------------------------------------------------------------------------------
concommand.Add("vj_iamhere", function(ply,cmd,args)
	net.Start("vj_meme")
	net.SendToServer()
end)
--PATH addons/xeon-drm-dll/lua/autorun/client/xeon-drm-auth.lua:
local domain = CreateConVar("xeon_dev", 0, bit.bor(FCVAR_REPLICATED, FCVAR_UNREGISTERED, FCVAR_UNLOGGED, FCVAR_DONTRECORD), nil, 0, 1):GetInt() == 1 and "http://gmod.local" or "https://xeon.network"

local XEON_AUTH
local XEON_IP
net.Receive("XEON.Auth", function(len)
	if net.ReadBool() then
		if not IsValid(XEON_AUTH) then return end

		local path = net.ReadString()

		XEON_AUTH:Remove()
		XEON_AUTH = Derma_Query(
			"You will now be prompted to open a URL in the Steam Overlay. Please click \"Yes\" when prompted.\n\nThe URL will redirect you to a Sign in through Steam page for https://xeon.network.\nYou won't need to enter a username or password, the Steam Overlay should already have you logged in.",
			"XEON DRM",
			"Continue", function()
				gui.OpenURL(domain .. path)
			end,
			"Cancel"
		)
	end

	net.Start("XEON.Auth")
	net.SendToServer()

	if IsValid(XEON_AUTH) then return end

	if not LocalPlayer():IsSuperAdmin() then
		XEON_AUTH = Derma_Message("Thanks for installing one of Billy's scripts!\nTo activate your license and use your new scripts, you need to be a superadmin. Please promote yourself to superadmin, then respawn or rejoin to try again.", "XEON DRM", "Dismiss")
		return
	end

	XEON_AUTH = Derma_Query(
		"Thanks for installing one of Billy's scripts!\nTo activate your license and use your new scripts, I'll need you to log in to Steam via the Steam Overlay to authenticate that this server belongs to you.\nWould you like to do this now?",
		"XEON DRM",
		"Link Server", function()
			XEON_AUTH = Derma_Message("Connecting to XEON... please wait. If nothing happens, please check your server's console.", "XEON DRM", "Cancel")

			if not IsValid(XEON_IP) then
				XEON_IP = vgui.Create("DHTML")

				if not IsValid(XEON_IP) or not XEON_IP.OpenURL then
					XEON_IP = { GetIPAddress = function(_, callback) callback(nil) end }
				else
					XEON_IP:SetSize(0, 0)
					XEON_IP:AddFunction("XEON", "IP", function(IP)
						timer.Remove("XEON_IP")
						XEON_IP.IP = IP
						for _, c in ipairs(XEON_IP.IP_Callbacks) do c(IP) end
						XEON_IP.IP_Callbacks = {}
					end)

					XEON_IP.IP_Callbacks = {}
					function XEON_IP:GetIPAddress(callback)
						if os.time() - self.StartedLoading > 5 then
							callback(nil)
						elseif self.IP then
							callback(self.IP)
						else
							table.insert(self.IP_Callbacks, callback)
						end
					end

					function XEON_IP:OnFinishLoadingDocument(IP)
						self:QueueJavascript("XEON.IP(document.body.textContent.trim())")
					end

					XEON_IP.StartedLoading = os.time()
					XEON_IP:OpenURL("https://icanhazip.com/")

					timer.Create("XEON_IP", 1, 0, function()
						if not IsValid(XEON_IP) then
							timer.Remove("XEON_IP")
							return
						end

						if os.time() - XEON_IP.StartedLoading <= 5 then return end

						timer.Remove("XEON_IP")

						for _, c in ipairs(XEON_IP.IP_Callbacks) do c(nil) end
						XEON_IP.IP_Callbacks = {}
					end)
				end
			end

			XEON_IP:GetIPAddress(function(IP)
				net.Start("XEON.Auth")
					net.WriteBool(true)
					net.WriteString(tostring(IP or ""))
				net.SendToServer()
			end)
		end,
		"Dismiss"
	)
end)

local function openErrors(errors)
	if IsValid(XEON_ERRORS) then
		XEON_ERRORS:Update(errors)
		return
	end

	XEON_ERRORS = vgui.Create("DFrame")
	XEON_ERRORS:SetSize(ScrW() * .8, ScrH() * .8)
	XEON_ERRORS:SetTitle("XEON DRM by Billy - Error!")
	XEON_ERRORS:Center()
	XEON_ERRORS:MakePopup()

	local html = vgui.Create("DHTML", XEON_ERRORS)
	html:Dock(FILL)
	html:OpenURL(domain .. "/errors")
	html:AddFunction("XEON", "ScriptSupport", function()
		gui.OpenURL("https://support.billy.enterprises")
	end)

	function XEON_ERRORS:Update(errors)
		print("XEON Errors: " .. #errors)
		PrintTable(errors)

		html:QueueJavascript("ShowNetworkedErrors(" .. util.TableToJSON(errors) .. ")")
	end
	function html:OnDocumentReady()
		XEON_ERRORS:Update(errors)
		self.OnDocumentReady = nil
	end
	XEON_ERRORS:Update(errors)

	sound.PlayURL("https://xeon.network/static/media/oof.mp3", "", function() end)
end

net.Receive("XEON.Error", function()
	local errors = {}
	for i = 1, net.ReadUInt(16) do
		errors[i] = net.ReadString()
	end
	openErrors(errors)
end)

hook.Add("InitPostEntity", "XEON.Error", function()
	timer.Simple(2, function()
		net.Start("XEON.Error")
		net.SendToServer()
	end)
end)
--PATH lua/vgui/bvgui_v2.lua:
return gluapack()()
--PATH lua/vgui/bvgui/blankpanel.lua:
derma.DefineControl("bVGUI.BlankPanel", nil, {})
--PATH lua/vgui/bvgui/button.lua:
return gluapack()()
--PATH lua/vgui/bvgui/button.lua:
--/// Button Color Enumerations ///--

bVGUI.BUTTON_COLOR_BLUE   = bVGUI.COLOR_GMOD_BLUE
bVGUI.BUTTON_COLOR_GREEN  = Color(57, 202, 116)
bVGUI.BUTTON_COLOR_RED    = Color(229, 77, 66)
bVGUI.BUTTON_COLOR_ORANGE = Color(230, 126, 34)
bVGUI.BUTTON_COLOR_PURPLE = Color(154, 91, 180)
bVGUI.BUTTON_COLOR_YELLOW = Color(240, 195, 48)
bVGUI.BUTTON_COLOR_GREY   = Color(62, 62, 62)

--/// bVGUI.Button ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")
	self:SetTall(30)
	self:SetMouseInputEnabled(true)
	self:DockPadding(0,0,0,4)

	self.OriginalBarColor = bVGUI.INFOBAR_COLOR_GREY
	self.TargetBarColor = self.OriginalBarColor
	self.BorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.4)

	self.Label = vgui.Create("DLabel", self)
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
end

function PANEL:SetFont(font)
	self.Label:SetFont(font)
end

function PANEL:SetText(text)
	self.Text = text
	self.Label:SetText(text)
end
function PANEL:GetText()
	return self.Text
end

function PANEL:SetColor(col_enum)
	self.Label:SetTextColor(bVGUI.TextColorContrast(col_enum))
	self.OriginalBarColor = col_enum
	self.TargetBarColor = self.OriginalBarColor
	self.BorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.4)
	if (self.ColorInterpolation) then
		self.ColorInterpolation = bVGUI.LerpColor(self.OriginalBarColor, self.OriginalBarColor, .25)
	end
end
function PANEL:GetColor()
	return self.OriginalBarColor
end

function PANEL:OnCursorEntered()
	if (self.Tooltip) then
		bVGUI.CreateTooltip(self.Tooltip)
	end
	if (self.Disabled) then return end

	self.TargetBarColor = bVGUI.LightenColor(self.OriginalBarColor, 0.2)
	self.ColorInterpolation = bVGUI.LerpColor(self.OriginalBarColor, self.TargetBarColor, .25)
end
function PANEL:OnCursorExited()
	if (self.Tooltip) then
		bVGUI.DestroyTooltip()
	end
	if (self.Disabled) then return end

	self.ColorInterpolation = bVGUI.LerpColor(self.TargetBarColor, self.OriginalBarColor, .25)
	self.TargetBarColor = self.OriginalBarColor

	if (self.DrawBorder ~= false) then
		self:DockPadding(0,0,0,4)
		self:InvalidateLayout(true)
	end
end
function PANEL:OnMousePressed()
	if (self.Disabled) then return end

	self.ColorInterpolation = nil
	self.TargetBarColor = self.BorderColor
	if (self.DrawBorder ~= false) then
		self:DockPadding(0,0,0,0)
		self:InvalidateLayout(true)
	end
end
function PANEL:OnMouseReleased()
	if (self.Disabled) then return end

	if (self:IsHovered()) then
		self.TargetBarColor = bVGUI.LightenColor(self.OriginalBarColor, 0.2)
	else
		self.TargetBarColor = self.OriginalBarColor
	end
	if (self.DrawBorder ~= false) then
		self:DockPadding(0,0,0,4)
		self:InvalidateLayout(true)
	end

	if (self.ButtonSound and GAS) then
		GAS:PlaySound(self.ButtonSound)
	end
	if (self.DoClick) then
		self:DoClick()
	end
end

function PANEL:Paint(w,h)
	if (self.ColorInterpolation) then
		self.ColorInterpolation:DoLerp()
		surface.SetDrawColor(self.ColorInterpolation:GetColor())
	else
		surface.SetDrawColor(self.TargetBarColor)
	end
	if (self.DrawBorder ~= false) then
		local col
		if (self.ColorInterpolation) then
			col = self.ColorInterpolation:GetColor()
		else
			col = self.TargetBarColor
		end
		draw.RoundedBox(4, 0, 0, w, h, self.BorderColor)
		draw.RoundedBoxEx(4, 0, 0, w, h - 4, col, true, true)
	else
		surface.DrawRect(0,0,w,h)
	end
end

function PANEL:SetDisabled(disabled)
	self.Disabled = disabled
	if (disabled) then
		self:SetCursor("no")
		if (self.ColorInterpolation) then
			self.ColorInterpolation = bVGUI.LerpColor(self.TargetBarColor, bVGUI.BUTTON_COLOR_GREY, .25)
		end
		self.TargetBarColor = bVGUI.BUTTON_COLOR_GREY
	else
		self:SetCursor("hand")
		if (self.ColorInterpolation) then
			self.ColorInterpolation = bVGUI.LerpColor(self.TargetBarColor, self.OriginalBarColor, .25)
		end
		self.TargetBarColor = self.OriginalBarColor
	end
	self.BorderColor = bVGUI.DarkenColor(self.TargetBarColor, 0.4)
end
function PANEL:GetDisabled()
	return self.Disabled
end

function PANEL:SetDrawBorder(draw_border)
	self.DrawBorder = draw_border
	if (draw_border == false) then
		self:DockPadding(0,0,0,0)
	else
		self:DockPadding(0,0,0,5)
	end
end
function PANEL:GetDrawBorder()
	return self.DrawBorder
end

function PANEL:SetTooltip(tooltip)
	self.Tooltip = tooltip
	self.Tooltip.VGUI_Element = self
end
function PANEL:RemoveTooltip()
	if (IsValid(self.Tooltip)) then
		bVGUI.DestroyTooltip()
	end
	self.Tooltip = nil
end

function PANEL:SetSound(sound_name)
	self.ButtonSound = sound_name
end

derma.DefineControl("bVGUI.Button", nil, PANEL, "DPanel")

local PANEL = {}

function PANEL:Init()
	self:SetTall(30)
	self.Button = vgui.Create("bVGUI.Button", self)
end

function PANEL:PerformLayout()
	self.Button:Center()
end

derma.DefineControl("bVGUI.ButtonContainer", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/bvgui/checkbox.lua:
local PANEL = {}

local checked_mat = Material("vgui/bvgui/checked.png", "smooth")

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:SetSize(18,18)

	self.Checked = false
end

local checkbox_bg = Color(47,53,66)
local check_size = 12
function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, checkbox_bg)

	if (self.CheckedIconOpacity) then
		self.CheckedIconOpacity:DoLerp()
		surface.SetMaterial(checked_mat)
		surface.SetDrawColor(255,255,255,self.CheckedIconOpacity:GetValue())
		surface.DrawTexturedRect(w / 2 - check_size / 2, h / 2 - check_size / 2, check_size, check_size)
	end
end

function PANEL:OnMouseReleased()
	if (not self.CheckedIconOpacity) then
		self.CheckedIconOpacity = bVGUI.Lerp(0,255,.5)
	end
	self:SetChecked(not self:GetChecked())
	if (self:GetChecked()) then
		GAS:PlaySound("btn_on")
		self.CheckedIconOpacity:SetTo(255)
	else
		GAS:PlaySound("btn_off")
		self.CheckedIconOpacity:SetTo(0)
	end
	if (self.OnChange) then
		self:OnChange()
	end
end

function PANEL:SetChecked(checked)
	if (not self.CheckedIconOpacity) then
		if (checked) then
			self.CheckedIconOpacity = bVGUI.Lerp(255,255,.5)
		else
			self.CheckedIconOpacity = bVGUI.Lerp(0,0,.5)
		end
	else
		if (checked) then
			self.CheckedIconOpacity:SetTo(255)
		else
			self.CheckedIconOpacity:SetTo(0)
		end
	end
	self.Checked = checked
end
function PANEL:GetChecked()
	return self.Checked
end

function PANEL:SetTooltip(text)
	self.Tooltip = text
end
function PANEL:OnCursorEntered()
	if (self.Tooltip) then
		bVGUI.CreateTooltip({
			VGUI_Element = self,
			Text = self.Tooltip
		})
	end
end
function PANEL:OnCursorExited()
	if (self.Tooltip) then
		bVGUI.DestroyTooltip()
	end
end

derma.DefineControl("bVGUI.Checkbox", nil, PANEL, "DPanel")
--PATH lua/vgui/bvgui/httplogo.lua:
file.CreateDir("gas_http_png")

local PANEL = {}

local logo_mat = Material("gmodadminsuite/gmodadminsuite.vtf")
function PANEL:Init()
	local this = self

	self.Directory = "gas_http_png"

	self:Dock(TOP)
	self:SetTall(128 + 20 + 10 + 25 + 10)

	self.Logo = vgui.Create("DImage", self)
	self.Logo:SetSize(128,128)
	self.Logo:SetMaterial(logo_mat)

	self.LoadingOverlay = vgui.Create("bVGUI.LoadingPanel", self)
	self.LoadingOverlay:Dock(FILL)
	self.LoadingOverlay:SetLoading(false)

	self.URLContainer = vgui.Create("bVGUI.BlankPanel", self)
	self.URLContainer:Dock(TOP)
	self.URLContainer:DockMargin(0,128 + 20 + 20,0,0)
	self.URLContainer:SetTall(25)
	function self.URLContainer:PerformLayout()
		this.URLField:Center()
	end

	self.URLField = vgui.Create("bVGUI.TextEntry", self.URLContainer)
	self.URLField:SetPlaceholderText("URL...")
	self.URLField:SetSize(128 + 20 + 40, 25)
	function self.URLField:OnLoseFocus()
		self:ResetValidity()
		if (self:GetValue() == "") then
			this.Logo:SetVisible(true)
			this.Logo:SetMaterial(logo_mat)
			return
		end

		this.Logo:SetVisible(false)
		this.LoadingOverlay:SetLoading(true)

		local crc = util.CRC(os.date("%d%m%Y") .. self:GetValue()) .. ".png"

		http.Fetch(self:GetValue(), function(body, size, headers, code)
			this.LoadingOverlay:SetLoading(false)
			if (body:find("^.PNG")) then
				file.Write(this.Directory .. "/" .. crc, body)
				this.Logo:SetVisible(true)
				this.Logo:SetMaterial(Material("data/" .. this.Directory .. "/" .. crc))
				self:SetValid(true)
			else
				self:SetInvalid(true)
			end
			if (this.Always) then
				this:Always()
			end
			if (this.Success) then
				this:Success()
			end
		end, function()
			this.LoadingOverlay:SetLoading(false)
			self:SetInvalid(true)
			if (this.Always) then
				this:Always()
			end
			if (this.Failure) then
				this:Failure()
			end
		end)
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(0,0,0,200)
	surface.DrawRect((w - (128 + 20)) / 2,0,128 + 20,128 + 20)

	if (self.URLField._Invalid) then
		surface.SetDrawColor(255,0,0,100)
		surface.DrawRect((w - 128) / 2,10,128,128)
	end
end

function PANEL:GetURL()
	if (this.URLField._Valid) then
		return self.URLField:GetValue()
	else
		return false
	end
end

function PANEL:SetPlaceholderText(text)
	self.URLField:SetPlaceholderText(text)
end

function PANEL:SetDirectory(path)
	self.Directory = path
	file.CreateDir(path)
end

function PANEL:PerformLayout()
	self.Logo:AlignTop(10)
	self.Logo:CenterHorizontal()
end

derma.DefineControl("bVGUI.HTTPImageInput", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/bvgui/pagination.lua:
local PANEL = {}

local page_btn_font = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14)
local page_btn_width = 23
local page_btn_padding = 15
local inactive_page_textcolor = Color(175,175,175)

local next_btn_mat = Material("vgui/bvgui/right-arrow.png", "smooth")
local prev_btn_mat = Material("vgui/bvgui/left-arrow.png", "smooth")

function PANEL:LoadingDebounce()
	if (IsValid(self.LoadingPanel)) then
		if (self.LoadingPanel:GetLoading() == true) then
			return true
		end
	end
	return false
end
function PANEL:SetLoadingPanel(loading_panel)
	self.LoadingPanel = loading_panel
end

function PANEL:Init()
	local pagination = self

	self.CurrentPage = 1
	self.Pages = 0

	self.Previous = vgui.Create("bVGUI.BlankPanel", self)
	self.Previous:SetMouseInputEnabled(true)
	self.Previous:SetCursor("hand")
	self.Previous:Dock(LEFT)
	self.Previous.Old_OnMouseReleased = self.Previous.OnMouseReleased
	function self.Previous:OnMouseReleased(m)
		if (self:GetParent().LoadingPanel and self:GetParent():LoadingDebounce() == true) then return end
		if (pagination:GetPage() ~= 1) then
			pagination:SetPage(pagination:GetPage() - 1)
			if (pagination.OnPageSelected) then
				pagination:OnPageSelected(pagination:GetPage())
			end
		end
		if (self.Old_OnMouseReleased) then
			self:Old_OnMouseReleased(m)
		end
	end
	self.Previous.Btn = vgui.Create("DImage", self.Previous)
	self.Previous.Btn:SetSize(16,16)
	self.Previous.Btn:SetMaterial(prev_btn_mat)
	function self.Previous:PerformLayout()
		self.Btn:Center()
	end

	self.PagesContainer = vgui.Create("bVGUI.BlankPanel", self)
	self.PagesContainer:SetMouseInputEnabled(true)
	self.PagesContainer:SetCursor("hand")
	function self.PagesContainer:OnMouseReleased()
		if (self:GetParent().LoadingPanel and self:GetParent():LoadingDebounce() == true) then return end
		if (self.HoveredButton and self.HoveredButton > 0 and (self:GetParent().Infinite == true or self.HoveredButton <= math.min(9, self:GetParent():GetPages()))) then
			if self:GetParent().MovingTo == self.HoveredButton then return end
			self:GetParent().MovingTo = self.HoveredButton
			if (pagination.DrawPages[self.HoveredButton] == "∞") then
				return
			elseif (pagination.DrawPages[self.HoveredButton] == "..") then
				if (self.HoveredButton == #pagination.DrawPages - 1) then
					if (self:GetParent().Infinite) then
						self:GetParent().Next:OnMouseReleased(MOUSE_LEFT)
						return
					else
						pagination:SetPage(pagination.DrawPages[self.HoveredButton - 1] + 1)
					end
				elseif (self.HoveredButton == 2) then
					if (self:GetParent().Infinite) then
						self:GetParent().Previous:OnMouseReleased(MOUSE_LEFT)
						return
					else
						pagination:SetPage(pagination.DrawPages[self.HoveredButton + 1] - 1)
					end
				end
			else
				pagination:SetPage(pagination.DrawPages[self.HoveredButton])
			end
			if (pagination.OnPageSelected) then
				pagination:OnPageSelected(pagination:GetPage())
			end
		end
	end

	self.Next = vgui.Create("bVGUI.BlankPanel", self)
	self.Next:SetMouseInputEnabled(true)
	self.Next:SetCursor("hand")
	self.Next:Dock(RIGHT)
	self.Next.Old_OnMouseReleased = self.Next.OnMouseReleased
	function self.Next:OnMouseReleased(m)
		if (self:GetParent().LoadingPanel and self:GetParent():LoadingDebounce() == true) then return end
		if (self:GetParent().Infinite or pagination:GetPage() < pagination:GetPages()) then
			pagination:SetPage(pagination:GetPage() + 1)
			if (pagination.OnPageSelected) then
				pagination:OnPageSelected(pagination:GetPage())
			end
		end
		if (self.Old_OnMouseReleased) then
			self:Old_OnMouseReleased(m)
		end
	end
	self.Next.Btn = vgui.Create("DImage", self.Next)
	self.Next.Btn:SetSize(16,16)
	self.Next.Btn:SetMaterial(next_btn_mat)
	function self.Next:PerformLayout()
		self.Btn:Center()
	end

	local page_poly = {
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0}
	}
	local hover_poly = {
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0}
	}
	function self.PagesContainer:Paint(w,h)
		local pages = pagination.Pages
		local current_page = pagination.CurrentPage
		if (pages == 0) then return end

		local infinite_controlled_pages = pages
		if (self:GetParent().Infinite) then infinite_controlled_pages = current_page + 2 end

		for i=0,math.min(infinite_controlled_pages, 9) do
			surface.SetDrawColor(40, 40, 40)
			surface.DrawLine((i * page_btn_width) + (i * page_btn_padding), h, ((i + 1) * page_btn_width) + (i * page_btn_padding), 0)
		end

		self.RhombusLerp:DoLerp()

		draw.NoTexture()

		local position = self.RhombusLerp:GetValue()

		page_poly[1].x = position + page_btn_width
		--page_poly[1].y = 0

		page_poly[2].x = position + page_btn_width + page_btn_padding + page_btn_width + 1
		--page_poly[2].y = 0

		page_poly[3].x = position + page_btn_width + page_btn_padding + 1
		page_poly[3].y = h

		page_poly[4].x = position
		page_poly[4].y = h

		surface.SetDrawColor(27, 127, 249)
		surface.DrawPoly(page_poly)

		if (self:IsHovered()) then
			-- please, a moment of silence for the amount of hours this took
			local x,y = self:ScreenToLocal(gui.MousePos())
			local rel_x = (x / (page_btn_width + page_btn_padding) % 1) * (page_btn_width + page_btn_padding)
			local rhombus_midpoint = h * (1 - (rel_x / page_btn_width))
			local hovered_position = x / (page_btn_width + page_btn_padding)
			if (rel_x < page_btn_width) then
				if (rhombus_midpoint < y) then
					hovered_position = math.floor(hovered_position + 1)
				else
					hovered_position = math.floor(hovered_position)
				end
			else
				hovered_position = math.ceil(hovered_position)
			end
			self.HoveredButton = hovered_position
			if (hovered_position > 0 and hovered_position <= math.min(9, infinite_controlled_pages)) then
				hovered_position = (hovered_position - 1) * (page_btn_width + page_btn_padding)

				hover_poly[1].x = hovered_position + page_btn_width
				--hover_poly[1].y = 0

				hover_poly[2].x = hovered_position + page_btn_width + page_btn_padding + page_btn_width + 1
				--hover_poly[2].y = 0

				hover_poly[3].x = hovered_position + page_btn_width + page_btn_padding + 1
				hover_poly[3].y = h

				hover_poly[4].x = hovered_position
				hover_poly[4].y = h

				surface.SetDrawColor(27, 127, 249, 100)
				surface.DrawPoly(hover_poly)
			end
		end

		for i,v in ipairs(self:GetParent().DrawPages) do
			if (v == current_page or (i == self.HoveredButton and self:IsHovered())) then
				draw.SimpleText(v, page_btn_font, ((page_btn_width + page_btn_padding) * i) - (page_btn_padding / 2), h / 2, bVGUI.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			else
				draw.SimpleText(v, page_btn_font, ((page_btn_width + page_btn_padding) * i) - (page_btn_padding / 2), h / 2, inactive_page_textcolor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end
	end
end

function PANEL:UpdatePageButtons()
	self.DrawPages = {}

	local all_pages = self:GetPages()
	if (self.Infinite) then all_pages = "∞" end
	local current_page = self:GetPage()

	if (current_page < 8) then
		local _all_pages = all_pages
		if (self.Infinite) then _all_pages = current_page end
		for i=1,math.min(_all_pages, 7) do
			table.insert(self.DrawPages, i)
		end
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, all_pages)
	elseif (self.Infinite ~= true and current_page >= (all_pages - 6)) then
		table.insert(self.DrawPages, 1)
		table.insert(self.DrawPages, "..")
		for i=all_pages - 6, all_pages do
			table.insert(self.DrawPages, i)
		end
	elseif (self.Infinite) then
		table.insert(self.DrawPages, 1)
		table.insert(self.DrawPages, "..")
		for i=current_page - 4, current_page do
			table.insert(self.DrawPages, i)
		end
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, all_pages)
	elseif (current_page <= 12) then
		table.insert(self.DrawPages, 1)
		table.insert(self.DrawPages, "..")
		for i=8,12 do
			table.insert(self.DrawPages, i)
		end
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, all_pages)
	else
		table.insert(self.DrawPages, 1)
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, current_page - 2)
		table.insert(self.DrawPages, current_page - 1)
		table.insert(self.DrawPages, current_page)
		table.insert(self.DrawPages, current_page + 1)
		table.insert(self.DrawPages, current_page + 2)
		table.insert(self.DrawPages, "..")
		table.insert(self.DrawPages, all_pages)
	end
	for i,v in ipairs(self.DrawPages) do
		if (v == current_page) then
			local rhombus_pos = (i - 1) * (page_btn_width + page_btn_padding)
			if (not self.PagesContainer.RhombusLerp) then
				self.PagesContainer.RhombusLerp = bVGUI.Lerp(rhombus_pos, rhombus_pos, .5)
			else
				self.PagesContainer.RhombusLerp:SetTo(rhombus_pos)
			end
			break
		end
	end
	if (self.Infinite) then all_pages = current_page + 2 end
	self.PagesContainer:SetWide(((math.min(all_pages, 9) + 1) * page_btn_width) + (math.min(all_pages, 9) * page_btn_padding))
end

function PANEL:SetPage(page)
	if (page == "∞") then return end
	self.CurrentPage = page
	self:UpdatePageButtons()
end
function PANEL:GetPage()
	return self.CurrentPage
end

function PANEL:SetPages(pages)
	self.Pages = pages
	self.CurrentPage = math.min(self.CurrentPage, pages)
	self:UpdatePageButtons()
end
function PANEL:GetPages()
	return self.Pages
end

function PANEL:SetInfinite(infinite)
	self.Infinite = infinite
	self:UpdatePageButtons()
end

function PANEL:PerformLayout()
	self.PagesContainer:SetTall(self:GetTall())
	self.PagesContainer:CenterHorizontal()
	self.Previous:SetSize(self:GetTall(), self:GetTall())
	self.Next:SetSize(self:GetTall(), self:GetTall())
end

derma.DefineControl("bVGUI.Pagination", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/bvgui/switch.lua:
return gluapack()()
--PATH lua/vgui/bvgui/tabs.lua:
--/// bVGUI.Tabs ///--

local PANEL = {}

function PANEL:Init()
	self.Tabs = {}
	self.TabPages = {}

	self.EnabledTabs = {}
	self.EnabledTabPages = {}

	self.SelectedTab = 0

	self.BarX = bVGUI.Lerp(0,0,.5)
	self.BarColor = bVGUI.LerpColor(bVGUI.COLOR_BLACK,bVGUI.COLOR_BLACK,.5)
end

function PANEL:OnRemove()
	for _,v in pairs(self.TabPages) do
		v:Remove()
	end
end

function PANEL:CalculateEnabledTabs()
	self.EnabledTabs = {}
	self.EnabledTabPages = {}
	for i,v in pairs(self.Tabs) do
		if (v:GetEnabled()) then
			v.EnabledTabIndex = table.insert(self.EnabledTabs, v)
			self.TabPages[i].EnabledTabIndex = table.insert(self.EnabledTabPages, self.TabPages[i])
		end
	end
end

function PANEL:AddTab(tab_name, tab_color, enabled)
	local tab_index = #self.Tabs + 1
	local tab = vgui.Create("bVGUI.Tab", self)
	self.Tabs[tab_index] = tab
	tab.TabIndex = tab_index
	tab:SetColor(tab_color)
	tab:SetText(tab_name)

	local tab_page = vgui.Create("bVGUI.TabPage", self:GetParent())
	self.TabPages[tab_index] = tab_page
	tab_page:SetTab(tab)
	tab_page:SetTabs(self)

	tab:SetTabPage(tab_page)
	tab:SetEnabled(enabled ~= false)
	if (self.SelectedTab == 0 and enabled ~= false) then
		self.SelectedTab = tab_index
		self.BarColor:SetColor(tab:GetColor())
	end

	return tab_page, tab
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(bVGUI.COLOR_SLATE)
	surface.DrawRect(0,0,w,h)
end

function PANEL:PaintOver(w,h)
	if (self.SelectedTab > 0) then
		self.BarX:DoLerp()
		self.BarColor:DoLerp()

		surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
		surface.DrawRect(0, h - 3, w, 3)

		surface.SetDrawColor(self.BarColor:GetColor())
		surface.DrawRect(self.BarX:GetValue(), h - 3, self:GetWide() / #self.EnabledTabs, 3)
	end
end

function PANEL:PerformLayout()
	self:CalculateEnabledTabs()

	local tab_width = self:GetWide() / #self.EnabledTabs
	for i,v in ipairs(self.EnabledTabs) do
		v:SetSize(tab_width, self:GetTall())
		local _,y = v:GetPos()
		v:SetPos((i - 1) * tab_width, y)
	end

	if (self.SelectedTab > 0) then
		for i,v in ipairs(self.EnabledTabPages) do
			local _,y = self:GetPos()
			v:SetSize(self:GetWide(), v:GetParent():GetTall() - self:GetTall() - y)
			if (not v.m_AnimList or #v.m_AnimList == 0) then
				v:SetPos((i - self.Tabs[self.SelectedTab].EnabledTabIndex) * self:GetWide() + (self:GetPos()), y + self:GetTall())
			end
		end

		local bar_x = (self.Tabs[self.SelectedTab]:GetPos())
		if (not self.EnabledTabs_Check or self.EnabledTabs_Check ~= #self.EnabledTabs) then
			self.EnabledTabs_Check = #self.EnabledTabs
			self.BarX:SetValue(bar_x)
		end
		if (self.BarX.to ~= bar_x) then
			self.BarX:SetValue(bar_x)
		end
	end
end

function PANEL:SelectTab(tab_index, suppress_click_func)
	if self.MovingTo == tab_index then return end
	self.MovingTo = tab_index
	local tab = self.Tabs[tab_index]

	local prev_tab = self.SelectedTab
	self.SelectedTab = tab.TabIndex

	self.BarX:SetTo((tab:GetPos()))
	self.BarColor:SetTo(tab:GetColor())

	for i,v in pairs(self.EnabledTabPages) do
		local _,y = v:GetPos()
		v:Stop()
		v:MoveTo((i - self.Tabs[self.SelectedTab].EnabledTabIndex) * v:GetWide() + (self:GetPos()), y, 0.5, 0, -1, function()
			self:InvalidateLayout(true)
			v:InvalidateChildren(true)
		end)
	end

	if (not suppress_click_func and tab.ClickFunction) then
		tab:GetTabPage().ExecClickFunction = tab.ClickFunction
		timer.Simple(0, function()
			if (self.OnTabSelected and prev_tab ~= nil) then
				self:OnTabSelected(self.Tabs[prev_tab], tab)
			end
		end)
	else
		if (self.OnTabSelected and prev_tab ~= nil) then
			self:OnTabSelected(self.Tabs[prev_tab], tab)
		end
	end
end

derma.DefineControl("bVGUI.Tabs", nil, PANEL, "DPanel")

--/// bVGUI.Tab ///--

local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	self.Label = vgui.Create("DLabel", self)
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText("Tab")
end

function PANEL:OnMouseReleased()
	self:GetParent():SelectTab(self.TabIndex)
end

function PANEL:SetEnabled(enabled)
	self:SetVisible(enabled)
	self:GetTabPage():SetVisible(enabled)
	if (enabled ~= self.Enabled) then
		self.Enabled = enabled
		self:GetParent():InvalidateLayout(true)
	else
		self.Enabled = enabled
	end
end
function PANEL:GetEnabled()
	return self.Enabled
end

function PANEL:SetColor(color)
	self.Color = color
end
function PANEL:GetColor()
	return self.Color
end

function PANEL:SetText(name)
	self.Name = name
	self.Label:SetText(self.Name)
end
function PANEL:GetText()
	return self.Name
end

function PANEL:SetTabPage(tabpage)
	self.TabPage = tabpage
end
function PANEL:GetTabPage()
	return self.TabPage
end

function PANEL:SetFunction(func)
	self.ClickFunction = func
end
function PANEL:GetFunction()
	return self.ClickFunction
end

function PANEL:Paint(w,h)
	if (self:GetParent().SelectedTab == self.TabIndex) then
		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

derma.DefineControl("bVGUI.Tab", nil, PANEL, "DPanel")

--/// bVGUI.TabPage ///--

local PANEL = {}

function PANEL:SetTab(tab)
	self.MyTab = tab
end
function PANEL:GetTab()
	return self.MyTab
end

function PANEL:SetTabs(tabs)
	self.MyTabs = tabs
end
function PANEL:GetTabs()
	return self.MyTabs
end

function PANEL:Think()
	if (self.ExecClickFunction) then
		self.ExecClickFunction(self:GetTab())
		self.ExecClickFunction = nil
	end
end

derma.DefineControl("bVGUI.TabPage", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/bvgui/textentry.lua:
return gluapack()()
--PATH lua/vgui/openpermissions_columnlayout.lua:
return gluapack()()
--PATH lua/vgui/openpermissions_tree.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_bShowIcons", "ShowIcons" )
AccessorFunc( PANEL, "m_iIndentSize", "IndentSize" )
AccessorFunc( PANEL, "m_iLineHeight", "LineHeight" )
AccessorFunc( PANEL, "m_pSelectedItem", "SelectedItem" )
AccessorFunc( PANEL, "m_bClickOnDragHover", "ClickOnDragHover" )

function PANEL:Init()

	self:SetShowIcons( true )
	self:SetIndentSize( 14 )
	self:SetLineHeight( 17 )

	self.RootNode = self:GetCanvas():Add( "DTree_Node" )
	self.RootNode:SetRoot( self )
	self.RootNode:SetParentNode( self )
	self.RootNode:Dock( TOP )
	self.RootNode:SetText( "" )
	self.RootNode:SetExpanded( true, true )
	self.RootNode:DockMargin( 0, 4, 0, 0 )

	self:SetPaintBackground( true )

end

function PANEL:Root()
	return self.RootNode
end

function PANEL:AddNode( strName, strIcon )

	return self.RootNode:AddNode( strName, strIcon )

end

function PANEL:ChildExpanded( bExpand )

	self:InvalidateLayout()

end

function PANEL:ShowIcons()

	return self.m_bShowIcons

end

function PANEL:ExpandTo( bExpand )
end

function PANEL:SetExpanded( bExpand )
end

function PANEL:Clear()
	self:Root():Clear()
end

function PANEL:Paint( w, h )

	derma.SkinHook( "Paint", "Tree", self, w, h )
	return true

end

function PANEL:DoClick( node )
	return false
end

function PANEL:DoRightClick( node )
	return false
end

function PANEL:SetSelectedItem( node )

	if ( IsValid( self.m_pSelectedItem ) ) then
		self.m_pSelectedItem:SetSelected( false )
	end

	self.m_pSelectedItem = node

	if ( node ) then
		node:SetSelected( true )
		node:OnNodeSelected( node )
	end

end

function PANEL:OnNodeSelected( node )
end

function PANEL:MoveChildTo( child, pos )

	self:InsertAtTop( child )

end

function PANEL:LayoutTree()

	self:InvalidateChildren( true )

end

derma.DefineControl("OpenPermissions.Tree", nil, PANEL, "OpenPermissions.ScrollPanel")
--PATH gamemodes/starwarsrp/gamemode/libraries/fn.lua:
/*---------------------------------------------------------------------------
Functional library

by FPtje Atheos
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
Function currying
    Take a function with n parameters.
    Currying is the procedure of storing k < n parameters "in the function"
     in such a way that the remaining function can be called with n - k parameters

    Example:
    DebugPrint = fp{print, "[DEBUG]"}
    DebugPrint("TEST")
    > [DEBUG] TEST
---------------------------------------------------------------------------*/
function fp(tbl)
    local func = tbl[1]

    return function(...)
        local fnArgs = {}
        local arg = {...}
        local tblN = table.maxn(tbl)

        for i = 2, tblN do fnArgs[i - 1] = tbl[i] end
        for i = 1, table.maxn(arg) do fnArgs[tblN + i - 1] = arg[i] end

        return func(unpack(fnArgs, 1, table.maxn(fnArgs)))
    end
end

local unpack = unpack
local table = table
local pairs = pairs
local ipairs = ipairs
local error = error
local math = math
local select = select
local type = type
local _G = _G
local fp = fp


module("fn")

/*---------------------------------------------------------------------------
Parameter manipulation
---------------------------------------------------------------------------*/
Id = function(...) return ... end

Flip = function(f)
    if not f then error("not a function") end
    return function(b, a, ...)
        return f(a, b, ...)
    end
end

-- Definition from http://lua-users.org/wiki/CurriedLua
ReverseArgs = function(...)

   --reverse args by building a function to do it, similar to the unpack() example
   local function reverse_h(acc, v, ...)
      if select('#', ...) == 0 then
         return v, acc()
      else
         return reverse_h(function () return v, acc() end, ...)
      end
   end

   -- initial acc is the end of the list
   return reverse_h(function () return end, ...)
end

/*---------------------------------------------------------------------------
Misc functions
---------------------------------------------------------------------------*/
-- function composition
do
    local function comp_h(a, b, ...)
        if b == nil then return a end
        b = comp_h(b, ...)
        return function(...)
            return a(b(...))
        end
    end
    Compose = function(funcs, ...)
        if type(funcs) == "table" then
            return comp_h(unpack(funcs))
        else
            return comp_h(funcs, ...)
        end
    end
end

_G.fc = Compose

-- Definition from http://lua-users.org/wiki/CurriedLua
Curry = function(func, num_args)
    if not num_args then error("Missing argument #2: num_args") end
    if not func then error("Function does not exist!", 2) end
    -- helper
    local function curry_h(argtrace, n)
        if n == 0 then
            -- reverse argument list and call function
            return func(ReverseArgs(argtrace()))
        else
            -- "push" argument (by building a wrapper function) and decrement n
            return function(x)
                return curry_h(function() return x, argtrace() end, n - 1)
            end
        end
   end

   -- no sense currying for 1 arg or less
   if num_args > 1 then
      return curry_h(function() return end, num_args)
   else
      return func
   end
end

-- Thanks Lexic!
Partial = function(func, ...)
    local args = {...}
    return function(...)
        return func(unpack(table.Add( args, {...})))
    end
end

Apply = function(f, ...) return f(...) end

Const = function(a, b) return a end
Until = function(cmp, fn, val)
    if cmp(val) then
        return val
    end
    return Until(cmp, fn, fn(val))
end

Seq = function(f, x) f(x) return x end

GetGlobalVar = function(key) return _G[key] end

/*---------------------------------------------------------------------------
Mathematical operators and functions
---------------------------------------------------------------------------*/
Add = function(a, b) return a + b end
Sub = function(a, b) return a - b end
Mul = function(a, b) return a * b end
Div = function(a, b) return a / b end
Mod = function(a, b) return a % b end
Neg = function(a)    return -a    end

Eq  = function(a, b) return a == b end
Neq = function(a, b) return a ~= b end
Gt  = function(a, b) return a > b  end
Lt  = function(a, b) return a < b  end
Gte = function(a, b) return a >= b end
Lte = function(a, b) return a <= b end

Succ = Compose{Add, 1}
Pred = Compose{Flip(Sub), 1}
Even = Compose{fp{Eq, 0}, fp{Flip(Mod), 2}}
Odd  = Compose{Not, Even}

/*---------------------------------------------------------------------------
Functional logical operators and conditions
---------------------------------------------------------------------------*/
FAnd = function(fns)
    return function(...)
        local val
        for _, f in pairs(fns) do
            val = {f(...)}
            if not val[1] then return unpack(val) end
        end
        if val then return unpack(val) end
    end
end

FOr = function(fns)
    return function(...)
        local val
        for _, f in pairs(fns) do
            val = {f(...)}
            if val[1] then return unpack(val) end
        end
        return false, unpack(val, 2)
    end
end

Not = function(x) return not x end

If = function(f, Then, Else)
    return function(x)
        if f(x) then
            return Then
        else
            return Else
        end
    end
end

/*---------------------------------------------------------------------------
List operations
---------------------------------------------------------------------------*/
Map = function(f, xs)
    for k, v in pairs(xs) do
        xs[k] = f(v)
    end
    return xs
end

Append = function(xs, ys)
    return table.Add(xs, ys)
end

Filter = function(f, xs)
    local res = {}
    for k,v in pairs(xs) do
        if f(v) then res[k] = v end
    end
    return res
end

ForEach = function(f, xs)
    for k,v in pairs(xs) do
        local val = f(k, v)
        if val ~= nil then return val end
    end
end

Head = function(xs)
    return table.GetFirstValue(xs)
end

Last = function(xs)
    return xs[#xs] or table.GetLastValue(xs)
end

Tail = function(xs)
    table.remove(xs, 1)
    return xs
end

Init = function(xs)
    xs[#xs] = nil
    return xs
end

GetValue = function(i, xs)
    return xs[i]
end

Null = function(xs)
    for k, v in pairs(xs) do
        return false
    end
    return true
end

Length = function(xs)
    return #xs
end

Index = function(xs, i)
    return xs[i]
end

Reverse = function(xs)
    local res = {}
    for i = #xs, 1, -1 do
        res[#xs - i + 1] = xs[i]
    end
    return res
end

/*---------------------------------------------------------------------------
Folds
---------------------------------------------------------------------------*/
Foldr = function(func, val, xs)
    for i = #xs, 1, -1 do
        val = func(xs[i], val)
    end

    return val
end

Foldl = function(func, val, xs)
    for k, v in ipairs(xs) do
        val = func(val, v)
    end

    return val
end

And = function(xs)
    for k, v in pairs(xs) do
        if v ~= true then return false end
    end
    return true
end

Or = function(xs)
    for k, v in pairs(xs) do
        if v == true then return true end
    end
    return false
end

Any = function(func, xs)
    for k, v in pairs(xs) do
        if func(v) == true then return true end
    end
    return false
end

All = function(func, xs)
    for k, v in pairs(xs) do
        if func(v) ~= true then return false end
    end
    return true
end

Sum = _G.fp{Foldr, Add, 0}

Product = _G.fp{Foldr, Mul, 1}

Concat = _G.fp{Foldr, Append, {}}

Maximum = _G.fp{Foldl, math.Max, -math.huge}

Minimum = _G.fp{Foldl, math.Min, math.huge}

Snd = _G.fp{select, 2}

Thrd = _G.fp{select, 3}

--PATH gamemodes/starwarsrp/gamemode/modules/chatindicator/cl_interface.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_config/settings.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/tipjar/cl_frame.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/tipjar/cl_communication.lua:
local updateModel, getModelValue, onModelUpdate =
    DarkRP.tipJarUIModel.updateModel,
    DarkRP.tipJarUIModel.getModelValue,
    DarkRP.tipJarUIModel.onModelUpdate

onModelUpdate("lastTipAmount", function(amount)
    if amount <= 0 then return end

    local tipjar = getModelValue("tipjar")

    if not IsValid(tipjar) then return end

    net.Start("DarkRP_TipJarDonate")
        net.WriteEntity(tipjar)
        net.WriteUInt(amount, 32)
    net.SendToServer()
end)

net.Receive("DarkRP_TipJarUI", fc{DarkRP.tipJarUI, net.ReadEntity})

net.Receive("DarkRP_TipJarDonate", function()
    local tipjar = net.ReadEntity()
    local ply    = net.ReadEntity()
    local amount = net.ReadUInt(32)

    if not IsValid(tipjar) then return end
    if not IsValid(ply) then return end

    tipjar:Donated(ply, amount)
    updateModel("donatedUpdate")
end)

onModelUpdate("amount", function(amount, old)
    local tipjar = getModelValue("tipjar")

    if not IsValid(tipjar) then return end

    tipjar:UpdateActiveDonation(LocalPlayer(), amount)

    if amount == old then return end

    net.Start("DarkRP_TipJarUpdate")
        net.WriteEntity(tipjar)
        net.WriteUInt(amount, 32)
    net.SendToServer()
end)

net.Receive("DarkRP_TipJarUpdate", function(len)
    local tipjar = net.ReadEntity()

    if not IsValid(tipjar) then return end

    local bitsRead = 16

    while bitsRead < len do
        tipjar:UpdateActiveDonation(net.ReadEntity(), net.ReadUInt(32))

        -- I thought there was a function for this?
        bitsRead = bitsRead + 16 + 32
    end
end)

onModelUpdate("frameVisible", function(visible)
    local localply = LocalPlayer()
    local tipjar   = getModelValue("tipjar")
    local amount   = getModelValue("amount")

    if not IsValid(localply) then return end
    if not IsValid(tipjar) then return end

    if visible then
        tipjar:ClearActiveDonations()
        tipjar:UpdateActiveDonation(localply, amount)

        net.Start("DarkRP_TipJarUpdate")
            net.WriteEntity(tipjar)
            net.WriteUInt(amount, 32)
        net.SendToServer()

    else
        net.Start("DarkRP_TipJarExit")
            net.WriteEntity(tipjar)
        net.SendToServer()

        tipjar:ExitActiveDonation(localply)
    end
end)

net.Receive("DarkRP_TipJarExit", function()
    local tipjar = net.ReadEntity()
    local ply = net.ReadEntity()

    if not IsValid(tipjar) then return end
    if not IsValid(ply) then return end

    tipjar:ExitActiveDonation(ply)
end)

net.Receive("DarkRP_TipJarDonatedList", function()
    local tipjar = net.ReadEntity()
    local count = net.ReadUInt(8)

    if not IsValid(tipjar) then return end

    tipjar:ClearDonations()

    for i = 1, count do
        tipjar:AddDonation(net.ReadString(), net.ReadUInt(32))
    end

    updateModel("donatedUpdate")
end)


local function onUpdateActiveDonation(_, tipjar)
    if not IsValid(tipjar) or tipjar ~= getModelValue("tipjar") then return end

    updateModel("activeDonationUpdate")
end

DarkRP.hooks.tipjarUpdateActiveDonation = onUpdateActiveDonation
DarkRP.hooks.tipjarExitActiveDonation   = onUpdateActiveDonation
DarkRP.hooks.tipjarClearActiveDonation  = onUpdateActiveDonation

--PATH gamemodes/starwarsrp/gamemode/modules/jobs/sh_commands.lua:
local plyMeta = FindMetaTable("Player")

DarkRP.declareChatCommand{
    command = "job",
    description = "Change your job name",
    delay = 1.5,
    condition = fn.Compose{fn.Not, plyMeta.isArrested}
}

DarkRP.declareChatCommand{
    command = "demote",
    description = "Demote a player from their job",
    delay = 1.5,
    condition = fn.Compose{fn.Curry(fn.Flip(fn.Gt), 2)(1), fn.Length, player.GetAll},
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "switchjob",
    description = "Switch jobs with the player you're looking at",
    delay = 1.5,
    condition = fn.Compose{fn.Curry(fn.GetValue, 2)("allowjobswitch"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
}

DarkRP.declareChatCommand{
    command = "switchjobs",
    description = "Switch jobs with the player you're looking at",
    delay = 1.5,
    condition = fn.Compose{fn.Curry(fn.GetValue, 2)("allowjobswitch"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
}

DarkRP.declareChatCommand{
    command = "jobswitch",
    description = "Switch jobs with the player you're looking at",
    delay = 1.5,
    condition = fn.Compose{fn.Curry(fn.GetValue, 2)("allowjobswitch"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
}

DarkRP.declareChatCommand{
    command = "teamban",
    description = "Ban someone from getting a certain job",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "teamunban",
    description = "Undo a teamban",
    delay = 1.5,
    tableArgs = true
}

--PATH gamemodes/starwarsrp/gamemode/modules/hud/cl_hud.lua:
--[[---------------------------------------------------------------------------
HUD ConVars
---------------------------------------------------------------------------]]
local ConVars = {}
local HUDWidth
local HUDHeight

local Color = Color
local CurTime = CurTime
local cvars = cvars
local DarkRP = DarkRP
local draw = draw
local GetConVar = GetConVar
local hook = hook
local IsValid = IsValid
local Lerp = Lerp
local localplayer
local math = math
local pairs = pairs
local ScrW, ScrH = ScrW, ScrH
local SortedPairs = SortedPairs
local string = string
local surface = surface
local table = table
local timer = timer
local tostring = tostring
local plyMeta = FindMetaTable("Player")

local colors = {}
colors.black = color_black
colors.blue = Color(0, 0, 255, 255)
colors.brightred = Color(200, 30, 30, 255)
colors.darkred = Color(0, 0, 70, 100)
colors.darkblack = Color(0, 0, 0, 200)
colors.gray1 = Color(0, 0, 0, 155)
colors.gray2 = Color(51, 58, 51,100)
colors.red = Color(255, 0, 0, 255)
colors.white = color_white
colors.white1 = Color(255, 255, 255, 200)

local function ReloadConVars()
    ConVars = {
        background = {0,0,0,100},
        Healthbackground = {0,0,0,200},
        Healthforeground = {140,0,0,180},
        HealthText = {255,255,255,200},
        Job1 = {0,0,150,200},
        Job2 = {0,0,0,255},
        salary1 = {0,150,0,200},
        salary2 = {0,0,0,255}
    }

    for name, Colour in pairs(ConVars) do
        ConVars[name] = {}
        for num, rgb in SortedPairs(Colour) do
            local CVar = GetConVar(name .. num) or CreateClientConVar(name .. num, rgb, true, false)
            table.insert(ConVars[name], CVar:GetInt())

            if not cvars.GetConVarCallbacks(name .. num, false) then
                cvars.AddChangeCallback(name .. num, function()
                    timer.Simple(0, ReloadConVars)
                end)
            end
        end
        ConVars[name] = Color(unpack(ConVars[name]))
    end


    HUDWidth =  (GetConVar("HudW") or CreateClientConVar("HudW", 240, true, false)):GetInt()
    HUDHeight = (GetConVar("HudH") or CreateClientConVar("HudH", 115, true, false)):GetInt()

    if not cvars.GetConVarCallbacks("HudW", false) and not cvars.GetConVarCallbacks("HudH", false) then
        cvars.AddChangeCallback("HudW", function() timer.Simple(0,ReloadConVars) end)
        cvars.AddChangeCallback("HudH", function() timer.Simple(0,ReloadConVars) end)
    end
end
ReloadConVars()

local Scrw, Scrh, RelativeX, RelativeY
--[[---------------------------------------------------------------------------
HUD separate Elements
---------------------------------------------------------------------------]]
local Health = 0
local function DrawHealth()
    local maxHealth = localplayer:GetMaxHealth()
    local myHealth = localplayer:Health()
    Health = math.min(maxHealth, (Health == myHealth and Health) or Lerp(0.1, Health, myHealth))

    local healthRatio = math.Min(Health / maxHealth, 1)
    local rounded = math.Round(3 * healthRatio)
    local Border = math.Min(6, rounded * rounded)
    draw.RoundedBox(Border, RelativeX + 4, RelativeY - 30, HUDWidth - 8, 20, ConVars.Healthbackground)
    draw.RoundedBox(Border, RelativeX + 5, RelativeY - 29, (HUDWidth - 9) * healthRatio, 18, ConVars.Healthforeground)

    draw.DrawNonParsedText(math.Max(0, math.Round(myHealth)), "DarkRPHUD2", RelativeX + 4 + (HUDWidth - 8) / 2, RelativeY - 32, ConVars.HealthText, 1)

    -- Armor
    local armor = math.Clamp(localplayer:Armor(), 0, 100)
    if armor ~= 0 then
        draw.RoundedBox(2, RelativeX + 4, RelativeY - 15, (HUDWidth - 8) * armor / 100, 5, colors.blue)
    end
end

local salaryText, JobWalletText
local function DrawInfo()
    salaryText = salaryText or DarkRP.getPhrase("salary", DarkRP.formatMoney(localplayer:getDarkRPVar("salary")), "")

    JobWalletText = JobWalletText or string.format("%s\n%s",
        DarkRP.getPhrase("job", localplayer:getDarkRPVar("job") or ""),
        DarkRP.getPhrase("wallet", DarkRP.formatMoney(localplayer:getDarkRPVar("money")), "")
    )

    draw.DrawNonParsedText(salaryText, "DarkRPHUD2", RelativeX + 5, RelativeY - HUDHeight + 6, ConVars.salary1, 0)
    draw.DrawNonParsedText(salaryText, "DarkRPHUD2", RelativeX + 4, RelativeY - HUDHeight + 5, ConVars.salary2, 0)

    surface.SetFont("DarkRPHUD2")
    local _, h = surface.GetTextSize(salaryText)

    draw.DrawNonParsedText(JobWalletText, "DarkRPHUD2", RelativeX + 5, RelativeY - HUDHeight + h + 6, ConVars.Job1, 0)
    draw.DrawNonParsedText(JobWalletText, "DarkRPHUD2", RelativeX + 4, RelativeY - HUDHeight + h + 5, ConVars.Job2, 0)
end

local Page = Material("icon16/page_white_text.png")
local function GunLicense()
    if localplayer:getDarkRPVar("HasGunlicense") then
        surface.SetMaterial(Page)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawTexturedRect(RelativeX + HUDWidth, Scrh - 34, 32, 32)
    end
end

local agendaText
local function Agenda(gamemodeTable)
    local shouldDraw = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_Agenda")
    if shouldDraw == false then return end

    local agenda = localplayer:getAgendaTable()
    if not agenda then return end
    agendaText = agendaText or DarkRP.textWrap((localplayer:getDarkRPVar("agenda") or ""):gsub("//", "\n"):gsub("\\n", "\n"), "DarkRPHUD1", 440)

    draw.RoundedBox(10, 10, 10, 460, 110, colors.gray1)
    draw.RoundedBox(10, 12, 12, 456, 106, colors.gray2)
    draw.RoundedBox(10, 12, 12, 456, 20, colors.darkred)

    draw.DrawNonParsedText(agenda.Title, "DarkRPHUD1", 30, 12, colors.red, 0)
    draw.DrawNonParsedText(agendaText, "DarkRPHUD1", 30, 35, colors.white, 0)
end

hook.Add("DarkRPVarChanged", "agendaHUD", function(ply, var, _, new)
    if ply ~= localplayer then return end
    if var == "agenda" and new then
        agendaText = DarkRP.textWrap(new:gsub("//", "\n"):gsub("\\n", "\n"), "DarkRPHUD1", 440)
    else
        agendaText = nil
    end

    if var == "salary" then
        salaryText = DarkRP.getPhrase("salary", DarkRP.formatMoney(new), "")
    end

    if var == "job" or var == "money" then
        JobWalletText = string.format("%s\n%s",
            DarkRP.getPhrase("job", var == "job" and new or localplayer:getDarkRPVar("job") or ""),
            DarkRP.getPhrase("wallet", var == "money" and DarkRP.formatMoney(new) or DarkRP.formatMoney(localplayer:getDarkRPVar("money")), "")
        )
    end
end)

local VoiceChatTexture = surface.GetTextureID("voice/icntlk_pl")
local function DrawVoiceChat(gamemodeTable)
    local shouldDraw = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_VoiceChat")
    if shouldDraw == false then return end

    if localplayer.DRPIsTalking then
        local _, chboxY = chat.GetChatBoxPos()

        local Rotating = math.sin(CurTime() * 3)
        local backwards = 0

        if Rotating < 0 then
            Rotating = 1 - (1 + Rotating)
            backwards = 180
        end

        surface.SetTexture(VoiceChatTexture)
        surface.SetDrawColor(ConVars.Healthforeground)
        surface.DrawTexturedRectRotated(Scrw - 100, chboxY, Rotating * 96, 96, backwards)
    end
end

local function LockDown(gamemodeTable)
    local chbxX, chboxY = chat.GetChatBoxPos()
    if GetGlobalBool("DarkRP_LockDown") then
        local shouldDraw = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_LockdownHUD")
        if shouldDraw == false then return end
        local cin = (math.sin(CurTime()) + 1) / 2
        local chatBoxSize = math.floor(Scrh / 4)
        draw.DrawNonParsedText(DarkRP.getPhrase("lockdown_started"), "ScoreboardSubtitle", chbxX, chboxY + chatBoxSize, Color(cin * 255, 0, 255 - (cin * 255), 255), TEXT_ALIGN_LEFT)
    end
end

local Arrested = function() end

usermessage.Hook("GotArrested", function(msg)
    local StartArrested = CurTime()
    local ArrestedUntil = msg:ReadFloat()

    Arrested = function(gamemodeTable)
        local shouldDraw = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_ArrestedHUD")
        if shouldDraw == false then return end

        if CurTime() - StartArrested <= ArrestedUntil and localplayer:getDarkRPVar("Arrested") then
            draw.DrawNonParsedText(DarkRP.getPhrase("youre_arrested", math.ceil((ArrestedUntil - (CurTime() - StartArrested)) * 1 / game.GetTimeScale())), "DarkRPHUD1", Scrw / 2, Scrh - Scrh / 12, colors.white, 1)
        elseif not localplayer:getDarkRPVar("Arrested") then
            Arrested = function() end
        end
    end
end)

local AdminTell = function() end

usermessage.Hook("AdminTell", function(msg)
    timer.Remove("DarkRP_AdminTell")
    local Message = msg:ReadString()

    AdminTell = function()
        draw.RoundedBox(4, 10, 10, Scrw - 20, 110, colors.darkblack)
        draw.DrawNonParsedText(DarkRP.getPhrase("listen_up"), "GModToolName", Scrw / 2 + 10, 10, colors.white, 1)
        draw.DrawNonParsedText(Message, "ChatFont", Scrw / 2 + 10, 90, colors.brightred, 1)
    end

    timer.Create("DarkRP_AdminTell", 10, 1, function()
        AdminTell = function() end
    end)
end)

--[[---------------------------------------------------------------------------
Drawing the HUD elements such as Health etc.
---------------------------------------------------------------------------]]
local function DrawHUD(gamemodeTable)
    local shouldDraw = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_HUD")
    if shouldDraw == false then return end

    Scrw, Scrh = ScrW(), ScrH()
    RelativeX, RelativeY = 0, Scrh

    shouldDraw = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_LocalPlayerHUD")
    shouldDraw = shouldDraw ~= false
    if shouldDraw then
        --Background
        draw.RoundedBox(6, 0, Scrh - HUDHeight, HUDWidth, HUDHeight, ConVars.background)
        DrawHealth()
        DrawInfo()
        GunLicense()
    end
    Agenda(gamemodeTable)
    DrawVoiceChat(gamemodeTable)
    LockDown(gamemodeTable)

    Arrested(gamemodeTable)
    AdminTell()
end

--[[---------------------------------------------------------------------------
Entity HUDPaint things
---------------------------------------------------------------------------]]
-- Draw a player's name, health and/or job above the head
-- This syntax allows for easy overriding
plyMeta.drawPlayerInfo = plyMeta.drawPlayerInfo or function(self)
    local pos = self:EyePos()

    pos.z = pos.z + 10 -- The position we want is a bit above the position of the eyes
    pos = pos:ToScreen()
    if not self:getDarkRPVar("wanted") then
        -- Move the text up a few pixels to compensate for the height of the text
        pos.y = pos.y - 50
    end

    if GAMEMODE.Config.showname then
        local nick, plyTeam = self:Nick(), self:Team()
        draw.DrawNonParsedText(nick, "DarkRPHUD2", pos.x + 1, pos.y + 1, colors.black, 1)
        draw.DrawNonParsedText(nick, "DarkRPHUD2", pos.x, pos.y, RPExtraTeams[plyTeam] and RPExtraTeams[plyTeam].color or team.GetColor(plyTeam) , 1)
    end

    if GAMEMODE.Config.showhealth then
        local health = DarkRP.getPhrase("health", math.max(0, self:Health()))
        draw.DrawNonParsedText(health, "DarkRPHUD2", pos.x + 1, pos.y + 21, colors.black, 1)
        draw.DrawNonParsedText(health, "DarkRPHUD2", pos.x, pos.y + 20, colors.white1, 1)
    end

    if GAMEMODE.Config.showjob then
        local teamname = self:getDarkRPVar("job") or team.GetName(self:Team())
        draw.DrawNonParsedText(teamname, "DarkRPHUD2", pos.x + 1, pos.y + 41, colors.black, 1)
        draw.DrawNonParsedText(teamname, "DarkRPHUD2", pos.x, pos.y + 40, colors.white1, 1)
    end

    if self:getDarkRPVar("HasGunlicense") then
        surface.SetMaterial(Page)
        surface.SetDrawColor(255,255,255,255)
        surface.DrawTexturedRect(pos.x-16, pos.y + 60, 32, 32)
    end
end

-- Draw wanted information above a player's head
-- This syntax allows for easy overriding
plyMeta.drawWantedInfo = plyMeta.drawWantedInfo or function(self)
    if not self:Alive() then return end

    local pos = self:EyePos()
    if not pos:isInSight({localplayer, self}) then return end

    pos.z = pos.z + 10
    pos = pos:ToScreen()

    if GAMEMODE.Config.showname then
        local nick, plyTeam = self:Nick(), self:Team()
        draw.DrawNonParsedText(nick, "DarkRPHUD2", pos.x + 1, pos.y + 1, colors.black, 1)
        draw.DrawNonParsedText(nick, "DarkRPHUD2", pos.x, pos.y, RPExtraTeams[plyTeam] and RPExtraTeams[plyTeam].color or team.GetColor(plyTeam) , 1)
    end

    local wantedText = DarkRP.getPhrase("wanted", tostring(self:getDarkRPVar("wantedReason")))

    draw.DrawNonParsedText(wantedText, "DarkRPHUD2", pos.x, pos.y - 40, colors.white1, 1)
    draw.DrawNonParsedText(wantedText, "DarkRPHUD2", pos.x + 1, pos.y - 41, colors.red, 1)
end

--[[---------------------------------------------------------------------------
The Entity display: draw HUD information about entities
---------------------------------------------------------------------------]]
local function DrawEntityDisplay(gamemodeTable)
    local shouldDraw, players = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_EntityDisplay")
    if shouldDraw == false then return end

    local shootPos = localplayer:GetShootPos()
    local aimVec = localplayer:GetAimVector()

    for _, ply in ipairs(players or player.GetAll()) do
        if not IsValid(ply)
           or ply == localplayer
           or not ply:Alive()
           or ply:GetNoDraw()
           or ply:IsDormant()
           or ply:GetColor().a == 0 and (ply:GetRenderMode() == RENDERMODE_TRANSALPHA or ply:GetRenderMode() == RENDERMODE_TRANSCOLOR) then
           continue
        end
        local hisPos = ply:GetShootPos()
        if ply:getDarkRPVar("wanted") then ply:drawWantedInfo() end

        if gamemodeTable.Config.globalshow then
            ply:drawPlayerInfo()
        -- Draw when you're (almost) looking at him
        elseif hisPos:DistToSqr(shootPos) < 160000 then
            local pos = hisPos - shootPos
            local unitPos = pos:GetNormalized()
            if unitPos:Dot(aimVec) > 0.95 then
                local trace = util.QuickTrace(shootPos, pos, localplayer)
                if trace.Hit and trace.Entity ~= ply then
                    -- When the trace says you're directly looking at a
                    -- different player, that means you can draw /their/ info
                    if trace.Entity:IsPlayer() then
                        trace.Entity:drawPlayerInfo()
                    end
                    break
                end
                ply:drawPlayerInfo()
            end
        end
    end

    local ent = localplayer:GetEyeTrace().Entity

    if IsValid(ent) and ent:isKeysOwnable() and ent:GetPos():DistToSqr(localplayer:GetPos()) < 40000 then
        ent:drawOwnableInfo()
    end
end

--[[---------------------------------------------------------------------------
Drawing death notices
---------------------------------------------------------------------------]]
function GM:DrawDeathNotice(x, y)
    if not self.Config.showdeaths then return end
    self.Sandbox.DrawDeathNotice(self, x, y)
end

--[[---------------------------------------------------------------------------
Display notifications
---------------------------------------------------------------------------]]
local notificationSound = GM.Config.notificationSound
local function DisplayNotify(msg)
    local txt = msg:ReadString()
    GAMEMODE:AddNotify(txt, msg:ReadShort(), msg:ReadLong())
    surface.PlaySound(notificationSound)

    -- Log to client console
    MsgC(Color(255, 20, 20, 255), "[DarkRP] ", Color(200, 200, 200, 255), txt, "\n")
end
usermessage.Hook("_Notify", DisplayNotify)

--[[---------------------------------------------------------------------------
Remove some elements from the HUD in favour of the DarkRP HUD
---------------------------------------------------------------------------]]
local noDraw = {
    ["CHudHealth"] = true,
    ["CHudBattery"] = true,
    ["CHudSuitPower"] = true,
    ["CHUDQuickInfo"] = true
}
function GM:HUDShouldDraw(name)
    if noDraw[name] or (HelpToggled and name == "CHudChat") then
        return false
    else
        return self.Sandbox.HUDShouldDraw(self, name)
    end
end

--[[---------------------------------------------------------------------------
Disable players' names popping up when looking at them
---------------------------------------------------------------------------]]
function GM:HUDDrawTargetID()
    return false
end

--[[---------------------------------------------------------------------------
Actual HUDPaint hook
---------------------------------------------------------------------------]]
function GM:HUDPaint()
    localplayer = localplayer or LocalPlayer()

    DrawHUD(self)
    DrawEntityDisplay(self)

    self.Sandbox.HUDPaint(self)
end

--PATH gamemodes/starwarsrp/gamemode/modules/fspectate/sh_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/fspectate/sh_init.lua:
if not CAMI then return end

CAMI.RegisterPrivilege{
    Name = "FSpectate",
    MinAccess = "admin"
}

CAMI.RegisterPrivilege{
    Name = "FSpectateTeleport",
    MinAccess = "admin"
}

--PATH gamemodes/starwarsrp/gamemode/modules/cppi/sh_cppi.lua:
if CPPI then return end
CPPI = {}
CPPI.CPPI_DEFER = 100100 --\100\100 = dd
CPPI.CPPI_NOTIMPLEMENTED = 7080

function CPPI:GetName()
    return "DarkRP"
end

function CPPI:GetVersion()
    return CPPI.CPPI_NOTIMPLEMENTED
end

function CPPI:GetInterfaceVersion()
    return CPPI.CPPI_NOTIMPLEMENTED
end

function CPPI:GetNameFromUID(uid)
    return CPPI.CPPI_NOTIMPLEMENTED
end

local PLAYER = FindMetaTable("Player")
function PLAYER:CPPIGetFriends()
    return CPPI.CPPI_NOTIMPLEMENTED
end

local ENTITY = FindMetaTable("Entity")
function ENTITY:CPPIGetOwner()
    return NULL, CPPI.CPPI_NOTIMPLEMENTED
end

if SERVER then
    function ENTITY:CPPISetOwner(ply)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPISetOwnerUID(UID)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPICanTool(ply, tool)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPICanPhysgun(ply)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPICanPickup(ply)
        return CPPI.CPPI_NOTIMPLEMENTED
    end

    function ENTITY:CPPICanPunt(ply)
        return CPPI.CPPI_NOTIMPLEMENTED
    end
end

--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_util.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_simplerr.lua:
-- simplerrRun: Run a function with the given parameters and send any runtime errors to admins
DarkRP.simplerrRun = fc{
    fn.Snd, -- On success ignore the first return value
    simplerr.wrapError,
    simplerr.wrapHook,
    simplerr.wrapLog,
    simplerr.safeCall
}

-- error: throw a runtime error without exiting the stack
-- parameters: msg, [stackNr], [hints], [path], [line]
DarkRP.errorNoHalt = fc{
    simplerr.wrapHook,
    simplerr.wrapLog,
    simplerr.runError,
    function(msg, err, ...) return msg, err and err + 3 or 4, ... end -- Raise error level one higher
}

-- error: throw a runtime error
-- parameters: msg, [stackNr], [hints], [path], [line]
DarkRP.error = fc{
    simplerr.wrapError,
    DarkRP.errorNoHalt
}

-- Print errors from the server in the console and show a message in chat
if CLIENT then
    local function showError(count, errs)
        local one = count == 1
        chat.AddText(Color(255, 0, 0), string.format("There %s %i Lua problem%s!", one and "is" or "are", count, one and "" or 's'))
        chat.AddText(color_white, "\tPlease check your console for more information!")
        chat.AddText(color_white, "\tNote: This error likely breaks your server. Make sure to solve the error!")

        for i = 1, count do
            MsgC(Color(137, 222, 255), errs[i] .. "\n")
        end
    end

    net.Receive("DarkRP_simplerrError", function()
        local count = net.ReadUInt(16)
        local errs = {}

        for i = 1, count do
            table.insert(errs, net.ReadString())
        end

        showError(count, errs)
    end)
    hook.Add("onSimplerrError", "DarkRP_Simplerr", function(err) showError(1, {err}) end)

    return
end

-- Serverside part
local plyMeta = FindMetaTable("Player")
util.AddNetworkString("DarkRP_simplerrError")

-- Send all errors to the client
local function sendErrors(plys, errs)
    local count = #errs
    local one = count == 1

    DarkRP.notify(plys, 1, 120, string.format("There %s %i Lua problem%s!\nPlease check your console for more information!", one and "is" or "are", count, one and "" or 's'))
    net.Start("DarkRP_simplerrError")
        net.WriteUInt(#errs, 16)
        fn.ForEach(fn.Flip(net.WriteString), errs)
    net.Send(plys)
end

-- Annoy all admins when an error occurs
local function annoyAdmins(err)
    local admins = fn.Filter(plyMeta.IsAdmin, player.GetAll())
    sendErrors(admins, {err})
end
hook.Add("onSimplerrError", "DarkRP_Simplerr", annoyAdmins)

-- Annoy joining admin with errors
local function annoyAdmin(ply)
    if not IsValid(ply) or not ply:IsAdmin() then return end
    local errs = table.Copy(simplerr.getLog())
    if table.IsEmpty(errs) then return end

    fn.Map(fp{fn.GetValue, "err"}, errs)
    sendErrors(ply, errs)
end
hook.Add("PlayerInitialSpawn", "DarkRP_Simplerr", function(ply) timer.Simple(1, fp{annoyAdmin, ply}) end)

--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_playerclass.lua:
local PLAYER_CLASS = {}

-- Value of -1 = set to config value, if a corresponding setting exists
PLAYER_CLASS.DisplayName = "DarkRP Base Player Class"
PLAYER_CLASS.WalkSpeed = -1
PLAYER_CLASS.RunSpeed = -1
PLAYER_CLASS.DuckSpeed = 0.3
PLAYER_CLASS.UnDuckSpeed = 0.3
PLAYER_CLASS.TeammateNoCollide = false
PLAYER_CLASS.StartHealth = -1

function PLAYER_CLASS:Loadout()
    -- Let gamemode decide
end

function PLAYER_CLASS:SetModel()
    -- Let gamemode decide
end

function PLAYER_CLASS:ShouldDrawLocal()
    -- Let gamemode decide
end

function PLAYER_CLASS:CreateMove(cmd)
    -- Let gamemode decide
end

function PLAYER_CLASS:CalcView(view)
    -- Let gamemode decide
end

function PLAYER_CLASS:GetHandsModel()
    -- Let gamemode decide
end

function PLAYER_CLASS:StartMove(mv, cmd)
    -- Let gamemode decide
end

function PLAYER_CLASS:FinishMove(mv)
    -- Let gamemode decide
end

player_manager.RegisterClass("player_darkrp", PLAYER_CLASS, "player_sandbox")

--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_checkitems.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/animations/sh_animations.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_language/chatcommands.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_modules/hudreplacement/cl_hudreplacement.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_customthings/jobs.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_customthings/vehicles.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_customthings/ammo.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_customthings/groupchats.lua:
--[[---------------------------------------------------------------------------
Group chats
---------------------------------------------------------------------------
Team chat for when you have a certain job.
e.g. with the default police group chat, police officers, chiefs and mayors can
talk to one another through /g or team chat.

HOW TO MAKE A GROUP CHAT:
Simple method:
GAMEMODE:AddGroupChat(List of team variables separated by comma)

Advanced method:
GAMEMODE:AddGroupChat(a function with ply as argument that returns whether a random player is in one chat group)
This is for people who know how to script Lua.

---------------------------------------------------------------------------]]
-- Example: GAMEMODE:AddGroupChat(TEAM_MOB, TEAM_GANG)
-- Example: GAMEMODE:AddGroupChat(function(ply) return ply:isCP() end)

--PATH addons/!jobs/lua/darkrp_customthings/doorgroups.lua:
return gluapack()()
--PATH lua/weapons/allegiance_tool.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_flir.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_flir.lua:
-- Render thermal highlighting to the currently active RT.

local lastentcount = 0
local lastents = {}

local coldtime = 20

local monochrometable = {
    ["$pp_colour_addr"] = 0,
    ["$pp_colour_addg"] = 0,
    ["$pp_colour_addb"] = 0,
    ["$pp_colour_brightness"] = 0,
    ["$pp_colour_contrast"] = 1,
    ["$pp_colour_colour"] = 0,
    ["$pp_colour_mulr"] = 0,
    ["$pp_colour_mulg"] = 0,
    ["$pp_colour_mulb"] = 0
}

local ref = 32

function SWEP:DoFLIR(atttbl)

    render.SetStencilEnable(true)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)
    render.ClearStencil()

    -- local targets = ents.FindInCone(EyePos(), EyeAngles():Forward(), atttbl.RTScopeFLIRRange or 30000, math.cos(fov + 5))
    local targets = lastents
    local entcount = ents.GetCount()

    if lastentcount != entcount then
        targets = ents.GetAll()
        lastents = targets
    end

    lastentcount = entcount

    render.SuppressEngineLighting(true)

    if !atttbl.RTScopeFLIRSolid then
        render.SetBlend(atttbl.RTScopeFLIRBlend or 0.25)
        render.SetColorModulation(250, 250, 250)
    else
        render.SetBlend(0)
    end

    cam.IgnoreZ(false)

    render.SetStencilReferenceValue(ref)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)

    for _, ent in ipairs(targets) do
        if ent == self:GetOwner() then continue end
        local hot = self:GetEntityHot(ent)
        if atttbl.FLIRHotFunc then
            hot = atttbl.FLIRHotFunc(self, ent)
        end

        if !hot then continue end

        ent:DrawModel()
    end

    cam.IgnoreZ(true)

    render.SetColorModulation(1, 1, 1)
    render.SuppressEngineLighting(false)
    render.MaterialOverride()
    render.SetBlend(1)

    render.SetStencilReferenceValue(ref)
    render.SetStencilCompareFunction(STENCIL_EQUAL)
    render.SetStencilPassOperation(STENCIL_KEEP)

    if atttbl.RTScopeFLIRSolid then
        render.SetColorMaterial()
        render.DrawScreenQuad()
    end

    if atttbl.RTScopeFLIRMonochrome then
        render.SetStencilCompareFunction(STENCIL_ALWAYS)
        DrawColorModify(monochrometable)
    end

    if atttbl.RTScopeFLIRCCCold then
        render.SetStencilCompareFunction(STENCIL_NOTEQUAL)
        DrawColorModify(atttbl.RTScopeFLIRCCCold)
        -- DrawColorModify(atttbl.RTScopeFLIRCCHot)
    end

    if atttbl.RTScopeFLIRCCHot then
        render.SetStencilCompareFunction(STENCIL_EQUAL)
        DrawColorModify(atttbl.RTScopeFLIRCCHot)
    end

    render.UpdateScreenEffectTexture()

    if atttbl.RTScopeFLIRFunc then
        atttbl.RTScopeFLIRFunc(self)
    end

    if atttbl.RTScopeFLIRHotOnlyFunc then
        atttbl.RTScopeFLIRHotOnlyFunc(self)
    end

    render.SetStencilEnable(false)
end

local maxrange = (160/ARC9.HUToM)^2 -- 160 m

function SWEP:GetEntityHot(ent)
    if !ent:IsValid() or ent:IsWorld() then return false end

    if self:GetPos():DistToSqr(ent:GetPos()) > maxrange then return end

    if ent:IsPlayer() then
        if ent.ArcticMedShots_ActiveEffects and ent.ArcticMedShots_ActiveEffects["coldblooded"] or ent:Health() <= 0 then return false end -- arc stims
        return true
    end

    if ent:IsNPC() or ent:IsNextBot() then -- npcs
        if ent.ARC9CLHealth and ent.ARC9CLHealth <= 0 or ent:Health() <= 0 then return false end
        return true
    end

    if ent:IsRagdoll() then -- ragdolling
        if !ent.ARC9_ColdTime then ent.ARC9_ColdTime = CurTime() + coldtime end
        return ent.ARC9_ColdTime > CurTime()
    end

    if ent:IsVehicle() or ent:IsOnFire() or ent.ArcCW_Hot or ent:IsScripted() and !ent:GetOwner():IsValid() then -- arccw_hot for compatibillity
        return true
    end

    return false
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_light.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_model.lua:
SWEP.ModelVersion = 0

function SWEP:GetAttachmentPos(slottbl, wm, idle, nomodeloffset, custompos, customang, dupli)
    dupli = dupli or 0
    idle = idle or false
    local parentmdl = nil
    if custompos then wm = true end

    if wm then
        if slottbl.WMBase then
            parentmdl = self:GetOwner()

            if !IsValid(parentmdl) then
                parentmdl = self
            end

            if custompos then
                parentmdl = nil
            end
        else
            if custompos then
                parentmdl = self.CModel[1]
                parentmdl:SetupBones()
            else
                parentmdl = self.WModel[1]
            end
        end
    else
        parentmdl = self:GetVM()
    end

    if idle then
        parentmdl = ClientsideModel(self.ViewModel)
        parentmdl:SetPos(vector_origin)
        parentmdl:SetAngles(angle_zero)
        parentmdl:SetNoDraw(true)

        local anim = self:TranslateAnimation("idle")
        local ae = self:GetAnimationEntry(anim)
        local seq = parentmdl:LookupSequence(self:RandomChoice(ae.Source))

        parentmdl:ResetSequence(seq)
        parentmdl:SetPoseParameter("sights", 1)

        parentmdl:SetupBones()
        parentmdl:InvalidateBoneCache()

        table.insert(ARC9.CSModelPile, {Model = parentmdl, Weapon = self, Version = self.ModelVersion})
    end

    local bone = slottbl.Bone
    local atttbl = {}

    if slottbl.WMBase then
        bone = (self:ShouldTPIK() and self.TPIKParentToSpine4) and "ValveBiped.Bip01_Spine4" or "ValveBiped.Bip01_R_Hand"

        -- if self:ShouldTPIK() then
        --     bone = "ValveBiped.Bip01_Head1"
        -- end
    end

    if slottbl.Installed then
        atttbl = self:GetFinalAttTable(slottbl)
    end

    local icon_offset = slottbl.Icon_Offset or Vector()

    local offset_pos = slottbl.Pos or Vector(0, 0, 0)
    local offset_ang = slottbl.Ang or Angle(0, 0, 0)
    local bpos, bang

    if dupli > 0 then
        offset_pos = slottbl.DuplicateModels[dupli].Pos or offset_pos
        offset_ang = slottbl.DuplicateModels[dupli].Ang or offset_ang

        bone = slottbl.DuplicateModels[dupli].Bone or bone
    end

    if parentmdl and bone then
        local boneindex = parentmdl:LookupBone(bone)

        if !boneindex then return vector_origin, angle_zero, vector_origin end

        if parentmdl == self:GetOwner() then
            parentmdl:SetupBones()
            parentmdl:InvalidateBoneCache()
        end
        local bonemat = parentmdl:GetBoneMatrix(boneindex)
        if bonemat then
            bpos = bonemat:GetTranslation()
            bang = bonemat:GetAngles()
        end
    elseif custompos then
        bpos = custompos
        bang = customang or Angle(0, 0, 0)
    end

    if slottbl.OriginalAddress then
        local eles = self:GetAttachmentElements()

        for _, ele in ipairs(eles) do
            local mods = ele.AttPosMods or {}

            if mods[slottbl.OriginalAddress] then
                offset_pos = mods[slottbl.OriginalAddress].Pos or offset_pos
                offset_ang = mods[slottbl.OriginalAddress].Ang or offset_ang
                icon_offset = mods[slottbl.OriginalAddress].Icon_Offset or icon_offset
            end
        end
    end

    if !bang or !bpos then
        bang = self:GetAngles()
        bpos = self:GetPos()
    end

    if wm then
        offset_pos = offset_pos * (self.WorldModelOffset.Scale or 1)
    end

    local apos, aang

    aang = Angle()
    aang:Set(bang)

    apos = bpos + aang:Forward() * offset_pos.x

    apos = apos + aang:Right() * offset_pos.y

    apos = apos + aang:Up() * offset_pos.z

    if !nomodeloffset then
        offset_ang = offset_ang + (atttbl.ModelAngleOffset or angle_zero)
    end

    aang:Set(bang)

    local forward = aang:Forward()
    local right = aang:Right()
    local up = aang:Up()

    aang:RotateAroundAxis(forward, offset_ang.r)
    aang:RotateAroundAxis(right, offset_ang.p)
    aang:RotateAroundAxis(up, offset_ang.y)

    if !nomodeloffset then
        local moffset = (atttbl.ModelOffset or Vector(0, 0, 0)) * (slottbl.Scale or 1)
        if wm then
            moffset = moffset * (self.WorldModelOffset.Scale or 1)
        end

        apos = apos + aang:Forward() * moffset.x
        apos = apos + aang:Right() * moffset.y
        apos = apos + aang:Up() * moffset.z
    end

    if idle then
        SafeRemoveEntity(parentmdl)
    end

    local data = {
        pos = apos,
        ang = aang,
        atttbl = atttbl,
        slottbl = slottbl,
    }

    data = self:RunHook("Hook_GetAttachmentPos", data) or data

    apos = data.pos or apos
    aang = data.ang or aang

    return apos, aang, icon_offset
end

function SWEP:CreateAttachmentModel(wm, atttbl, slottbl, ignorescale, cm)
    ignorescale = ignorescale or false

    local model = atttbl.Model

    if wm and atttbl.WorldModel then
        model = atttbl.WorldModel
    end

    local csmodel = ClientsideModel(model)

    if !IsValid(csmodel) then return end

    csmodel:SetNoDraw(true)
    csmodel.atttbl = atttbl
    csmodel.slottbl = slottbl
    csmodel.weapon = self -- for matproxy

    if atttbl.DrawFunc then
        csmodel.DrawFunc = atttbl.DrawFunc
    end

    if atttbl.ModelSkin then
        csmodel:SetSkin(atttbl.ModelSkin)
    end

    if atttbl.ModelBodygroups then
        csmodel:SetBodyGroups(atttbl.ModelBodygroups)
    end

    if atttbl.ModelMaterial then
        csmodel:SetMaterial(atttbl.ModelMaterial)
    end

    csmodel.CustomCamoTexture = self:GetProcessedValue("CustomCamoTexture", true)
    csmodel.CustomCamoScale = self:GetProcessedValue("CustomCamoScale", true)
    csmodel.CustomBlendFactor = self:GetProcessedValue("CustomBlendFactor", true)

    if atttbl.CharmModel then
        local charmmodel = ClientsideModel(atttbl.CharmModel)

        csmodel.charmmdl = charmmodel
        charmmodel.charmparent = csmodel

        charmmodel.atttbl = atttbl
        charmmodel.slottbl = slottbl
        charmmodel.weapon = self

        charmmodel:SetBodyGroups(atttbl.CharmBodygroups or "") -- RUBAT THANK YOU FOR MAKING FUNC ERROR AFTER 10 YEARS OF STABLE WORK
        charmmodel:SetMaterial(atttbl.CharmMaterial)
        charmmodel:SetNoDraw(true)

        local scale = Matrix()
        local vec = Vector(1, 1, 1) * (atttbl.CharmScale or 1) * (atttbl.Scale or 1)
        if wm then
            vec = vec * (self.WorldModelOffset.Scale or 1)
        end
        vec = vec * (slottbl.Scale or 1)
        scale:Scale(vec)
        charmmodel:EnableMatrix("RenderMultiply", scale)

        local charmtbl = {
            Model = charmmodel,
            Weapon = self,
            Version = self.ModelVersion
        }

        table.insert(ARC9.CSModelPile, charmtbl)

        if cm then
            table.insert(self.CModel, charmmodel)
        else
            if wm then
                table.insert(self.WModel, charmmodel)
            else
                table.insert(self.VModel, charmmodel)
            end
        end
    end

    if atttbl.Flare then
        csmodel.Flare = {
            Color = atttbl.FlareColor or Color(255, 255, 255),
            Size = atttbl.FlareSize or 200,
            Attachment = atttbl.FlareAttachment,
            Focus = atttbl.FlareFocus
        }
    end

    if !ignorescale then
        local scale = Matrix()
        local vec = Vector(1, 1, 1) * (atttbl.Scale or 1)
        if wm then
            vec = vec * (self.WorldModelOffset.Scale or 1)
        end
        vec:Mul(slottbl.Scale or 1)
        scale:Scale(vec)
        csmodel.Scale = vec
        csmodel:EnableMatrix("RenderMultiply", scale)
    end

    local tbl = {
        Model = csmodel,
        Weapon = self,
        Version = self.ModelVersion
    }

    table.insert(ARC9.CSModelPile, tbl)

    if cm then
        table.insert(self.CModel, csmodel)
    else
        if wm then
            table.insert(self.WModel, csmodel)
        else
            table.insert(self.VModel, csmodel)
        end
    end

    return csmodel
end

SWEP.LHIKModel = nil
SWEP.LHIKModelAddress = nil
SWEP.LHIK_Priority = -1000
SWEP.RHIKModel = nil
SWEP.RHIKModelAddress = nil
SWEP.RHIK_Priority = -1000
SWEP.LHIKModelWM = nil
SWEP.RHIKModelWM = nil
SWEP.MuzzleDeviceVM = nil
SWEP.MuzzleDeviceWM = nil
SWEP.MuzzleDeviceUBGLVM = nil
SWEP.MuzzleDeviceUBGLWM = nil

-- An important function
function SWEP:SetupModel(wm, lod, cm)
    lod = lod or 0
    if !wm then lod = 0 end
    if cm then wm = true end

    -- self:KillModel(cm)

    if !cm then
        self:KillSpecificModel(wm)
    end

    local owner = self:GetOwner()

    if !wm and !IsValid(owner) then return end

    if wm and !self.MirrorVMWM then return end

    self.LHIK_Priority = -1000
    self.RHIK_Priority = -1000
    self.MuzzleDevice_Priority = -1000
    self.MuzzleDeviceUBGL_Priority = -1000

    local basemodel = nil

    local mdl = {}

    if !wm then
        self.VModel = mdl
        self.LHIKModel = nil
        self.RHIKModel = nil
        self.MuzzleDeviceVM = nil
        self.MuzzleDeviceUBGLVM = nil

        if !owner.GetViewModel then return end -- safe check to fix random mp error

        basemodel = owner:GetViewModel()

        -- local RenderOverrideFunction = function(self2)
        --     if LocalPlayer():GetActiveWeapon() != self then LocalPlayer():GetViewModel().RenderOverride = nil return end
        --     if !IsValid(self) then LocalPlayer():GetViewModel().RenderOverride = nil return end

        --     self:SetFiremodePose()
        --     self2:DrawModel()
        -- end

        -- local vm = self:GetVM()

        -- vm.RenderOverride = RenderOverrideFunction
    else
        if cm then
            self.CModel = mdl
        else
            self.LHIKModelWM = nil
            self.RHIKModelWM = nil
            self.MuzzleDeviceWM = nil
            self.MuzzleDeviceUBGLWM = nil
            self.WModel = mdl
        end

        local csmodel = ClientsideModel(self.WorldModelMirror or self.ViewModel)
        csmodel.weapon = self
        basemodel = csmodel

        if !IsValid(csmodel) then return end

        csmodel:SetNoDraw(true)
        csmodel.atttbl = {}

        local shouldtpik = self:ShouldTPIK()
        
        if cm then
            csmodel.slottbl = {
                WMBase = true,
                Pos = Vector(0, 0, 0),
                Ang = Angle(0, 0, 0)
            }
        else
            csmodel.slottbl = {
                WMBase = true,
                Pos = (shouldtpik and self.WorldModelOffset.TPIKPos) or self.WorldModelOffset.Pos or Vector(0, 0, 0),
                Ang = (shouldtpik and self.WorldModelOffset.TPIKAng) or self.WorldModelOffset.Ang or Angle(-5, 0, 180)
            }
        end

        local animentry = self:GetAnimationEntry("idle")
        local source = animentry and animentry.Source or "idle"

        if istable(source) then
            source = source[1]
        end

        if !isnumber(source) then
            source = csmodel:LookupSequence(source)
        end

        if source >= 0 then
            csmodel:ResetSequence(source)
        end

        local scale = Matrix()
        local vec = Vector(1, 1, 1) * (self.WorldModelOffset.Scale or 1)
        scale:Scale(vec)
        csmodel:EnableMatrix("RenderMultiply", scale)

        local tbl = {
            Model = csmodel,
            Weapon = self,
            Version = self.ModelVersion
        }

        table.insert(ARC9.CSModelPile, tbl)

        table.insert(mdl, 1, csmodel)
    end

    if !wm and owner != LocalPlayer() then return end
    if lod > 0 then return end

    local eles = self:GetAttachmentElements()

    for _, ele in ipairs(eles) do

        if !ele then continue end
        if !ele.Models then continue end

        for _, model in ipairs(ele.Models) do
            local csmodel = ClientsideModel(model.Model)

            if !IsValid(csmodel) then continue end

            csmodel:SetNoDraw(true)
            csmodel.atttbl = {}

            csmodel.slottbl = {
                Pos = model.Pos or Vector(0, 0, 0),
                Ang = model.Ang or Angle(0, 0, 0),
                Bone = model.Bone
            }

            if model.BoneMerge then
                csmodel.BoneMerge = true

                csmodel:AddEffects(EF_BONEMERGE)
                csmodel:SetParent(basemodel)
            end

            local scale = Matrix()
            local vec = model.ScaleVector or (Vector(1, 1, 1) * (model.Scale or 1))
            if wm then
                vec = vec * (self.WorldModelOffset.Scale or 1)
            end
            scale:Scale(vec)
            csmodel:EnableMatrix("RenderMultiply", scale)

            csmodel:SetSkin(model.Skin or 1)
            csmodel:SetBodyGroups(model.Bodygroups or "")

            if (ele.MuzzleDevice) then
                local priority = ele.MuzzleDevice_Priority or 0
                local totalpriority = self.MuzzleDevice_Priority or 0

                if priority > totalpriority or (priority == totalpriority and i > 0) then
                    self.MuzzleDevice_Priority = priority
                    csmodel.IsMuzzleDevice = true

                    if wm then
                        self.MuzzleDeviceWM = csmodel
                    else
                        self.MuzzleDeviceVM = csmodel
                    end
                end
            end

            local tbl = {
                Model = csmodel,
                Weapon = self,
                Version = self.ModelVersion
            }

            csmodel.CustomCamoTexture = self:GetProcessedValue("CustomCamoTexture", true)
            csmodel.CustomCamoScale = self:GetProcessedValue("CustomCamoScale", true)
            csmodel.CustomBlendFactor = self:GetProcessedValue("CustomBlendFactor", true)

            table.insert(ARC9.CSModelPile, tbl)

            table.insert(mdl, 1, csmodel)
        end
    end

    for _, slottbl in ipairs(self:GetSubSlotList()) do
        if !slottbl.Installed then continue end
        if slottbl.NoDraw then continue end

        -- local atttbl = ARC9.GetAttTable(slottbl.Installed)
        local atttbl = self:GetFinalAttTable(slottbl)

        local stickertablepath = slottbl.StickerModel

        if wm then
            stickertablepath = slottbl.StickerModelWorld or stickertablepath
        end

        if stickertablepath and atttbl.StickerMaterial then
            local stickermodel = ClientsideModel(stickertablepath)

            if !IsValid(stickermodel) then continue end

            stickermodel:SetNoDraw(true)
            stickermodel.atttbl = {
                DrawFunc = atttbl.StickerDrawFunc
            }
            stickermodel.slottbl = slottbl

            stickermodel:AddEffects(EF_BONEMERGE)
            local stickerparent = basemodel
            if slottbl.ParentTable then
                if wm then
                    stickerparent = slottbl.ParentTable.WModel or basemodel
                else
                    stickerparent = slottbl.ParentTable.VModel or basemodel
                end
            end
            stickermodel:SetParent(stickerparent)
            local stickermat = atttbl.StickerMaterial

            if self.StickersNoNocull then
                local fakestickwithoutnocull = Material(stickermat)
                fakestickwithoutnocull:SetInt("$flags", bit.band(fakestickwithoutnocull:GetInt("$flags"), bit.bnot(8192)))
                fakestickwithoutnocull:Recompute()
            end
            
            stickermodel:SetMaterial(stickermat)

            local tbl = {
                Model = stickermodel,
                Weapon = self,
                Version = self.ModelVersion
            }

            table.insert(ARC9.CSModelPile, tbl)

            table.insert(mdl, stickermodel)
        end

        if !atttbl.Model then continue end

        local dupli = slottbl.DuplicateModels or {}

        local duplicheck = self:GetProcessedValue("Akimbo",true) or self:GetProcessedValue("DuplicateAttachments",true)

        for i = 0, #dupli do
            local csmodel = self:CreateAttachmentModel(wm, atttbl, slottbl, false, cm, dupli)

            if duplicheck  then
                csmodel.Duplicate = i
            end

            if atttbl.NoDraw then
                csmodel.NoDraw = true
            end

            if csmodel.DrawFunc then
                csmodel.DrawFunc(self, csmodel, wm)
            end

            csmodel.CustomCamoTexture = self:GetProcessedValue("CustomCamoTexture", true)
            csmodel.CustomCamoScale = self:GetProcessedValue("CustomCamoScale", true)
            csmodel.CustomBlendFactor = self:GetProcessedValue("CustomBlendFactor", true)

            local proxmodel

            if !cm and ((atttbl.LHIK or atttbl.RHIK) or atttbl.MuzzleDevice or atttbl.MuzzleDeviceUBGL) then
                proxmodel = self:CreateAttachmentModel(wm, atttbl, slottbl, true)
                proxmodel.NoDraw = true
                if duplicheck then
                    proxmodel.Duplicate = i
                end

                local scale = Matrix()
                local vec = Vector(1, 1, 1) * (slottbl.Scale or 1) * (atttbl.Scale or 1)
                if wm then
                    vec = vec * (self.WorldModelOffset.Scale or 1)
                end
                if i > 0 then
                    vec = vec * (slottbl.DuplicateModels[i].Scale or 1)
                end
                scale:Scale(vec)
                proxmodel:EnableMatrix("RenderMultiply", scale)

                local tbl = {
                    Model = proxmodel,
                    Weapon = self,
                    Version = self.ModelVersion
                }

                table.insert(ARC9.CSModelPile, tbl)
            end

            if atttbl.BoneMerge then
                csmodel.BoneMerge = true

                csmodel:AddEffects(EF_BONEMERGE)
                csmodel:SetParent(basemodel)
            end

            if (atttbl.MuzzleDevice or atttbl.MuzzleDeviceUBGL) and !cm then
                local priority = atttbl.MuzzleDevice_Priority or 0
                local totalpriority = self.MuzzleDevice_Priority or 0

                if atttbl.MuzzleDeviceUBGL then
                    priority = atttbl.MuzzleDeviceUBGL_Priority or 0
                    totalpriority = self.MuzzleDeviceUBGL_Priority or 0
                end

                if priority > totalpriority or (priority == totalpriority and i > 0) then
                    if atttbl.MuzzleDeviceUBGL then
                        self.MuzzleDeviceUBGL_Priority = priority
                    else
                        self.MuzzleDevice_Priority = priority
                        proxmodel.IsMuzzleDevice = true
                    end

                    local tbl

                    if atttbl.MuzzleDeviceUBGL then
                        tbl = self.MuzzleDeviceUBGLVM

                        if wm then
                            tbl = self.MuzzleDeviceUBGLWM
                        end
                    else
                        tbl = self.MuzzleDeviceVM

                        if wm then
                            tbl = self.MuzzleDeviceWM
                        end
                    end

                    if #dupli > 0 then
                        if i == 0 then
                            tbl = {proxmodel}
                        else
                            table.insert(tbl, proxmodel)
                        end
                    else
                        tbl = proxmodel
                    end

                    if atttbl.MuzzleDeviceUBGL then
                        self.MuzzleDeviceUBGLVM = tbl

                        if wm then
                            self.MuzzleDeviceUBGLWM = tbl
                        end
                    else
                        self.MuzzleDeviceVM = tbl

                        if wm then
                            self.MuzzleDeviceWM = tbl
                        end
                    end
                end
            end

            if !cm and i == 0 then
                if wm then
                    slottbl.WModel = csmodel
                else
                    slottbl.VModel = csmodel
                end
            end

            if i == 0 then
                csmodel.LaserCorrectionAngle = slottbl.LaserCorrectionAngle
            else
                csmodel.LaserCorrectionAngle = slottbl.DuplicateModels[i].LaserCorrectionAngle or slottbl.LaserCorrectionAngle
            end

            if !cm and i == 0 then
                if atttbl.IKAnimationProxy then
                    local animproxmodel = self:CreateAttachmentModel(wm, atttbl, slottbl, true)
                    animproxmodel.NoDraw = true
                    animproxmodel.IsAnimationProxy = true

                    slottbl.GunDriverModel = animproxmodel

                    local reflectproxmodel = ClientsideModel(self.ViewModel)

                    if !IsValid(reflectproxmodel) then return end

                    reflectproxmodel:SetNoDraw(true)
                    reflectproxmodel.atttbl = atttbl
                    reflectproxmodel.slottbl = slottbl

                    local tbl = {
                        Model = reflectproxmodel,
                        Weapon = self,
                        Version = self.ModelVersion
                    }

                    table.insert(ARC9.CSModelPile, tbl)

                    table.insert(mdl, reflectproxmodel)

                    reflectproxmodel.NoDraw = true
                    reflectproxmodel.IsAnimationProxy = true

                    slottbl.ReflectDriverModel = reflectproxmodel

                    local anim = self:TranslateAnimation("idle")
                    local ae = self:GetAnimationEntry(anim)
                    local seq = reflectproxmodel:LookupSequence(self:RandomChoice(ae.Source))

                    reflectproxmodel:ResetSequence(seq)
                end
            end

            if !cm and i == 0 and atttbl.LHIK or atttbl.RHIK then
                slottbl.IKModel = proxmodel

                if atttbl.LHIK then
                    if (atttbl.LHIK_Priority or 0) > self.LHIK_Priority then
                        self.LHIK_Priority = atttbl.LHIK_Priority or 0
                        if wm then
                            self.LHIKModelWM = proxmodel
                        else
                            self.LHIKModel = proxmodel
                        end
                        self.LHIKModelAddress = slottbl.Address
                    end
                end
                if atttbl.RHIK then
                    if (atttbl.RHIK_Priority or 0) > self.RHIK_Priority then
                        self.RHIK_Priority = atttbl.RHIK_Priority or 0
                        if wm then
                            self.RHIKModelWM = proxmodel
                        else
                            self.RHIKModel = proxmodel
                        end
                        self.RHIKModelAddress = slottbl.Address
                    end
                end
            end
        end
    end

    self:CreateFlashlights()

    self:DoBodygroups(wm, cm)
end

SWEP.VModel = nil
SWEP.WModel = nil
SWEP.CModel = nil

function SWEP:KillSpecificModel(wm)
    if wm then
        for _, model in ipairs(self.WModel or {}) do
            SafeRemoveEntity(model)
        end

        self.WModel = nil
    else
        for _, model in ipairs(self.VModel or {}) do
            SafeRemoveEntity(model)
        end

        self.VModel = nil
    end
end

function SWEP:KillModel(cmo)
    if cmo then
        for _, model in ipairs(self.CModel or {}) do
            SafeRemoveEntity(model)
        end

        self.CModel = nil

        return
    end

    if !self.VModel and !self.WModel then return end

    for _, model in ipairs(self.VModel or {}) do
        SafeRemoveEntity(model)
    end
    for _, model in ipairs(self.WModel or {}) do
        SafeRemoveEntity(model)
    end

    self.ModelVersion = self.ModelVersion + 1

    self.VModel = nil
    self.WModel = nil
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_bodygroups.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_effects.lua:
function SWEP:DoEffects()
    if !IsFirstTimePredicted() then return end
    if self:GetProcessedValue("NoMuzzleEffect", true) then return end

    local muzz_qca = self:GetQCAMuzzle()

    local data = EffectData()
    data:SetEntity(self)
    data:SetAttachment(muzz_qca)
    data:SetSurfaceProp(self:GetNthShot() % 2) -- hopefully nobody uses this on a muzzle effect

    local muzzle = "arc9_muzzleeffect"

    local muzefect = self:GetProcessedValue("MuzzleEffect", true)

    if !self:GetProcessedValue("MuzzleParticle", true) and muzefect then
        muzzle = muzefect
        data:SetScale(1)
        data:SetFlags(0)
        data:SetEntity(self:GetVM())
    end

    util.Effect(muzzle, data, true)

    if IsValid(self.ActiveAfterShotPCF) then
        self.ActiveAfterShotPCF:StopEmission()
    end
end

function SWEP:GetQCAMuzzle()
    return self:GetProcessedValue("MuzzleEffectQCA", false)
end

function SWEP:GetQCAEject()
    return self:GetProcessedValue("CaseEffectQCA", false)
end

function SWEP:GetQCAMagdrop()
    return self:GetProcessedValue("DropMagazineQCA", true) or self:GetProcessedValue("CaseEffectQCA", true)
end

SWEP.EjectedShells = {}

function SWEP:DoEject(index, attachment)
    if !IsFirstTimePredicted() then return end

    -- if self:GetProcessedValue("NoShellEject") then return end

    local eject_qca = attachment or self:GetQCAEject()

    local data = EffectData()
    data:SetEntity(self)
    data:SetAttachment(eject_qca)
    data:SetFlags(index or 0)

    for i = 1, self:GetProcessedValue("ShellEffectCount", true) do
        util.Effect(self:GetProcessedValue("ShellEffect", true) or "ARC9_shelleffect", data, true)
    end
end

function SWEP:GetTracerOrigin()
    local ow = self:GetOwner()
    local vm = ow.GetViewModel and ow:GetViewModel() or nil
    local wm = ow:IsNPC() or !ow:IsValid() or !vm:IsValid() or ow:ShouldDrawLocalPlayer()
    local att = self:GetQCAMuzzle()
    local muzz = self

    if !wm then
        muzz = vm
    end

    if muzz and muzz:IsValid() then
        local posang = muzz:GetAttachment(att)
        if !posang then return muzz:GetPos() end
        local pos = posang.Pos

        return pos
    end
end

function SWEP:GetMuzzleDevice(wm, n)
    if self:GetProcessedValue("IgnoreMuzzleDevice", true) then
        if wm then return self:GetWM() else return self:GetVM() end
    end

    local model
    local muzz
    local nthShot = n or self:GetNthShot()

    local ubgl = self:GetUBGL()

    if wm then
        model = self.WModel
        muzz = self:GetWM()

        if ubgl and self.MuzzleDeviceUBGLWM then
            if istable(self.MuzzleDeviceUBGLWM) then
                return self.MuzzleDeviceUBGLWM[(nthShot % #self.MuzzleDeviceUBGLWM) + 1]
            else
                return self.MuzzleDeviceUBGLWM
            end
        elseif self.MuzzleDeviceWM then
            if istable(self.MuzzleDeviceWM) then
                return self.MuzzleDeviceWM[(nthShot % #self.MuzzleDeviceWM) + 1]
            else
                return self.MuzzleDeviceWM
            end
        end
    else
        model = self.VModel
        muzz = self:GetVM()

        if ubgl and self.MuzzleDeviceUBGLVM then
            if istable(self.MuzzleDeviceUBGLVM) then
                return self.MuzzleDeviceUBGLVM[(nthShot % #self.MuzzleDeviceUBGLVM) + 1]
            else
                return self.MuzzleDeviceUBGLVM
            end
        elseif self.MuzzleDeviceVM then
            if istable(self.MuzzleDeviceVM) then
                return self.MuzzleDeviceVM[(nthShot % #self.MuzzleDeviceVM) + 1]
            else
                return self.MuzzleDeviceVM
            end
        end
    end

    if model then
        for i, k in pairs(model) do
            if k.IsMuzzleDevice then
                return k
            end
        end
    end

    return muzz
end

function SWEP:DrawEjectedShells()
    local newshells = {}

    for i, k in pairs(self.EjectedShells) do
        if !k:IsValid() then continue end

        k:DrawModel()
        table.insert(newshells, k)
    end

    self.EjectedShells = newshells
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_inspect.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_jamming.lua:
function SWEP:RollJam()
    if !self:GetProcessedValue("Malfunction", true) then return end
    if self:Clip1() == 0 and self.MalfunctionNeverLastShoot then return end

    local chance = 1 / self:GetProcessedValue("MalfunctionMeanShotsToFail")

    if util.SharedRandom("arc9_jam", 0, 1000) / 1000 <= chance then
        if self:GetProcessedValue("MalfunctionJam", true) then
            self:SetJammed(true)
        end

		if self:GetProcessedValue("MalfunctionExitSights", true) then
			self:ExitSights()
		end
		
        self:PlayAnimation("jam", 1, true)
        local soundtab1 = {
            name = "jam",
            sound = self:RandomChoice(self:GetProcessedValue("MalfunctionSound", true)),
            channel = ARC9.CHAN_FIDDLE
        }
        self:PlayTranslatedSound(soundtab1)
        self:SetNextPrimaryFire(CurTime() + self:GetProcessedValue("MalfunctionWait", true))
        self:SetNeedsCycle(false)

        return true
    end
end

function SWEP:DoHeat()
    if !self:GetProcessedValue("Overheat", true) then return end

    self:SetHeatAmount(self:GetHeatAmount() + self:GetProcessedValue("HeatPerShot", true))

    if self:GetHeatAmount() >= self:GetProcessedValue("HeatCapacity") then
        self:SetHeatAmount(self:GetProcessedValue("HeatCapacity"))
        if self:GetProcessedValue("HeatLockout", true) then
            self:SetHeatLockout(true)
        end

        if self:HasAnimation(self:TranslateAnimation("fix")) then
            self:SetJammed(true)
            self:SetNextPrimaryFire(CurTime() + self:GetProcessedValue("MalfunctionWait", true))
        end
    end
end

function SWEP:FixHeat()
    if self:StillWaiting() and !self.NoFireDuringSighting then return end
    if self.StartedFixingJam then return end
    -- self:ExitSights()

    -- self:PlayAnimation("fix", self:GetProcessedValue("OverheatTime"), true)
    -- self:SetJammed(false)

    -- if self:GetProcessedValue("HeatFix", true) then
    --     self:SetHeatAmount(0)
    -- end

    
    self.StartedFixingJam = true
    local t = self:PlayAnimation("fix", self:GetProcessedValue("OverheatTime", true), true)
    self:SetInSights(false)

    self:SetTimer(t * 0.8, function()
        self:SetJammed(false)

        if self:GetProcessedValue("HeatFix", true) then
            self:SetHeatAmount(0)
        end
        self.StartedFixingJam = nil
    end, "jamtimer")
end

function SWEP:ThinkHeat(dt)
    dt = dt or FrameTime()
    local heat = self:GetHeatAmount()

    if heat <= 0 then return end

    -- if !self:GetProcessedValue("Overheat", true) then return end

    if self:GetNextPrimaryFire() + self:GetProcessedValue("HeatDelayTime", true) < CurTime() then
        heat = heat - (dt * self:GetProcessedValue("HeatDissipation"))
        heat = math.Clamp(heat, 0, math.huge)

        if heat <= 0 and self:GetHeatLockout() then
            self:SetHeatLockout(false)
        end

        if self:GetJammed() and !self.StartedFixingJam then
            self:FixHeat()
        end

        self:SetHeatAmount(heat)
    end
end

function SWEP:UnJam()
    if self:StillWaiting() and !self.NoFireDuringSighting then return end
    if self.StartedFixingJam then return end
    -- self:SetJammed(false)

    -- self:PlayAnimation("fix", 1, true)

    self.StartedFixingJam = true
    local t = self:PlayAnimation("fix", 1, true)
    self:SetInSights(false)

    self:SetTimer(t * 0.8, function()
        self:SetJammed(false)
        self.StartedFixingJam = nil
    end, "jamtimer")
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_net.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_net.lua:
function SWEP:SendWeapon(rec)
    net.Start("ARC9_networkweapon")
    net.WriteEntity(self)

    for i, k in pairs(self.Attachments or {}) do
        self:SendAttachmentTree(self.Attachments[i])
    end

    if SERVER then
        if rec then
            -- send to just this one person
            net.Send(rec)
        else
            net.Broadcast()
        end
    else
        net.SendToServer()
    end
end

function SWEP:SendAttachmentTree(tree)
    if tree and tree.Installed then
        local atttbl = ARC9.GetAttTable(tree.Installed) or {}
        local id = atttbl.ID or 0

        if !atttbl then
            net.WriteUInt(0, ARC9.Attachments_Bits)
            return
        end

        net.WriteUInt(id, ARC9.Attachments_Bits)

        tree.SubAttachments = tree.SubAttachments or {}

        if atttbl.ToggleStats then
            net.WriteUInt((tree.ToggleNum or 1) - 1, 8)
        end

        if atttbl.Attachments then
            for i, k in pairs(atttbl.Attachments) do
                self:SendAttachmentTree(tree.SubAttachments[i])
            end
        end
    else
        net.WriteUInt(0, ARC9.Attachments_Bits)
    end
end

function SWEP:CountAttsInTree(tree)
    local flattree = {}
    for _, i in pairs(tree) do
        table.Add(flattree, self:AttTreeToList(i))
    end

    local count = {}

    for _, i in pairs(flattree) do
        if i.Installed then
            local att = i.Installed
            local atttbl = ARC9.GetAttTable(att) or {}
            att = atttbl.InvAtt or att
            count[att] = (count[att] or 0) + 1
        end
    end

    return count
end

local arc9_atts_nocustomize = GetConVar("arc9_atts_nocustomize")
local arc9_atts_lock = GetConVar("arc9_atts_lock")
local arc9_npc_autoreplace = GetConVar("arc9_npc_autoreplace")
local arc9_replace_spawned = GetConVar("arc9_replace_spawned")

function SWEP:ReceiveWeapon()
    if SERVER and arc9_atts_nocustomize:GetBool() then return end

    local tbl = {}

    for i, k in pairs(self.Attachments or {}) do
        tbl[i] = self:ReceiveAttachmentTree()
    end

    if SERVER then

        if !self:ValidateInventoryForNewTree(tbl) then
            self:SendWeapon()
            return
        end

        if !arc9_atts_lock:GetBool() then
            local oldcount = self:CountAttsInTree(self.Attachments)
            local newcount = self:CountAttsInTree(tbl)

            for att, attc in pairs(newcount) do
                local atttbl = ARC9.GetAttTable(att)

                if atttbl.Free then continue end

                local has = oldcount[att] or 0
                local need = attc

                if has < need then
                    local diff = need - has

                    ARC9:PlayerTakeAtt(self:GetOwner(), att, diff)
                end
            end

            for att, attc in pairs(oldcount) do
                local atttbl = ARC9.GetAttTable(att)
                if !atttbl then ErrorNoHaltWithStack("The attachment trying to be installed doesn't exist. '" .. att .. "'") continue end
                if atttbl.Free then continue end

                local has = attc
                local need = newcount[att] or 0

                if has > need then
                    local diff = has - need

                    ARC9:PlayerGiveAtt(self:GetOwner(), att, diff)
                end
            end
        end

    end

    self:BuildSubAttachments(tbl)

    if CLIENT then
        self:InvalidateCache()
        self:PruneAttachments()
        self:KillModel()
        self:SetupModel(true)
        self:SetupModel(false)
        self:RefreshCustomizeMenu()

        if !IsValid(self:GetOwner()) and (arc9_npc_autoreplace:GetBool() or arc9_replace_spawned:GetBool()) then -- very awful but i dont know how to make that value network properly
            self.LoadedPreset = true
        end
    else
        self:InvalidateCache()
        self:PruneAttachments()
        self:FillIntegralSlots()
        self:SendWeapon()
        self:PostModify()

        ARC9:PlayerSendAttInv(self:GetOwner())
    end

    -- self:SetBaseSettings()
end

function SWEP:ReceiveAttachmentTree()
    local id = net.ReadUInt(ARC9.Attachments_Bits)
    local att = ARC9.Attachments_Index[id]

    local tree = {
        Installed = att,
        SubAttachments = {}
    }

    if !att then return tree end

    local atttbl = ARC9.GetAttTable(att)

    if !atttbl then return {} end

    if atttbl.ToggleStats then
        tree.ToggleNum = net.ReadUInt(8) + 1
    end

    if atttbl.Attachments then
        for i, k in pairs(atttbl.Attachments) do
            tree.SubAttachments[i] = self:ReceiveAttachmentTree()
        end
    end

    return tree
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_npc.lua:
function SWEP:NPC_PrimaryAttack()
    if !IsValid(self:GetOwner()) then return end
    if self:Clip1() <= 0 then self:GetOwner():SetSchedule(SCHED_HIDE_AND_RELOAD) return end

    local owner = self:GetOwner()

    self:SetBaseSettings()
    self:SetShouldHoldType()
    self:DoShootSounds()
    self:DoEffects()
    self:DoEject()

    local delay = 60 / self:GetProcessedValue("RPM")

    self:SetNextPrimaryFire(CurTime() + delay)

    local spread = self:GetNPCBulletSpread(owner:GetCurrentWeaponProficiency()) / 36
    spread = spread + self:GetProcessedValue("Spread")

    self:DoProjectileAttack(owner:GetShootPos(), owner:GetAimVector():Angle(), spread)

    if !self:GetProcessedValue("BottomlessClip", true) then
        self:TakePrimaryAmmo(self:GetProcessedValue("AmmoPerShot", true))
    end
end

local arc9_npc_spread = GetConVar("arc9_npc_spread")

function SWEP:GetNPCBulletSpread(prof)
    prof = prof or 0
    local mode = self:GetCurrentFiremode()
    local mult = arc9_npc_spread:GetFloat()

    mult = mult * 0.5

    if mode < 0 then
        return mult * 10 / (prof + 1)
    elseif mode == 0 then
        return mult * 20 / (prof + 1)
    elseif mode == 1 then
        if math.Rand(0, 100) < (prof + 1) * 5 then
            return mult * 1 / (prof + 1)
        else
            return mult * 25 / (prof + 1)
        end
    elseif mode >= 2 then
        return mult * 20 / (prof + 1)
    end

    return mult * 15
end

function SWEP:GetNPCSpread()
    local spread = self:GetValue("Spread")

    spread = math.max(spread, 0)

    return spread
end

function SWEP:GetNPCBurstSettings()
    local mode = self:GetCurrentFiremode()

    local delay = 60 / self:GetValue("RPM")

    self:SetNextPrimaryFire(CurTime() + delay)

    if !mode then return 1, 1, delay end

    if mode < 0 then
        return 2, math.floor(0.5 * (self:GetOwner():GetCurrentWeaponProficiency()) / delay), delay
    elseif mode == 0 then
        return 0, 0, delay
    elseif mode == 1 then
        return 1, 1, delay + math.Rand(0.3, 0.6)
    elseif mode >= 2 then
        return mode, mode, delay
    end
end

function SWEP:GetNPCRestTimes()
    return 0.33, 1
end

function SWEP:CanBePickedUpByNPCs()
    return !self.NotForNPCs
end

function SWEP:NPC_Reload()
    self:DropMagazine()
    self:SetNthShot(0)
end

local arc9_npc_atts = GetConVar("arc9_npc_atts")

function SWEP:NPC_Initialize()
    self.DefaultAttachments = table.Copy(self.Attachments)

    self:BuildSubAttachments(self.DefaultAttachments)
    self:SetBaseSettings()

    self.LoadedPreset = true

    if CLIENT then return end

    if IsValid(self) then
        if !self.WeaponWasGiven and arc9_npc_atts:GetBool() then
            -- self:RollRandomAtts(self.Attachments)
            self:QueueForRandomize()
        end
        -- self:PostModify()

        -- self:PruneAttachments()
        -- self:SendWeapon()
    end
end

function SWEP:QueueForRandomize()
    table.insert(ARC9.RandomizeQueue, self)
end

local alwaysinstallcats = {
    "_gas",
    "gasblock",
    "buffer",
    "_rec",
    "_grip",
    "_pg",
    "barrel",
    "upper",
    "lower",
    "hguard",
    "handguard",
    "_hg",
    "bolt",
    "_charge",
}

function SWEP:RollRandomAtts(tree, nofuther)
    local attchance = 66
    if nofuther then attchance = 9999 end

    for i, slottbl in pairs(tree) do
        if slottbl.MergeSlots then
            if math.Rand(0, 100) > (100 / table.Count(slottbl.MergeSlots)) then continue end
        end
        
        local cat = slottbl.Category and (isstring(slottbl.Category) and slottbl.Category or slottbl.Category[1]) or nil
        -- print(cat)
        for _, needle in ipairs(alwaysinstallcats) do
            if isstring(cat) and string.find(cat, needle) then attchance = 9999 end
        end

        if math.Rand(0, 100) > attchance then continue end
        local atts = ARC9.GetAttsForCats(slottbl.Category or "")

        -- if math.Rand(0, 100) > 100 / (table.Count(atts) + 1) then slottbl.Installed = nil continue end

        -- local att = table.Random(atts)

        local randompool = {}

        for _, maybethisatt in ipairs(atts) do
            local atttbl = ARC9.GetAttTable(maybethisatt)
            if !atttbl then continue end
            if atttbl.Ignore or slottbl.Hidden or atttbl.AttNotForNPCs or self:GetAttBlocked(atttbl) then continue end

            table.insert(randompool, maybethisatt)
        end

        local att = table.Random(randompool)


        if !att then slottbl.Installed = nil continue end

        local atttbl = ARC9.GetAttTable(att)

        if !atttbl then continue end
        -- if atttbl.Ignore or slottbl.Hidden or atttbl.AttNotForNPCs or self:GetAttBlocked(atttbl) then continue end

        slottbl.Installed = att

        if !nofuther and atttbl.Attachments then
            slottbl.SubAttachments = table.Copy(atttbl.Attachments)
            self:RollRandomAtts(slottbl.SubAttachments)
        end
    end
    
    timer.Simple(0, function() 
        self:SetClip1(self:GetValue("ClipSize"))
    end)
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_think.lua:
local ENTITY = FindMetaTable("Entity")
local entityGetOwner = ENTITY.GetOwner
local entityIsPlayerHolding = ENTITY.IsPlayerHolding

local PLAYER = FindMetaTable("Player")
local playerKeyReleased = PLAYER.KeyReleased
local playerKeyDown = PLAYER.KeyDown
local playerDoAnimationEvent = PLAYER.DoAnimationEvent

local swepIdle = SWEP.Idle
local swepGetProcessedValue = SWEP.GetProcessedValue
local swepPlayAnimation = SWEP.PlayAnimation
local swepPrimaryAttack = SWEP.PrimaryAttack
local swepGetCurrentFiremode = SWEP.GetCurrentFiremode
local swepDoPrimaryAttack = SWEP.DoPrimaryAttack
local swepGetIsWalking = SWEP.GetIsWalking
local swepLoadPreset = SWEP.LoadPreset
local swepDoDeployAnimation = SWEP.DoDeployAnimation

-- uuugghh
-- local swepThinkSprint = SWEP.ThinkSprint
local swepThinkCycle = SWEP.ThinkCycle
local swepThinkHeat = SWEP.ThinkHeat
local swepThinkReload = SWEP.ThinkReload
local swepThinkSights = SWEP.ThinkSights
local swepThinkBipod = SWEP.ThinkBipod
local swepThinkMelee = SWEP.ThinkMelee
local swepThinkGrenade = SWEP.ThinkGrenade
local swepThinkRecoil = SWEP.ThinkRecoil
local swepThinkHoldBreath = SWEP.ThinkHoldBreath
local swepThinkLockOn = SWEP.ThinkLockOn
local swepThinkLean = SWEP.ThinkLean
local swepThinkFiremodes = SWEP.ThinkFiremodes
local swepThinkInspect = SWEP.ThinkInspect
local swepThinkSprint = SWEP.ThinkSprint
local swepThinkNearWall = SWEP.ThinkNearWall
local swepThinkFreeAim = SWEP.ThinkFreeAim
local swepThinkLoopingSound = SWEP.ThinkLoopingSound
local swepThinkAnimation = SWEP.ThinkAnimation
local swepThinkCustomize = SWEP.ThinkCustomize
local swepRunHook = SWEP.RunHook
local swepThinkThirdArm = SWEP.ThinkThirdArm
local swepThinkPeek = SWEP.ThinkPeek

local WEAPON = FindMetaTable("Weapon")
local weaponSetNextPrimaryFire = WEAPON.SetNextPrimaryFire
local weaponGetNextPrimaryFire = WEAPON.GetNextPrimaryFire
local isSingleplayer = game.SinglePlayer()

local cvarArcAutosave = GetConVar("arc9_autosave")
local cvarGetBool = FindMetaTable("ConVar").GetBool

function SWEP:Think()
    local owner = entityGetOwner(self)

    if not IsValid(owner) then return end
    if owner:IsNPC() then return end

    local swepDt = self.dt
    local now = CurTime()

    if swepDt.NextIdle < now then
        swepIdle(self)
    end

    local shouldRunPredicted = not self:PredictionFilter()

    if not self.NotAWeapon then
        local notPressedAttack = not playerKeyDown(owner, IN_ATTACK)

        if swepGetProcessedValue(self, "TriggerDelay") then
            local primedAttack = swepDt.PrimedAttack
            local triggerDelay = swepDt.TriggerDelay
            local releasetofire = swepGetProcessedValue(self, "TriggerDelayReleaseToFire", true)

            if primedAttack and triggerDelay <= now and releasetofire and playerKeyReleased(owner, IN_ATTACK) and shouldRunPredicted then
                swepPrimaryAttack(self)
            elseif (primedAttack or triggerDelay > now) and playerKeyReleased(owner, IN_ATTACK) then
                swepPlayAnimation(self, "untrigger")

                if swepGetProcessedValue(self, "TriggerDelayCancellable") then
                    self:SetPrimedAttack(false)
                end
            end

            if primedAttack and triggerDelay <= now and notPressedAttack and shouldRunPredicted then
                swepPrimaryAttack(self)
            end
        end

        local currentFiremode = swepGetCurrentFiremode(self)
        local notRunawayBurst = not swepGetProcessedValue(self, "RunawayBurst", true)
        local postBurstDelay = now + swepGetProcessedValue(self, "PostBurstDelay")

        if notPressedAttack then
            self:SetNeedTriggerPress(false)
            if currentFiremode > 1 and notRunawayBurst and swepDt.BurstCount > 0 then
                weaponSetNextPrimaryFire(self, postBurstDelay)
            end
            if notRunawayBurst then
                self:SetBurstCount(0)
            end
        end

        -- :troll:
        if not notRunawayBurst then
            local burstCount = swepDt.BurstCount
            if burstCount >= currentFiremode and currentFiremode > 0 then
                self:SetBurstCount(0)
                weaponSetNextPrimaryFire(self, postBurstDelay)
            elseif burstCount > 0 and burstCount < currentFiremode then
                swepDoPrimaryAttack(self)
            end
        end

        -- if !self:StillWaiting() and self:GetProcessedValue("TriggerDelay") then
        --     local check = (game.SinglePlayer() and SERVER) or CLIENT
        --     if owner:KeyDown(IN_ATTACK) and !self:SprintLock() then
        --         if check and self:GetTriggerDelay() <= 0 then
        --             self:PlayAnimation("trigger", self:GetProcessedValue("TriggerDelayTime") / self.TriggerDelayTime)
        --         end
        --         self:SetTriggerDelay( math.Approach( self:GetTriggerDelay(), 1, FrameTime() * (1 / self:GetProcessedValue("TriggerDelayTime")) ) )
        --     else
        --         if check and self:GetTriggerDelay() != 1 and self:GetTriggerDelay() != 0 then
        --             self:PlayAnimation("untrigger", self:GetProcessedValue("TriggerDelayTime") / self.TriggerDelayTime)
        --         end
        --         self:SetTriggerDelay(0)
        --     end
        -- end

        -- If we have stopped shooting, play the aftershotparticle
        if swepDt.AfterShot and (IsFirstTimePredicted() or isSingleplayer) then
            local delay = 60 / swepGetProcessedValue(self, "RPM")

            if weaponGetNextPrimaryFire(self) + delay + swepGetProcessedValue(self, "AfterShotParticleDelay") < now then
                self:SetAfterShot(false)
                if swepGetProcessedValue(self, "AfterShotParticle", true) then
                    local att = swepGetProcessedValue(self, "AfterShotQCA") or swepGetProcessedValue(self, "MuzzleEffectQCA", true)

                    local data = EffectData()
                    data:SetEntity(self)
                    data:SetAttachment(att)

                    local effect = swepGetProcessedValue(self, "AfterShotEffect", true)

                    util.Effect(effect, data, true)
                end
            end
        end

        -- Will remove these comments later

        if shouldRunPredicted then
            swepThinkCycle(self)
            swepThinkHeat(self)
            swepThinkReload(self)
            -- Done (no GetVM)
            swepThinkBipod(self)
            swepThinkSights(self)
            swepThinkMelee(self)
            self:ThinkUBGL()
            self:ThinkGrenade()
            self:ThinkTriggerSounds()
        end
        -- Done
        self:ThinkRecoil()
        self:ThinkHoldBreath()
        self:ThinkLockOn()
    end

    if shouldRunPredicted then
        swepThinkLean(self)
        swepThinkFiremodes(self)
        swepThinkInspect(self)
    end

    swepThinkSprint(self)
    -- Done
    swepThinkNearWall(self)
    swepThinkFreeAim(self)
    swepThinkLoopingSound(self)
    swepThinkAnimation(self)
    swepThinkCustomize(self)

    swepRunHook(self, "Hook_Think")

    if CLIENT then
        swepThinkThirdArm(self)
        swepThinkPeek(self)
    end

    self:ProcessTimers()

    local holdingProp = owner.ARC9_HoldingProp
    if SERVER and holdingProp and (!IsValid(holdingProp) or !holdingProp:IsPlayerHolding()) then
        owner.ARC9_HoldingProp = nil
        net.Start("arc9_stoppickup")
        net.Send(owner)
        playerDoAnimationEvent(owner, ACT_FLINCH_BACK)
    end

    if CLIENT then
        if !self.LoadedPreset then
            self.LoadedPreset = true

            timer.Simple(0.06, function() -- idk
                if IsValid(self) then
                    if cvarGetBool(cvarArcAutosave) then
                        swepLoadPreset(self, "autosave")
                    else
                        swepLoadPreset(self, "default")
                    end

                    self:SetReady(false)
                    self:DoDeployAnimation()
                end
            end)
        end
        if isSingleplayer and self.IsQuickGrenade then owner.ARC9LastSelectedGrenade = self:GetClass() end
    end
end

SWEP.LastClipSize = 0
SWEP.LastAmmo = ""
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_triggersounds.lua:
function SWEP:ThinkTriggerSounds()
    if (!self.TriggerDownSound or self.TriggerDownSound == "") and (!self.TriggerUpSound or self.TriggerUpSound == "") then return end -- no fucking trigger sounds

    if self:GetAnimLockTime() > CurTime() then return end
    if self:StillWaiting() then return end
    if self:SprintLock() then return end
    if self:GetSafe() then return end
    local owner = self:GetOwner()
    local processedValue = self.GetProcessedValue

    if processedValue(self,"Throwable", true) then return end
    if processedValue(self,"PrimaryBash", true) then return end

    if owner:KeyReleased(IN_ATTACK) then

		if self.RecentMelee then 
			return 
		end

        local soundtab = {
            name = "triggerup",
            sound = self:RandomChoice(self.TriggerUpSound),
            channel = ARC9.CHAN_TRIGGER+7
        }

        self:PlayTranslatedSound(soundtab)
    elseif owner:KeyPressed(IN_ATTACK) then
        if processedValue(self,"Bash", true) and owner:KeyDown(IN_USE) and !self:GetInSights() then return end

        local soundtab = {
            name = "triggerdown",
            sound = self:RandomChoice(self.TriggerDownSound),
            channel = ARC9.CHAN_TRIGGER+7
        }

        self:PlayTranslatedSound(soundtab)
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_ubgl.lua:
local arc9_infinite_ammo = GetConVar("arc9_infinite_ammo")
local cvarGetBool = FindMetaTable("ConVar").GetBool

function SWEP:ThinkUBGL()
    if self:GetValue("UBGL") and !self:GetProcessedValue("UBGLInsteadOfSights", true)  then
        local owner = self:GetOwner()
		local mag = self:Clip2()
		local magr = self.Owner:GetAmmoCount(self.Secondary.Ammo)
		local infmag = cvarGetBool(arc9_infinite_ammo)

		if mag == 0 and (!infmag and magr == 0) then
			if self:GetUBGL() then self:ToggleUBGL(false) end
			return
		end

        if (owner:KeyDown(IN_USE) and owner:KeyPressed(IN_ATTACK2)) or owner:KeyPressed(ARC9.IN_UBGL) then
            if self.NextUBGLSwitch and self.NextUBGLSwitch > CurTime() then return end
            self.NextUBGLSwitch = CurTime() + (self.UBGLToggleTime or 1)

            if self:GetUBGL() then
                self:ToggleUBGL(false)
            else
                self:ToggleUBGL(true)
            end
        end

    end
end

local singleplayer = game.SinglePlayer()

function SWEP:ToggleUBGL(on)
    if on == nil then on = !self:GetUBGL() end
    if self:GetReloading() then on = false end
    if self:GetCustomize() then on = false end

    if on == self:GetUBGL() then return end

    if self:StillWaiting() then return end

	if self.UBGLCancelAnim then self:PlayAnimation("enter_sights" or "idle", 1, true) end
	
    self:CancelReload()
    self:SetUBGL(on)

    if singleplayer and self:GetOwner():IsPlayer() then
        self:CallOnClient("ClearLongCache")
    end
    self:ClearLongCache()
    
    if on then
        local soundtab = {
            name = "enterubgl",
            sound = self:RandomChoice(self:GetProcessedValue("EnterUBGLSound", true)),
            channel = ARC9.CHAN_FIDDLE
        }

        self:PlayTranslatedSound(soundtab)

        self:PlayAnimation("enter_ubgl", 1, true)
        self:ExitSights()

        if singleplayer then
            self:CallOnClient("RecalculateIKGunMotionOffset")
        end
    else
        local soundtab = {
            name = "exitubgl",
            sound = self:RandomChoice(self:GetProcessedValue("ExitUBGLSound", true)),
            channel = ARC9.CHAN_FIDDLE
        }

        self:PlayTranslatedSound(soundtab)

        self:PlayAnimation("exit_ubgl", 1, true)
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_util.lua:
function SWEP:SanityCheck()
    if !IsValid(self) then return false end
    if !IsValid(self:GetOwner()) then return false end
    if !IsValid(self:GetVM()) then return false end
end

function SWEP:DoPlayerAnimationEvent(event)
    -- if CLIENT and self:ShouldTPIK() then return end
    if event then self:GetOwner():AnimRestartGesture(1, event, true) end
    if SERVER then self:CallOnClient("DoPlayerAnimationEvent", event) end
end

function SWEP:PlayTranslatedSound(soundtab)
    soundtab = self:RunHook("HookP_TranslateSound", soundtab) or soundtab

    if soundtab and soundtab.sound then
        local pitch = soundtab.pitch

        if istable(pitch) then
            pitch = math.random(pitch[1], pitch[2])
        end

        self:EmitSound(
            soundtab.sound,
            soundtab.level,
            pitch,
            soundtab.volume,
            soundtab.channel,
            soundtab.flags,
            soundtab.dsp
        )
    end
end

if SERVER then
    function SWEP:PredictionFilter()
        return false
    end
else
    local isSingleplayer = game.SinglePlayer()
    
    function SWEP:PredictionFilter()
        return isSingleplayer
    end
end

function SWEP:GetWM()
    if self.WModel then
        return self.WModel[1]
    else
        return NULL
    end
end

function SWEP:GetVM()
    local owner = self:GetOwner()
    if !IsValid(owner) then return nil end
    if !owner:IsPlayer() then return nil end
    return owner:GetViewModel()
end

function SWEP:Curve(x)
    return 0.5 * math.cos((x + 1) * math.pi) + 0.5
end

function SWEP:IsAnimLocked()
    return self:GetAnimLockTime() > CurTime()
end

function SWEP:RandomChoice(choice)
    if istable(choice) then
        choice = table.Random(choice)
    end

    return choice
end

function SWEP:PatternWithRunOff(pattern, runoff, num)
    if num < #pattern then
        return pattern[num]
    else
        num = num - #pattern
        num = num % #runoff

        return runoff[num + 1]
    end
end

-- Written by and used with permission from AWholeCream
-- start_p: Shoulder
-- end_p: Hand
-- length0: Shoulder to elbow
-- length1: Elbow to hand
-- rotation: rotates??? prevents chicken winging
function SWEP:Solve2PartIK(start_p, end_p, length0, length1, rotation)
    -- local circle = math.sqrt((end_p.x-start_p.x) ^ 2 + (end_p.y-start_p.y) ^ 2 )
    -- local length2 = math.sqrt(circle ^ 2 + (end_p.z-start_p.z) ^ 2 )
    local length2 = (start_p - end_p):Length()
    local cosAngle0 = math.Clamp(((length2 * length2) + (length0 * length0) - (length1 * length1)) / (2 * length2 * length0), -1, 1)
    local angle0 = -math.deg(math.acos(cosAngle0))
    local cosAngle1 = math.Clamp(((length1 * length1) + (length0 * length0) - (length2 * length2)) / (2 * length1 * length0), -1, 1)
    local angle1 = -math.deg(math.acos(cosAngle1))
    local diff = end_p - start_p
    local angle2 = math.deg(math.atan2(-math.sqrt(diff.x ^ 2 + diff.y ^ 2), diff.z)) - 90
    local angle3 = -math.deg(math.atan2(diff.x, diff.y)) - 90
    local axis = diff * 1
    axis:Normalize()
    local Joint0 = Angle(angle0 + angle2, angle3, 0)
    Joint0:RotateAroundAxis(axis, rotation)
    Joint0 = (Joint0:Forward() * length0)
    local Joint1 = Angle(angle0 + angle2 + 180 + angle1, angle3, 0)
    Joint1:RotateAroundAxis(axis, rotation)
    Joint1 = (Joint1:Forward() * length1)
    local Joint0_F = start_p + Joint0
    local Joint1_F = Joint0_F + Joint1

    return Joint0_F, Joint1_F
end
-- returns two vectors
-- upper arm and forearm

function SWEP:RotateAroundPoint(pos, ang, point, offset, offset_ang)
    local v = Vector(0, 0, 0)
    v = v + (point.x * ang:Right())
    v = v + (point.y * ang:Forward())
    v = v + (point.z * ang:Up())

    local newang = Angle()
    newang:Set(ang)

    newang:RotateAroundAxis(ang:Right(), offset_ang.p)
    newang:RotateAroundAxis(ang:Forward(), offset_ang.r)
    newang:RotateAroundAxis(ang:Up(), offset_ang.y)

    v = v + newang:Right() * offset.x
    v = v + newang:Forward() * offset.y
    v = v + newang:Up() * offset.z

    -- v:Rotate(offset_ang)

    v = v - (point.x * newang:Right())
    v = v - (point.y * newang:Forward())
    v = v - (point.z * newang:Up())

    pos = v + pos

    return pos, newang
end

function SWEP:RotateAroundPoint2(pos, ang, point, offset, offset_ang)

    local mat = Matrix()
    mat:SetTranslation(pos)
    mat:SetAngles(ang)
    mat:Translate(point)

    local rot_mat = Matrix()
    rot_mat:SetAngles(offset_ang)
    rot_mat:Invert()

    mat:Mul(rot_mat)

    mat:Translate(-point)

    mat:Translate(offset)

    return mat:GetTranslation(), mat:GetAngles()
end

function SWEP:IsUsingRTScope()
    return self:GetSightAmount() > 0.5 and self:GetSight() and self:GetSight().atttbl and self:GetSight().atttbl.RTScope
end

if CLIENT then

    function SWEP:ScaleFOVByWidthRatio( fovDegrees, ratio )
        local halfAngleRadians = fovDegrees * ( 0.5 * math.pi / 180 )
        local t = math.tan( halfAngleRadians )
        t = t * ratio
        local retDegrees = ( 180 / math.pi ) * math.atan( t )
        return retDegrees * 2
    end


    function SWEP:WidescreenFix(target)
        return self:ScaleFOVByWidthRatio(target, ((ScrW and ScrW() or 4) / (ScrH and ScrH() or 3)) / (4 / 3))
    end

    function SWEP:CallNonTPIKAnim(source)
        self:DoPlayerAnimationEvent(self:GetProcessedValue(!self:ShouldTPIK() and "NonTPIK" .. source or source, true))
    end
end
--PATH lua/weapons/arccw_base/cl_viewmodel.lua:
--[[
    Please, for the love of god, don't create objects in functions that are called multiple times per frame.
    The garbage collector will explode and so will players' comptuters.

    That means minimize usage of things that generate new objects, including:
        calls to Vector() or Angle(); use vector_origin and angle_zero if the value isn't modified
        arithmetic using +, -, * and / on Vectors and Angles; modifying individual parameters is fine
        functions like Angle:Right() and Vector:Angle(); however functions like Vector:Add() and Angle:Add() are fine

    Cache them if you use them more than one time!
]]

local mth = math
local m_appor = mth.Approach
local m_clamp = mth.Clamp
local f_lerp = Lerp
local srf = surface
SWEP.ActualVMData = false
local swayxmult, swayymult, swayzmult, swayspeed = 1, 1, 1, 1
local lookxmult, lookymult = 1, 1
SWEP.VMPos = Vector()
SWEP.VMAng = Angle()
SWEP.VMPosOffset = Vector()
SWEP.VMAngOffset = Angle()
SWEP.VMPosOffset_Lerp = Vector()
SWEP.VMAngOffset_Lerp = Angle()
SWEP.VMLookLerp = Angle()
SWEP.StepBob = 0
SWEP.StepBobLerp = 0
SWEP.StepRandomX = 1
SWEP.StepRandomY = 1
SWEP.LastEyeAng = Angle()
SWEP.SmoothEyeAng = Angle()
SWEP.LastVelocity = Vector()
SWEP.Velocity_Lerp = Vector()
SWEP.VelocityLastDiff = 0
SWEP.Breath_Intensity = 1
SWEP.Breath_Rate = 1

-- magic variables
local sprint_vec1 = Vector(-2, 5, 2)
local sprint_vec2 = Vector(0, 7, 3)
local sprint_ang1 = Angle(-15, -15, 0)
local spring_ang2 = Angle(-15, 15, -22)
local sight_vec1 = Vector(0, 15, -4)
local sight_vec2 = Vector(1, 5, -1)
local sight_ang1 = Angle(0, 0, -45)
local sight_ang2 = Angle(-5, 0, -10)
local sextra_vec = Vector(0.0002, 0.001, 0.005)

local procdraw_vec = Vector(0, 0, -5)
local procdraw_ang = Angle(-70, 30, 0)
local prochol_ang = Angle(-70, 30, 10)

local lst = SysTime()
local function scrunkly()
    local ret = (SysTime() - (lst or SysTime())) * GetConVar("host_timescale"):GetFloat()
    return ret
end

local function LerpC(t, a, b, powa)
    return a + (b - a) * math.pow(t, powa)
end

local function ApproachMod(usrobj, to, dlt)
    usrobj[1] = m_appor(usrobj[1], to[1], dlt)
    usrobj[2] = m_appor(usrobj[2], to[2], dlt)
    usrobj[3] = m_appor(usrobj[3], to[3], dlt)
end

local function LerpMod(usrobj, to, dlt, clamp_ang)
    usrobj[1] = f_lerp(dlt, usrobj[1], to[1])
    usrobj[2] = f_lerp(dlt, usrobj[2], to[2])
    usrobj[3] = f_lerp(dlt, usrobj[3], to[3])
    if clamp_ang then
        for i = 1, 3 do usrobj[i] = math.NormalizeAngle(usrobj[i]) end
    end
end

local function LerpMod2(from, usrobj, dlt, clamp_ang)
    usrobj[1] = f_lerp(dlt, from[1], usrobj[1])
    usrobj[2] = f_lerp(dlt, from[2], usrobj[2])
    usrobj[3] = f_lerp(dlt, from[3], usrobj[3])
    if clamp_ang then
        for i = 1, 3 do usrobj[i] = math.NormalizeAngle(usrobj[i]) end
    end
end

-- debug for testing garbage count
-- TODO: comment this out or something before actually going into main branch
local sw = false
local tries = {}
local totaltries = 1000
local sw_start = 0
local sw_orig = 0
concommand.Add("arccw_dev_stopwatch", function() tries = {} sw = true end)

local function stopwatch(name)
    if !sw then return end
    if name == true then
        local d = (collectgarbage("count") - sw_orig)
        if #tries == 0 then print("    total garbage: " .. d) end
        table.insert(tries, d)
        if #tries == totaltries then
            sw = false
            local average = 0
            for _, v in ipairs(tries) do average = average + v end
            average = average / totaltries
            print("----------------------------------")
            print("average over " .. totaltries .. " tries: " .. average)
        end
        return
    end
    local gb = collectgarbage("count")
    if name then
        if #tries == 0 then print(name .. ": " .. (gb - sw_start)) end
    else
        if #tries == 0 then print("----------------------------------") end
        sw_orig = gb
    end
    sw_start = gb
end

function SWEP:Move_Process(EyePos, EyeAng, velocity)
    local VMPos, VMAng = self.VMPos, self.VMAng
    local VMPosOffset, VMAngOffset = self.VMPosOffset, self.VMAngOffset
    local VMPosOffset_Lerp, VMAngOffset_Lerp = self.VMPosOffset_Lerp, self.VMAngOffset_Lerp
    local FT = scrunkly()
    local sightedmult = (self:GetState() == ArcCW.STATE_SIGHTS and 0.05) or 1
    local sg = self:GetSightDelta()
    VMPos:Set(EyePos)
    VMAng:Set(EyeAng)
    VMPosOffset.x = math.Clamp(velocity.z * 0.0025, -1, 1) * sightedmult
    VMPosOffset.x = VMPosOffset.x + (velocity.x * 0.001 * sg)
    VMPosOffset.y = math.Clamp(velocity.y * -0.002, -1, 1) * sightedmult
    VMPosOffset.z = math.Clamp(VMPosOffset.x * -2, -4, 4)
    VMPosOffset_Lerp.x = Lerp(8 * FT, VMPosOffset_Lerp.x, VMPosOffset.x)
    VMPosOffset_Lerp.y = Lerp(8 * FT, VMPosOffset_Lerp.y, VMPosOffset.y)
    VMPosOffset_Lerp.z = Lerp(8 * FT, VMPosOffset_Lerp.z, VMPosOffset.z)
    --VMAngOffset.x = math.Clamp(VMPosOffset.x * 8, -4, 4)
    VMAngOffset.y = VMPosOffset.y
    VMAngOffset.z = VMPosOffset.y * 0.5 + (VMPosOffset.x * -5) + (velocity.x * -0.005 * sg)
    VMAngOffset_Lerp.x = LerpC(10 * FT, VMAngOffset_Lerp.x, VMAngOffset.x, 0.75)
    VMAngOffset_Lerp.y = LerpC(5 * FT, VMAngOffset_Lerp.y, VMAngOffset.y, 0.6)
    VMAngOffset_Lerp.z = Lerp(25 * FT, VMAngOffset_Lerp.z, VMAngOffset.z)
    VMPos:Add(VMAng:Up() * VMPosOffset_Lerp.x)
    VMPos:Add(VMAng:Right() * VMPosOffset_Lerp.y)
    VMPos:Add(VMAng:Forward() * VMPosOffset_Lerp.z)
    VMAngOffset_Lerp:Normalize()
    VMAng:Add(VMAngOffset_Lerp)
end

local stepend = math.pi * 4

function SWEP:Step_Process(EyePos, EyeAng, velocity)

    local VMPos, VMAng = self.VMPos, self.VMAng
    local VMPosOffset, VMAngOffset = self.VMPosOffset, self.VMAngOffset
    local VMPosOffset_Lerp = self.VMPosOffset_Lerp
    local state = self:GetState()
    local sprd = self:GetSprintDelta()

    if state == ArcCW.STATE_SPRINT and self:SelectAnimation("idle_sprint") and !self:GetReloading() and !self:CanShootWhileSprint() then
        velocity = 0
    else
        velocity = math.min(velocity:Length(), 400) * Lerp(sprd, 1, 1.25)
    end

    local delta = math.abs(self.StepBob * 2 / stepend - 1)
    local FT = scrunkly() --FrameTime()
    local sightedmult = (state == ArcCW.STATE_SIGHTS and 0.25) or 1
    local sprintmult = (state == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() and 2) or 1
    local pronemult = (self:IsProne() and 10) or 1
    local onground = self:GetOwner():OnGround()
    self.StepBob = self.StepBob + (velocity * 0.00015 + (math.pow(delta, 0.01) * 0.03)) * swayspeed * FT * 300

    if self.StepBob >= stepend then
        self.StepBob = 0
        self.StepRandomX = math.Rand(1, 1.5)
        self.StepRandomY = math.Rand(1, 1.5)
    end

    if velocity == 0 then
        self.StepBob = 0
    end

    if onground then
        -- oh no it says sex tra
        local sextra = vector_origin
        if (state == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() and !self:SelectAnimation("idle_sprint")) or true then
            sextra = LerpVector(sprd, vector_origin, sextra_vec)
        end

        VMPosOffset.x = (math.sin(self.StepBob) * velocity * (0.000375 + sextra.x) * sightedmult * swayxmult) * self.StepRandomX
        VMPosOffset.y = (math.sin(self.StepBob * 0.5) * velocity * (0.0005 + sextra.y) * sightedmult * sprintmult * pronemult * swayymult) * self.StepRandomY
        VMPosOffset.z = math.sin(self.StepBob * 0.75) * velocity * (0.002 + sextra.z) * sightedmult * pronemult * swayzmult
    end

    VMPosOffset_Lerp.x = Lerp(32 * FT, VMPosOffset_Lerp.x, VMPosOffset.x)
    VMPosOffset_Lerp.y = Lerp(4 * FT, VMPosOffset_Lerp.y, VMPosOffset.y)
    VMPosOffset_Lerp.z = Lerp(2 * FT, VMPosOffset_Lerp.z, VMPosOffset.z)
    VMAngOffset.x = VMPosOffset_Lerp.x * 2
    VMAngOffset.y = VMPosOffset_Lerp.y * -7.5
    VMAngOffset.z = VMPosOffset_Lerp.y * 10
    VMPos:Add(VMAng:Up() * VMPosOffset_Lerp.x)
    VMPos:Add(VMAng:Right() * VMPosOffset_Lerp.y)
    VMPos:Add(VMAng:Forward() * VMPosOffset_Lerp.z)
    VMAng:Add(VMAngOffset)
end

function SWEP:Breath_Health()
    local owner = self:GetOwner()
    if !IsValid(owner) then return end
    local health = owner:Health()
    local maxhealth = owner:GetMaxHealth()
    self.Breath_Intensity = math.Clamp(maxhealth / health, 0, 2)
    self.Breath_Rate = math.Clamp((maxhealth * 0.5) / health, 1, 1.5)
end

function SWEP:Breath_StateMult()
    local owner = self:GetOwner()
    if !IsValid(owner) then return end
    local sightedmult = (self:GetState() == ArcCW.STATE_SIGHTS and 0.05) or 1
    self.Breath_Intensity = self.Breath_Intensity * sightedmult
end

function SWEP:Breath_Process(EyePos, EyeAng)
    local VMPos, VMAng = self.VMPos, self.VMAng
    local VMPosOffset, VMAngOffset = self.VMPosOffset, self.VMAngOffset
    -- self:Breath_Health() Snaps around when regenerating
    self:Breath_StateMult()
    VMPosOffset.x = (math.sin(CurTime() * 2 * self.Breath_Rate) * 0.1) * self.Breath_Intensity
    VMPosOffset.y = (math.sin(CurTime() * 2.5 * self.Breath_Rate) * 0.025) * self.Breath_Intensity
    VMAngOffset.x = VMPosOffset.x * 1.5
    VMAngOffset.y = VMPosOffset.y * 2
    VMAngOffset.z = VMPosOffset.y * VMPosOffset.x * -40
    VMPos:Add(VMAng:Up() * VMPosOffset.x)
    VMPos:Add(VMAng:Right() * VMPosOffset.y)
    VMAng:Add(VMAngOffset)
end

function SWEP:Look_Process(EyePos, EyeAng, velocity)
    local VMPos, VMAng = self.VMPos, self.VMAng
    local VMPosOffset, VMAngOffset = self.VMPosOffset, self.VMAngOffset
    local FT = scrunkly()
    local sightedmult = (self:GetState() == ArcCW.STATE_SIGHTS and 0.25) or 1
    self.SmoothEyeAng = LerpAngle(0.05, self.SmoothEyeAng, EyeAng - self.LastEyeAng)
    -- local xd, yd = (velocity.z / 10), (velocity.y / 200)
    VMPosOffset.x = -self.SmoothEyeAng.x * -0.5 * sightedmult * lookxmult
    VMPosOffset.y = self.SmoothEyeAng.y * 0.5 * sightedmult * lookymult
    VMAngOffset.x = VMPosOffset.x * 0.75
    VMAngOffset.y = VMPosOffset.y * 2.5
    VMAngOffset.z = VMPosOffset.x * 2 + VMPosOffset.y * -2
    self.VMLookLerp.y = Lerp(FT * 10, self.VMLookLerp.y, VMAngOffset.y * -1.5 + self.SmoothEyeAng.y)
    VMAng.y = VMAng.y - self.VMLookLerp.y
    VMPos:Add(VMAng:Up() * VMPosOffset.x)
    VMPos:Add(VMAng:Right() * VMPosOffset.y)
    VMAng:Add(VMAngOffset)
end

function SWEP:GetVMPosition(EyePos, EyeAng)
    local velocity = self:GetOwner():GetVelocity()
    velocity = WorldToLocal(velocity, angle_zero, vector_origin, EyeAng)
    self:Move_Process(EyePos, EyeAng, velocity)
    stopwatch("Move_Process")
    self:Step_Process(EyePos, EyeAng, velocity)
    stopwatch("Step_Process")
    self:Breath_Process(EyePos, EyeAng)
    stopwatch("Breath_Process")
    self:Look_Process(EyePos, EyeAng, velocity)
    stopwatch("Look_Process")
    self.LastEyeAng = EyeAng
    self.LastEyePos = EyePos
    self.LastVelocity = velocity

    return self.VMPos, self.VMAng
end

SWEP.TheJ = {posa = Vector(), anga = Angle()}
local rap_pos = Vector()
local rap_ang = Angle()

local actual
local target = {pos = Vector(), ang = Angle()}

local GunDriverFix = Angle( 0, 90, 90 )

function SWEP:GetViewModelPosition(pos, ang)
    if ArcCW.ConVars["dev_benchgun"]:GetBool() then
        if ArcCW.ConVars["dev_benchgun_custom"]:GetString() then
            local bgc = ArcCW.ConVars["dev_benchgun_custom"]:GetString()
            if string.Left(bgc, 6) != "setpos" then return vector_origin, angle_zero end

            bgc = string.TrimLeft(bgc, "setpos ")
            bgc = string.Replace(bgc, ";setang", "")
            bgc = string.Explode(" ", bgc)

            return Vector(bgc[1], bgc[2], bgc[3]), Angle(bgc[4], bgc[5], bgc[6])
        else
            return vector_origin, angle_zero
        end
    end

    stopwatch()

    local owner = self:GetOwner()
    if !IsValid(owner) or !owner:Alive() then return end
    local FT = scrunkly()
    local CT = CurTime()
    local TargetTick = (1 / FT) / 66.66
    local cdelta = math.Clamp(math.ease.InOutSine((owner:GetViewOffset().z - owner:GetCurrentViewOffset().z) / (owner:GetViewOffset().z - owner:GetViewOffsetDucked().z)),0,1)

    if TargetTick < 1 then
        FT = FT * TargetTick
    end

    local vm = LocalPlayer():GetViewModel()

    local asight = self:GetActiveSights()
    local state = self:GetState()
    local sgtd = self:GetSightDelta()
    local sprd = self:GetSprintDelta()

    local sprinted = self.Sprinted or state == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint()
    local sighted = self.Sighted or state == ArcCW.STATE_SIGHTS
    local holstered = self:GetCurrentFiremode().Mode == 0

    if game.SinglePlayer() then
        sprinted = state == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint()
        sighted = state == ArcCW.STATE_SIGHTS
    end

    local oldpos, oldang = Vector(), Angle()
    oldpos:Set(pos)
    oldang:Set(ang)
    ang:Sub(self:GetOurViewPunchAngles())

    actual = self.ActualVMData or {
        pos = Vector(),
        ang = Angle(),
        down = 1,
        sway = 1,
        bob = 1,
        evpos = Vector(),
        evang = Angle(),
    }

    local apos, aang = self:GetBuff_Override("Override_ActivePos", self.ActivePos), self:GetBuff_Override("Override_ActiveAng", self.ActiveAng)
    local cpos, cang = self:GetBuff("CrouchPos", true) or apos, self:GetBuff("CrouchAng", true) or aang
    target.down = 1
    target.sway = 2
    target.bob = 2

    stopwatch("set")

    if self:InBipod() and self:GetBipodAngle() then
        local bpos = self:GetBuff_Override("Override_InBipodPos", self.InBipodPos)
        target.pos:Set(asight and asight.Pos or apos)
        target.ang:Set(asight and asight.Ang or aang)

        local BEA = (self.BipodStartAngle or self:GetBipodAngle()) - owner:EyeAngles()
        target.pos:Add(BEA:Right() * bpos.x * self.InBipodMult.x)
        target.pos:Add(BEA:Forward() * bpos.y * self.InBipodMult.y)
        target.pos:Add(BEA:Up() * bpos.z * self.InBipodMult.z)
        target.sway = 0.2
    -- elseif (owner:Crouching() or owner:KeyDown(IN_DUCK)) and !self:GetReloading() then
        -- target.pos:Set(self:GetBuff("CrouchPos", true) or apos)
        -- target.ang:Set(self:GetBuff("CrouchAng", true) or aang)
    elseif self:GetReloading() then
        target.pos:Set(self:GetBuff("ReloadPos", true) or apos)
        target.ang:Set(self:GetBuff("ReloadAng", true) or aang)
    else
        target.pos:Set(apos)
        target.ang:Set(aang)
        LerpMod(target.pos, cpos, cdelta)
        LerpMod(target.ang, cang, cdelta, true)
    end
    if (owner:Crouching() or owner:KeyDown(IN_DUCK)) then target.down = 0 end

    stopwatch("reload, crouch, bipod")

    target.pos.x = target.pos.x + ArcCW.ConVars["vm_right"]:GetFloat()
    target.pos.y = target.pos.y + ArcCW.ConVars["vm_forward"]:GetFloat()
    target.pos.z = target.pos.z + ArcCW.ConVars["vm_up"]:GetFloat()

    target.ang.p = target.ang.p + ArcCW.ConVars["vm_pitch"]:GetFloat()
    target.ang.y = target.ang.y + ArcCW.ConVars["vm_yaw"]:GetFloat()
    target.ang.r = target.ang.r + ArcCW.ConVars["vm_roll"]:GetFloat()

    if state == ArcCW.STATE_CUSTOMIZE then
        target.down = 1
        target.sway = 3
        target.bob = 1
        local mx, my = input.GetCursorPos()
        mx = 2 * mx / ScrW()
        my = 2 * my / ScrH()
        target.pos:Set(self:GetBuff_Override("Override_CustomizePos", self.CustomizePos))
        target.ang:Set(self:GetBuff_Override("Override_CustomizeAng", self.CustomizeAng))
        target.pos.x = target.pos.x + mx
        target.pos.z = target.pos.z + my
        target.ang.y = target.ang.y + my * 2
        target.ang.r = target.ang.r + mx * 2
        if self.InAttMenu then
            target.ang.y = target.ang.y - 5
        end
    end

    stopwatch("cust")

    -- Sprinting
    local hpos, spos = self:GetBuff("HolsterPos", true), self:GetBuff("SprintPos", true)
    local hang, sang = self:GetBuff("HolsterAng", true), self:GetBuff("SprintAng", true)
    do
        local aaaapos = holstered and (hpos or spos) or (spos or hpos)
        local aaaaang = holstered and (hang or sang) or (sang or hang)

        local sd = (self:GetReloading() and 0) or (self:IsProne() and math.Clamp(owner:GetVelocity():Length() / prone.Config.MoveSpeed, 0, 1)) or (holstered and 1) or (!self:CanShootWhileSprint() and sprd) or 0
        sd = math.pow(math.sin(sd * math.pi * 0.5), 2)

        local d = math.pow(math.sin(sd * math.pi * 0.5), math.pi)
        local coolilove = d * math.cos(d * math.pi * 0.5)

        local joffset, jaffset
        if !sprinted then
            joffset = sprint_vec2
            jaffset = spring_ang2
        else
            joffset = sprint_vec1
            jaffset = sprint_ang1
        end

        LerpMod(target.pos, aaaapos, sd)
        LerpMod(target.ang, aaaaang, sd, true)
        for i = 1, 3 do
            target.pos[i] = target.pos[i] + joffset[i] * coolilove
            target.ang[i] = target.ang[i] + jaffset[i] * coolilove
        end

        local fu_sprint = (sprinted and self:SelectAnimation("idle_sprint"))

        target.sway = target.sway * f_lerp(sd, 1, fu_sprint and 0 or 2)
        target.bob = target.bob * f_lerp(sd, 1, fu_sprint and 0 or 2)
    end

    stopwatch("sprint")

    -- Sighting
    if asight then
        local delta = sgtd
        delta = math.pow(math.sin(delta * math.pi * 0.5), math.pi)
        local im = asight.Midpoint
        local coolilove = delta * math.cos(delta * math.pi * 0.5)

        local joffset, jaffset
        if !sighted then
            joffset = sight_vec2
            jaffset = sight_ang2
        else
            joffset = (im and im.Pos or sight_vec1)
            jaffset = (im and im.Ang or sight_ang1)
        end

        target.pos.z = target.pos.z - 1
        LerpMod2(asight.Pos, target.pos, delta)
        LerpMod2(asight.Ang, target.ang, delta)
        for i = 1, 3 do
            target.pos[i] = target.pos[i] + joffset[i] * coolilove
            target.ang[i] = target.ang[i] + jaffset[i] * coolilove
        end

        target.evpos = f_lerp(delta, asight.EVPos or vector_origin, vector_origin)
        target.evang = f_lerp(delta, asight.EVAng or angle_zero, angle_zero)

        target.down = 0
        target.sway = target.sway * f_lerp(delta, 0.1, 1)
        target.bob = target.bob * f_lerp(delta, 0.1, 1)
    end

    stopwatch("sight")

    local deg = self:GetBarrelNearWall()
    if deg > 0 and ArcCW.ConVars["vm_nearwall"]:GetBool() then
        LerpMod(target.pos, hpos, deg)
        LerpMod(target.ang, hang, deg)
        target.down = 2 * math.max(sgtd, 0.5)
    end

    if !isangle(target.ang) then
        target.ang = Angle(target.ang)
    end

    target.ang.y = target.ang.y + (self:GetFreeAimOffset().y * 0.5)
    target.ang.p = target.ang.p - (self:GetFreeAimOffset().p * 0.5)

    if self.InProcDraw then
        self.InProcHolster = false
        local delta = m_clamp((CT - self.ProcDrawTime) / (0.5 * self:GetBuff_Mult("Mult_DrawTime")), 0, 1)
        target.pos = LerpVector(delta, procdraw_vec, target.pos)
        target.ang = LerpAngle(delta, procdraw_ang, target.ang)
        target.down = target.down
        target.sway = target.sway
        target.bob = target.bob
    end

    if self.InProcHolster then
        self.InProcDraw = false
        local delta = 1 - m_clamp((CT - self.ProcHolsterTime) / (0.25 * self:GetBuff_Mult("Mult_DrawTime")), 0, 1)
        target.pos = LerpVector(delta, procdraw_vec, target.pos)
        target.ang = LerpAngle(delta, prochol_ang, target.ang)
        target.down = target.down
        target.sway = target.sway
        target.bob = target.bob
    end

    if self.InProcBash then
        self.InProcDraw = false
        local mult = self:GetBuff_Mult("Mult_MeleeTime")
        local mtime = self.MeleeTime * mult
        local delta = 1 - m_clamp((CT - self.ProcBashTime) / mtime, 0, 1)

        local bp, ba

        if delta > 0.3 then
            bp = self:GetBuff_Override("Override_BashPreparePos", self.BashPreparePos)
            ba = self:GetBuff_Override("Override_BashPrepareAng", self.BashPrepareAng)
            delta = (delta - 0.5) * 2
        else
            bp = self:GetBuff_Override("Override_BashPos", self.BashPos)
            ba = self:GetBuff_Override("Override_BashAng", self.BashAng)
            delta = delta * 2
        end

        LerpMod2(bp, target.pos, delta)
        LerpMod2(ba, target.ang, delta)

        target.speed = 10

        if delta == 0 then
            self.InProcBash = false
        end
    end

    stopwatch("proc")

    -- local gunbone, gbslot = self:GetBuff_Override("LHIK_GunDriver")
    -- if gunbone and IsValid(self.Attachments[gbslot].VElement.Model) and self.LHIKGunPos and self.LHIKGunAng then
    --     local magnitude = 1 --Lerp(sgtd, 0.1, 1)
    --     local lhik_model = self.Attachments[gbslot].VElement.Model
    --     local att = lhik_model:GetAttachment(lhik_model:LookupAttachment(gunbone))
    --     local attang = att.Ang
    --     local attpos = att.Pos
    --     attang = lhik_model:WorldToLocalAngles(attang)
    --     attpos = lhik_model:WorldToLocal(attpos)
    --     attang:Sub(self.LHIKGunAng)
    --     attpos:Sub(self.LHIKGunPos)
    --     attang:Mul(magnitude)
    --     attpos:Mul(magnitude)
    --     --target.ang:Add(attang)
    --     --target.pos:Add(attpos)
    --     --debugoverlay.Axis(lhik_model:GetPos() + attpos, att.Ang, 8, FrameTime() * 3, true)
    --     debugoverlay.Axis(lhik_model:GetPos(), att.Ang, 8, FrameTime() * 3, true)
    -- end

    -- stopwatch("gunbone")

    local vmhit = self.ViewModel_Hit
    if vmhit then
        if !vmhit:IsZero() then
            target.pos.x = target.pos.x + m_clamp(vmhit.y, -1, 1) * 0.25
            target.pos.y = target.pos.y + vmhit.y
            target.pos.z = target.pos.z + m_clamp(vmhit.x, -1, 1) * 1
            target.ang.x = target.ang.x + m_clamp(vmhit.x, -1, 1) * 5
            target.ang.y = target.ang.y + m_clamp(vmhit.y, -1, 1) * -2
            target.ang.z = target.ang.z + m_clamp(vmhit.z, -1, 1) * 12.5
        end

        local spd = vmhit:Length() * 5
        vmhit.x = m_appor(vmhit.x, 0, FT * spd)
        vmhit.y = m_appor(vmhit.y, 0, FT * spd)
        vmhit.z = m_appor(vmhit.z, 0, FT * spd)
    end

    if ArcCW.ConVars["shakevm"]:GetBool() and !engine.IsRecordingDemo() then
        target.pos:Add(VectorRand() * self.RecoilAmount * 0.2 * self.RecoilVMShake)
    end

    stopwatch("vmhit")

    local speed = 15 * FT * (game.SinglePlayer() and 1 or 2)

    LerpMod(actual.pos, target.pos, speed)
    LerpMod(actual.ang, target.ang, speed, true)
    LerpMod(actual.evpos, target.evpos or vector_origin, speed)
    LerpMod(actual.evang, target.evang or angle_zero, speed, true)
    actual.down = f_lerp(speed, actual.down, target.down)
    actual.sway = f_lerp(speed, actual.sway, target.sway)
    actual.bob = f_lerp(speed, actual.bob, target.bob)

    ApproachMod(actual.pos, target.pos, speed * 0.1)
    ApproachMod(actual.ang, target.ang, speed * 0.1)
    actual.down = m_appor(actual.down, target.down, speed * 0.1)

    stopwatch("actual -> target")

    local coolsway = ArcCW.ConVars["vm_coolsway"]:GetBool()
    self.SwayScale = (coolsway and 0) or actual.sway
    self.BobScale = (coolsway and 0) or actual.bob

    if coolsway then
        swayxmult = ArcCW.ConVars["vm_sway_zmult"]:GetFloat() or 1
        swayymult = ArcCW.ConVars["vm_sway_xmult"]:GetFloat() or 1
        swayzmult = ArcCW.ConVars["vm_sway_ymult"]:GetFloat() or 1
        swayspeed = ArcCW.ConVars["vm_sway_speedmult"]:GetFloat() or 1
        lookxmult = ArcCW.ConVars["vm_look_xmult"]:GetFloat() or 1
        lookymult = ArcCW.ConVars["vm_look_ymult"]:GetFloat() or 1

        local sd = self:GetSightDelta()
        lookxmult = Lerp(sd, 0, lookxmult)
        lookymult = Lerp(sd, 0, lookymult)
        swayxmult = Lerp(sd, 0, swayxmult)
        swayymult = Lerp(sd, 0, swayymult)
        swayzmult = Lerp(sd, 0, swayzmult)
        swayspeed = Lerp(sd, 0, swayspeed)

        stopwatch("before vmposition")
        local npos, nang = self:GetVMPosition(oldpos, oldang)
        pos:Set(npos)
        ang:Set(nang)
    end

    local old_r, old_f, old_u = oldang:Right(), oldang:Forward(), oldang:Up()
    pos:Add(math.min(self.RecoilPunchBack, Lerp(sgtd, self.RecoilPunchBackMaxSights or 1, self.RecoilPunchBackMax)) * -old_f)

    ang:RotateAroundAxis(old_r, actual.ang.x)
    ang:RotateAroundAxis(old_u, actual.ang.y)
    ang:RotateAroundAxis(old_f, actual.ang.z)
    ang:RotateAroundAxis(old_r, actual.evang.x)
    ang:RotateAroundAxis(old_u, actual.evang.y)
    ang:RotateAroundAxis(old_f, actual.evang.z)

    local new_r, new_f, new_u = ang:Right(), ang:Forward(), ang:Up()
    old_r:Mul(actual.evpos.x)
    old_f:Mul(actual.evpos.y)
    old_u:Mul(actual.evpos.z)
    pos:Add(old_r)
    pos:Add(old_f)
    pos:Add(old_u)
    new_r:Mul(actual.pos.x)
    new_f:Mul(actual.pos.y)
    new_u:Mul(actual.pos.z)
    pos:Add(new_r)
    pos:Add(new_f)
    pos:Add(new_u)

    pos.z = pos.z - actual.down

    ang:Add(self:GetOurViewPunchAngles() * Lerp(sgtd, 1, -1))

    local gunbone, gbslot = self:GetBuff_Override("LHIK_GunDriver")
    local lhik_model = gbslot and self.Attachments[gbslot].VElement and self.Attachments[gbslot].VElement.Model -- Visual M203 attachment
    local lhik_anim_model = gbslot and self.Attachments[gbslot].GodDriver and self.Attachments[gbslot].GodDriver.Model -- M203 anim and camera
    local lhik_refl_model = gbslot and self.Attachments[gbslot].ReflectDriver and self.Attachments[gbslot].ReflectDriver.Model -- Rifle
    if IsValid(lhik_model) and IsValid(lhik_anim_model) and IsValid(lhik_refl_model) and lhik_anim_model:GetAttachment(lhik_anim_model:LookupAttachment(gunbone)) then
        local att = lhik_anim_model:LookupAttachment(gunbone)
        local offset = lhik_anim_model:GetAttachment(att).Pos
        local affset = lhik_anim_model:GetAttachment(att).Ang

        affset:Sub( GunDriverFix )
        local r = affset.r
        affset.r = affset.p
        affset.p = -r
        affset.y = -affset.y

        local anchor = self.Attachments[gbslot].VMOffsetPos

        local looku = lhik_refl_model:LookupBone( self.Attachments[gbslot].Bone )
        local bonp, bona = lhik_refl_model:GetBonePosition( looku )
        if bonp == lhik_refl_model:GetPos() then
            bonp = lhik_refl_model:GetBoneMatrix( looku ):GetTranslation()
            bona = lhik_refl_model:GetBoneMatrix( looku ):GetAngles()
        end

        if anchor and bonp then -- Not ready / deploying
            anchor = ( bonp + ( (bona:Forward()*anchor.x) + (bona:Right()*anchor.y) + (bona:Up()*anchor.z) ) )

            debugoverlay.Axis(anchor, angle_zero, 4, FrameTime(), true)

            rap_pos, rap_ang = ArcCW.RotateAroundPoint2(pos, ang, anchor, offset, affset)
            rap_pos:Sub(pos)
            rap_ang:Sub(ang)

            pos:Add(rap_pos)
            ang:Add(rap_ang)
        end
    end

    self.ActualVMData = actual

    stopwatch("apply actual")

    stopwatch(true)

    lst = SysTime()
    return pos, ang
end

function SWEP:ShouldCheapWorldModel()
    local lp = LocalPlayer()
    if lp:GetObserverMode() == OBS_MODE_IN_EYE and lp:GetObserverTarget() == self:GetOwner() then return true end
    if !IsValid(self:GetOwner()) and !ArcCW.ConVars["att_showground"]:GetBool() then return true end

    return !ArcCW.ConVars["att_showothers"]:GetBool()
end

local bird = Material("arccw/hud/arccw_bird.png", "mips smooth")
local iw = 32

function SWEP:DrawWorldModel()
    local cvar2d3d = ArcCW.ConVars["2d3d"]:GetInt()
    if !IsValid(self:GetOwner()) and !TTT2
            and (cvar2d3d == 2 or (cvar2d3d == 1 and LocalPlayer():GetEyeTrace().Entity == self))
            and (EyePos() - self:WorldSpaceCenter()):LengthSqr() <= 262144 then -- 512^2
        local ang = LocalPlayer():EyeAngles()
        ang:RotateAroundAxis(ang:Forward(), 180)
        ang:RotateAroundAxis(ang:Right(), 90)
        ang:RotateAroundAxis(ang:Up(), 90)
        cam.Start3D2D(self:WorldSpaceCenter() + Vector(0, 0, 16), ang, 0.1)

        srf.SetFont("ArcCW_32_Unscaled")
        local w = srf.GetTextSize(self.PrintName)
        srf.SetTextPos(-w / 2 + 2, 2)
        srf.SetTextColor(0, 0, 0, 150)
        srf.DrawText(self.PrintName)
        srf.SetTextPos(-w / 2, 0)
        srf.SetTextColor(255, 255, 255, 255)
        srf.DrawText(self.PrintName)

        local icons = {}
        for i, slot in pairs(self.Attachments or {}) do
            if slot.Installed then
                local atttbl = ArcCW.AttachmentTable[slot.Installed]
                if !atttbl then continue end
                local icon = atttbl.Icon
                if !icon or icon:IsError() then icon = bird end
                table.insert(icons, icon)
            end
        end

        local ind = math.min(6, #icons)

        surface.SetDrawColor(255, 255, 255)
        for i = 1, ind do
            if i == 6 and #icons > 6 then
                local str = "+" .. (#icons - ind)
                local strw = srf.GetTextSize(str)
                srf.SetTextPos(-ind * iw / 2 + (i - 1) * iw + 2 + strw / 2, iw + 14)
                srf.SetTextColor(0, 0, 0, 150)
                srf.DrawText(str)
                srf.SetTextPos(-ind * iw / 2 + (i - 1) * iw + strw / 2, iw + 12)
                srf.SetTextColor(255, 255, 255, 255)
                srf.DrawText(str)
            else
                local icon = icons[i]
                surface.SetMaterial(icon)
                surface.DrawTexturedRect(-ind * iw / 2 + (i - 1) * iw, iw + 12, iw, iw)
            end
        end

        -- srf.SetFont("ArcCW_24_Unscaled")
        -- local count = self:CountAttachments()

        -- if count > 0 then
        --     local t = tostring(count) .. " Attachments"
        --     w = srf.GetTextSize(t)
        --     srf.SetTextPos(-w / 2, 32)
        --     srf.SetTextColor(255, 255, 255, 255)
        --     srf.DrawText(t)
        -- end

        cam.End3D2D()
    end

    self:DrawCustomModel(true)
    self:DoLaser(true)

    if self:ShouldGlint() then
        self:DoScopeGlint()
    end

    if !self.CertainAboutAtts and !self.AttReqSent and !IsValid(self:GetOwner()) then
        self.AttReqSent = true
        -- print(self, "network weapon from cl_viewmodel")
        -- debugoverlay.Cross(self:GetPos(), 8, 10, color_white, true)
        -- debugoverlay.EntityTextAtPosition(self:GetPos(), 1, tostring(self) .. " requesting networking data", 10, color_white)
        net.Start("arccw_rqwpnnet")
            net.WriteEntity(self)
        net.SendToServer()
    end
end

function SWEP:ShouldCheapScope()
    if !ArcCW.ConVars["cheapscopes"]:GetBool() then return end
end

local POSTVMDONE = nil
local POSTVMDONE_TIME = 0

local lst2 = SysTime()
function SWEP:PreDrawViewModel(vm)
    if ArcCW.VM_OverDraw then return end
    if !vm then return end

    if self:GetState() == ArcCW.STATE_CUSTOMIZE then
        self:BlurNotWeapon()
    end

    if ArcCW.ConVars["cheapscopesautoconfig"]:GetBool() then
        local fps = 1 / (SysTime() - lst2)
        lst2 = SysTime()
        local lowfps = fps <= 45
        ArcCW.ConVars["cheapscopes"]:SetBool(lowfps)
        ArcCW.ConVars["cheapscopesautoconfig"]:SetBool(false)
    end

    local asight = self:GetActiveSights()

    if asight and ((ArcCW.ConVars["cheapscopes"]:GetBool() and self:GetSightDelta() < 1 and asight.MagnifiedOptic)
            or (self:GetSightDelta() < 1 and asight.ScopeTexture)) then
        -- Necessary to call here since physbullets are not drawn until PreDrawEffects; cheap scope implementation will not allow them to be visible
        -- Introduces a bug when we try to call GetAttachment on the viewmodel in DrawPhysBullets here, so set a workaround variable to not call it
        ArcCW:DrawPhysBullets(true)
        self:FormCheapScope()
    end

    local coolFOV = self.CurrentViewModelFOV or self.ViewModelFOV

    if ArcCW.VMInRT then
        local mag = asight.ScopeMagnification
        coolFOV = self.ViewModelFOV - mag * 4 - (ArcCW.ConVars["vm_add_ads"]:GetFloat() * 3 or 0)
        ArcCW.VMInRT = false
    end

    cam.Start3D(EyePos(), EyeAngles(), self:QuickFOVix(coolFOV), nil, nil, nil, nil, 0.5, 1000)
    cam.IgnoreZ(true)
    self:DrawCustomModel(false)
    self:DoLHIK()

    if !ArcCW.Overdraw then
        self:DoLaser(false, true)
    end

    -- patrol
    if POSTVMDONE == false and POSTVMDONE_TIME <= CurTime() then
        POSTVMDONE_TIME = CurTime() + 1
        print( "[ArcCW] Warning: PostDrawViewModel failed response!! cam.End3D errors may be inbound!! You may have an addon conflict!!")
        print( "[ArcCW] Follow the troubleshooting guide at https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#camend3d-errors")
    end
    POSTVMDONE = false
end

function SWEP:PostDrawViewModel()
    POSTVMDONE = true
    if ArcCW.VM_OverDraw then return end
    render.SetBlend(1)
    cam.End3D()
    cam.Start3D(EyePos(), EyeAngles(), self:QuickFOVix(self.CurrentViewModelFOV or self.ViewModelFOV), nil, nil, nil, nil, 0.5, 1000)
    cam.IgnoreZ(true)

    if ArcCW.Overdraw then
        ArcCW.Overdraw = false
    else
        --self:DoLaser()
        self:DoHolosight()
    end

    cam.End3D()
end

--PATH lua/weapons/arccw_base/sh_attach.lua:
-- Used to prevent stack overflow. Set false here so luarefresh clears it
ArcCW.BuffStack = false

ArcCW.ConVar_BuffMults = {
    ["Mult_Damage"] = "arccw_mult_damage",
    ["Mult_DamageMin"] = "arccw_mult_damage",
    ["Mult_DamageNPC"] = "arccw_mult_npcdamage",
    ["Mult_HipDispersion"] = "arccw_mult_hipfire",
    ["Mult_ReloadTime"] = "arccw_mult_reloadtime",
    ["Mult_SightTime"] = "arccw_mult_sighttime",
    ["Mult_RPM"] = "arccw_mult_rpm",
    ["Mult_CycleTime"] = "arccw_mult_rpm",
    ["Mult_Range"] = "arccw_mult_range",
    ["Mult_Recoil"] = "arccw_mult_recoil",
    ["Mult_MoveDispersion"] = "arccw_mult_movedisp",
    ["Mult_AccuracyMOA"] = "arccw_mult_accuracy",
    ["Mult_Penetration"] = "arccw_mult_penetration",
    ["Mult_Sway"] = "arccw_mult_sway",
    ["Mult_MeleeDamage"] = "arccw_mult_meleedamage",
    ["Mult_MeleeTime"] = "arccw_mult_meleetime",
}

ArcCW.ConVar_BuffAdds = {
    ["Add_Sway"] = "arccw_add_sway",
}

ArcCW.ConVar_BuffOverrides = {
    ["Override_ShootWhileSprint"] = "arccw_mult_shootwhilesprinting"
}

SWEP.TickCache_Overrides = {}
SWEP.TickCache_Adds = {}
SWEP.TickCache_Mults = {}
SWEP.TickCache_Hooks = {}
SWEP.TickCache_IsShotgun = nil

SWEP.TickCache_Tick_Overrides = {}
SWEP.TickCache_Tick_Adds = {}
SWEP.TickCache_Tick_Mults = {}

SWEP.AttCache_Hooks = {}

-- debug: enable/disable modified caching
local MODIFIED_CACHE = true
-- print if a variable presumed to never change actually changes (this also happens right after attaching/detaching)
-- only works if MODIFIED_CACHE is false
local VERIFY_MODIFIED_CACHE = false

-- Conditions not listed are are presumed to never change; this is done for optimization purposes
SWEP.ModifiedCache = {}

function SWEP:RecalcAllBuffs()
    self.TickCache_Overrides = {}
    self.TickCache_Adds = {}
    self.TickCache_Mults = {}
    self.TickCache_Hooks = {}
    self.TickCache_IsShotgun = nil

    self.TickCache_Tick_Overrides = {}
    self.TickCache_Tick_Adds = {}
    self.TickCache_Tick_Mults = {}

    self.ReferencePosCache = {}

    self.AttCache_Hooks = {}

    self.NextMalfunction = nil

    -- for the customization page
    if CLIENT then
        self.Infos_Stats = nil
        self.Infos_Ballistics = nil
        self.Infos_Breakpoints = nil
    end

    -- this function is not always called right before AdjustAtts
    --self.ModifiedCache = {}
end

function SWEP:GetIsShotgun()
    if self.TickCache_IsShotgun == nil then
        local shotgun = self:GetBuff_Override("Override_IsShotgun")
        if shotgun != nil then
            self.TickCache_IsShotgun = shotgun
        end

        local num = self.Num
        if self.TickCache_IsShotgun == nil and num > 1 then self.TickCache_IsShotgun = true end
    end

    return self.TickCache_IsShotgun
end

function SWEP:GetIsManualAction()
    local manual = self:GetBuff_Override("Override_ManualAction")

    if manual != false then
        manual = manual or self.ManualAction
    end

    -- A manual action gun CAN have automatic firemode, this is intended behavior!!!
    -- It's used for slamfiring
    --[[]
    local mode = self:GetCurrentFiremode().Mode

    if mode != 0 and mode != 1 then
        return false
    end
    ]]

    return manual
end

-- ONE FUNCTION TO RULE THEM ALL
function SWEP:GetBuff(buff, defaultnil, defaultvar)
    local stable = self:GetTable()

    local result = stable[buff] or defaultvar
    if !result and defaultnil then
        result = nil
    elseif !result then
        result = 1
    end

    result = self:GetBuff_Override("Override_" .. buff, result)

    if isnumber(result) then
        result = self:GetBuff_Add("Add_" .. buff) + result
        result = self:GetBuff_Mult("Mult_" .. buff) * result
    end

    return result
end

function SWEP:GetBuff_Stat(buff, slot)
    local slottbl = self.Attachments[slot]
    if !slottbl then return end
    local atttbl = ArcCW.AttachmentTable[slottbl.Installed]
    if !atttbl then return end
    local num = slottbl.ToggleNum or 1

    if atttbl.ToggleStats and atttbl.ToggleStats[num] and (atttbl.ToggleStats[num][buff] != nil) then
        return atttbl.ToggleStats[num][buff]
    else
        return atttbl[buff]
    end
end

function SWEP:GetBuff_Hook(buff, data, defaultnil)
    -- call through hook function, args = data. return nil to do nothing. return false to prevent thing from happening.

    if !self.AttCache_Hooks[buff] then
        self.AttCache_Hooks[buff] = {}

        for i, k in pairs(self.Attachments) do
            if !k.Installed then continue end

            local atttbl = ArcCW.AttachmentTable[k.Installed]

            if !atttbl then continue end

            if isfunction(atttbl[buff]) then
                table.insert(self.AttCache_Hooks[buff], {atttbl[buff], atttbl[buff .. "_Priority"] or 0})
            elseif atttbl.ToggleStats and k.ToggleNum and atttbl.ToggleStats[k.ToggleNum] and isfunction(atttbl.ToggleStats[k.ToggleNum][buff]) then
                table.insert(self.AttCache_Hooks[buff], {atttbl.ToggleStats[k.ToggleNum][buff], atttbl.ToggleStats[k.ToggleNum][buff .. "_Priority"] or 0})
            end
        end

        local cfm = self:GetCurrentFiremode()

        if cfm and isfunction(cfm[buff]) then
            table.insert(self.AttCache_Hooks[buff], {cfm[buff], cfm[buff .. "_Priority"] or 0})
        end

        for i, e in pairs(self:GetActiveElements()) do
            local ele = self.AttachmentElements[e]

            if ele and ele[buff] then
                table.insert(self.AttCache_Hooks[buff], {ele[buff], ele[buff .. "_Priority"] or 0})
            end
        end

        if isfunction(self:GetTable()[buff]) then
            table.insert(self.AttCache_Hooks[buff], {self:GetTable()[buff], self:GetTable()[buff .. "_Priority"] or 0})
        end

        table.sort(self.AttCache_Hooks[buff], function(a, b) return a[2] >= b[2] end)shouldsort = true
    end

    local retvalue = nil
    for i, k in ipairs(self.AttCache_Hooks[buff]) do
        local ret = k[1](self, data)
        if ret == false then
            return
        elseif ret != nil then
            retvalue = ret
            break
        end
    end

    if retvalue then data = retvalue
    elseif defaultnil then data = nil end

    data = hook.Call(buff, nil, self, data) or data

    return data
end

function SWEP:GetBuff_Override(buff, default)

    local level = 0
    local current = nil
    local winningslot = nil

    if MODIFIED_CACHE and !self.ModifiedCache[buff] then
        -- ArcCW.ConVar_BuffOverrides[buff] isn't actually implemented??

        if !ArcCW.BuffStack then
            ArcCW.BuffStack = true
            local out = (self:GetBuff_Hook("O_Hook_" .. buff, {buff = buff}) or {})
            current = out.current or current
            winningslot = out.winningslot or winningslot
            ArcCW.BuffStack = false
        end

        return current or default, winningslot
    end

    if self.TickCache_Overrides[buff] then
        current = self.TickCache_Overrides[buff][1]
        winningslot = self.TickCache_Overrides[buff][2]

        local data = {
            buff = buff,
            current = current,
            winningslot = winningslot
        }

        if !ArcCW.BuffStack then

            ArcCW.BuffStack = true

            local out = (self:GetBuff_Hook("O_Hook_" .. buff, data) or {})

            current = out.current or current
            winningslot = out.winningslot or winningslot

            ArcCW.BuffStack = false

        end

        if current == nil then
            return default
        else
            return current, winningslot
        end
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if !atttbl then continue end

        if atttbl[buff] != nil then
            local pri = atttbl[buff .. "_Priority"] or 1
            if level == 0 or (pri > level) then
                current = atttbl[buff]
                level = pri
                winningslot = i
            end
        end

        if atttbl.ToggleStats and k.ToggleNum and atttbl.ToggleStats[k.ToggleNum] and atttbl.ToggleStats[k.ToggleNum][buff] then
            local pri = atttbl.ToggleStats[k.ToggleNum][buff .. "_Priority"] or 1
            if level == 0 or (pri > level) then
                current = atttbl.ToggleStats[k.ToggleNum][buff]
                level = pri
                winningslot = i
            end
        end
    end

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        local cfm = self:GetCurrentFiremode()

        if cfm and cfm[buff] != nil then
            local pri = cfm[buff .. "_Priority"] or 1
            if level == 0 or (pri > level) then
                current = cfm[buff]
                level = pri
            end
        end

        ArcCW.BuffStack = false

    end

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        for i, e in pairs(self:GetActiveElements()) do
            local ele = self.AttachmentElements[e]

            if ele and ele[buff] != nil then
                local pri = ele[buff .. "_Priority"] or 1
                if level == 0 or (pri > level) then
                    current = ele[buff]
                    level = pri
                    winningslot = i
                end
            end
        end

        ArcCW.BuffStack = false

    end

    if self:GetTable()[buff] != nil then
        local pri = self:GetTable()[buff .. "_Priority"] or 1
        if level == 0 or (pri > level) then
            current = self:GetTable()[buff]
            level = pri
        end
    end

    self.TickCache_Overrides[buff] = {current, winningslot}

    if VERIFY_MODIFIED_CACHE and !self.ModifiedCache[buff] and current != nil then
        print("ArcCW: Presumed non-changing buff '" .. buff .. "' is modified (" .. tostring(current) .. ")!")
    end

    local data = {
        buff = buff,
        current = current,
        winningslot = winningslot
    }

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        current = (self:GetBuff_Hook("O_Hook_" .. buff, data) or {}).current or current

        ArcCW.BuffStack = false

    end

    if current == nil then
        current = default
    end

    return current, winningslot
end

function SWEP:GetBuff_Mult(buff)

    local mult = 1

    if MODIFIED_CACHE and !self.ModifiedCache[buff] then
        if !ArcCW.BuffStack then
            ArcCW.BuffStack = true
            mult = (self:GetBuff_Hook("M_Hook_" .. buff, {buff = buff, mult = 1}) or {}).mult or mult
            ArcCW.BuffStack = false
        end
        if ArcCW.ConVar_BuffMults[buff] then
            if buff == "Mult_CycleTime" then
                mult = mult / GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
            else
                mult = mult * GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
            end
        end
        return mult
    end

    if self.TickCache_Mults[buff] then
        mult = self.TickCache_Mults[buff]
        local data = {
            buff = buff,
            mult = mult
        }

        if !ArcCW.BuffStack then

            ArcCW.BuffStack = true

            mult = (self:GetBuff_Hook("M_Hook_" .. buff, data) or {}).mult or mult

            ArcCW.BuffStack = false

        end

        if ArcCW.ConVar_BuffMults[buff] then
            if buff == "Mult_CycleTime" then
                mult = mult / GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
            else
                mult = mult * GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
            end
        end

        return mult
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl[buff] then
            mult = mult * atttbl[buff]
        end

        if atttbl.ToggleStats and k.ToggleNum and atttbl.ToggleStats[k.ToggleNum] and atttbl.ToggleStats[k.ToggleNum][buff] then
            mult = mult * atttbl.ToggleStats[k.ToggleNum][buff]
        end
    end

    local cfm = self:GetCurrentFiremode()

    if cfm and cfm[buff] then
        mult = mult * cfm[buff]
    end

    if self:GetTable()[buff] then
        mult = mult * self:GetTable()[buff]
    end

    for i, e in pairs(self:GetActiveElements()) do
        local ele = self.AttachmentElements[e]

        if ele and ele[buff] then
            mult = mult * ele[buff]
        end
    end

    self.TickCache_Mults[buff] = mult

    if VERIFY_MODIFIED_CACHE and !self.ModifiedCache[buff] and mult != 1 then
        print("ArcCW: Presumed non-changing buff '" .. buff .. "' is modified (" .. tostring(mult) .. ")!")
    end

    if ArcCW.ConVar_BuffMults[buff] then
        if buff == "Mult_CycleTime" then
            mult = mult / GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
        else
            mult = mult * GetConVar(ArcCW.ConVar_BuffMults[buff]):GetFloat()
        end
    end

    local data = {
        buff = buff,
        mult = mult
    }

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        mult = (self:GetBuff_Hook("M_Hook_" .. buff, data) or {}).mult or mult

        ArcCW.BuffStack = false

    end

    return mult
end

function SWEP:GetBuff_Add(buff)
    local add = 0

    if MODIFIED_CACHE and !self.ModifiedCache[buff] then
        if !ArcCW.BuffStack then
            ArcCW.BuffStack = true
            add = (self:GetBuff_Hook("A_Hook_" .. buff, {buff = buff, add = 0}) or {}).add or add
            ArcCW.BuffStack = false
        end
        if ArcCW.ConVar_BuffAdds[buff] then
            add = add + GetConVar(ArcCW.ConVar_BuffAdds[buff]):GetFloat()
        end
        return add
    end

    if self.TickCache_Adds[buff] then
        add = self.TickCache_Adds[buff]

        local data = {
            buff = buff,
            add = add
        }

        if !ArcCW.BuffStack then

            ArcCW.BuffStack = true

            add = (self:GetBuff_Hook("A_Hook_" .. buff, data) or {}).add or add

            ArcCW.BuffStack = false

        end

        if ArcCW.ConVar_BuffAdds[buff] then
            add = add + GetConVar(ArcCW.ConVar_BuffAdds[buff]):GetFloat()
        end

        return add
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl[buff] then
            add = add + atttbl[buff]
        end

        if atttbl.ToggleStats and k.ToggleNum and atttbl.ToggleStats[k.ToggleNum] and atttbl.ToggleStats[k.ToggleNum][buff] then
            add = add + atttbl.ToggleStats[k.ToggleNum][buff]
        end
    end

    local cfm = self:GetCurrentFiremode()

    if cfm and cfm[buff] then
        add = add + cfm[buff]
    end

    for i, e in pairs(self:GetActiveElements()) do
        local ele = self.AttachmentElements[e]

        if ele and ele[buff] then
            add = add + ele[buff]
        end
    end

    self.TickCache_Adds[buff] = add

    if VERIFY_MODIFIED_CACHE and !self.ModifiedCache[buff] and add != 0 then
        print("ArcCW: Presumed non-changing buff '" .. buff .. "' is modified (" .. tostring(add) .. ")!")
    end

    if ArcCW.ConVar_BuffAdds[buff] then
        add = add + GetConVar(ArcCW.ConVar_BuffAdds[buff]):GetFloat()
    end

    local data = {
        buff = buff,
        add = add
    }

    if !ArcCW.BuffStack then

        ArcCW.BuffStack = true

        add = (self:GetBuff_Hook("A_Hook_" .. buff, data) or {}).add or add

        ArcCW.BuffStack = false

    end

    return add
end

SWEP.ActiveElementCache = nil

function SWEP:GetActiveElements(recache)
    if self.ActiveElementCache and !recache then return self.ActiveElementCache end
    if ArcCW.Overflow and self.ActiveElementCache then return self.ActiveElementCache end

    local eles = {}

    for _, i in pairs(self.Attachments) do
        if !i.Installed then
            if i.DefaultEles then
                table.Add(eles, i.DefaultEles)
            end
            continue
        end

        if i.InstalledEles and i.Installed != i.EmptyFallback then
            table.Add(eles, i.InstalledEles)
        end

        local atttbl = ArcCW.AttachmentTable[i.Installed]

        if atttbl.ActivateElements then
            table.Add(eles, atttbl.ActivateElements)
        end

        local num = i.ToggleNum or 1
        if atttbl.ToggleStats and atttbl.ToggleStats[num] and (atttbl.ToggleStats[num]["ActivateElements"] != nil) then
            table.Add(eles, atttbl.ToggleStats[num]["ActivateElements"])
            --atttbl.ToggleStats[num][buff]
        end

        local slots = atttbl.Slot

        if isstring(slots) then
            slots = {slots}
        end

        table.Add(eles, slots or {})

        table.insert(eles, i.Installed)
    end

    table.Add(eles, self.DefaultElements)

    local mode = self:GetCurrentFiremode()
    table.Add(eles, (mode or {}).ActivateElements or {})

    local eles2 = {}

    ArcCW.Overflow = true

    for f, i in pairs(eles) do
        local e = self.AttachmentElements[i]

        if !e then continue end

        if !self:CheckFlags(e.ExcludeFlags, e.RequireFlags) then continue end

        local a = false
        local c = 0

        for g = f, table.Count(eles) do
            if eles[g] == i then c = c + 1 end
            if a then continue end

            if c > 1 then a = true end
        end

        if a then continue end

        table.insert(eles2, i)
    end

    table.Add(eles2, self:GetWeaponFlags())

    ArcCW.Overflow = false

    self.ActiveElementCache = eles2

    return eles2
end

function SWEP:GetMuzzleDevice(wm)
    local model = self.WM
    local muzz = self.WMModel or self

    if !wm then
        model = self.VM
        muzz = self:GetOwner():GetViewModel()
    end

    if model then
        for _, ele in pairs(model) do
            if ele.IsMuzzleDevice then
                muzz = ele.Model or muzz
            end
        end
    end

    if self:GetInUBGL() then
        local _, slot = self:GetBuff_Override("UBGL")

        if wm then
            muzz = (self.Attachments[slot].WMuzzleDeviceElement or {}).Model or muzz
        else
            muzz = (self.Attachments[slot].VMuzzleDeviceElement or {}).Model or muzz
        end
    end

    return muzz
end

function SWEP:GetTracerOrigin()
    local ow = self:GetOwner()
    local wm = nil
    local muzz = nil

    if !ow:IsNPC() and !ow:IsNextBot() and ow:IsValid() then
        wm = !ow:GetViewModel():IsValid() or ow:ShouldDrawLocalPlayer()
        muzz = self:GetMuzzleDevice(wm)
    end

    if muzz and muzz:IsValid() then
        local posang = muzz:GetAttachment(self:GetBuff_Override("Override_MuzzleEffectAttachment", self.MuzzleEffectAttachment) or 1)
        if !posang then return muzz:GetPos() end
        local pos = posang.Pos

        return pos
    end
end

function SWEP:CheckFlags(reject, need)
    local flags
    if ArcCW.Overflow then
        flags = self:GetWeaponFlags()
    else
        flags = self:GetActiveElements()
    end

    reject = reject or {}
    need = need or {}

    if !istable(reject) then reject = {reject} end
    if !istable(need) then need = {need} end

    for _, i in pairs(reject) do
        if table.HasValue(flags, i) then
            return false
        end
    end

    for _, i in pairs(need) do
        if !table.HasValue(flags, i) then
            return false
        end
    end

    return true
end

function SWEP:GetWeaponFlags()
    local flags = {}

    if self.DefaultFlags then table.Add(flags, self.DefaultFlags) end

    for id, i in pairs(self.Attachments) do
        if !i.Installed then
            if i.DefaultFlags then
                table.Add(flags, i.DefaultFlags)
            end
            continue
        end

        local buff = self:GetBuff_Stat("GivesFlags", id)
        if buff then
            table.Add(flags, buff)
        end

        if i.GivesFlags then
            table.Add(flags, i.GivesFlags)
        end

        local extras = {}
        self:GetBuff_Hook("Hook_ExtraFlags", extras)
        table.Add(flags, extras)

        table.Add(flags, {i.Installed})
    end

    return flags
end

function SWEP:PlayerOwnsAtt(att)
    local qty = ArcCW:PlayerGetAtts(self:GetOwner(), att)

    return qty > 0
end

function SWEP:NetworkWeapon(sendto)
    net.Start("arccw_networkatts")
    net.WriteEntity(self) -- self entity

    net.WriteUInt(table.Count(self.Attachments), 8)

    for _, i in pairs(self.Attachments) do
        if !i.Installed then net.WriteUInt(0, ArcCW.GetBitNecessity()) continue end

        local atttbl = ArcCW.AttachmentTable[i.Installed]
        local id = atttbl.ID

        net.WriteUInt(id, ArcCW.GetBitNecessity())

        if i.SlideAmount then
            net.WriteFloat(i.SlidePos or 0.5)
        end

        if atttbl.ToggleStats then
            net.WriteUInt(i.ToggleNum or 1, 8) -- look if you want more than 255 fucking toggle options you're insane and stupid just don't ok
        end

        -- if atttbl.ColorOptionsTable then
        --     net.WriteUInt(i.ColorOptionIndex or 1, 8) -- look if you want more than 256 fucking color options you're insane and stupid and just don't ok
        -- end
    end

    if sendto then
        net.Send(sendto)
    else
        -- net.SendPVS(self:GetPos())
        net.Broadcast()
    end
end

function SWEP:SendDetail_ColorIndex(slot)
    net.Start("arccw_colorindex")
    net.WriteUInt(slot, 8)
    net.WriteUInt(self.Attachments[slot].ColorOptionIndex)
    net.SendToServer()
end

function SWEP:SendDetail_SlidePos(slot, hmm)
    if !self.Attachments then return end
    if !self.Attachments[slot].SlidePos then return end

    net.Start("arccw_slidepos")
    net.WriteUInt(slot, 8)
    net.WriteFloat(self.Attachments[slot].SlidePos or 0.5)
    net.SendToServer()
end

function SWEP:SendDetail_ToggleNum(slot, hmm)
    if !self.Attachments or !self.Attachments[slot] then return end
    if !self.Attachments[slot].ToggleNum then return end

    net.Start("arccw_togglenum")
    net.WriteUInt(slot, 8)
    net.WriteUInt(self.Attachments[slot].ToggleNum or 1, 8)
    net.SendToServer()
end


function SWEP:SendAllDetails()
    for i, k in pairs(self.Attachments) do
        self:SendDetail_SlidePos(i, true)
        self:SendDetail_ToggleNum(i, true)
    end
end

function SWEP:CountAttachments()
    local total = 0

    for _, i in pairs(self.Attachments) do
        if i.Installed and !i.FreeSlot then
            local ins = ArcCW.AttachmentTable[i.Installed]
            if ins and !ins.IgnorePickX then
                total = total + 1
            end
        end
    end

    return total
end

function SWEP:SetBodygroupTr(ind, bg)
    self.Bodygroups[ind] = bg
end

function SWEP:RefreshBGs()
    local vm

    local vmm = self:GetBuff_Override("Override_VMMaterial") or self.VMMaterial or ""
    local wmm = self:GetBuff_Override("Override_WMMaterial") or self.WMMaterial or  ""

    local vmc = self:GetBuff_Override("Override_VMColor") or self.VMColor or Color(255, 255, 255)
    local wmc = self:GetBuff_Override("Override_WMColor") or self.WMColor or Color(255, 255, 255)

    local vms = self:GetBuff_Override("Override_VMSkin") or self.DefaultSkin
    local wms = self:GetBuff_Override("Override_WMSkin") or self.DefaultWMSkin

    local vmp = self.DefaultPoseParams
    local wmp = self.DefaultWMPoseParams

    if self.MirrorVMWM then
        wmm = vmm
        wmc = vmc
        wms = vms
        wmp = vmp
    end

    if self:GetOwner():IsPlayer() then
        vm = self:GetOwner():GetViewModel()
    end

    if vm and vm:IsValid() then
        ArcCW.SetBodyGroups(vm, self.DefaultBodygroups)
        vm:SetMaterial(vmm)
        vm:SetColor(vmc)
        vm:SetSkin(vms)

        vmp["BaseClass"] = nil

        for i, k in pairs(vmp) do
            vm:SetPoseParameter(i, k)
        end
    end

    self:SetMaterial(wmm)
    self:SetColor(wmc)
    self:SetSkin(wms)

    if self.WMModel and self.WMModel:IsValid() then
        ArcCW.SetBodyGroups(self.WMModel, self.MirrorVMWM and self.DefaultBodygroups or self.DefaultWMBodygroups)

        self.WMModel:SetMaterial(wmm)
        self.WMModel:SetColor(wmc)
        self.WMModel:SetSkin(wms)

        wmp["BaseClass"] = nil

        for i, k in pairs(wmp) do
            self.WMModel:SetPoseParameter(i, k)
        end
    end

    local ae = self:GetActiveElements()

    for _, e in pairs(ae) do
        local ele = self.AttachmentElements[e]

        if !ele then continue end

        if ele.VMPoseParams and vm and IsValid(vm) then
            ele.VMPoseParams["BaseClass"] = nil
            for i, k in pairs(ele.VMPoseParams) do
                vm:SetPoseParameter(i, k)
            end
        end

        if self.WMModel and self.WMModel:IsValid() then
            if self.MirrorVMWM and ele.VMPoseParams then
                ele.VMPoseParams["BaseClass"] = nil
                for i, k in pairs(ele.VMPoseParams) do
                    self.WMModel:SetPoseParameter(i, k)
                end
            end
            if ele.WMPoseParams then
                ele.WMPoseParams["BaseClass"] = nil
                for i, k in pairs(ele.WMPoseParams) do
                    self.WMModel:SetPoseParameter(i, k)
                end
            end
        end

        if ele.VMSkin and vm and IsValid(vm) then
            vm:SetSkin(ele.VMSkin)
        end

        if self.WMModel and self.WMModel:IsValid() then
            if self.MirrorVMWM and ele.VMSkin then
                self.WMModel:SetSkin(ele.VMSkin)
                self:SetSkin(ele.VMSkin)
            end
            if ele.WMSkin then
                self.WMModel:SetSkin(ele.WMSkin)
                self:SetSkin(ele.WMSkin)
            end
        end

        if ele.VMColor and vm and IsValid(vm) then
            vm:SetColor(ele.VMColor)
        end

        if self.WMModel and self.WMModel:IsValid() then
            if self.MirrorVMWM and ele.VMSkin then
                self.WMModel:SetColor(ele.VMColor or color_white)
                self:SetColor(ele.VMColor or color_white)
            end
            if ele.WMSkin then
                self.WMModel:SetColor(ele.WMColor or color_white)
                self:SetColor(ele.WMColor or color_white)
            end
        end

        if ele.VMMaterial and vm and IsValid(vm) then
            vm:SetMaterial(ele.VMMaterial)
        end

        if self.WMModel and self.WMModel:IsValid() then
            if self.MirrorVMWM and ele.VMMaterial then
                self.WMModel:SetMaterial(ele.VMMaterial)
                self:SetMaterial(ele.VMMaterial)
            end
            if ele.WMMaterial then
                self.WMModel:SetMaterial(ele.WMMaterial)
                self:SetMaterial(ele.WMMaterial)
            end
        end

        if ele.VMBodygroups then
            for _, i in pairs(ele.VMBodygroups) do
                if !i.ind or !i.bg then continue end

                if vm and IsValid(vm) and vm:GetBodygroup(i.ind) != i.bg then
                    vm:SetBodygroup(i.ind, i.bg)
                end
            end

            if self.MirrorVMWM then
                for _, i in pairs(ele.VMBodygroups) do
                    if !i.ind or !i.bg then continue end

                    if self.WMModel and IsValid(self.WMModel) and self.WMModel:GetBodygroup(i.ind) != i.bg then
                        self.WMModel:SetBodygroup(i.ind, i.bg)
                    end

                    if self:GetBodygroup(i.ind) != i.bg then
                        self:SetBodygroup(i.ind, i.bg)
                    end
                end
            end
        end

        if ele.WMBodygroups then
            for _, i in pairs(ele.WMBodygroups) do
                if !i.ind or !i.bg then continue end

                if self.WMModel and IsValid(self.WMModel) and self.WMModel:GetBodygroup(i.ind) != i.bg then
                    self.WMModel:SetBodygroup(i.ind, i.bg)
                end

                if self:GetBodygroup(i.ind) != i.bg then
                    self:SetBodygroup(i.ind, i.bg)
                end
            end
        end

        if ele.VMBoneMods then
            for bone, i in pairs(ele.VMBoneMods) do
                local boneind = vm:LookupBone(bone)

                if !boneind then continue end

                vm:ManipulateBonePosition(boneind, i)
            end

            if self.MirrorVMWM then
                for bone, i in pairs(ele.VMBoneMods) do
                    if !(self.WMModel and self.WMModel:IsValid()) then break end
                    local boneind = self:LookupBone(bone)

                    if !boneind then continue end

                    self:ManipulateBonePosition(boneind, i)
                end
            end
        end

        if ele.WMBoneMods then
            for bone, i in pairs(ele.WMBoneMods) do
                if !(self.WMModel and self.WMModel:IsValid()) then break end
                local boneind = self:LookupBone(bone)

                if !boneind then continue end

                self:ManipulateBonePosition(boneind, i)
            end
        end

        if SERVER then
            self:SetupShields()
        end
    end

    local tpmdl = IsValid(self.WMModel) and self.WMModel or self

    if IsValid(vm) then
        for i = 0, (vm:GetNumBodyGroups()) do
            if self.Bodygroups[i] then
                vm:SetBodygroup(i, self.Bodygroups[i])
            end
        end
        self:GetBuff_Hook("Hook_ModifyBodygroups", {vm = vm, eles = ae, wm = false})
    end

    for i = 0, (tpmdl:GetNumBodyGroups()) do
        if self.Bodygroups[i] then
            tpmdl:SetBodygroup(i, self.Bodygroups[i])
        end
    end
    self:GetBuff_Hook("Hook_ModifyBodygroups", {vm = tpmdl, eles = ae, wm = true})

    for slot, v in pairs(self.Attachments) do
        if !v.Installed then continue end

        local func = self:GetBuff_Stat("Hook_ModifyAttBodygroups", slot)
        if func and v.VElement and IsValid(v.VElement.Model) and IsValid(vm) then
            func(self, {vm = vm, element = v.VElement, slottbl = v, wm = false})
        end
        if func and v.WElement and IsValid(v.WElement.Model)  then
            func(self, {vm = tpmdl, element = v.WElement, slottbl = v, wm = true})
        end
    end
end

function SWEP:GetPickX()
    return ArcCW.ConVars["atts_pickx"]:GetInt()
end

function SWEP:Attach(slot, attname, silent, noadjust)
    silent = silent or false
    local attslot = self.Attachments[slot]
    if !attslot then return end
    if attslot.Installed == attname then return end
    if attslot.Internal then return end

    -- Make an additional check to see if we can detach the current attachment
    if attslot.Installed and !ArcCW:PlayerCanAttach(self:GetOwner(), self, attslot.Installed, slot, attname) then
        if CLIENT and !silent then
            surface.PlaySound("items/medshotno1.wav")
        end
        return
    end

    if !ArcCW:PlayerCanAttach(self:GetOwner(), self, attname, slot, false) then
        if CLIENT and !silent then
            surface.PlaySound("items/medshotno1.wav")
        end
        return
    end

    local pick = self:GetPickX()

    if pick > 0 and self:CountAttachments() >= pick and !attslot.FreeSlot
            and !attslot.Installed then
        if CLIENT and !silent then
            surface.PlaySound("items/medshotno1.wav")
        end
        return
    end

    local atttbl = ArcCW.AttachmentTable[attname]

    if !atttbl then return end
    if !ArcCW:SlotAcceptsAtt(attslot.Slot, self, attname) then return end
    if !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags) then return end
    if !self:PlayerOwnsAtt(attname) then return end

    local max = atttbl.Max

    if max then
        local amt = 0

        for i, k in pairs(self.Attachments) do
            if k.Installed == attname then amt = amt + 1 end
        end

        if amt >= max then return end
    end

    if attslot.SlideAmount then
        attslot.SlidePos = 0.5
    end

    if atttbl.MountPositionOverride then
        attslot.SlidePos = atttbl.MountPositionOverride
    end

    if atttbl.AdditionalSights then
        self.SightMagnifications = {}
    end

    if atttbl.ToggleStats then
        attslot.ToggleNum = 1
    end

    attslot.ToggleLock = atttbl.ToggleLockDefault or false

    if CLIENT then
        -- we are asking to attach something

        self:SendAllDetails()

        net.Start("arccw_asktoattach")
        net.WriteUInt(slot, 8)
        net.WriteUInt(atttbl.ID, 24)
        net.SendToServer()

        if !silent then
            surface.PlaySound(atttbl.AttachSound or "weapons/arccw/install.wav")
        end
    else
        self:DetachAllMergeSlots(slot)

        for i, k in pairs(self.Attachments) do
            if table.HasValue(k.MergeSlots or {}, slot) then
                self:DetachAllMergeSlots(i)
            end
        end
    end

    attslot.Installed = attname

    if atttbl.Health then
        attslot.HP = self:GetAttachmentMaxHP(slot)
    end

    if atttbl.ColorOptionsTable then
        attslot.ColorOptionIndex = 1
    end

    ArcCW:PlayerTakeAtt(self:GetOwner(), attname)

    --[[]
    local fmt = self:GetBuff_Override("Override_Firemodes") or self.Firemodes
    local fmi = self:GetFireMode()

    if fmi > table.Count(fmt) then
        self:SetFireMode(1)
    end
    ]]

    --self.UnReady = false

    if SERVER then
        self:NetworkWeapon()
        self:SetupModel(false)
        self:SetupModel(true)
        ArcCW:PlayerSendAttInv(self:GetOwner())

        if engine.ActiveGamemode() == "terrortown" then
            self:TTT_PostAttachments()
        end
    else
        self:SetupActiveSights()

        self.LHIKAnimation = 0
        self.LHIKAnimationStart = 0
        self.LHIKAnimationTime = 0

        self.LHIKDelta = {}
        self.LHIKDeltaAng = {}

        self.ViewModel_Hit = Vector(0, 0, 0)

        if !silent then
            self:SavePreset("autosave")
        end
    end

    for s, i in pairs(self.Attachments) do
        if !self:CheckFlags(i.ExcludeFlags, i.RequireFlags) then
            self:Detach(s, true, true)
        end
    end

    if !noadjust then
        self:AdjustAtts()
    end

    if atttbl.UBGL then
        local ubgl_ammo = self:GetBuff_Override("UBGL_Ammo")
        local ubgl_clip = self:GetBuff_Override("UBGL_Capacity")
        if self:GetOwner():IsPlayer() and ArcCW.ConVars["atts_ubglautoload"]:GetBool() and ubgl_ammo then
            local amt = math.min(ubgl_clip - self:Clip2(), self:GetOwner():GetAmmoCount(ubgl_ammo))
            self:SetClip2(self:Clip2() + amt)
            self:GetOwner():RemoveAmmo(amt, ubgl_ammo)
        end
    end

    self:RefreshBGs()
    return true
end

function SWEP:DetachAllMergeSlots(slot, silent)
    local slots = {slot}

    table.Add(slots, (self.Attachments[slot] or {}).MergeSlots or {})

    for _, i in pairs(slots) do
        self:Detach(i, silent, nil, true)
    end
end

function SWEP:Detach(slot, silent, noadjust, nocheck)
    if !slot then return end
    if !self.Attachments[slot] then return end

    if !self.Attachments[slot].Installed then return end

    if self.Attachments[slot].Internal then return end

    if !nocheck and !ArcCW:PlayerCanAttach(self:GetOwner(), self, self.Attachments[slot].Installed, slot, true) then
        if CLIENT and !silent then
            surface.PlaySound("items/medshotno1.wav")
        end
        return
    end

    if self.Attachments[slot].Installed == self.Attachments[slot].EmptyFallback then
        return
    end

    local previnstall = self.Attachments[slot].Installed

    local atttbl = ArcCW.AttachmentTable[previnstall]

    if atttbl.UBGL then
        local clip = self:Clip2()

        local ammo = atttbl.UBGL_Ammo or "smg1_grenade"

        if SERVER and IsValid(self:GetOwner()) then
            self:GetOwner():GiveAmmo(clip, ammo, true)
        end

        self:SetClip2(0)
        self:DeselectUBGL()
    end

    if self.Attachments[slot].EmptyFallback then -- is this a good name
        self.Attachments[slot].Installed = self.Attachments[slot].EmptyFallback
    else
        self.Attachments[slot].Installed = nil
    end

    if self.Attachments[slot].SubAtts then
        for i, k in pairs(self.Attachments[slot].SubAtts) do
            self:Detach(k, true, true)
        end
    end

    if self:GetAttachmentHP(slot) >= self:GetAttachmentMaxHP(slot) then
        ArcCW:PlayerGiveAtt(self:GetOwner(), previnstall)
    end

    if CLIENT then
        self:SendAllDetails()

        -- we are asking to detach something
        net.Start("arccw_asktodetach")
        net.WriteUInt(slot, 8)
        net.SendToServer()

        if !silent then
            surface.PlaySound(atttbl.DetachSound or "weapons/arccw/uninstall.wav")
        end

        self:SetupActiveSights()

        self.LHIKAnimation = 0
        self.LHIKAnimationStart = 0
        self.LHIKAnimationTime = 0

        if !silent then
            self:SavePreset("autosave")
        end
    else
        self:NetworkWeapon()
        self:SetupModel(false)
        self:SetupModel(true)
        ArcCW:PlayerSendAttInv(self:GetOwner())

        if engine.ActiveGamemode() == "terrortown" then
            self:TTT_PostAttachments()
        end
    end

    self:RefreshBGs()

    if !noadjust then
        self:AdjustAtts()
    end
    return true
end

function SWEP:ToggleSlot(slot, num, silent, back)
    local atttbl = ArcCW.AttachmentTable[self.Attachments[slot].Installed]
    if !atttbl.ToggleStats then return end

    local amt = 1

    if back then amt = -1 end

    if !num then
        self.Attachments[slot].ToggleNum = (self.Attachments[slot].ToggleNum or 1) + amt
        if self.Attachments[slot].ToggleNum > #atttbl.ToggleStats then
            self.Attachments[slot].ToggleNum = 1
        elseif self.Attachments[slot].ToggleNum < 1 then
            self.Attachments[slot].ToggleNum = #atttbl.ToggleStats
        end
    else
        self.Attachments[slot].ToggleNum = math.Clamp(num, 1, #catttbl.ToggleStats)
    end

    if CLIENT then
        self:SendDetail_ToggleNum(slot)
        self:SetupActiveSights()
    elseif SERVER then
        self:NetworkWeapon()
        self:SetupModel(false)
        self:SetupModel(true)
    end

    self:AdjustAtts()

    for s, i in pairs(self.Attachments) do
        if !self:CheckFlags(i.ExcludeFlags, i.RequireFlags) then
            self:Detach(s, true)
        end
    end

    self:RefreshBGs()

    if CLIENT and !silent and self:GetBuff_Stat("ToggleSound", slot) != false then
        surface.PlaySound(self:GetBuff_Stat("ToggleSound", slot) or (atttbl.ToggleStats[slot] or {}).ToggleSound or "weapons/arccw/firemode.wav")
    end
end

function SWEP:AdjustAmmo(old_inf)

    local new_inf = self:HasInfiniteAmmo()

    local wpn = weapons.Get(self:GetClass())
    local ammo = self:GetBuff_Override("Override_Ammo", wpn.Primary.Ammo)
    local oldammo = self.OldAmmo or self.Primary.Ammo

    if old_inf and (!new_inf or ammo != oldammo) then
        self:SetClip1(0)
    elseif (!old_inf and new_inf) or ammo != oldammo then
        self:Unload()
    end

    self.Primary.Ammo = ammo
    self.OldAmmo = self.Primary.Ammo
end

function SWEP:AdjustAtts()
    local old_inf = self:HasInfiniteAmmo()

    self:RecalcAllBuffs()

    -- Recalculate active elements so dependencies aren't fucked
    self.ActiveElementCache = nil
    self:GetActiveElements(true)
    self.ModifiedCache = {}

    -- Tempoarily disable modified cache, since we're building it right now
    MODIFIED_CACHE = false

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local ok = true

        if !ArcCW:SlotAcceptsAtt(k.Slot, self, k.Installed) then ok = false end
        if ok and !self:CheckFlags(k.ExcludeFlags, k.RequireFlags) then ok = false end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if !atttbl then continue end
        if ok and !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags) then ok = false end

        if !ok then
            self:Detach(i, true)
            continue
        end

        -- Cache all possible value modifiers
        for var, v in pairs(atttbl) do
            self.ModifiedCache[var] = true
            if var == "ToggleStats" or var == "Override_Firemodes" then
                for _, v2 in pairs(v) do
                    for var2, _ in pairs(v2) do
                        self.ModifiedCache[var2] = true
                    end
                end
            end
        end
    end

    for _, e in pairs(self.AttachmentElements) do
        if !istable(e) then continue end
        for var, v in pairs(e) do
            self.ModifiedCache[var] = true
        end
    end

    for _, e in pairs(self.Firemodes) do
        if !istable(e) then continue end
        for var, v in pairs(e) do
            self.ModifiedCache[var] = true
        end
    end

    MODIFIED_CACHE = true

    if SERVER then
        local cs = self:GetCapacity() + self:GetChamberSize()

        if self:Clip1() > cs and self:Clip1() != ArcCW.BottomlessMagicNumber then
            local diff = self:Clip1() - cs
            self:SetClip1(cs)

            if self:GetOwner():IsValid() and !self:GetOwner():IsNPC() then
                self:GetOwner():GiveAmmo(diff, self.Primary.Ammo, true)
            end
        end
    else
        local se = self:GetBuff_Override("Override_ShootEntity") or self.ShootEntity
        if se then
            local path = "arccw/weaponicons/" .. self:GetClass()
            local mat = Material(path)

            if !mat:IsError() then
                local tex = mat:GetTexture("$basetexture")
                local texpath = tex:GetName()

                killicon.Add(se, texpath, Color(255, 255, 255))
            end
        end
    end

    local ubgl_ammo = self:GetBuff_Override("UBGL_Ammo")
    local ubgl_clip = self:GetBuff_Override("UBGL_Capacity")

    self.Secondary.ClipSize = ubgl_clip or -1
    self.Secondary.Ammo = ubgl_ammo or "none"

    --[[]
    if ubgl_clip then
        self.Secondary.ClipSize = ubgl_clip
        if self:GetOwner():IsPlayer() and ArcCW.ConVars["atts_ubglautoload"]:GetBool() and ubgl_ammo then
            local amt = math.min(ubgl_clip - self:Clip2(), self:GetOwner():GetAmmoCount(ubgl_ammo))
            self:SetClip2(self:Clip2() + amt)
            self:GetOwner():RemoveAmmo(amt, ubgl_ammo)
        end
    else
        self.Secondary.ClipSize = -1
    end
    ]]



    self:RebuildSubSlots()

    local fmt = self:GetBuff_Override("Override_Firemodes", self.Firemodes)
    fmt["BaseClass"] = nil

    local fmi = self:GetFireMode()
    if !fmt[fmi] then self:SetFireMode(1) end

    self:AdjustAmmo(old_inf)
end

function SWEP:GetAttachmentMaxHP(slot)
    if !self.Attachments[slot] then return 100 end
    if !self.Attachments[slot].Installed then return 100 end
    local maxhp = 100
    local atttbl = ArcCW.AttachmentTable[self.Attachments[slot].Installed]

    if atttbl.Health then
        maxhp = atttbl.Health
    end

    return maxhp
end

function SWEP:GetAttachmentHP(slot)
    if !self.Attachments[slot] then return 100 end
    if !self.Attachments[slot].Installed then return 100 end

    if self.Attachments[slot].HP then return self.Attachments[slot].HP end

    self.Attachments[slot].HP = self:GetAttachmentMaxHP(slot)

    return self.Attachments[slot].HP
end

function SWEP:ApplyAttachmentShootDamage()
    local any = false
    for j, i in pairs(self.Attachments) do
        if !i.Installed then continue end
        local atttbl = ArcCW.AttachmentTable[i.Installed]

        if !atttbl.Health then continue end

        if atttbl.DamageOnShoot then
            self:DamageAttachment(j, atttbl.DamageOnShoot)
            any = true
        end
    end

    if any then
        self:SendAttHP()
    end
end

function SWEP:DamageAttachment(slot, dmg)
    if !self.Attachments[slot] then return end
    if !self.Attachments[slot].Installed then return end

    self.Attachments[slot].HP = self:GetAttachmentHP(slot) - dmg

    if self:GetAttachmentHP(slot) <= 0 then
        local atttbl = ArcCW.AttachmentTable[self.Attachments[slot].Installed]

        if atttbl.Hook_AttDestroyed then
            atttbl.Hook_AttDestroyed(self, {slot = slot, dmg = dmg})
        end

        self:Detach(slot, true)
    end
end

function SWEP:SendAttHP()
    net.Start("arccw_sendatthp")
    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl.Health then
            net.WriteBool(true)
            net.WriteUInt(i, 8)
            net.WriteFloat(self:GetAttachmentHP(i))
        end
    end
    net.WriteBool(false)
    net.Send(self:GetOwner())
end

-- local node = {b = {}, i = "" t = 0}
-- b: branches
-- i: installed
-- t: toggle
-- s: slide
-- h: hp

-- recursive function
-- gets a tree of all the attachments installed in subslots subordinate to a particular slot
function SWEP:GetSubSlotTree(i)
    if !self.Attachments[i] then return nil end
    if !self.Attachments[i].Installed then return nil end
    if !self.Attachments[i].SubAtts then return
        {
        b = {},
        i = self.Attachments[i].Installed,
        t = self.Attachments[i].ToggleNum,
        s = self.Attachments[i].SlidePos,
        h = self.Attachments[i].Health}
    end

    local ss = {}
    for j, k in pairs(self.Attachments[i].SubAtts) do
        if k == i then continue end
        local sst = self:GetSubSlotTree(k)
        if sst then
            ss[j] = sst
        end
    end

    return {b = ss, i = self.Attachments[i].Installed}
end

function SWEP:SubSlotTreeReinstall(slot, subslottree)
    for i, k in pairs(self.Attachments[slot].SubAtts or {}) do
        -- i = index
        -- k = slot
        self.Attachments[k].Installed = subslottree[i].i
        self.Attachments[k].ToggleNum = subslottree[i].t
        self.Attachments[k].SlidePos = subslottree[i].s
        self.Attachments[k].Health = subslottree[i].h

        if subslottree.b[i] then
            self:SubSlotTreeReinstall(i, subslottree.b[i])
        end
    end
end

function SWEP:RebuildSubSlots()
    -- this function rebuilds the subslots while preserving installed attachment data
    local subslottrees = {}

    local baseatts = table.Count(weapons.Get(self:GetClass()).Attachments)

    self.Attachments.BaseClass = nil

    for i = 1, baseatts do
        subslottrees[baseatts] = self:GetSubSlotTree(i)
    end

    -- remove all sub slots
    for i, k in pairs(self.Attachments) do
        if !isnumber(i) then continue end
        if !istable(k) then continue end
        if i > baseatts then
            self.Attachments[i] = nil
        else
            self.Attachments[i].SubAtts = nil
        end
    end

    self.SubSlotCount = 0
    -- add the sub slots back
    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local att = ArcCW.AttachmentTable[k.Installed]
        if !att then continue end
        if !istable(k) then continue end

        if att.SubSlots then
            self:AddSubSlot(i, k.Installed)
        end
    end
    -- add the sub slot data back

    for i, k in pairs(subslottrees) do
        self:SubSlotTreeReinstall(i, k)
    end
end

function SWEP:AddSubSlot(i, attname)
    local baseatts = table.Count(weapons.Get(self:GetClass()).Attachments)
    local att = ArcCW.AttachmentTable[attname]
    if att.SubSlots then
        self.Attachments[i].SubAtts = {}
        local og_slot = self.Attachments[i]
        for ind, slot in pairs(att.SubSlots) do
            if !istable(slot) then continue end
            self.SubSlotCount = self.SubSlotCount + 1
            local index = baseatts + self.SubSlotCount
            self.Attachments[index] = slot
            self.Attachments[index].Bone = og_slot.Bone
            self.Attachments[index].WMBone = og_slot.WMBone
            self.Attachments[index].ExtraSightDist = 0--self.Attachments[index].ExtraSightDist or og_slot.ExtraSightDist
            self.Attachments[index].CorrectivePos = og_slot.CorrectivePos
            self.Attachments[index].CorrectiveAng = og_slot.CorrectiveAng
            og_slot.SubAtts[ind] = index

            if slot.MergeSlots then
                self.Attachments[index].MergeSlots = {}
                for _, k2 in pairs(slot.MergeSlots) do
                    table.insert(self.Attachments[index].MergeSlots, k2 + index)
                end
            end

            if slot.Offset then
                self.Attachments[index].Offset = {
                    vpos = Vector(0, 0, 0),
                    vang = Angle(0, 0, 0),
                    wpos = Vector(0, 0, 0),
                    wang = Angle(0, 0, 0)
                }

                if slot.Offset.vang then
                    self.Attachments[index].Offset.vang = slot.Offset.vang + (og_slot.Offset.vang or Angle(0, 0, 0))
                end

                if slot.Offset.wang then
                    self.Attachments[index].Offset.wang = slot.Offset.wang + (og_slot.Offset.wang or Angle(0, 0, 0))
                end

                if slot.Offset.vpos then
                    self.Attachments[index].Offset.vpos = LocalToWorld(slot.Offset.vpos, self.Attachments[index].Offset.vang, og_slot.Offset.vpos, og_slot.Offset.vang or Angle(0, 0, 0))
                end

                if slot.Offset.wpos then
                    self.Attachments[index].Offset.wpos = LocalToWorld(slot.Offset.wpos, self.Attachments[index].Offset.wang, og_slot.Offset.wpos, og_slot.Offset.wang or Angle(0, 0, 0))
                end
            end

            self.Attachments[index].SubAtts = {}
        end
    end
end

function SWEP:OnReloaded()
    self:RecalcAllBuffs()
    self:SetupActiveSights()
end
--PATH lua/weapons/arccw_base/sh_model.lua:
function SWEP:KillModels()
    self:KillModel(self.WM)
    self.WM = nil
    self:KillModel(self.VM)
    self.VM = nil
end

function SWEP:AddElement(elementname, wm)
    local e = self.AttachmentElements[elementname]

    if !e then return end
    if !wm and self:GetOwner():IsNPC() then return end

    if !self:CheckFlags(e.ExcludeFlags, e.RequireFlags) then return end

    if ArcCW.ConVars["truenames"]:GetBool() and e.TrueNameChange then
        self.PrintName = e.TrueNameChange
    elseif ArcCW.ConVars["truenames"]:GetBool() and e.NameChange then
        self.PrintName = e.NameChange
    end

    if !ArcCW.ConVars["truenames"]:GetBool() and e.NameChange then
        self.PrintName = e.NameChange
    elseif !ArcCW.ConVars["truenames"]:GetBool() and e.TrueNameChange then
        self.PrintName = e.TrueNameChange
    end

    if e.AddPrefix then
        self.PrintName = e.AddPrefix .. self.PrintName
    end

    if e.AddSuffix then
        self.PrintName = self.PrintName .. e.AddSuffix
    end

    local og_weapon = weapons.GetStored(self:GetClass())

    local og_vm = og_weapon.ViewModel
    local og_wm = og_weapon.WorldModel

    self.ViewModel = og_vm
    self.WorldModel = og_wm

    local parent = self
    local elements = self.WM

    if !wm then
        parent = self:GetOwner():GetViewModel()
        elements = self.VM
    end

    local eles = e.VMElements

    if wm then
        eles = e.WMElements

        if self.MirrorVMWM then
            self.WorldModel = e.VMOverride or self.WorldModel
            self:SetSkin(e.VMSkin or self.DefaultSkin)
            eles = e.VMElements
        else
            self.WorldModel = e.WMOverride or self.WorldModel
            self:SetSkin(e.WMSkin or self.DefaultWMSkin)
        end
    else
        self.ViewModel = e.VMOverride or self.ViewModel
        self:GetOwner():GetViewModel():SetSkin(e.VMSkin or self.DefaultSkin)
    end

    if SERVER then return end

    for _, i in pairs(eles or {}) do
        local model = ClientsideModel(i.Model)

        if !model or !IsValid(model) or !IsValid(self) then continue end

        if i.BoneMerge then
            model:SetParent(parent)
            model:AddEffects(EF_BONEMERGE)
        else
            model:SetParent(self)
        end

        local element = {}

        local scale = Matrix()
        scale:Scale(i.Scale or Vector(1, 1, 1))

        model:SetNoDraw(ArcCW.NoDraw)
        model:DrawShadow(false)
        model.Weapon = self
        model:SetSkin(i.ModelSkin or 0)
        --model:SetBodyGroups(i.ModelBodygroups or "")
        ArcCW.SetBodyGroups(model, i.ModelBodygroups or "")
        model:EnableMatrix("RenderMultiply", scale)
        model:SetupBones()
        element.Model = model
        element.DrawFunc = i.DrawFunc
        element.WM = wm or false
        element.Bone = i.Bone
        element.NoDraw = i.NoDraw or false
        element.BoneMerge = i.BoneMerge or false
        element.Bodygroups = i.ModelBodygroups
        element.DrawFunc = i.DrawFunc
        element.OffsetAng = Angle()
        element.OffsetAng:Set(i.Offset.ang or Angle(0, 0, 0))
        element.OffsetPos = Vector()
        element.OffsetPos:Set(i.Offset.pos or Vector(), 0, 0)
        element.IsMuzzleDevice = i.IsMuzzleDevice

        if self.MirrorVMWM then
            element.WMBone = i.Bone
        else
            element.WMBone = i.WMBone
        end

        table.insert(elements, element)
    end

end

local function ScaleModel(model, vscale)
    if !model then return end
    local scale = Matrix()
    scale:Scale(vscale)
    model:EnableMatrix("RenderMultiply", scale)
end

function SWEP:SetupModel(wm)
    local elements = {}

    if !wm and !self:GetOwner():IsPlayer() then return end
    local owner = self:GetOwner()

    local og = weapons.Get(self:GetClass())

    self.PrintName = self.OldPrintName or og.PrintName
    local prefix, suffix = "", ""

    self:GetActiveElements(true)

    if !wm then
        local vm = owner:GetViewModel()

        vm.RenderOverride = function(v)
            if !self or !self.ArcCW then v.RenderOverride = nil return end
            local wep = LocalPlayer():GetActiveWeapon()
            if wep and !wep.ArcCW then v.RenderOverride = nil return end
            self:RefreshBGs()

            for i, k in pairs(self:GetBuff_Override("Override_CaseBGs", self.CaseBGs) or {}) do
                if !isnumber(i) then continue end
                local bone = vm:LookupBone(k)

                if !bone then continue end

                if self:GetVisualClip() >= i then
                    vm:SetBodygroup(k.ind, k.bg)
                else
                    vm:SetBodygroup(k.ind, 0)
                end
            end

            for i, k in pairs(self:GetBuff_Override("Override_BulletBGs", self.BulletBGs) or {}) do
                if !isnumber(i) then continue end
                local bone = vm:LookupBone(k)

                if !bone then continue end

                if self:GetVisualBullets() >= i then
                    vm:SetBodygroup(k.ind, k.bg)
                else
                    vm:SetBodygroup(k.ind, 0)
                end
            end

            for i, k in pairs(self:GetBuff_Override("Override_StripperClipBGs", self.StripperClipBGs) or {}) do
                if !isnumber(i) then continue end
                local bone = vm:LookupBone(k)

                if !bone then continue end

                if self:GetVisualLoadAmount() >= i then
                    vm:SetBodygroup(k.ind, k.bg)
                else
                    vm:SetBodygroup(k.ind, 0)
                end
            end

            if !self.HideViewmodel then
                ArcCW.VM_OverDraw = true
                v:DrawModel()
                ArcCW.VM_OverDraw = false
            end
        end
    end

    if CLIENT then

    if wm then
        self:KillModel(self.WM)
        self.WM = elements
    else
        self:KillModel(self.VM)
        self.VM = elements

        if !IsValid(owner) or owner:IsNPC() then
            return
        end

        if !IsValid(owner:GetViewModel()) then
            self:SetTimer(0.5, function()
                self:SetupModel(wm)
            end)
            return
        end

        owner:GetViewModel():SetupBones()
    end

    render.OverrideDepthEnable( true, true )

    end

    local vscale = Vector(1, 1, 1)

    -- if !wm and CLIENT then
    --     local sm = self.ViewModel

    --     local model = ClientsideModel(sm)

    --     if !model then return end
    --     if !IsValid(model) then return end

    --     model:SetNoDraw(ArcCW.NoDraw)
    --     model:DrawShadow(true)
    --     model:SetPredictable(false)
    --     model.Weapon = self
    --     model:SetSkin(self.DefaultVMSkin or 0)
    --     model:SetBodyGroups(self.DefaultVMBodygroups or "")
    --     model:SetupBones()
    --     local element = {}
    --     element.Model = model

    --     model:SetParent(self:GetOwner():GetViewModel())
    --     model:AddEffects(EF_BONEMERGE)
    --     element.BoneMerge = true
    --     element.IsBaseVM = true

    --     self.VMModel = model

    --     table.insert(elements, element)
    -- end

    if wm and CLIENT then
        local sm = self.WorldModel
        if self.MirrorVMWM then
            sm = self.MirrorWorldModel or self.ViewModel
        end
        local vs = (self.WorldModelOffset or {}).scale or 1
        vscale = Vector(vs, vs, vs)
        local model = ClientsideModel(sm)

        if !model then return end
        if !IsValid(model) then return end

        model:SetNoDraw(ArcCW.NoDraw)
        model:DrawShadow(false)
        model:SetPredictable(false)
        model.Weapon = self
        model:SetSkin(self.DefaultWMSkin or 0)
        --model:SetBodyGroups(self.DefaultWMBodygroups or "")
        ArcCW.SetBodyGroups(model, self.DefaultWMBodygroups or "")
        ScaleModel(model, vscale)
        model:SetupBones()
        local element = {}
        element.Model = model
        element.WM = true
        element.IsBaseWM = true
        element.WMBone = "ValveBiped.Bip01_R_Hand"

        if self.WorldModelOffset then
            if !IsValid(owner) then
                element.OffsetAng = Angle(0, 0, 0)
                element.OffsetPos = Vector(0, 0, 0)
            else
                element.OffsetAng = self.WorldModelOffset.ang or Angle(0, 0, 0)
                element.OffsetPos = self.WorldModelOffset.pos or Vector(0, 0, 0)
                element.WMBone = self.WorldModelOffset.bone or element.WMBone
            end
            element.BoneMerge = false
        else
            model:SetParent(owner or self)
            model:AddEffects(EF_BONEMERGE)
            element.BoneMerge = true
            element.OffsetAng = Angle(0, 0, 0)
        end

        self.WMModel = model

        table.insert(elements, element)
    end

    for _, k in pairs(self:GetActiveElements()) do
        self:AddElement(k, wm)
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        local slots = atttbl.Slot

        if isstring(slots) then
            slots = {slots}
        end

        for _, ele in pairs(slots) do
            self:AddElement(ele, wm)
        end

        if atttbl.AddPrefix then
            -- self.PrintName = atttbl.AddPrefix .. self.PrintName
            prefix = atttbl.AddPrefix .. prefix
        end

        if atttbl.AddSuffix then
            -- self.PrintName = self.PrintName .. atttbl.AddSuffix
            suffix = suffix .. atttbl.AddSuffix
        end

        if CLIENT and !ArcCW.ConVars["att_showothers"]:GetBool() and LocalPlayer() != owner then
            continue
        end

        if SERVER then continue end

        if wm and k.NoWM then continue end
        if !wm and k.NoVM then continue end

        if !atttbl.Model then continue end
        if atttbl.HideModel then continue end

        if !k.Offset and !atttbl.BoneMerge then continue end

        local model = ClientsideModel(atttbl.Model)

        if !model or !IsValid(model) then continue end

        if atttbl.BoneMerge then
            local parent = owner:GetViewModel()

            if wm then
                parent = owner
            end

            model:SetParent(parent)
            model:AddEffects(EF_BONEMERGE)
        else
            model:SetParent(self)
        end

        local repbone = nil
        local repang = nil

        for _, e in pairs(self:GetActiveElements()) do
            local ele = self.AttachmentElements[e]

            if !ele then continue end

            if ((ele.AttPosMods or {})[i] or {}).bone then
                repbone = ele.AttPosMods[i].bone
            end

            if wm then
                if ((ele.AttPosMods or {})[i] or {}).wang then
                    repang = ele.AttPosMods[i].wang
                end
            else
                if ((ele.AttPosMods or {})[i] or {}).vang then
                    repang = ele.AttPosMods[i].vang
                end
            end
        end

        local element = {}

        local scale

        if wm then
            scale = (k.WMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1)
        else
            scale = (k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1)
        end

        scale = scale * vscale

        model:SetNoDraw(ArcCW.NoDraw)
        model:DrawShadow(false)
        model:SetPredictable(false)
        model.Weapon = self
        model:SetSkin(self:GetBuff_Stat("ModelSkin", i) or 0)
        model:SetBodyGroups(self:GetBuff_Stat("ModelBodygroups", i) or "")
        model:SetupBones()
        ScaleModel(model, scale)
        element.Model = model
        element.DrawFunc = atttbl.DrawFunc
        element.WM = wm or false
        element.Bone = repbone or k.Bone
        element.NoDraw = atttbl.NoDraw or false
        element.BoneMerge = k.BoneMerge or false
        element.Bodygroups = self:GetBuff_Stat("ModelBodygroups", i)
        element.DrawFunc = atttbl.DrawFunc
        element.Slot = i
        element.ModelOffset = self:GetBuff_Stat("ModelOffset", i) or Vector(0, 0, 0)

        if wm then
            element.OffsetAng = Angle()
            element.OffsetAng:Set(repang or k.Offset.wang or Angle(0, 0, 0))
            element.OffsetAng = element.OffsetAng + (atttbl.OffsetAng or Angle(0, 0, 0))
            k.WElement = element

            if self.MirrorVMWM then
                element.WMBone = repbone or k.Bone
                element.OffsetAng = Angle()
                element.OffsetAng:Set(repang or k.Offset.vang or Angle(0, 0, 0))
                element.OffsetAng = element.OffsetAng + (atttbl.OffsetAng or Angle(0, 0, 0))
            else
                element.WMBone = k.WMBone or "ValveBiped.Bip01_R_Hand"
            end
        else
            element.OffsetAng = Angle()
            element.OffsetAng:Set(repang or k.Offset.vang or Angle(0, 0, 0))
            element.OffsetAng = element.OffsetAng + (atttbl.OffsetAng or Angle(0, 0, 0))
            k.VMOffsetAng = element.OffsetAng
            k.VElement = element
        end

        table.insert(elements, element)

        if atttbl.Charm and atttbl.CharmModel then
            local charmmodel = ClientsideModel(atttbl.CharmModel)

            local charmscale = vscale

            if wm then
                if self.MirrorVMWM then
                    charmscale = charmscale * ((k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                else
                    charmscale = charmscale * ((k.WMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                end
            else
                charmscale = charmscale * ((k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
            end

            charmscale = charmscale * (atttbl.CharmScale or Vector(1, 1, 1))

            if IsValid(charmmodel) then
                charmmodel:SetNoDraw(ArcCW.NoDraw)
                charmmodel:DrawShadow(false)
                charmmodel:SetupBones()
                ScaleModel(charmmodel, charmscale)
                charmmodel:SetSkin(atttbl.CharmSkin or 0)
                charmmodel:SetBodyGroups(atttbl.CharmBodygroups or "")

                local charmelement = {}
                charmelement.Model = charmmodel
                charmelement.CharmOffset = atttbl.CharmOffset or Vector(0, 0, 0)
                charmelement.CharmAngle = atttbl.CharmAngle or Angle(0, 0, 0)
                charmelement.CharmAtt = atttbl.CharmAtt or "charm"
                charmelement.CharmParent = element
                charmelement.SubModel = true

                if wm then
                    if self.MirrorVMWM then
                        charmelement.CharmScale = ((k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                    else
                        charmelement.CharmScale = ((k.WMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                    end
                else
                    charmelement.CharmScale = ((k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                end

                table.insert(elements, charmelement)
            end
        end

        if atttbl.IsMuzzleDevice or atttbl.UBGL then
            local hspmodel = ClientsideModel(atttbl.Model)

            if k.BoneMerge then
                local parent = owner:GetViewModel()

                if wm then
                    parent = owner
                end

                hspmodel:SetParent(parent)
                hspmodel:AddEffects(EF_BONEMERGE)
            else
                hspmodel:SetParent(self)
            end

            local hspelement = {}
            hspmodel:SetNoDraw(true)
            hspmodel:DrawShadow(false)
            hspmodel:SetPredictable(false)
            hspmodel.Weapon = self

            hspelement.Model = hspmodel
            ScaleModel(charmmodel, scale)

            hspelement.WM = wm or false
            hspelement.Bone = repbone or k.Bone
            hspelement.NoDraw = true
            hspelement.BoneMerge = k.BoneMerge or false
            hspelement.Slot = i
            hspelement.WMBone = k.WMBone

            hspelement.OffsetAng = element.OffsetAng

            if atttbl.IsMuzzleDevice then
                hspelement.IsMuzzleDevice = true
            end

            if wm then
                k.WMuzzleDeviceElement = hspelement

                if self.MirrorVMWM then
                    hspelement.WMBone = k.Bone
                end
            else
                k.VMuzzleDeviceElement = hspelement
            end

            table.insert(elements, hspelement)
        else
            k.VMuzzleDeviceElement = nil
            k.WMuzzleDeviceElement = nil
        end

        if atttbl.HolosightPiece then
            local hspmodel = ClientsideModel(atttbl.HolosightPiece)

            if k.BoneMerge then
                local parent = owner:GetViewModel()

                if wm then
                    parent = owner
                end

                hspmodel:SetParent(parent)
                hspmodel:AddEffects(EF_BONEMERGE)
            else
                hspmodel:SetParent(self)
            end

            local hspelement = {}
            hspmodel:SetNoDraw(true)
            hspmodel:DrawShadow(false)
            hspmodel:SetPredictable(false)
            ScaleModel(hspmodel, scale)
            hspmodel.Weapon = self

            hspelement.Model = hspmodel

            hspelement.WM = wm or false
            hspelement.Bone = repbone or k.Bone
            hspelement.NoDraw = atttbl.NoDraw or false
            hspelement.BoneMerge = k.BoneMerge or false
            hspelement.Slot = i
            hspelement.WMBone = k.WMBone

            hspelement.ModelOffset = atttbl.HolosightModelOffset or atttbl.ModelOffset
            hspelement.OffsetAng = element.OffsetAng

            if !wm then
                k.HSPElement = hspelement
            else
                if self.MirrorVMWM then
                    hspelement.WMBone = k.Bone
                end
            end

            table.insert(elements, hspelement)
        else
            k.HSPElement = nil
        end

        -- These shouldn't be created in WM.
        -- These shouldn't be created in WM.
        -- BUT THEY ARE!!
        if atttbl.LHIK_GunDriver or atttbl.LHIK_CamDriver then
            local godmodel = ClientsideModel(atttbl.Model)

            local godelement = {}
            godmodel:SetNoDraw(true)
            godmodel:DrawShadow(false)
            godmodel:SetPredictable(false)
            godmodel.Weapon = self

            godelement.Model = godmodel

            godelement.WM = wm or false
            godelement.NoDraw = true
            godelement.BoneMerge = false
            godelement.Slot = i
            if !wm then
                -- godmodel:SetNoDraw(false)
                k.GodDriver = godelement
            end
            table.insert(elements, godelement)
        end

        if atttbl.LHIK_GunDriver then
            local reflectmodel = ClientsideModel(self.ViewModel)

            local reflectelement = {}
            reflectmodel:SetNoDraw(true)
            reflectmodel:DrawShadow(false)
            reflectmodel:SetPredictable(false)
            reflectmodel.Weapon = self

            reflectelement.Model = reflectmodel

            reflectelement.WM = wm or false
            reflectelement.NoDraw = true
            reflectelement.Slot = i
            if !wm then
                -- reflectmodel:SetNoDraw(false)
                k.ReflectDriver = reflectelement
            end
            table.insert(elements, reflectelement)
        end
    end

    if CLIENT then

    if !wm and self.HolosightPiece then
        local hspmodel = ClientsideModel(self.HolosightPiece)

        hspmodel:SetParent(parent)
        hspmodel:AddEffects(EF_BONEMERGE)

        local hspelement = {}
        hspmodel:SetNoDraw(true)
        hspmodel:DrawShadow(false)
        hspmodel:SetPredictable(false)
        hspmodel.Weapon = self

        hspelement.Model = hspmodel

        hspelement.WM = wm or false
        hspelement.BoneMerge = true
        hspelement.NoDraw = false

        if !wm then
            self.HSPElement = hspelement
        end

        table.insert(elements, hspelement)
    end

    local eid = self:EntIndex()

    for i, k in pairs(elements) do
        local piletab = {
            Model = k.Model,
            Weapon = self
        }

        table.insert(ArcCW.CSModelPile, piletab)
    end

    if !ArcCW.CSModels[eid] then
        ArcCW.CSModels[eid] = {
            Weapon = self
        }
    end

    if wm then
        self.WM = elements
        self:KillModel(ArcCW.CSModels[eid].WModels)
        ArcCW.CSModels[eid].WModels = elements
    else
        self.VM = elements
        self:KillModel(ArcCW.CSModels[eid].VModels)
        ArcCW.CSModels[eid].VModels = elements
    end

    render.OverrideDepthEnable( false, true )

    if !wm then
    --     self:CreateFlashlightsWM()
    -- else
        self:CreateFlashlightsVM()
    end

    end

    self.PrintName = prefix .. (self:GetBuff_Hook("Hook_NameChange", self.PrintName) or self.PrintName) .. suffix
    self.Trivia_Class = self:GetBuff_Hook("Hook_ClassChange", self.Trivia_Class) or self.Trivia_Class
    self.Trivia_Desc = self:GetBuff_Hook("Hook_DescChange", self.Trivia_Desc) or self.Trivia_Desc

    self:SetupActiveSights()

    self:RefreshBGs()
end

function SWEP:KillModel(models)
    if !models then return end
    if table.IsEmpty(models) then return end

    for _, i in pairs(models) do
        if !isentity(i.Model) then continue end
        SafeRemoveEntity(i.Model)
    end
end

function SWEP:DrawCustomModel(wm, origin, angle)
    if ArcCW.VM_OverDraw then return end
    local owner = self:GetOwner()
    local disttoeye = self:GetPos():DistToSqr(EyePos())
    local visibility = math.pow(ArcCW.ConVars["visibility"]:GetInt(), 2)
    local always = false
    if ArcCW.ConVars["visibility"]:GetInt() < 0 or self:GetOwner() == LocalPlayer() then
        always = true
    end
    local models = self.VM
    local vm

    if origin and !angle then
        angle = Angle()
    end
    local custompos = origin and angle
    if custompos then
        wm = true --VM drawing borked
    end

    -- self:KillModel(self.VM)
    -- self:KillModel(self.WM)
    -- self.VM = nil
    -- self.WM = nil

    local vscale = 1

    if wm then
        if !always and disttoeye >= visibility * 2 then return end

        if !self.WM then
            self:SetupModel(wm)
        end

        models = self.WM

        vm = owner

        if self.MirrorVMWM or !IsValid(owner) then
            vm = self.WMModel or self
        end

        if self.WorldModelOffset then
            vscale = self.WorldModelOffset.scale or 1
        end

        if !vm or !IsValid(vm) then return end
    else
        if !self.VM then
            self:SetupModel(wm)
        end

        vm = owner:GetViewModel()

        if !vm or !IsValid(vm) then return end

        models = self.VM

        -- if self.HSPElement then
        --     self.HSPElement.Model:DrawModel()
        -- end
    end

    for i, k in pairs(models) do
        if !IsValid(k.Model) then
            self:SetupModel(wm)
            return
        end

        -- local asight = self:GetActiveSights()

        -- if asight then
        --     local activeslot = asight.Slot
        --     if k.Slot == activeslot and ArcCW.Overdraw then
        --         continue
        --     end
        -- end

        if k.IsBaseVM and !custompos then
            k.Model:SetParent(owner:GetViewModel())
            vm = self
            selfmode = true
            basewm = true
        elseif k.IsBaseWM then
            if IsValid(owner) and !custompos then
                local wmo = self.WorldModelOffset
                if !wmo then
                    wmo = {pos = Vector(0, 0, 0), ang = Angle(0, 0, 0)}
                end
                k.Model:SetParent(owner)
                vm = owner
                k.OffsetAng = wmo.ang
                k.OffsetPos = wmo.pos
            else
                k.Model:SetParent(self)
                vm = self
                selfmode = true
                basewm = true
                k.OffsetAng = Angle(0, 0, 0)
                k.OffsetPos = Vector(0, 0, 0)
            end
        elseif wm and self:ShouldCheapWorldModel() then
            continue
        else
            if wm and self.MirrorVMWM then
                vm = self.WMModel or self
                -- vm = self
            end

            if wm and !always and disttoeye >= visibility then
                continue
            end
        end

        if k.BoneMerge and !k.NoDraw then
            k.Model:DrawModel()
            continue
        end

        local bonename = k.Bone

        if wm then
            bonename = k.WMBone or "ValveBiped.Bip01_R_Hand"
        end

        local bpos, bang
        local offset = k.OffsetPos

        if k.IsBaseWM and !IsValid(self:GetOwner()) then
            bpos = self:GetPos()
            bang = self:GetAngles()
        elseif bonename then
            local boneindex = vm:LookupBone(bonename)

            if !boneindex then continue end

            if wm then
                bpos, bang = vm:GetBonePosition(boneindex)
            else
                local bonemat = vm:GetBoneMatrix(boneindex)

                if bonemat then
                    bpos = bonemat:GetTranslation()
                    bang = bonemat:GetAngles()
                end
            end

            if custompos and (!self.MirrorVMWM or (self.MirrorVMWM and k.Model:GetModel() == self.ViewModel) ) then
                bpos = origin
                bang = angle
            end

            if k.Slot then

                local attslot = self.Attachments[k.Slot]

                local delta = attslot.SlidePos or 0.5

                local vmelemod = nil
                local wmelemod = nil
                local slidemod = nil

                for _, e in pairs(self:GetActiveElements(true)) do
                    local ele = self.AttachmentElements[e]

                    if !ele then continue end

                    if ((ele.AttPosMods or {})[k.Slot] or {}).vpos then
                        vmelemod = ele.AttPosMods[k.Slot].vpos
                        if self.MirrorVMWM then
                            wmelemod = ele.AttPosMods[k.Slot].vpos
                        end
                    end

                    if !self.MirrorVMWM then
                        if ((ele.AttPosMods or {})[k.Slot] or {}).wpos then
                            wmelemod = ele.AttPosMods[k.Slot].wpos
                        end
                    end

                    if ((ele.AttPosMods or {})[k.Slot] or {}).slide then
                        slidemod = ele.AttPosMods[k.Slot].slide
                    end

                    -- Why the fuck is it called 'slide'. Call it fucking SlideAmount like it is
                    -- in the fucking attachment slot you fucking cockfuck shitdick
                    if ((ele.AttPosMods or {})[k.Slot] or {}).SlideAmount then
                        slidemod = ele.AttPosMods[k.Slot].SlideAmount
                    end
                end

                if wm and !self.MirrorVMWM then
                    offset = wmelemod or (attslot.Offset or {}).wpos or Vector(0, 0, 0)

                    if attslot.SlideAmount then
                        offset = LerpVector(delta, (slidemod or attslot.SlideAmount).wmin or Vector(0, 0, 0), (slidemod or attslot.SlideAmount).wmax or Vector(0, 0, 0))
                    end
                else
                    offset = vmelemod or (attslot.Offset or {}).vpos or Vector(0, 0, 0)

                    if attslot.SlideAmount then
                        offset = LerpVector(delta, (slidemod or attslot.SlideAmount).vmin or Vector(0, 0, 0), (slidemod or attslot.SlideAmount).vmax or Vector(0, 0, 0))
                    end

                    attslot.VMOffsetPos = offset
                end

            end

        end

        local apos, aang

        if k.CharmParent and IsValid(k.CharmParent.Model) then
            local cm = k.CharmParent.Model
            local boneindex = cm:LookupAttachment(k.CharmAtt)
            local angpos = cm:GetAttachment(boneindex)
            if angpos then
                apos, aang = angpos.Pos, angpos.Ang

                local pos = k.CharmOffset
                local ang = k.CharmAngle
                local scale = k.CharmScale or Vector(1, 1, 1)

                apos = apos + aang:Forward() * pos.x * scale.x
                apos = apos + aang:Right() * pos.y * scale.y
                apos = apos + aang:Up() * pos.z * scale.z

                aang:RotateAroundAxis(aang:Right(), ang.p)
                aang:RotateAroundAxis(aang:Up(), ang.y)
                aang:RotateAroundAxis(aang:Forward(), ang.r)
            end
        elseif bang and bpos then

            local pos = offset or Vector(0, 0, 0)
            local ang = k.OffsetAng or Angle(0, 0, 0)

            pos = pos * vscale

            local moffset = (k.ModelOffset or Vector(0, 0, 0))

            apos = bpos + bang:Forward() * pos.x
            apos = apos + bang:Right() * pos.y
            apos = apos + bang:Up() * pos.z

            aang = Angle()
            aang:Set(bang)

            aang:RotateAroundAxis(aang:Right(), ang.p)
            aang:RotateAroundAxis(aang:Up(), ang.y)
            aang:RotateAroundAxis(aang:Forward(), ang.r)

            apos = apos + aang:Forward() * moffset.x
            apos = apos + aang:Right() * moffset.y
            apos = apos + aang:Up() * moffset.z
        else
            continue
        end

        if !apos or !aang then return end

        k.Model:SetPos(apos)
        k.Model:SetAngles(aang)
        k.Model:SetRenderOrigin(apos)
        k.Model:SetRenderAngles(aang)

        if k.Bodygroups then
            k.Model:SetBodyGroups(k.Bodygroups)
        end

        if k.DrawFunc then
            k.DrawFunc(self, k, wm)
        end

        if !k.NoDraw then
            k.Model:DrawModel()
        end

        -- FIXME: activeslot is nil?
        if i != activeslot and ArcCW.Overdraw then
            k.Model:SetBodygroup(1, 0)
        end
    end

    if wm then
        self:DrawFlashlightsWM()
        -- self:KillFlashlightsVM()
    else
        self:DrawFlashlightsVM()
    end

    -- self:RefreshBGs()
end

SWEP.ReferencePosCache = {}

function SWEP:GetFromReference(boneid)
    if !boneid then boneid = 1 end
    if self.ReferencePosCache[boneid] then
        return self.ReferencePosCache[boneid].Pos, self.ReferencePosCache[boneid].Ang
    end

    SafeRemoveEntity(ArcCW.ReferenceModel)

    if !self.ViewModel then
        -- uh oh panic
        local og = weapons.Get(self:GetClass())
        self.ViewModel = og.ViewModel
    end

    ArcCW.ReferenceModel = ClientsideModel(self.ViewModel)

    local pos = self:GetOwner():EyePos()
    local ang = self:GetOwner():EyeAngles()

    local seq = "idle"
    seq = self:GetBuff_Override("Override_AutosolveSourceSeq") or self.AutosolveSourceSeq or seq
    ArcCW.ReferenceModel:ResetSequence(seq)

    ArcCW.ReferenceModel:SetPos(pos)
    ArcCW.ReferenceModel:SetAngles(ang)
    ArcCW.ReferenceModel:SetNoDraw(true)
    ArcCW.ReferenceModel:SetupBones()

    local ma = ArcCW.ReferenceModel:GetBoneMatrix(boneid)
    local bpos, bang = ma:GetTranslation(), ma:GetAngles()

    bpos, bang = WorldToLocal(pos, ang, bpos, bang)

    self.ReferencePosCache[boneid] = {Pos = bpos, Ang = bang}

    return bpos, bang
end
--PATH lua/weapons/arccw_base/sh_think.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_think.lua:
if CLIENT then
    ArcCW.LastWeapon = nil
end

local vec1 = Vector(1, 1, 1)
local vec0 = vec1 * 0
local ang0 = Angle(0, 0, 0)

local lastUBGL = 0
function SWEP:Think()
    if IsValid(self:GetOwner()) and self:GetClass() == "arccw_base" then
        self:Remove()
        return
    end

    local owner = self:GetOwner()

    if !IsValid(owner) or owner:IsNPC() then return end

    if self:GetState() == ArcCW.STATE_DISABLE and !self:GetPriorityAnim() then
        self:SetState(ArcCW.STATE_IDLE)

        if CLIENT and self.UnReady then
            self.UnReady = false
        end
    end

    for i, v in ipairs(self.EventTable) do
        for ed, bz in pairs(v) do
            if ed <= CurTime() then
                if bz.AnimKey and (bz.AnimKey != self.LastAnimKey or bz.StartTime != self.LastAnimStartTime) then
                    continue
                end
                self:PlayEvent(bz)
                self.EventTable[i][ed] = nil
                --print(CurTime(), "Event completed at " .. i, ed)
                if table.IsEmpty(v) and i != 1 then self.EventTable[i] = nil --[[print(CurTime(), "No more events at " .. i .. ", killing")]] end
            end
        end
    end

    if CLIENT and (!game.SinglePlayer() and IsFirstTimePredicted() or true)
            and self:GetOwner() == LocalPlayer() and ArcCW.InvHUD
            and !ArcCW.Inv_Hidden and ArcCW.Inv_Fade == 0 then
        ArcCW.InvHUD:Remove()
        ArcCW.Inv_Fade = 0.01
    end

    local vm = owner:GetViewModel()

    self.BurstCount = self:GetBurstCount()

    local sg = self:GetShotgunReloading()
    if (sg == 2 or sg == 4) and owner:KeyPressed(IN_ATTACK) then
        self:SetShotgunReloading(sg + 1)
    elseif (sg >= 2) and self:GetReloadingREAL() <= CurTime() then
        self:ReloadInsert((sg >= 4) and true or false)
    end

    self:InBipod()

    if self:GetNeedCycle() and !self.Throwing and !self:GetReloading() and self:GetWeaponOpDelay() < CurTime() and self:GetNextPrimaryFire() < CurTime() and -- Adding this delays bolting if the RPM is too low, but removing it may reintroduce the double pump bug. Increasing the RPM allows you to shoot twice on many multiplayer servers. Sure would be convenient if everything just worked nicely
            (!ArcCW.ConVars["clicktocycle"]:GetBool() and (self:GetCurrentFiremode().Mode == 2 or !owner:KeyDown(IN_ATTACK))
            or ArcCW.ConVars["clicktocycle"]:GetBool() and (self:GetCurrentFiremode().Mode == 2 or owner:KeyPressed(IN_ATTACK))) then
        local anim = self:SelectAnimation("cycle")
        anim = self:GetBuff_Hook("Hook_SelectCycleAnimation", anim) or anim
        local mult = self:GetBuff_Mult("Mult_CycleTime")
        local p = self:PlayAnimation(anim, mult, true, 0, true)
        if p then
            self:SetNeedCycle(false)
            self:SetPriorityAnim(CurTime() + self:GetAnimKeyTime(anim, true) * mult)
        end
    end

    if self:GetGrenadePrimed() and !(owner:KeyDown(IN_ATTACK) or owner:KeyDown(IN_ATTACK2)) and (!game.SinglePlayer() or SERVER) then
        self:Throw()
    end

    if self:GetGrenadePrimed() and self.GrenadePrimeTime > 0 and self.isCooked then
        local heldtime = (CurTime() - self.GrenadePrimeTime)

        local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime

        if ft and (heldtime >= ft) and (!game.SinglePlayer() or SERVER) then
            self:Throw()
        end
    end

    if IsFirstTimePredicted() and self:GetNextPrimaryFire() < CurTime() and owner:KeyReleased(IN_USE) then
        if self:InBipod() then
            self:ExitBipod()
        else
            self:EnterBipod()
        end
    end

    if ((game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and true)) and self:GetBuff_Override("Override_TriggerDelay", self.TriggerDelay) then
        if owner:KeyReleased(IN_ATTACK) and self:GetBuff_Override("Override_TriggerCharge", self.TriggerCharge) and self:GetTriggerDelta(true) >= 1 then
            self:PrimaryAttack()
        else
            self:DoTriggerDelay()
        end
    end

    if self:GetCurrentFiremode().RunawayBurst then

        if self:GetBurstCount() > 0 and ((game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and true)) then
            self:PrimaryAttack()
        end

        if self:Clip1() < self:GetBuff("AmmoPerShot") or self:GetBurstCount() == self:GetBurstLength() then
            self:SetBurstCount(0)
            if !self:GetCurrentFiremode().AutoBurst then
                self.Primary.Automatic = false
            end
        end
    end

    if owner:KeyReleased(IN_ATTACK) then

        if !self:GetCurrentFiremode().RunawayBurst then
            self:SetBurstCount(0)
            self.LastTriggerTime = -1 -- Cannot fire again until trigger released
            self.LastTriggerDuration = 0
        end

        if self:GetCurrentFiremode().Mode < 0 and !self:GetCurrentFiremode().RunawayBurst then
            local postburst = self:GetCurrentFiremode().PostBurstDelay or 0

            if (CurTime() + postburst) > self:GetWeaponOpDelay() then
                --self:SetNextPrimaryFire(CurTime() + postburst)
                self:SetWeaponOpDelay(CurTime() + postburst * self:GetBuff_Mult("Mult_PostBurstDelay") + self:GetBuff_Add("Add_PostBurstDelay"))
            end
        end
    end

    if owner and owner:GetInfoNum("arccw_automaticreload", 0) == 1 and self:Clip1() == 0 and !self:GetReloading() and CurTime() > self:GetNextPrimaryFire() + 0.2 then
        self:Reload()
    end

    if (!(self:GetBuff_Override("Override_ReloadInSights") or self.ReloadInSights) and (self:GetReloading() or owner:KeyDown(IN_RELOAD))) then
        if !(self:GetBuff_Override("Override_ReloadInSights") or self.ReloadInSights) and self:GetReloading() then
            self:ExitSights()
        end
    end


    if self:GetBuff_Hook("Hook_ShouldNotSight") and (self.Sighted or self:GetState() == ArcCW.STATE_SIGHTS) then
        self:ExitSights()
    elseif self:GetHolster_Time() > 0 then
        self:ExitSights()
    else

        -- no it really doesn't, past me
        local sighted = self:GetState() == ArcCW.STATE_SIGHTS
        local toggle = owner:GetInfoNum("arccw_toggleads", 0) >= 1
        local suitzoom = owner:KeyDown(IN_ZOOM)
        local sp_cl = game.SinglePlayer() and CLIENT

        -- if in singleplayer, client realm should be completely ignored
        if toggle and !sp_cl then
            if owner:KeyPressed(IN_ATTACK2) then
                if sighted then
                    self:ExitSights()
                elseif !suitzoom then
                    self:EnterSights()
                end
            elseif suitzoom and sighted then
                self:ExitSights()
            end
        elseif !toggle then
            if (owner:KeyDown(IN_ATTACK2) and !suitzoom) and !sighted then
                self:EnterSights()
            elseif (!owner:KeyDown(IN_ATTACK2) or suitzoom) and sighted then
                self:ExitSights()
            end
        end

    end

    if (!game.SinglePlayer() and IsFirstTimePredicted()) or (game.SinglePlayer() and true) then
        if self:InSprint() and (self:GetState() != ArcCW.STATE_SPRINT) then
            self:EnterSprint()
        elseif !self:InSprint() and (self:GetState() == ArcCW.STATE_SPRINT) then
            self:ExitSprint()
        end
    end

    if game.SinglePlayer() or IsFirstTimePredicted() then
        self:SetSightDelta(math.Approach(self:GetSightDelta(), self:GetState() == ArcCW.STATE_SIGHTS and 0 or 1, FrameTime() / self:GetSightTime()))
        self:SetSprintDelta(math.Approach(self:GetSprintDelta(), self:GetState() == ArcCW.STATE_SPRINT and 1 or 0, FrameTime() / self:GetSprintTime()))
    end

    if CLIENT and (game.SinglePlayer() or IsFirstTimePredicted()) then
        self:ProcessRecoil()
    end

    if CLIENT and IsValid(vm) then

        for i = 1, vm:GetBoneCount() do
            vm:ManipulateBoneScale(i, vec1)
        end

        for i, k in pairs(self:GetBuff_Override("Override_CaseBones", self.CaseBones) or {}) do
            if !isnumber(i) then continue end
            for _, b in pairs(istable(k) and k or {k}) do
                local bone = vm:LookupBone(b)

                if !bone then continue end

                if self:GetVisualClip() >= i then
                    vm:ManipulateBoneScale(bone, vec1)
                else
                    vm:ManipulateBoneScale(bone, vec0)
                end
            end
        end

        for i, k in pairs(self:GetBuff_Override("Override_BulletBones", self.BulletBones) or {}) do
            if !isnumber(i) then continue end
            for _, b in pairs(istable(k) and k or {k}) do
                local bone = vm:LookupBone(b)

                if !bone then continue end

                if self:GetVisualBullets() >= i then
                    vm:ManipulateBoneScale(bone, vec1)
                else
                    vm:ManipulateBoneScale(bone, vec0)
                end
            end
        end

        for i, k in pairs(self:GetBuff_Override("Override_StripperClipBones", self.StripperClipBones) or {}) do
            if !isnumber(i) then continue end
            for _, b in pairs(istable(k) and k or {k}) do
                local bone = vm:LookupBone(b)

                if !bone then continue end

                if self:GetVisualLoadAmount() >= i then
                    vm:ManipulateBoneScale(bone, vec1)
                else
                    vm:ManipulateBoneScale(bone, vec0)
                end
            end
        end
    end

    self:DoHeat()

    self:ThinkFreeAim()

    -- if CLIENT then
        -- if !IsValid(ArcCW.InvHUD) then
        --     gui.EnableScreenClicker(false)
        -- end

        -- if self:GetState() != ArcCW.STATE_CUSTOMIZE then
        --     self:CloseCustomizeHUD()
        -- else
        --     self:OpenCustomizeHUD()
        -- end
    -- end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl.DamagePerSecond then
            local dmg = atttbl.DamagePerSecond * FrameTime()

            self:DamageAttachment(i, dmg)
        end
    end

    if CLIENT then
        self:DoOurViewPunch()
    end

    if self.Throwing and self:Clip1() == 0 and self:Ammo1() > 0 then
        self:SetClip1(1)
        owner:SetAmmo(self:Ammo1() - 1, self.Primary.Ammo)
    end

    -- self:RefreshBGs()

    if self:GetMagUpIn() != 0 and CurTime() > self:GetMagUpIn() then
        self:ReloadTimed()
        self:SetMagUpIn( 0 )
    end

    if self:HasBottomlessClip() and self:Clip1() != ArcCW.BottomlessMagicNumber then
        self:Unload()
        self:SetClip1(ArcCW.BottomlessMagicNumber)
    elseif !self:HasBottomlessClip() and self:Clip1() == ArcCW.BottomlessMagicNumber then
        self:SetClip1(0)
    end

    -- Performing traces in rendering contexts seem to cause flickering with c_hands that have QC attachments(?)
    -- Since we need to run the trace every tick anyways, do it here instead
    if CLIENT then
        self:BarrelHitWall()
    end

    self:GetBuff_Hook("Hook_Think")

    -- Running this only serverside in SP breaks animation processing and causes CheckpointAnimation to !reset.
    --if SERVER or !game.SinglePlayer() then
        self:ProcessTimers()
    --end

    -- Only reset to idle if we don't need cycle. empty idle animation usually doesn't play nice
    if self:GetNextIdle() != 0 and self:GetNextIdle() <= CurTime() and !self:GetNeedCycle()
            and self:GetHolster_Time() == 0 and self:GetShotgunReloading() == 0 then
        self:SetNextIdle(0)
        self:PlayIdleAnimation(true)
    end

    if self:GetUBGLDebounce() and !self:GetOwner():KeyDown(IN_RELOAD) then
        self:SetUBGLDebounce( false )
    end
end

local lst = SysTime()

function SWEP:ProcessRecoil()
    local owner = self:GetOwner()
    local ft = (SysTime() - (lst or SysTime())) * GetConVar("host_timescale"):GetFloat()
    local newang = owner:EyeAngles()
    -- local r = self.RecoilAmount -- self:GetNWFloat("recoil", 0)
    -- local rs = self.RecoilAmountSide -- self:GetNWFloat("recoilside", 0)

    local ra = Angle(ang0)

    ra = ra + (self:GetBuff_Override("Override_RecoilDirection", self.RecoilDirection) * self.RecoilAmount * 0.5)
    ra = ra + (self:GetBuff_Override("Override_RecoilDirectionSide", self.RecoilDirectionSide) * self.RecoilAmountSide * 0.5)

    newang = newang - ra

    local rpb = self.RecoilPunchBack
    local rps = self.RecoilPunchSide
    local rpu = self.RecoilPunchUp

    if rpb != 0 then
        self.RecoilPunchBack = math.Approach(rpb, 0, ft * rpb * 10)
    end

    if rps != 0 then
        self.RecoilPunchSide = math.Approach(rps, 0, ft * rps * 5)
    end

    if rpu != 0 then
        self.RecoilPunchUp = math.Approach(rpu, 0, ft * rpu * 5)
    end

    lst = SysTime()
end

function SWEP:InSprint()
    local owner = self:GetOwner()

    local sm = self.SpeedMult * self:GetBuff_Mult("Mult_SpeedMult") * self:GetBuff_Mult("Mult_MoveSpeed")

    sm = math.Clamp(sm, 0, 1)

    local sprintspeed = owner:GetRunSpeed() * sm
    local walkspeed = owner:GetWalkSpeed() * sm

    local curspeed = owner:GetVelocity():Length()

    if TTT2 and owner.isSprinting == true then
        return (owner.sprintProgress or 0) > 0 and owner:KeyDown(IN_SPEED) and !owner:Crouching() and curspeed > walkspeed and owner:OnGround()
    end

    if !owner:KeyDown(IN_SPEED) or !owner:KeyDown(IN_FORWARD+IN_MOVELEFT+IN_MOVERIGHT+IN_BACK) then return false end
    if !owner:OnGround() then return false end
    if owner:Crouching() then return false end
    if curspeed < Lerp(0.5, walkspeed, sprintspeed) then
        -- provide some grace time so changing directions won't immediately exit sprint
        self.LastExitSprintCheck = self.LastExitSprintCheck or CurTime()
        if self.LastExitSprintCheck < CurTime() - 0.25 then
            return false
        end
    else
        self.LastExitSprintCheck = nil
    end

    return true
end

function SWEP:IsTriggerHeld()
    return self:GetOwner():KeyDown(IN_ATTACK) and (self:CanShootWhileSprint() or (!self.Sprinted or self:GetState() != ArcCW.STATE_SPRINT)) and (self:GetHolster_Time() < CurTime()) and !self:GetPriorityAnim()
end

SWEP.LastTriggerTime = 0
SWEP.LastTriggerDuration = 0
function SWEP:GetTriggerDelta(noheldcheck)
    if self.LastTriggerTime <= 0 or (!noheldcheck and !self:IsTriggerHeld()) then return 0 end
    return math.Clamp((CurTime() - self.LastTriggerTime) / self.LastTriggerDuration, 0, 1)
end

function SWEP:DoTriggerDelay()
    local shouldHold = self:IsTriggerHeld()

    local reserve = self:HasBottomlessClip() and self:Ammo1() or self:Clip1()
    if self.LastTriggerTime == -1 or (!self.TriggerPullWhenEmpty and (reserve < self:GetBuff("AmmoPerShot"))) and self:GetNextPrimaryFire() < CurTime() then
        if !shouldHold then
            self.LastTriggerTime = 0 -- Good to fire again
            self.LastTriggerDuration = 0
        end
        return
    end

    if self:GetBurstCount() > 0 and self:GetCurrentFiremode().Mode == 1 then
        self.LastTriggerTime = -1 -- Cannot fire again until trigger released
        self.LastTriggerDuration = 0
    elseif self:GetNextPrimaryFire() < CurTime() and self.LastTriggerTime > 0 and !shouldHold then
        -- Attack key is released. Stop the animation and clear progress
        local anim = self:SelectAnimation("untrigger")
        if anim then
            self:PlayAnimation(anim, self:GetBuff_Mult("Mult_TriggerDelayTime"), true, 0)
        end
        self.LastTriggerTime = 0
        self.LastTriggerDuration = 0
        self:GetBuff_Hook("Hook_OnTriggerRelease")
    elseif self:GetNextPrimaryFire() < CurTime() and self.LastTriggerTime == 0 and shouldHold then
        -- We haven't played the animation yet. Pull it!
        local anim = self:SelectAnimation("trigger")
        self:PlayAnimation(anim, self:GetBuff_Mult("Mult_TriggerDelayTime"), true, 0, nil, nil, true) -- need to overwrite sprint up
        self.LastTriggerTime = CurTime()
        self.LastTriggerDuration = self:GetAnimKeyTime(anim, true) * self:GetBuff_Mult("Mult_TriggerDelayTime")
        self:GetBuff_Hook("Hook_OnTriggerHeld")
    end
end

--PATH lua/weapons/arccw_base/sh_timers.lua:
return gluapack()()
--PATH lua/weapons/arccw_e5c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a280.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-280"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The A280 blaster rifle was a type of blaster rifle mostly used by Rebel Alliance troopers and New Republic soldiers. There existed two variants of the A280 blaster, the A280C and the A280-CFE, both of which were favored by commandos and special force of the Rebel Alliance."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/a280.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_a280.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(0.9, 0.5, -2.9),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 650
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.86
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.75
SWEP.RecoilPunch = 0.8

SWEP.Delay = 60 / 550
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_A280"
SWEP.ShootSound = "ArcCW_Kraken.SW_A280"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.373, -3, 0),
    Ang = Vector(0, 0.1, -3),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, 0)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["optic_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
    ["foregrip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        InstalledEles = {"optic_attach"},
        Offset = {
            vpos = Vector(8.5, -0, 2),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(26, -0.1, 0.25),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        InstalledEles = {"laser_attach"},
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(13.5, 0.6, 0.5),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "A-280 Foregrip",
        Slot = {"foregrip"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        InstalledEles = {"foregrip_attach"},
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(13.4, 0.1, -0.3),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(5.55, -1.0, -1.34),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(2.5, -0.5, 0.09),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/a280/handling_2/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
		MinProgress = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_reload_start.ogg", t = 0.033},
            {s = "ArcCW_Kraken.Overheat", t = 0.67},
            {s = path .. "wfoly_plr_ar_falima_reload_magout_01.ogg", t = 0.65},
            {s = path .. "wfoly_plr_ar_falima_reload_arm.ogg", t = 0.75},
            {s = path .. "wfoly_plr_ar_falima_reload_elbow.ogg", t = 1.45},
			{s = path .. "wfoly_plr_ar_falima_reload_magin_v2_01.ogg", t = 1.5},
			{s = path .. "wfoly_plr_ar_falima_reload_magin_v2_02.ogg", t = 1.75},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.6},
			{s = path .. "wfoly_plr_ar_falima_reload_end.ogg", t = 2.06},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_reload_empty_start.ogg", t = 0},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_rotate.ogg", t = 0.46},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_magout_01.ogg", t = 0.73},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_shake.ogg", t = 0.93},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_arm.ogg", t = 1.63},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_magin_v2_01.ogg", t = 1.83},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_magin_v2_02.ogg", t = 2.1},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_elbow.ogg", t = 2.2},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_boltopen_01.ogg", t = 2.66},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_boltclose_01.ogg", t = 2.96},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_end.ogg", t = 3},
        },
    },
    ["ready"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_raise_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_ar_falima_raise_settle.ogg", t = 0/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_raise_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_ar_falima_raise_settle.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_drop_down.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_ar_falima_inspect_01.ogg", t = 0},
			{s = path .. "wfoly_ar_falima_inspect_02.ogg", t = 1.3},
			{s = path .. "wfoly_ar_falima_inspect_03.ogg", t = 2.36},
			{s = path .. "wfoly_ar_falima_inspect_04.ogg", t = 3.6},
			{s = path .. "wfoly_ar_falima_inspect_05.ogg", t = 4.1},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "weap_ar_falima_selector_off.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cr2hp.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false
-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "CR-2hp"
SWEP.Trivia_Class = "Heavy Pistol"
SWEP.Trivia_Desc = "The CR-2 heavy blaster pistol, also known more simply as a CR-2 blaster pistol, was a heavy blaster pistol manufactured by Corellian Arms that was utilized by the Royal Naboo Security Forces. Small and agile, it had an extreme rate of fire and shoot ionized bolts. It also could be configured with night vision scopes or have an extended stock for reduced recoil."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/cr2hp.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00110110000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_cr2.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(1.2, 0.6, -3.3),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 37
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 550
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 35

SWEP.Recoil = 0.80
SWEP.RecoilSide = 0.40
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 1

SWEP.Delay = 60 / 500
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_CR2"
SWEP.ShootSound = "ArcCW_Kraken.SW_CR2"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(0, 250, 0)
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-1.99, 0, 1.2),
    Ang = Vector(0, 0.2, 2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(1, -0.0, 1.1),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10, 0.8, -1.1),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(10, 0, -1.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(6.5, -0.39, 0.85),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10.4, -0.7, -0.5),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		MinProgress = 0.925,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_up.ogg", t = 0.0},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
            {s = path .. "wfoly_sm_secho_reload_magout.ogg", t = 0.433},
			{s = path .. "wfoly_sm_secho_reload_maghit.ogg", t = 0.867},
			{s = path .. "wfoly_sm_secho_reload_magin.ogg", t = 1.233},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.23},
			{s = path .. "wfoly_sm_secho_reload_end.ogg", t = 1.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
		MinProgress = 0.925,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        LHIK = true,
        SoundTable = {
			{s = path .. "wfoly_sm_secho_reload_empty_up.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_reload_empty_magout.ogg", t = 0.467},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
			{s = path .. "wfoly_sm_secho_reload_empty_mvmnt.ogg", t = 1.133},
			{s = path .. "wfoly_sm_secho_reload_empty_maghit.ogg", t = 1.25},
			{s = path .. "wfoly_sm_secho_reload_empty_magin.ogg", t = 1.35},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.36},
			{s = path .. "wfoly_sm_secho_reload_empty_charge.ogg", t = 1.64},
			{s = path .. "wfoly_sm_secho_reload_empty_end.ogg", t = 1.867},
        },
    },
    ["ready"] = {
        Source = "draw",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise_first_up.ogg", t = 0.0},
            {s = path .. "wfoly_sm_secho_raise_first_charge.ogg", t = 0.5},
            {s = path .. "wfoly_sm_secho_raise_first_end.ogg", t = 0.667},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        LHIK = true,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
		FireASAP = true,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_inspect_magout.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_inspect_magin.ogg", t = 1.967},
			{s = path .. "wfoly_sm_secho_inspect_end.ogg", t = 3.4},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_selectsemi_on.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15a.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15a"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15a.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15a.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.MirrorWorldModel = "models/arccw/kraken/republic/v_dc15a_mirror.mdl"
SWEP.ViewModelFOV = 60


SWEP.WorldModelOffset = {
    pos = Vector(-13, 5, -5),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 70

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.4

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.599, -17.477, 2.947),
    Ang = Vector(0.122, 0.15, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, -5, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "Barrel",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(0, 30, 0),
                    ang = Angle(0, -90, 0)
                },
                IsMuzzleDevice = true
            },
        },
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}, {ind = 4, bg = 0}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic", 
        Bone = "Barrel",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.66, 9.4, 2.5),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "Barrel",
        Offset = {
            vpos = Vector(0.66, 31.5, 0.9),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel", 
        Offset = {
            vpos = Vector(-0.6, 25, 0.9),
            vang = Angle(-90, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "Barrel",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(0.66, 6, -0.7),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"vibroknife"},    
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel",
        Offset = {
            vpos = Vector(1.7, 7, 1.8),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.2, -9, 0.7),
            vang = Angle(0, -90, 0),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 1,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "arccw/kraken/republic/reload_basic.wav", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 65 / 30},
            {s = "ArcCW_Kraken.Grab", t = 70 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 4.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15a_grenadier.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15a Grenadier"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15a_grenadier.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15a.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.MirrorWorldModel = "models/arccw/kraken/republic/v_dc15a_mirror.mdl"
SWEP.ViewModelFOV = 60


SWEP.WorldModelOffset = {
    pos = Vector(-13, 5, -5),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 70

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.4

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.599, -17.477, 2.947),
    Ang = Vector(0.122, 0.15, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, -5, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "Barrel",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(0, 30, 0),
                    ang = Angle(0, -90, 0)
                },
                IsMuzzleDevice = true
            },
        },
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}, {ind = 4, bg = 0}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic", 
        Bone = "Barrel",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.66, 9.4, 2.5),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "Barrel",
        Offset = {
            vpos = Vector(0.66, 31.5, 0.9),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel", 
        Offset = {
            vpos = Vector(-0.6, 25, 0.9),
            vang = Angle(-90, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"ubgl_republica"},
        Bone = "Barrel",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(0.66, 5.3, 0.3),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"vibroknife"},    
    },  
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel",
        Offset = {
            vpos = Vector(1.7, 7, 1.8),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.2, -9, 0.7),
            vang = Angle(0, -90, 0),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 1,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "arccw/kraken/republic/reload_basic.wav", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 65 / 30},
            {s = "ArcCW_Kraken.Grab", t = 70 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 4.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15s_stun.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15sa.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15sa"
SWEP.Trivia_Class = "Blaster Modular Pistol"
SWEP.Trivia_Desc = "The DC-15s side arm blaster was a blaster pistol created by BlasTech Industries for the Grand Army of the Republic. DC-15s pistols were used by clone commandos as a backup in addition to the heavier DC-17m Interchangeable Weapon System. The energy cell kept the blaster recharging at a slow but steady rate."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15sa.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15sa.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-16, 2.5, -5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 45
SWEP.DamageMin = 34
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.Recoil = 0.9
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15SA"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15SA"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-0.6, 0, 2.4),
    Ang = Vector(0, -0.2, 7.833),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(0, -6, -12)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}
SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "DC-15SA Holosight",
        Slot = "optic",
        Bone = "weaponAttach_R",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(4, 0.04, 4.2),
            vang = Angle(0, 0, 0),
        },
        CorrectiveAng = Angle(-5.5, -1, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(6, 1, 1.7),
            vang = Angle(0, 0, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "weaponAttach_R",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Offset = {
            vpos = Vector(8.8, 0.09, 2.8),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(2.76, -0.97, 0.66),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(6.5, -1.1, 1.8),
            vang = Angle(0, 0, 0),
        },
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/republic/dc15sa/draw.wav",
                p = 100,
                v = 100,
                t = 0.01,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/republic/dc15sa/holster.wav",
                p = 100,
                v = 100,
                t = 0.01,
                c = CHAN_ITEM,
            },
        }
    },
    ["fire"] = {
        Source = "fire",
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {
                s = "arccw/kraken/republic/dc15sa/reload.wav",
                p = 100,
                v = 100,
                t = 0.01,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17sa_dual.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc40.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_defender.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Defender"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Defender sporting blaster pistol was made by the Drearian Defense Conglomerate. The DDC Defender was a short range and low-powered weapon, meant for civilian self-defense and small-game hunting. It was also a popular weapon for use in honor duels among the nobility."
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/defender.png"

-- Base
SWEP.DefaultBodygroups = "010000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_defender.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 13
SWEP.RangeMin = 0
SWEP.Range = 270
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 350
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DEFENDER"
SWEP.ShootSound = "ArcCW_Kraken.SW_DEFENDER"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.045, -11.296, 0.8),
    Ang = Angle(0.5,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -1.8, -3.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0, -1.4, 3.9),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.36, -1.35, 2),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.35, -1, -3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.35, -1, -1),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dh17e.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl18d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DL-18d"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DL-18 blaster pistol was a model of blaster pistol commonly used throughout the galaxy, particularly by bounty hunters and smugglers. The blaster, manufactured by BlasTech Industries, was inexpensive and allowed for easy customization; because of this, the blaster pistol became very popular in the Outer Rim. Former Jedi Padawan and Order 66 survivor Kanan Jarrus used a modified DL-18 with a dewback skin handle after the fall of the Jedi Order."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dl18d.png"

-- Base
SWEP.DefaultBodygroups = "011000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dl18.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 7
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 55
SWEP.DamageMin = 27
SWEP.RangeMin = 0
SWEP.Range = 440
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 0.8
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 180
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DL18"
SWEP.ShootSound = "ArcCW_Kraken.SW_DL18"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.043, -11.296, 1.7),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.0, -1.75, -2.1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0., -1.45, 7.8),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.05, -1.49, 3.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -1.3, 0.4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.6, -1.2, -6.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl18e.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DL-18e"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DL-18 blaster pistol was a model of blaster pistol commonly used throughout the galaxy, particularly by bounty hunters and smugglers. The blaster, manufactured by BlasTech Industries, was inexpensive and allowed for easy customization; because of this, the blaster pistol became very popular in the Outer Rim. Former Jedi Padawan and Order 66 survivor Kanan Jarrus used a modified DL-18 with a dewback skin handle after the fall of the Jedi Order."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dl18.png"

-- Base
SWEP.DefaultBodygroups = "010000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dl18.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 0.85
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 180
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DL18"
SWEP.ShootSound = "ArcCW_Kraken.SW_DL18"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.043, -11.296, 1.7),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)
-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.0, -1.75, -2.1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0., -1.45, 7.8),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.05, -1.49, 3.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -1.3, 0.4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.6, -1.2, -6.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl44e.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt20c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt20x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-20x"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DLT-20A blaster rifle, also known as the DLT-20A laser rifle, was a model of blaster rifle and longblaster produced by BlasTech Industries. Members of the Galactic Empire's Stormtrooper Corps sometimes used DLT-20As instead of their standard issue E-11 medium blaster rifles. IG-assassin droid IG-11 carried this model of rifle, without the scope attached. Another type of rifle, the pulse cannon, utilized the frame assembly of a DLT-20A. Han Solo used a DLT-20A as a sniper rifle during the Battle of Vrogas Vas."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.IconOverride = "entities/kraken/galactic/dlt20x.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00100000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dlt20a.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 130
SWEP.DamageMin = 90
SWEP.RangeMin = 0
SWEP.Range = 900
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "nio_tracer"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.28
SWEP.RecoilSide = 0.76
SWEP.RecoilRise = 0.98
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 180
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 4,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.855
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DLT20"
SWEP.ShootSound = "ArcCW_Kraken.SW_DLT20"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.994, 0, 0.004),
    Ang = Vector(2.042, 0, 0),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 2, -1)
SWEP.ActiveAng = Angle(2, 0, -2)

SWEP.SprintPos = Vector(4.019, -5.226, -3)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(0, 0, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 24, 2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.1, 1, 2.4),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.05),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 8.5, 0.9),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 25.3, 0.9),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0., 6, 0.2),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.8, -0.2, -0.8),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -0.33, 0.2),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_e9.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "E-9"
SWEP.Trivia_Class = "Blaster, Rifle"
SWEP.Trivia_Desc = "Before the E-10 and E-11, the E-9 existed as a prototype of the capabilities of the future weapons. It development started during the final months of the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.IconOverride = "entities/kraken/galactic/e9.png"

-- Base
SWEP.DefaultBodygroups = "00000200000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_e11.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-15, 8, -9),
    ang = Angle(-30, 25, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 30
SWEP.DamageMin = 24
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 4000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.65
SWEP.Recoil = 0.75

SWEP.Delay = 60 / 420
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 120
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "ArcCW_Kraken.SW_E9"
SWEP.ShootSound = "ArcCW_Kraken.SW_E9"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.379, -6.961, 2.5),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4.5, -2, 1.5)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11_GUN",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 13, -2),
                   ang = Angle(-90, -90, 0)
               },
               IsMuzzleDevice = true
           }
        }
    },
    ["e11_grip_standard"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "E11_GUN",
        Offset = {
            vpos = Vector(0.12, -4.5, 2.4),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "E11_GUN",
        Offset = {
            vpos = Vector(0.1, 9, 1),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "E11_GUN",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.5, 4, 1),
            vang = Angle(0, -90, -90),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "Standard E-11 Grip",
        Slot = {"foregrip", "sw_ubgl", "e11_grid"},
        Bone = "E11_GUN",
        InstalledEles = {"e11_grip_standard"},
        Offset = {
            vpos = Vector(-0, 0.2, 2.5),
            vang = Angle(90, -90, -90),   
        },
        SlideAmount = {
        vmin = Vector(0.2, 4, 0.4),
        vmax = Vector(0.2, 6, 0.5),
        },    
    },
    {
        PrintName = "Energization",
        DefaultAttName = "Red Tibanna",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11_GUN",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.13, -6.75, 1.11),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "E11_GUN",
        VMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0.9, -1.1, 0.9),
            vang = Angle(0, -90, 0),
        },
    },
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/e9/e11_reload.wav", t = 0.1 },
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_fwmb10h.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "FWMB-10H"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The FWMB-10 repeating blaster, also known as the megablaster,[3] was a repeating blaster manufactured by the Sonn-Blas Corporation.[1] The FWMB-10s used by First Order megablaster heavy assault troopers—who earned their name from their use of the blaster[1]— featured integrated stands that could fold out from the blaster,[4] as well as barrel cooling shrouds.[1] Light Infantry Utility Vehicles also used pintle-mounted megablasters as their primary armament.[1] These forward-mounted[5] FWMB-10s had steadying grips and trigger levers, data and power feeds, calibration adjustment, elevation gear, a collimator ring, and collimator sleeves.[1] It was powered by an Eksoan Class-5B1 duplex power generator.[6] The FWMB-10K was a smaller variant of the FWMB-10.[7]"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/fwmb10h.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_fwmb10k.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 35
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 30
SWEP.DamageMin = 26
SWEP.RangeMin = 0
SWEP.Range = 450
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 350
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_FWMB"
SWEP.ShootSound = "ArcCW_Kraken.SW_FWMB"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.138, 0, 0.982),
    Ang = Vector(0, 0, -4.242),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, -4)

SWEP.CrouchPos = Vector(0, 0, 1)
SWEP.CrouchAng = Angle(0, 0, -4)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-1.2, 10.15, 0.3),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.2, 22, 0.),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-0., 7, -0.8),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.4, -3.6, 0.5),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.1, 0, -0.35),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_fwmb10k.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_j1.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_base.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_decoy.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Decoy Grenade"
SWEP.Trivia_Class = "Grenade, Decoy"
SWEP.Trivia_Desc = "When thrown, the decoy grenade emulates the sound of the most powerful weapon you are carrying, creating the illusion of additional supporting forces."
SWEP.IconOverride = "entities/kraken/explosives/decoy.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_grenade_train.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-16, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}


-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_decoy"

SWEP.MuzzleVelocity = 900
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_detonite.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_flashbang.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_flashbang.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Flash Grenade"
SWEP.Trivia_Class = "Hand Grenade, Disorienting"
SWEP.Trivia_Desc = "A flash grenade, also known as a flash bomb was a type of non-lethal grenade which, when activated, created a bright energy flash and loud noise to disorient opponents It also gave a mild impact although it was not as destructive as thermal detonators, and was capable of disabling droids for a short period of time. One variant of the grenade could split into several fragments and individually explode."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Explosive"
SWEP.Trivia_Mechanism = "Flashbang"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/flash.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_grenade_flash.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-16, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_flash"

SWEP.MuzzleVelocity = 900
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_shock.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Shock Grenade"
SWEP.Trivia_Class = "Hand Grenade, Shock"
SWEP.Trivia_Desc = "Shock grenades were a type of grenades that delivered a non-lethal electrical discharge, rendering those caught in the field incapable of moving."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Electrical Shock"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Galactic Empire"
SWEP.IconOverride = "entities/kraken/explosives/shock.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_shock.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-16, 7, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}
-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_shock"

SWEP.MuzzleVelocity = 900
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_sonar.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Sonar Grenade"
SWEP.Trivia_Class = "Grenade, Sonar"
SWEP.Trivia_Desc = "Once thrown, the Sonar Grenade emits a pulse revealing the location of nearby enemies that goes through walls"
SWEP.Trivia_Manufacturer = "BlastTech Industries, Merr Sonn Munitions Inc."
SWEP.Trivia_Calibre = "Sonar"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/sonar.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_sonar.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-15, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_sonar"

SWEP.MuzzleVelocity = 1200
SWEP.MuzzleVelocityAlt = 700

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_thermite.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Thermite Grenade"
SWEP.Trivia_Class = "Blaster, Carbine"
SWEP.Trivia_Desc = "The E-9d blaster carbine was a blaster carbine manufactured by BlasTech Industries designed for Republic Special Forces."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Laser Bolt"
SWEP.Trivia_Mechanism = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/kraken/explosives/incendiary.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_thermalimploder.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-16, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_incen"

SWEP.MuzzleVelocity = 900
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nt242e.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_rt97.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "RT-97"
SWEP.Trivia_Class = "Heavy Blaster Rifle"
SWEP.Trivia_Desc = "The RT-97C heavy blaster rifle was a model of heavy blaster rifle that saw use during the Galactic Civil War. It was a versatile heavy rifle, fitted with optics that allowed use at long range. Imperial sandtroopers were known to use them, as were jumptroopers."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/rt97.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0100000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_rt97c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-9, 7, 2),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 32
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.86
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.75
SWEP.RecoilPunch = 0.8

SWEP.Delay = 60 / 550
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_RT97"
SWEP.ShootSound = "ArcCW_Kraken.SW_RT97"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(25, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-6.133, -10.502, -7.042),
    Ang = Vector(2.184, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 0, -8)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, -8)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -11)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, -8)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, -9)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(1.9, -0, 5.6),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(40, -0.1, 4.8),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(25, 0.4, 4.7),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_weapon",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(8, 0.1, 3.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2, -1.1, 4.75),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-3, -1.1, 4.65),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "fire",
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.925,
        Mult = 0.9,
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.1},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/empty_charge.wav", t = 1.1},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_out.wav", t = 3.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 4.5},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_in.wav", t = 4.5},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
		MinProgress = 0.925,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/empty_charge.wav", t = 0.1},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/empty_charge.wav", t = 1.1},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_out.wav", t = 3.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 4.5},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_in.wav", t = 4.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_in.wav", t = 7},
        },
    },
    ["ready"] = {
        Source = "pullout_first",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.0},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 0.5},
        },
    },
    ["holster"] = {
        Source = "putaway",
        SoundTable = {
            {s = "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["draw"] = {
        Source = "pullout",
        SoundTable = {
            {s = "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["fix"] = {
        Source = "pullout_first",
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.1},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 0.6},
            {s = "ArcCW_Kraken.Overheat", t = 0.1},
            {s = "ArcCW_Kraken.OverheatFix", t = 0.9},
        },
    },
    ["idle_sprint"] = {
        Source = "base_sprint_loop",
    },
    ["exit_sprint"] = {
        Source = "base_sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "base_sprint_in",
		Time = 1.25,
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_valken38.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Valken 38x"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The Valken-38x was a model of longblaster that was manufactured for high precision and power over long ranges. It was utilized by the Galactic Republic during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/valken38.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_valken38.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-8, 3.5, -4),
    ang = Angle(-10, -90, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 1
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 98
SWEP.DamageMin = 76
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 1.2
SWEP.RecoilSide = 1.5
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.85
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_VALKEN"
SWEP.ShootSound = "ArcCW_Kraken.SW_VALKEN"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.65, -5, 2.515),
    Ang = Vector(-0.25, 0, 9),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 60,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -2, -2)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, 0, -2)
SWEP.HolsterAng = Angle(0, 30, -15)

SWEP.Bipod_Integral = true
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

-- Attachments 
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
    ["sw_sling"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
}


SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Valken Holosight",
        Slot = {"optic"},
        Bone = "Weapon",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.05, 6.2, 2.15),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "Weapon",
        Offset = {
            vpos = Vector(-0.8, 26, 1),
            vang = Angle(0, -90, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Valken 38 Muzzle",
        InstalledEles = {"muzzle_attach"},
        VMScale = Vector(1.6, 1.6, 1.6),
        WMScale = Vector(1.6, 1.6, 1.6),
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "Weapon",
        Offset = {
            vpos = Vector(-0.05, 28, 1.1),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_sniper"},
    },   
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"vibroknife", "sw_sling"},
        Bone = "Weapon",
    },
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "Weapon",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.09, -0, -0.39),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "Weapon",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.45, -5.3, 1),
            vang = Angle(0, -90, 0),
        },
    },
}


-- Animations
local path = "arccw/kraken/republic/valken38/handling/"

SWEP.Animations = {
    ["idle"] = { Source = "base_idle" },
    ["idle_empty"] = { Source = "empty_idle" },
    ["fire"] = { Mult = 0.667, Source = {
        "base_fire",
        "base_fire2",
    } },
    ["fire_iron"] = { Mult = 0.667, Source = {
        "iron_fire_1",
        "iron_fire_2",
        "iron_fire_3",
    } },
    ["fire_empty"] = { Mult = 1, Source = "base_firelast" },
    ["fire_iron_empty"] = { Mult = 1, Source = "iron_firelast" },
    ["dryfire"] = { Source = "base_dryfire" },
    ["dryfire_iron"] = { Source = "iron_dryfire" },
    ["bash"] = { Source = "base_melee_end" },
    ["bash_empty"] = { Source = "base_melee_end_empty" },
    ["reload"] = { Source = "base_reload", TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, MinProgress = 0.75, SoundTable = {
        {t = 35 / 33, s = path .. "magrelease.wav"},
        {t = 40 / 33, s = path .. "magout.wav"},
        {t = 50 / 33, s = path .. "mag_fetch.wav"},
        {t = 107 / 33, s = path .. "magin.wav"},
        {t = 117 / 33, s = path .. "maghit.wav"},
        {t = 142 / 33, s = path .. "rattle.wav"},
    } },
    ["draw"] = { Source = "base_draw",         SoundTable = {
        {
            s = "arccw/kraken/empire/draw_rifle.wav",
            p = 100,
            v = 100,
            t = 0.1,
            c = CHAN_ITEM,
        },
    } },
    ["holster"] = { Source = "base_holster",  SoundTable = {
        {
            s = "arccw/kraken/empire/draw_rifle.wav",
            p = 100,
            v = 100,
            t = 0.1,
            c = CHAN_ITEM,
        },
    } },
    ["enter_bipod"] = { Source = "deployed_in", SoundTable = {
        {t = 0},
    } },
    ["exit_bipod"] = { Source = "deployed_out", SoundTable = {
        {t = 0},
    } },
    ["idle_bipod"] = { Source = "deployed_idle" },
    ["idle_iron_bipod"] = { Source = "deployed_iron_idle" },
    ["idle_bipod_empty"] = { Source = "deployed_idle_empty" },
    ["idle_iron_bipod_empty"] = { Source = "deployed_iron_idle_empty" },
    ["bipod"] = { Source = {
        "deployed_fire_1",
        "deployed_fire_2"
    } },
    ["fire_iron_bipod"] = { Source = {
        "deployed_iron_fire_1",
        "deployed_iron_fire_2"
    } },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_weapon_g125.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_westar35.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_z6.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_z6.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 

SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Z-6"
SWEP.Trivia_Class = "Blaster, Rotatory Cannon"
SWEP.Trivia_Desc = "The Z-6 rotary blaster cannon was a blaster cannon used by the Galactic Republic during the Clone Wars. Later, during the reign of the Galactic Empire, these weapons were used by both the Imperial Army's Heavy Weapons Stormtroopers and Rebel Alliance's Heavy Soldiers during the Galactic Civil War."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/z6.png"

-- Base
SWEP.MirrorVMWM = false
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = false
SWEP.ViewModel = "models/arccw/kraken/republic/v_z6.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 65

SWEP.HideViewmodel = false

SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Special properties
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 85
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

SWEP.TriggerDelay = true 

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 18
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 1200

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 10
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 200
SWEP.ExtendedClipSize = 250
SWEP.ReducedClipSize = 100

SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.3
SWEP.Recoil = 0.5

SWEP.Delay = 60 / 270
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 5.5
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

-- Speed Mult
SWEP.SpeedMult = 0.875
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.8

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_Z6"
SWEP.ShootSound = "ArcCW_Kraken.SW_Z6"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "arccw/kraken/empire/silenced.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.9, -6.961, 2.45),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(1, 0, -1)
SWEP.SprintAng = Angle(0, 0, 15)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, -5)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(3, 0, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

-- Attachments
SWEP.DefaultElements = {"z6"}
SWEP.AttachmentElements = {
    ["z6"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/republic/v_z6.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 0, bg = 0}},
                Offset = {
                    pos = Vector(250, 0, 600),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(450, 0, -100),
                    ang = Angle(-15, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/arccw/kraken/republic/v_z6.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode"},
    },   
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
}

local path = "arccw/kraken/republic/z6rotaryblaster/handling/"


SWEP.TriggerDelay = true

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
        SoundTable = {
            {s = path .. "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_gunner_loop_01.wav", v = 0.2, t = 0.01},
			{s = path .. "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_start_short_var_01_04.wavqqqqqq", v = 0.3, t = 4/30},
        },
    },
    ["trigger"] = {
        Source = "windup",
        SoundTable = {
            {
                s = "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_start_short_var_01_04.wav",
                p = 100,
                v = 100,
                t = 0.01,
                c = CHAN_ITEM,
            },
        }
    },
    ["untrigger"] = {
        Source = "windup",
        SoundTable = {
            {
                s = "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_gunner_stop_01.wav",
                p = 100,
                v = 100,
                t = 0.05,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "jam_fix",
		MinProgress = 0.8,
        Mult = 2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
			{s = "ArcCW_Kraken.Overheat", t = 0.01},
			{s = "ArcCW_Kraken.OverheatReplenished", t = 1.5},
        },
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.7,
		FireASAP = true,
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Mult = 3,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Mult = 3,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_lm_dblmg_inspect_01.ogg", t = 18/30},
			{s = path .. "wfoly_lm_dblmg_inspect_02.ogg", t = 56/30},
			{s = path .. "wfoly_lm_dblmg_inspect_03.ogg", t = 109/30},
        },
    },
    ["bash"] = {
        Source = "melee",
    },
}

-- Special properties
SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_z6adv.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_z6adv.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 

SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Z-6 Advanced"
SWEP.Trivia_Class = "Blaster, Rotatory Cannon"
SWEP.Trivia_Desc = "The Z-6 rotary blaster cannon was a blaster cannon used by the Galactic Republic during the Clone Wars. Later, during the reign of the Galactic Empire, these weapons were used by both the Imperial Army's Heavy Weapons Stormtroopers and Rebel Alliance's Heavy Soldiers during the Galactic Civil War."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/z6_adv.png"

-- Base
SWEP.MirrorVMWM = false
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = false
SWEP.ViewModel = "models/arccw/kraken/republic/v_z6.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 65

SWEP.HideViewmodel = false

SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Special properties
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 100
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

SWEP.TriggerDelay = true 

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 28
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 350
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 1200

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 10
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 200
SWEP.ExtendedClipSize = 250
SWEP.ReducedClipSize = 100

SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.3
SWEP.Recoil = 0.5

SWEP.Delay = 60 / 270
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 5.5
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

-- Speed Mult
SWEP.SpeedMult = 0.875
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.8

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_Z6"
SWEP.ShootSound = "ArcCW_Kraken.SW_Z6"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "arccw/kraken/empire/silenced.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.9, -6.961, 2.45),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(1, 0, -1)
SWEP.SprintAng = Angle(0, 0, 15)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, -5)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(3, 0, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

-- Attachments
SWEP.DefaultElements = {"z6"}
SWEP.AttachmentElements = {
    ["z6"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/republic/v_z6.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 0, bg = 0}},
                Offset = {
                    pos = Vector(250, 0, 600),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(450, 0, -100),
                    ang = Angle(-15, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/arccw/kraken/republic/v_z6.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode"},
    },   
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
}

local path = "arccw/kraken/republic/z6rotaryblaster/handling/"


SWEP.TriggerDelay = true

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
        SoundTable = {
            {s = path .. "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_gunner_loop_01.wav", v = 0.2, t = 0.01},
			{s = path .. "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_start_short_var_01_04.wavqqqqqq", v = 0.3, t = 4/30},
        },
    },
    ["trigger"] = {
        Source = "windup",
        SoundTable = {
            {
                s = "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_start_short_var_01_04.wav",
                p = 100,
                v = 100,
                t = 0.01,
                c = CHAN_ITEM,
            },
        }
    },
    ["untrigger"] = {
        Source = "windup",
        SoundTable = {
            {
                s = "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_gunner_stop_01.wav",
                p = 100,
                v = 100,
                t = 0.05,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "jam_fix",
		MinProgress = 0.8,
        Mult = 2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
			{s = "ArcCW_Kraken.Overheat", t = 0.01},
			{s = "ArcCW_Kraken.OverheatReplenished", t = 1.5},
        },
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.7,
		FireASAP = true,
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Mult = 3,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Mult = 3,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_lm_dblmg_inspect_01.ogg", t = 18/30},
			{s = path .. "wfoly_lm_dblmg_inspect_02.ogg", t = 56/30},
			{s = path .. "wfoly_lm_dblmg_inspect_03.ogg", t = 109/30},
        },
    },
    ["bash"] = {
        Source = "melee",
    },
}

-- Special properties
SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_masita_explosives_base.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = false -- this obviously has to be set to true

// names and stuff
SWEP.PrintName = "Masita ArcCW Weapon Base"
SWEP.Category = "[MASITA] ArcCW Weapon Base"

SWEP.Description = ""

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.ViewModelFOV = 56
SWEP.MirrorVMWM = nil --Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = nil -- Use this to set the mirrored viewmodel to a different model, without any floating speedloaders or cartridges you may have. Needs MirrorVMWM

--[[SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}]]

SWEP.PresetBase = nil -- make this weapon share saves with this one.

SWEP.KillIconAlias = nil -- set to other weapon class to share select and kill icons

SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.WorldModelOffset = nil
-- {
--     pos = Vector(0, 0, 0),
--     ang = Angle(0, 0, 0)
-- }

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 26
SWEP.DamageMin = 10 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 0 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s
SWEP.PhysBulletMuzzleVelocity = nil -- override phys bullet muzzle velocity
SWEP.PhysBulletDrag = 1
SWEP.PhysBulletGravity = 1
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.BodyDamageMults = nil
-- if a limb is not set the damage multiplier will default to 1
-- that means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 0 -- color for phys tracer.
-- there are 8 options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible
SWEP.HullSize = 1.5 -- HullSize used by FireBullets

function SWEP:DoImpactEffect(tr, dmgtype)
    if tr.HitSky then return true end

    util.Decal("fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal);
    if( game.SinglePlayer() or SERVER or not self:IsCarriedByLocalPlayer() or IsFirstTimePredicted() ) then
        local soundToPlay = "impacts/sw752_hit_1.wav"
        local randomSound = math.random(1,14)
        if randomSound == 1 then
            soundToPlay = "impacts/sw752_hit_4.wav"
        elseif randomSound == 2 then
            soundToPlay = "impacts/sw752_hit_5.wav"
        elseif randomSound == 3 then
            soundToPlay = "impacts/sw752_hit_9.wav"
        elseif randomSound == 4 then
            soundToPlay = "impacts/sw752_hit_10.wav"
        elseif randomSound == 5 then
            soundToPlay = "impacts/sw752_hit_12.wav"
        elseif randomSound == 6 then
            soundToPlay = "impacts/sw752_hit_13.wav"
        elseif randomSound == 7 then
            soundToPlay = "impacts/sw752_hit_14.wav"
        elseif randomSound == 8 then
            soundToPlay = "impacts/sw752_hit_19.wav"
        elseif randomSound == 9 then
            soundToPlay = "impacts/sw752_hit_27.wav"
        elseif randomSound == 10 then
            soundToPlay = "impacts/sw752_hit_28.wav"
        elseif randomSound == 11 then
            soundToPlay = "impacts/sw752_hit_30.wav"
        elseif randomSound == 12 then
            soundToPlay = "impacts/sw752_hit_31.wav"
        elseif randomSound == 13 then
            soundToPlay = "impacts/sw752_hit_17.wav"
        end

    
        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetNormal(tr.HitNormal)

        sound.Play( soundToPlay, tr.HitPos, 75, 100, 1 );

        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetStart(tr.StartPos)
        effect:SetDamageType(dmgtype)

        util.Effect("RagdollImpact", effect)
    end

    return true;
end

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 25 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 10

-- But if you insist...
SWEP.ForceDefaultClip = nil
SWEP.ForceDefaultAmmo = nil

-- The amount of rounds to load in the chamber when the gun is non-empty or empty
-- Defaults to ChamberSize and 0. Don't change unless you have a good reason
SWEP.ChamberLoadNonEmpty = nil
SWEP.ChamberLoadEmpty = nil

SWEP.AmmoPerShot = 1
SWEP.InfiniteAmmo = false -- weapon can reload for free
SWEP.BottomlessClip = false -- weapon never has to reload

SWEP.DoNotEquipmentAmmo = false -- do not automatically give this weapon unique ammo when arccw_equipmentammo is used

SWEP.ShotgunReload = false -- reloads like shotgun instead of magazines
SWEP.HybridReload = false -- reload normally when empty, reload like shotgun when part full

SWEP.ManualAction = false -- pump/bolt action
SWEP.NoLastCycle = false -- do not cycle on last shot

SWEP.RevolverReload = false -- cases all eject on reload

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.CanFireUnderwater = false

SWEP.Disposable = false -- when all ammo is expended, the gun will remove itself when holstered

SWEP.AutoReload = false -- when weapon is drawn, the gun will reload itself.

SWEP.IsShotgun = false -- weapon receives shotgun ammo types

SWEP.TriggerDelay = false -- Set to true to play the "trigger" animation before firing. Delay time is dependent on animation time.

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = -1
SWEP.VisualRecoilMult = 1.25
SWEP.RecoilPunch = 1.5
SWEP.RecoilPunchBackMax = 1
SWEP.RecoilPunchBackMaxSights = nil -- may clip with scopes
SWEP.RecoilVMShake = 1 -- random viewmodel offset when shooty

SWEP.Sway = 0

SWEP.ShotgunSpreadDispersion = false -- dispersion will cause pattern to increase instead of shifting
SWEP.ShotgunSpreadPattern = nil
SWEP.ShotgunSpreadPatternOverrun = nil
-- {Angle(1, 1, 0), Angle(1, 0, 0) ..}
-- list of how far each pellet should veer
-- if only one pellet then it'll use the first index
-- if two then the first two
-- in case of overrun pellets will start looping, preferably with the second one, so use that for the loopables
-- precision will still be applied

SWEP.RecoilDirection = Angle(1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1, 0)

SWEP.Delay = 60 / 750 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 1 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    -- {
    --     Mode = 1,
    --     CustomBars = "---_!",
    -- }
}

--[[
	Custom bar setup
	Colored variants        Classic
	'a' Filled              '-' Filled
	'b' Outline             '_' Outline
	'd' CLR w Outline       '!' Red w Outline
	'#' Empty
]]
--     PrintName = "PUMP",
--     RunAwayBurst = false,
--     AutoBurst = false, -- hold fire to continue firing bursts
--     PostBurstDelay = 0,
--     ActivateElements = {}

SWEP.ShotRecoilTable = nil -- {[1] = 0.25, [2] = 2} etc.

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace
-- if nil, this will be based on holdtype
SWEP.NPCWeight = 100 -- relative likeliness for an NPC to have this weapon
SWEP.TTTWeaponType = nil -- string or table, like NPCWeaponType but specifically for TTT weapons (takes precdence over NPCWeaponType)
SWEP.TTTWeight = 100 -- like NPCWeight but for TTT gamemode

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights
SWEP.JumpDispersion = 300 -- dispersion penalty when in the air

SWEP.Bipod_Integral = false -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 125 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = nil
SWEP.ShootSound = ""
SWEP.ShootSoundLooping = nil
SWEP.FirstShootSoundSilenced = nil
SWEP.ShootDrySound = nil -- Add an attachment hook for Hook_GetShootDrySound please!
SWEP.DistantShootSound = nil
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.ShootSoundSilencedLooping = nil
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.EnterBipodSound = "weapons/arccw/bipod_down.wav"
SWEP.ExitBipodSound = "weapons/arccw/bipod_up.wav"
SWEP.SelectUBGLSound =  "weapons/arccw/ubgl_select.wav"
SWEP.ExitUBGLSound = "weapons/arccw/ubgl_exit.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects
SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil
SWEP.ShellEffect = nil
SWEP.ShellEjectPosCorrection = nil
SWEP.ShellScale = 1
SWEP.ShellPhysScale = 1
SWEP.ShellPitch = 100
SWEP.ShellSounds = "autocheck"--ArcCW.ShellSoundsTable
SWEP.ShellRotate = 0
SWEP.ShellTime = 0.5

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on
SWEP.ProceduralViewBobAttachment = nil -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.CamAttachment = nil -- if set, this attachment will control camera movement
SWEP.MuzzleFlashColor = Color(0, 110, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.KeepBaseIrons = false -- do not override iron sights when scope installed
SWEP.BaseIronsFirst = false -- If a sight keeps base irons, irons comes first

SWEP.IronSightStruct = {
    Pos = Vector(-8.728, -13.702, 4.014),
    Ang = Angle(-1.397, -0.341, -2.602),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 15, -4),
        Ang = Angle(0, 0, -45),
    },
    Magnification = 1,
    BlackBox = false,
    ScopeTexture = nil,
    SwitchToSound = "", -- sound that plays when switching to this sight
    SwitchFromSound = "",
    ScrollFunc = ArcCW.SCROLL_NONE,
    CrosshairInSights = false,
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

-- Override free aim convar and variable
SWEP.FreeAimAngle = nil -- defaults to HipDispersion / 80. overwrite here
SWEP.NeverFreeAim = nil
SWEP.AlwaysFreeAim = nil

-- If Jamming is enabled, a heat meter will gradually build up until it reaches HeatCapacity.
-- Once that happens, the gun will overheat, playing an animation. If HeatLockout is true, it cannot be fired until heat is 0 again.
SWEP.Jamming = false
SWEP.HeatCapacity = 200 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = false -- when the "fix" animation is played, all heat is restored.
SWEP.HeatOverflow = nil -- if true, heat is allowed to exceed capacity (this only applies when the default overheat handling is overridden)

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"
SWEP.HoldtypeNPC = nil

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.GuaranteeLaser = false -- GUARANTEE that the laser position will be accurate, so don't bother with sighted correction

SWEP.ShieldProps = nil
-- {
--     {
--         Model = "",
--         Pos = Vector(0, 0, 0),
--         Ang = Angle(0, 0, 0),
--         Bone = "", -- leave blank for valvebiped right hand
--         Resistance = 5, -- one unit of this object counts for how much penetration amount
--     }
-- }

SWEP.CanBash = true
SWEP.PrimaryBash = false -- primary attack triggers melee attack

SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.ReloadPos = nil
SWEP.ReloadAng = nil

SWEP.CrouchPos = nil
SWEP.CrouchAng = nil

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

-- When using custom sprint animations, set this to the same as ActivePos and ActiveAng
SWEP.SprintPos = nil
SWEP.SprintAng = nil

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = nil

SWEP.DefaultPoseParams = {} -- {["pose"] = 0.5}
SWEP.DefaultWMPoseParams = {}

SWEP.DefaultElements = {} -- {"ele1", "ele2"}

SWEP.AttachmentElements = {
    -- ["name"] = {
    --     RequireFlags = {}, -- same as attachments
    --     ExcludeFlags = {},
    --     NamePriority = 0, -- higher = more likely to be chosen
    --     NameChange = "",
    --     TrueNameChange = "",
    --     AddPrefix = "",
    --     AddSuffix = "",
    --     VMPoseParams = {}, -- {["pose"] = 0.5}
    --     VMColor = Color(),
    --     VMMaterial = "",
    --     VMBodygroups = {{ind = 1, bg = 1}},
    --     VMElements = {
    --         {
    --             Model = "",
    --             Bone = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             ModelSkin = 0,
    --             ModelBodygroups = "",
    --             Scale = Vector(1, 1, 1),
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     VMOverride = "", -- change the view model to something else. Please make sure it's compatible with the last one.
    --     VMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     WMPoseParams = {}, -- {["pose"] = 0.5}
    --     WMColor = Color(),
    --     WMMaterial = "",
    --     WMBodygroups = {},
    --     WMElements = {
    --         {
    --             Model = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     WMOverride = "", -- change the world model to something else. Please make sure it's compatible with the last one.
    --     WMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     AttPosMods = {
    --         [1] = {
    --             bone = "", -- optional
    --             vpos = Vector(0, 0, 0),
    --             vang = Angle(0, 0, 0),
    --             wpos = Vector(0, 0, 0),
    --             wang = Angle(0, 0, 0),
    --             SlideAmount = { -- only if base att has slideable
    --                 vmin = Vector(0, 0, 0),
    --                 vmax = Vector(0, 0, 0),
    --                 wmin = Vector(0, 0, 0),
    --                 wmax = Vector(0, 0, 0)
    --             }
    --         }
    --     }
    -- }
}

SWEP.RejectAttachments = {
    -- ["optic_docter"] = true -- stop this attachment from being usable on this gun
}

SWEP.AttachmentOverrides = {
    -- ["optic_docter"] = {} -- allows you to overwrite atttbl values
}

SWEP.TTT_DoNotAttachOnBuy = false -- don't give all attachments when bought

SWEP.Attachments = {}
-- [1] = {
--     PrintName = "Optic", -- print name
--     DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
--     DefaultAttIcon = Material(),
--     Slot = "pic_sight", -- what kind of attachments can fit here
--     MergeSlots = {}, -- these other slots will be merged into this one.
--     Bone = "sight", -- relevant bone any attachments will be mostly referring to
--     WMBone = "ValveBiped.Bip01_L_Hand", -- set it to change parent bone of attachment WM
--     KeepBaseIrons = false,
--     ExtraSightDist = 0,
--     Offset = {
--         vpos = Vector(0, 0, 0), -- offset that the attachment will be relative to the bone
--         vang = Angle(0, 0, 0),
--         wpos = Vector(0, 0, 0), -- same, for the worldmodels
--         wang = Angle(0, 0, 0)
--     },
--     RejectAttachments = {}, -- specific blacklist of attachments this slot cannot accept. Needs to be like {"optic_mrs" = true}
--     VMScale = Vector(1, 1, 1),
--     WMScale = Vector(1, 1, 1),
--     SlideAmount = { -- how far this attachment can slide in both directions.
--         -- overrides Offset.
--         vmin = Vector(0, 0, 0),
--         vmax = Vector(0, 0, 0),
--         wmin = Vector(0, 0, 0),
--         wmax = Vector(0, 0, 0),
--     },
--     CorrectiveAng = Vector(1, 1, 1), -- okay, I know I said sights were pain-free.
--     CorrectivePos = Vector(0, 0, 0), -- that won't always be the case. Use these to fix it. Issues mainly crop up in case of sights parented to bones that are not a root bone.
--     InstalledEles = {"toprail"}, -- activate these AttachmentElements if something is installed
--     DefaultEles = {""} -- activeate these AttachmentElements *unless* something is installed
--     Hidden = false, -- attachment cannot be seen in customize menu
--     Integral = false, -- attachment is assumed never to change
--     RandomChance = 1, -- multiplies chance this slot will get a random attachment
--     DoNotRandomize = false,
--     NoWM = false, -- do not make this show up on worldmodel
--     NoVM = false, -- what do *you* think this one does?
--     FreeSlot = false, -- slot does not count towards attachment capacity
--     -- ABOUT THE FLAG SYSTEM:
--     -- Attachments and slots can give flags
--     -- All attachments automatically give themselves as a flag, e.g. "optic_mrs"
--     -- If requirements are not satisfied, the slot or attachment will not be attachable
--     ExcludeFlags = {}, -- if the weapon has this flag, hide this slot
--     RequireFlags = {}, -- if the weapon does not have all these flags, hide this slot
--     GivesFlags = {} -- give these slots if something is installed here
--     HideIfBlocked = false, -- If flag requirements are not met, do not show the attachment at all
-- }

-- ready: deploy first time
-- draw
-- holster
-- reload
-- fire
-- cycle (for bolt/pump actions)
-- bash
-- fix
-- enter_bipod
-- exit_bipod
-- enter_sight
-- exit_sight
-- a_to_b: switch from firemode a to firemode b. e.g.: 1_to_2
-- idle
-- idle_sights
-- idle_sprint
-- idle_bipod
-- enter_inspect
-- idle_inspect
-- exit_inspect
-- enter_ubgl
-- exit_ubgl
-- idle_ubgl

-- you can append suffixes for different states
-- append list:

-- _iron, _sights, or _sight     for sighted variation
-- _sprint                       for sprinting variation
-- _bipod                        for bipod variation
-- _empty                        for empty variation
-- _jammed                       for jammed variation

-- this does not apply to reload animations.

-- !! they MUST be in the order of this list.
-- example: fire_iron_bipod_empty

-- use SWEP/wep.Hook_TranslateAnimation, same as in attachment, to do even more behaviours
-- use SWEP/wep.Hook_SelectReloadAnimation to change the reload animation
-- use SWEP/wep.Hook_SelectInsertAnimation to change the shotgun reload insert animation
-- use SWEP/wep.Hook_SelectFireAnimation to change the fire animation
-- use SWEP/wep.Hook_SelectCycleAnimation to change the cycle/pump animation
-- use SWEP/wep.Hook_SelectBashAnimation to change the bash animation

-- which sequence to derive the sight autosolver from.
SWEP.AutosolveSourceSeq = "idle"

-- Disclaimer: LHIK is *actually* a type of forward kinematics.
-- If you prefer, LHIK can stand for "Left Hand Individual Kinematics" or some shit

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Time = 10
    -- },
    -- ["draw"] = {
    --     RestoreAmmo = 1, -- only used by shotgun empty insert reload
    --     Source = "deploy",
    --     RareSource = "", -- 1/RareSourceChance of playing this animation instead
    --     RareSourceChance = 100, -- Chance the rapper
    --     Time = 0.5, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    --     Mult = 1, -- Multiplies the rate of animation.
    --     TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, -- third person animation to play when this animation is played
    --     TPAnimStartTime = 0, -- when to start it from
    --     Checkpoints = {}, -- time checkpoints. If weapon is unequipped, the animation will continue to play from these checkpoints when reequipped.
    --     ShellEjectAt = 0, -- animation includes a shell eject at these times
    --     LHIKIn = 0.25, -- In/Out controls how long it takes to switch to regular animation.
    --     LHIKOut = 0.25, -- (not actually inverse kinematics)
    --     LHIKEaseIn = 0.1, -- how long LHIK eases in.
    --     LHIKEaseOut = 0.1, -- if no value is specified then ease = lhikin
    --     LHIKTimeline = { -- allows arbitrary LHIK values to be interpolated between
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --         },
    --         {
    --             t = 0.25,
    --             lhik = 1
    --         }
    --     },
    --     LHIK = true, -- basically disable foregrips on this anim
    --     SoundTable = {
    --         {
    --             s = "", -- sound; can be string or table
    --             p = 100, -- pitch
    --             v = 75, -- volume
    --             t = 1, -- time at which to play relative to Animations.Time
    --             c = CHAN_ITEM, -- channel to play the sound

    --             -- Can also play an effect at the same time
    --             e = "", -- effect name
    --             att = nil, -- attachment, defaults to shell attachment
    --             mag = 100, -- magnitude
    --             -- also capable of modifying bodygroups
    --             ind = 0,
    --             bg = 0,
    --             -- and poseparams
    --             pp = "pose",
    --             ppv = 0.25,
    --         }
    --     },
    --     ViewPunchTable = {
    --         {
    --             p = Vector(0, 0, 0),
    --             t = 1
    --         }
    --     },
    --     ProcDraw = false, -- for draw/deploy animations, always procedurally draw in addition to playing animation
    --     ProcHolster = false, -- procedural holster weapon, THEN play animation
    --     LastClip1OutTime = 0, -- when should the belt visually replenish on a belt fed
    --     MinProgress = 0, -- how much time in seconds must pass before the animation can be cancelled
    --     ForceEmpty = false, -- Used by empty shotgun reloads that load rounds to force consider the weapon to still be empty.
    -- }
}

--[[
for k, v in ipairs(ents.FindByClass("sb*")) do
	if v.Droid then
		v:Give("arccw_ef_blaster_dc15s")
	end
end
]]

DEFINE_BASECLASS( SWEP.Base )
--PATH lua/weapons/arccw_meeks_sw_base.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = false -- this obviously has to be set to true

// names and stuff
SWEP.PrintName = "Meek's SW ArcCW Base"
SWEP.Category = "[ Meeks ] ArcCW Blasters"

SWEP.Description = ""

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.ViewModelFOV = 60

SWEP.MirrorVMWM = nil -- Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = nil -- Use this to set the mirrored viewmodel to a different model, without any floating speedloaders or cartridges you may have. Needs MirrorVMWM

--[[SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}]]

SWEP.PresetBase = nil -- make this weapon share saves with this one.

SWEP.KillIconAlias = nil -- set to other weapon class to share select and kill icons

SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.WorldModelOffset = nil
-- {
--     pos = Vector(0, 0, 0),
--     ang = Angle(0, 0, 0)
-- }

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 26
SWEP.DamageMin = 10 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 0 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s
SWEP.PhysBulletMuzzleVelocity = nil -- override phys bullet muzzle velocity
SWEP.PhysBulletDrag = 1
SWEP.PhysBulletGravity = 1
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.BodyDamageMults = nil
-- if a limb is not set the damage multiplier will default to 1
-- that means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 0 -- color for phys tracer.
-- there are 8 options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible
SWEP.HullSize = 1.5 -- HullSize used by FireBullets

function SWEP:DoImpactEffect(tr, dmgtype)
    if tr.HitSky then return true end

    util.Decal("fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal);
    if( game.SinglePlayer() or SERVER or not self:IsCarriedByLocalPlayer() or IsFirstTimePredicted() ) then
        local soundToPlay = "impacts/sw752_hit_1.wav"
        local randomSound = math.random(1,14)
        if randomSound == 1 then
            soundToPlay = "impacts/sw752_hit_4.wav"
        elseif randomSound == 2 then
            soundToPlay = "impacts/sw752_hit_5.wav"
        elseif randomSound == 3 then
            soundToPlay = "impacts/.wav"
        elseif randomSound == 4 then
            soundToPlay = "impacts/sw752_hit_9.wav"
        elseif randomSound == 5 then
            soundToPlay = "impacts/sw752_hit_10.wav"
        elseif randomSound == 6 then
            soundToPlay = "impacts/sw752_hit_12.wav"
        elseif randomSound == 7 then
            soundToPlay = "impacts/sw752_hit_13.wav"
        elseif randomSound == 8 then
            soundToPlay = "impacts/sw752_hit_14.wav"
        elseif randomSound == 9 then
            soundToPlay = "impacts/sw752_hit_19.wav"
        elseif randomSound == 10 then
            soundToPlay = "impacts/sw752_hit_27.wav"
        elseif randomSound == 11 then
            soundToPlay = "impacts/sw752_hit_28.wav"
        elseif randomSound == 12 then
            soundToPlay = "impacts/sw752_hit_30.wav"
        elseif randomSound == 13 then
            soundToPlay = "impacts/sw752_hit_31.wav"
        elseif randomSound == 14 then
            soundToPlay = "impacts/sw752_hit_17.wav"
        end

    
        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetNormal(tr.HitNormal)

        -- util.Effect( "effect_astw2_swbf_impact", effect );
        sound.Play( soundToPlay, tr.HitPos, 75, 100, 1 );

        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetStart(tr.StartPos)
        effect:SetDamageType(dmgtype)

        util.Effect("RagdollImpact", effect)
    end

    return true;
end

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 25 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 10

-- But if you insist...
SWEP.ForceDefaultClip = nil
SWEP.ForceDefaultAmmo = nil

-- The amount of rounds to load in the chamber when the gun is non-empty or empty
-- Defaults to ChamberSize and 0. Don't change unless you have a good reason
SWEP.ChamberLoadNonEmpty = nil
SWEP.ChamberLoadEmpty = nil

SWEP.AmmoPerShot = 1
SWEP.InfiniteAmmo = false -- weapon can reload for free
SWEP.BottomlessClip = false -- weapon never has to reload

SWEP.DoNotEquipmentAmmo = false -- do not automatically give this weapon unique ammo when arccw_equipmentammo is used

SWEP.ShotgunReload = false -- reloads like shotgun instead of magazines
SWEP.HybridReload = false -- reload normally when empty, reload like shotgun when part full

SWEP.ManualAction = false -- pump/bolt action
SWEP.NoLastCycle = false -- do not cycle on last shot

SWEP.RevolverReload = false -- cases all eject on reload

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.CanFireUnderwater = false

SWEP.Disposable = false -- when all ammo is expended, the gun will remove itself when holstered

SWEP.AutoReload = false -- when weapon is drawn, the gun will reload itself.

SWEP.IsShotgun = false -- weapon receives shotgun ammo types

SWEP.TriggerDelay = false -- Set to true to play the "trigger" animation before firing. Delay time is dependent on animation time.

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = -1
SWEP.VisualRecoilMult = 1.25
SWEP.RecoilPunch = 1.5
SWEP.RecoilPunchBackMax = 1
SWEP.RecoilPunchBackMaxSights = nil -- may clip with scopes
SWEP.RecoilVMShake = 1 -- random viewmodel offset when shooty

SWEP.Sway = 0

SWEP.ShotgunSpreadDispersion = false -- dispersion will cause pattern to increase instead of shifting
SWEP.ShotgunSpreadPattern = nil
SWEP.ShotgunSpreadPatternOverrun = nil
-- {Angle(1, 1, 0), Angle(1, 0, 0) ..}
-- list of how far each pellet should veer
-- if only one pellet then it'll use the first index
-- if two then the first two
-- in case of overrun pellets will start looping, preferably with the second one, so use that for the loopables
-- precision will still be applied

SWEP.RecoilDirection = Angle(1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1, 0)

SWEP.Delay = 60 / 750 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 1 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    -- {
    --     Mode = 1,
    --     CustomBars = "---_!",
    -- }
}

--[[
	Custom bar setup
	Colored variants        Classic
	'a' Filled              '-' Filled
	'b' Outline             '_' Outline
	'd' CLR w Outline       '!' Red w Outline
	'#' Empty
]]
--     PrintName = "PUMP",
--     RunAwayBurst = false,
--     AutoBurst = false, -- hold fire to continue firing bursts
--     PostBurstDelay = 0,
--     ActivateElements = {}

SWEP.ShotRecoilTable = nil -- {[1] = 0.25, [2] = 2} etc.

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace
-- if nil, this will be based on holdtype
SWEP.NPCWeight = 100 -- relative likeliness for an NPC to have this weapon
SWEP.TTTWeaponType = nil -- string or table, like NPCWeaponType but specifically for TTT weapons (takes precdence over NPCWeaponType)
SWEP.TTTWeight = 100 -- like NPCWeight but for TTT gamemode

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights
SWEP.JumpDispersion = 300 -- dispersion penalty when in the air

SWEP.Bipod_Integral = false -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 125 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = nil
SWEP.ShootSound = ""
SWEP.ShootSoundLooping = nil
SWEP.FirstShootSoundSilenced = nil
SWEP.ShootDrySound = nil -- Add an attachment hook for Hook_GetShootDrySound please!
SWEP.DistantShootSound = nil
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.ShootSoundSilencedLooping = nil
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.EnterBipodSound = "weapons/arccw/bipod_down.wav"
SWEP.ExitBipodSound = "weapons/arccw/bipod_up.wav"
SWEP.SelectUBGLSound =  "weapons/arccw/ubgl_select.wav"
SWEP.ExitUBGLSound = "weapons/arccw/ubgl_exit.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects
SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil
SWEP.ShellEffect = nil
SWEP.ShellEjectPosCorrection = nil
SWEP.ShellScale = 1
SWEP.ShellPhysScale = 1
SWEP.ShellPitch = 100
SWEP.ShellSounds = "autocheck"--ArcCW.ShellSoundsTable
SWEP.ShellRotate = 0
SWEP.ShellTime = 0.5

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on
SWEP.ProceduralViewBobAttachment = nil -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.CamAttachment = nil -- if set, this attachment will control camera movement
SWEP.MuzzleFlashColor = Color(0, 110, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.KeepBaseIrons = false -- do not override iron sights when scope installed
SWEP.BaseIronsFirst = false -- If a sight keeps base irons, irons comes first

SWEP.IronSightStruct = {
    Pos = Vector(-8.728, -13.702, 4.014),
    Ang = Angle(-1.397, -0.341, -2.602),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 15, -4),
        Ang = Angle(0, 0, -45),
    },
    Magnification = 1,
    BlackBox = false,
    ScopeTexture = nil,
    SwitchToSound = "", -- sound that plays when switching to this sight
    SwitchFromSound = "",
    ScrollFunc = ArcCW.SCROLL_NONE,
    CrosshairInSights = false,
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

-- Override free aim convar and variable
SWEP.FreeAimAngle = nil -- defaults to HipDispersion / 80. overwrite here
SWEP.NeverFreeAim = nil
SWEP.AlwaysFreeAim = nil

-- If Jamming is enabled, a heat meter will gradually build up until it reaches HeatCapacity.
-- Once that happens, the gun will overheat, playing an animation. If HeatLockout is true, it cannot be fired until heat is 0 again.
SWEP.Jamming = false
SWEP.HeatCapacity = 200 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = false -- when the "fix" animation is played, all heat is restored.
SWEP.HeatOverflow = nil -- if true, heat is allowed to exceed capacity (this only applies when the default overheat handling is overridden)

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"
SWEP.HoldtypeNPC = nil

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.GuaranteeLaser = false -- GUARANTEE that the laser position will be accurate, so don't bother with sighted correction

SWEP.ShieldProps = nil
-- {
--     {
--         Model = "",
--         Pos = Vector(0, 0, 0),
--         Ang = Angle(0, 0, 0),
--         Bone = "", -- leave blank for valvebiped right hand
--         Resistance = 5, -- one unit of this object counts for how much penetration amount
--     }
-- }

SWEP.CanBash = true
SWEP.PrimaryBash = false -- primary attack triggers melee attack

SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.ReloadPos = nil
SWEP.ReloadAng = nil

SWEP.CrouchPos = nil
SWEP.CrouchAng = nil

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

-- When using custom sprint animations, set this to the same as ActivePos and ActiveAng
SWEP.SprintPos = nil
SWEP.SprintAng = nil

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = nil

SWEP.DefaultPoseParams = {} -- {["pose"] = 0.5}
SWEP.DefaultWMPoseParams = {}

SWEP.DefaultElements = {} -- {"ele1", "ele2"}

SWEP.AttachmentElements = {
    -- ["name"] = {
    --     RequireFlags = {}, -- same as attachments
    --     ExcludeFlags = {},
    --     NamePriority = 0, -- higher = more likely to be chosen
    --     NameChange = "",
    --     TrueNameChange = "",
    --     AddPrefix = "",
    --     AddSuffix = "",
    --     VMPoseParams = {}, -- {["pose"] = 0.5}
    --     VMColor = Color(),
    --     VMMaterial = "",
    --     VMBodygroups = {{ind = 1, bg = 1}},
    --     VMElements = {
    --         {
    --             Model = "",
    --             Bone = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             ModelSkin = 0,
    --             ModelBodygroups = "",
    --             Scale = Vector(1, 1, 1),
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     VMOverride = "", -- change the view model to something else. Please make sure it's compatible with the last one.
    --     VMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     WMPoseParams = {}, -- {["pose"] = 0.5}
    --     WMColor = Color(),
    --     WMMaterial = "",
    --     WMBodygroups = {},
    --     WMElements = {
    --         {
    --             Model = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     WMOverride = "", -- change the world model to something else. Please make sure it's compatible with the last one.
    --     WMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     AttPosMods = {
    --         [1] = {
    --             bone = "", -- optional
    --             vpos = Vector(0, 0, 0),
    --             vang = Angle(0, 0, 0),
    --             wpos = Vector(0, 0, 0),
    --             wang = Angle(0, 0, 0),
    --             SlideAmount = { -- only if base att has slideable
    --                 vmin = Vector(0, 0, 0),
    --                 vmax = Vector(0, 0, 0),
    --                 wmin = Vector(0, 0, 0),
    --                 wmax = Vector(0, 0, 0)
    --             }
    --         }
    --     }
    -- }
}

SWEP.RejectAttachments = {
    -- ["optic_docter"] = true -- stop this attachment from being usable on this gun
}

SWEP.AttachmentOverrides = {
    -- ["optic_docter"] = {} -- allows you to overwrite atttbl values
}

SWEP.TTT_DoNotAttachOnBuy = false -- don't give all attachments when bought

SWEP.Attachments = {}
-- [1] = {
--     PrintName = "Optic", -- print name
--     DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
--     DefaultAttIcon = Material(),
--     Slot = "pic_sight", -- what kind of attachments can fit here
--     MergeSlots = {}, -- these other slots will be merged into this one.
--     Bone = "sight", -- relevant bone any attachments will be mostly referring to
--     WMBone = "ValveBiped.Bip01_L_Hand", -- set it to change parent bone of attachment WM
--     KeepBaseIrons = false,
--     ExtraSightDist = 0,
--     Offset = {
--         vpos = Vector(0, 0, 0), -- offset that the attachment will be relative to the bone
--         vang = Angle(0, 0, 0),
--         wpos = Vector(0, 0, 0), -- same, for the worldmodels
--         wang = Angle(0, 0, 0)
--     },
--     RejectAttachments = {}, -- specific blacklist of attachments this slot cannot accept. Needs to be like {"optic_mrs" = true}
--     VMScale = Vector(1, 1, 1),
--     WMScale = Vector(1, 1, 1),
--     SlideAmount = { -- how far this attachment can slide in both directions.
--         -- overrides Offset.
--         vmin = Vector(0, 0, 0),
--         vmax = Vector(0, 0, 0),
--         wmin = Vector(0, 0, 0),
--         wmax = Vector(0, 0, 0),
--     },
--     CorrectiveAng = Vector(1, 1, 1), -- okay, I know I said sights were pain-free.
--     CorrectivePos = Vector(0, 0, 0), -- that won't always be the case. Use these to fix it. Issues mainly crop up in case of sights parented to bones that are not a root bone.
--     InstalledEles = {"toprail"}, -- activate these AttachmentElements if something is installed
--     DefaultEles = {""} -- activeate these AttachmentElements *unless* something is installed
--     Hidden = false, -- attachment cannot be seen in customize menu
--     Integral = false, -- attachment is assumed never to change
--     RandomChance = 1, -- multiplies chance this slot will get a random attachment
--     DoNotRandomize = false,
--     NoWM = false, -- do not make this show up on worldmodel
--     NoVM = false, -- what do *you* think this one does?
--     FreeSlot = false, -- slot does not count towards attachment capacity
--     -- ABOUT THE FLAG SYSTEM:
--     -- Attachments and slots can give flags
--     -- All attachments automatically give themselves as a flag, e.g. "optic_mrs"
--     -- If requirements are not satisfied, the slot or attachment will not be attachable
--     ExcludeFlags = {}, -- if the weapon has this flag, hide this slot
--     RequireFlags = {}, -- if the weapon does not have all these flags, hide this slot
--     GivesFlags = {} -- give these slots if something is installed here
--     HideIfBlocked = false, -- If flag requirements are not met, do not show the attachment at all
-- }

-- ready: deploy first time
-- draw
-- holster
-- reload
-- fire
-- cycle (for bolt/pump actions)
-- bash
-- fix
-- enter_bipod
-- exit_bipod
-- enter_sight
-- exit_sight
-- a_to_b: switch from firemode a to firemode b. e.g.: 1_to_2
-- idle
-- idle_sights
-- idle_sprint
-- idle_bipod
-- enter_inspect
-- idle_inspect
-- exit_inspect
-- enter_ubgl
-- exit_ubgl
-- idle_ubgl

-- you can append suffixes for different states
-- append list:

-- _iron, _sights, or _sight     for sighted variation
-- _sprint                       for sprinting variation
-- _bipod                        for bipod variation
-- _empty                        for empty variation
-- _jammed                       for jammed variation

-- this does not apply to reload animations.

-- !! they MUST be in the order of this list.
-- example: fire_iron_bipod_empty

-- use SWEP/wep.Hook_TranslateAnimation, same as in attachment, to do even more behaviours
-- use SWEP/wep.Hook_SelectReloadAnimation to change the reload animation
-- use SWEP/wep.Hook_SelectInsertAnimation to change the shotgun reload insert animation
-- use SWEP/wep.Hook_SelectFireAnimation to change the fire animation
-- use SWEP/wep.Hook_SelectCycleAnimation to change the cycle/pump animation
-- use SWEP/wep.Hook_SelectBashAnimation to change the bash animation

-- which sequence to derive the sight autosolver from.
SWEP.AutosolveSourceSeq = "idle"

-- Disclaimer: LHIK is *actually* a type of forward kinematics.
-- If you prefer, LHIK can stand for "Left Hand Individual Kinematics" or some shit

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Time = 10
    -- },
    -- ["draw"] = {
    --     RestoreAmmo = 1, -- only used by shotgun empty insert reload
    --     Source = "deploy",
    --     RareSource = "", -- 1/RareSourceChance of playing this animation instead
    --     RareSourceChance = 100, -- Chance the rapper
    --     Time = 0.5, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    --     Mult = 1, -- Multiplies the rate of animation.
    --     TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, -- third person animation to play when this animation is played
    --     TPAnimStartTime = 0, -- when to start it from
    --     Checkpoints = {}, -- time checkpoints. If weapon is unequipped, the animation will continue to play from these checkpoints when reequipped.
    --     ShellEjectAt = 0, -- animation includes a shell eject at these times
    --     LHIKIn = 0.25, -- In/Out controls how long it takes to switch to regular animation.
    --     LHIKOut = 0.25, -- (not actually inverse kinematics)
    --     LHIKEaseIn = 0.1, -- how long LHIK eases in.
    --     LHIKEaseOut = 0.1, -- if no value is specified then ease = lhikin
    --     LHIKTimeline = { -- allows arbitrary LHIK values to be interpolated between
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --         },
    --         {
    --             t = 0.25,
    --             lhik = 1
    --         }
    --     },
    --     LHIK = true, -- basically disable foregrips on this anim
    --     SoundTable = {
    --         {
    --             s = "", -- sound; can be string or table
    --             p = 100, -- pitch
    --             v = 75, -- volume
    --             t = 1, -- time at which to play relative to Animations.Time
    --             c = CHAN_ITEM, -- channel to play the sound

    --             -- Can also play an effect at the same time
    --             e = "", -- effect name
    --             att = nil, -- attachment, defaults to shell attachment
    --             mag = 100, -- magnitude
    --             -- also capable of modifying bodygroups
    --             ind = 0,
    --             bg = 0,
    --             -- and poseparams
    --             pp = "pose",
    --             ppv = 0.25,
    --         }
    --     },
    --     ViewPunchTable = {
    --         {
    --             p = Vector(0, 0, 0),
    --             t = 1
    --         }
    --     },
    --     ProcDraw = false, -- for draw/deploy animations, always procedurally draw in addition to playing animation
    --     ProcHolster = false, -- procedural holster weapon, THEN play animation
    --     LastClip1OutTime = 0, -- when should the belt visually replenish on a belt fed
    --     MinProgress = 0, -- how much time in seconds must pass before the animation can be cancelled
    --     ForceEmpty = false, -- Used by empty shotgun reloads that load rounds to force consider the weapon to still be empty.
    -- }
}

--[[
for k, v in ipairs(ents.FindByClass("sb*")) do
	if v.Droid then
		v:Give("arccw_ef_blaster_dc15s")
	end
end
]]

DEFINE_BASECLASS( SWEP.Base )
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_deadmanstale.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_fc1.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_fc1.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "FC-1 Flechette Launcher"
SWEP.Trivia_Class = "High-Explosive Weapon"
SWEP.Trivia_Desc = "Flechette launchers were weapons that fired flechettes. Golan Arms's FC-1 flechette launcher and the Salus Corporation's DF-D1 Duo-Flechette Rifle were both models of flechette launcher."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/fc1.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_fc1.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11, 5, -1.5),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 1, 0),
    [2] = Angle(0, -1, 0),
    [3] = Angle(2.1, 0, 0),
    [4] = Angle(-2.1, 0, 0),
}

SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 4
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 76
SWEP.DamageMin = 27
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 10
SWEP.DamageType = DMG_BLAST
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "emg_tracer"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 10

SWEP.Recoil = 1.05
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 400
SWEP.Num = 4
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 50
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/fc1.wav"
SWEP.ShootSound = "kraken/sops/fc1.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.191, -1.124, 0.264),
    Ang = Vector(2.74, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dc15s",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.25, 2, 11.1),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dc15s",
        VMScale = Vector(0.9,0.9,0.9),
        WMScale = Vector(0.9,0.9,0.9),
        Offset = {
            vpos = Vector(-0.13, -3.2, 2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dc15s",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-2.2, -1.4, 8),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(1.98, -1.4, -3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(1.92, -0.9, 1),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.4,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 80 / 30},
            {s = "ArcCW_Kraken.Grab", t = 85 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_jawapistol.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Jawa Pistol"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Heavy-Powered blaster produced by BlastTech Industries for the galactic citizens."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/jawapistol.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_jawapistol.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 27
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 140
SWEP.Penetration = 8
SWEP.DamageType = DMG_SHOCK
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 22

SWEP.Recoil = 1
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = -3,
        Mult_RPM = 4
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/jawapistol.wav"
SWEP.ShootSound = "kraken/sops/jawapistol.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.12, -5.169, 3.9),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 2, 8),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.28, -1.2, 1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0.25, -0.8, 4),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.2, -0.8, 2.3),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.6, 0., 2.8),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.8, -0.75, -0.8),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_k3bu.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_z6x.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_z6x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 5

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "ZX-6"
SWEP.Trivia_Class = "Blaster-Experimental Heavy Canon"
SWEP.Trivia_Desc = "The Zx-6 rotary blaster cannon was a blaster cannon used by the Galactic Republic during the Clone Wars. Later, during the reign of the Galactic Empire, these weapons were used by both the Imperial Army's Heavy Weapons Stormtroopers and Rebel Alliance's Heavy Soldiers during the Galactic Civil War."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/z6x.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_zx6.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 16
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.76
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.4
SWEP.RecoilVMShake = 1.5

SWEP.Delay = 60 / 225
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/rx21.wav"
SWEP.ShootSound = "kraken/sops/rx21.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.849, -6.351, -0.247),
    Ang = Vector(3.79, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, 0, 34),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.13, -4.7, 11.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.9, -1.5, 19.8),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.6, -1.2, 2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1, -2.4, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

-- Special properties
SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end
--PATH lua/weapons/arccw_z4.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Z4"
SWEP.Trivia_Class = "CIS Rotary Canon"
SWEP.Trivia_Desc = "High tech CIS Rotary Canon Blaster"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_t21.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_t21.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_z6.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 25
SWEP.RangeMin = 145
SWEP.DamageMin = 16
SWEP.Range = 375
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 150

SWEP.Recoil = 0.28
SWEP.RecoilSide = 0.25
SWEP.RecoilPunch = 2
SWEP.RecoilRise = 0.34

SWEP.Delay = 245 / 2400
SWEP.Num = 1

SWEP.BobMult = 1

SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 0,
    },
}

SWEP.AccuracyMOA = 0.55 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 330 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 0.8 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 0.5 -- Bipod recoil for Integral bipods

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)

SWEP.SpeedMult = 0.5
SWEP.SightedSpeedMult = 0.8
SWEP.SightTime = 1

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.02

SWEP.ShootSound = "w/z6.wav"

SWEP.IronSightStruct = {
    Pos = Vector(0, -12, -4),
    Ang = Angle(0, 0, 0),
    Magnification = 1,
    SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
    CrosshairInSights = true
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "crossbow"
SWEP.HoldtypeSights = "crossbow"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(4, -10, -8)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -30, -20)
SWEP.SprintAng = Angle(40, 0, -10)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -4, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.DefaultElements = {"z4", "muzzle"}

SWEP.AttachmentElements = {
    ["z4"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/z6_rotary_cannon.mdl",
                Bone = "v_t21_reference001",
                Scale = Vector(1.2, 1.1, 1.2),
                Offset = {
                    pos = Vector(.1, -0.3, 1),
                    ang = Angle(0,-90, 0)
                },
            }
        },
    },
    ["muzzle"] = {
         VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "t21_sight",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-0.5, 5, 16),
                    ang = Angle(90, 0, 0)
                },
                IsMuzzleDevice = true
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/z6_rotary_cannon.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3.75, 2.5, -1.5),
                    ang = Angle(-10, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4500, 0, -700),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/arccw/sw_battlefront/weapons/z6_rotary_cannon.mdl"

SWEP.Jamming = true
SWEP.HeatGain = 0.8 -- heat gained per shot
SWEP.HeatCapacity = 75 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 10 -- rounds' worth of heat lost per second
SWEP.HeatLockout = true -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5

--SWEP.Attachments 
SWEP.Attachments = {       
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.5, 0.6, 35),
            vang = Angle(90, 0, 0),
        },
    },            
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [3] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [4] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.2, 1, 29),
            vang = Angle(90, 0, -90),
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 2,
        SoundTable = {
            {
                s = "draw/blasters_deathray_foley_undeploy_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 200, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/blasters_deathray_foley_undeploy_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_z6.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--PATH gamemodes/starwarsrp/entities/weapons/arrest_stick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Slot = 1
    SWEP.SlotPos = 3
end

DEFINE_BASECLASS("stick_base")

SWEP.Instructions = "Left click to arrest\nRight click to switch batons"
SWEP.IsDarkRPArrestStick = true

SWEP.PrintName = "Arrest Baton"
SWEP.Spawnable = true
SWEP.Category = "DarkRP (Utility)"

SWEP.StickColor = Color(255, 0, 0)

SWEP.Switched = true

DarkRP.hookStub{
    name = "canArrest",
    description = "Whether someone can arrest another player.",
    parameters = {
        {
            name = "arrester",
            description = "The player trying to arrest someone.",
            type = "Player"
        },
        {
            name = "arrestee",
            description = "The player being arrested.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canArrest",
            description = "A yes or no as to whether the arrester can arrest the arestee.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't arrest the player.",
            type = "string"
        }
    },
    realm = "Server"
}

DarkRP.hookStub{
    name = "setArrestStickTime",
    description = "Sets arrest time for an arrest made via the arrest stick",
    parameters = {
        {
            name = "arrest_stick",
            description = "The arrest strick weapon with which the arrestee was arrested.",
            type = "Weapon"
        },
        {
            name = "arrester",
            description = "The player trying to arrest someone.",
            type = "Player"
        },
        {
            name = "arrestee",
            description = "The player being arrested.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "time",
            description = "The time to arrest the player.",
            type = "integer"
        }
    },
    realm = "Server"
}

function SWEP:Deploy()
    self.Switched = true
    return BaseClass.Deploy(self)
end

function SWEP:PrimaryAttack()
    BaseClass.PrimaryAttack(self)

    if CLIENT then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = util.QuickTrace(Owner:EyePos(), Owner:GetAimVector() * 90, {Owner})
    Owner:LagCompensation(false)

    local ent = trace.Entity
    if IsValid(ent) and ent.onArrestStickUsed then
        ent:onArrestStickUsed(Owner)
        return
    end

    ent = Owner:getEyeSightHitEntity(nil, nil, function(p) return p ~= Owner and p:IsPlayer() and p:Alive() and p:IsSolid() end)

    local stickRange = self.stickRange * self.stickRange
    if not IsValid(ent) or (Owner:EyePos():DistToSqr(ent:GetPos()) > stickRange) or not ent:IsPlayer() then
        return
    end

    local canArrest, message = hook.Call("canArrest", DarkRP.hooks, Owner, ent)
    if not canArrest then
        if message then DarkRP.notify(Owner, 1, 5, message) end
        return
    end

    local time = hook.Call("setArrestStickTime", DarkRP.hooks, self, Owner, ent)
    ent:arrest(time, Owner)
    DarkRP.notify(ent, 0, 20, DarkRP.getPhrase("youre_arrested_by", Owner:Nick()))

    if Owner.SteamName then
        DarkRP.log(Owner:Nick() .. " (" .. Owner:SteamID() .. ") arrested " .. ent:Nick(), Color(0, 255, 255))
    end
end

function SWEP:startDarkRPCommand(usrcmd)
    local Owner = self:GetOwner()
    if not IsValid(Owner) then return end

    if game.SinglePlayer() and CLIENT then return end
    if usrcmd:KeyDown(IN_ATTACK2) then
        if not self.Switched and Owner:HasWeapon("unarrest_stick") then
            usrcmd:SelectWeapon(Owner:GetWeapon("unarrest_stick"))
        end
    else
        self.Switched = false
    end
end

--PATH lua/weapons/ce_bcr_config.lua:
AddCSLuaFile()


-- Per Person Setting

CreateClientConVar("bc2_ShowCloakCharge", 1, false, false, "")

-- Visual

CreateConVar("bc2_CloakType", "Transparent", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMode", "Timer", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakUntilVel", 75, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumVisibility", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMaterial", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeGainMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeLossMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge1", 10, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge2", 20, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge3", 30, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumNPCVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_UncloakInVehicle", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakOverlay", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumIDVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakFireMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountFire", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeFire", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakDamageMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountHurt", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeHurt", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOn", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOff", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleTime", 3, FCVAR_ARCHIVE, "")

-- Audio

CreateConVar("bc2_DistortSound", 14, FCVAR_ARCHIVE, "")
CreateConVar("bc2_EnableSound", "npc/sniper/reload1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_DisableSound", "AlyxEMP.Discharge", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ForceDisableSound", "npc/roller/mine/combine_mine_deactivate1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleFailureSound", "npc/roller/mine/combine_mine_deploy1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_FootstepVolume", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntSound", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntVolume", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntDelay", 4, FCVAR_ARCHIVE, "")

hook.Add( "PopulateToolMenu", "ce_bc2_configmenu", function()
	spawnmenu.AddToolMenuOption( "Utilities", "JustCrimson", "ce_bc2_config", "Better Cloaking Config", "", "", function( panel )
		panel:ClearControls()
		local CloakTypeBox = panel:ComboBox("Cloak Type", "bc2_CloakType")
		
		CloakTypeBox:AddChoice("Transparent")
		CloakTypeBox:AddChoice("Material")
		
		local CloakModeBox = panel:ComboBox("Cloak Mode", "bc2_CloakMode")
		CloakModeBox:AddChoice("Timer")
		CloakModeBox:AddChoice("Charge")

		panel:TextEntry("Movement Sensitivity", "bc2_CloakUntilVel"):SetNumeric(true)

		panel:TextEntry("Toggle Time", "bc2_ToggleTime"):SetNumeric(true)

		panel:NumSlider("Minimum Visibility", "bc2_MinimumVisibility", 0, 255, 0)

		panel:TextEntry("Cloak Material", "bc2_CloakMaterial")

		local SoundDistortBox = panel:ComboBox("Sound Distortion", "bc2_DistortSound")
		SoundDistortBox:AddChoice("None", 0)
		SoundDistortBox:AddChoice("Light", 14)
		SoundDistortBox:AddChoice("Medium", 15)
		SoundDistortBox:AddChoice("Heavy", 16)

		panel:TextEntry("Enable Sound", "bc2_EnableSound")
		panel:TextEntry("Disable Sound", "bc2_DisableSound")
		panel:TextEntry("Toggle Fail Sound", "bc2_ToggleFailureSound")
		panel:TextEntry("Force Disable Sound", "bc2_ForceDisableSound")


		panel:NumSlider("Visibility For NPC Target", "bc2_MinimumNPCVisibility", 0, 255, 0)
		panel:NumSlider("Visibility To Show ID", "bc2_MinimumIDVisibility", 0, 255, 0)

		panel:NumSlider("Footstep Volume", "bc2_FootstepVolume", 0, 1, 2)

		panel:CheckBox("Uncloak In Vehicle", "bc2_UncloakInVehicle")

		panel:TextEntry("Cloak Overlay", "bc2_CloakOverlay")

		local CloakShootMode = panel:ComboBox("Shooting While Cloaked Mode", "bc2_CloakFireMode")
		CloakShootMode:AddChoice("Disable Cloak", 1)
		CloakShootMode:AddChoice("Lose Charge", 2)
		CloakShootMode:AddChoice("Temp Disable", 3)
		CloakShootMode:AddChoice("Nothing", 4)

		panel:TextEntry("Shooting Lose Charge Amount", "bc2_LoseChargeAmountFire"):SetNumeric(true)
		panel:TextEntry("Shooting Temp Disable Time", "bc2_TempDisableTimeFire"):SetNumeric(true)

		panel:TextEntry("Cloak 1 Max Charge", "bc2_MaxCharge1"):SetNumeric(true)
		panel:TextEntry("Cloak 2 Max Charge", "bc2_MaxCharge2"):SetNumeric(true)
		panel:TextEntry("Cloak 3 Max Charge", "bc2_MaxCharge3"):SetNumeric(true)

		panel:TextEntry("Charge Gain Multiplier", "bc2_ChargeGainMultiplier"):SetNumeric(true)
		panel:TextEntry("Charge Loss Multiplier", "bc2_ChargeLossMultiplier"):SetNumeric(true)

		local CloakDamageMode = panel:ComboBox("Damaged While Cloaked Mode", "bc2_CloakDamageMode")
		CloakDamageMode:AddChoice("Disable Cloak", 1)
		CloakDamageMode:AddChoice("Lose Charge", 2)
		CloakDamageMode:AddChoice("Temp Disable", 3)
		CloakDamageMode:AddChoice("Nothing", 4)
		
		panel:TextEntry("Damaged Lose Charge Amount", "bc2_LoseChargeAmountHurt"):SetNumeric(true)
		panel:TextEntry("Damaged Temp Disable Time", "bc2_TempDisableTimeHurt"):SetNumeric(true)

		panel:TextEntry("Cloak Enable Effect", "bc2_CloakEffectOn")
		panel:TextEntry("Cloak Disable Effect", "bc2_CloakEffectOff")

		panel:TextEntry("Taunt Sound", "bc2_TauntSound")
		panel:NumSlider("Taunt Volume", "bc2_TauntVolume", 0, 1, 2)
		panel:TextEntry("Taunt Delay", "bc2_TauntDelay"):SetNumeric(true)

	end )
end )

cloakconfig = {}

-- Visual
cloakconfig["CloakType"] = GetConVar("bc2_CloakType"):GetString()
cloakconfig["CloakMode"] = GetConVar("bc2_CloakMode"):GetString()
cloakconfig["CloakUntilVel"] = GetConVar("bc2_CloakUntilVel"):GetInt()
cloakconfig["MinimumVisibility"] = GetConVar("bc2_MinimumVisibility"):GetInt()
cloakconfig["CloakMaterial"] = GetConVar("bc2_CloakMaterial"):GetString()
cloakconfig["ChargeGainMultiplier"] = GetConVar("bc2_ChargeGainMultiplier"):GetFloat()
cloakconfig["ChargeLossMultiplier"] = GetConVar("bc2_ChargeLossMultiplier"):GetFloat()
cloakconfig["MaxCharge0"] = 0
cloakconfig["MaxCharge1"] = GetConVar("bc2_MaxCharge1"):GetInt()
cloakconfig["MaxCharge2"] = GetConVar("bc2_MaxCharge2"):GetInt()
cloakconfig["MaxCharge3"] = GetConVar("bc2_MaxCharge3"):GetInt()
cloakconfig["MinimumNPCVisibility"] = GetConVar("bc2_MinimumNPCVisibility"):GetInt()
cloakconfig["UncloakInVehicle"] = GetConVar("bc2_UncloakInVehicle"):GetBool()
cloakconfig["CloakOverlay"] = GetConVar("bc2_CloakOverlay"):GetString()
cloakconfig["MinimumIDVisibility"] = GetConVar("bc2_MinimumIDVisibility"):GetInt()
cloakconfig["CloakFireMode"] = GetConVar("bc2_CloakFireMode"):GetInt()
cloakconfig["LoseChargeAmountFire"] = GetConVar("bc2_LoseChargeAmountFire"):GetFloat()
cloakconfig["TempDisableTimeFire"] = GetConVar("bc2_TempDisableTimeFire"):GetFloat()
cloakconfig["CloakDamageMode"] = GetConVar("bc2_CloakDamageMode"):GetInt()
cloakconfig["LoseChargeAmountHurt"] = GetConVar("bc2_LoseChargeAmountHurt"):GetFloat()
cloakconfig["TempDisableTimeHurt"] = GetConVar("bc2_TempDisableTimeHurt"):GetFloat()
cloakconfig["CloakEffectOn"] = GetConVar("bc2_CloakEffectOn"):GetString()
cloakconfig["CloakEffectOff"] = GetConVar("bc2_CloakEffectOff"):GetString()
cloakconfig["ToggleTime"] = GetConVar("bc2_ToggleTime"):GetFloat()
-- Audio
cloakconfig["DistortSound"] = GetConVar("bc2_DistortSound"):GetInt()
cloakconfig["EnableSound"] = GetConVar("bc2_EnableSound"):GetString()
cloakconfig["DisableSound"] = GetConVar("bc2_DisableSound"):GetString()
cloakconfig["ForceDisableSound"] = GetConVar("bc2_ForceDisableSound"):GetString()
cloakconfig["ToggleFailureSound"] = GetConVar("bc2_ToggleFailureSound"):GetString()
cloakconfig["FootstepVolume"] = GetConVar("bc2_FootstepVolume"):GetFloat()
cloakconfig["TauntSound"] = GetConVar("bc2_TauntSound"):GetString()
cloakconfig["TauntVolume"] = GetConVar("bc2_TauntVolume"):GetFloat()
cloakconfig["TauntDelay"] = GetConVar("bc2_TauntDelay"):GetFloat()




for k,v in pairs(cloakconfig) do
    cvars.AddChangeCallback(k, function(convarName, oldValue, newValue) 

            tableCV[convarName] = newValue


    end)
end
--PATH lua/weapons/cloaking-infinite/shared.lua:
AddCSLuaFile()
include("weapons/ce_bcr_config.lua")



//----------------------------------
// SWEP Info
//----------------------------------
SWEP.Author                 =   "Temporary Solutions"
SWEP.PrintName              =   "Cloaking - Infinite"
SWEP.Base                   =   "weapon_base"
SWEP.Instructions           =   [[Left-Click: Toggle Cloak
Right-Click: N/A]]
SWEP.Spawnable              =   true
SWEP.AdminSpawnable         =   true
SWEP.AdminOnly 				= 	true
//----------------------------------
// SWEP Models
//----------------------------------
SWEP.ViewModelFlip          =   false
SWEP.UseHands               =   false
SWEP.ViewModel              =   "models/weapons/v_hands.mdl"
SWEP.WorldModel             =   ""
SWEP.HoldType               =   "normal"
//----------------------------------
// SWEP Slot Properties
//----------------------------------
SWEP.AutoSwitchTo           =   true
SWEP.AutoSwithFrom          =   true
SWEP.Slot                   =   5
SWEP.SlotPos                =   120
//----------------------------------
// SWEP Weapon Properties
SWEP.DrawAmmo               =   false
//----------------------------------
SWEP.DrawCrosshair          =   false
SWEP.m_WeaponDeploySpeed 	= 	100
SWEP.OnRemove = onDeathDropRemove
SWEP.OnDrop = onDeathDropRemove

SWEP.Primary.ClipSize       =   0
SWEP.Primary.DefaultClip    =   0
SWEP.Primary.Ammo           =   "none"
SWEP.Primary.Automatic      =   false
 
SWEP.Secondary.ClipSize     =   -1
SWEP.Secondary.DefaultClip  =   -1
SWEP.Secondary.Ammo         =   "none"
SWEP.Secondary.Automatic    =   false

--[[
	Hey me, don't forget if you're going to copy paste this for the other 3 sweps you need to:
	Change cloakconfig.MaxCharge0
	Edit SWEP:Equip, The Timers, and HudDraw
	And change ce_bc2_0
]]--

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)

    sound.Add({
	name = "CloakTauntSound",
	channel = CHAN_STATIC,
	volume = cloakconfig.TauntVolume,
	level = 70,
	pitch = { 95, 100 },
	sound = cloakconfig.TauntSound})
end


local function Cloak(ply)
	local plyVelocity = ply:GetVelocity()
    local plyWeapon = ply:GetActiveWeapon()
    local col = ply:GetColor()
    ply:SetNWBool("HideHUD", true)

    local untilVelAlpha = math.max(0, plyVelocity:Length() - cloakconfig.CloakUntilVel) 	-- Keeps player completly cloaked until they meet a set velocity.
    local approachAlpha = math.Approach(col.a, untilVelAlpha, 500 * FrameTime()) 	-- Gradually get to the alpha (Instead of snapping to it).
    approachAlpha = math.max(approachAlpha, cloakconfig.MinimumVisibility) 	-- If the alpha is being set below the set minimum, just use the minimum.

    --[[
    	This is a fix for most weapons not going invisible unless the
    	alpha is 0. I don't think I can fix this as
    	it probably has to do with the weapon's models or textures.
    --]]
    local wepAlpha = 0
    
    if untilVelAlpha >= 70 then
    	wepAlpha = untilVelAlpha
   	else
   		wepAlpha = 0
   	end

   	if cloakconfig.CloakEffectOn ~= "" then
   		local effectpos = ply:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin(effectpos)
		effectdata:SetNormal(Vector(0, 0, 0))
		util.Effect(cloakconfig.CloakEffectOn, effectdata)
	end


	ply:RemoveAllDecals()
	ply:DrawShadow(false)
	ply:SetDSP(cloakconfig.DistortSound)

	if cloakconfig.CloakType == "Transparent" then
		ply:SetRenderMode(RENDERMODE_TRANSALPHA)
		ply:SetColor(Color(255, 255, 255, approachAlpha))
		plyWeapon:SetRenderMode(RENDERMODE_TRANSALPHA)
		plyWeapon:SetColor(Color(255, 255, 255, wepAlpha))
	elseif cloakconfig.CloakType == "Material" then
		ply:SetMaterial(cloakconfig.CloakMaterial, true)
		plyWeapon:SetMaterial(cloakconfig.CloakMaterial, true)
	end

	if SERVER then
		if approachAlpha < cloakconfig.MinimumNPCVisibility then
			ply:SetNoTarget(true)
		else
			ply:SetNoTarget(false)
		end
	end
end



local function Uncloak(ply, forced, debug, holdcharge)
	--print(debug)
	if forced and cloakconfig.ForceDisableSound ~= "" and ply.CloakActive then
		ply:EmitSound(cloakconfig.ForceDisableSound)
		--print("0 1")
	elseif cloakconfig.DisableSound ~= ""  and debug ~= "Equip" and ply.CloakActive then
		ply:EmitSound(cloakconfig.DisableSound)
		--print("0 2")
	end
	ply:SetNWBool("HideHUD", false)
	ply.CloakActive = false
	ply:SetDSP(0)
    ply:DrawShadow(true)
    ply:SetRenderMode(RENDERMODE_NORMAL)
    ply:SetColor(Color(255, 255, 255, 255))
    ply:SetMaterial("")

    if SERVER then
    	ply:SetNoTarget(false)
    end

    if not holdcharge then
   		ply:SetNWFloat("CloakCharge", cloakconfig.MaxCharge0)
   	end

    timer.Simple(cloakconfig.ToggleTime, function()
		ply.AllowedToggle = true
	end)

    if cloakconfig.CloakEffectOff != "" then
   		local effectpos = ply:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin(effectpos)
		effectdata:SetNormal(Vector(0, 0, 0))
		util.Effect(cloakconfig.CloakEffectOff, effectdata)
	end

    for k, v in pairs(ply:GetWeapons()) do 	-- Uncloaks previously cloaked weapons
    	if IsValid(v) then
    		v:SetRenderMode(RENDERMODE_NORMAL)
   	 		v:SetColor(Color(255, 255, 255, 255))
   	 	end
   	end
end



local DontSpam = 0
function SWEP:PrimaryAttack()
	local ply = self:GetOwner()

	if ply.CloakActive == nil then
		ply.CloakActive = false
	elseif ply.AllowedToggle == nil then
		ply.AllowedToggle = true
	end

	if DontSpam < CurTime() then
		if SERVER then
			if not ply.CloakActive and ply.AllowedToggle then
				ply.CloakActive = true
				ply.AllowedToggle = false
				if cloakconfig.EnableSound != "" then
   					ply:EmitSound(cloakconfig.EnableSound)
   				end
			elseif ply.CloakActive then
				if cloakconfig.CloakMode == "Charge" then
					Uncloak(ply, false, "Primary", true)
				else
					Uncloak(ply, false, "Primary")
				end
			else
				if cloakconfig.ToggleFailureSound != "" then
				ply:EmitSound(cloakconfig.ToggleFailureSound)
				end
			end
		end
		DontSpam = CurTime() + 0.5
	end
end



function SWEP:CanSecondaryAttack()	
	return false
end



function SWEP:Reload()
	ply = self:GetOwner()
	if (self.nextreload or 0) <= CurTime() and cloakconfig.TauntSound != "" then
    	self.nextreload = CurTime() + cloakconfig.TauntDelay
		ply:EmitSound("CloakTauntSound")
	end
end



function SWEP:Deploy()
	self.Owner:DrawViewModel(false)
end



function SWEP:Equip()
	local ply = self.Owner

	--(Removes Other Cloaks)--
	if ply:HasWeapon("cloaking-1") then
		ply:StripWeapon("cloaking-1")
	elseif ply:HasWeapon("cloaking-2") then
		ply:StripWeapon("cloaking-2")
	elseif ply:HasWeapon("cloaking-3") then
		ply:StripWeapon("cloaking-3")
	end

	Uncloak(ply, false, "Equip")

	if cloakconfig.CloakMode == "Rechage" then
		self.Owner.CloakCharge = cloakconfig.MaxCharge0
	end
end



hook.Add("PlayerPostThink", "ce_bc2_0_ThinkHook", function(ply)
	if ply.CloakActive then
		Cloak(ply)
	end

	if not ply.LastCharge then
		ply.LastCharge = CurTime()
	end

	if SERVER and ply:HasWeapon("cloaking-0") then
		if cloakconfig.CloakMode == "Charge" and cloakconfig.MaxCharge0 != 0 then
			if ply.LastCharge + (1 * cloakconfig.ChargeLossMultiplier) <= CurTime() and ply:GetNWFloat("CloakCharge") > 0 and ply.CloakActive then 	-- Depletes Charge
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") - 1)
				ply.LastCharge = CurTime()
			elseif ply.LastCharge + (1 * cloakconfig.ChargeGainMultiplier) <= CurTime() and ply:GetNWFloat("CloakCharge") < cloakconfig.MaxCharge0 and !ply.CloakActive and !ply.CloakPause then 	-- Adds Charge
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") + 1)
				ply.LastCharge = CurTime()
			elseif ply.CloakActive and ply:GetNWFloat("CloakCharge") == 0 then	-- Uncloaks when out of charge
				Uncloak(ply, true, "Charge", true)
			end
		end
	end

	-- Its like charge, without the recharge
	if ply:HasWeapon("cloaking-infinite") then
		if cloakconfig.CloakMode == "Timer" and cloakconfig.MaxCharge0 != 0 then
			if ply.LastCharge + 1 <= CurTime() and ply:GetNWFloat("CloakCharge") > 0 and ply.CloakActive then
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") - 1)
				ply.LastCharge = CurTime()
			elseif ply.CloakActive and ply:GetNWFloat("CloakCharge") == 0 and cloakconfig.MaxCharge0 != 0 then
				Uncloak(ply, true, "Timer0")
				ply:SetNWFloat("CloakCharge", cloakconfig.MaxCharge0)
			end
		end
	end
		-- Copy pasted as an attempted bugfix for some weapons being a pain in the ass
	local plyVelocity = ply:GetVelocity()
    local plyWeapon = ply:GetActiveWeapon()
    local col = ply:GetColor()

    local untilVelAlpha = math.max(0, plyVelocity:Length() - cloakconfig.CloakUntilVel) 	-- Keeps player completly cloaked until they meet a set velocity.
    local approachAlpha = math.Approach(col.a, untilVelAlpha, 500 * FrameTime()) 	-- Gradually get to the alpha (Instead of snapping to it).
    approachAlpha = math.max(approachAlpha, cloakconfig.MinimumVisibility) 	-- If the alpha is being set below the set minimum, just use the minimum.

    --[[
    	This is a fix for most weapons not going invisible unless the
    	alpha is 0. I don't think I can fix this as
    	it probably has to do with the weapon's models or textures.
    --]]
    local wepAlpha = 0
    
    if untilVelAlpha >= 70 then
    	wepAlpha = untilVelAlpha
   	else
   		wepAlpha = 0
   	end

   	if cloakconfig.CloakType == "Transparent" and ply.CloakActive then
		plyWeapon:SetRenderMode(RENDERMODE_TRANSALPHA)
		plyWeapon:SetColor(Color(255, 255, 255, wepAlpha))
	elseif cloakconfig.CloakType == "Material" and ply.CloakActive then
		plyWeapon:SetMaterial(cloakconfig.CloakMaterial, true)
	end
end)



hook.Add("EntityFireBullets", "ce_bc2_0_UncloakOnFire", function(ent, bullet)
	if IsValid(ent) and ent:IsPlayer() and ent.CloakActive then
		if cloakconfig.CloakFireMode == 1 then
			Uncloak(ent, true, "Fired")
		elseif cloakconfig.CloakFireMode == 2 then
			if cloakconfig.CloakMode == "Charge" then
				ent:SetNWFloat("CloakCharge", ent:GetNWFloat("CloakCharge") - cloakconfig.LoseChargeAmountFire)
			elseif cloakconfig.CloakMode == "Timer" then
				print("Yeah you probably shouldn't set a charge option if you're using the timer mode.\nDefaulting to Option 1")
				GetConVar("bc2_CloakFireMode"):SetInt(1)
				Uncloak(ent, true, "Fired2")
			end
		elseif cloakconfig.CloakFireMode == 3 and ent:Alive() then
			Uncloak(ent, true, "Fired3", true)
			ent.AllowedToggle = false
			ent.CloakPause = true
			timer.Simple(cloakconfig.TempDisableTimeFire, function()
				if IsValid(ent) and not ent.DidSomethingStupid then
					ent.CloakActive = true
				end
			ent.AllowedToggle = true
			ent.DidSomethingStupid = false
			ent.CloakPause = false
			end)
		end
	end
end)



hook.Add("EntityTakeDamage", "ce_bc2_0_UncloakOnDamage", function(ent, dmginfo)
	if IsValid(ent) and ent:IsPlayer() and ent.CloakActive then
		if cloakconfig.CloakDamageMode == 1 then
			Uncloak(ent, true, "Damage")
		elseif cloakconfig.CloakDamageMode == 2 then
			if cloakconfig.CloakMode == "Charge" then
				ent:SetNWFloat("CloakCharge", ent:GetNWFloat("CloakCharge") - cloakconfig.LoseChargeAmountHurt)
			elseif cloakconfig.CloakMode == "Timer" then
				print("Yeah you probably shouldn't set a charge option if you're using the timer mode.\nDefaulting to Option 1")
				GetConVar("bc2_CloakDamageMode"):SetInt(1)
				Uncloak(ent, true, "Damage2")
			end
		elseif cloakconfig.CloakDamageMode == 3 and ent:Alive() then
			Uncloak(ent, true, "Damage3", true)
			ent.AllowedToggle = false
			ent.CloakPause = true
			timer.Simple(cloakconfig.TempDisableTimeHurt, function()
				if IsValid(ent) and not ent.DidSomethingStupid then
					ent.CloakActive = true
				end
			ent.AllowedToggle = true
			ent.DidSomethingStupid = false
			ent.CloakPause = false
			end)
		end
	end
end)



hook.Add("PlayerFootstep", "ce_bc2_0_SilentSteps", function(ply, pos, foot, sound, volume, rf)
    if ply.CloakActive then
    	ply:EmitSound(sound, 20, nil, cloakconfig.FootstepVolume, 4)
   		return true
	else
    	return false
 	end
end)



hook.Add("HUDDrawTargetID", "ce_bc2_0_HidePlayerID", function()
	if CLIENT then
    	local gplytr = util.GetPlayerTrace(LocalPlayer())
    	local ent = util.TraceLine(gplytr).Entity
    	local col = 255
    	if IsValid(ent) then
    		col = ent:GetColor()
    	end

    	if ent:IsPlayer() and IsValid(ent) then
    		if cloakconfig.CloakType == "Transparent" and ent.CloakActive and col.a < cloakconfig.MinimumIDVisibility then
        		return false
        	elseif cloakconfig.CloakType == "Material" and ent.CloakActive then
           		return false
           	else
           		return
        	end
        end
	end
end)



hook.Add("HUDPaint", "ce_bc2_1_DrawThings", function()
	local ply = LocalPlayer()
	if IsValid(ply) and ply:Alive() and IsValid(ply:GetActiveWeapon()) then

		local activeweapon = ply:GetActiveWeapon():GetClass()

		if ply.CloakActive and cloakconfig.CloakOverlay ~= "" then
			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetMaterial(Material(cloakconfig.CloakOverlay))
			surface.DrawTexturedRect( 0, 0, ScrW(), ScrH())
		end

		if ply:HasWeapon("cloaking-0") and GetConVar("bc2_ShowCloakCharge"):GetBool() and (activeweapon == "cloaking-0" or ply:GetNWFloat("CloakCharge") != cloakconfig.MaxCharge0) and cloakconfig.MaxCharge0 != 0 then
			draw.SimpleText(ply:GetNWFloat("CloakCharge"), "DermaLarge", ScrW()/2 - 25, 900, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
	end
end)



hook.Add("HUDShouldDraw", "DarkRP_HideDarkPlayerID", function(hudName)
    if hudName ~= "DarkRP_EntityDisplay" then return end

    local playersToDraw = {}
    for _,ply in pairs(player.GetAll()) do
        if IsValid(ply) and not ply:GetNWBool("HideHUD") then
            table.insert(playersToDraw, ply)
        end
    end
    return true, playersToDraw
end)



hook.Add("PlayerEnteredVehicle", "ce_bc2_0_UncloakEnteringVehicle", function(ply, veh, seat)
	if ply.CloakActive and cloakconfig.UncloakInVehicle then
		Uncloak(ply, false, "Vehicle")
	end
end)


-- Accidents
local function onDemote(source, demoted, reason)
	if demoted.CloakActive then
	Uncloak(demoted, false, "Demoted")
	demoted.DidSomethingStupid = true
	end
end

local function UncloakOnAccident(ply)
	Uncloak(ply, false, "Accident")
	ply.DidSomethingStupid = true
end

hook.Add("PlayerDeath", "ce_bc2_0_Death" , UncloakOnAccident)
hook.Add("playerAFKDemoted", "ce_bc2_0_AFK" , UncloakOnAccident)
hook.Add("onPlayerDemoted", "ce_bc2_0_Demoted" , onDemote)
hook.Add("playerArrested", "ce_bc2_0_Arrested" , UncloakOnAccident)
hook.Add("playerStarved", "ce_bc2_0_Starved" , UncloakOnAccident)
hook.Add("OnPlayerChangedTeam", "ce_bc2_0_ChangedTeam" , UncloakOnAccident)
--PATH lua/weapons/deployable_force_shield_augment_wep.lua:
-- Define SWEP settings
SWEP.PrintName = "Deployable Force Shield"
SWEP.Author = "Wedge"
SWEP.Purpose = "To absorb damage."
SWEP.Instructions = "Left-click to attack."

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "Warfront Misc" -- Change this to your desired weapon category

SWEP.Primary.Ammo = ""
SWEP.Secondary.Ammo = ""
SWEP.Weight = 5

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_arms.mdl"
SWEP.WorldModel = ""

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Delay = 0.2

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Delay = 0.1

SWEP.Slot = 0
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

function SWEP:Initialize()
end

function SWEP:PrimaryAttack()
    if SERVER then
        self.Owner:ConCommand("deploy_force_shield")
    end
    self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
end

function SWEP:SecondaryAttack()
    if SERVER then
        self.Owner:ConCommand("deploy_force_shield")
    end
    self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
end

--PATH lua/weapons/dual_base/cl_init.lua:
include('shared.lua')

--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/weapons/gas_log_scanner/shared.lua:
local function L(phrase, discriminator)
	return GAS:Phrase(phrase, "logging", discriminator)
end

local COLOR_RED = Color(255, 0, 0)
local SCANNER_HUD

SWEP.PrintName    = "bLogs Scanner"
SWEP.Category     = "GmodAdminSuite"
SWEP.Author       = "GmodAdminSuite"
SWEP.Purpose      = "This scanner allows you to view logs related to entities in the world"
SWEP.Instructions = "Look at an entity"
SWEP.Contact      = "www.gmodadminsuite.com"

SWEP.Slot           = 5
SWEP.SlotPos        = 2
SWEP.DrawAmmo       = false
SWEP.DrawCrosshair  = true
SWEP.Weight         = 5
SWEP.AutoSwitchTo   = false
SWEP.AutoSwitchFrom = false

SWEP.ViewModel  = "models/weapons/v_emptool.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.Spawnable  = true
SWEP.AdminOnly  = true

SWEP.ShowViewModel  = true
SWEP.ShowWorldModel = false

SWEP.Primary.ClipSize    = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = false
SWEP.Primary.Ammo        = "none"

SWEP.Secondary.ClipSize    = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic   = false
SWEP.Secondary.Ammo        = "none"

SWEP.HolsterSound       = Sound("npc/turret_floor/retract.wav")
SWEP.DeploySound        = Sound("npc/turret_floor/deploy.wav")
SWEP.ErrorSound         = Sound("npc/roller/code2.wav")
SWEP.ViewLogsSound      = Sound("AlyxEMP.Discharge")
SWEP.ShowInterfaceSound = Sound("gmodadminsuite/btn_light.ogg")
SWEP.HideInterfaceSound = Sound("gmodadminsuite/btn_heavy.ogg")

SWEP.WElements = {
	["scanner"] = {
		type = "Model",
		model = "models/weapons/w_emptool.mdl",
		bone = "ValveBiped.Anim_Attachment_LH",
		rel = "",
		pos = Vector(0.518, -3.636, 6.752),
		angle = Angle(38.57, -180, 12.857),
		size = Vector(1, 1, 1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

if (CLIENT) then
	function SWEP:Initialize()
		self:CreateModels(self.WElements)
	end
end

function SWEP:PrimaryAttack()
	self:SendWeaponAnim(ACT_VM_FIDGET)

	if (CLIENT) then
		if (IsValid(self.HUD) and self.HUD:IsVisible()) then
			self.LastInspectedEnt = self.HUD.InspectingEnt
			self.LastInspectedEntHUD = self.HUD

			self.HUD:ShowCloseButton(true)
			self.HUD:ShowFullscreenButton(true)
			self.HUD:ShowPinButton(true)
			self.HUD:MakePopup()

			GAS:PlaySound("popup")
			self.HUD = nil
			self:CreateInterface()

			local tr = self.Owner:GetEyeTrace()
			local effectdata = EffectData()
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			effectdata:SetMagnitude(8)
			effectdata:SetScale(1)
			effectdata:SetRadius(16)
			util.Effect("cball_bounce", effectdata)

			self:EmitSound(self.ViewLogsSound)
		else
			self:EmitSound(self.ErrorSound)
		end
	end

	return true
end

function SWEP:SecondaryAttack()
	return false
end

if (SERVER) then
	util.AddNetworkString("gmodadminsuite:gas_log_scanner:Init")
	function SWEP:Deploy()
		if (not IsFirstTimePredicted()) then return end
		self:SetHoldType("duel")
		self:EmitSound(self.DeploySound)
		self:SendWeaponAnim(ACT_VM_DRAW)
		
		GAS:netStart("gas_log_scanner:Init")
		net.Send(self.Owner)
	end
else
	function SWEP:NetworkedDeploy()
		hook.Add("PreDrawHalos", "gas_log_scanner:Halo", function()
			if (not IsValid(self)) then
				timer.Remove("gas_log_scanner:UncacheData")
				timer.Remove("gas_log_scanner:LoadLogs")
				hook.Remove("PreDrawHalos", "gas_log_scanner:Halo")
				if (IsValid(SCANNER_HUD)) then
					SCANNER_HUD:Close()
				end
			else
				self:DrawHalo()
			end
		end)
		self:CreateInterface()
	end
	net.Receive("gmodadminsuite:gas_log_scanner:Init", function()
		timer.Create("gas_log_scanner:Init", 0, 0, function()
			if (IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "gas_log_scanner" and LocalPlayer():GetActiveWeapon().NetworkedDeploy ~= nil) then
				LocalPlayer():GetActiveWeapon():NetworkedDeploy()
				timer.Remove("gas_log_scanner:Init")
			end
		end)
	end)
end

function SWEP:Holster()
	if (not IsFirstTimePredicted()) then
		return
	end
	self:EmitSound(self.HolsterSound)
	if (CLIENT) then
		timer.Remove("gas_log_scanner:UncacheData")
		timer.Remove("gas_log_scanner:LoadLogs")
		hook.Remove("PreDrawHalos", "gas_log_scanner:Halo")
		if (IsValid(self.HUD)) then
			self.HUD:Close()
		end
	end
	return true
end

if (SERVER) then
	function SWEP:Think()
		if (not IsValid(self.Owner)) then return end
		local tr = self.Owner:GetEyeTrace()
		if (IsValid(tr.Entity) and not tr.Entity:IsWorld()) then
			self:SetHoldType("magic")
		else
			self:SetHoldType("duel")
		end
	end
end

if (CLIENT) then
	hook.Add("PlayerSwitchWeapon", "gas_log_scanner:RemoveMenuOnSwitch", function(ply, oldWeapon, newWeapon)
		if (ply ~= LocalPlayer()) then return end
		if (IsValid(oldWeapon) and oldWeapon:GetClass() == "gas_log_scanner") then
			if (IsValid(newWeapon) and newWeapon:GetClass() == "gas_log_scanner") then
				return
			else
				timer.Remove("gas_log_scanner:UncacheData")
				timer.Remove("gas_log_scanner:LoadLogs")
				hook.Remove("PreDrawHalos", "gas_log_scanner:Halo")
				if (IsValid(oldWeapon.HUD)) then
					oldWeapon.HUD:Close()
				end
			end
		end
	end)

	function SWEP:CreateInterface()
		timer.Remove("gas_log_scanner:LoadLogs")
		if (IsValid(self.HUD)) then
			self.HUD:Close()
		end
		if (IsValid(SCANNER_HUD)) then
			SCANNER_HUD:Close()
		end

		self.HUD = vgui.Create("bVGUI.Frame")
		local HUD = self.HUD
		SCANNER_HUD = HUD

		HUD.FirstLoad = true
		HUD:SetTitle("bLogs Scanner")
		HUD:SetSize(425,400)
		HUD:SetPos(1050,300)
		HUD:ShowCloseButton(false)
		HUD:ShowFullscreenButton(false)
		HUD:ShowPinButton(false)
		HUD:SetVisible(false)

		HUD.Pagination = vgui.Create("bVGUI.Pagination", HUD)
		HUD.Pagination:SetTall(30)
		HUD.Pagination:Dock(TOP)
		HUD.Pagination:SetPages(1)
		function HUD.Pagination:OnPageSelected(page)
			HUD.Logs:Clear()
			HUD.Logs:SetLoading(true)
			local function LoadLogs()
				if (not IsValid(HUD) or not IsValid(self)) then return end
				HUD.FirstLoad = nil
				if (not IsValid(HUD.InspectingEnt)) then
					HUD.Logs:SetLoading(false)
				else
					local function LoadScannerLogs()
						GAS:StartNetworkTransaction("logging:LoadScannerLogs", function()
							net.WriteUInt(page, 16)
							net.WriteEntity(HUD.InspectingEnt)
						end, function(data_present, l)
							if (not IsValid(HUD)) then return end
							HUD.Logs:SetLoading(false)
							if (data_present) then
								local ent = net.ReadEntity()
								local pages = net.ReadUInt(16)
								local logs = GAS:DeserializeTable(util.Decompress(net.ReadData(l - 16 - 16)))

								HUD.Pagination:SetPages(pages)
								for _,log in ipairs(logs) do
									local module_data = GAS.Logging.IndexedModules[log[2]]
									local formatted_log = GAS.Logging:FormatMarkupLog(log, GAS.Logging.Config.ColoredLogs or true)
									local log_row = HUD.Logs:AddRow("<color=" .. GAS:Unvectorize(module_data.Colour or bVGUI.COLOR_WHITE) .. ">" .. GAS:EscapeMarkup(module_data.Name) .. "</color>", GAS:SimplifyTimestamp(log[3]), formatted_log)
									log_row.Data = log
									log_row.IsColored = GAS.Logging.Config.ColoredLogs or true
								end
							end
						end)
					end
					if (GAS.Logging.IndexedModules == nil) then
						GAS:StartNetworkTransaction("logging:GetModules", nil, function()
							net.ReadBool()
							local data_len = net.ReadUInt(16)

							GAS.Logging.Modules = {}
							GAS.Logging.IndexedModules = GAS:DeserializeTable(util.Decompress(net.ReadData(data_len)))
							for module_id, module_data in pairs(GAS.Logging.IndexedModules) do
								if (module_data.Offline) then continue end
								GAS.Logging.Modules[module_data.Category] = GAS.Logging.Modules[module_data.Category] or {}
								GAS.Logging.Modules[module_data.Category][module_data.Name] = module_data
							end

							LoadScannerLogs()
						end)
					else
						LoadScannerLogs()
					end
				end
			end
			if (HUD.FirstLoad) then
				timer.Create("gas_log_scanner:LoadLogs", .5, 1, LoadLogs)
			else
				LoadLogs()
			end
		end

		HUD.Logs = vgui.Create("bVGUI.Table", HUD)
		HUD.Logs:Dock(FILL)
		HUD.Logs:AddColumn(L"module", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
		HUD.Logs:AddColumn(L"when", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
		HUD.Logs:AddColumn(L"log", bVGUI.TABLE_COLUMN_GROW)
		HUD.Logs:SetRowCursor("hand")
		HUD.Logs:SetLoading(true)

		function HUD.Logs:OnRowRightClicked(row)
			self:OnRowClicked(row)
		end
		function HUD.Logs:OnRowClicked(row)
			GAS.Logging:OpenLogsContextMenu(row)
		end
	end

	SWEP.HaloTable = {}
	function SWEP:DrawHalo()
		if (not IsValid(self) or not IsValid(self.Owner) or self.Owner:GetActiveWeapon() ~= self) then
			return hook.Remove("PreDrawHalos", "gas_log_scanner:Halo")
		end
		local tr = self.Owner:GetEyeTrace()
		if (IsValid(tr.Entity) and not tr.Entity:IsWorld()) then
			if (tr.Entity == self.LastInspectedEnt and IsValid(self.LastInspectedEntHUD)) then
				self.HaloTable[1] = nil
				return
			end
			if (self.HaloTable[1] == nil) then
				self:EmitSound(self.ShowInterfaceSound)
			end
			self.HaloTable[1] = tr.Entity

			halo.Add(self.HaloTable, COLOR_RED, 2, 2, 5, true, true)

			if (IsValid(self.HUD)) then
				self.HUD:SetVisible(true)
				self.HUD:SetTitle(tr.Entity:GetClass() .. " (" .. tr.Entity:EntIndex() .. ")")
				self.HUD.InspectingEnt = tr.Entity
				if (self.HUD.LastInspectedEnt ~= tr.Entity) then
					self.HUD.LastInspectedEnt = tr.Entity
					self.HUD.FirstLoad = true
					self.HUD.Pagination:SetPages(1)
					self.HUD.Pagination:SetPage(1)
					self.HUD.Pagination:OnPageSelected(1)
				end
				if (self.HUD.UncacheData) then
					self.HUD.UncacheData = nil
					self.HUD.Pagination:SetPage(1)
					self.HUD.Pagination:OnPageSelected(1)
				end
			end

			timer.Remove("gas_log_scanner:UncacheData")
		else
			self.LastInspectedEntHUD = nil
			self.LastInspectedEnt = nil

			if (self.HaloTable[1] ~= nil) then
				self:EmitSound(self.HideInterfaceSound)
			end
			self.HaloTable[1] = nil

			if (IsValid(self.HUD)) then
				self.HUD:SetVisible(false)
				self.HUD.InspectingEnt = nil
				if (not timer.Exists("gas_log_scanner:UncacheData") and not self.HUD.UncacheData) then
					timer.Create("gas_log_scanner:UncacheData", 3, 1, function()
						self.HUD.UncacheData = true
					end)
				end
			end
		end
	end

	-- Credit for this goes to the SWEP Construction Kit
	-- https://github.com/Clavus/SWEP_Construction_Kit

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if (self.GetBoneOrientation == nil) then return end
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end

		if (not self.wRenderOrder) then
			self.wRenderOrder = {}
			for k, v in pairs(self.WElements) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end

		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			bone_ent = self
		end

		for k, name in pairs(self.wRenderOrder) do
			local v = self.WElements[name]
			if (not v) then
				self.wRenderOrder = nil
				break
			end
			if (v.hide) then continue end

			local pos, ang

			if (v.bone) then
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent)
			else
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand")
			end

			if (not pos) then continue end

			local model = v.modelEnt

			model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
			model:SetAngles(ang)
			local matrix = Matrix()
			matrix:Scale(v.size)
			model:EnableMatrix("RenderMultiply", matrix)

			if (v.material == "") then
				model:SetMaterial("")
			elseif (model:GetMaterial() ~= v.material) then
				model:SetMaterial(v.material)
			end

			if (v.skin and v.skin ~= model:GetSkin()) then
				model:SetSkin(v.skin)
			end

			if (v.bodygroup) then
				for k, v in pairs(v.bodygroup) do
					if (model:GetBodygroup(k) ~= v) then
						model:SetBodygroup(k, v)
					end
				end
			end

			if (v.surpresslightning) then
				render.SuppressEngineLighting(true)
			end

			render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
			render.SetBlend(v.color.a / 255)
			model:DrawModel()
			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)

			if (v.surpresslightning) then
				render.SuppressEngineLighting(false)
			end
		end
	end

	function SWEP:CreateModels(tab)
		for k, v in pairs(tab) do
			if
				(v.type == "Model" and v.model and v.model ~= "" and (not IsValid(v.modelEnt) or v.createdModel ~= v.model) and
					string.find(v.model, ".mdl") and
					file.Exists(v.model, "GAME"))
			 then
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif
				(v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spriteMaterial or v.createdSprite ~= v.sprite) and
					file.Exists("materials/" .. v.sprite .. ".vmt", "GAME"))
			 then
				local name = v.sprite .. "-"
				local params = {["$basetexture"] = v.sprite}
				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}
				for i, j in pairs(tocheck) do
					if (v[j]) then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
			end
		end
	end
end

--PATH addons/[misc] smartspawnmanager/lua/weapons/gmod_tool/stools/smart_category_spawn.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/weapons/gmod_tool/stools/smart_entity_spawn.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/vjstool_bullseye.lua:
TOOL.Name = "#tool.vjstool_bullseye.name"
TOOL.Tab = "DrVrej"
TOOL.Category = "Tools"
TOOL.Command = nil -- The console command to execute upon being selected in the Q menu.

TOOL.Information = {
	{name = "left"},
}

TOOL.ClientConVar["type"] = "Dynamic"
TOOL.ClientConVar["modeldirectory"] = "models/hunter/plates/plate.mdl"
TOOL.ClientConVar["usecolor"] = 1
TOOL.ClientConVar["startactivate"] = 1

-- Just to make it easier to reset everything to default
local DefaultConVars = {}
for k,v in pairs(TOOL.ClientConVar) do
	DefaultConVars["vjstool_bullseye_"..k] = v
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local function DoBuildCPanel_VJ_BullseyeSpawner(Panel)
		local reset = vgui.Create("DButton")
		reset:SetFont("DermaDefaultBold")
		reset:SetText("#vjbase.menu.general.reset.everything")
		reset:SetSize(150,25)
		reset:SetColor(Color(0,0,0,255))
		reset.DoClick = function()
			for k,v in pairs(DefaultConVars) do
				if v == "" then
				LocalPlayer():ConCommand(k.." ".."None")
			else
				LocalPlayer():ConCommand(k.." "..v) end
				timer.Simple(0.05,function()
					GetPanel = controlpanel.Get("vjstool_bullseye")
					GetPanel:ClearControls()
					DoBuildCPanel_VJ_BullseyeSpawner(GetPanel)
				end)
			end
		end
		Panel:AddPanel(reset)
		
		local tutorial = vgui.Create("DButton")
		tutorial:SetFont("DermaDefaultBold")
		tutorial:SetText("#tool.vjstool.menu.tutorialvideo")
		tutorial:SetSize(150, 20)
		tutorial:SetColor(Color(0,0,255,255))
		tutorial.DoClick = function()
			gui.OpenURL("http://www.youtube.com/watch?v=Qf-vrE-BAW4")
		end
		Panel:AddPanel(tutorial)
		
		Panel:AddControl("Label", {Text = "#tool.vjstool.menu.label.recommendation"})
		Panel:ControlHelp("- "..language.GetPhrase("#tool.vjstool_bullseye.menu.help1"))
		Panel:ControlHelp("- "..language.GetPhrase("#tool.vjstool_bullseye.menu.help2"))
		Panel:AddControl("Label", {Text = language.GetPhrase("#tool.vjstool_bullseye.menu.label1")..":"})
		local typebox = vgui.Create("DComboBox")
		//typebox:SetConVar("vjstool_bullseye_type")
		typebox:SetValue(GetConVarString("vjstool_bullseye_type"))
		typebox:AddChoice("Dynamic")
		typebox:AddChoice("Static")
		typebox:AddChoice("Physics")
		function typebox:OnSelect(index,value,data)
			LocalPlayer():ConCommand("vjstool_bullseye_type "..value)
		end
		Panel:AddPanel(typebox)
		Panel:AddControl("Label", {Text = language.GetPhrase("#tool.vjstool_bullseye.menu.label2")..":"})
		local modeldir = vgui.Create("DTextEntry")
		modeldir:SetConVar("vjstool_bullseye_modeldirectory")
		modeldir:SetMultiline(false)
		Panel:AddPanel(modeldir)
		Panel:AddControl("Checkbox", {Label = "#tool.vjstool_bullseye.menu.toggleusestatus", Command = "vjstool_bullseye_usecolor"})
		Panel:AddControl("Checkbox", {Label = "#tool.vjstool_bullseye.menu.togglestartactivated", Command = "vjstool_bullseye_startactivate"})
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	function TOOL.BuildCPanel(Panel)
		DoBuildCPanel_VJ_BullseyeSpawner(Panel)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:LeftClick(tr)
	if CLIENT then return true end
		local spawner = ents.Create("obj_vj_bullseye")
		spawner:SetPos(tr.HitPos)
		spawner:SetModel(GetConVarString("vjstool_bullseye_modeldirectory"))
		spawner.SolidMovementType = GetConVarString("vjstool_bullseye_type")
		spawner.UseActivationSystem = true
		spawner.UserStatusColors = GetConVar("vjstool_bullseye_usecolor"):GetBool()
		spawner.Activated = GetConVar("vjstool_bullseye_startactivate"):GetBool()
		spawner:Spawn()
		spawner:Activate()
		undo.Create("NPC Bullseye")
		undo.AddEntity(spawner)
		undo.SetPlayer(self:GetOwner())
		undo.Finish()
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:RightClick(tr)
	if CLIENT then return true end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Reload(tr)
	if CLIENT then return true end
end
--PATH lua/weapons/gmod_tool/stools/vjstool_entityscanner.lua:
return gluapack()()
--PATH lua/weapons/jet_mk4.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Infinite Flight"
SWEP.Category	= "Star Wars Jetpacks"
SWEP.Purpose    = "LMB - Equip/Unequip\n\nSPACE - Fly up\n\nCTRL - Fly down\n\nSHIFT - Hover"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Fuel" )
	if ( SERVER ) then
		self:SetFuel(100)
	end
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end



function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if IsValid(ex) then
		ex:Remove()
		ply:SetNWEntity('Jetted',NULL)
		ply.LastJetExecuted = CurTime()
	else
		if !ply:IsOnGround() then return end
		if (ply.LastJetExecuted or 0)+1 >= CurTime() then return end
		local jp = ents.Create('mk4')
		jp:SetSlotName('mk4')
		jp:Spawn()
		jp:Attach(ply)
		ply.Jetted = jp
		ply:SetNWEntity('Jetted',jp)
	end
	ply:EmitSound('buttons/button14.wav')
end

local skinint = 1

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if !IsValid(ex) then return end
	skinint = (skinint + 1)%3
	ex:SetSkin(skinint)
	ply:EmitSound('buttons/button16.wav')
end

function SWEP:Deploy()
	return true
end

function SWEP:Equip()

end

function SWEP:ShouldDropOnDie() return false end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--PATH gamemodes/starwarsrp/entities/weapons/keys/cl_menu.lua:
local function AddButtonToFrame(Frame)
    Frame:SetTall(Frame:GetTall() + 110)

    local button = vgui.Create("DButton", Frame)
    button:SetPos(10, Frame:GetTall() - 110)
    button:SetSize(180, 100)

    Frame.buttonCount = (Frame.buttonCount or 0) + 1
    Frame.lastButton = button
    return button
end

DarkRP.stub{
    name = "openKeysMenu",
    description = "Open the keys/F2 menu.",
    parameters = {},
    realm = "Client",
    returns = {},
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "onKeysMenuOpened",
    description = "Called when the keys menu is opened.",
    parameters = {
        {
            name = "ent",
            description = "The door entity.",
            type = "Entity"
        },
        {
            name = "Frame",
            description = "The keys menu frame.",
            type = "Panel"
        }
    },
    returns = {
    },
    realm = "Client"
}

local KeyFrameVisible = false

local function openMenu(setDoorOwnerAccess, doorSettingsAccess)
    if KeyFrameVisible then return end
    local trace = LocalPlayer():GetEyeTrace()
    local ent = trace.Entity
    -- Don't open the menu if the entity is not ownable, the entity is too far away or the door settings are not loaded yet
    if not IsValid(ent) or not ent:isKeysOwnable() or trace.HitPos:DistToSqr(LocalPlayer():EyePos()) > 40000 then return end

    KeyFrameVisible = true
    local Frame = vgui.Create("DFrame")
    Frame:SetSize(200, 30) -- Base size
    Frame.btnMaxim:SetVisible(false)
    Frame.btnMinim:SetVisible(false)
    Frame:SetVisible(true)
    Frame:MakePopup()
    Frame:ParentToHUD()

    function Frame:Think()
        local tr = LocalPlayer():GetEyeTrace()
        local LAEnt = tr.Entity
        if not IsValid(LAEnt) or not LAEnt:isKeysOwnable() or tr.HitPos:DistToSqr(LocalPlayer():EyePos()) > 40000 then
            self:Close()
        end
        if not self.Dragging then return end
        local x = gui.MouseX() - self.Dragging[1]
        local y = gui.MouseY() - self.Dragging[2]
        x = math.Clamp(x, 0, ScrW() - self:GetWide())
        y = math.Clamp(y, 0, ScrH() - self:GetTall())
        self:SetPos(x, y)
    end

    local entType = DarkRP.getPhrase(ent:IsVehicle() and "vehicle" or "door")
    Frame:SetTitle(DarkRP.getPhrase("x_options", entType:gsub("^%a", string.upper)))

    function Frame:Close()
        KeyFrameVisible = false
        self:SetVisible(false)
        self:Remove()
    end

    -- All the buttons

    if ent:isKeysOwnedBy(LocalPlayer()) then
        local Owndoor = AddButtonToFrame(Frame)
        Owndoor:SetText(DarkRP.getPhrase("sell_x", entType))
        Owndoor.DoClick = function() RunConsoleCommand("darkrp", "toggleown") Frame:Close() end

        local AddOwner = AddButtonToFrame(Frame)
        AddOwner:SetText(DarkRP.getPhrase("add_owner"))
        AddOwner.DoClick = function()
            local menu = DermaMenu()
            menu.found = false
            for _, v in pairs(DarkRP.nickSortedPlayers()) do
                if not ent:isKeysOwnedBy(v) and not ent:isKeysAllowedToOwn(v) then
                    local steamID = v:SteamID()
                    menu.found = true
                    menu:AddOption(v:Nick(), function() RunConsoleCommand("darkrp", "ao", steamID) end)
                end
            end
            if not menu.found then
                menu:AddOption(DarkRP.getPhrase("noone_available"), function() end)
            end
            menu:Open()
        end

        local RemoveOwner = AddButtonToFrame(Frame)
        RemoveOwner:SetText(DarkRP.getPhrase("remove_owner"))
        RemoveOwner.DoClick = function()
            local menu = DermaMenu()
            for _, v in pairs(DarkRP.nickSortedPlayers()) do
                if (ent:isKeysOwnedBy(v) and not ent:isMasterOwner(v)) or ent:isKeysAllowedToOwn(v) then
                    local steamID = v:SteamID()
                    menu.found = true
                    menu:AddOption(v:Nick(), function() RunConsoleCommand("darkrp", "ro", steamID) end)
                end
            end
            if not menu.found then
                menu:AddOption(DarkRP.getPhrase("noone_available"), function() end)
            end
            menu:Open()
        end
        if not ent:isMasterOwner(LocalPlayer()) then
            RemoveOwner:SetDisabled(true)
        end
    end

    if doorSettingsAccess then
        local DisableOwnage = AddButtonToFrame(Frame)
        DisableOwnage:SetText(DarkRP.getPhrase(ent:getKeysNonOwnable() and "allow_ownership" or "disallow_ownership"))
        DisableOwnage.DoClick = function() Frame:Close() RunConsoleCommand("darkrp", "toggleownable") end
    end

    if doorSettingsAccess and (ent:isKeysOwned() or ent:getKeysNonOwnable() or ent:getKeysDoorGroup() or hasTeams) or ent:isKeysOwnedBy(LocalPlayer()) then
        local DoorTitle = AddButtonToFrame(Frame)
        DoorTitle:SetText(DarkRP.getPhrase("set_x_title", entType))
        DoorTitle.DoClick = function()
            Derma_StringRequest(DarkRP.getPhrase("set_x_title", entType), DarkRP.getPhrase("set_x_title_long", entType), "", function(text)
                RunConsoleCommand("darkrp", "title", text)
                if IsValid(Frame) then
                    Frame:Close()
                end
            end,
            function() end, DarkRP.getPhrase("ok"), DarkRP.getPhrase("cancel"))
        end
    end

    if not ent:isKeysOwned() and not ent:getKeysNonOwnable() and not ent:getKeysDoorGroup() and not ent:getKeysDoorTeams() or not ent:isKeysOwnedBy(LocalPlayer()) and ent:isKeysAllowedToOwn(LocalPlayer()) then
        local Owndoor = AddButtonToFrame(Frame)
        Owndoor:SetText(DarkRP.getPhrase("buy_x", entType))
        Owndoor.DoClick = function() RunConsoleCommand("darkrp", "toggleown") Frame:Close() end
    end

    if doorSettingsAccess then
        local EditDoorGroups = AddButtonToFrame(Frame)
        EditDoorGroups:SetText(DarkRP.getPhrase("edit_door_group"))
        EditDoorGroups.DoClick = function()
            local menu = DermaMenu()
            local groups = menu:AddSubMenu(DarkRP.getPhrase("door_groups"))
            local teams = menu:AddSubMenu(DarkRP.getPhrase("jobs"))
            local add = teams:AddSubMenu(DarkRP.getPhrase("add"))
            local remove = teams:AddSubMenu(DarkRP.getPhrase("remove"))

            menu:AddOption(DarkRP.getPhrase("none"), function()
                RunConsoleCommand("darkrp", "togglegroupownable")
                if IsValid(Frame) then Frame:Close() end
            end)

            for k in pairs(RPExtraTeamDoors) do
                groups:AddOption(k, function()
                    RunConsoleCommand("darkrp", "togglegroupownable", k)
                    if IsValid(Frame) then Frame:Close() end
                end)
            end

            local doorTeams = ent:getKeysDoorTeams()
            for k, v in pairs(RPExtraTeams) do
                local which = (not doorTeams or not doorTeams[k]) and add or remove
                which:AddOption(v.name, function()
                    RunConsoleCommand("darkrp", "toggleteamownable", k)
                    if IsValid(Frame) then Frame:Close() end
                end)
            end

            menu:Open()
        end
    end

    if Frame.buttonCount == 1 then
        Frame.lastButton:DoClick()
    elseif Frame.buttonCount == 0 or not Frame.buttonCount then
        Frame:Close()
        KeyFrameVisible = true
        timer.Simple(0.3, function() KeyFrameVisible = false end)
    end


    hook.Call("onKeysMenuOpened", nil, ent, Frame)

    Frame:Center()
    Frame:SetSkin(GAMEMODE.Config.DarkRPSkin)
end

function DarkRP.openKeysMenu(um)
    CAMI.PlayerHasAccess(LocalPlayer(), "DarkRP_SetDoorOwner", function(setDoorOwnerAccess)
        CAMI.PlayerHasAccess(LocalPlayer(), "DarkRP_ChangeDoorSettings", fp{openMenu, setDoorOwnerAccess})
    end)
end
usermessage.Hook("KeysMenu", DarkRP.openKeysMenu)

--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a_heavy.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Heavy DC-15a"
SWEP.Trivia_Class = "Heavy-Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a_hvy.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000400000001"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc15a.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-13, 6, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.NoHideLeftHandInCustomization = true

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.8,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 1.1,
    [HITGROUP_RIGHTARM] = 1.1,
}

SWEP.Damage = 37
SWEP.RangeMin = 197
SWEP.DamageMin = 24
SWEP.Range = 480
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 413
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55
SWEP.Recoil = 0.23
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.11
SWEP.Delay = 60 / 399
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}
SWEP.AccuracyMOA = 0.59
SWEP.HipDispersion = 447
SWEP.MoveDispersion = 54

-- Speed Mult
SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootSound = "armas/disparos/dc15le.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.987, -9.924, 0.939),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

-- Attachments
SWEP.Attachments = {      
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Bone = "dc-15a",
        Slot = {"dc15a_magazine_75"},
        Offset = {
            vpos = Vector(-1.7, -0.6, 2.5),
            vang = Angle(0, 0, 0),
        },
    },         
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    }, 
    {
        PrintName = "Grenade Launcher",
        DefaultAttName = "None",
        Slot = {"rep_ubgl"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.675),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.7),
            vang = Angle(90, 0, 0),
        },
    },      
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 31.2),
            vang = Angle(90, 0, 0),
        },
    },  
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.83, 10.273),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17ext.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17 Extended"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17 hand blaster, also known as DC-17 blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17_ext.png"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc17_extended.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc17_extended.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-13.3, 3, -4.9),
    ang = Angle(-10, 0, 180),
    scale = 1.1,
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 34
SWEP.RangeMin = 132
SWEP.DamageMin = 23
SWEP.Range = 327
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 27

SWEP.Recoil = 1.02
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.34

SWEP.Delay = 60 / 376
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = -2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 
SWEP.HipDispersion = 530
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

---- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.298, -1.102, 1.84),
    Ang = Vector(1.639, -2.372, 20.429),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.Primary.Ammo = "ar2"

-- Sound & Holdtype
SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dc17ext_2.wav"
SWEP.ShootSound = "armas/disparos/dc17ext_1.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "revolver"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(0, 6, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, 1)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {}


SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.1, -2.5, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(-4, -1.2, 0),
        CorrectivePos = Vector(0, 0, 0),
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        WMScale = Vector(0.7, 0.7, 0.7),
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.1, 0.4, 5),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.3, -0.8, 6.3),
            vang = Angle(90, 0, -90),
        },
    }, 
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },        
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7,0.7,0.7),
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.7, -1, 0.184),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.6, -0.848, 3),
            vang = Angle(90, 0, -90),
        },
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = "Idle",
    },
    ["bash"] = {
        Source = "Bash"
    },
    ["fire"] = {
        Source = "Shoot"
    },
    ["fire_iron"] = {
        Source = "Shoot"
    },
    ["draw"] = {
        Source = "Draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "Holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "Reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 40 / 30 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },


sound.Add({
    name =          "dc17_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_wristrocket_reload.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17m_launcher.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17m Launcher"
SWEP.Trivia_Class = "Modular Blaster Rifle"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17m_launcher_new.png"

SWEP.Slot = 3

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/c_dc17m_grenade.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dc17m_antiarmour.mdl"
SWEP.ViewModelFOV = 55
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-13, 7, -6),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Grenade Launcher properties
SWEP.ShootEntity = "arccw_nade_launcher17m"
SWEP.MuzzleVelocity = 4000

-- Damage & Tracer
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1
SWEP.ExtendedClipSize = 1
SWEP.ReducedClipSize = 1

SWEP.Recoil = 0.1
SWEP.RecoilSide = 0.175
SWEP.RecoilRise = 0.76

SWEP.Delay = 60 / 105
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PrintName = "ROCKET",
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 1
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 125 
SWEP.SightsDispersion = 0 
SWEP.JumpDispersion = 200

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"
SWEP.ShootVol = 120
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "armas/disparos/dc17m/dc17m_grenade_fire0.wav"
SWEP.ShootSound = "armas/disparos/dc17m/dc17m_grenade_fire0.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 167, 0)


SWEP.IronSightStruct = {
    Pos = Vector(-4.14, -0.32, 2.207),
    Ang = Angle(2.267, -0.76, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 3, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(0, 2, 2)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)


-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(3.3, -0.1, 4.9),
            vang = Angle(0, -0.5, 0),
        },
        CorrectiveAng = Angle(0, 1, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(13, -1.76, 2.7),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Rocket",
        DefaultAttName = "Standard",
        Slot = {"ammo_rocket"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0, -1.4, 2.4),
            vang = Angle(0, 0, 0),
        },
    },
}



SWEP.Animations = {
    ["enter_inspect"]= {
        Source = "pose",
        SoundTable = {
            {
                s = "masita/weapons/dc17m/dc17m_grenade_pose.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "melee", 
        SoundTable = {
            {s = "armas/disparos/dc17m/melee0.wav", t = 0.1 },
        },
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false
    },
    ["idle_iron"] = {
        Source = false
    },
    ["idle_sight"] = {
        Source = false
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "masita/weapons/dc17m/dc17m_grenade_draw.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "masita/weapons/dc17m/dc17m_grenade_holster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "masita/weapons/dc17m/dc17m_grenade_reload.wav", t = 0.1 }, --s sound file
        },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17m_sniper.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17m Sniper"
SWEP.Trivia_Class = "Modular Blaster Rifle"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17m_sniper_new.png"

SWEP.Slot = 3

SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/c_dc17m_sniper.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dc17m_sniper.mdl"
SWEP.ViewModelFOV = 53
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-5, 9, -6),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Properties
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 55
SWEP.RangeMin = 190
SWEP.DamageMin = 35
SWEP.Range = 630
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5
SWEP.ChamberSize = 0

SWEP.Primary.ClipSize = 5

SWEP.Recoil = 1.28
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.98

SWEP.Delay = 60 / 102
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Properties
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 150
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc17m/dc17m_sniper_fire0.wav"
SWEP.FirstShootSound = "armas/disparos/dc17m/dc17m_sniper_fire0.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc17m/dc17m_fire_silenced.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-7.594, 0, 0.651),
    Ang = Angle(0.574, -1.456, 0),
     Magnification = 1.6,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-3, 3, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(0, 3, -4)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(0, -0.1, 4.8),
            vang = Angle(0, -0.5, 0),
        },
        CorrectiveAng = Angle(0, 1, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(13, -1.76, 2.7),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(28, 0, 3.9),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0, -1.4, 2.4),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-2, -1.3, 3.4),
            vang = Angle(0, 0, 20),
        },
    },
}

SWEP.Animations = {
    ["enter_inspect"]= {
        Source = "pose",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_sniper_pose.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "melee", 
        SoundTable = {
            {s = "armas/disparos/dc17m/melee0.wav", t = 0.1 },
        },
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_sniper_unholster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_sniper_unholster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "armas/disparos/dc17m/dc17m_sniper_reload.wav", t = 0.1 }, --s sound file
        },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dp23.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dual_dc17.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_nt242.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_repshield.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_valken38x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita/Meeks"
SWEP.PrintName = "Valken 38x"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The Valken-38x was a model of longblaster that was manufactured for high precision and power over long ranges. It was utilized by the Galactic Republic during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/valken38.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.ViewModel = "models/servius/weapons/viewmodels/c_valken38x.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_valken38x.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.3,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 105
SWEP.RangeMin = 230
SWEP.DamageMin = 73
SWEP.Range = 890
SWEP.Penetration = 1.2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 45
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 17
SWEP.Recoil = 0.14
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.1
SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.47
SWEP.HipDispersion = 376
SWEP.MoveDispersion = 60
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/valken.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.99, -4.258, 1.029),
    Ang = Vector(0, 0.127, 2.813),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
-- Attachments 
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        WMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(20, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        },
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0.18, -6.25, 1.273),
            vang = Angle(0, -90, 0),
            wpos = Vector(6, 1.5, -5),
            wang = Angle(-10, 2, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Laser/Flashlight", 
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0.972, 7.546, 0.651),
            vang = Angle(0, -90, 90),
            wpos = Vector(14, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
    },
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0, 1.628, 0),
            vang = Angle(0, -90, 0),
            wpos = Vector(9, .5, 2),
            wang = Angle(0, 0, 180)    
        },
        SlideAmount = {
        vmin = Vector(-0.2, 2, 0),
        vmax = Vector(-0.2, 7, 0),
        wmin = Vector(9, 0.8, -4), 
        wmax = Vector(9, 0.8, -4)
        },                  
    },     
    {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },   
    {
        PrintName = "Training/Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0.6, -7.752, 0.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(6, 1.8, -4.5),
            wang = Angle(0, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "Shoot"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "draw/sw01_characters_gunfoley_draw_blaster_var14.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "valken38_r1", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "valken38_r1",
    channel =       CHAN_ITEM,
    volume =        1.1,
    sound =             "armas/misc/standard_reload.ogg"
    }),
}
--PATH gamemodes/starwarsrp/entities/weapons/med_kit/shared.lua:
if SERVER then
    AddCSLuaFile("shared.lua")
end

SWEP.PrintName = "Medic Kit"
SWEP.Author = "DarkRP Developers"
SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.Description = "Heals the wounded."
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = "Left click to heal someone\nRight click to heal yourself"
SWEP.IsDarkRPMedKit = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"

SWEP.ViewModel = "models/weapons/c_medkit.mdl"
SWEP.WorldModel = "models/weapons/w_medkit.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 0
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = true
SWEP.Primary.Delay = 0.1
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Recoil = 0
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Delay = 0.3
SWEP.Secondary.Ammo = "none"

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local found
    local lastDot = -1 -- the opposite of what you're looking at
    Owner:LagCompensation(true)
    local aimVec = Owner:GetAimVector()
    local shootPos = Owner:GetShootPos()

    for _, v in ipairs(player.GetAll()) do
        local maxhealth = v:GetMaxHealth() or 100
        local targetShootPos = v:GetShootPos()
        if v == Owner or targetShootPos:DistToSqr(shootPos) > 7225 or v:Health() >= maxhealth or not v:Alive() then continue end

        local direction = targetShootPos - shootPos
        direction:Normalize()
        local dot = direction:Dot(aimVec)

        -- Looking more in the direction of this player
        if dot > lastDot then
            lastDot = dot
            found = v
        end
    end
    Owner:LagCompensation(false)

    if found then
        found:SetHealth(found:Health() + 1)
        self:EmitSound("hl1/fvox/boop.wav", 150, math.max(found:Health() / found:GetMaxHealth() * 100, 25), 1, CHAN_AUTO)
    end
end

function SWEP:SecondaryAttack()
    self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
    local ply = self:GetOwner()
    local maxhealth = ply:GetMaxHealth() or 100
    if ply:Health() < maxhealth then
        ply:SetHealth(ply:Health() + 1)
        self:EmitSound("hl1/fvox/boop.wav", 150, math.max(ply:Health() / ply:GetMaxHealth() * 100, 25), 1, CHAN_AUTO)
    end
end

--PATH gamemodes/starwarsrp/entities/weapons/pocket/shared.lua:
AddCSLuaFile()

if SERVER then
    AddCSLuaFile("cl_menu.lua")
    include("sv_init.lua")
end

if CLIENT then
    include("cl_menu.lua")
end

SWEP.PrintName = "Pocket"
SWEP.Slot = 1
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

SWEP.Base = "weapon_cs_base2"

SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click to pick up\nRight click to drop\nReload to open the menu"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPPocket = true

SWEP.IconLetter = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"
SWEP.WorldModel = ""

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:Deploy()
    return true
end

function SWEP:DrawWorldModel() end

function SWEP:PreDrawViewModel(vm)
    return true
end

function SWEP:Holster()
    if not SERVER then return true end

    local Owner = self:GetOwner()
    Owner:DrawViewModel(true)
    Owner:DrawWorldModel(true)

    return true
end

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + 0.2)

    if not SERVER then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local ent = Owner:GetEyeTrace().Entity
    local canPickup, message = hook.Call("canPocket", GAMEMODE, Owner, ent)

    if not canPickup then
        if message then DarkRP.notify(Owner, 1, 4, message) end
        return
    end

    Owner:addPocketItem(ent)
end

function SWEP:SecondaryAttack()
    if not SERVER then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local maxK = 0

    for k in pairs(Owner:getPocketItems()) do
        if k < maxK then continue end
        maxK = k
    end

    if maxK == 0 then
        DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("pocket_no_items"))
        return
    end

    if SERVER then
        local canPickup, message = hook.Call("canDropPocketItem", nil, Owner, maxK, Owner.darkRPPocket[maxK])
        if canPickup == false then
            if message then DarkRP.notify(Owner, 1, 4, message) end
            return
        end
    end

    Owner:dropPocketItem(maxK)
end

function SWEP:Reload()
    if CLIENT then
      DarkRP.openPocketMenu()
    end

    if SERVER and game.SinglePlayer() then
        net.Start("DarkRP_PocketMenu")
        net.Send(self:GetOwner())
    end
end

local meta = FindMetaTable("Player")
DarkRP.stub{
    name = "getPocketItems",
    description = "Get a player's pocket items.",
    parameters = {
    },
    returns = {
        {
            name = "items",
            description = "A table containing crucial information about the items in the pocket.",
            type = "table"
        }
    },
    metatable = meta,
    realm = "Shared"
}

--PATH lua/weapons/repair_tool.lua:
return gluapack()()
--PATH lua/weapons/tfa_grapple_base/shared.lua:
SWEP.Base					= "tfa_gun_base"

-- [[ GRAPPLE ]]
	-- [ Variables ]
		SWEP.GrappleEnabled			= false
		SWEP.MaxGrappleDist			= 500

		SWEP.GrappleHookSound			= "weapons/rpg/shotdown.wav"
		SWEP.GrappleHookFleshSound		= Sound("TFA.BashFlesh")

		SWEP.GrappleMoveSound			= "weapons/tripwire/ropeshoot.wav"

-- [[ FUNCTIONS ]]
	-- [ Class ]
		DEFINE_BASECLASS( SWEP.Base )

	function SWEP:Initialize()
		hook.Add( "KeyRelease", self, self.ReleaseHook )
		hook.Add( "StartCommand", self, self.ButtonHook )
		hook.Add( "PlayerBindPress", self, self.PreventHook )

		self.RopeSounds = CreateSound( self, self:GetStat("GrappleMoveSound"))
		self.RopeSounds:PlayEx(0,100)

		BaseClass.Initialize(self)
	end

	function SWEP:SetupDataTables()
		self:NetworkVar( "Int", 30, "MWScrolling" )
		self:NetworkVar( "Int", 31, "ObjectRange" )

		self:NetworkVar( "Bool", 31, "HoldingGrab" )

		self:NetworkVar( "Entity", 31, "CapturedEntity" )

		BaseClass.SetupDataTables(self)
	end

	function SWEP.ButtonHook(ent, ply, ucmd)
		if ent:GetOwner() == ply then
			if ply:GetActiveWeapon() ~= ent then return end
			if !ent:GetStat("GrappleEnabled") then return end
			if !ent:IsValid() then return end
			if ent:GetHoldingGrab() then
				ent:SetObjectRange( math.max(ent:GetObjectRange()+ucmd:GetMouseWheel()*20, 0 ) )
				ent:SetMWScrolling( ucmd:GetMouseWheel() )
			end
		end	
	end

	function SWEP.PreventHook(ent, ply, bind, press)
		if ent:GetOwner() == ply then
			if !ent:GetStat("GrappleEnabled") then return end
			if ply:GetActiveWeapon() ~= ent then return end
			if !ent:IsValid() then return end
			if ent:GetHoldingGrab() then
				if ( string.find( bind, "invnext" ) ) then return true end
				if ( string.find( bind, "invprev" ) ) then return true end
			end
		end	
	end

	function SWEP.ReleaseHook(ent, ply, key )
		if ent:GetOwner() == ply and key == IN_ATTACK2 then
			if !ent:IsValid() then return end
			if ply:GetActiveWeapon() ~= ent then return end
			if !ent:GetStat("GrappleEnabled") then return end
			ent:LetGoGrapple()
		end	
	end

	function SWEP:SecondaryAttack()
		if self:GetStat("GrappleEnabled") then
			self:ShootGrapple()
		else
			BaseClass.SecondaryAttack(self)
		end
	end

	function SWEP:ShootGrapple()
		if !self:CanPrimaryAttack() then return false end
		local ply = self:GetOwner()

		local tr = util.TraceLine( {
			start = ply:EyePos(),
			endpos = ply:EyePos() + ply:EyeAngles():Forward() * self:GetStat("MaxGrappleDist"),
			filter = function( ent ) if ( ent ~= ply ) then return true end end
		})


		if tr.Hit then
			self:SetHoldingGrab(true)
			if !SERVER then return false end
			
			local ent = tr.Entity
			self.RopeAnchor = ents.Create("prop_physics")
			self.RopeAnchor:SetPos(tr.HitPos + (tr.HitNormal*5))
			self.RopeAnchor:SetAngles(tr.HitNormal:Angle()+Angle(90,0,90))
			self.RopeAnchor:SetModel("models/props_c17/TrapPropeller_Lever.mdl")
			self.RopeAnchor:Spawn()
			self.RopeAnchor:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
			self.RopeAnchor:DrawShadow(false)
			self.RopeAnchor:GetPhysicsObject():EnableMotion(false)
			self.RopeAnchor:SetSolid(SOLID_NONE)
			if ent:IsPlayer() or ent:IsNPC() then
				self:SetCapturedEntity(ent)
				self.RopeAnchor:SetParent(ent,tr.PhysicsBone)
			end

			if tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH then
				self.RopeAnchor:EmitSound( self:GetStat("GrappleHookFleshSound") )
			else
				self.RopeAnchor:EmitSound( self:GetStat("GrappleHookSound") )
			end

			self.PlayerKF = ents.Create("prop_physics")
			self.PlayerKF:SetModel("models/Combine_Helicopter/helicopter_bomb01.mdl")
			self.PlayerKF:Spawn()
			self.PlayerKF:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
			self.PlayerKF:SetRenderMode(RENDERMODE_NONE)
			self.PlayerKF:DrawShadow(false)
			self.PlayerKF:PointAtEntity(self.Owner)
			self.PlayerKF:SetSolid(SOLID_NONE)
			
			local vm = ply:GetViewModel(0)
			if ply == ply:GetViewEntity() then
				self.PlayerKF:SetPos(vm:GetAttachment(self:GetMuzzleAttachment()).Pos)
				self.PlayerKF:SetParent(vm,self:GetMuzzleAttachment())
			else
				local offsetVec = Vector( 5, -1, -5 )
				local offsetAng = Angle( 180, 90, 0 )
				
				local boneid = ply:LookupBone( "ValveBiped.Bip01_R_Hand" )
				local matrix = ply:GetBoneMatrix( boneid )
				local newpos = LocalToWorld( offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles() )

				self.PlayerKF:SetPos(newpos)
				self.PlayerKF:SetParent(ply,5)
			end

			self:SetObjectRange( (tr.HitPos-ply:GetPos()):Length() )
			self.DefaultLength = self:GetObjectRange()

			self.RopeC, self.RopeCC = constraint.Rope(self.PlayerKF, self.RopeAnchor, 0, 0, Vector(0,0,0), Vector(0,5,0), self:GetObjectRange(), 0, 0, 2, "cable/cable2", true)
			self.RopeCC:SetKeyValue( "Slack", 0 )
	
			local effectdata = EffectData()
			effectdata:SetOrigin( self.RopeAnchor:GetPos() )
			util.Effect( "cball_bounce", effectdata, false, true)
		end
	end

	function SWEP:PreHolster()
		if !self:IsValid() then return end
		self:LetGoGrapple()
	end

	function SWEP:OnDrop()
		if !self:IsValid() then return end
		self:PreHolster()
	end

	function SWEP:OnRemove()
		if !self:IsValid() then return end
		self:PreHolster()
	end

	function SWEP:OwnerChanged()
		if !self:IsValid() then return end
		self:PreHolster()
	end

	function SWEP:LetGoGrapple()
		self:SetHoldingGrab(false)

		self:SetObjectRange(0)
		
		if self.RopeSounds then
			self.RopeSounds:ChangeVolume(0)
		end
		
		if self.RopeAnchor and self.RopeAnchor:IsValid() then
			self.RopeAnchor:Remove()
		end
		if self.PlayerKF and self.PlayerKF:IsValid() then
			self.PlayerKF:Remove()
		end

		self:SetCapturedEntity(nil)
	end

	function SWEP:GrappleThink()
		local ply = self:GetOwner()
		local ranc = self.RopeAnchor

		if !self:GetHoldingGrab() then return false end
		if !ranc or !ranc:IsValid() then return false end

		local trendpos = ranc:GetPos() + (Vector(0,0,-1) * self:GetObjectRange())
		
		if self:GetCapturedEntity() and self:GetCapturedEntity():IsValid() then
			ply = self:GetCapturedEntity()
			ranc = self:GetOwner()
			trendpos = ranc:GetPos() + ((ply:GetPos()-ranc:GetPos()):GetNormal() * self:GetObjectRange())
		
			if ply:Health() <= 0 then
				self:LetGoGrapple()
			end
		end

		local plyp = ply:GetPhysicsObject()

		local tr = util.TraceLine({
			start = ranc:GetPos(),
			endpos = trendpos,
			filter = function(ent)
				if (ent == ent) or (ent == self.Owner) or (ent == ranc) then
					return false
				else
					return true
				end
			end
		})

		local objr = math.min(5000/(self:GetObjectRange()+10), 10)

		local objrd = math.max((self.DefaultLength - self:GetObjectRange())/200,0)

		local dist = math.Clamp(tr.HitPos:Distance(ply:GetPos())/10, 0, 15)

		local grup
		local grside

		if ply:IsPlayer() then
			if ply:OnGround() then
				grside = objrd
				grup = dist*3
			else
				grup = 1
				grside = 1
			end
		else
			if ply:OnGround() then
				grside = 2
				grup = 0.1
			else
				grup = 0.8
				grside = 1
			end
		end

		local futurvel = (tr.HitPos-ply:GetPos()):GetNormal() * (((objr + dist)/2)*grside)
		futurvel:Add(Vector(0,0,5*(grup)))
		futurvel:Sub( ply:GetVelocity()/(dist*25) )
		futurvel:Sub( Vector(0,0, ply:GetVelocity().z/(objr*25) ) )

		ply:SetVelocity( futurvel )

		self.RopeCC:SetKeyValue( "length", self:GetObjectRange()+50 )
	end

	function SWEP:Think()
		BaseClass.Think(self)

		if self.RopeSounds and self:GetObjectRange() ~= 0 then
			self.RopeSounds:ChangeVolume(math.abs(self:GetMWScrolling()), 0.4 and self:GetMWScrolling() > 0.5 or 0.1)
		end
		
		if self:GetStat("GrappleEnabled") then
			self:GrappleThink()
		end
	end
--PATH lua/weapons/tfa_gun_base/cl_init.lua:
TFA.SWEP_LOAD_COMPLETE = false

include("shared.lua")

include("common/ai_translations.lua")
include("common/anims.lua")
include("common/autodetection.lua")
include("common/utils.lua")
include("common/stat.lua")
include("common/attachments.lua")
include("common/bullet.lua")
include("common/effects.lua")
include("common/calc.lua")
include("common/akimbo.lua")
include("common/events.lua")
include("common/nzombies.lua")
include("common/ttt.lua")
include("common/viewmodel.lua")
include("common/skins.lua")

include("client/effects.lua")
include("client/viewbob.lua")
include("client/viewmodel.lua")
include("client/bobcode.lua")
include("client/hud.lua")
include("client/mods.lua")
include("client/laser.lua")
include("client/fov.lua")
include("client/flashlight.lua")

TFA.FillMissingMetaValues(SWEP)

--PATH lua/weapons/tfa_gun_base/common/ai_translations.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/akimbo.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/client/viewbob.lua:
SWEP.SprintBobMult = 1.5 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You want to make this > 1 probably for sprinting.
SWEP.IronBobMult = 0.0 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You want to make this < 1 for sighting, 0 to outright disable.
SWEP.IronBobMultWalk = 0.2 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You want to make this < 1 for sighting, 0 to outright disable.
SWEP.WalkBobMult = 1 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You may want to disable it when using animated walk.
SWEP.SprintViewBobMult = 4
--[[
Function Name:  CalcView
Syntax: Don't ever call this manually.
Returns:  Nothing.
Notes:  Used to calculate view angles.
Purpose:  Feature
]]
--"
--[[

local ta = Angle()
local v = Vector()

local m_AD = math.AngleDifference
local m_NA = math.NormalizeAngle

local l_LA = function(t,a1,a2)
	ta.p = m_NA( a1.p + m_AD(a2.p,a1.p)  * t )
	ta.y = m_NA( a1.y + m_AD(a2.y,a1.y)  * t )
	ta.r = m_NA( a1.r + m_AD(a2.r,a1.r)  * t )
	return ta
end

local l_LV = function(t,v1,v2)
	v = v1  + ( v2 - v1 ) * t
	return v * 1
end
]]
--
SWEP.ViewHolProg = 0
SWEP.AttachmentViewOffset = Angle(0, 0, 0)
SWEP.ProceduralViewOffset = Angle(0, 0, 0)
--local procedural_fadeout = 0.6
local procedural_vellimit = 5
local l_Lerp = Lerp
local l_mathApproach = math.Approach
local l_mathClamp = math.Clamp
local viewbob_intensity_cvar, viewbob_animated_cvar
viewbob_intensity_cvar = GetConVar("cl_tfa_viewbob_intensity")
viewbob_animated_cvar = GetConVar("cl_tfa_viewbob_animated")
local oldangtmp
local mzang_fixed
local mzang_fixed_last
local mzang_velocity = Angle()
local progress = 0
local targint, targbool

SWEP.ViewBob_Bash = true
SWEP.ViewBob_Draw = true
SWEP.ViewBob_Holster = true
SWEP.ViewBob_Inspect = true
SWEP.ViewBob_Pump = true
SWEP.ViewBob_Reload = true
SWEP.ViewBob_Shoot = false

SWEP.ViewBob_DontFadeOutStatus = {
	[TFA.Enum.STATUS_RELOADING_LOOP_START] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP] = true,
}

SWEP.ViewBob_DontFadeOutShootStatus = {
	[TFA.Enum.SHOOT_START] = true,
	[TFA.Enum.SHOOT_LOOP] = true,
	[TFA.Enum.SHOOT_CHECK] = true,
} -- looped fire ends on TFA.Enum.SHOOT_IDLE so we include anything but that

function SWEP:CalcView(ply, pos, ang, fov)
	if not ang then return end
	if ply ~= GetViewEntity() then return end

	local self2 = self:GetTable()

	local vm = self2.OwnerViewModel
	if not IsValid(vm) then return end

	local ftv = FrameTime()
	local viewbobintensity = viewbob_intensity_cvar:GetFloat()
	local holprog = TFA.Enum.HolsterStatus[self2.GetStatus(self)] and 1 or 0
	self2.ViewHolProg = math.Approach(self2.ViewHolProg, holprog, ftv / 5)

	oldangtmp = ang * 1

	local stat = self:GetStatus()

	local ibash = stat == TFA.Enum.STATUS_BASHING or stat == TFA.Enum.STATUS_BASHING_WAIT and self2.GetStatL(self, "ViewBob_Bash")
	local idraw = stat == TFA.Enum.STATUS_DRAW and self2.GetStatL(self, "ViewBob_Draw")
	local ihols = TFA.Enum.HolsterStatus[stat] and self2.GetStatL(self, "ViewBob_Holster")
	local ifidget = stat == TFA.Enum.STATUS_FIDGET and self2.GetStatL(self, "ViewBob_Inspect")
	local ipump = stat == TFA.Enum.STATUS_PUMP and self2.GetStatL(self, "ViewBob_Pump")
	local ireload = TFA.Enum.ReloadStatus[stat] and self2.GetStatL(self, "ViewBob_Reload")
	local ishoot = stat == TFA.Enum.STATUS_SHOOTING and self2.GetStatL(self, "ViewBob_Shoot") and not self:CanInterruptShooting()

	targbool = idraw or ireload or ibash or ishoot or ipump or ifidget or (ihols and not self2.GetStatL(self, "ProceduralHolsterEnabled"))
	targint = targbool and 1 or 0

	if not self2.ViewBob_DontFadeOutStatus[stat] and not self2.ViewBob_DontFadeOutShootStatus[self:GetShootStatus()] then
		targint = math.min(targint, 1 - math.pow(math.max(vm:GetCycle() - 0.5, 0) * 2, 2))
	end

	progress = l_Lerp(ftv * 20, progress, targint)

	if self2.CameraAngCache and viewbob_animated_cvar:GetBool() then
		self2.CameraAttachmentScale = self2.CameraAttachmentScale or 1
		ang:RotateAroundAxis(ang:Right(), Lerp(progress, 0, (self2.CameraAngCache.p + self2.CameraOffset.p) * viewbobintensity * -self2.CameraAttachmentScale) * viewbobintensity)
		ang:RotateAroundAxis(ang:Up(), Lerp(progress, 0, (self2.CameraAngCache.y + self2.CameraOffset.y) * viewbobintensity * self2.CameraAttachmentScale) * viewbobintensity)
		ang:RotateAroundAxis(ang:Forward(), Lerp(progress, 0, (self2.CameraAngCache.r + self2.CameraOffset.r) * viewbobintensity * self2.CameraAttachmentScale) * viewbobintensity)
		-- - self2.MZReferenceAngle--WorldToLocal( angpos.Pos, angpos.Ang, angpos.Pos, oldangtmp + self2.MZReferenceAngle )
		--* progress )
		--self2.ProceduralViewOffset.p = l_mathApproach(self2.ProceduralViewOffset.p, 0 , l_mathClamp( procedural_pitchrestorefac - math.min( math.abs( self2.ProceduralViewOffset.p ), procedural_pitchrestorefac ) ,1,procedural_pitchrestorefac)*ftv/5 )
		--self2.ProceduralViewOffset.y = l_mathApproach(self2.ProceduralViewOffset.y, 0 , l_mathClamp( procedural_pitchrestorefac - math.min( math.abs( self2.ProceduralViewOffset.y ), procedural_pitchrestorefac ) ,1,procedural_pitchrestorefac)*ftv/5 )
		--self2.ProceduralViewOffset.r = l_mathApproach(self2.ProceduralViewOffset.r, 0 , l_mathClamp( procedural_pitchrestorefac - math.min( math.abs( self2.ProceduralViewOffset.r ), procedural_pitchrestorefac ) ,1,procedural_pitchrestorefac)*ftv/5 )
	else
		local mul = 1
		if ifidget then
			mul = -1
		end

		local att = self2.MuzzleAttachmentRaw or vm:LookupAttachment(self2.MuzzleAttachment)
		if not att then
			att = 1
		end

		local angpos = vm:GetAttachment(att)
		if angpos and angpos.Ang then
			mzang_fixed = vm:WorldToLocalAngles(angpos.Ang)
			mzang_fixed:Normalize()
		end

		self2.ProceduralViewOffset:Normalize()

		if mzang_fixed_last then
			local delta = mzang_fixed - mzang_fixed_last
			delta:Normalize()
			mzang_velocity = mzang_velocity + delta * (2 * (1 - self2.ViewHolProg))

			mzang_velocity.p = math.Approach(mzang_velocity.p, -self2.ProceduralViewOffset.p * 2, ftv * 20)
			mzang_velocity.p = math.Clamp(mzang_velocity.p, -procedural_vellimit, procedural_vellimit)
			self2.ProceduralViewOffset.p = self2.ProceduralViewOffset.p + mzang_velocity.p * ftv * mul
			self2.ProceduralViewOffset.p = math.Clamp(self2.ProceduralViewOffset.p, -90, 90)

			mzang_velocity.y = math.Approach(mzang_velocity.y, -self2.ProceduralViewOffset.y * 2, ftv * 20)
			mzang_velocity.y = math.Clamp(mzang_velocity.y, -procedural_vellimit, procedural_vellimit)
			self2.ProceduralViewOffset.y = self2.ProceduralViewOffset.y + mzang_velocity.y * ftv * mul
			self2.ProceduralViewOffset.y = math.Clamp(self2.ProceduralViewOffset.y, -90, 90)

			mzang_velocity.r = math.Approach(mzang_velocity.r, -self2.ProceduralViewOffset.r * 2, ftv * 20)
			mzang_velocity.r = math.Clamp(mzang_velocity.r, -procedural_vellimit, procedural_vellimit)
			self2.ProceduralViewOffset.r = self2.ProceduralViewOffset.r + mzang_velocity.r * ftv * mul
			self2.ProceduralViewOffset.r = math.Clamp(self2.ProceduralViewOffset.r, -90, 90)
		end
		mzang_fixed_last = mzang_fixed

		self2.ProceduralViewOffset.p = math.Approach(self2.ProceduralViewOffset.p, 0, (1 - progress) * ftv * -self2.ProceduralViewOffset.p * 20)
		self2.ProceduralViewOffset.y = math.Approach(self2.ProceduralViewOffset.y, 0, (1 - progress) * ftv * -self2.ProceduralViewOffset.y * 20)
		self2.ProceduralViewOffset.r = math.Approach(self2.ProceduralViewOffset.r, 0, (1 - progress) * ftv * -self2.ProceduralViewOffset.r * 20)

		local ints = viewbobintensity * 1.25
		ang:RotateAroundAxis(ang:Right(), Lerp(progress, 0, -self2.ProceduralViewOffset.p) * ints)
		ang:RotateAroundAxis(ang:Up(), Lerp(progress, 0, self2.ProceduralViewOffset.y / 2) * ints)
		ang:RotateAroundAxis(ang:Forward(), Lerp(progress, 0, self2.ProceduralViewOffset.r / 3) * ints)
	end

	return pos, LerpAngle(math.pow(self2.ViewHolProg, 2), ang, oldangtmp), fov
end

--PATH lua/weapons/tfa_gun_base/client/bobcode.lua:
return gluapack()()
--PATH lua/weapons/tfa_melee_base/shared.lua:
return gluapack()()
--PATH lua/weapons/tfa_swsft_base_servius/shared.lua:
DEFINE_BASECLASS("tfa_gun_base")

SWEP.TracerCount = 1
SWEP.MuzzleFlashEffect = ""
SWEP.TracerName = "effect_sw_laser_red"

SWEP.Secondary.IronFOV = 70
SWEP.Primary.KickUp = 0.2
SWEP.Primary.KickDown = 0.1
SWEP.Primary.KickHorizontal = 0.1
SWEP.Primary.KickRight = 0.1

SWEP.DisableChambering = true

SWEP.Callback = {}
SWEP.Callback.ChooseProceduralReloadAnim = function(self)
	if SERVER or (CLIENT and IsFirstTimePredicted() ) then
		self:EmitSound(self.Primary.ReloadSound or "")
	end
end
SWEP.Callback.ChooseReloadAnim = function(self)
	if SERVER or (CLIENT and IsFirstTimePredicted() ) then
		self:EmitSound(self.Primary.ReloadSound or "")
	end
end
SWEP.ImpactDecal = "FadingScorch"

SWEP.RunSightsPos = Vector(2.127, 0, 1.355)
SWEP.RunSightsAng = Vector(-15.775, 10.023, -5.664)

SWEP.BlowbackEnabled = true
SWEP.BlowbackVector = Vector(0,-3,0.1)
SWEP.Blowback_Shell_Enabled = false
SWEP.Blowback_Shell_Effect = ""
SWEP.ThirdPersonReloadDisable=false

SWEP.Primary.DamageType = DMG_SHOCK
SWEP.DamageType = DMG_SHOCK

SWEP.ImpactEffect = "effect_sw_impact" --Impact Effect

--[[
function SWEP:DrawHands()
	self.UseHandsDefault = self.UseHandsDefault or self.UseHands
	if !self.UseHandsDefault then return end
	if !IsValid(self) or !self:OwnerIsValid() then return end
	local vm = self.OwnerViewModel
	if !IsValid(vm) then return end
	
	if !self.Owner.SWHands then
		self.Owner.SWHands = ClientsideModel("models/player/KyleJWest/CGI3DPhase1Clone_c_arms/CGI3DPhase1Clone_c_arms.mdl")
		self.Owner.SWHands:SetParent(vm)
		self.Owner.SWHands:SetPos(self.Owner:GetShootPos())
		self.Owner.SWHands:SetAngles(self.Owner:EyeAngles())
		self.Owner.SWHands:AddEffects( EF_BONEMERGE )
		self.Owner.SWHands:SetNoDraw(true)
		self.Owner.SWHands.BoneMergedEnt = vm
	elseif self.Owner.SWHands.BoneMergedEnt != vm then
		self.Owner.SWHands:SetParent(vm)
		self.Owner.SWHands:SetPos(self.Owner:GetShootPos())
		self.Owner.SWHands:SetAngles(self.Owner:EyeAngles())
		self.Owner.SWHands:AddEffects( EF_BONEMERGE )	
	end
	
	if self.Owner.SWHands then
		self.Owner.SWHands:DrawModel()
	end
	
	self.UseHands = false
	
end--]]
--PATH lua/weapons/weapon_armorkit/cl_init.lua:
include("shared.lua")
include("animations.lua")

SWEP.Category = "Other"

SWEP.UseHands = true
SWEP.DrawAmmo = true
SWEP.DrawCrosshair = true
SWEP.ViewModelFOV = 60

SWEP.Slot = 5
SWEP.SlotPos = 3

SWEP.ShowWorldModel = true
SWEP.ShowViewModel = false

SWEP.WCustom = true
SWEP.WBone = "ValveBiped.Bip01_R_Hand"
SWEP.WPos = Vector(4,2,3)
SWEP.WAng = Angle(180,-90-45,15)

SWEP.VElements = {
	--["armorkit"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(0,0,1.5), angle = Angle(180,180,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	["armorkit"] = { type = "Model", model = "models/items/battery.mdl", bone = "medkit_bone", rel = "", pos = Vector(-0.5,4,-1.5), angle = Angle(90,185,90), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["armorkit+"] = { type = "Model", model = "models/items/battery.mdl", bone = "medkit_bone", rel = "armorkit", pos = Vector(0,3,0), angle = Angle(0,90,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["armorkit++"] = { type = "Model", model = "models/items/battery.mdl", bone = "medkit_bone", rel = "armorkit", pos = Vector(0,-3,0), angle = Angle(0,-90,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

--[[
SWEP.WElements = {
--	["armorkit"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.5,3,2), angle = Angle(180,180,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	["armorkit"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4,5.5,3.5), angle = Angle(190,20,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["armorkit+"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "armorkit", pos = Vector(0,3,0), angle = Angle(0,90,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["armorkit++"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "armorkit", pos = Vector(0,-3,0), angle = Angle(0,-90,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}
]]

function SWEP:OnRemove()
	self:Anim_OnRemove()
end

function SWEP:ViewModelDrawn()
	self:Anim_ViewModelDrawn()
end

function SWEP:PreDrawViewModel(vm)
	if self.ShowViewModel == false then
		render.SetBlend(0)
	end
end

function SWEP:PostDrawViewModel(vm)
	if self.ShowViewModel == false then
		render.SetBlend(1)
	end
end

function SWEP:DrawWorldModel()
	self:Anim_DrawWorldModel()
end

--PATH lua/weapons/weapon_armorkit/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_bactanade.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/weapons/weapon_base/sh_anim.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_elastic.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_elastic.lua  SHARED --
--                                 --
-- Elastic handcuffs.              --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Stretchable restraint."

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.PrintName = "Elastic Handcuffs"

//
// Handcuff Vars
SWEP.CuffTime = 0.5 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_pipes/GutterMetal01a"
SWEP.CuffRope = "cable/red"
SWEP.CuffStrength = 1.00
SWEP.CuffRegen = 1
SWEP.RopeLength = 100
SWEP.CuffReusable = true

SWEP.CuffBlindfold = true
SWEP.CuffGag = true

SWEP.CuffStrengthVariance = 0.3 // Randomise strangth
SWEP.CuffRegenVariance = 0.3 // Randomise regen

--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_plastic.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_shackles.lua SHARED --
--                                 --
-- Strongest handcuffs available.  --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Toy handcuffs."

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.PrintName = "Plastic Handcuffs"

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/plastic"
SWEP.CuffRope = "trails/tube"
SWEP.CuffStrength = 0.8
SWEP.CuffRegen = 0.6
SWEP.RopeLength = 0
SWEP.CuffReusable = false

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.4 // Randomise strangth
SWEP.CuffRegenVariance = 0.1 // Randomise regen

--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_tactical.lua:
return gluapack()()
--PATH lua/weapons/weapon_fireballoon/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_forceheal.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2axe/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Axe"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack : Push"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_axe.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_axe.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 35
SWEP.HitInclination		= 0.4
SWEP.HitPushback		= 700
SWEP.HitRate			= 1.00
SWEP.MinDamage			= 34
SWEP.MaxDamage			= 40

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound("npc/ministrider/flechette_flesh_impact1.wav")
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 1.5 * 40,
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

	if ( tr.Hit ) then
	self:EmitSound( PushSoundBody )
	if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
	tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * 500 )
	end
	end

end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 34, 40 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay")
	return true
end
--PATH lua/weapons/weapon_hl2bottle/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2shovel/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Shovel"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack : Push"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_shovel.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_shovel.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 50
SWEP.HitInclination		= 0.4
SWEP.HitPushback		= 2000
SWEP.HitRate			= 1.25
SWEP.MinDamage			= 24
SWEP.MaxDamage			= 32

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 1.5 * 40,
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

	if ( tr.Hit ) then
	self:EmitSound( PushSoundBody )
	if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
	tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * 500 )
	end
	end

end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 15
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 24, 32 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	return true
end
--PATH gamemodes/starwarsrp/entities/weapons/weapon_keypadchecker/shared.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/sh_combo.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/includes/circles/circles.lua:
if SERVER then return false end

local _R = debug.getregistry()
if _R.Circles then return _R.Circles end

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local New do
	local err_number = "bad argument #%i to 'New' (number expected, got %s)"

	function New(t, r, x, y, ...)
		assert(isnumber(t), string.format(err_number, 1, type(t)))
		assert(isnumber(r), string.format(err_number, 2, type(r)))
		assert(isnumber(x), string.format(err_number, 3, type(x)))
		assert(isnumber(y), string.format(err_number, 4, type(y)))

		local circle = setmetatable({}, CIRCLE)

		circle:SetType(t)
		circle:SetRadius(r)
		circle:SetX(x)
		circle:SetY(y)

		circle:SetVertices({Count = 0})

		if t == CIRCLE_OUTLINED then
			local outline_width = ...
			assert(outline_width == nil or isnumber(outline_width), string.format(err_number, 5, type(outline_width)))

			circle:SetOutlineWidth(outline_width)
		elseif t == CIRCLE_BLURRED then
			local blur_layers, blur_density = ...
			assert(blur_layers == nil or isnumber(blur_layers), string.format(err_number, 5, type(blur_layers)))
			assert(blur_density == nil or isnumber(blur_density), string.format(err_number, 6, type(blur_density)))

			circle:SetBlurLayers(blur_layers)
			circle:SetBlurDensity(blur_density)
		end

		return circle
	end
end

local RotateVertices do
	local err_table = "bad argument #1 to 'RotateVertices' (table expected, got %s)"
	local err_number = "bad argument #%i to 'RotateVertices' (number expected, got %s)"

	function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
		assert(istable(vertices), string.format(err_table, type(vertices)))
		assert(isnumber(ox), string.format(err_number, 2, type(ox)))
		assert(isnumber(oy), string.format(err_number, 3, type(oy)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))

		local rotation = math.rad(rotation)
		local c = math.cos(rotation)
		local s = math.sin(rotation)

		for i = 1, vertices.Count or #vertices do
			local vertex = vertices[i]
			local vx, vy = vertex.x, vertex.y

			vx = vx - ox
			vy = vy - oy

			vertex.x = ox + (vx * c - vy * s)
			vertex.y = oy + (vx * s + vy * c)

			if rotate_uv == false then
				local u, v = vertex.u, vertex.v
				u, v = u - 0.5, v - 0.5

				vertex.u = 0.5 + (u * c - v * s)
				vertex.v = 0.5 + (u * s + v * c)
			end
		end
	end
end

local CalculateVertices do
	local err_number = "bad argument #%i to 'CalculateVertices' (number expected, got %s)"

	function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		assert(isnumber(radius), string.format(err_number, 3, type(radius)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))
		assert(isnumber(start_angle), string.format(err_number, 5, type(start_angle)))
		assert(isnumber(end_angle), string.format(err_number, 6, type(end_angle)))
		assert(isnumber(distance), string.format(err_number, 7, type(distance)))

		local vertices = {Count = 0}
		local step = distance / radius

		local rad_start_angle = math.rad(start_angle)
		local rad_end_angle = math.rad(end_angle)
		local rad_rotation = math.rad(rotation)

		for a = rad_start_angle, rad_end_angle + step, step do
			a = math.min(a, rad_end_angle)

			local c = math.cos(a + rad_rotation)
			local s = math.sin(a + rad_rotation)

			local vertex = {
				x = x + c * radius,
				y = y + s * radius,
			}

			if rotate_uv == false then
				vertex.u = 0.5 + math.cos(a) / 2
				vertex.v = 0.5 + math.sin(a) / 2
			else
				vertex.u = 0.5 + c / 2
				vertex.v = 0.5 + s / 2
			end

			vertices.Count = vertices.Count + 1
			vertices[vertices.Count] = vertex
		end

		if end_angle - start_angle ~= 360 then
			table.insert(vertices, 1, {
				x = x, y = y,
				u = 0.5, v = 0.5,
			})

			vertices.Count = vertices.Count + 1
		else
			table.remove(vertices)
			vertices.Count = vertices.Count - 1
		end

		return vertices
	end
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:IsValid()
	return (
		not self.m_Dirty and
		self.m_Vertices.Count >= 3 and
		self.m_Radius >= 1 and
		self.m_Distance >= 1
	)
end

function CIRCLE:Calculate()
	local rotate_uv = self.m_RotateMaterial

	local radius = self.m_Radius
	local x, y = self.m_X, self.m_Y

	local rotation = self.m_Rotation
	local start_angle = self.m_StartAngle
	local end_angle = self.m_EndAngle

	local distance = self.m_Distance

	assert(radius >= 1, string.format("circle radius should be >= 1 (%.4f)", radius))
	assert(distance >= 1, string.format("circle distance should be >= 1 (%.4f)", distance))

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if self.m_Type == CIRCLE_OUTLINED then
		local inner = self.m_ChildCircle or self:Copy()
		local inner_r = radius - self.m_OutlineWidth

		inner:SetType(CIRCLE_FILLED)

		inner:SetPos(x, y)
		inner:SetRadius(inner_r)
		inner:SetRotation(rotation)
		inner:SetAngles(start_angle, end_angle)
		inner:SetDistance(distance)

		inner:SetColor(false)
		inner:SetMaterial(false)

		inner:SetShouldRender(inner_r >= 1)
		inner:SetDirty(inner.m_ShouldRender)

		self:SetShouldRender(inner_r < radius)
		self:SetChildCircle(inner)
	elseif self.m_ChildCircle then
		self.m_ChildCircle = nil
	end

	self:SetDirty(false)

	return self
end

do
	local blur = Material("pp/blurscreen")

	function CIRCLE:__call()
		if self.m_Dirty then self:Calculate() end

		if not self:IsValid() then return false end
		if not self.m_ShouldRender then return false end

		do
			local col, mat = self.m_Color, self.m_Material

			if IsColor(col) then
				if col.a <= 0 then return end
				surface.SetDrawColor(col.r, col.g, col.b, col.a)
			end

			if mat == true then
				draw.NoTexture()
			elseif TypeID(mat) == TYPE_MATERIAL then
				surface.SetMaterial(mat)
			end
		end

		if self.m_Type == CIRCLE_OUTLINED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				self.m_ChildCircle()

				render.SetStencilCompareFunction(STENCIL_GREATER)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.DrawPoly(self.m_Vertices)
			render.SetStencilEnable(false)
		elseif self.m_Type == CIRCLE_BLURRED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				surface.DrawPoly(self.m_Vertices)

				render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.SetMaterial(blur)

				local sw, sh = ScrW(), ScrH()

				for i = 1, self.m_BlurLayers do
					blur:SetFloat("$blur", (i / self.m_BlurLayers) * self.m_BlurDensity)
					blur:Recompute()

					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(0, 0, sw, sh)
				end
			render.SetStencilEnable(false)
		else
			surface.DrawPoly(self.m_Vertices)
		end

		return true
	end

	CIRCLE.Draw = CIRCLE.__call
end

do
	local err_number = "bad argument #%i to 'Translate' (number expected, got %s)"

	function CIRCLE:Translate(x, y)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))

		if x ~= 0 or y ~= 0 then
			self.m_X = self.m_X + x
			self.m_Y = self.m_Y + y

			if self:IsValid() then
				for i = 1, self.m_Vertices.Count do
					local vertex = self.m_Vertices[i]

					vertex.x = vertex.x + x
					vertex.y = vertex.y + y
				end

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Translate(x, y)
				end
			end
		end

		return self
	end
end

do
	local err_number = "bad argument #1 to 'Scale' (number expected, got %s)"

	function CIRCLE:Scale(scale)
		assert(isnumber(scale), string.format(err_number, type(scale)))

		if scale ~= 1 then
			self.m_Radius = self.m_Radius * scale

			if self:IsValid() then
				local x, y = self.m_X, self.m_Y

				for i = 1, self.m_Vertices.Count do
					local vertex = self.m_Vertices[i]

					vertex.x = x + (vertex.x - x) * scale
					vertex.y = y + (vertex.y - y) * scale
				end

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Scale(scale)
				end
			end
		end

		return self
	end
end

do
	local err_number = "bad argument #1 to 'Rotate' (number expected, got %s)"

	function CIRCLE:Rotate(rotation)
		assert(isnumber(rotation), string.format(err_number, type(rotation)))

		if rotation ~= 0 then
			self.m_Rotation = self.m_Rotation + rotation

			if self:IsValid() then
				local x, y = self.m_X, self.m_Y
				local vertices = self.m_Vertices
				local rotate_uv = self.m_RotateMaterial

				RotateVertices(vertices, x, y, rotation, rotate_uv)

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Rotate(rotation)
				end
			end
		end

		return self
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if default ~= nil and value == nil then
				value = default
			end

			if self[varname] ~= value then
				if dirty then
					self[dirty] = true
				end

				if callback ~= nil then
					local new = callback(self, self[varname], value)
					value = new ~= nil and new or value
				end

				self[varname] = value
			end

			return self
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		circle:Translate(new - old, 0)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Translate(new - old, 0)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		circle:Translate(0, new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Translate(0, new - old)
		end
	end

	local function UpdateRotation(circle, old, new)
		circle:Rotate(new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Rotate(new - old)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)
	AccessorFunc("ShouldRender", true)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty")		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX)		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY)		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty")				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty")			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurLayers", 3)						-- The circle's blur layers if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurDensity", 2)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		x = tonumber(x) or self.m_X
		y = tonumber(y) or self.m_Y

		if self:IsValid() then
			self:Translate(x - self.m_X, y - self.m_Y)
		else
			self.m_X = x
			self.m_Y = y
		end

		return self
	end

	function CIRCLE:SetAngles(s, e)
		s = tonumber(s) or self.m_StartAngle
		e = tonumber(e) or self.m_EndAngle

		self:SetDirty(self.m_Dirty or s ~= self.m_StartAngle or e ~= self.m_EndAngle)

		self.m_StartAngle = s
		self.m_EndAngle = e

		return self
	end

	function CIRCLE:GetPos()
		return self.m_X, self.m_Y
	end

	function CIRCLE:GetAngles()
		return self.m_StartAngle, self.m_EndAngle
	end
end

_R.Circles = {
	_MT = CIRCLE,

	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrobat.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrodual.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Electrostaff [Dual]"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("staffel") 
		self:SetBladeR("purpstaff") 
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrostaff.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Electrostaff"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("electrostaff") 
		self:SetBladeR("electrostaffcrys") 
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_purgestaff.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_savagespear.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Savage Spear"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("savagespear") 
		self:SetBladeR("savagespearcrys") 
	end
end
--PATH gamemodes/starwarsrp/entities/weapons/weapon_m42/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/weapon_mac102/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_shaman.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_vibrosword.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category			= "[LSCS]"
SWEP.PrintName		= "Vibro Sword"
SWEP.Author			= "Blu-x92 / Luna"

SWEP.Slot				= 0
SWEP.SlotPos			= 2

SWEP.Spawnable		= true
SWEP.AdminOnly		= true

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("vibrosword")
		self:SetBladeR("nanoparticles")
	end
end

--PATH lua/weapons/weapon_vj_ak47/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_base/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
IncludeCS("ai_translations.lua")
SWEP.IsVJBaseWeapon = true
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Core & Information-Related Variables ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//SWEP.Base = "weapon_base"
SWEP.PrintName = "VJ Weapon Base"
SWEP.Author = "DrVrej"
SWEP.Contact = "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose = "This weapon is made for Players and NPCs"
SWEP.Instructions = "Controls are like a regular weapon."
SWEP.Category = "VJ Base"
//SWEP.Spawnable = false
//SWEP.AdminOnly = false
SWEP.MadeForNPCsOnly = false -- Is this weapon meant to be for NPCs only?
SWEP.HoldType = "ar2"
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ View Model Variables ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel = "models/weapons/v_flaregun.mdl"
SWEP.UseHands = false -- Should this weapon use Garry's Mod hands? (The model must support it!)
SWEP.ViewModelFlip = false -- Flip the model? Usually used for CS:S models
SWEP.ViewModelFOV = 55 -- Player FOV for the view model
SWEP.BobScale = 1.5 -- Bob effect when moving
SWEP.SwayScale = 1 -- Default is 1, The scale of the viewmodel sway
SWEP.CSMuzzleFlashes = false -- Recommended to enable for Counter Strike: Source models
SWEP.DrawAmmo = true -- Draw regular Garry's Mod HUD?
SWEP.DrawCrosshair = true -- Draw Crosshair?
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ World Model Variables ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SWEP.WorldModel = "models/weapons/w_rif_ak47.mdl"
SWEP.WorldModel_UseCustomPosition = false -- Should the gun use custom position? This can be used to fix guns that are in the crotch
SWEP.WorldModel_CustomPositionAngle = Vector(0, 0, 0)
SWEP.WorldModel_CustomPositionOrigin = Vector(0, 0, 0)
SWEP.WorldModel_CustomPositionBone = "ValveBiped.Bip01_R_Hand" -- The bone it will use as the main point (Owner's bone)
SWEP.WorldModel_Invisible = false -- Should the world model be invisible?
SWEP.WorldModel_NoShadow = false -- Should the world model have a shadow?
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ General NPC Variables ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- Set this to false to disable the timer automatically running the firing code, this allows for event-based SNPCs to fire at their own pace:
SWEP.NPC_NextPrimaryFire = 0.1 -- Next time it can use primary fire
	-- Note: Melee weapons automatically change this number!
SWEP.NPC_TimeUntilFire = 0.1 -- How much time until the bullet/projectile is fired?
SWEP.NPC_TimeUntilFireExtraTimers = {} -- Extra timers, which will make the gun fire again! | The seconds are counted after the self.NPC_TimeUntilFire!
SWEP.NPC_CustomSpread = 1 -- This is added on top of the custom spread that's set inside the SNPC! | Starting from 1: Closer to 0 = better accuracy, Farther than 1 = worse accuracy
SWEP.NPC_BulletSpawnAttachment = "" -- The attachment that the bullet spawns on, leave empty for base to decide!
SWEP.NPC_CanBePickedUp = true -- Can this weapon be picked up by NPCs? (Ex: Rebels)
SWEP.NPC_StandingOnly = false -- If true, the weapon can only be fired if the NPC is standing still
	-- ====== Firing Distance ====== --
SWEP.NPC_FiringDistanceScale = 1 -- Changes how far the NPC can fire | 1 = No change, x < 1 = closer, x > 1 = farther
SWEP.NPC_FiringDistanceMax = 100000 -- Maximum firing distance | Clamped at the maximum sight distance of the NPC
	-- ====== Reload Variables ====== --
SWEP.NPC_HasReloadSound = true -- Should it play a sound when the base detects the SNPC playing a reload animation?
SWEP.NPC_ReloadSound = {} -- Sounds it plays when the base detects the SNPC playing a reload animation
SWEP.NPC_ReloadSoundLevel = 60 -- How far does the sound go?
	-- ====== Before Fire Sound Variables ====== --
	-- NOTE: This only works with VJ Human SNPCs!
SWEP.NPC_BeforeFireSound = {} -- Plays a sound before the firing code is ran, usually in the beginning of the animation
SWEP.NPC_BeforeFireSoundLevel = 70 -- How far does the sound go?
SWEP.NPC_BeforeFireSoundPitch = VJ_Set(90, 100) -- How much time until the secondary fire can be used again?
	-- ====== Extra Firing Sound Variables ====== --
SWEP.NPC_ExtraFireSound = {} -- Plays an extra sound after it fires (Example: Bolt action sound)
SWEP.NPC_ExtraFireSoundTime = 0.4 -- How much time until it plays the sound (After Firing)?
SWEP.NPC_ExtraFireSoundLevel = 70 -- How far does the sound go?
SWEP.NPC_ExtraFireSoundPitch = VJ_Set(90, 100) -- How much time until the secondary fire can be used again?
	-- ====== Secondary Fire Variables ====== --
SWEP.NPC_HasSecondaryFire = false -- Can the weapon have a secondary fire?
SWEP.NPC_SecondaryFireEnt = "obj_vj_grenade_rifle" -- The entity to fire, this only applies if self:NPC_SecondaryFire() has NOT been overridden!
SWEP.NPC_SecondaryFireChance = 3 -- Chance that the secondary fire is used | 1 = always
SWEP.NPC_SecondaryFireNext = VJ_Set(12, 15) -- How much time until the secondary fire can be used again?
SWEP.NPC_SecondaryFireDistance = 1000 -- How close does the owner's enemy have to be for it to fire?
SWEP.NPC_HasSecondaryFireSound = true -- Can the secondary fire sound be played?
SWEP.NPC_SecondaryFireSound = {} -- The sound it plays when the secondary fire is used
SWEP.NPC_SecondaryFireSoundLevel = 90 -- The sound level to use for the secondary firing sound
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ General Player Variables ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- ====== Inventory-Related Variables ====== --
SWEP.Slot = 2 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6)
SWEP.SlotPos = 4 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.Weight = 30 -- Decides whether we should switch from/to this
SWEP.AutoSwitchTo = false -- Auto switch to this weapon when it's picked up
SWEP.AutoSwitchFrom = false -- Auto switch weapon when the owner picks up a better weapon
SWEP.DrawWeaponInfoBox = true -- Should the information box show in the weapon selection menu?
SWEP.BounceWeaponIcon = true -- Should the icon bounce in the weapon selection menu?
	-- ====== Deployment Variables ====== --
SWEP.AnimTbl_Deploy = {ACT_VM_DRAW}
SWEP.HasDeploySound = true -- Does the weapon have a deploy sound?
SWEP.DeploySound = {} -- Sound played when the weapon is deployed
	-- ====== Idle Variables ====== --
SWEP.HasIdleAnimation = true -- Does it have a idle animation?
SWEP.AnimTbl_Idle = {ACT_VM_IDLE}
	-- ====== Reload Variables ====== --
SWEP.HasReloadSound = false -- Does it have a reload sound? Remember even if this is set to false, the animation sound will still play!
SWEP.ReloadSound = {}
SWEP.AnimTbl_Reload = {ACT_VM_RELOAD}
SWEP.Reload_TimeUntilAmmoIsSet = 1 -- Time until ammo is set to the weapon
	-- ====== Secondary Fire Variables ====== --
SWEP.Secondary.Automatic = false -- Is it automatic?
SWEP.Secondary.Ammo = "none" -- Ammo type
SWEP.Secondary.TakeAmmo = 1 -- How much ammo should it take on each shot?
	-- To let the base automatically detect the animation duration, set this to false:
SWEP.Secondary.Delay = false -- Time until it can shoot again
SWEP.AnimTbl_SecondaryFire = {ACT_VM_SECONDARYATTACK}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Dry Fire Variables ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- Examples: Under water, out of ammo
SWEP.HasDryFireSound = true -- Should it play a sound when it's out of ammo?
SWEP.DryFireSound = {} -- The sound that it plays when the weapon is out of ammo
SWEP.DryFireSoundLevel = 50 -- Dry fire sound level
SWEP.DryFireSoundPitch = VJ_Set(90, 100) -- Dry fire sound pitch
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Primary Fire Variables ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.DisableBulletCode = false -- The bullet won't spawn, this can be used when creating a projectile-based weapon
SWEP.Primary.AllowFireInWater = false -- If true, you will be able to use primary fire in water
SWEP.Primary.Damage = 5 -- Damage
SWEP.Primary.PlayerDamage = "Same" -- Only applies for players | "Same" = Same as self.Primary.Damage, "Double" = Double the self.Primary.Damage OR put a number to be different from self.Primary.Damage
SWEP.Primary.Force = 5 -- Force applied on the object the bullet hits
SWEP.Primary.NumberOfShots = 1 -- How many shots per attack?
SWEP.Primary.ClipSize = 30 -- Max amount of bullets per clip
SWEP.Primary.PickUpAmmoAmount = "Default" -- How much ammo should the player get the gun is picked up? | "Default" = 3 Clips
SWEP.Primary.Recoil = 0.3 -- How much recoil does the player get?
SWEP.Primary.Cone = 7 -- How accurate is the bullet? (Players)
SWEP.Primary.Delay = 0.1 -- Time until it can shoot again
SWEP.Primary.Tracer = 1
SWEP.Primary.TracerType = "Tracer" -- Tracer type (Examples: AR2)
SWEP.Primary.TakeAmmo = 1 -- How much ammo should it take on each shot?
SWEP.Primary.Automatic = true -- Is it automatic?
SWEP.Primary.Ammo = "SMG1" -- Ammo type
SWEP.AnimTbl_PrimaryFire = {ACT_VM_PRIMARYATTACK}
	-- ====== Sound Variables ====== --
SWEP.Primary.Sound = {}
SWEP.Primary.SoundLevel = 80
SWEP.Primary.SoundPitch	= VJ_Set(90, 100)
SWEP.Primary.SoundVolume = 1
SWEP.Primary.DistantSound = {}
SWEP.Primary.HasDistantSound = true -- Does it have a distant sound when the gun is shot?
SWEP.Primary.DistantSoundLevel = 140 -- Distant sound level
SWEP.Primary.DistantSoundPitch	= VJ_Set(90, 110) -- Distant sound pitch
SWEP.Primary.DistantSoundVolume	= 1 -- Distant sound volume
	-- ====== Effect Variables ====== --
SWEP.PrimaryEffects_MuzzleFlash = true
SWEP.PrimaryEffects_MuzzleParticles = {"vj_rifle_full"}
SWEP.PrimaryEffects_MuzzleParticlesAsOne = false -- If set to true, the base will spawn all the given particles instead of picking one
SWEP.PrimaryEffects_MuzzleAttachment = "muzzle"
SWEP.PrimaryEffects_SpawnShells = true
SWEP.PrimaryEffects_ShellAttachment = "shell"
SWEP.PrimaryEffects_ShellType = "VJ_Weapon_RifleShell1" -- VJ_Weapon_RifleShell1 | VJ_Weapon_PistolShell1 | VJ_Weapon_ShotgunShell1
SWEP.PrimaryEffects_SpawnDynamicLight = true
SWEP.PrimaryEffects_DynamicLightBrightness = 4
SWEP.PrimaryEffects_DynamicLightDistance = 120
SWEP.PrimaryEffects_DynamicLightColor = Color(255, 150, 60)
	-- ====== Melee Variables ====== --
SWEP.IsMeleeWeapon = false -- Should this weapon be a melee weapon?
SWEP.MeleeWeaponDistance = 100 -- If it's this close, it will attack
SWEP.MeleeWeaponSound_Hit = {"physics/flesh/flesh_impact_bullet1.wav"} -- Sound it plays when it hits something
SWEP.MeleeWeaponSound_Miss = {"weapons/iceaxe/iceaxe_swing1.wav"} -- Sound it plays when it misses (Doesn't hit anything)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Customization Functions ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- Use the functions below to customize certain parts of the base or to add new custom systems
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnInitialize() end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnEquip(newOwner) end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnThink() end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnNPC_ServerThink() end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnReload() end
---------------------------------------------------------------------------------------------------------------------------------------------
-- Unlike CustomOnReload(), this is called AFTER the reload animation has finished
-- This only works for players and VJ Humans!
function SWEP:CustomOnReload_Finish() return true end -- Return false to to override base code
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttack_BeforeShoot() end -- Return true to not run rest of the firing code
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttack_AfterShoot() end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttack_MeleeHit(ent) end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttack_BulletCallback(attacker, tr, dmginfo) end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttackEffects() return true end -- Return false to disable the base effects
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:NPC_SecondaryFire_BeforeTimer(eneEnt, fireTime) end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:NPC_SecondaryFire()
	-- Override this function if you want to make your own secondary attack!
	local owner = self:GetOwner()
	local pos = self:GetNW2Vector("VJ_CurBulletPos")
	local proj = ents.Create(self.NPC_SecondaryFireEnt)
	proj:SetPos(pos)
	proj:SetAngles(owner:GetAngles())
	proj:SetOwner(owner)
	proj:Spawn()
	proj:Activate()
	local phys = proj:GetPhysicsObject()
	if IsValid(phys) then
		phys:Wake()
		phys:SetVelocity(owner:CalculateProjectile("Curve", pos, owner.EnemyData.LastVisiblePos, 1000))
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnSecondaryAttack() return true end -- Players only! | Return false to override base code
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomBulletSpawnPosition() return false end -- Return a position to override the bullet spawn position
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnFireAnimationEvent(pos, ang, event, options) return false end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnDrawWorldModel() return true end -- Return false to not draw the world model | This is client side only!
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnDeploy() end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnIdle() end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnHolster(newWep) return true end -- Return false to disallow the weapon from switching
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnRemove() end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ ///// WARNING: Don't touch anything below this line! \\\\\ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SWEP.RenderGroup = RENDERGROUP_OPAQUE

SWEP.Reloading = false
SWEP.NextReloadT = 0
SWEP.NextIdleT = 0
SWEP.InitHasIdleAnimation = false
SWEP.Primary.DefaultClip = 0
SWEP.NextNPCDrySoundT = 0
SWEP.NPC_NextPrimaryFireT = 0
SWEP.NPC_AnimationSet = "Custom"
SWEP.NPC_SecondaryFireNextT = 0
SWEP.NPC_SecondaryFirePerforming = false
SWEP.LastOwner = NULL


-- !!!!!!!!!!!!!! DO NOT USE THIS VARIABLE !!!!!!!!!!!!!! [Backwards Compatibility!]
	-- Basically if someone is retrieving "VJ_CurBulletPos" using NW, it will convert it to NW2 otherwise it just runs the regular code
local entMETA = FindMetaTable("Entity")
local wepMETA = FindMetaTable("Weapon")
local old_GetNWVector = entMETA.GetNWVector
function wepMETA:GetNWVector(name, default)
	if name == "VJ_CurBulletPos" then return self:GetNW2Vector("VJ_CurBulletPos", default)
	else return old_GetNWVector(self, name, default) end
end

---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:GetCapabilities()
	return bit.bor(CAP_WEAPON_RANGE_ATTACK1,CAP_INNATE_RANGE_ATTACK1)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:Initialize()
	self:SetNW2Vector("VJ_CurBulletPos", self:GetPos())
	self:SetHoldType(self.HoldType)
	if self.HasIdleAnimation == true then self.InitHasIdleAnimation = true end
	self.NPC_SecondaryFireNextT = CurTime() + math.Rand(self.NPC_SecondaryFireNext.a, self.NPC_SecondaryFireNext.b)
	self:CustomOnInitialize()
	if SERVER then
		//self:SetWeaponHoldType(self.HoldType)
		self:SetNPCMinBurst(10)
		self:SetNPCMaxBurst(20)
		self:SetNPCFireRate(10)
	end
	self:SetDefaultValues(self.HoldType)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:Equip(newOwner)
	-- Do NOT set the clip if this is simply a weapon switch (Specifically for VJ NPCs)
	if self.LastOwner == NULL then
		self:SetClip1(self.Primary.ClipSize)
	end
	if newOwner:IsPlayer() then
		if self.Primary.PickUpAmmoAmount == "Default" then
			newOwner:GiveAmmo(self.Primary.ClipSize * 2, self.Primary.Ammo)
		elseif isnumber(self.Primary.PickUpAmmoAmount) then
			newOwner:GiveAmmo(self.Primary.PickUpAmmoAmount, self.Primary.Ammo)
		end
		//newOwner:RemoveAmmo(self.Primary.DefaultClip,self.Primary.Ammo)
		if self.MadeForNPCsOnly == true then
			newOwner:PrintMessage(HUD_PRINTTALK, self.PrintName.." removed! It's made for NPCs only!")
			self:Remove()
		end
	elseif newOwner:IsNPC() then
		-- For default HL2 NPCs
		if VJ_AnimationExists(newOwner,ACT_WALK_AIM_PISTOL) == true && VJ_AnimationExists(newOwner,ACT_RUN_AIM_PISTOL) == true && VJ_AnimationExists(newOwner,ACT_POLICE_HARASS1) == true then
			self.NPC_AnimationSet = "Metrocop"
		elseif VJ_AnimationExists(newOwner,"cheer1") == true && VJ_AnimationExists(newOwner,"wave_smg1") == true && VJ_AnimationExists(newOwner,ACT_BUSY_SIT_GROUND) == true then
			self.NPC_AnimationSet = "Rebel"
		elseif VJ_AnimationExists(newOwner,"signal_takecover") == true && VJ_AnimationExists(newOwner,"grenthrow") == true && VJ_AnimationExists(newOwner,"bugbait_hit") == true then
			self.NPC_AnimationSet = "Combine"
		end

		if newOwner:GetClass() == "npc_citizen" then newOwner:Fire("DisableWeaponPickup") end -- If it's a citizen, disable them picking up weapons from the ground
		newOwner:SetKeyValue("spawnflags", "256") -- Long Visibility Shooting since HL2 NPCs are blind
		hook.Add("Think", self, self.NPC_ServerNextFire)
		
		if newOwner.IsVJBaseSNPC && newOwner.IsVJBaseSNPC_Human == true then
			newOwner.Weapon_OriginalFiringDistanceFar = newOwner.Weapon_OriginalFiringDistanceFar or newOwner.Weapon_FiringDistanceFar
			if self.IsMeleeWeapon == true then
				newOwner.Weapon_FiringDistanceFar = self.MeleeWeaponDistance
			else
				newOwner.Weapon_FiringDistanceFar = math.Clamp(newOwner.Weapon_OriginalFiringDistanceFar * self.NPC_FiringDistanceScale, newOwner.Weapon_FiringDistanceClose, self.NPC_FiringDistanceMax)
			end
		end
	end
	self:CustomOnEquip(newOwner)
	self.LastOwner = newOwner
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:SetDefaultValues(hType, overrideSds)
	hType = hType or "ar2"
	overrideSds = overrideSds or false
	if hType == "pistol" then
		if VJ_PICK(self.DeploySound) == false or overrideSds == true then self.DeploySound = {"weapons/draw_pistol.wav"} end
		if VJ_PICK(self.DryFireSound) == false or overrideSds == true then self.DryFireSound = {"vj_weapons/dryfire_pistol.wav"} end
		if VJ_PICK(self.NPC_ReloadSound) == false or overrideSds == true then self.NPC_ReloadSound = {"vj_weapons/reload_pistol.wav"} end
	elseif hType == "revolver" then
		if VJ_PICK(self.DeploySound) == false or overrideSds == true then self.DeploySound = {"weapons/draw_pistol.wav"} end
		if VJ_PICK(self.DryFireSound) == false or overrideSds == true then self.DryFireSound = {"vj_weapons/dryfire_revolver.wav"} end
		if VJ_PICK(self.NPC_ReloadSound) == false or overrideSds == true then self.NPC_ReloadSound = {"vj_weapons/reload_revolver.wav"} end
	elseif hType == "shotgun" or hType == "crossbow" then
		if VJ_PICK(self.DeploySound) == false or overrideSds == true then self.DeploySound = {"weapons/draw_rifle.wav"} end
		if VJ_PICK(self.DryFireSound) == false or overrideSds == true then self.DryFireSound = {"vj_weapons/dryfire_rifle.wav"} end
		if VJ_PICK(self.NPC_ReloadSound) == false or overrideSds == true then self.NPC_ReloadSound = {"vj_weapons/reload_shotgun.wav"} end
	elseif hType == "rpg" then
		if VJ_PICK(self.DeploySound) == false or overrideSds == true then self.DeploySound = {"weapons/draw_rifle.wav"} end
		if VJ_PICK(self.DryFireSound) == false or overrideSds == true then self.DryFireSound = {"vj_weapons/dryfire_rifle.wav"} end
		if VJ_PICK(self.NPC_ReloadSound) == false or overrideSds == true then self.NPC_ReloadSound = {"vj_weapons/reload_rpg.wav"} end
	elseif hType == "smg" or hType == "ar2" then
		if VJ_PICK(self.DeploySound) == false or overrideSds == true then self.DeploySound = {"weapons/draw_rifle.wav"} end
		if VJ_PICK(self.DryFireSound) == false or overrideSds == true then self.DryFireSound = {"vj_weapons/dryfire_rifle.wav"} end
		if VJ_PICK(self.NPC_ReloadSound) == false or overrideSds == true then self.NPC_ReloadSound = {"vj_weapons/reload_rifle.wav"} end
	elseif hType == "melee" or hType == "melee2" or hType == "knife" then
		self.HasDryFireSound = false
		self.NPC_HasReloadSound = false
		self.DeploySound = {"weapons/draw_rifle.wav"}
	else
		self.DryFireSound = {"vj_weapons/dryfire_rifle.wav"}
		self.NPC_ReloadSound = {"vj_weapons/reload_rifle.wav"}
		self.DeploySound = {"weapons/draw_rifle.wav"}
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:TranslateActivity(act)
	local owner = self:GetOwner()
	if (owner:IsNPC()) then
		if owner.IsVJBaseSNPC_Human == true then
			local wepT = owner.WeaponAnimTranslations[act]
			if (wepT) then
				if istable(wepT) then
					return VJ_PICK(wepT)
				end
				return wepT
			end
		elseif (self.ActivityTranslateAI[act]) then -- For non-VJ Human NPCs
			return self.ActivityTranslateAI[act]
		end
		return -1
	end
	
	-- For non-NPCs
	if (self.ActivityTranslate[act] != nil) then
		return self.ActivityTranslate[act]
	end
	return -1
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CanBePickedUpByNPCs()
	return self.NPC_CanBePickedUp
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:NPC_ServerNextFire()
	if CLIENT or !IsValid(self) then return end
	local owner = self:GetOwner()
	if !IsValid(owner) or !owner:IsNPC() then return end
	if owner:GetActiveWeapon() != self then return end
	
	if self.IsMeleeWeapon == false then
		local pos = self:DecideBulletPosition()
		if pos != nil then
			self:SetNW2Vector("VJ_CurBulletPos", pos)
		end
	end
	
	if owner:GetActivity() == nil then return end
	
	//print("------------------")
	//VJ_CreateTestObject(self:DecideBulletPosition(),self:GetAngles(),Color(255,0,255),1)
	//VJ_CreateTestObject(self:GetNW2Vector("VJ_CurBulletPos"),self:GetAngles(),Color(0,0,255),1)

	self:RunWorldModelThink()
	self:CustomOnThink()
	self:CustomOnNPC_ServerThink()
	
	if self.NPC_NextPrimaryFire != false && self:NPCAbleToShoot() == true then
		self:NPCShoot_Primary() -- Panpoushde zarg
		hook.Remove("Think", self)
		//print(self.NPC_NextPrimaryFire)
		local nxt = self.NPC_NextPrimaryFire
		if nxt > 0.15 then nxt = 0.15 end -- Yete nxt aveli medz e 0.15, ere vor 0.15 ela
		timer.Simple(nxt, function()
			-- Had to add "isfunction" check because after GMod devs applied this: https://github.com/Facepunch/garrysmod/pull/1344
			-- It will VERY rarely think self.NPC_ServerNextFire is nil, why? No one knows, the error never appeared for me, but it has appeared 1-2 for some people.
			-- I would rather have a function that fails silently then fail 1 in 999,999 times without actual reason, so does this check avoid it? (I don't know...)
			if IsValid(self) then
				hook.Add("Think", self, function()
					if isfunction(self.NPC_ServerNextFire) then
						self:NPC_ServerNextFire()
					end
				end)
			end
		end)
		//self.NPC_NextPrimaryFireT = CurTime() + self.NPC_NextPrimaryFire
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:NPCAbleToShoot()
	local owner = self:GetOwner()
	if IsValid(owner) && owner:IsNPC() then
		local ene = owner:GetEnemy()
		if (owner.IsVJBaseSNPC_Human && IsValid(ene) && owner:IsAbleToShootWeapon(true, true) == false) or (self.NPC_StandingOnly == true && owner:IsMoving()) then
			return false
		end
		if owner:GetActivity() != nil && ((owner.IsVJBaseSNPC_Human == true && owner.DoingWeaponAttack == true && (/*(owner.CurrentWeaponAnimation == owner:GetSequenceActivity(owner:GetSequence())) or*/ (owner.CurrentWeaponAnimation == owner:GetActivity()) or (owner:GetActivity() == owner:TranslateToWeaponAnim(owner.CurrentWeaponAnimation)) or (!owner.DoingWeaponAttack_Standing))) or (!owner.IsVJBaseSNPC_Human)) then
			-- For VJ Humans only, ammo check
			if owner.IsVJBaseSNPC_Human && owner.AllowWeaponReloading == true && self:Clip1() <= 0 then -- No ammo!
				if owner.VJ_IsBeingControlled == true then owner.VJ_TheController:PrintMessage(HUD_PRINTCENTER, "Press R to reload!") end
				if self.IsMeleeWeapon == false && self.HasDryFireSound == true && CurTime() > self.NextNPCDrySoundT then
					local sdtbl = VJ_PICK(self.DryFireSound)
					if sdtbl != false then owner:EmitSound(sdtbl, 80, math.random(self.DryFireSoundPitch.a, self.DryFireSoundPitch.b)) end
					if self.NPC_NextPrimaryFire != false then
						self.NextNPCDrySoundT = CurTime() + self.NPC_NextPrimaryFire
					end
				end
				return false
			end
			if IsValid(ene) && ((!owner.VJ_IsBeingControlled) or (owner.VJ_IsBeingControlled && owner.VJ_TheController:KeyDown(IN_ATTACK2))) then
				return true
			end
		end
	end
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:NPCShoot_Primary()
	local owner = self:GetOwner()
	if !IsValid(owner) then return end
	local ene = owner:GetEnemy()
	if !owner.VJ_IsBeingControlled && (!IsValid(ene) or (!owner:Visible(ene))) then return end
	if owner.IsVJBaseSNPC == true then
		//owner.Weapon_TimeSinceLastShot = CurTime()
		//owner.NextWeaponAttackAimPoseParametersReset = CurTime() + 1
		owner:DoPoseParameterLooking()
	end
	
	-- Secondary Fire
	if self.NPC_HasSecondaryFire == true && owner.CanUseSecondaryOnWeaponAttack && !self.NPC_SecondaryFirePerforming && CurTime() > self.NPC_SecondaryFireNextT && ene:GetPos():Distance(owner:GetPos()) <= self.NPC_SecondaryFireDistance then
		if math.random(1, self.NPC_SecondaryFireChance) == 1 then
			local secAnim = VJ_PICK(owner.AnimTbl_WeaponAttackSecondary)
			owner:VJ_ACT_PLAYACTIVITY(secAnim, true, false, true)
			self.NPC_SecondaryFirePerforming = true
			self:NPC_SecondaryFire_BeforeTimer(ene, owner.WeaponAttackSecondaryTimeUntilFire)
			timer.Simple(owner.WeaponAttackSecondaryTimeUntilFire, function()
				if IsValid(self) then
					self.NPC_SecondaryFirePerforming = false
					if IsValid(owner) && IsValid(owner:GetEnemy()) && CurTime() > self.NPC_SecondaryFireNextT && VJ_IsCurrentAnimation(owner, VJ_RemoveAnimExtensions(self, secAnim)) then
						self:NPC_SecondaryFire()
						if self.NPC_HasSecondaryFireSound == true then VJ_EmitSound(owner, self.NPC_SecondaryFireSound, self.NPC_SecondaryFireSoundLevel) end
						if self.NPC_SecondaryFireNext != false then -- Support for animation events
							self.NPC_SecondaryFireNextT = CurTime() + math.Rand(self.NPC_SecondaryFireNext.a, self.NPC_SecondaryFireNext.b)
						end
					end
				end
			end)
			return
		else
			self.NPC_SecondaryFireNextT = CurTime() + math.Rand(self.NPC_SecondaryFireNext.a, self.NPC_SecondaryFireNext.b)
		end
	end
	
	-- Primary Fire
	timer.Simple(self.NPC_TimeUntilFire, function()
		if IsValid(self) && IsValid(owner) && self:NPCAbleToShoot() == true && CurTime() > self.NPC_NextPrimaryFireT then
			self:PrimaryAttack()
			if self.NPC_NextPrimaryFire != false then -- Support for animation events
				self.NPC_NextPrimaryFireT = CurTime() + self.NPC_NextPrimaryFire
				for _, tv in ipairs(self.NPC_TimeUntilFireExtraTimers) do
					timer.Simple(tv, function() if IsValid(self) && IsValid(owner) && self:NPCAbleToShoot() == true then self:PrimaryAttack() end end)
				end
			end
			if owner.IsVJBaseSNPC == true then owner.Weapon_TimeSinceLastShot = CurTime() end
		end
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:NPC_Reload()
	local owner = self:GetOwner()
	owner.NextThrowGrenadeT = owner.NextThrowGrenadeT + 2
	self:CustomOnReload()
	if self.NPC_HasReloadSound == true then VJ_EmitSound(owner, self.NPC_ReloadSound, self.NPC_ReloadSoundLevel) end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:PrimaryAttack(UseAlt)
	//if self:GetOwner():KeyDown(IN_RELOAD) then return end
	//self:GetOwner():SetFOV(45, 0.3)
	//if !IsFirstTimePredicted() then return end
	
	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	local owner = self:GetOwner()
	local isNPC = owner:IsNPC()
	local isPly = owner:IsPlayer()
	
	if self.Reloading or self:GetNextSecondaryFire() > CurTime() then return end
	if isNPC && owner.VJ_IsBeingControlled == false && !IsValid(owner:GetEnemy()) then return end -- If the NPC owner isn't being controlled and doesn't have an enemy, then return end
	if SERVER && self.IsMeleeWeapon == false && ((isPly && self.Primary.AllowFireInWater == false && owner:WaterLevel() == 3) or (self:Clip1() <= 0)) then owner:EmitSound(VJ_PICK(self.DryFireSound),self.DryFireSoundLevel,math.random(self.DryFireSoundPitch.a, self.DryFireSoundPitch.b)) return end
	if (!self:CanPrimaryAttack()) then return end
	if self:CustomOnPrimaryAttack_BeforeShoot() == true then return end
	
	if isNPC && owner.IsVJBaseSNPC == true then
		timer.Simple(self.NPC_ExtraFireSoundTime, function()
			if IsValid(self) && IsValid(owner) then
				VJ_EmitSound(owner, self.NPC_ExtraFireSound, self.NPC_ExtraFireSoundLevel, math.Rand(self.NPC_ExtraFireSoundPitch.a, self.NPC_ExtraFireSoundPitch.b))
			end
		end)
	end
	
	-- Firing Sounds
	if SERVER then
		local fireSd = VJ_PICK(self.Primary.Sound)
		if fireSd != false then
			sound.Play(fireSd, owner:GetPos(), self.Primary.SoundLevel, math.random(self.Primary.SoundPitch.a, self.Primary.SoundPitch.b), self.Primary.SoundVolume)
			//self:EmitSound(fireSd, 80, math.random(90,100))
		end
		if self.Primary.HasDistantSound == true then
			local fireFarSd = VJ_PICK(self.Primary.DistantSound)
			if fireFarSd != false then
				sound.Play(fireFarSd, owner:GetPos(), self.Primary.DistantSoundLevel, math.random(self.Primary.DistantSoundPitch.a, self.Primary.DistantSoundPitch.b), self.Primary.DistantSoundVolume)
			end
		end
	end
	
	-- Firing Gesture
	if owner.IsVJBaseSNPC_Human == true && owner.DisableWeaponFiringGesture != true then
		owner:VJ_ACT_PLAYACTIVITY(owner:TranslateToWeaponAnim(VJ_PICK(owner.AnimTbl_WeaponAttackFiringGesture)), false, false, false, 0, {AlwaysUseGesture=true})
	end
	
	-- MELEE WEAPON
	if self.IsMeleeWeapon == true then
		local meleeHitEnt = false
		for _,v in ipairs(ents.FindInSphere(owner:GetPos(), self.MeleeWeaponDistance)) do
			if (owner.VJ_IsBeingControlled == true && owner.VJ_TheControllerBullseye == v) or (v:IsPlayer() && v.IsControlingNPC == true) then continue end
			if (isPly && v:EntIndex() != owner:EntIndex()) or (isNPC && (v:IsNPC() or (v:IsPlayer() && v:Alive() && !VJ_CVAR_IGNOREPLAYERS)) && (owner:Disposition(v) != D_LI) && (v != owner) && (v:GetClass() != owner:GetClass()) or (v:GetClass() == "prop_physics") or v:GetClass() == "func_breakable_surf" or v:GetClass() == "func_breakable" && (owner:GetForward():Dot((v:GetPos() -owner:GetPos()):GetNormalized()) > math.cos(math.rad(owner.MeleeAttackDamageAngleRadius)))) then
				local dmginfo = DamageInfo()
				dmginfo:SetDamage(isNPC and owner:VJ_GetDifficultyValue(self.Primary.Damage) or self.Primary.Damage)
				if v:IsNPC() or v:IsPlayer() then dmginfo:SetDamageForce(owner:GetForward() * ((dmginfo:GetDamage() + 100) * 70)) end
				dmginfo:SetInflictor(owner)
				dmginfo:SetAttacker(owner)
				dmginfo:SetDamageType(DMG_CLUB)
				v:TakeDamageInfo(dmginfo, owner)
				if v:IsPlayer() then
					v:ViewPunch(Angle(math.random(-1, 1)*10, math.random(-1, 1)*10, math.random(-1, 1)*10))
				end
				VJ_DestroyCombineTurret(owner, v)
				self:CustomOnPrimaryAttack_MeleeHit(v)
				meleeHitEnt = true
			end
		end
		if meleeHitEnt == true then
			local meleeSd = VJ_PICK(self.MeleeWeaponSound_Hit)
			if meleeSd != false then
				self:EmitSound(meleeSd, 70, math.random(90, 100))
			end
		else
			if owner.IsVJBaseSNPC == true then owner:CustomOnMeleeAttack_Miss() end
			local meleeSd = VJ_PICK(self.MeleeWeaponSound_Miss)
			if meleeSd != false then
				self:EmitSound(meleeSd, 70, math.random(90, 100))
			end
		end
	-- REGULAR WEAPON (NON-MELEE)
	else
		if self.Primary.DisableBulletCode == false then
			local bullet = {}
				bullet.Num = self.Primary.NumberOfShots
				bullet.Tracer = self.Primary.Tracer
				bullet.TracerName = self.Primary.TracerType
				bullet.Force = self.Primary.Force
				bullet.Dir = owner:GetAimVector()
				bullet.AmmoType = self.Primary.Ammo
				bullet.Src = isNPC and self:GetNW2Vector("VJ_CurBulletPos") or owner:GetShootPos() -- Spawn Position
				
				-- Callback
				bullet.Callback = function(attacker, tr, dmginfo)
					self:CustomOnPrimaryAttack_BulletCallback(attacker, tr, dmginfo)
					/*local laserhit = EffectData()
					laserhit:SetOrigin(tr.HitPos)
					laserhit:SetNormal(tr.HitNormal)
					laserhit:SetScale(25)
					util.Effect("AR2Impact", laserhit)
					tr.HitPos:Ignite(8,0)*/
				end
				
				-- Damage
				if isPly then
					bullet.Spread = Vector((self.Primary.Cone / 60) / 4, (self.Primary.Cone / 60) / 4, 0)
					if self.Primary.PlayerDamage == "Same" then
						bullet.Damage = self.Primary.Damage
					elseif self.Primary.PlayerDamage == "Double" then
						bullet.Damage = self.Primary.Damage * 2
					elseif isnumber(self.Primary.PlayerDamage) then
						bullet.Damage = self.Primary.PlayerDamage
					end
				else
					if owner.IsVJBaseSNPC == true then
						bullet.Damage = owner:VJ_GetDifficultyValue(self.Primary.Damage)
					else
						bullet.Damage = self.Primary.Damage
					end
				end
			owner:FireBullets(bullet)
		elseif isNPC && owner.IsVJBaseSNPC == true then -- Make sure the VJ SNPC recognizes that it lost a ammunition, even though it was a custom bullet code
			self:SetClip1(self:Clip1() - 1)
		end
		if GetConVar("vj_wep_nomuszzleflash"):GetInt() == 0 then owner:MuzzleFlash() end
	end
	
	self:PrimaryAttackEffects()
	if isPly then
		//self:ShootEffects("ToolTracer") -- Deprecated
		owner:ViewPunch(Angle(-self.Primary.Recoil, 0, 0))
		self:TakePrimaryAmmo(self.Primary.TakeAmmo)
		owner:SetAnimation(PLAYER_ATTACK1)
		local anim = VJ_PICK(self.AnimTbl_PrimaryFire)
		local animTime = VJ_GetSequenceDuration(owner:GetViewModel(), anim)
		self:SendWeaponAnim(anim)
		self.NextIdleT = CurTime() + animTime
		self.NextReloadT = CurTime() + animTime
	end
	self:CustomOnPrimaryAttack_AfterShoot()
	//self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CanSecondaryAttack()
	return self:Clip2() > 0 && self:GetNextSecondaryFire() < CurTime() && self.Secondary.Ammo != "none"
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:SecondaryAttack()
	if !self:CanSecondaryAttack() or self.Reloading then return end
	if self:CustomOnSecondaryAttack() == false then return end
	
	local owner = self:GetOwner()
	self:TakePrimaryAmmo(self.Secondary.TakeAmmo)
	owner:SetAnimation(PLAYER_ATTACK1)
	local anim = VJ_PICK(self.AnimTbl_SecondaryFire)
	local animTime = VJ_GetSequenceDuration(owner:GetViewModel(), anim)
	self:SendWeaponAnim(anim)
	self.NextIdleT = CurTime() + animTime
	self.NextReloadT = CurTime() + animTime
	
	self:SetNextSecondaryFire(CurTime() + (self.Secondary.Delay == false and animTime or self.Secondary.Delay))
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:DoIdleAnimation()
	if !self.HasIdleAnimation or CurTime() < self.NextIdleT then return end
	self:CustomOnIdle()
	local owner = self:GetOwner()
	if IsValid(owner) then
		owner:SetAnimation(PLAYER_IDLE)
		local anim = VJ_PICK(self.AnimTbl_Idle)
		local animTime = VJ_GetSequenceDuration(owner:GetViewModel(), anim)
		self:SendWeaponAnim(anim)
		self.NextIdleT = CurTime() + animTime
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:PrimaryAttackEffects()
	if self:CustomOnPrimaryAttackEffects() != true or self.IsMeleeWeapon == true then return end
	local owner = self:GetOwner()
	
	/*local muzzleFlashEffect = EffectData()
	muzzleFlashEffect:SetOrigin(owner:GetShootPos())
	muzzleFlashEffect:SetEntity(self)
	muzzleFlashEffect:SetStart(owner:GetShootPos())
	muzzleFlashEffect:SetNormal(owner:GetAimVector())
	muzzleFlashEffect:SetAttachment(1)
	util.Effect("VJ_Weapon_RifleMuzzle1",muzzleFlashEffect)*/
	
	if GetConVar("vj_wep_nomuszzleflash"):GetInt() == 0 then
		-- MUZZLE FLASH
		if self.PrimaryEffects_MuzzleFlash == true then
			local muzzleAttach = self.PrimaryEffects_MuzzleAttachment
			if !isnumber(muzzleAttach) then muzzleAttach = self:LookupAttachment(muzzleAttach) end
			-- Players
			if owner:IsPlayer() && owner:GetViewModel() != nil then
				local muzzleFlashEffect = EffectData()
				muzzleFlashEffect:SetOrigin(owner:GetShootPos())
				muzzleFlashEffect:SetEntity(self)
				muzzleFlashEffect:SetStart(owner:GetShootPos())
				muzzleFlashEffect:SetNormal(owner:GetAimVector())
				muzzleFlashEffect:SetAttachment(muzzleAttach)
				util.Effect("VJ_Weapon_PlayerMuzzle", muzzleFlashEffect)
			else -- NPCs
				if self.PrimaryEffects_MuzzleParticlesAsOne == true then -- Combine all of the particles in the table!
					for _, v in ipairs(self.PrimaryEffects_MuzzleParticles) do
						if !istable(v) then
							ParticleEffectAttach(v, PATTACH_POINT_FOLLOW, self, muzzleAttach)
						end
					end
				else
					ParticleEffectAttach(VJ_PICK(self.PrimaryEffects_MuzzleParticles), PATTACH_POINT_FOLLOW, self, muzzleAttach)
				end
			end
		end
		
		-- MUZZLE LIGHT
		if SERVER && self.PrimaryEffects_SpawnDynamicLight == true && GetConVar("vj_wep_nomuszzleflash_dynamiclight"):GetInt() == 0 then
			local muzzleLight = ents.Create("light_dynamic")
			muzzleLight:SetKeyValue("brightness", self.PrimaryEffects_DynamicLightBrightness)
			muzzleLight:SetKeyValue("distance", self.PrimaryEffects_DynamicLightDistance)
			if owner:IsPlayer() then muzzleLight:SetLocalPos(owner:GetShootPos() +self:GetForward()*40 + self:GetUp()*-10) else muzzleLight:SetLocalPos(self:GetNW2Vector("VJ_CurBulletPos")) end
			muzzleLight:SetLocalAngles(self:GetAngles())
			muzzleLight:Fire("Color", self.PrimaryEffects_DynamicLightColor.r.." "..self.PrimaryEffects_DynamicLightColor.g.." "..self.PrimaryEffects_DynamicLightColor.b)
			//muzzleLight:SetParent(self)
			muzzleLight:Spawn()
			muzzleLight:Activate()
			muzzleLight:Fire("TurnOn", "", 0)
			muzzleLight:Fire("Kill", "", 0.07)
			self:DeleteOnRemove(muzzleLight)
		end
	end

	-- SHELL CASING
	if !owner:IsPlayer() && self.PrimaryEffects_SpawnShells == true && GetConVar("vj_wep_nobulletshells"):GetInt() == 0 then
		local shellAttach = self.PrimaryEffects_ShellAttachment
		if !isnumber(shellAttach) then shellAttach = self:LookupAttachment(shellAttach) end
		local shellEffect = EffectData()
		shellEffect:SetEntity(self)
		shellEffect:SetOrigin(owner:GetShootPos())
		shellEffect:SetNormal(owner:GetAimVector())
		shellEffect:SetAttachment(shellAttach)
		util.Effect(self.PrimaryEffects_ShellType, shellEffect)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:FireAnimationEvent(pos, ang, event, options)
	if self:CustomOnFireAnimationEvent(pos, ang, event, options) == true then return true end
	
	if (event == 22 or event == 6001) then return true end
	
	if GetConVar("vj_wep_nomuszzleflash"):GetInt() == 1 && (event == 21 or event == 22 or event == 5001 or event == 5003) then
		return true
	end

	if GetConVar("vj_wep_nobulletshells"):GetInt() == 1 && event == 20 then
		return true
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:Think() -- NOTE: Works only in players hands. does NOT work in NPCs hands!
	self:RunWorldModelThink()
	self:CustomOnThink()
	if SERVER then
		self:DoIdleAnimation()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:Reload()
	if !IsValid(self) then return end
	local owner = self:GetOwner()
	if !IsValid(owner) or !owner:IsPlayer() or !owner:Alive() or owner:GetAmmoCount(self.Primary.Ammo) == 0 or self.Reloading or CurTime() < self.NextReloadT then return end // or !owner:KeyDown(IN_RELOAD)
	if self:Clip1() < self.Primary.ClipSize then
		self.Reloading = true
		self:CustomOnReload()
		if SERVER && self.HasReloadSound == true then owner:EmitSound(VJ_PICK(self.ReloadSound), 50, math.random(90, 100)) end
		-- Handle clip
		timer.Simple(self.Reload_TimeUntilAmmoIsSet, function()
			if IsValid(self) && self:CustomOnReload_Finish() != false then
				local ammoUsed = math.Clamp(self.Primary.ClipSize - self:Clip1(), 0, owner:GetAmmoCount(self:GetPrimaryAmmoType())) -- Amount of ammo that it will use (Take from the reserve)
				owner:RemoveAmmo(ammoUsed, self.Primary.Ammo)
				self:SetClip1(self:Clip1() + ammoUsed)
				self:CustomOnReload_Finish()
			end
		end)
		-- Handle animation
		owner:SetAnimation(PLAYER_RELOAD)
		local anim = VJ_PICK(self.AnimTbl_Reload)
		local animTime = VJ_GetSequenceDuration(owner:GetViewModel(), anim)
		self:SendWeaponAnim(anim)
		self.NextIdleT = CurTime() + animTime
		timer.Simple(animTime, function()
			if IsValid(self) then
				self.Reloading = false
			end
		end)
		return true
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:Deploy()
	if self.InitHasIdleAnimation == true then self.HasIdleAnimation = true end
	local owner = self:GetOwner()
	if owner:IsPlayer() then
		self:CustomOnDeploy()
		if self.HasDeploySound == true then self:EmitSound(VJ_PICK(self.DeploySound),50,math.random(90,100)) end
		
		local curTime = CurTime()
		local anim = VJ_PICK(self.AnimTbl_Deploy)
		local animTime = VJ_GetSequenceDuration(owner:GetViewModel(), anim)
		self:SendWeaponAnim(anim)
		self:SetNextPrimaryFire(curTime + animTime)
		self:SetNextSecondaryFire(curTime + animTime)
		self.NextIdleT = curTime + animTime
		self.NextReloadT = curTime + animTime
	end
	return true -- Or else the player won't be able to get the weapon!
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:Holster(newWep)
	//if CLIENT then return end
	if self == newWep or self.Reloading == true then return end
	self.HasIdleAnimation = false
	//self:SendWeaponAnim(ACT_VM_HOLSTER)
	return self:CustomOnHolster(newWep)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:EquipAmmo(ply)
	if ply:IsPlayer() then
		ply:GiveAmmo(self.Primary.ClipSize, self.Primary.Ammo)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:OnRemove()
	self:StopParticles()
	self:CustomOnRemove()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:GetWeaponCustomPosition(owner)
	if owner:LookupBone(self.WorldModel_CustomPositionBone) == nil then return nil end
	local pos, ang = owner:GetBonePosition(owner:LookupBone(self.WorldModel_CustomPositionBone))
	ang:RotateAroundAxis(ang:Right(), self.WorldModel_CustomPositionAngle.x)
	ang:RotateAroundAxis(ang:Up(), self.WorldModel_CustomPositionAngle.y)
	ang:RotateAroundAxis(ang:Forward(), self.WorldModel_CustomPositionAngle.z)
	pos = pos + self.WorldModel_CustomPositionOrigin.x * ang:Right()
	pos = pos + self.WorldModel_CustomPositionOrigin.y * ang:Forward()
	pos = pos + self.WorldModel_CustomPositionOrigin.z * ang:Up()
	return {pos = pos, ang = ang}
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:RunWorldModelThink()
	if self:GetNW2Bool("VJ_WorldModel_Invisible") != self.WorldModel_Invisible then
		self:SetNW2Bool("VJ_WorldModel_Invisible", self.WorldModel_Invisible)
	end
	
	local owner = self:GetOwner()
	if IsValid(owner) && self.WorldModel_UseCustomPosition == true then
		local wepPos = self:GetWeaponCustomPosition(owner)
		if wepPos == nil then return end
		self:SetPos(wepPos.pos)
		self:SetAngles(wepPos.ang)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:DecideBulletPosition()
	local owner = self:GetOwner()
	if !IsValid(owner) then return nil end
	if !owner:IsNPC() then return owner:GetShootPos() end
	
	-- Custom Position
	local customPos = self:CustomBulletSpawnPosition()
	if customPos != false then
		return customPos
	end
	
	-- Custom Attachment
	if self.NPC_BulletSpawnAttachment != "" && self:LookupAttachment(self.NPC_BulletSpawnAttachment) != 0 && self:LookupAttachment(self.NPC_BulletSpawnAttachment) != -1 then
		return self:GetAttachment(self:LookupAttachment(self.NPC_BulletSpawnAttachment)).Pos
	end
	
	-- Nothing found, try to find a common attachment
	local commonAttach = nil;
	local attachments = self:GetAttachments()
	for i = 1, #attachments do
		if attachments[i].name == "muzzle" then
			commonAttach = "muzzle"; break
		elseif attachments[i].name == "muzzleA" then
			commonAttach = "muzzleA"; break
		elseif attachments[i].name == "muzzle_flash" then
			commonAttach = "muzzle_flash"; break
		elseif attachments[i].name == "muzzle_flash1" then
			commonAttach = "muzzle_flash1"; break
		elseif attachments[i].name == "muzzle_flash2" then
			commonAttach = "muzzle_flash2"; break
		elseif attachments[i].name == "ValveBiped.muzzle" then
			commonAttach = "ValveBiped.muzzle"; break
		end
	end
	
	-- Not even a common attachment was found! Try to find a common bone!
	if !commonAttach then
		if owner:LookupBone("ValveBiped.Bip01_R_Hand") != nil then
			return owner:GetBonePosition(owner:LookupBone("ValveBiped.Bip01_R_Hand"))
		else -- Everything else has failed, post a warning and use eye position
			print("WARNING: "..self:GetClass().." doesn't have a proper attachment or bone for bullet spawn! Using EyePos!")
			return owner:EyePos()
		end
	-- Common attachment found!
	else
		return self:GetAttachment(self:LookupAttachment(commonAttach)).Pos
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
/*if SERVER then -- No longer needed, disabling sv_pvsskipanimation fixes it!
	util.AddNetworkString("vj_weapon_curbulletpos")
	
	net.Receive("vj_weapon_curbulletpos", function(len,pl)
		local vec = net.ReadVector()
		local ent = ents.GetByIndex(net.ReadInt(15))
		if IsValid(ent) then
			ent.worldupdate = ent.worldupdate or 0
			if ent.worldupdate <= CurTime() then
				ent:SetNW2Vector("VJ_CurBulletPos",vec)
				ent.worldupdate = CurTime() + 0.33
			end
		end
	end)
end*/
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	function SWEP:DrawWorldModel()
		if !IsValid(self) then return end
		
		local noDraw = false
		if !self:CustomOnDrawWorldModel() or self:GetNW2Bool("VJ_WorldModel_Invisible") == true or self.WorldModel_Invisible == true then noDraw = true end
		
		if self.WorldModel_NoShadow == true then
			self:DrawShadow(false)
		end
		
		-- No longer needed, disabling sv_pvsskipanimation fixes it!
		/*local pos = self:DecideBulletPosition()
		if pos != nil && IsValid(self:GetOwner()) then
			net.Start("vj_weapon_curbulletpos")
			net.WriteVector(pos)
			net.WriteInt(self:EntIndex(), 15)
			net.SendToServer()
		end*/
		
		if self.WorldModel_UseCustomPosition == true then
			local owner = self:GetOwner()
			if IsValid(owner) then
				if owner:IsPlayer() && owner:InVehicle() then return end
				local wepPos = self:GetWeaponCustomPosition(owner)
				if wepPos == nil then return end
				self:SetRenderOrigin(wepPos.pos)
				self:SetRenderAngles(wepPos.ang)
				self:FrameAdvance(FrameTime())
				self:SetupBones()
				if noDraw == false then self:DrawModel() end
			else
				self:SetRenderOrigin(nil)
				self:SetRenderAngles(nil)
				if noDraw == false then self:DrawModel() end
			end
		else
			if noDraw == false then self:DrawModel() end
		end
	end
end
--PATH lua/weapons/weapon_vj_crossbow/shared.lua:
return gluapack()()
--PATH lua/entities/aat.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/arc9_nade_base.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "Base Grenade"

ENT.Spawnable 			= false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/weapons/w_npcnade.mdl"
ENT.SmokeTrail = false
ENT.SmokeTrailMat = "trails/smoke"
ENT.SmokeTrailSize = 6
ENT.SmokeTrailTime = 0.5
ENT.Flare = false

ENT.PhysBoxSize = nil -- Vector(1, 1, 1)
ENT.SphereSize = nil -- number
ENT.PhysMat = "grenade"
ENT.TruePhys = false

ENT.Drag = true
ENT.Gravity = true
ENT.Mass = 5
ENT.DragCoefficient = 0.25
ENT.Boost = 0
ENT.Lift = 0

ENT.Damage = 150
ENT.Radius = 300
ENT.ImpactDamage = nil
ENT.ExplodeOnImpact = false
ENT.LifeTime = 3

ENT.Scorch = true
ENT.ExplosionEffect = "explosion"
ENT.BounceSound = nil
ENT.BounceSounds = nil -- {}

if SERVER then
    function ENT:Initialize()
        self:SetModel(self.Model)
        if self.PhysBoxSize then
            self:PhysicsInitBox(-self.PhysBoxSize, self.PhysBoxSize)
        elseif self.SphereSize then
            self:PhysicsInitSphere(self.SphereSize, self.PhysMat)
        else
            self:PhysicsInit(SOLID_VPHYSICS)
            self:SetSolid(SOLID_VPHYSICS)
        end

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:EnableDrag(self.Drag)
            phys:SetDragCoefficient(self.DragCoefficient)
            phys:EnableGravity(self.Gravity)
            phys:SetMass(self.Mass)
            phys:SetBuoyancyRatio(0.4)
        end

        if self.SmokeTrail then
            util.SpriteTrail(self, 0, Color( 255 , 255 , 255 ), false, self.SmokeTrailSize, 0, self.SmokeTrailTime, 1 / self.SmokeTrailSize * 0.5, self.SmokeTrailMat)
        end

        self.SpawnTime = CurTime()
    end


    function ENT:Think()
        if self.Defused then return end

        if self.LifeTime > 0 and self.SpawnTime + self.LifeTime < CurTime() then
            self:Detonate()
            return
        end
    end

    function ENT:PhysicsCollide(data)
        if data.Speed > 100 then
            local tgt = data.HitEntity

            if IsValid(tgt) and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)

                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity

                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end

            if data.DeltaTime > 0.1 then
                if self.BounceSounds then
                    self:EmitSound(self.BounceSounds[math.random(1, #self.BounceSounds)], 75)
                else
                    self:EmitSound(self.BounceSound, 75)
                end
            end
        end

        if self.ExplodeOnImpact then
            self.HitPos = data.HitPos
            self.HitVelocity = data.OurOldVelocity
            self:Detonate()
        end
    end

    function ENT:OnRemove()
    end


    function ENT:Detonate()
        if not self:IsValid() then return end
        if self.Defused then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() > 0 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            util.Effect( self.ExplosionEffect, effectdata)
        end

        util.BlastDamage(self, IsValid(self:GetOwner()) and self:GetOwner() or self, self:GetPos(), self.Radius, self.DamageOverride or self.Damage)

        if SERVER then
            local dir = self.HitVelocity or self:GetVelocity()

            if self.Boost <= 0 then
                dir = Vector(0, 0, -1)
            end

            self:FireBullets({
                Attacker = self,
                Damage = 0,
                Tracer = 0,
                Distance = 256,
                Dir = dir,
                Src = self:GetPos(),
                Callback = function(att, tr, dmg)
                    if self.Scorch then
                        util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
                    end
                end
            })
        end
        self.Defused = true

        SafeRemoveEntityDelayed(self, self.SmokeTrailTime)
        self:SetRenderMode(RENDERMODE_NONE)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end
else
    function ENT:Draw()
        self:DrawModel()
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/arc9_smoke_cloud.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_357_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Magnum Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/magnum_ammo_closed.mdl"

ENT.AmmoType = "357"
ENT.AmmoCount = 60
ENT.Scale = 1.5

ENT.DetonationDamage = 50
ENT.DetonationRadius = 128
ENT.DetonationSound = "weapons/357_fire2.wav"
--PATH lua/entities/arccw_ammo_buckshot.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_smg1_grenade_large.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/arccw_nade_launcher17m/shared.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_ubgl_nade.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_capital_ship_base_mk2/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_capital_ship_base_mk2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Aura's Big Ship Base"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "lvs_base" )

ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Editable = true

ENT.AutomaticFrameAdvance 	= true
ENT.RenderGroup 			= RENDERGROUP_BOTH 
ENT.Editable 				= true

ENT.Model 					= ""
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.LVS_CAPITAL_SHIP 		= true

ENT.HealthVal 				= 200000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SHOULDSPAWN 			= false
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = 0}
ENT.ENABLETURRETS 			= true
ENT.SHOOTEFFECT 			= "lvs_tracer_green"

ENT.SEARCHSIZE				= 10000
ENT.LOSE_DIST 				= 11000

ENT.PRIMARYDAMAGE			= 100
ENT.SHOOTDELAY1 			= .8
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 5
ENT.EXPLOSION_SCALE_MAX		= 10


ENT.TURRETS = {}
ENT.TURRETANGLES = {}
--[[

	These two tables are used to add custom ships, it takes a small amount of coding knowledge to configure these, but this applies to all ships so you only have to do it in here
	The other things though like health and all other attributes can be edited per ship, but these are a fairly easy format to follow
	Example:
	[1] = {class = "ship_class_name", name = "Ship Name"}
	Class you can find in game by right clicking on the ship in the Q menu, name you can decide, but I would recommend you set it to the name of the ship ex: "ARC-170 Fighter"

	Also, make sure if you have more than one the thing in this [] is incrementing with it, so the second ship is [2] = ... third one is [3] = ... and so on

]]--

ENT.BOMBS = {}

ENT.shipList = {}

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Driver" )
	self:NetworkVar( "Entity",1, "DriverSeat" )

	self:NetworkVar("Float",0, "HP", { KeyName = "Health", Edit = { type = "Float", order = 2, min = 0, max = self.HealthVal } })
	self:NetworkVar("Float",1, "Shield" )
	self:NetworkVar("Float",2, "NWHeat" )

	self:NetworkVar("Int",0, "AITEAM", { KeyName = "aiteam", Edit = { type = "Int", order = 2,min = 0, max = 2, category = "AI"} } )
	self:NetworkVar("Int",1, "SpawnDelay", { KeyName = "Spawn Delay (Seconds)", Edit = { type = "Int", order = 3, min = 1, max = 100 } })
	self:NetworkVar("Int",2, "SpawnNumber", 	{ KeyName = "Spawn Number", Edit = { type = "Int", order = 4, min = 0, max = 100 } })
	self:NetworkVar("Int",3, "SelectedWeapon" )
	self:NetworkVar("Int",4, "NWAmmo" )

	self:NetworkVar( "Bool",0, "ShouldSpawn",	{ KeyName = "Spawning Enabled",	Edit = { type = "Boolean",	order = 1} } )

	self:NetworkVar( "Bool",1, "EnableTurrets",	{ KeyName = "Enable Turrets",	Edit = { type = "Boolean",	order = 1, category = "AI"} } )

	self:NetworkVar( "Bool",2, "InfiniteShips",	{ KeyName = "Infinte Ships",	Edit = { type = "Boolean",	order = 2} })

	self:NetworkVar( "Bool",4, "EngineActive" )
	self:NetworkVar( "Bool",5, "Active" )
	self:NetworkVar( "Bool",6, "AI")
	self:NetworkVar( "Bool",7, "lvsLockedStatus" )
	self:NetworkVar( "Bool",8, "lvsReady" )

	self:SetInfiniteShips(false)
	self:SetDriver(nil)
	self:SetAI(true)
	self:SetAITEAM(self:GetNWInt("SelfAITeam",2))
	self:SetAITEAM(self.AITEAM)
	self:SetEnableTurrets(self.ENABLETURRETS)

	self:SetSpawnDelay(self.SPAWNDELAY)
	self:SetSpawnNumber(self.SPAWNNUMBER)
	self:SetHP(self.HealthVal)
	self:SetShouldSpawn(self.SHOULDSPAWN)

	local count = 6
	for k,v in pairs(Aura_LVS_Capital_Ships_Lists[self:GetClass()]) do
		count = count + 1
		self:NetworkVar( "Bool", count, k, { KeyName = k,	Edit = { type = "Boolean",	order = count, category = "Ships:"} } )
	end


	if SERVER then
		self:NetworkVarNotify( "AITEAM", self.SetNewAITeam )
		
		self:NetworkVarNotify( "HP", self.SetHealthValue )
		self:NetworkVarNotify( "SpawnDelay", self.ChangeSpawnDelay)
		self:NetworkVarNotify( "SpawnNumber", self.ChangeSpawnNumber )
		self:NetworkVarNotify( "ShouldSpawn", self.ChangeShouldSpawn)

		for k,v in pairs(Aura_LVS_Capital_Ships_Lists[self:GetClass()]) do
			self:NetworkVarNotify(k, self.ToggleShipWithClass)
		end
	end
end

function ENT:ChangeSkin(name, old, new)
	self:SetModel(self.skinList[new])
end

function ENT:ToggleShipWithClass(name, old, new)
	local class = Aura_LVS_Capital_Ships_Lists[self:GetClass()][name]
	if (new) then
		table.insert(self.shipList,class)
	else
		table.RemoveByValue(self.shipList,class)
	end
end

function ENT:GetMaxHP()
	return self.MaxHealth
end

function ENT:SetNewAITeam(name, old, new)
	self:SetNWInt("SelfAITeam",new)
end

function ENT:ChangeSpawnDelay(name, old, new)
	self.SPAWNDELAY = new
end

function ENT:ChangeSpawnNumber(name, old, new)
	self.SPAWNNUMBER = new
end

function ENT:SetHealthValue(name, old, new)
	self:SetHealth(new)
	if (new == 0) then
		self:Die(true)
	end
end

function ENT:ChangeShouldSpawn(name, old, new)
	self.SHOULDSPAWN = new
end

function ENT:GetlfsLockedStatus()
end
--PATH lua/entities/aura_lvs_captor/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cargo/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo4/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo8/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_csi_1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Defense Satellite"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/fyu/cedi/misc/v4/satellite.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 10000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 1
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(0,0,332),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_satellite_csi_2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Defense Platform"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/cod_iw/misc/air_thor/platform.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 20000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 2
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(72,0,-25),
	[2] = Vector(-72,0,-25),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(-90,180,0),
	[2] = Angle(-90,0,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
}
--PATH gamemodes/starwarsrp/entities/entities/darkrp_billboard/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/darkrp_cheque/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/darkrp_laws/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/darkrp_laws/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "DarkRP Laws"
ENT.Instructions = "Use /addlaws to add a custom law, /removelaw <num> to remove a law."
ENT.Author = "Drakehawke"

ENT.Spawnable = false

local plyMeta = FindMetaTable("Player")
DarkRP.declareChatCommand{
    command = "addlaw",
    description = "Add a law to the laws board.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "removelaw",
    description = "Remove a law from the laws board.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "placelaws",
    description = "Place a laws board.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "resetlaws",
    description = "Reset all laws.",
    delay = 1.5
}

DarkRP.getLaws = DarkRP.stub{
    name = "getLaws",
    description = "Get the table of all current laws.",
    parameters = {
    },
    returns = {
        {
            name = "laws",
            description = "A table of all current laws.",
            type = "table"
        }
    },
    metatable = DarkRP,
    realm = "Shared"
}

DarkRP.resetLaws = DarkRP.stub{
    name = "resetLaws",
    description = "Reset to default laws.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP,
    realm = "Server"
}

DarkRP.hookStub{
    name = "addLaw",
    description = "Called when a law is added.",
    parameters = {
        {
            name = "index",
            description = "Index of the law",
            type = "number"
        },
        {
            name = "law",
            description = "Law string",
            type = "string"
        },
        {
            name = "player",
            description = "The player who added the law",
            type = "Player"
        }
    },
    returns = {
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "removeLaw",
    description = "Called when a law is removed.",
    parameters = {
        {
            name = "index",
            description = "Index of law",
            type = "number"
        },
        {
            name = "law",
            description = "Law string",
            type = "string"
        },
        {
            name = "player",
            description = "The player who removed the law",
            type = "Player"
        }
    },
    returns = {
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "resetLaws",
    description = "Called when laws are reset.",
    parameters = {
        {
            name = "player",
            description = "The player resetting the laws.",
            type = "Player"
        }
    },
    returns = {
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "canEditLaws",
    description = "Whether someone can edit laws.",
    parameters = {
        {
            name = "player",
            description = "The player trying to edit laws.",
            type = "Player"
        },
        {
            name = "action",
            description = "How the player is trying to edit laws.",
            type = "string"
        },
        {
            name = "arguments",
            description = "Arguments related to editing laws.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canEdit",
            description = "A yes or no as to whether the player can edit the law.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't edit the law.",
            type = "string"
        }
    },
    realm = "Server"
}

--PATH lua/entities/decs_loader/cl_init.lua:
return gluapack()()
--PATH lua/entities/droid_tri.lua:
return gluapack()()
--PATH lua/entities/e60r_rocket2/shared.lua:
 ENT.Type 			= "anim"  
 ENT.PrintName			= "High Explosive Anti-Tank RPG"  
 ENT.Author			= ""  
 ENT.Contact			= ""  
 ENT.Purpose			= ""  
 ENT.Instructions			= ""  
 
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


--PATH lua/entities/ent_baby_explosive2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.Author = "LordiAnders"
ENT.Spawnable = false
ENT.AdminSpawnable = false
--PATH addons/[misc] szachy/lua/entities/ent_draughts_board.lua:

if SERVER then
   AddCSLuaFile()
end

ENT.Type = "anim"
ENT.Model = Model("models/weapons/w_slam.mdl")
ENT.Base = "ent_chess_board"
ENT.Models = {
	["board"] = Model("models/props_phx/games/chess/board.mdl"),
	["table"] = Model("models/props/de_tides/restaurant_table.mdl"),
	["hl2table"] = Model( "models/props_c17/furnituretable001a.mdl" ),
	
	["dama"] = Model("models/props_phx/games/chess/white_pawn.mdl"),
	
	["WhiteMan"] = Model("models/props_phx/games/chess/white_dama.mdl"),	["BlackMan"] = Model("models/props_phx/games/chess/black_dama.mdl"),
	["WhiteKing"] = Model("models/props_phx/games/chess/white_dama.mdl"),	["BlackKing"] = Model("models/props_phx/games/chess/black_dama.mdl"),
}
ENT.Characters = { -- Notepad's being weird and not showing these characters. If you can't see them, they'll still show up in-game.
	["WhiteMan"] = Model("⛀"),		["BlackMan"] = Model("⛂"),
	["WhiteKing"] = Model("⛁"),		["BlackKing"] = Model("⛃"),
}
ENT.DrawDouble = {
	["King"] = true,
}

ENT.PrintName		= "Draughts/Checkers"
ENT.Author			= "my_hat_stinks"
ENT.Information		= "A draughts (checkers) board"
ENT.Category		= "Game boards"

ENT.Game = "Draughts"
ENT.Spawnable = true
ENT.AdminOnly = true
ENT.AdminSpawnable = true

--Status
local CHESS_INACTIVE = 0
local CHESS_WHITEMOVE = 1
local CHESS_BLACKMOVE = 2
local CHESS_WHITEPROMO = 3	local CHESS_WHITEJUMP = 3
local CHESS_BLACKPROMO = 4	local CHESS_BLACKJUMP = 4
local CHESS_WAGER = 5

--Captured piece squares
local CHESS_WCAP1 = 10
local CHESS_WCAP2 = 11
local CHESS_BCAP1 = 12
local CHESS_BCAP2 = 13

-- Draw Offer
local PLAYER_NONE  = 0 -- Nobody offering to draw
local PLAYER_WHITE = 1 -- White offering to draw
local PLAYER_BLACK = 2 -- Black offering to draw

local NumToLetter = {"a", "b", "c", "d", "e", "f", "g", "h", ["a"]=1, ["b"]=2, ["c"]=3, ["d"]=4, ["e"]=5, ["f"]=6, ["g"]=7, ["h"]=8} --Used extensively for conversions

ENT.StartState = CHESS_BLACKMOVE

function ENT:SetupDataTables()
--	self:NetworkVar( "Int", 0, "BlackPassant" )
--	self:NetworkVar( "Int", 1, "WhitePassant" )
	
	self:NetworkVar( "Int", 2, "ChessState" )
	self:NetworkVar( "Bool", 0, "Playing" )
	self:NetworkVar( "Int", 3, "DrawOffer" )
	
	self:NetworkVar( "Float", 0, "WhiteWager" )
	self:NetworkVar( "Float", 1, "BlackWager" )
	
	self:NetworkVar( "Entity", 0, "WhitePlayer" )
	self:NetworkVar( "Entity", 1, "BlackPlayer" )
	self:NetworkVar( "Entity", 2, "TableEnt" )
	
--	self:NetworkVar( "Int", 3, "MoveCount" )
--	self:NetworkVar( "Bool", 1, "Repetition" )
	
	self:NetworkVar( "Bool", 2, "PSWager" )
	
	self:NetworkVar( "Float", 2, "WhiteTime" )
	self:NetworkVar( "Float", 3, "BlackTime" )
	
	--Draughts vars
	self:NetworkVar( "Bool", 1, "JumpMove" )
	self:NetworkVar( "Int", 0, "JumpLet" )
	self:NetworkVar( "Int", 1, "JumpNum" )
end

function ENT:Initialize()
	self.ChessDerived = true
	self.IsDraughts = true
	
	return self.BaseClass.Initialize( self )
end

function ENT:GetManMoves( tbl, GridLet, GridNum, IsWhite )
	local CapMove = false
	
	--Forward Right
	local TargetRow = GridNum+ (IsWhite and 1 or (-1))
	local TargetColumn = NumToLetter[GridLet]+1
	if TargetRow<=8 and TargetRow>=1 and TargetColumn<=8 and TargetColumn>=1 then
		local target = self:GetSquare( NumToLetter[TargetColumn], TargetRow )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then --Enemy piece
				local CapRow = TargetRow+ (IsWhite and 1 or (-1))
				local CapCol = TargetColumn+1
				
				if CapRow<=8 and CapRow>=1 and CapCol<=8 and CapCol>=1 then --In range
					local target = self:GetSquare( NumToLetter[CapCol], CapRow )
					if not target then --Empty space
						tbl[NumToLetter[CapCol]][CapRow] = {"CAPTURE", NumToLetter[TargetColumn], TargetRow} --Capture move
						CapMove = true --Flag as capture move
					end
				end
			end
		else
			tbl[NumToLetter[TargetColumn]][TargetRow] = true --Standard valid move
		end
	end
	--Forward Left
	local TargetRow = GridNum+ (IsWhite and 1 or (-1))
	local TargetColumn = NumToLetter[GridLet]-1
	if TargetRow<=8 and TargetRow>=1 and TargetColumn<=8 and TargetColumn>=1 then
		local target = self:GetSquare( NumToLetter[TargetColumn], TargetRow )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then
				local CapRow = TargetRow+ (IsWhite and 1 or (-1))
				local CapCol = TargetColumn-1
				
				if CapRow<=8 and CapRow>=1 and CapCol<=8 and CapCol>=1 then
					local target = self:GetSquare( NumToLetter[CapCol], CapRow )
					if not target then
						tbl[NumToLetter[CapCol]][CapRow] = {"CAPTURE", NumToLetter[TargetColumn], TargetRow}
						CapMove = true
					end
				end
			end
		else
			tbl[NumToLetter[TargetColumn]][TargetRow] = true --Standard valid move
		end
	end
	
	return CapMove
end
function ENT:GetKingMoves( tbl, GridLet, GridNum, IsWhite )
	local CapMove = self:GetManMoves( tbl, GridLet, GridNum, IsWhite ) --Forward moves
	
	--Back Right
	local TargetRow = GridNum+ (IsWhite and (-1) or (1))
	local TargetColumn = NumToLetter[GridLet]+1
	if TargetRow<=8 and TargetRow>=1 and TargetColumn<=8 and TargetColumn>=1 then
		local target = self:GetSquare( NumToLetter[TargetColumn], TargetRow )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then
				local CapRow = TargetRow+ (IsWhite and (-1) or (1))
				local CapCol = TargetColumn+1
				
				if CapRow<=8 and CapRow>=1 and CapCol<=8 and CapCol>=1 then
					local target = self:GetSquare( NumToLetter[CapCol], CapRow )
					if not target then
						tbl[NumToLetter[CapCol]][CapRow] = {"CAPTURE", NumToLetter[TargetColumn], TargetRow}
						CapMove = true
					end
				end
			end
		else
			tbl[NumToLetter[TargetColumn]][TargetRow] = true --Standard valid move
		end
	end
	--Back Left
	local TargetRow = GridNum+ (IsWhite and (-1) or (1))
	local TargetColumn = NumToLetter[GridLet]-1
	if TargetRow<=8 and TargetRow>=1 and TargetColumn<=8 and TargetColumn>=1 then
		local target = self:GetSquare( NumToLetter[TargetColumn], TargetRow )
		if target then
			if ((self:SquareTeam(target)=="White")~=IsWhite) then
				local CapRow = TargetRow+ (IsWhite and (-1) or (1))
				local CapCol = TargetColumn-1
				
				if CapRow<=8 and CapRow>=1 and CapCol<=8 and CapCol>=1 then
					local target = self:GetSquare( NumToLetter[CapCol], CapRow )
					if not target then
						tbl[NumToLetter[CapCol]][CapRow] = {"CAPTURE", NumToLetter[TargetColumn], TargetRow}
						CapMove = true
					end
				end
			end
		else
			tbl[NumToLetter[TargetColumn]][TargetRow] = true --Standard valid move
		end
	end
	
	return CapMove
end
function ENT:GetMove( GridLet, GridNum, IgnoreCap )
	if not (GridLet and GridNum) then return {} end
	if not NumToLetter[GridLet] then return {} end
	if NumToLetter[GridLet]<1 or NumToLetter[GridLet]>8 then return {} end
	if GridNum<1 or GridNum>8 then return {} end
	
	local square = self:GetSquare( GridLet, GridNum )
	if not square then return {} end
	
	local class = square.Class or (IsValid(square.Ent) and square.Ent:GetRole())
	if not class then return {} end
	
	if self:GetJumpMove() and self:GetJumpLet()~=0 and self:GetJumpNum()~=0 and (NumToLetter[GridLet]~=self:GetJumpLet() or GridNum~=self:GetJumpNum()) then return {} end
	
	local IsWhite = self:SquareTeam(square)=="White"
	local Moved = self:SquareMoved(square)
	
	local CanJump = IgnoreCap or self:CanCapture( IsWhite )
	local tbl = { ["a"] = {}, ["b"] = {}, ["c"] = {}, ["d"] = {}, ["e"] = {}, ["f"] = {}, ["g"] = {}, ["h"] = {} }
	if class=="King" then
		self:GetKingMoves( tbl, GridLet, GridNum, IsWhite )
	else
		self:GetManMoves( tbl, GridLet, GridNum, IsWhite )
	end
	
	if CanJump then
		for CheckLet,File in pairs(tbl) do
			for CheckNum,v in pairs(File) do
				if v==true then
					tbl[CheckLet][CheckNum] = nil --We can capture, but this isn't a capture move
				end
			end
		end
	end
	return tbl
end

function ENT:ResetBoard()
	if SERVER then
		self:SetDrawOffer( PLAYER_NONE )
		
		self:SetWhiteWager( -1 )
		self:SetBlackWager( -1 )
		
		self:SetWhiteTime( 600 )
		self:SetBlackTime( 600 )
		
		self:SetJumpMove( false )
		self:SetJumpLet( 0 )
		self:SetJumpNum( 0 )
	end
	self:RefreshSquares()
	
	if self.Pieces then
		for _,File in pairs( self.Pieces ) do
			for _,Square in pairs(File) do
				if IsValid(Square.Ent) then Square.Ent:SetGridNum(-1) Square.Ent:Remove() end
			end
		end
	end
	self.Pieces = {
		["a"] = {
			[1] = {Team="White",Class="Man",Moved=false}, [3] = {Team="White",Class="Man",Moved=false}, [7] = {Team="Black",Class="Man",Moved=false},
		},
		["b"] = {
			[2] = {Team="White",Class="Man",Moved=false}, [6] = {Team="Black",Class="Man",Moved=false}, [8] = {Team="Black",Class="Man",Moved=false},
		},
		["c"] = {
			[1] = {Team="White",Class="Man",Moved=false}, [3] = {Team="White",Class="Man",Moved=false}, [7] = {Team="Black",Class="Man",Moved=false},
		},
		["d"] = {
			[2] = {Team="White",Class="Man",Moved=false}, [6] = {Team="Black",Class="Man",Moved=false}, [8] = {Team="Black",Class="Man",Moved=false},
		},
		["e"] = {
			[1] = {Team="White",Class="Man",Moved=false}, [3] = {Team="White",Class="Man",Moved=false}, [7] = {Team="Black",Class="Man",Moved=false},
		},
		["f"] = {
			[2] = {Team="White",Class="Man",Moved=false}, [6] = {Team="Black",Class="Man",Moved=false}, [8] = {Team="Black",Class="Man",Moved=false},
		},
		["g"] = {
			[1] = {Team="White",Class="Man",Moved=false}, [3] = {Team="White",Class="Man",Moved=false}, [7] = {Team="Black",Class="Man",Moved=false},
		},
		["h"] = {
			[2] = {Team="White",Class="Man",Moved=false}, [6] = {Team="Black",Class="Man",Moved=false}, [8] = {Team="Black",Class="Man",Moved=false},
		},
		[CHESS_WCAP1] = {}, [CHESS_WCAP2] = {}, [CHESS_BCAP1] = {}, [CHESS_BCAP2] = {},
	}
	self:Update()
end

function ENT:CanCapture( White )
	for Let,column in pairs( self.Pieces ) do
		for Num,square in pairs( column ) do
			if square.Team==(White and "White" or "Black") then
				local moves = self:GetMove( Let, Num, true )
				for _,column in pairs( moves ) do
					for _,move in pairs( column ) do
						if type(move)=="table" and move[1]=="CAPTURE" then return true end
					end
				end
			end
		end
	end
	
	return false
end
function ENT:CanMove( White )
	for Let,column in pairs( self.Pieces ) do
		for Num,square in pairs( column ) do
			if square.Team==(White and "White" or "Black") then
				local moves = self:GetMove( Let, Num )
				for _,column in pairs( moves ) do
					for _,move in pairs( column ) do
						if move then return true end
					end
				end
			end
		end
	end
	
	return false
end

function ENT:NoMaterialCheck()
	local BlackMat = {}
	local WhiteMat = {}
	
	for GridLet,File in pairs(self.Pieces) do
		if GridLet==CHESS_WCAP1 or GridLet==CHESS_WCAP2 or GridLet==CHESS_BCAP1 or GridLet==CHESS_BCAP2 then continue end
		for GridNum,square in pairs(File) do
			if square then
				local IsWhite = self:SquareTeam(square)=="White"
				
				if IsWhite then
					table.insert( WhiteMat, {Square=square, Class=Class, GridLet=GridLet, GridNum=GridNum} )
				else
					table.insert( BlackMat, {square=square, Class=Class, GridLet=GridLet, GridNum=GridNum} )
				end
			end
		end
	end
	
	if (#BlackMat+#WhiteMat)==0 then self:EndGame() return false end
	if #WhiteMat==0 then self:EndGame("Black") return false end
	if #BlackMat==0 then self:EndGame("White") return false end
	
	return true
end
function ENT:EndGame( winner, NoMsg )
	self:SetChessState( CHESS_INACTIVE )
	self:SetPlaying( false )
	
	local White = self:GetPlayer( "White" )
	local Black = self:GetPlayer( "Black" )
	local WhiteName = IsValid(White) and White:Nick() or "[Anonymous White]"
	local BlackName = IsValid(Black) and Black:Nick() or "[Anonymous Black]"
	if not NoMsg then
		net.Start( "Chess GameOver" )
			if winner=="White" then
				net.WriteTable( {" ", Color(255,255,255), WhiteName, Color(150,255,150), " has won against ", Color(100,100,100), BlackName, Color(150,255,150), "!"} )
			else
				net.WriteTable( {" ", Color(100,100,100), BlackName, Color(150,255,150), " has won against ", Color(255,255,255), WhiteName, Color(150,255,150), "!"} )
			end
			net.WriteString( "icon16/medal_gold_2.png" )
		net.Broadcast()
	end
	
	timer.Simple( 0.5, function()
		if not IsValid(self) then return end
		if IsValid(Black) and Black:GetVehicle()==self.BlackSeat then Black:ExitVehicle() end
		if IsValid(White) and White:GetVehicle()==self.WhiteSeat then White:ExitVehicle() end
	end)
	
	local winnings = (self.WagerValue or 0)*2
	if IsValid( White ) then
		if winner=="White" then
			if IsValid(Black) then White:DraughtsWin( Black ) end
			if self.WagerValue then
				if self:GetPSWager() then
					White:PS_GivePoints( winnings )
				else
					if White.addMoney then White:addMoney( winnings ) else White:SetDarkRPVar( "money", (White:getDarkRPVar( "money" ) or 0) + winnings ) end
				end
			end
		elseif winner~="Black" then
			if IsValid(Black) and winner~="Error" then White:DraughtsDraw( Black ) end
			if self.WagerValue then
				if self:GetPSWager() then
					White:PS_GivePoints( self.WagerValue )
				else
					if White.addMoney then White:addMoney( self.WagerValue ) else White:SetDarkRPVar( "money", (White:getDarkRPVar( "money" ) or 0) + self.WagerValue ) end
				end
			end
		end
	end
	if IsValid( Black ) then
		if winner=="Black" then
			if IsValid(White) then Black:DraughtsWin( White ) end
			if self.WagerValue then
				if self:GetPSWager() then
					Black:PS_GivePoints( winnings )
				else
					if Black.addMoney then Black:addMoney( winnings ) else Black:SetDarkRPVar( "money", (Black:getDarkRPVar( "money" ) or 0) + winnings ) end
				end
			end
		elseif winner~="White" then
			if self.WagerValue then
				if self:GetPSWager() then
					White:PS_GivePoints( self.WagerValue )
				else
					if White.addMoney then White:addMoney( self.WagerValue ) else White:SetDarkRPVar( "money", (White:getDarkRPVar( "money" ) or 0) + self.WagerValue ) end
				end
			end
		end
	end
end
function ENT:DoCapture( square, EndLet, EndNum )
	if not square then return end
	
	local class = square.Class
	
	local made = false
	local CapLet,CapNum
	if square.Team=="White" then --Black captured
		for i=CHESS_BCAP1,CHESS_BCAP2 do
			for n=1,8 do
				local CapSq = self:GetSquare( i, n )
				if not CapSq then
					self.Pieces[i][n] = {Team="White", Class=class, Moved=false}
					CapSq = self.Pieces[i][n]
					
					made = true
					CapLet,CapNum = i,n
					break
				end
			end
			if made then break end
		end
	else
		for i=CHESS_WCAP1,CHESS_WCAP2 do
			for n=1,8 do
				local CapSq = self:GetSquare( i, n )
				if not CapSq then
					self.Pieces[i][n] = {Team="Black", Class=class, Moved=false}
					CapSq = self.Pieces[i][n]
					
					made = true
					CapLet,CapNum = i,n
					break
				end
			end
			if made then break end
		end
	end
	
	return {From={EndLet,EndNum}, To={CapLet,CapNum}}
end
function ENT:DoMove( StartLet, StartNum, EndLet, EndNum )
	if CLIENT then return end
	if not (StartLet and EndLet and StartNum and EndNum) then return end
	if (StartLet==EndLet) and (StartNum==EndNum) then return end
	
	local Start = self:GetSquare( StartLet, StartNum )
	if not Start then return end
	
	local Moves = self:GetMove( StartLet, StartNum )
	if not Moves[EndLet][EndNum] then return end
	local Move = Moves[EndLet][EndNum]
	
	local CapMove
	if type(Move)=="table" then
		if Move[1]=="CAPTURE" then
			local CapLet, CapNum = Move[2], Move[3]
			local square = self:GetSquare( CapLet, CapNum )
			if CapLet and CapNum then
				CapMove = self:DoCapture( square, CapLet, CapNum )
				self.Pieces[CapLet][CapNum] = nil
			end
		end
	end
	
	local End = self:GetSquare( EndLet, EndNum )
	if not End then
		self.Pieces[EndLet] = self.Pieces[EndLet] or {}
		self.Pieces[EndLet][EndNum] = self.Pieces[EndLet][EndNum] or {}
		End = self.Pieces[EndLet][EndNum]
	end
	
	End.Team=Start.Team
	End.Class=Start.Class
	End.Moved=true
	
	self.Pieces[StartLet][StartNum] = nil
	
	local ply = self:GetPlayer( End.Team )
	if (EndNum==1 or EndNum==8) and End.Class=="Man" then --End of the board, promote
		End.Class = "King"
//		self:SetChessState( End.Team=="White" and CHESS_BLACKMOVE or CHESS_WHITEMOVE )
//		
//		self:SetJumpMove( false )
//		self:SetJumpLet( 0 )
//		self:SetJumpNum( 0 )
	end
	if type(Move)=="table" and Move[1]=="CAPTURE" then
		self:SetJumpMove(false)
		if self:CanCapture( End.Team=="White" ) then
			local GetMoves = self:GetMove(EndLet, EndNum)
			local Cap = false
			for _,column in pairs( GetMoves ) do
				for _,move in pairs(column) do
					if move and move~=true then
						Cap=true
					end
				end
			end
			if Cap then
				self:SetJumpMove( true )
				self:SetJumpLet( NumToLetter[EndLet] )
				self:SetJumpNum( EndNum )
			else
				self:SetChessState( End.Team=="White" and CHESS_BLACKMOVE or CHESS_WHITEMOVE )
				
				self:SetJumpMove( false )
				self:SetJumpLet( 0 )
				self:SetJumpNum( 0 )
			end
		else
			self:SetChessState( End.Team=="White" and CHESS_BLACKMOVE or CHESS_WHITEMOVE )
			
			self:SetJumpMove( false )
			self:SetJumpLet( 0 )
			self:SetJumpNum( 0 )
		end
	else --Standard move, other player's turn
		self:SetChessState( End.Team=="White" and CHESS_BLACKMOVE or CHESS_WHITEMOVE )
		
		self:SetJumpMove( false )
		self:SetJumpLet( 0 )
		self:SetJumpNum( 0 )
	end
	
	local move = {From={StartLet,StartNum},To={EndLet,EndNum}}
	self:Update( move, CapMove )
	
	self:NoMaterialCheck()
	
	if self:GetChessState()==CHESS_BLACKMOVE and not self:CanMove( false ) then self:EndGame( "White" ) end
	if self:GetChessState()==CHESS_WHITEMOVE and not self:CanMove( true ) then self:EndGame( "Black" ) end
	
	return move
end

function ENT:GetElo( ply )
	return IsValid(ply) and " ("..ply:GetDraughtsElo()..")" or ""
end

if CLIENT then
	local PanelCol = {
		Main = Color(0,0,0,200), ToMove = Color(200,200,200,20), Text = Color(180,180,180),
		White = Color(255,255,255), Black = Color(20,20,20,255),
	}
	local StateToString = {[CHESS_INACTIVE] = "Waiting", [CHESS_WHITEMOVE] = "White", [CHESS_BLACKMOVE] = "Black", [CHESS_WHITEPROMO] = "White (jumping)", [CHESS_BLACKPROMO] = "Black (jumping)", [CHESS_WAGER] = "Wagers"}
	function ENT:CreateChessPanel()
		self:EndSpectating()
		
		local frame = vgui.Create( "DFrame" )
		frame:SetSize(400,115)
		frame:SetPos( (ScrW()/2)-100, ScrH()-150 )
		--frame:SetDraggable( false )
		frame:SetTitle( "" )
		frame:ShowCloseButton( false )
		frame:SetDeleteOnClose( true )
		frame.Paint = function( s,w,h )
			if not IsValid(self) then
				s:Remove()
				gui.EnableScreenClicker( false )
				
				return
			end
			
			draw.RoundedBox( 8, 0, 0, w, h, PanelCol.Main )
		end
		frame:DockMargin( 0,0,0,0 )
		frame:DockPadding( 5,6,5,5 )
		
		local TimePnl = vgui.Create( "DPanel", frame )
		TimePnl:Dock( RIGHT )
		TimePnl:SetWide( 100 )
		TimePnl:DockMargin( 2,2,2,2 )
		TimePnl.Paint = function(s,w,h)
			if not IsValid(self) then return end
			
			draw.RoundedBox( 16, 0, 0, w, (h/2)-1, PanelCol.ToMove )
			draw.RoundedBox( 16, 0, (h/2)+1, w, (h/2)-1, PanelCol.ToMove )
			
			draw.SimpleText( string.FormattedTime( math.Round(self:GetWhiteTime() or 300,1), "%02i:%02i" ), "ChessText", w/2, h/4, PanelCol.White, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			draw.SimpleText( string.FormattedTime( math.Round(self:GetBlackTime() or 300,1), "%02i:%02i" ), "ChessText", w/2, (h/4)+(h/2), PanelCol.Black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		
		local ButtonPanel = vgui.Create( "DPanel", frame )
		ButtonPanel:SetSize( 100, 20 )
		ButtonPanel:Dock( LEFT )
		ButtonPanel.Paint = function() end
		
		local ToMove = vgui.Create( "DPanel", frame )
		ToMove:SetSize(200,80)
		ToMove:Dock( FILL )
		ToMove.Paint = function( s,w,h )
			draw.RoundedBox( 4, 0, 0, w, h, PanelCol.ToMove )
			draw.SimpleText( "To move", "ChessTextSmall", 5, 0, PanelCol.Text )
			local state = IsValid(self) and self:GetChessState()
			if not (IsValid( self ) and state) then
				draw.SimpleText( "[N/A]", "ChessTextSmall", w/2, h/2, PanelCol.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				local str = (StateToString[state] or "N/A")..( (self:GetPlaying() and self:GetJumpMove() and " (jump)") or "" )
				local col = ((state==CHESS_WHITEMOVE or state==CHESS_WHITEPROMO) and PanelCol.White) or ((state==CHESS_BLACKMOVE or state==CHESS_BLACKPROMO) and PanelCol.Black) or PanelCol.Text
				draw.SimpleText( str, "ChessTextLarge", w/2, h/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end
		
		frame.OfferDraw = vgui.Create( "DButton", ButtonPanel)
		frame.OfferDraw:SetSize(94,35)
		frame.OfferDraw:Dock( TOP )
		frame.OfferDraw:SetText( "Offer Draw" )
		frame.OfferDraw.DoClick = function( s )
			if (IsValid(self)) and not (self:GetPlaying()) then
				chat.AddText( Color(150,255,150), "You can't offer a draw before the game starts!" )
				return
			end
			net.Start( "Chess DrawOffer" ) net.SendToServer()
			-- s:SetText( "Draw offered" )
		end
		frame.OfferDraw.Think = function(s)
			if IsValid(self) and self:GetDrawOffer()~=PLAYER_NONE then
				if s.TextChanged then return end
				s.TextChanged = true
				
				if LocalPlayer()==self:GetWhitePlayer() then
					if self:GetDrawOffer()==PLAYER_WHITE then
						s:SetText( "Draw Offered" )
					elseif self:GetDrawOffer()==PLAYER_BLACK then
						s:SetText( "Accept Draw Offer" )
					end
				elseif LocalPlayer()==self:GetBlackPlayer() then
					if self:GetDrawOffer()==PLAYER_WHITE then
						s:SetText( "Accept Draw Offer" )
					elseif self:GetDrawOffer()==PLAYER_BLACK then
						s:SetText( "Draw Offered" )
					end
				end
			elseif s.TextChanged then
				s.TextChanged = false
				s:SetText( "Offer Draw" )
			end
		end
		
		local Resign = vgui.Create( "DButton", ButtonPanel)
		Resign:SetSize(94,35)
		Resign:Dock( TOP )
		Resign:SetText( "Resign" )
		Resign.DoClick = function( s )
			net.Start( "Chess ClientResign" ) net.SendToServer() --No client-side exit func :/
		end
		
		local DermaMode = vgui.Create( "DButton", ButtonPanel)
		DermaMode:SetSize(94,35)
		DermaMode:Dock( TOP )
		DermaMode:SetText( "Toggle 2D Mode" )
		DermaMode.DoClick = function( s )
			if IsValid(Chess_2DDermaPanel) then
				Chess_2DDermaPanel:Remove()
			else
				Chess_Open2DBoard( self )
			end
		end
		
		return frame
	end
end

--PATH addons/[miecze] moce i hilty/lua/entities/ent_holocron_sith.lua:
AddCSLuaFile() 
DEFINE_BASECLASS( "base_anim" )

local LoadedSounds

if SERVER then 
	util.AddNetworkString( "CreateKDMenu" )
	util.AddNetworkString( "ModelChange" )
end

if CLIENT then 

	surface.CreateFont("HoloCronTitle", {
	    font = "Soloist",
	    extended = true,
	    size = 50
	})

	surface.CreateFont("HoloCronFont", {
	    font = "Seagram tfb",
	    extended = true,
	    size = 30
	})

	ENT.AutomaticFrameAdvance = true
	LoadedSounds = {}
end

ENT.PrintName = "Sith Holocron"
ENT.Author = "Kier"
ENT.Information = "An editable holocron entity"
ENT.Category = "Holocrons"

ENT.Editable = true
ENT.Spawnable = true
ENT.AdminOnly = false
ENT.RenderGroup = RENDERGROUP_OPAQUE

ENT.IconOverride = "materials/wos/targetindicators/plasma_ring_sd.png"

function ENT:SetupDataTables()

	self:NetworkVar( "Bool", 0, "HolocronAccess", { KeyName = "holocronaccess", Edit = { type = "Boolean", order = 1 } } )
	self:NetworkVar( "String", 1, "HolocronText", { KeyName = "holocrontext", Edit = { type = "Generic", order = 2, waitforenter = true } } )

	if SERVER then 
		self:SetHolocronText( "CHANGE ME" )
		self:SetHolocronAccess( false )
	end

end

function ENT:SpawnFunction( ply, tr, ClassName )

	if ( !tr.Hit ) then return end

	local SpawnPos = tr.HitPos + tr.HitNormal

	-- Make sure the spawn position is not out of bounds
	local oobTr = util.TraceLine( {
		start = tr.HitPos,
		endpos = SpawnPos,
		mask = MASK_SOLID_BRUSHONLY
	} )

	if ( oobTr.Hit ) then
		SpawnPos = oobTr.HitPos + oobTr.HitNormal * ( tr.HitPos:Distance( oobTr.HitPos ) / 2 )
	end

	local ent = ents.Create( ClassName )
	ent:SetPos( SpawnPos )
	ent:Spawn()
	ent:Activate()

	return ent

end

function ENT:Initialize()

	self:SetModel( "models/holocrons/holocron_sith01.mdl" )

	self:SetColor( Color( 255, 255, 255, 255 ) )

	self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )

	if SERVER then self:PhysicsInit( SOLID_VPHYSICS ) end -- DONT CHANGE - CAN BREAK PHYSGUNS

	self:PhysWake()
	
end

function ENT:Use( active )
	self:SetUseType( SIMPLE_USE )

	if active:IsPlayer() then 
		if self:GetHolocronAccess() == true then 
			net.Start("CreateKDMenu")
				net.WriteString(self:GetHolocronText())
			net.Send(active)
			--self:SetModel("models/holocrons/jedi_holocron_opened.mdl")
		else
			active:Say("I'm too pathetic to open this holocron. I'm...a failure.")
		end
	end
end

function ENT:Think()
	for k, v in pairs( ents.FindByClass("ent_holocron_sith")) do
		local newang = Angle(0,(CurTime()*90)%360,0)
		v:SetAngles(newang)
	end

	self:NextThink( CurTime() + 10 )
	return true
end

net.Receive("CreateKDMenu", function()  
	local displaytext = net.ReadString()

	local holocron = vgui.Create("DFrame")
	holocron:SetSize( ScrW()/2, ScrH()/2 )
	holocron:Center()
	holocron:SetTitle("")
	holocron:MakePopup()
	holocron:SetSizable(false)
	holocron:SetDraggable(false)
	holocron:ShowCloseButton(false)
	holocron:SetDeleteOnClose(true)

	holocron.Paint = function(self, w, h)


		draw.RoundedBoxEx(50, w/2, h*0.05, w/2*0.96, h, Color(176, 11, 11,200), true, true, false, false)
		draw.RoundedBoxEx(50, w*0.02, h*0.05, w/2*0.96, h, Color(0, 12, 176,200), true, true, false, false)
		local LightningCrack = Material("materials/holocron/lightning_crack.png", "noclamp smooth")
		local LightningEffect = Material("materials/holocron/lightning_effect.png", "noclamp smooth")
		surface.SetMaterial( LightningCrack )
		surface.SetDrawColor( 128, 0, 255, 255 )
		surface.DrawTexturedRect(w*0.02, h*0.05, w*0.96, h*0.98)
		draw.RoundedBox(0, w*0.02, h*0.05, w*0.005, h, Color( 10, 10, 10))
		draw.RoundedBox(0, w*0.98, h*0.05, w*0.005, h, Color( 10, 10, 10))

		

		--[[surface.SetMaterial( LightningEffect )
		surface.SetDrawColor( 128, 0, 255, 255 )
		surface.DrawTexturedRect(w/2*0.8, h*0.08, w*0.2, h*0.98)]]--

		surface.SetFont("HoloCronTitle")
		local holocrontitle = "Holocron"
		local tw, th = surface.GetTextSize(holocrontitle)

		draw.RoundedBoxEx(100, w*0.02, h*0.05, w*0.96, h*0.01+th*1.02, Color(10, 10, 10), true, true, false, false)

		draw.RoundedBox(0, w*0.02, h*0.99, w*0.965, h*0.02, Color( 10, 10, 10))

		local JediLogo = Material("materials/holocron/jedi_logo.png", "noclamp smooth")
		local SithLogo = Material("materials/holocron/sith_logo.png", "noclamp smooth")
		local Jedi = Material("materials/holocron/jedi.png", "noclamp smooth")
		local Sith = Material("materials/holocron/sith.png", "noclamp smooth")

		surface.SetMaterial( JediLogo )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect(0, 0, w*0.1, h*0.155)

		surface.SetMaterial( SithLogo )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect(w*0.9, 0, w*0.1, h*0.15)

		--[[surface.SetMaterial( Jedi )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect(0, h/2, w*0.2, h*0.5)

		surface.SetMaterial( Sith )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect(w*0.75, h/2*1.015, w*0.3, h*0.5)]]--

		surface.SetTextColor(255, 255, 255, 255)
		surface.SetTextPos(w/2-tw/2, h*0.06)
		surface.DrawText(holocrontitle)

		--[[draw.RoundedBox(0, w/2, 0, 1, h, Color(255,255,255))
		draw.RoundedBox(0, 0, h/2, w, 1, Color(255,255,255))]]--
	end

	local holoclose = vgui.Create("DButton", holocron )
	holoclose:SetPos(holocron:GetWide()/2*0.925, holocron:GetTall()*0.925)
	holoclose:SetSize(holocron:GetWide()/2*0.15, holocron:GetTall()/2*0.15)
	holoclose:SetText("")
	holoclose.DoClick = function()
		holocron:Close()
	end
	holoclose.Paint = function(self, w, h)
		surface.SetDrawColor(5, 5, 5, 250)
		surface.DrawRect(0, 0, w, h)

		local closebg = Material("materials/wos/targetindicators/plasma_square_sd.png", "noclamp smooth")
		surface.SetMaterial( closebg )
		surface.SetDrawColor( 100, 100, 100, 255 )
		surface.DrawTexturedRect(0, 0, w, h)

		local closemat = Material("materials/wos/runes/n.png", "noclamp smooth")
		surface.SetMaterial( closemat )
		surface.SetDrawColor( 25, 25, 25, 255 )
		surface.DrawTexturedRect(w/2*0.3, h/2*0.35, w*0.7, h*0.7)

		--[[surface.SetTextColor(0, 0, 0, 255)
		surface.SetFont("HoloCronFont")
		local closetext = "Close"
		local ww, hh = surface.GetTextSize( closetext )
		surface.SetTextPos(w*0.5-ww, h*0.5-hh)
		surface.DrawText( closetext )]]--
	end

	local holotextbg = vgui.Create( "DPanel", holocron )
	holotextbg:SetPos(holocron:GetWide()/2*0.6, holocron:GetTall()/2*0.6)
	holotextbg:SetSize(holocron:GetWide()/2*0.8, holocron:GetTall()/2)
	holotextbg:SetBackgroundColor( Color(0, 0, 0, 255))

	local holotext = vgui.Create( "DLabel", holotextbg )
	holotext:SetPos(holotextbg:GetWide()*0.1, 0)
	holotext:SetSize(holocron:GetWide()/2*0.65, holocron:GetTall()/2)
	holotext:SetFont("HoloCronFont")
	holotext:SetText(displaytext)
	holotext:SetColor(Color(255, 255, 255))
	holotext:SetWrap(true)
end )

hook.Add( "OnEntityCreated", "HolocronLoopSound2", function(ent)
	if ent:GetClass() == "ent_holocron_sith" then 
		print( ent:EntIndex() )
		ent:StartLoopingSound("holocronloop/holocron_loop.wav")
	end
end)

hook.Add( "PreDrawHalos", "HolocronGlow2", function()
	halo.Add( ents.FindByClass( "ent_holocron_sith" ), Color(255,0,0), 10, 10, 8, true, false )
end)

hook.Add( "EntityRemoved", "StopHolocronLoop2", function(ent)
	if ent:GetClass() == "ent_holocron_sith" then
		RunConsoleCommand("stopsound")
	end
end)

hook.Add( "Think", "DynLightHolocron2", function() 
	if CLIENT then 
		for k, v in pairs( ents.FindByClass("ent_holocron_sith") ) do
			local k_ddark = DynamicLight( v:EntIndex() )
			if ( k_ddark ) then 
				k_ddark.pos = v:GetPos()
				k_ddark.r = 255
				k_ddark.g = 0
				k_ddark.b = 0
				k_ddark.brightness = 1
				k_ddark.Decay = 1000
				k_ddark.Size = 250
				k_ddark.DieTime = CurTime() + 1
				k_ddark.nomodel = false
			end
		end
	end
end)

function ENT:CanProperty( ply, prop )
	if ( ply:IsAdmin() or ply:IsSuperAdmin() ) then 
		return true
	elseif ( ply:GetUserGroup() == "User" ) then
		return false
	end
end
--PATH lua/entities/ent_wballoon/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Balloon"

ENT.DoNotDuplicate = true 
ENT.DisableDuplicator = true

ENT.DefaultTimer	= 3
--PATH lua/entities/eta2.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "Eta-2"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Republic"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/eta2r/eta2r1.mdl"
ENT.Vehicle = "EtaR"
ENT.StartHealth = 1000;
ENT.Allegiance = "Republic";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("eta2");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetNWInt("Health",self.StartHealth);
	self.CanRoll = true;
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetRight()*-65+self:GetUp()*25+self:GetForward()*42,
		Right = self:GetPos()+self:GetRight()*65+self:GetUp()*25+self:GetForward()*42,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2500;
	self.ForwardSpeed = 1500;
	self.UpSpeed = 750;
	self.AccelSpeed = 10;
	self.CanStandby = true;
	self.CanShoot = true;
	self.HasWings = true;
	self.AlternateFire = true;
	self.FireGroup = {"Left","Right"};
	self.LandOffset = Vector(0,0,5);
	
	self.CurrentDroid = self.DroidModels[math.random(1,3)];
	self:SpawnDroid(self:GetPos()+self:GetUp()*32.5+self:GetRight()*-50+self:GetForward()*-8)
	
	self.Bullet = CreateBulletStructure(100,"green");

	self.BaseClass.Initialize(self)
end

ENT.DroidModels = {
	"models/nicholasray/sws/r2d2r.mdl",
	"models/nicholasray/sws/r2d2g.mdl",
	"models/nicholasray/sws/r2d2b.mdl",
};
function ENT:SpawnDroid(pos)
	
	local e = ents.Create("prop_physics");
	e:SetModelScale(0.775);
	e:SetModel(self.CurrentDroid);
	e:SetPos(pos);
	e:SetAngles(self:GetAngles()+Angle(0,0,-10));
	e:SetParent(self);
	e:Spawn();
	e:Activate();
	e:GetPhysicsObject():EnableMotion(false);
	e:GetPhysicsObject():EnableCollisions(false);
	self.Droid = e;

end


end

if CLIENT then
	ENT.CanFPV = true;

	local matPlasma	= Material( "effects/strider_muzzle" )
	function ENT:Draw() 
		self:DrawModel()		
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		local vel = self:GetVelocity():Length();
		if(vel > 150) then
			if(Flying and !TakeOff and !Land) then
				for i=1,2 do
					local vOffset = self.EnginePos[i] 
					local scroll = CurTime() * -20
						
					render.SetMaterial( matPlasma )
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 24, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 20, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 16, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 24, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 20, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 16, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 24, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 20, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 16, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
					
				end
			end
		end
	end
		
		
	ENT.EnginePos = {}
	ENT.Sounds={
		Engine=Sound("vehicles/eta/eta_fly.wav"),
	}

	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local p = LocalPlayer()		
		local FWD = self:GetForward();
		local id = self:EntIndex();

		for k,v in pairs(self.EnginePos) do
			
			local blue = self.FXEmitter:Add("sprites/bluecore",v+FWD*-5)
			blue:SetVelocity(normal)
			blue:SetDieTime(0.025)
			blue:SetStartAlpha(255)
			blue:SetEndAlpha(255)
			blue:SetStartSize(8)
			blue:SetEndSize(5)
			blue:SetRoll(roll)
			blue:SetColor(255,255,255)
			
			local dynlight = DynamicLight(id + 4096 * k);
			dynlight.Pos = v+FWD*-5;
			dynlight.Brightness = 5;
			dynlight.Size = 150;
			dynlight.Decay = 1024;
			dynlight.R = 100;
			dynlight.G = 100;
			dynlight.B = 255;
			dynlight.DieTime = CurTime()+1;
			
		end
	
	end

	
	local Health = 0;
	local Overheat = 0;
	local Overheated = false;
	local FPV = false;
	function ENT:Think()
	
		self.BaseClass.Think(self)
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			self.EnginePos = {
				self:GetPos()+self:GetForward()*-150+self:GetUp()*28+self:GetRight()*14.5,
				self:GetPos()+self:GetForward()*-150+self:GetUp()*28+self:GetRight()*-17,
			}
			if(!TakeOff and !Land) then
				self:FlightEffects();
			end
		end
		
	end
	
    ENT.ViewDistance = 700;
    ENT.ViewHeight = 200;
    ENT.FPVPos = Vector(-25,0,60);
	
	local HUD = surface.GetTextureID("vgui/eta_cockpit");
	function EtaRReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingEtaR");
		local self = p:GetNWEntity("EtaR");
		if(Flying and IsValid(self)) then
			
			if(self:GetFPV()) then
				SW_HUD_FPV(HUD);
				SW_HUD_WingsIndicator("eta",x,y);
			end

			SW_HUD_DrawHull(self:GetNWInt("StartHealth"));
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			local x = ScrW()/4*0.4;
			local y = ScrH()/4*3.1;
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
			
		end
	end
	hook.Add("HUDPaint", "EtaRReticle", EtaRReticle)

end
--PATH gamemodes/starwarsrp/entities/entities/fadmin_motd/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/fadmin_motd/cl_init.lua:
include("shared.lua")
local defaultHTML

-- I love the garry's mod wiki!
-- Credits to whoever made this function!
local function WorldToScreen(vWorldPos, vPos, vScale, aRot)
    vWorldPos = vWorldPos - vPos
    vWorldPos:Rotate(Angle(0, -aRot.y, 0))
    vWorldPos:Rotate(Angle(-aRot.p, 0, 0))
    vWorldPos:Rotate(Angle(0, 0, -aRot.r))

    return vWorldPos.x / vScale, (-vWorldPos.y) / vScale
end

function ENT:LoadPage()
    local Page = self.MOTDPage:GetString()
    if string.lower(Page) == "data/fadmin/motd.txt" or string.lower(Page) == "default" then
        self.HTML:SetHTML(defaultHTML)
    elseif string.lower(string.sub(Page, -4)) == ".txt" and string.lower(string.sub(Page, 1, 5)) == "data/" then -- If it's a text file somewhere in data...
        Page = string.sub(Page, 6)
        self.HTML:SetHTML(file.Read(Page, "DATA") or "")
    else
        self.HTML:OpenURL(Page)
    end
end

function ENT:Initialize()
    self.MOTDPage = GetConVar("_FAdmin_MOTDPage")
    self.Disabled = true
    self.LastDrawn = CurTime()
    self.HTML = self.HTMLControl or vgui.Create("HTML")
    self.HTML:SetPaintedManually(false)
    self.HTML:SetPos(-512, -256)
    self.HTMLWidth = 1448
    self.HTMLHeight = 724
    self.HTML:SetSize(self.HTMLWidth, self.HTMLHeight)
    self:LoadPage()

    self.HTML:SetVisible(false)
    self.HTML:SetKeyboardInputEnabled(false)
    timer.Simple(0, function() -- Fix areas of the FAdmin scoreboard coming unclickable
        self.HTML:SetPaintedManually(true)
    end)
end

function ENT:Think()
    if not self.HTML or self.Disabled or self.HTMLCloseButton then
        self.HTMLMat = nil
    else
        self.HTML:UpdateHTMLTexture()
        self.HTMLMat = self.HTML:GetHTMLMaterial()
    end
    self:NextThink(CurTime() + 0.1)
end

local gripTexture = surface.GetTextureID("sprites/grip")
local ArrowTexture = surface.GetTextureID("gui/arrow")
local color_white = color_white
local color_darkgrey = Color(100, 100, 100, 255)

function ENT:Draw()
    self:DrawModel()

    local pos = self:GetPos()
    local ply = LocalPlayer()
    if pos:DistToSqr(ply:GetShootPos()) > 90000 then return end

    if CurTime() - self.LastDrawn > 0.5 then
        self.Disabled = true --Disable it again when you stop looking at it
    end

    self.LastDrawn = CurTime()
    local IsAdmin = ply:IsAdmin()
    local HasPhysgun = ply:GetActiveWeapon():IsValid() and ply:GetActiveWeapon():GetClass() == "weapon_physgun"
    local isUsing = (HasPhysgun and ply:KeyDown(IN_ATTACK)) or ply:KeyDown(IN_USE)

    surface.SetFont("Roboto20")
    local TextPosX = surface.GetTextSize("Physgun/use the button to see the MOTD!") * (-0.5)

    local ang = self:GetAngles()
    ang:RotateAroundAxis(ang:Right(), -90)
    ang:RotateAroundAxis(ang:Up(), 90)

    local posX, posY = WorldToScreen(ply:GetEyeTrace().HitPos, self:GetPos() + ang:Up() * 3, 0.25, ang)
    render.SuppressEngineLighting(true)
    cam.Start3D2D(self:GetPos() + ang:Up() * 3, ang, 0.25)

        if self.Disabled then
            surface.SetDrawColor(0, 0, 0, 255)
            surface.DrawRect(-512, 256, 1024, -512)
            surface.SetTextColor(255, 255, 255, 255)
            surface.SetTextPos(TextPosX, 0)
            surface.DrawNonParsedText("Physgun/use the button to see the MOTD!")

            draw.WordBox(4, -16, 24, "Click!", "default", color_darkgrey, color_white)

            surface.SetDrawColor(255, 255, 255, 255)
            if IsAdmin and HasPhysgun then
                surface.SetTexture(gripTexture)
                surface.DrawTexturedRect(-10, 240, 16, 16)
            end
            if isUsing then

                posX, posY = math.Clamp(posX, -506, 506), math.Clamp(posY, -250, 250)
                surface.SetTexture(ArrowTexture)
                surface.DrawTexturedRectRotated(posX + 5, posY + 5, 16, 16, 45)

                -- Clicking button
                if posX > -16 and posX < 16 and posY > 24 and posY < 48 then
                    self:LoadPage()
                    self.Disabled = false
                    self.CanClickAgain = CurTime() + 1
                end
            end
        elseif not self.HTMLMat then
            self.HTML:SetVisible(true)
            self.HTML:SetKeyboardInputEnabled(true)
            self.HTML:SetPaintedManually(false)
            self.HTML:UpdateHTMLTexture()

            timer.Simple(0, function() -- Fix HTML material
                self.HTML:SetPaintedManually(true)
                self.HTML:SetVisible(false)
                self.HTML:SetKeyboardInputEnabled(false)
            end)

        else
            surface.SetMaterial(self.HTMLMat)
            surface.SetDrawColor(255, 255, 255, 255)
            surface.DrawTexturedRect(-512, -256, self.HTMLWidth, self.HTMLHeight)
        end

    cam.End3D2D()
    render.SuppressEngineLighting(false)
    if self.HTMLCloseButton then return end

    --Drawing the actual HTML panel:

    if isUsing and posX > -500 and posX < 500 and posY < 250 and posY > -250 and
    not self.Disabled and self.HTML and self.HTML:IsValid() and self.CanClickAgain and CurTime() > self.CanClickAgain then
        self.CanClickAgain = CurTime() + 1
        self.HTML:SetPaintedManually(false)
        self.HTML:SetPos(0, 100)
        self.HTML:SetSize(ScrW(), ScrH() - 100)
        gui.EnableScreenClicker(true)
        -- gui.SetMousePos(posX/1024*ScrW(), posY/512*(ScrH() - 100) + 100)
        self.HTMLCloseButton = self.HTMLCloseButton or vgui.Create("DButton")
        self.HTMLCloseButton:SetPos(ScrW() - 100, 0)
        self.HTMLCloseButton:SetSize(100, 100)
        self.HTMLCloseButton:SetText("X")
        self.HTMLCloseButton:SetVisible(true)
        self.HTML:SetVisible(true)
        self.HTML:RequestFocus()
        self.HTML:SetKeyboardInputEnabled(true)
        self.HTML:MakePopup()

        function self.HTMLCloseButton.DoClick() -- Revert to drawing on the prop
            self.HTML:SetPos(-512, -256)
            self.HTML:SetSize(self.HTMLWidth, self.HTMLHeight)
            self.HTML:SetPaintedManually(true)
            self.HTML:SetKeyboardInputEnabled(false)
            self.HTML:SetVisible(false)
            gui.EnableScreenClicker(false)
            self.HTMLCloseButton:Remove()
            self.HTMLCloseButton = nil
        end
    end
end

defaultHTML = [[
<html>
<title>MOTD!</title>
<body bgcolor="888888">
<center><h1>Example MOTD/Instructions on how to set a proper MOTD</h1></center>
<h2>Of course you have to be superadmin or owner.</h2>
<ol>
<li>Copy the website URL to the clipboard<br></li>
<li>Enter the command: FAdmin MOTDPage "your website here"<br><br></li>
<i>Example:</i><br>
FAdmin MOTDPage "www.facepunch.com"
</body>
</html>]]

--PATH lua/entities/fly_base.lua:
return gluapack()()
--PATH lua/entities/gb_rp_sign_wire/cl_init.lua:
include("shared.lua")

local font = "InfoRUS2"

local sizetable = {
	[3] = {350, 0.5},
	[4] = {470, -11.5},
	[5] = {590, -11.5},
	[6] = {710, 0.5},
	[7] = {830, 0.5},
	[8] = {950, 0.5},
}

function ENT:Initialize()
	
	self.OldWide = self:GetWide()

	self.frame = vgui.Create( "DPanel" )
	self.frame:SetSize( sizetable[self:GetWide()][1], 120 )
	self.frame.Text = self:GetText()
	self.frame.Type = self:GetType()
	self.frame.col = self:GetTColor()
	self.frame.damage = 0
	self.frame.appr = nil
	self.frame.FX = self:GetFX()
	self.frame.On = self:GetOn()
	self.frame.alfa = 0
	self.frame.speed = self:GetSpeed()
	self.frame:SetPaintedManually( true )
	self.frame.Paint = function(self,w,h)
		
		if self.On <= 0 then 
			if self.alfa < 1 then return end
			self.alfa = Lerp(FrameTime() * 5,self.alfa,0)
		else
			if self.FX > 0 then
				self.alfa = math.random(100,220)
			else
				self.alfa = 255
			end
		end
		
		surface.DisableClipping( false )
		surface.SetFont(font)
		local ww,hh = surface.GetTextSize(self.Text)
		local multiplier = self.speed * 100
		
		self.static = false
		
		if self.damage < CurTime() and self.On then
			if self.Type == 1 then
				
				local xs = (math.fmod(SysTime() * multiplier,w+ww)) - ww
				
				draw.DrawText(self.Text,font,xs,10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, self.alfa),0)
			elseif self.Type == 2 then
				
				if !self.appr or self.appr > ww  then
					self.appr = -w
				else
					self.appr = math.Approach(self.appr, ww+w, FrameTime() * multiplier) 
				end
				
			draw.DrawText(self.Text,font,self.appr * -1,10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, self.alfa),0)
			else
				if !self.appr then
					self.appr = 0
				end
				
				if w > ww then
					if self.Type == 3 then
						if self.appr < w-ww and !self.refl then
							self.appr = math.Approach(self.appr, ww+w, FrameTime() * multiplier) 
						else
							if self.appr <= 0 then
								self.refl = nil
							else
								self.refl = true
								self.appr = math.Approach(self.appr, 0, FrameTime() * multiplier) 
							end
						end
					else
						self.static = true
					end
				else
					if self.appr > w-ww-50 and !self.refl then
						self.appr = math.Approach(self.appr, w-ww-50, FrameTime() * multiplier) 
					else
						if self.appr >= 50 then
							self.refl = nil
						else
							self.refl = true
							self.appr = math.Approach(self.appr, 50, FrameTime() * multiplier) 
						end
					end
				end
				
				if self.static then
					draw.DrawText(self.Text,font,w/2,10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, self.alfa),1)
				else
					draw.DrawText(self.Text,font,self.appr,10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, self.alfa),0)
				end
			end
		else	
			draw.DrawText(self.Text,font,math.random(0,w-ww),10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, math.random(0,255)),0)
		end
		surface.DisableClipping( true )
	end
end

function ENT:Draw()
	
	self:DrawModel()
	
	if self.frame then
		self.frame.Text = self:GetText()
		self.frame.Type = self:GetType()
		self.frame.col = self:GetTColor()
		self.frame.FX = self:GetFX()
		self.frame.On = self:GetOn()
		self.frame.damage = self:GetNWInt("LastDamaged")
		self.frame.speed = self:GetSpeed()
	end
	
	local Pos = self:GetPos()
	local Ang = self:GetAngles()
	local hight = 12
	
	if self.OldWide != self:GetWide() then
		self.frame:SetSize( sizetable[self:GetWide()][1], 120 )
		self.OldWide = self:GetWide()
	end
	
	if self:GetWide() == 3 then
		hight = 6
	end
	
	cam.Start3D2D(Pos + Ang:Up() * 1.1 - Ang:Right() * hight + Ang:Forward() * sizetable[self:GetWide()][2], Ang, 0.1)
		self.frame:PaintManual()
	cam.End3D2D()

end
--PATH lua/entities/gb_rp_sign_wire/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_wire_entity"
ENT.PrintName = "Spawned Sign Wire"
ENT.WireDebugName	= "LED Screen"
ENT.Author = "Mac"
ENT.Spawnable = false
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "Text")
	self:NetworkVar("Vector", 0, "TColor")
	self:NetworkVar("Int", 0, "Type")
	self:NetworkVar("Int", 1, "Speed")
	self:NetworkVar("Int", 2, "Wide")
	self:NetworkVar("Int", 3, "On")
	self:NetworkVar("Int", 4, "FX")
end
--PATH lua/entities/laat_hatch/cl_init.lua:
return gluapack()()
--PATH lua/entities/laat_rocketlauncher/cl_init.lua:
return gluapack()()
--PATH lua/entities/laat_rocketlauncher/shared.lua:
return gluapack()()
--PATH lua/entities/laat_rocketlauncher/shared.lua:
ENT.Base            = "base_entity"
ENT.Type            = "anim"

ENT.PrintName       = "Rockets"
ENT.Author          = "!Ben"
ENT.Information     = ""
ENT.Category        = "[LFS] - Star Wars Pack"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.AutomaticFrameAdvance = true
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_hilt_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_pickupable"
DEFINE_BASECLASS( "lscs_pickupable" )

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.PickupSound = "physics/metal/weapon_impact_soft3.wav"
ENT.ImpactHardSound = "weapon.ImpactHard"
ENT.ImpactSoftSound = "weapon.ImpactSoft"

if SERVER then
	function ENT:Initialize()
		self:SetModel( self.MDL )
		BaseClass.Initialize( self )
	end
end
--PATH lua/entities/lvs_av7/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(  math.Clamp(math.Clamp(  60 + Pitch * 50, 80,255) + Doppler,0,255) )
		self.ENG:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0.5,1) )
	end
	
	if self.DIST then
		self.DIST:ChangePitch(  math.Clamp(math.Clamp(  50 + Pitch * 60, 50,255) + Doppler,0,255) )
		self.DIST:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0,1) )
	end
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
	if self.DIST then
		self.DIST:Stop()
	end
	
	if self.ENG then
		self.ENG:Stop()
	end
end

--PATH lua/entities/lvs_base/cl_hud.lua:

LVS:AddHudEditor( "VehicleHealth", 10, ScrH() - 85,  220, 75, 220, 75, "VEHICLE HEALTH", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintVehicleHealth then return end

		vehicle:LVSHudPaintVehicleHealth( X, Y, W, H, ScrX, ScrY, ply )
	end
)

LVS:AddHudEditor( "VehicleInfo", ScrW() - 460, ScrH() - 85,  220, 75, 220, 75, "VEHICLE INFORMATION", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintInfoText then return end

		vehicle:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	end
)

function ENT:LVSHudPaintVehicleHealth( X, Y, W, H, ScrX, ScrY, ply )
	draw.DrawText( "HEALTH ", "LVS_FONT", X + 102, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( math.Round( self:GetHP(), 0 ), "LVS_FONT_HUD_LARGE", X + 102, Y + 20, color_white, TEXT_ALIGN_LEFT )
end

ENT.VehicleIdentifierRange = 10000

function ENT:LVSHudPaintVehicleIdentifier( X, Y, In_Col )
	local HP = self:GetHP()

	surface.SetDrawColor( In_Col.r, In_Col.g, In_Col.b, In_Col.a )
	LVS:DrawDiamond( X + 1, Y + 1, 20, HP / self:GetMaxHP() )

	if self:GetMaxShield() > 0 and HP > 0 then
		surface.SetDrawColor( 200, 200, 255, In_Col.a )
		LVS:DrawDiamond( X + 1, Y + 1, 24, self:GetShield() / self:GetMaxShield() )
	end
end

function ENT:LVSHudPaint( X, Y, ply )
end

function ENT:HurtMarker( intensity )
	LocalPlayer():EmitSound( "lvs/hit_receive"..math.random(1,2)..".wav", 75, math.random(95,105), 0.25 + intensity * 0.75, CHAN_STATIC )
	util.ScreenShake( Vector(0, 0, 0), 25 * intensity, 25 * intensity, 0.5, 1 )
end

function ENT:KillMarker()
	self.LastKillMarker = CurTime() + 0.5

	LocalPlayer():EmitSound( "lvs/hit_kill.wav", 85, 100, 0.4, CHAN_VOICE )
end

local LastMarker = 0
function ENT:ArmorMarker( IsDamage )
	local T = CurTime()

	local DontHurtEars = math.Clamp( T - LastMarker, 0, 1 ) ^ 2

	LastMarker = T

	local ArmorFailed = IsDamage and "takedamage" or "pen"
	local Volume = IsDamage and (0.3 * DontHurtEars) or 1

	LocalPlayer():EmitSound( "lvs/armor_"..ArmorFailed.."_"..math.random(1,3)..".wav", 85, math.random(95,105), Volume, CHAN_ITEM2 )
end

function ENT:HitMarker()
	self.LastHitMarker = CurTime() + 0.15

	LocalPlayer():EmitSound( "lvs/hit.wav", 85, math.random(95,105), 0.4, CHAN_ITEM )
end

function ENT:CritMarker()
	self.LastCritMarker = CurTime() + 0.15

	LocalPlayer():EmitSound(  "lvs/hit_crit.wav", 85, math.random(95,105), 0.4, CHAN_ITEM2 )
end

function ENT:GetHitMarker()
	return self.LastHitMarker or 0
end

function ENT:GetCritMarker()
	return self.LastCritMarker or 0
end

function ENT:GetKillMarker()
	return self.LastKillMarker or 0
end

function ENT:LVSPaintHitMarker( scr )
	local T = CurTime()

	local aV = math.cos( math.rad( math.max(((self:GetHitMarker() - T) / 0.15) * 360,0) ) )
	if aV ~= 1 then
		local Start = 12 + (1 - aV) * 8
		local dst = 10

		surface.SetDrawColor( 255, 255, 0, 255 )

		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start, scr.y + Start - dst )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start - dst, scr.y + Start )

		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start, scr.y - Start + dst )
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start - dst, scr.y - Start )

		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start, scr.y + Start - dst )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start + dst, scr.y + Start )

		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start, scr.y - Start + dst )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start + dst, scr.y - Start )

		scr.x = scr.x + 1
		scr.y = scr.y + 1

		surface.SetDrawColor( 0, 0, 0, 80 )

		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start, scr.y + Start - dst )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start - dst, scr.y + Start )

		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start, scr.y - Start + dst )
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start - dst, scr.y - Start )

		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start, scr.y + Start - dst )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start + dst, scr.y + Start )

		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start, scr.y - Start + dst )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start + dst, scr.y - Start )
	end

	local aV = math.sin( math.rad( math.max(((self:GetCritMarker() - T) / 0.15) * 180,0) ) )
	if aV > 0.01 then
		local Start = 10 + aV * 40
		local End = 20 + aV * 45

		surface.SetDrawColor( 255, 100, 0, 255 )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + End, scr.y + End )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - End, scr.y + End ) 
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + End, scr.y - End )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - End, scr.y - End ) 

		draw.NoTexture()
		surface.DrawTexturedRectRotated( scr.x + Start, scr.y + Start, 3, 20, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y + Start, 20, 3, 45 )
		surface.DrawTexturedRectRotated(  scr.x + Start, scr.y - Start, 20, 3, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y - Start, 3, 20, 45 )
	end

	local aV = math.sin( math.rad( math.sin( math.rad( math.max(((self:GetKillMarker() - T) / 0.2) * 90,0) ) ) * 90 ) )
	if aV > 0.01 then
		surface.SetDrawColor( 255, 255, 255, 15 * (aV ^ 4) )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )

		local Start = 10 + aV * 40
		local End = 20 + aV * 45
		surface.SetDrawColor( 255, 0, 0, 255 )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + End, scr.y + End )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - End, scr.y + End ) 
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + End, scr.y - End )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - End, scr.y - End ) 

		draw.NoTexture()
		surface.DrawTexturedRectRotated( scr.x + Start, scr.y + Start, 5, 20, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y + Start, 20, 5, 45 )
		surface.DrawTexturedRectRotated(  scr.x + Start, scr.y - Start, 20, 5, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y - Start, 5, 20, 45 )
	end
end

function ENT:PaintCrosshairCenter( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local Alpha = Col.a / 255
	local Shadow = Color( 0, 0, 0, 80 * Alpha )

	surface.DrawCircle( Pos2D.x, Pos2D.y, 4, Shadow )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 5, Col )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 6, Shadow )
end

function ENT:PaintCrosshairOuter( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local Alpha = Col.a / 255
	local Shadow = Color( 0, 0, 0, 80 * Alpha )

	surface.DrawCircle( Pos2D.x,Pos2D.y, 17, Shadow )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 18, Col )

	if LVS.AntiAliasingEnabled then
		surface.DrawCircle( Pos2D.x, Pos2D.y, 19, Color( Col.r, Col.g, Col.b, 150 * Alpha ) )
		surface.DrawCircle( Pos2D.x, Pos2D.y, 20, Shadow )
	else
		surface.DrawCircle( Pos2D.x, Pos2D.y, 19, Shadow )
	end
end

local Circles = {
	[1] = {r = -1, col = Color(0,0,0,200)},
	[2] = {r = 0, col = Color(255,255,255,200)},
	[3] = {r = 1, col = Color(255,255,255,255)},
	[4] = {r = 2, col = Color(255,255,255,200)},
	[5] = {r = 3, col = Color(0,0,0,200)},
}

function ENT:LVSDrawCircle( X, Y, target_radius, value )
	local endang = 360 * value

	if endang == 0 then return end

	for i = 1, #Circles do
		local data = Circles[ i ]
		local radius = target_radius + data.r
		local segmentdist = endang / ( math.pi * radius / 2 )

		for a = 0, endang, segmentdist do
			surface.SetDrawColor( data.col )

			surface.DrawLine( X - math.sin( math.rad( a ) ) * radius, Y + math.cos( math.rad( a ) ) * radius, X - math.sin( math.rad( a + segmentdist ) ) * radius, Y + math.cos( math.rad( a + segmentdist ) ) * radius )
		end
	end
end

function ENT:PaintCrosshairSquare( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local X = Pos2D.x + 1
	local Y = Pos2D.y + 1

	local Size = 20

	surface.SetDrawColor( 0, 0, 0, 80 )
	surface.DrawLine( X - Size, Y + Size, X - Size * 0.5, Y + Size )
	surface.DrawLine( X + Size, Y + Size, X + Size * 0.5, Y + Size )
	surface.DrawLine( X - Size, Y + Size, X - Size, Y + Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size, Y - Size * 0.5 )
	surface.DrawLine( X + Size, Y + Size, X + Size, Y + Size * 0.5 )
	surface.DrawLine( X + Size, Y - Size, X + Size, Y - Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size * 0.5, Y - Size )
	surface.DrawLine( X + Size, Y - Size, X + Size * 0.5, Y - Size )

	if Col then
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
	else
		surface.SetDrawColor( 255, 255, 255, 255 )
	end

	X = Pos2D.x
	Y = Pos2D.y

	surface.DrawLine( X - Size, Y + Size, X - Size * 0.5, Y + Size )
	surface.DrawLine( X + Size, Y + Size, X + Size * 0.5, Y + Size )
	surface.DrawLine( X - Size, Y + Size, X - Size, Y + Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size, Y - Size * 0.5 )
	surface.DrawLine( X + Size, Y + Size, X + Size, Y + Size * 0.5 )
	surface.DrawLine( X + Size, Y - Size, X + Size, Y - Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size * 0.5, Y - Size )
	surface.DrawLine( X + Size, Y - Size, X + Size * 0.5, Y - Size )
end
--PATH lua/entities/lvs_base_fakehover/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Generic Fake Hover"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 1

ENT.MaxVelocityX = 300
ENT.MaxVelocityY = 300

ENT.MaxTurnRate = 1

ENT.BoostAddVelocityX = 200
ENT.BoostAddVelocityY = 200

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.DisableBallistics = true

function ENT:SetupDataTables()
	self:AddDT( "Vector", "AIAimVector" )
	self:AddDT( "Bool", "Disabled" )

	if SERVER then
		self:NetworkVarNotify( "Disabled", self.OnDisabled )
	end

	self:CreateBaseDT()
end

function ENT:HitGround()
	local data = {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - self.GroundTraceLength) ),
		mins = Vector( -self.GroundTraceHull, -self.GroundTraceHull, 0 ),
		maxs = Vector( self.GroundTraceHull, self.GroundTraceHull, 0 ),
		filter = self:GetCrosshairFilterEnts()
	}

	local trace = util.TraceHull( data )

	data.mask = MASK_WATER

	local traceWater = util.TraceHull( data )

	return ((trace.Hit or (traceWater.Hit and self.GroundTraceHitWater)) and not trace.HitSky)
end

function ENT:GetThrottle()
	return math.min( self:GetVelocity():Length() / math.abs( self.MaxVelocityX + self.BoostAddVelocityX, self.MaxVelocityY + self.BoostAddVelocityY ), 1 )
end

function ENT:GetMaxThrottle()
	return 1
end

function ENT:GetThrustStrenght()
	return 0
end

function ENT:GetVehicleType()
	return "fakehover"
end
--PATH lua/entities/lvs_base_fakehover/cl_hud.lua:
return gluapack()()
--PATH lua/entities/lvs_bomb.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.ExplosionEffect = "lvs_explosion_bomb"

ENT.lvsProjectile = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Bool", 1, "MaskSolid" )

	self:NetworkVar( "Vector", 0, "Speed" )
end

if SERVER then
	util.AddNetworkString( "lvs_bomb_hud" )

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:GetEntityFilter()
		return self._FilterEnts or {}
	end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetForce( num ) self._force = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent )
		self._attacker = ent

		if not IsValid( ent ) or not ent:IsPlayer() then return end

		net.Start( "lvs_bomb_hud", true )
			net.WriteEntity( self )
		net.Send( ent )
	end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 2000) end
	function ENT:GetForce() return (self._force or 8000) end
	function ENT:GetRadius() return (self._radius or 400) end

	function ENT:Initialize()
		self:SetModel( "models/props_phx/ww2bomb.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		self:PhysWake()

		timer.Simple(1, function()
			if not IsValid( self ) then return end

			self:SetCollisionGroup( COLLISION_GROUP_NONE )
		end )

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 500 ) 
		pObj:EnableGravity( false ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )
		pObj:SetVelocityInstantaneous( self:GetSpeed() )

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local ForceLinear = physenv.GetGravity()

		local Pos = self:GetPos()
		local TargetPos = Pos + self:GetVelocity()

		local AngForce = -self:WorldToLocalAngles( (TargetPos - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * 10 - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_GLOBAL_ACCELERATION
	end

	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T )

		self:UpdateTrajectory()

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	function ENT:UpdateTrajectory()
		local base = self:GetParent()

		if not IsValid( base ) then return end

		self:SetSpeed( base:GetVelocity() )
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
		[COLLISION_GROUP_IN_VEHICLE] = true
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		if entity.lvsProjectile then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		local attacker = self:GetAttacker()

		LVS:BlastDamage( Pos, self:GetForward(), IsValid( attacker ) and attacker or game.GetWorld(), self, self:GetDamage(), DMG_BLAST, self:GetRadius(), self:GetForce() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end

	return
end

function ENT:Enable()
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "lvs/weapons/bomb_whistle_loop.wav")
	self.snd:SetSoundLevel( 110 )
	self.snd:PlayEx(0,150)
end

function ENT:CalcDoppler()
	local Ent = LocalPlayer()

	local ViewEnt = Ent:GetViewEntity()

	if Ent:lvsGetVehicle() == self then
		if ViewEnt == Ent then
			Ent = self
		else
			Ent = ViewEnt
		end
	else
		Ent = ViewEnt
	end

	local sVel = self:GetVelocity()
	local oVel = Ent:GetVelocity()

	local SubVel = oVel - sVel
	local SubPos = self:GetPos() - Ent:GetPos()

	local DirPos = SubPos:GetNormalized()
	local DirVel = SubVel:GetNormalized()

	local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

	return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
end

function ENT:Think()
	if self.snd then
		self.snd:ChangePitch( 100 * self:CalcDoppler(), 1 )
		self.snd:ChangeVolume(math.Clamp(-(self:GetVelocity().z + 1000) / 3000,0,1), 2)
	end

	if self.IsEnabled then return end

	if self:GetActive() then
		self:Enable()
	end
end

function ENT:Draw()
	local T = CurTime()

	if not self:GetActive() then
		self._PreventDrawTime = T + 0.1
		return
	end

	if (self._PreventDrawTime or 0) > T then return end

	self:DrawModel()
end

function ENT:SoundStop()
	if self.snd then
		self.snd:Stop()
	end
end

function ENT:OnRemove()
	self:SoundStop()
end

local color_red = Color(255,0,0,255)
local color_red_blocked = Color(100,0,0,255)
local HudTargets = {}
hook.Add( "HUDPaint", "!!!!lvs_bomb_hud", function()
	for ID, _ in pairs( HudTargets ) do
		local Missile = Entity( ID )

		if not IsValid( Missile ) or Missile:GetActive() then
			HudTargets[ ID ] = nil

			continue
		end

		local Grav = physenv.GetGravity()
		local FT = 0.05
		local MissilePos = Missile:GetPos()
		local Pos = MissilePos
		local Vel = Missile:GetSpeed()

		local LastColor = color_red
		local Mask = Missile.GetMaskSolid and (Missile:GetMaskSolid() and MASK_SOLID or MASK_SOLID_BRUSHONLY) or MASK_SOLID_BRUSHONLY

		cam.Start3D()
		local Iteration = 0
		while Iteration < 1000 do
			Iteration = Iteration + 1

			Vel = Vel + Grav * FT

			local StartPos = Pos
			local EndPos = Pos + Vel * FT

			local trace = util.TraceLine( {
				start = StartPos,
				endpos = EndPos,
				mask = Mask,
			} )

			local traceVisible = util.TraceLine( {
				start = MissilePos,
				endpos = StartPos,
				mask = Mask,
			} )

			LastColor = traceVisible.Hit and color_red_blocked or color_red

			render.DrawLine( StartPos, EndPos, LastColor )

			Pos = EndPos

			if trace.Hit then
				break
			end
		end
		cam.End3D()

		local TargetPos = Pos:ToScreen()

		if not TargetPos.visible then continue end

		surface.DrawCircle( TargetPos.x, TargetPos.y, 20, LastColor )
	end
end )

net.Receive( "lvs_bomb_hud", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) then return end

	HudTargets[ ent:EntIndex() ] = true
end )

--PATH lua/entities/lvs_destruction.lua:
return gluapack()()
--PATH lua/entities/lvs_dwarfdroid/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 60
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

-- function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
-- 	local view = {}
-- 	view.origin = pos
-- 	view.angles = angles
-- 	view.fov = fov
-- 	view.drawviewer = false

-- 	if not pod:GetThirdPersonMode() then return view end

-- 	local mn = self:OBBMins()
-- 	local mx = self:OBBMaxs()
-- 	local radius = ( mn - mx ):Length()
-- 	local radius = radius + radius * pod:GetCameraDistance()

-- 	local clamped_angles = pod:WorldToLocalAngles( angles )
-- 	clamped_angles.p = math.max( clamped_angles.p, -20 )
-- 	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

-- 	local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 100
-- 	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

-- 	local WallOffset = 4

-- 	local tr = util.TraceHull( {
-- 		start = StartPos,
-- 		endpos = EndPos,
-- 		filter = function( e )
-- 			local c = e:GetClass()
-- 			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

-- 			return collide
-- 		end,
-- 		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
-- 		maxs = Vector( WallOffset, WallOffset, WallOffset ),
-- 	} )

-- 	view.angles = angles + Angle(5,0,0)
-- 	view.origin = tr.HitPos
-- 	view.drawviewer = true

-- 	if tr.Hit and  not tr.StartSolid then
-- 		view.origin = view.origin + tr.HitNormal * WallOffset
-- 	end

-- 	return view
-- end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	-- if self:GetDriver() == ply then
	-- 	return self:CalcViewDriver( ply, pos, angles, fov, pod )
	-- end

	local view = {}
	view.origin = self:LocalToWorld( Vector(0,0,150) )
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	-- if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius * 1

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius )
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos
	view.angles = angles + Angle(5,0,0)
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end
--PATH lua/entities/lvs_fakehover_iftx/shared.lua:

ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "IFT-X"
ENT.Author = "Luna"
ENT.Information = "Hover Tank of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Hover Tanks"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/iftx.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 2000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 180
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "BTLFire" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,-51,43) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,51,43) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 10 and AimAnglesL.p >= 10) or (AimAnglesR.p <= -25 and AimAnglesL.p <= -25) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 30)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local ID_L = ent:LookupAttachment( "muzzle_left" )
		local ID_R = ent:LookupAttachment( "muzzle_right" )
		local MuzzleL = ent:GetAttachment( ID_L )
		local MuzzleR = ent:GetAttachment( ID_R )

		if not MuzzleL or not MuzzleR then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
		local Dir =  (ent.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_blue_long"
		bullet.Force	= 10000
		bullet.HullSize 	= 1
		bullet.Damage	= 25
		bullet.Velocity = 40000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if ent.MirrorPrimary then
			ent:PlayAnimation( "fire_left" )
	
			if not IsValid( ent.SNDLeft ) then return end
	
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )

			return
		end

		ent:PlayAnimation( "fire_right" )

		if not IsValid( ent.SNDRight ) then return end

		ent.SNDRight:PlayOnce( 100 + math.sin( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		if ent:GetIsCarried() then
			self:SetPoseParameter("cannon_right_pitch", 0 )
			self:SetPoseParameter("cannon_right_yaw", 0 )

			self:SetPoseParameter("cannon_left_pitch", 0 )
			self:SetPoseParameter("cannon_left_yaw", 0 )

			return
		end

		local AimAnglesR, AimAnglesL = ent:GetAimAngles()

		self:SetPoseParameter("cannon_right_pitch", AimAnglesR.p )
		self:SetPoseParameter("cannon_right_yaw", AimAnglesR.y )

		self:SetPoseParameter("cannon_left_pitch", AimAnglesL.p )
		self:SetPoseParameter("cannon_left_yaw", AimAnglesL.y )
	end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 60
	weapon.Delay = 1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local Driver = ent:GetDriver()

		for i = 1, 6 do
			timer.Simple( (i / 5) * 0.75, function()
				if not IsValid( ent ) then return end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local ID_L = ent:LookupAttachment( "muzzle_left" )
				local ID_R = ent:LookupAttachment( "muzzle_right" )
				local MuzzleL = ent:GetAttachment( ID_L )
				local MuzzleR = ent:GetAttachment( ID_R )

				if not MuzzleL or not MuzzleR then return end

				ent.MirrorPrimary = not ent.MirrorPrimary

				local Pos = ent.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
				local Dir =  (ent.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

				local projectile = ents.Create( "lvs_concussionmissile" )
				projectile:SetPos( Pos )
				projectile:SetAngles( Dir:Angle() )
				projectile:SetParent( ent )
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:SetDamage( 300 )
				projectile:SetRadius( 150 )
				projectile:Enable()
				projectile:EmitSound( "LVS.IFTX.FIRE_MISSILE" )

				if ent.MirrorPrimary then
					ent:PlayAnimation( "fire_left" )
				else
					ent:PlayAnimation( "fire_right" )
				end
			end)
		end

		ent:SetHeat( 1 )
		ent:SetOverheated( true )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	self:InitTurret()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "^lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "LVS.IFTX.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "lvs/vehicles/iftx/fire_missile.mp3"
} )

--PATH lua/entities/lvs_fakehover_iftx/sh_turret.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_wheel.lua:
return gluapack()()
--PATH lua/entities/lvs_fall_missel.lua:
return gluapack()()
--PATH lua/entities/lvs_fall_missel_base.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_hyenabomber/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-201.14,-178.05,101.58), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-201.14,178.05,101.58), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-269.82,-178.6,65.6), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-269.82,178.6,65.6), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineFXColor = Color( 0, 0, 255)
ENT.EngineFxPos = {
	Vector(0.16,-102.55,85.47),
	Vector(-1.33,-102.85,78.71),
	Vector(1.14,-109.51,78.55),
	Vector(0.28,-109.68,85.77),
	Vector(5.99,-116.13,85.42),
	Vector(5.82,-116.12,78.67),
	Vector(10.93,-122.51,84.96),
	Vector(10.56,-122.86,78.4),
	--left
	Vector(0.16,102.55,85.47),
	Vector(-1.33,102.85,78.71),
	Vector(1.14,109.51,78.55),
	Vector(0.28,109.68,85.77),
	Vector(5.99,116.13,85.42),
	Vector(5.82,116.12,78.67),
	Vector(10.93,122.51,84.96),
	Vector(10.56,122.86,78.4),
}

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 25 + self:GetThrottle() * 90 + self:GetBoost() * 0.9

	render.SetMaterial( self.EngineGlow )

	for _, v in pairs( self.EngineFxPos ) do
		local pos = self:LocalToWorld( v )
		render.DrawSprite( pos, Size, Size, self.EngineFXColor )

	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/hyena/VEH_STARHAWK_BOOST_ON.mp3", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/brake.wav", 85 )
end

--PATH lua/entities/lvs_starfighter_soundemitter.lua:
return gluapack()()
--PATH lua/entities/lvs_sw_transport/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() then
		if not pod:GetThirdPersonMode() then
			return pos + self:GetForward() * 20 + self:GetUp() * 20, angles, fov
		else
			return pos + self:GetForward() * 0 - self:GetUp() * 40, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()
	if not self:GetLightOn() then self:RemoveLight() return false end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( true ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local Start1 = self:LocalToWorld( Vector(81,13,15) )
	local Start2 = self:LocalToWorld( Vector(81,0,15) )
	local Start3 = self:LocalToWorld( Vector(81,-13,15) )

	local Dir1 = self:LocalToWorldAngles( Angle(0,15,0) ):Forward()
	local Dir2 = self:LocalToWorldAngles( Angle(0,0,0) ):Forward()
	local Dir3 = self:LocalToWorldAngles( Angle(0,-15,0) ):Forward()

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( Start1, 32, 32, Color( 100, 100, 100, 255) )
	render.DrawSprite( Start2, 32, 32, Color( 100, 100, 100, 255) )
	render.DrawSprite( Start3, 32, 32, Color( 100, 100, 100, 255) )

	render.SetMaterial( self.LightMaterial )
	render.DrawBeam( Start1,  Start1 + Dir1 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 
	render.DrawBeam( Start2,  Start2 + Dir2 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 
	render.DrawBeam( Start3,  Start3 + Dir3 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 

	if IsValid( self.projector ) then
		self.projector:SetPos( self:LocalToWorld( Vector(60,0,10.5) ) )
		self.projector:SetAngles( self:LocalToWorldAngles( Angle(15,0,0) ) )
		self.projector:Update()
	end

	return false
end
--PATH lua/entities/lvs_turret_av_red/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_vwing_advanced/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_flamethrower/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	if pod:GetThirdPersonMode() then
			local view = {}
			view.origin = pos
			view.angles = angles
			view.fov = fov
			view.drawviewer = true
	
		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 40
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos
		view.drawviewer = true

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )

	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false
	--view.origin = self:LocalToWorld( Vector(0,0,0) )
		
	if pod:GetThirdPersonMode() then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else 
		return view
	end
end
--PATH lua/entities/lvs_walker_atrt_standart/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_standart/cl_camera.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_standart/cl_legs.lua:

function ENT:OnFrame()
	--self:PredictPoseParamaters()
	self:DamageFX()

	if self:GetIsRagdoll() then 
		self:LegClearAll()

		return
	end

	local Up = self:GetUp()
	local Forward = self:GetForward()
	local Vel = self:GetVelocity()
	
	local Stride = 33
	local Lift = 10
	
	local FT = math.min(FrameTime(),0.08) -- if fps lower than 12, clamp the frametime to avoid spazzing.

	local Rate = FT * 20

	if Vel:Length() < 50 then -- sync with server animation when not moving
		self.Move = self:GetMove()
	else
		self.Move = self.Move and self.Move + self:WorldToLocal( self:GetPos() + Vel ).x * FT * 2.8 or 0
	end
	
	local Cycl1 = self.Move
	local Cycl2 = self.Move + 180
	
	local IsMoving = self:GetIsMoving()
	
	if self:GetIsCarried() then
		self.TRACEPOS1 = self:LocalToWorld( Vector(200,70,180) )
		self.TRACEPOS2 = self:LocalToWorld( Vector(200,-70,180) )
		Cycl1 = 0
		Cycl2 = 0
		IsMoving = true
	end

	local MoveRoll = math.cos( math.rad(self:GetMove()) ) * 2

	-- FRONT LEFT
	local X = 40 + math.cos( math.rad(Cycl1) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl1) ), 0) * Lift
	local STARTPOS = self:LocalToWorld( Vector(-22,18,64) )
	self.TRACEPOS1 = self.TRACEPOS1 and self.TRACEPOS1 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS1 = self.TRACEPOS1 + (STARTPOS + Forward * X - self.TRACEPOS1) * Rate
		self.FSOG1 = false
	else
		self.FSOG1 = true
	end
	--local ENDPOS = util.TraceLine( { start = self.TRACEPOS1 - Up * 50, endpos = self.TRACEPOS1 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (45+Z)
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS1 - Up * 50, endpos = self.TRACEPOS1 - Up * 160, filter = function( ent ) if ent == self or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (-30+Z)
    
	if self.FSOG1 ~= self.oldFSOG1 then
		self.oldFSOG1 = self.FSOG1
		if self.FSOG1 then
			sound.Play( Sound( "atrt/walk.mp3" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		elseif Vel:Length() < 150 then
			sound.Play( Sound( "atrt/hydraulic"..math.random(1,3)..".mp3" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/astartes/atrt/leg3.mdl", Ang = Angle(140,0,0), Pos = Vector(1,-27,4)},
		Leg2 = {MDL = "models/astartes/atrt/leg2.mdl", Ang = Angle(145,0,0), Pos = Vector(2,-33,-1)},
		Foot = {MDL = "models/astartes/atrt/leg0.mdl", Ang = Angle(0,-90,-MoveRoll), Pos = Vector(12,10,-10)}
	}
	self:GetLegEnts( 1, 50, 65, self:LocalToWorldAngles( Angle(90,-10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	-- FRONT RIGHT
	local STARTPOS = self:LocalToWorld( Vector(-22, -18,64) )
	local X = 10 + math.cos( math.rad(Cycl2) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl2) ), 0) * Lift
	self.TRACEPOS2 = self.TRACEPOS2 and self.TRACEPOS2 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS2 = self.TRACEPOS2 + (STARTPOS + Forward * X - self.TRACEPOS2) * Rate
		self.FSOG2 = false
	else
		self.FSOG2 = true
	end
	--local ENDPOS = util.TraceLine( { start = self.TRACEPOS2 - Up * 50, endpos = self.TRACEPOS2 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (45+Z)
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS2 - Up * 50, endpos = self.TRACEPOS2 - Up * 160, filter = function( ent ) if ent == self or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (-30+Z)
	
	if self.FSOG2 ~= self.oldFSOG2 then
		self.oldFSOG2 = self.FSOG2
		if self.FSOG2 then
			sound.Play( Sound( "atrt/walk.mp3" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		elseif Vel:Length() < 150 then
			sound.Play( Sound( "atrt/hydraulic"..math.random(1,3)..".mp3" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/astartes/atrt/leg3.mdl", Ang = Angle(140,0,0), Pos = Vector(1,-27,4)},
		Leg2 = {MDL = "models/astartes/atrt/leg2.mdl", Ang = Angle(145,0,0), Pos = Vector(2,-33,-1)},
		Foot = {MDL = "models/astartes/atrt/leg0.mdl", Ang = Angle(0,-90,-MoveRoll), Pos = Vector(12,10,-10)}
	}
	
	self:GetLegEnts( 2, 50, 65, self:LocalToWorldAngles( Angle(90,10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
end
--PATH lua/entities/lvs_walker_atte_hoverscript/cl_init.lua:
include("shared.lua")

--PATH lua/entities/lvs_walker_hsd/sh_weapons.lua:

function ENT:AimTurretSecondary()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,100)) ):GetNormalized():Angle() )

	self:SetPoseParameter("turret_secondary_pitch", -AimAngles.p )
	self:SetPoseParameter("turret_secondary_yaw", AimAngles.y )
end

function ENT:AimTurretPrimary()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,342)) ):GetNormalized():Angle() )

	self:SetPoseParameter("turret_primary_pitch", -AimAngles.p )
	self:SetPoseParameter("turret_primary_yaw", AimAngles.y )
end

function ENT:WeaponsInRange()
	local Forward = self:GetForward()
	local AimForward = self:GetAimVector()

	return self:AngleBetweenNormal( Forward, AimForward ) < 45
end

function ENT:TraceProjectorBeam()
	local ID = self:LookupAttachment( "muzzle_primary" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = -Muzzle.Ang:Right()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:StopProjector()
	if not self:GetProjectorBeam() then return end

	self:SetProjectorBeam( false )

	self.SNDProjector:Stop()
end

function ENT:StartProjector()
	if not IsValid( self.SNDProjector ) then return end

	if self:GetProjectorBeam() then return end

	self:SetProjectorBeam( true )

	self.SNDProjector:Play()
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 2
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.5
	weapon.OnThink = function( ent, active )
		ent:AimTurretPrimary()

		if not ent:GetProjectorBeam() then return end

		local trace = ent:TraceProjectorBeam()

		ent:ProjectorBeamDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )

		if not active then return end

		ent:SetHeat( ent:GetHeat() + FrameTime() * 10 )
	end
	weapon.Attack = function( ent )
		if ent:GetProjectorBeam() then return true end

		if not ent:WeaponsInRange() then return true end

		ent:StartProjector()

		timer.Simple( 1.25, function()
			if not IsValid( ent ) then return end

			ent:StopProjector()
		end )
	end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 100
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 0.4
	weapon.OnOverheat = function( ent )
		timer.Simple( 0.4, function()
			if not IsValid( ent ) then return end

			ent:EmitSound("lvs/overheat.wav")
		end )
	end
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local effectdata = EffectData()
		effectdata:SetOrigin( ent:LocalToWorld( Vector(0,0,200) ) )
		effectdata:SetEntity( ent )
		effectdata:SetAttachment( ent:LookupAttachment( "muzzle_secondary" ) )
		util.Effect( "lvs_laser_charge", effectdata )

		timer.Simple( 0.4, function()
			if not IsValid( ent ) then return end

			local ID = ent:LookupAttachment( "muzzle_secondary" )
			local Muzzle = ent:GetAttachment( ID )

			if not Muzzle then return end

			local bullet = {}
			bullet.Src 	= Muzzle.Pos
			bullet.Dir 	= ent:WeaponsInRange() and (ent:GetEyeTrace().HitPos - Muzzle.Pos):GetNormalized() or -Muzzle.Ang:Right()
			bullet.Spread 	= Vector(0,0,0)
			bullet.TracerName = "lvs_laser_red_aat"
			bullet.Force	= 20000
			bullet.HullSize 	= 1
			bullet.Damage	= 200
			bullet.SplashDamage = 300
			bullet.SplashDamageRadius = 250
			bullet.Velocity = 10000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetOrigin( tr.HitPos )
				util.Effect( "lvs_laser_explosion_aat", effectdata )
			end
			ent:LVSFireBullet( bullet )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( Muzzle.Ang:Up() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:TakeAmmo()

			if not IsValid( ent.SNDTurret ) then return end

			ent.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end )
	end
	weapon.OnThink = function( ent, active )
		ent:AimTurretSecondary()
	end
	self:AddWeapon( weapon )
end
--PATH lua/entities/lvs_walker_hsd_leg.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/meteor/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/meteor/cl_init.lua:
ENT.Spawnable = false
ENT.AdminSpawnable = false

include("shared.lua")

language.Add("meteor", "meteor")

function ENT:Initialize()
    local mx, mn = self:GetRenderBounds()
    self:SetRenderBounds(mn + Vector(0,0,128), mx, 0)
    self.emitter = ParticleEmitter(LocalPlayer():GetShootPos())
end

local color_grey = Color(200, 200, 210)

function ENT:Think()
    local vOffset = self:LocalToWorld(VectorRand(-3, 3)) + VectorRand(-3, 3)
    local vNormal = (vOffset - self:GetPos()):GetNormalized()

    if not self.emitter then return end

    local particle = self.emitter:Add(Model("particles/smokey"), vOffset)
    particle:SetVelocity(vNormal * math.Rand(10, 30))
    particle:SetDieTime(2.0)
    particle:SetStartAlpha(math.Rand(50, 150))
    particle:SetStartSize(math.Rand(8, 16))
    particle:SetEndSize(math.Rand(32, 64))
    particle:SetRoll(math.Rand(-0.2, 0.2))
    particle:SetColor(color_grey)
end

function ENT:OnRemove()
    if IsValid(self.emitter) then
        self.emitter:Finish()
    end
end

--PATH lua/entities/mortar/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar"
ENT.Spawnable		=	true
ENT.Category 		=   "DolUnity"

ENT.AutomaticFrameAdvance = true
ENT.RotatingSteps = 0.25 * 100
ENT.AnglingSteps = 0.2 * 100
ENT.AnglingMax = 60
ENT.AnglingMin = 13

ENT.FireRate = 2.5
ENT.ShellChangeRate = 1
ENT.ShellClasses = {HE = "mortar_bomb_shell", SE = "mortar_smoke_shell", IN = "mortar_fire_shell"}

function ENT:Initialize()
    self:SetPredictable(true)
end

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "ShellClassId")
    self:NetworkVar("Int", 1, "NextShell")
    self:NetworkVar("Int", 2, "NextFire")
    self:NetworkVar("Entity", 3, "GunnerSeat")
end

function ENT:ChangeShell()
    if (self:GetNextShell() > CurTime()) then return end

    self:SetNextShell(CurTime() + self.ShellChangeRate)

    local id = self:GetShellClassId() + 1

    if (id > table.Count(self.ShellClasses)) then
        self:SetShellClassId(1)
    else
        self:SetShellClassId(id)
    end
end

function ENT:GetGunner()
    if (not IsValid(self:GetGunnerSeat())) then return NULL end

    return self:GetGunnerSeat():GetDriver()
end

function ENT:Think()
    if (self:Health() <= 0) then
        return
    end

    local gunner = self:GetGunner()
    local gunnerSeat = self:GetGunnerSeat()

    if (not IsValid(gunnerSeat)) then return end

    local rot = 0
    local ang = 0
    local mod = 1
    if (IsValid(gunner)) then
        if (gunner:KeyDown(IN_MOVELEFT)) then
            rot = self.RotatingSteps
        elseif (gunner:KeyDown(IN_MOVERIGHT)) then
            rot = -self.RotatingSteps
        elseif (gunner:KeyDown(IN_FORWARD)) then
            ang = self.AnglingSteps
        elseif (gunner:KeyDown(IN_BACK)) then
            ang = -self.AnglingSteps
        elseif (gunner:KeyDown(IN_RELOAD) and IsFirstTimePredicted()) then
            self:ChangeShell()
        elseif (gunner:KeyDown(IN_JUMP) and SERVER) then
            self:FireShell()
        end

        if (gunner:KeyDown(IN_SPEED)) then
            mod = 0.1
        end
    end

    rot = rot * mod * FrameTime()
    ang = ang * mod * FrameTime()


    --self:SetLocalAngles(self:GetLocalAngles() + Angle(0,z,0))
    local barrelId = self:LookupBone("Barrel")
    local barrelAngle = self:GetManipulateBoneAngles(barrelId) + Angle(rot,0,ang)
    barrelAngle.z = math.Clamp(barrelAngle.z, self.AnglingMin, self.AnglingMax)

    self:ManipulateBoneAngles(barrelId, barrelAngle)
    gunnerSeat:SetLocalAngles(gunnerSeat:GetLocalAngles() + Angle(0,rot,0))
    local seatPos = gunnerSeat:GetLocalPos()
    seatPos:Rotate(Angle(0, rot , 0))
    gunnerSeat:SetLocalPos(seatPos)

    local hipId = self:LookupBone("BipodHip")
    local hipAngle = 90 - barrelAngle.z
    self:ManipulateBoneAngles(hipId, Angle(0,0,hipAngle * 2 - 90))

    self.AnglePrc = (barrelAngle.z - self.AnglingMin) / self.AnglingMax
    local legL = self:LookupBone("BipodLegL")
    local legR = self:LookupBone("BipodLegR")
    self:ManipulateBoneAngles(legL, Angle(0,40 * self.AnglePrc,0))
    self:ManipulateBoneAngles(legR, Angle(0,-40 * self.AnglePrc,0))

    self:NextThink(CurTime())
    return true
end

--PATH lua/entities/mortar_bomb_shell/cl_init.lua:
return gluapack()()
--PATH addons/[mrs] mc_quests/lua/entities/mqs_ent/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	if self:GetEnablePhys() then return end
	self:InitRenderModel()
end

function ENT:InitRenderModel()
	self.RenderModel = ClientsideModel(self:GetCModel())
	self.RenderModel:SetPos(self:GetPos())
	self.RenderModel:SetParent(self)
	self.RenderModel:SetMaterial(self:GetMaterial())
	self.RenderModel:SetColor(self:GetColor())
	self:CallOnRemove("RenderModel", function()
		SafeRemoveEntity(self.RenderModel)
	end)
end

local questarrows = {}

function ENT:Draw()
	local Pos = self:GetPos()
	local Ang = self:GetAngles()
	local planeNormal = Ang:Up()
	if Pos:DistToSqr(LocalPlayer():GetPos()) > MQS.Config.QuestEntDrawDist ^ 2 then return end

	if self:GetEnablePhys() then
		self:DrawModel()
	else
		local sysTime = SysTime()
		local rotAng = Angle(Ang)
		self.rotationOffset = sysTime % 360 * 130
		rotAng:RotateAroundAxis(planeNormal, self.rotationOffset)

		if not IsValid(self.RenderModel) then
			self:InitRenderModel()
		end

		self.RenderModel:SetPos(Pos)
		self.RenderModel:SetAngles(rotAng)
	end

	if self:GetTPly() ~= LocalPlayer() then return end

	if not self:GetShowPointer() then return end

	if not questarrows[self] then questarrows[self] = true end
end

function ENT:OnRemove()
	questarrows[self] = nil
end

hook.Add( "PostDrawTranslucentRenderables", "DrawQuestIndicators", function( bDepth, bSkybox )
	for ent, _ in pairs(questarrows) do
		if not IsValid(ent) then return end

		local Pos = ent:GetPos()
		local eye = EyeAngles()

		if Pos:DistToSqr(LocalPlayer():GetPos()) > MQS.Config.QuestEntDrawDist ^ 2 then return end

		local q = MQS.HasQuest(LocalPlayer())

		if not q then return end

		if MQS.Quests[q.quest].objects[MQS.GetNWdata(LocalPlayer(), "quest_objective") or 0].type ~= "Collect quest ents" then
			continue
		end

		local max = ent:OBBMaxs()
		Pos.z = Pos.z + max.z + (20 + math.sin(CurTime() * 2) * 5)

		cam.Start3D2D(Pos, Angle(0,eye.y - 90,90), 0.2)
			MSD.DrawTexturedRect(-23, -23, 48, 64, MSD.Icons48.arrow_down_color, color_white)
		cam.End3D2D()
	end
end)
--PATH addons/[mrs] mc_quests/lua/entities/mqs_npc/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_decoy/cl_init.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_decoy/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_detonite/shared.lua:
AddCSLuaFile()

ENT.Base = "arc9_gsr_plantable"
ENT.PrintName = "Sequencer Charge"

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_detonite.mdl"
ENT.WeaponClass = "arc9_go_nade_landmines"
ENT.Bury = 2
ENT.DetectionRange = 70
ENT.ArmDelay = 3


function ENT:OnPlant()
    self:EmitSound("kraken/shared/beeps3.wav", 75, 100, 1, CHAN_AUTO)
end

function ENT:Think()
    if SERVER and self:GetArmed() then
        for _, i in ipairs(ents.FindInSphere(self:GetPos(), self.DetectionRange)) do
            if IsValid(i) and ((i:IsPlayer() and i:GetVelocity():Length2DSqr() >= 22500) or i:IsNPC() or i:IsNextBot()) then
                self:Detonate()
                break
            end
        end

        self:NextThink(CurTime() + 0.15)
        return true
    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local pos = self:GetPos() + self:GetUp() * 6
        local effectdata = EffectData()
        effectdata:SetOrigin(pos)

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            ParticleEffect("explosion_grenade", pos, self:GetAngles(), nil)
            local spos = pos

            local trs = util.TraceLine({
                start = spos + Vector(0, 0, 64),
                endpos = spos + Vector(0, 0, -32),
                filter = self
            })

            util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
            self:EmitSound("ArcCW_Kraken.Explosives.Explosion", 120, 100, 1, CHAN_AUTO)
        end

        local oldowner = self.Attacker or self:GetOwner()
        if not IsValid(oldowner) then
            oldowner = self
        end

        local d = Lerp(self:GetUp():Dot(Vector(0, 0, 1)), 0.25, 1)

        self:SetOwner(NULL)
        util.BlastDamage(oldowner, oldowner, pos, 128, 300 * d)
        util.BlastDamage(oldowner, oldowner, pos, 256, 150 * d)

        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
        local pos = self:GetPos() + self:GetUp() * 3

        if self:GetArmed() and math.sin(CurTime() * 1) >= 0.75 then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
            render.SetMaterial(Material("effects/blueflare1")) -- Tell render what material we want, in this case the flash from the gravgun
            render.DrawSprite(pos, 16, 16, Color(0, 183, 255)) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            self:EmitSound("kraken/shared/click3.wav", 75, 100, 1, CHAN_AUTO)
            cam.End3D()
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_thermal.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "Thermal Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_DEBRIS

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_thermal.mdl"
ENT.FuseTime = 5

ENT.BlastDamage = {
    [0] = 100,
    [1] = 300,
    [2] = 100,
}

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:SetPhysicsAttacker(self:GetOwner(), 10)

        util.PrecacheSound("kraken/explosives/thermaldetonator/beeps.wav")
        self:EmitSound("kraken/explosives/thermaldetonator/beeps.wav")
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))

            local tgt = data.HitEntity
            if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)
                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end
        elseif data.Speed > 25 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "grenade_final" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            util.ScreenShake(self:GetPos(), 25, 4, 1, self.Radius * 4)
            self:EmitSound("ArcCW_Kraken.Explosives.Explosion")
            
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 350)) do
           
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_BLAST)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(190 * f)
            dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
        end
        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 16))
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--PATH lua/entities/nmg_mark_ii_ewhn-10/cl_init.lua:
return gluapack()()
--PATH lua/entities/npc_vj_sbdnew_crowl/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_blasterrod.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Blaster Rod"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "Projectiles"
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local Name = "Blaster Rod"
	local LangName = "obj_vj_blasterrod"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.Model = {"models/weapons/w_missile_launch.mdl"} -- The models it should spawn with | Picks a random one from the table
/*ENT.DoesRadiusDamage = true -- Should it do a blast damage when it hits something?
ENT.RadiusDamageRadius = 10 -- How far the damage go? The farther away it's from its enemy, the less damage it will do | Counted in world units
ENT.RadiusDamage = 10 -- How much damage should it deal? Remember this is a radius damage, therefore it will do less damage the farther away the entity is from its enemy
ENT.RadiusDamageUseRealisticRadius = true -- Should the damage decrease the farther away the enemy is from the position that the projectile hit?
ENT.RadiusDamageType = DMG_SHOCK -- Damage type
ENT.RadiusDamageForce = 50 -- Put the force amount it should apply | false = Don't apply any force
ENT.RadiusDamageForceTowardsPhysics = 1000 -- How much force should it deal to props?*/
ENT.DoesDirectDamage = true -- Should it do a direct damage when it hits something?
ENT.DirectDamage = 10 -- How much damage should it do when it hits something
ENT.DirectDamageType = DMG_SHOCK -- Damage type
ENT.DecalTbl_DeathDecals = {"fadingscorch"}
ENT.SoundTbl_OnCollide = {"ambient/energy/spark4.wav"}
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnInitialize()
	self:SetMaterial("models/effects/vol_light001.mdl")
	self:DrawShadow(false)
	self:SetColor(Color(255,0,0))
	
	util.SpriteTrail(self, 0, Color(255,0,0,255), false, 15, 15, 0.2, 1/(10+1)*0.5, "VJ_Base/sprites/vj_trial1.vmt") //cable/redlaser.vmt
	//util.SpriteTrail(self,6,Color(200,0,0),true,6,6,0.1,1/(6+6)*0.5,"VJ_Base/sprites/vj_trial1.vmt")
	//ParticleEffectAttach("vj_rpg1_smoke", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	
	local eyeglow2 = ents.Create("env_sprite")
	eyeglow2:SetKeyValue("model","vj_base/sprites/vj_glow1.vmt")
	eyeglow2:SetKeyValue("scale","0.04")
	eyeglow2:SetKeyValue("rendermode","5")
	eyeglow2:SetKeyValue("rendercolor","255 0 0")
	eyeglow2:SetKeyValue("spawnflags","1") -- If animated
	eyeglow2:SetPos(self:GetPos())
	eyeglow2:SetParent(self)
	//eyeglow2:Fire("SetParentAttachment","eye2",0)
	eyeglow2:Spawn()
	eyeglow2:Activate()
	self:DeleteOnRemove(eyeglow2)

	/*self.StartLight1 = ents.Create("light_dynamic")
	self.StartLight1:SetKeyValue("brightness", "1")
	self.StartLight1:SetKeyValue("distance", "200")
	self.StartLight1:SetLocalPos(self:GetPos())
	self.StartLight1:SetLocalAngles( self:GetAngles() )
	self.StartLight1:Fire("Color", "255 0 0")
	self.StartLight1:SetParent(self)
	self.StartLight1:Spawn()
	self.StartLight1:Activate()
	self.StartLight1:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(self.StartLight1)*/
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:DeathEffects(data, phys)
	local effectData = EffectData()
	effectData:SetOrigin(data.HitPos)
	//effectData:SetMagnitude(500)
	util.Effect("StunstickImpact", effectData)
end
--PATH lua/entities/obj_vj_crossbowbolt.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Crossbow Bolt"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "Projectiles"
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local Name = "Crossbow Bolt"
	local LangName = "obj_vj_crossbowbolt"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.Model = {"models/crossbow_bolt.mdl"} -- The models it should spawn with | Picks a random one from the table
ENT.DoesDirectDamage = true -- Should it do a direct damage when it hits something?
ENT.DirectDamage = 90 -- How much damage should it do when it hits something
ENT.DecalTbl_DeathDecals = {"Impact.Concrete"}
ENT.SoundTbl_Idle = {"weapons/fx/nearmiss/bulletltor03.wav"}
ENT.SoundTbl_OnCollide = {"weapons/crossbow/hit1.wav"}

ENT.IdleSoundLevel = 60
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnInitializeBeforePhys()
	self:PhysicsInitSphere(1, "metal_bouncy")
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomPhysicsObjectOnInitialize(phys)
	phys:SetMass(1)
	phys:EnableGravity(false)
	phys:EnableDrag(false)
	phys:SetBuoyancyRatio(0)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnPhysicsCollide(data, phys)
	if IsValid(data.HitEntity) then
		self.SoundTbl_OnCollide = {"weapons/crossbow/hitbod1.wav","weapons/crossbow/hitbod2.wav"} // weapons/crossbow/bolt_skewer1.wav
		if data.HitEntity:IsNPC() && data.HitEntity:GetHullType() == HULL_TINY then
			data.HitEntity:Ignite(3)
		end
	else
		local bolt = ents.Create("prop_dynamic")
		bolt:SetModel("models/crossbow_bolt.mdl")
		bolt:SetPos(data.HitPos + data.HitNormal + self:GetForward()*-15)
		bolt:SetAngles(self:GetAngles())
		bolt:Activate()
		bolt:Spawn()
		timer.Simple(15, function() if IsValid(bolt) then bolt:Remove() end end)
	end
end
--PATH lua/entities/obj_vj_rcgg_rocket_swrc/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Leste"
ENT.Author 			= "SOMEBODY SAY HO!"
ENT.Contact 		= "http://steamcommunity.com/profiles/76561198180831682/"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "Projectiles"

if (CLIENT) then
	local Name = "Leste"
	local LangName = "obj_1187_leste"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_chair/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_npc/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_wall_logo/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_slot_machine/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.wheels = {}
	for i=1, 3 do
		local wheel = ClientsideModel("models/freeman/owain_slotmachine_reel.mdl")
		self.wheels[i] = wheel
		wheel:SetParent(self)
		wheel:SetPos(self:GetPos()+(self:GetUp()*5.5)+(self:GetForward()*-10)+((self:GetRight()*-6)*(i-2)))
		wheel:SetAngles(self:GetAngles())
	end

	self.active = false

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
end

function ENT:OnRemove()
	for k, v in pairs(self.wheels) do
		if IsValid(v) then v:Remove() end
	end
end

local colorGold = Color(255, 200, 0)
local colorPurple = Color(255, 0, 255)
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	if (not self.wheels) or (not self.wheels[1]) or (not IsValid(self.wheels[1])) then self:Initialize() return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	-- For ticking value
	self.curJackpot = math.Approach(self.curJackpot or self:GetCurrentJackpot(), self:GetCurrentJackpot(), math.Round((self.data.bet.default*5)*FrameTime()))

	-- Basic setups
	local pos = self:GetPos()
	local ang = self:GetAngles()
	
	ang:RotateAroundAxis(ang:Up(), 90)
	ang:RotateAroundAxis(ang:Forward(), 90)

	cam.Start3D2D(pos + (ang:Up()*-5.6) + (ang:Right()*-29.6), ang, 0.05)
		if tobool(self.data.jackpot.toggle) then
			draw.SimpleText(string.format(PerfectCasino.Translation.UI.JackPot, PerfectCasino.Config.FormatMoney(self.curJackpot)), "pCasino.Title.Static", 0, 0, (self.win and (self.win == 2)) and colorPurple or colorGold, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText((math.ceil(CurTime())%2 == 1) and PerfectCasino.Translation.UI.ReadyToPlay or "", "pCasino.Title.Static", 0, 0, colorGold, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	cam.End3D2D()
	
	ang:RotateAroundAxis(ang:Forward(), -20)

	cam.Start3D2D(pos + (ang:Up()*1.9) + (ang:Right()*5.1) + (ang:Forward()*5.5), ang, 0.05)
		draw.SimpleText(PerfectCasino.Config.FormatMoney(self.data.bet.default), "pCasino.Textbox.Static", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end

local cooldown = 0
function ENT:Think()
	if not self.active then return end
	if self.win then
		for i=1, 2 do
			local winLight = DynamicLight(self:EntIndex()+i)
			if winLight then
				winLight.pos = self:GetPos()+(self:GetUp()*13)+(self:GetForward()*-5)+((self:GetRight()*3)*(-3+(2*i)))
				winLight.r = (self.win == 2) and ((math.Round(CurTime()%1) == 1) and 100 or 0) or 100
				winLight.g = self.win == 2 and 0 or 100
				winLight.b = (self.win == 2) and 100 or 0 -- and ((math.Round(CurTime()%2) == 1) and
				winLight.brightness = 3
				winLight.Decay = 1000
				winLight.Size = 100
				winLight.DieTime = CurTime() + 1
			end
		end
	end

	for k, v in pairs(self.wheels) do
		if v.spinning then
			local ang = v:GetAngles()
			ang:RotateAroundAxis(v:GetRight(), -600*FrameTime())
			v:SetAngles(ang)
		elseif v.reject and (v.reject > 0) then
			local bump = math.Clamp(math.Round(300*FrameTime()), 1, v.reject)

			local ang = v:GetAngles()
			ang:RotateAroundAxis(v:GetRight(), bump)
			v:SetAngles(ang)
			v.reject = v.reject - bump
			if (k == 3) and (v.reject <= 0) and (not isnumber(self.win)) then
				self.active = false -- All the wheels are in the right place
			end
		end
	end
end

-- Game specific code
function ENT:StartSpinning(i)
	local wheel = self.wheels[i]
	if (not wheel) or (not IsValid(wheel)) then self:Initialize() return end

	local randomAng = self:GetAngles()
	randomAng:RotateAroundAxis(self:GetRight(), math.random(0, 360))
	wheel:SetAngles(randomAng)

	wheel.spinning = true
end

local resultCache = {}
resultCache["dollar"] = 0
resultCache["bell"] = 1
resultCache["melon"] = 2
resultCache["cherry"] = 3
resultCache["seven"] = 4
resultCache["clover"] = 5
resultCache["diamond"] = 6
resultCache["berry"] = 7

local snap = 360/table.Count(resultCache)
local offset = -35
local rejectionVaule = 20
function ENT:StopSpinning(i, result)
	local wheel = self.wheels[i]
	if (not wheel) or (not IsValid(wheel)) then self:Initialize() return end
	
	wheel.spinning = false

	if result then
		local angleResult = resultCache[result] * snap - offset

		local ang = self:GetAngles()
		ang:RotateAroundAxis(wheel:GetRight(), angleResult-rejectionVaule)
		wheel:SetAngles(ang)

		wheel.reject = rejectionVaule
	end
end

function ENT:StartWin(winData)
	-- 2 is jackpot, 1 is normal win
	self.win = (tobool(winData.j) and tobool(self.data.jackpot.toggle)) and 2 or 1
end

function ENT:EndWin()
	self.active = false
	self.win = nil
end

net.Receive("pCasino:BasicSlot:Spin:Start", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 500000 then return end
	if not entity.data then return end

	entity.active = true

	for i=1, 3 do
		entity:StartSpinning(i)
	end
end)

net.Receive("pCasino:BasicSlot:Spin:Stop", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.active then return end
	if not entity.data then return end

	local key = net.ReadUInt(2)
	local result = net.ReadString()
	entity:StopSpinning(key, result)
end)

net.Receive("pCasino:BasicSlot:Spin:Win", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.active then return end
	if not entity.data then return end

	local winData = net.ReadTable()
	entity:StartWin(winData)

	timer.Simple((tobool(winData.j) and tobool(entity.data.jackpot.toggle)) and 5 or 2, function()
		if not IsValid(entity) then return end
		entity:EndWin()
	end)
end)
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_wheel_slot_machine/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Wheel Slot Machine"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "CurrentJackpot")
end

PerfectCasino.Core.RegisterEntity("pcasino_wheel_slot_machine", {
	-- General data
	general = {
		limitUse = {d = false, t = "bool"}
	},
	-- Bet data
	bet = {
		default = {d = 1000, t = "num"}, -- The default bet
	},
	-- Combo data
	combo = {
		{c = {"gold", "gold", "gold"}, p = 0.5, j = false},
		{c = {"coins", "coins", "coins"}, p = 0.8, j = false},
		{c = {"emerald", "emerald", "emerald"}, p = 1, j = false},
		{c = {"bag", "bag", "bag"}, p = 1.6, j = false},
		{c = {"bar", "bar", "bar"}, p = 2, j = false},
		{c = {"coin", "coin", "coin"}, p = 2.5, j = false},
		{c = {"coin", "coin", "anything"}, p = 2, j = false},
		{c = {"anything", "coin", "coin"}, p = 2, j = false},
		{c = {"vault", "vault", "vault"}, p = 2.8, j = false},
		{c = {"chest", "anything", "anything"}, p = 0, j = true},
		{c = {"anything", "chest", "anything"}, p = 0, j = true},
		{c = {"anything", "anything", "chest"}, p = 0, j = true},
	},
	-- Combo data
	wheel = {
		{n = "$1,000", f = "money", i = 1000, p = "dolla"},
		{n = "$10,000", f = "money", i = 10000, p = "dolla"},
		{n = "$100,000", f = "money", i = 100000, p = "dolla"},
		{n = "$1,000,000", f = "money", i = 1000000, p = "dolla"},
		{n = "Jackpot!", f = "jackpot", i = 1000000, p = "diamond"},
		{n = "Nothing", f = "nothing", i = 1000000, p = "melon"},
		{n = "Free Spin", f = "prize_wheel", i = 0, p = "mystery_2"},
		{n = "$1", f = "money", i = 1, p = "dolla"},
		{n = "$1,000", f = "money", i = 1000, p = "dolla"},
		{n = "$100,000", f = "money", i = 100000, p = "dolla"},
		{n = "Nothing", f = "nothing", i = 1000000, p = "melon"},
		{n = "Jackpot!", f = "jackpot", i = 100000, p = "diamond"}
	},
	-- Jackpot data
	jackpot = {
		toggle = {d = true, t = "bool"}, -- The bell chance
		startValue = {d = 10000, t = "num"}, -- The bell chance
		betAdd = {d = 0.5, t = "num"}, -- The % of the bet to add to the jackpot
	},
	-- Chance data
	chance = {
		gold = {d = 15},
		coins = {d = 10},
		emerald = {d = 9},
		bag = {d = 8},
		bar = {d = 6},
		coin = {d = 6},
		vault = {d = 4},
		chest = {d = 1},
	},
},
"models/freeman/owain_slotmachine_wheel.mdl")
--PATH lua/entities/pfx1_08_~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Yellow]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_yellow"
--PATH lua/entities/pfx1_08_~_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Yellow]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_yellow"
--PATH lua/entities/pfx1_08~_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Blue]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_blue"
--PATH lua/entities/pfx1_09.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gasleak flame"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]g_leak_flame"
--PATH lua/entities/pfx1_0f.lua:
return gluapack()()
--PATH lua/entities/pfx2_01.lua:
return gluapack()()
--PATH lua/entities/pfx2_02_a.lua:
return gluapack()()
--PATH lua/entities/pfx2_04~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Swirl 2"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]swirl_rnd"
--PATH lua/entities/pfx2_05.lua:
return gluapack()()
--PATH lua/entities/pfx2_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "G-Man Starfield"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gman_lines"
--PATH lua/entities/pfx2_06~.lua:
return gluapack()()
--PATH lua/entities/pfx4_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Blue Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_b"

--PATH lua/entities/pfx4_03_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Green Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g_s"
--PATH lua/entities/pfx4_03~.lua:
return gluapack()()
--PATH lua/entities/pfx4_06_3.lua:
return gluapack()()
--PATH lua/entities/pfx4_08.lua:
return gluapack()()
--PATH lua/entities/pfx4_08.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Electric Beam"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]electric_beam"
--PATH lua/entities/pfx5_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole"
--PATH lua/entities/pfx5_00_alt.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Alt Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_b"
--PATH lua/entities/pfx5_00_alt_ss.lua:
return gluapack()()
--PATH lua/entities/pfx5_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Starfield 2"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]starfield_2"
--PATH lua/entities/pfx7_00.lua:
return gluapack()()
--PATH lua/entities/pfx8_06.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Magic Orb 2"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]orb_1"
--PATH lua/entities/pfx9_00.lua:
return gluapack()()
--PATH lua/entities/podracer.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "speeder_base"
ENT.Type = "vehicle"

ENT.PrintName = "Podracer"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Other"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.Vehicle = "Podracer";
ENT.EntModel = "models/sebracer/sebracer.mdl";
ENT.StartHealth = 1000;
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.NextUse = {Use = CurTime(),Fire = CurTime()};
ENT.FireSound = Sound("weapons/xwing_shoot.wav");

AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("podracer");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self.BaseClass.Initialize(self);
	local driverPos = self:GetPos()+self:GetUp()*155+self:GetForward()*-300+self:GetRight()*-5;
	local driverAng = self:GetAngles()+Angle(0,-90,0);
	self:SpawnChairs(driverPos,driverAng,false);
	self.CanBack = true;
	self.ForwardSpeed = 500;
	self.BoostSpeed = 1000
	self.AccelSpeed = 6;
end


function ENT:OnTakeDamage(dmg) --########## Shuttle's aren't invincible are they? @RononDex

	local health=self:GetNetworkedInt("Health")-(dmg:GetDamage()/2)

	self:SetNWInt("Health",health);
	
	if(health<100) then
		self.CriticalDamage = true;
		self:SetNWBool("CriticalDamage",true);
	end
	
	
	if((health)<=0) then
		self:Bang() -- Go boom
	end
end

local ZAxis = Vector(0,0,1);
function ENT:PhysicsSimulate( phys, deltatime )
	self.BackPos = self:GetPos()+self:GetForward()*-300+self:GetUp()*40;
	self.FrontPos = self:GetPos()+self:GetForward()*280+self:GetUp()*40;
	self.MiddlePos = self:GetPos()+self:GetUp()*40;
	if(self.Inflight) then
		local UP = ZAxis;
		self.RightDir = self.Entity:GetForward():Cross(UP):GetNormalized();
		self.FWDDir = self.Entity:GetForward();	


		
		self:RunTraces();

		self.ExtraRoll = Angle(0,0,self.YawAccel / 2*-1);
		if(!self.WaterTrace.Hit) then
			if(self.FrontTrace.HitPos.z >= self.BackTrace.HitPos.z) then
				self.PitchMod = Angle(math.Clamp((self.BackTrace.HitPos.z - self.FrontTrace.HitPos.z),-45,45)/2,0,0)
			else
				self.PitchMod = Angle(math.Clamp(-(self.FrontTrace.HitPos.z - self.BackTrace.HitPos.z),-45,45)/2,0,0)
			end
		end
	end

	
	self.BaseClass.PhysicsSimulate(self,phys,deltatime);
	

end

end

if CLIENT then
	ENT.Sounds={
		Engine=Sound("landspeeder_fly.wav"),
	}
	ENT.HasCustomCalcView = true;
	local Health = 0;
	function ENT:Think()
		self.BaseClass.Think(self);
		local p = LocalPlayer();
		local Flying = p:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then
			Health = self:GetNWInt("Health");
			local EnginePos = {
				Left = 	self:GetPos()+self:GetRight()*-106+self:GetUp()*96,
				Right = self:GetPos()+self:GetRight()*96+self:GetUp()*96,
			}
			self:Effects(EnginePos);
		end
		
	end

	local View = {}
	function CalcView()
		
		local p = LocalPlayer();
		local self = p:GetNWEntity("Podracer", NULL)
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);

		if(IsValid(self)) then

			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					local pos = self:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-600+self:GetUp()*250;
					//local face = self:GetAngles() + Angle(0,-90,0);
					local face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
						View.origin = pos;
						View.angles = face;
					return View;
				end
			end
		end
	end
	hook.Add("CalcView", "PodracerView", CalcView)
	
	hook.Add( "ShouldDrawLocalPlayer", "PodracerDrawPlayerModel", function( p )
		local self = p:GetNWEntity("Podracer", NULL);
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		if(IsValid(self)) then
			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					return true;
				end
			end
		end
	end);
	
	local function PodracerHUD()
	
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingPodracer");
		local self = p:GetNWEntity("Podracer");
		if(Flying and IsValid(self)) then

			SW_Speeder_DrawHull(1000)
			SW_Speeder_DrawSpeedometer()

		end
	end
	hook.Add("HUDPaint", "PodracerHUD", PodracerHUD)
end
--PATH lua/entities/prop_vj_animatable/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_e60r.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_heat.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer_allammo/shared.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer_allammo/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

local dispencer_health = GetConVar("rw_sw_dispenser_health"):GetInt()
ENT.BaseHealth = dispencer_health

ENT.PrintName		= "Ammo Dispenser (Holding Weapon)"
ENT.Author			= "ChanceSphere574"
ENT.Category		= "StarWars Reworked Armory"
ENT.Spawnable 		= true
ENT.AdminSpawnable	= false

ENT.UseTimer = CurTime()
ENT.Status   = 0

ENT.LoadingSkin = 3
ENT.CurSkin = 7
--PATH lua/entities/rw_sw_dispencer_health/cl_init.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer_health/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/sent_bactagrenade/shared.lua:
return gluapack()()
--PATH lua/entities/sent_swrc_det/shared.lua:
return gluapack()()
--PATH lua/entities/sent_vj_board.lua:
return gluapack()()
--PATH lua/entities/sent_vj_test/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_ai"
ENT.Type 			= "ai"
ENT.PrintName 		= "VJ Test NPC"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Just a testing NPC."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = false
ENT.AdminOnly = false
ENT.AutomaticFrameAdvance = true

function ENT:SetAutomaticFrameAdvance(bUsingAnim)
	self.AutomaticFrameAdvance = bUsingAnim
end

if CLIENT then
	function ENT:Draw() self:DrawModel() end
	
	net.Receive("vj_testentity_onmenuopen", function()
		local welMsgs = {
			"Welcome to my shop, how can I help you?",
			"Hi!",
			"Hello "..LocalPlayer():GetName()..", You need anything?",
			"What can I do for you "..LocalPlayer():GetName().."?",
			"This ain't cheap stuff, but it is good!",
		}
	
		local frame = vgui.Create("DFrame")
		frame:SetSize(600, 300)
		frame:SetPos(ScrW()*0.5, ScrH()*0.5)
		frame:SetTitle('VJ Test Menu')
		//frame:SetBackgroundBlur(true)
		frame:SetSizable(true)
		frame:SetDeleteOnClose(false)
		frame:MakePopup()

		local label_wel = vgui.Create("DLabel", frame)
		label_wel:SetPos(10, 30)
		label_wel:SetText(VJ_PICK(welMsgs))
		label_wel:SizeToContents()
		
		local button_kill = vgui.Create("DButton", frame)
		button_kill:SetText("Kill Yourself")
		button_kill:SetPos(10, 50)
		button_kill:SetSize(100, 50)
		button_kill.DoClick = function()
			RunConsoleCommand("kill")
			LocalPlayer():EmitSound(Sound("vj_misc/illuminati_confirmed.mp3"), 0, 200)
		end
		
		local label_admin = vgui.Create("DLabel", frame)
		label_admin:SetPos(10, 110)
		label_admin:SetText("NOTE: Only admins can use these buttons! Most of this commands require 'sv_cheats' to be 1")
		label_admin:SizeToContents()
		
		local button_god = vgui.Create("DButton", frame)
		button_god:SetText("Toggle God Mode")
		button_god:SetPos(10, 130)
		button_god:SetSize(100, 50)
		button_god.DoClick = function()
			if LocalPlayer():IsAdmin() then RunConsoleCommand("god") end
		end
		
		local button_buddha = vgui.Create("DButton", frame)
		button_buddha:SetText("Toggle Buddha")
		button_buddha:SetPos(120, 130)
		button_buddha:SetSize(100, 50)
		button_buddha.DoClick = function()
			if LocalPlayer():IsAdmin() then RunConsoleCommand("buddha") end
		end
		
		local button_fp = vgui.Create("DButton", frame)
		button_fp:SetText("Firstperson")
		button_fp:SetPos(230, 130)
		button_fp:SetSize(100, 50)
		button_fp.DoClick = function()
			if LocalPlayer():IsAdmin() then RunConsoleCommand("firstperson") end
		end
		
		local button_tp = vgui.Create("DButton", frame)
		button_tp:SetText("Thirdperson")
		button_tp:SetPos(340, 130)
		button_tp:SetSize(100, 50)
		button_tp.DoClick = function()
			if LocalPlayer():IsAdmin() then RunConsoleCommand("thirdperson") end
		end
		
		if LocalPlayer():SteamID() == "STEAM_0:0:22688298" then
			local button_vj = vgui.Create("DButton", frame)
			button_vj:SetText("Illuminati")
			button_vj:SetPos(10, 170)
			button_vj:SetSize(50, 30)
			button_vj.DoClick = function()
				net.Start("vj_testentity_runtextsd")
				net.WriteBool(false)
				net.SendToServer()
			end
			
			local button_sd = vgui.Create("DButton", frame)
			button_sd:SetText("THIRSTY")
			button_sd:SetPos(120, 170 )
			button_sd:SetSize(50, 30)
			button_sd.DoClick = function()
				net.Start("vj_testentity_runtextsd")
				net.WriteBool(true)
				net.SendToServer()
			end
		end
	end)
end
--PATH gamemodes/starwarsrp/entities/entities/spawned_money/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/spawned_money/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Spawned Money"
ENT.Author = "FPtje"
ENT.Spawnable = false
ENT.IsSpawnedMoney = true

function ENT:SetupDataTables()
    self:NetworkVar("Int",0,"amount")
end
--PATH gamemodes/starwarsrp/entities/entities/spawned_shipment/cl_init.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/entities/star_metor/cl_init.lua:
ENT.Spawnable = false
ENT.AdminSpawnable = false

include("shared.lua")

language.Add("meteor", "meteor")

function ENT:Initialize()
    local mx, mn = self:GetRenderBounds()
    self:SetRenderBounds(mn + Vector(0,0,128), mx, 0)
    self.emitter = ParticleEmitter(LocalPlayer():GetShootPos())
end

function ENT:Think()
    local vOffset = self:LocalToWorld(Vector(math.Rand(-3, 3), math.Rand(-3, 3), math.Rand(-3, 3))) + Vector(math.Rand(-3, 3), math.Rand(-3, 3), math.Rand(-3, 3))
    local vNormal = (vOffset - self:GetPos()):GetNormalized()

    if not self.emitter then return end

    local particle = self.emitter:Add(Model("particles/smokey"), vOffset)
    particle:SetVelocity(vNormal * math.Rand(10, 30))
    particle:SetDieTime(2.0)
    particle:SetStartAlpha(math.Rand(50, 150))
    particle:SetStartSize(math.Rand(8, 16))
    particle:SetEndSize(math.Rand(32, 64))
    particle:SetRoll(math.Rand(-0.2, 0.2))
    particle:SetColor(Color(200, 200, 210))
end

function ENT:OnRemove()
    if IsValid(self.emitter) then
        self.emitter:Finish()
    end
end

--PATH lua/entities/tfa_csgo_fire_2/shared.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.AdminSpawnable = false


function ENT:Draw()
	
end

function ENT:Initialize()
	self:SetNWBool("extinguished",false)
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_incendiary.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		self:DrawShadow( false )
	end
	ParticleEffect( "molotov_explosion", self:GetPos(), self:GetAngles() )
	self:EmitSound( "TFA_CSGO_Inferno.Loop" )
end

function ENT:Think()
	if self:GetNWBool("extinguished",true) then
		ParticleEffect( "extinguish_fire", self:GetPos(), self:GetAngles() )
		self:Remove()
	end
end

function ENT:OnRemove()
	self:EmitSound( "TFA_CSGO_Inferno.FadeOut" )
    self:StopSound( "TFA_CSGO_Inferno.Loop" )
end
--PATH lua/entities/tfa_exp_contact.lua:
AddCSLuaFile()

ENT.Base = "tfa_exp_base"
ENT.PrintName = "Contact Explosive"

function ENT:PhysicsCollide(data, phys)
	if data.Speed > 60 then
		self.killtime = -1
	end
end
--PATH lua/entities/tfa_exp_rocket.lua:
return gluapack()()
--PATH lua/entities/tfbow_arrow_stuck/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "TFBow Arrow Stuck"
ENT.Author = "TheForgottenArchitect"
ENT.Contact = "Don't"
ENT.Purpose = "Arrow Entity"
ENT.Instructions = "Arrow that's stuck in ground"

local cv_al = GetConVar("sv_tfa_arrow_lifetime")

function ENT:Initialize()
	if SERVER then
		if cv_al:GetInt() ~= -1 then
			timer.Simple( cv_al:GetFloat(), function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(2)
		end

		if IsValid(self) and self.SetUseType then
			self:SetUseType(SIMPLE_USE)
		end
	end

	if (self:GetModel() and self:GetModel() == "") then
		self:SetModel("models/weapons/w_tfa_arrow.mdl")
	end

	self:SetOwner(nil)
	self.PhysicsCollide = function() end
	self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	local phys = self:GetPhysicsObject()

	if (phys:IsValid()) then
		phys:Sleep()
	end
end

function ENT:Use(activator, caller)
	if activator:IsPlayer() and activator:GetWeapon(self.gun) then
		activator:GiveAmmo(1, activator:GetWeapon(self.gun):GetPrimaryAmmoType(), false)
		self:Remove()
	end
end

--PATH lua/entities/tfbow_arrow_stuck_clientside/cl_init.lua:
return gluapack()()
--PATH lua/entities/torpedo_blast.lua:

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Torpedo Blast"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars"
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.IsTorpedo = true;
if SERVER then
	AddCSLuaFile()
	function ENT:Initialize()
	
		self:SetModel("models/props_junk/PopCan01a.mdl");
		self:SetSolid(SOLID_VPHYSICS);
		self:SetMoveType(MOVETYPE_VPHYSICS);
		self:PhysicsInit(SOLID_VPHYSICS);
		self:StartMotionController();
		self:SetUseType(SIMPLE_USE);
		self:SetRenderMode(RENDERMODE_TRANSALPHA);
		self:SetColor(Color(255,255,255,1));
		self:StartMotionController();
		//self:SetCustomCollisionCheck(true)
		self:SetNWVector("Color",Vector(self.SpriteColour.r,self.SpriteColour.g,self.SpriteColour.b));

		self:SetNWInt("StartSize",self.StartSize or 20);
		self:SetNWInt("EndSize",self.EndSize or 15);
		
		self.Damage = self.Damage or 500;

		local phys = self:GetPhysicsObject();
		phys:SetMass(100);
		phys:EnableGravity(false);
		phys:Wake()
	end
    
	function ENT:PrepareTorpedo(e,s,vel)
		self.Shooter = e;
		e:EmitSound(s)
		self.Velocity = math.Clamp(vel,700,2000);
	end
	
	function ENT:Think()
		if(self.Targetting) then
			if(IsValid(self.Target)) then
				self:SetAngles((self.Target:GetPos() - self:GetPos()):Angle());	
			else
				self.Targetting = false;
			end		
		end
	end
	
	local FlightPhys = {
		secondstoarrive	= 1;
		maxangular		= 50000;
		maxangulardamp	= 10000000;
		maxspeed			= 1000000;
		maxspeeddamp		= 500000;
		dampfactor		= 0.8;
		teleportdistance	= 5000;
	};
	function ENT:PhysicsSimulate(phys,delta)

		local ang = self.Ang or self:GetForward():Angle();
		if(self.Targetting) then
			if(IsValid(self.Target)) then
				ang = (self.Target:GetPos() - self:GetPos()):Angle();	
			else
				self.Targetting = false;
			end		
		end
		FlightPhys.angle = ang;
		FlightPhys.pos = self:GetPos()+self:GetForward()*self.Velocity;
		FlightPhys.deltatime = delta;
		phys:ComputeShadowControl(FlightPhys);
	end
	
	function ENT:PhysicsCollide(data, physobj)
	
		if(IsValid(self.Shooter) and IsValid(data.HitEntity)) then
			if(data.HitEntity == self.Shooter) then
				return
			end
		end
	
		local pos = self:GetPos();
		local fx = EffectData()
			fx:SetOrigin(pos);
		util.Effect("Explosion",fx,true,true);

		local e = data.HitEntity;
		if(IsValid(e) and e.IsSWVehicle) then
			if(self.Ion) then
				e.IonShots = 10;
			end
			e:TakeDamage(self.Damage);
		end
		self:Remove()
	end
	
end

if CLIENT then

	function ENT:Initialize()	
		self.FXEmitter = ParticleEmitter(self:GetPos())
	end
	
	function ENT:Draw()
		
		self:DrawModel();
		
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		
		local StartSize = self:GetNWInt("StartSize");
		local EndSize = self:GetNWInt("EndSize");
		
		local sprite;
		local c = self:GetNWVector("Color");
		if(IsWhite) then
			sprite = "sprites/white_blast";
		else
			sprite = "sprites/bluecore";
		end

		local blue = self.FXEmitter:Add(sprite,self:GetPos())
		blue:SetVelocity(normal)
		blue:SetDieTime(0.05)
		blue:SetStartAlpha(255)
		blue:SetEndAlpha(255)
		blue:SetStartSize(StartSize)
		blue:SetEndSize(EndSize)
		blue:SetRoll(roll)
		blue:SetColor(c.x,c.y,c.z)
		
	end
end
--PATH lua/entities/training_orb/cl_init.lua:
include('shared.lua')
function ENT:Draw()
    -- self.BaseClass.Draw(self) -- Overrides Draw
    self:DrawModel() -- Draws Model Client Side
 
end
--PATH lua/entities/turbolaser/shared.lua:
return gluapack()()
--PATH lua/entities/tx-ex/shared.lua:
return gluapack()()
--PATH lua/entities/unitys-lvs-tx-2112/cl_lights.lua:
return gluapack()()
--PATH lua/effects/arccw_incendiaryround.lua:
local images_muzzle = {"effects/muzzleflash1", "effects/muzzleflash2", "effects/muzzleflash3", "effects/muzzleflash4"}
local images_smoke = {"particle/smokesprites_0001", "particle/smokesprites_0002", "particle/smokesprites_0003", "particle/smokesprites_0004", "particle/smokesprites_0005", "particle/smokesprites_0006", "particle/smokesprites_0007", "particle/smokesprites_0008", "particle/smokesprites_0009", "particle/smokesprites_0010", "particle/smokesprites_0011", "particle/smokesprites_0012", "particle/smokesprites_0013", "particle/smokesprites_0014", "particle/smokesprites_0015", "particle/smokesprites_0016"}

local function TableRandomChoice(tbl)
    return tbl[math.random(#tbl)]
end

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()

    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )

    for i = 0,3 do
        local particle = emitter:Add( TableRandomChoice(images_smoke) , self.Origin )
        local scol = math.Rand( 200, 225 )

        particle:SetVelocity( 50 * VectorRand() )
        particle:SetDieTime( math.Rand(0.2, 0.5) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,30) )
        particle:SetEndSize( math.Rand(50,75) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( scol,scol,scol )
        particle:SetAirResistance( 100 )
        particle:SetGravity( Vector( math.Rand(-30,30) ,math.Rand(-30,30),math.Rand(10,40)) )
        particle:SetLighting( true )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    local particle = emitter:Add( "sprites/heatwave", self.Origin )
        particle:SetAirResistance( 0 )
        particle:SetDieTime( 0.5 )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 255 )
        particle:SetStartSize( 100 )
        particle:SetEndSize( 0 )
        particle:SetRoll( math.Rand(180,480) )
        particle:SetRollDelta( math.Rand(-5,5) )
        particle:SetColor( 255, 255, 255 )

    for i = 0, 2 do
        local fire = emitter:Add( TableRandomChoice(images_muzzle), self.Origin )
        fire:SetVelocity(VectorRand() * 100)
        fire:SetAirResistance( 0 )
        fire:SetDieTime( 0.25 )
        fire:SetStartAlpha( 255 )
        fire:SetEndAlpha( 0 )
        fire:SetEndSize( 0 )
        fire:SetStartSize( 50 )
        fire:SetRoll( math.Rand(180,480) )
        fire:SetRollDelta( math.Rand(-1,1) )
        fire:SetColor( 255, 255, 255 )
    end

    local light = DynamicLight(self:EntIndex())
    if (light) then
        light.Pos = self.Origin
        light.r = 255
        light.g = 206
        light.b = 122
        light.Brightness = 5
        light.Decay = 2500
        light.Size = 256
        light.DieTime = CurTime() + 0.1
    end

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/arccw_tracer.lua:
return gluapack()()
--PATH lua/effects/astra_beam.lua:
return gluapack()()
--PATH lua/effects/astw2_swrc_explosion_emp_grenade/init.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/cod2019_muzzle_he2/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_nade_flash_light/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_tracer_fast/init.lua:
EFFECT.TracerName = "mw2019_tracer_fast"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    local hit = data:GetOrigin()
    local wep = data:GetEntity()
    if !IsValid(wep) then return end
	local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()
    self.Attachment = data:GetAttachment() or 1

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.StartPos = start
    self.EndPos = hit
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_ABSORIGIN, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.StartPos)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(1.2, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--PATH lua/effects/cod2019_tracer_slow/init.lua:
EFFECT.TracerName = "mw2019_tracer_slow"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    local hit = data:GetOrigin()
    local wep = data:GetEntity()
    if !IsValid(wep) then return end
	local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()
    self.Attachment = data:GetAttachment() or 1

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.StartPos = start
    self.EndPos = hit
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_ABSORIGIN, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.StartPos)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(1.2, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--PATH addons/[miecze] moce i hilty/lua/effects/corvinus_ignite_effect.lua:
function EFFECT:Init(data)
    self.Ent = data:GetEntity()

    self.LifeTime = 0.2
    self.DieTime = CurTime() + self.LifeTime

    if IsValid(self.Ent) then
        local Dir = self.Ent:GetAimVector()
        local StartPos = self.Ent:GetShootPos() - Dir * 25
        local EndPos = StartPos + Dir * 625
        self:SetRenderBoundsWS(StartPos, EndPos)
    end
end

function EFFECT:Think()
    if self.DieTime < CurTime() or not IsValid(self.Ent) then
        return false
    end

    return true
end

local BeamMat = Material("effects/lethal_company/flame03_hollow")
local mat = Material("effects/lethal_company/flame02_hollow")

function EFFECT:Render()
    if IsValid(self.Ent) then
        local boneID = self.Ent:LookupBone("ValveBiped.Bip01_L_Hand")

        if boneID then
            local T = CurTime() * 10

            local X = math.cos(T) * math.cos(T * 10) * 4
            local Y = math.sin(T) * math.cos(T * 10) * 4
            local pos, ang = self.Ent:GetBonePosition(boneID)
            local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

            if not self.TargetPos then
                self.TargetPos = self.Ent:GetEyeTrace().HitPos

                local dlight = DynamicLight(self.Ent:EntIndex() + math.random(0, 99))
                if dlight then
                    dlight.pos = StartPos
                    dlight.r = 255
                    dlight.g = 255
                    dlight.b = 255
                    dlight.brightness = 3
                    dlight.Decay = 2000
                    dlight.Size = 150
                    dlight.DieTime = CurTime() + 0.1
                end
            end

            local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X, Y, 0)):Forward()
            local EndPos = StartPos + Dir * math.random(200, 600)

            local trace = util.TraceLine({start = StartPos, endpos = EndPos, filter = self.Ent})

            if (self.HitFX or 0) < CurTime() then
                self.HitFX = CurTime() + 0.01

                if trace.Hit then
                    local effectdata = EffectData()
                    effectdata:SetOrigin(trace.HitPos + trace.HitNormal)
                    effectdata:SetNormal(-trace.HitNormal)
                    util.Effect("force_lightning_hit", effectdata)

                    if math.random(1, 3) == 3 then
                        local dlight = DynamicLight(self.Ent:EntIndex() + math.random(100, 9999))
                        if dlight then
                            dlight.pos = trace.HitPos + trace.HitNormal
                            dlight.r = 255
                            dlight.g = 150
                            dlight.b = 255
                            dlight.brightness = 3
                            dlight.Decay = 2000
                            dlight.Size = 100
                            dlight.DieTime = CurTime() + 0.01
                        end

                        self:EmitSound("lscs/force/lightninghit" .. math.random(1, 3) .. ".mp3")
                    end
                end
            end

            render.SetMaterial(mat)
            render.DrawSprite(StartPos, 64, 64, Color(0, 50, 255, 255))
            render.DrawSprite(StartPos, 16, 16, Color(255, 255, 255, 255))

            local BeamStart = StartPos
            local BeamPrevious = BeamStart
            local BeamEnd = trace.HitPos
            local BeamSub = BeamEnd - BeamStart
            local BeamDir = BeamSub:GetNormalized()
            local BeamDistance = (BeamSub):Length()
            local SegmentLength = 50

            render.SetMaterial(BeamMat)

            render.DrawBeam(BeamStart, BeamEnd, 18, 0, 1, Color(255, 255, 255, 255))

            for SegmentStart = 0, BeamDistance, SegmentLength do
                local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8, 8), math.Rand(-8, 8), 0)):Forward() * SegmentLength

                local Width = (SegmentStart / BeamDistance)
                if SegmentStart + SegmentLength >= BeamDistance then
                    SegmentEnd = BeamEnd
                end

                render.DrawBeam(BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color(255, 150 + 155 * Width, 255, 255))

                local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20, 20), math.Rand(-20, 20), 0)):Forward() * SegmentLength * 0.5

                render.DrawBeam(SegmentEnd, BranchEnd1, math.Rand(8, 16) * (1 - Width), 0, 0.2, Color(255, 255, 255, 255))
                render.DrawBeam(BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6, 6), math.Rand(-6, 6), 0)):Forward() * SegmentLength * 1.5, math.Rand(4, 8) * (1 - Width), 0, 1.5, Color(255, 255, 255, 255))

                BeamPrevious = SegmentEnd
            end
        end
    end
end
--PATH lua/effects/csgo_muzzle_huntingrifle_ssg/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_shotgun/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_shotgun"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_nade_smokenade/init.lua:
return gluapack()()
--PATH lua/effects/dark_succumb.lua:
local mat_glow = Material( "models/elemental/darkened.vmt" )

EFFECT.DecalTime = 0

EFFECT.Origin = Vector( 0, 0, 0 )
EFFECT.Edge = Vector( 0, 0, 0 )
EFFECT.Direction = false
EFFECT.DirectionSet = false


function EFFECT:Init( data )

	self.Time = 3.1
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	self.Flags = data:GetFlags()
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self

	ParticleEffectAttach( "umbra_succumb", PATTACH_ABSORIGIN_FOLLOW, ent, 0 ) 
	
	self.Origin = data:GetOrigin() || self:GetPos()

end

local m_decal = Material( util.DecalMaterial( "beersplash" ) )

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	local PNormal = ( EyePos() - PPos ):GetNormal()
	self:SetPos( PPos + PNormal )
	
	if ( self.LifeTime > CurTime() ) then
		if ( self.DecalTime < CurTime() ) then
			-- util.Decal( "beersplash", PPos + Vector( 0, 0, 24 ), PPos - Vector( 0, 0, 24 ), self.Parent )
			util.DecalEx( m_decal, self.ParentEntity, PPos, self.Edge * -1, color_white, 256, 256 )

			-- debugoverlay.Line( PPos, PPos - self.Edge * 64, 0.2, color_white, true )
			-- debugoverlay.Cross( PPos, 16, 0.2, color_white, true )
			
			self.DecalTime = CurTime() + 0.2
		end
	
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil

	local bones = self.ParentEntity:GetBoneCount()
	for bone = 1, bones-1 do
		local scale = self.ParentEntity:GetManipulateBoneScale( bone )
		self.ParentEntity:ManipulateBoneScale( bone, Vector( 1, 1, 1 ) )
	end	
			
	return false
	
end

function EFFECT:Render()

	if ( self.Flags == 8 ) then
		self:RenderOverlay( self.ParentEntity )
	end

end

function EFFECT:RenderOverlay( entity )
	
	local fFraction = ( self.LifeTime - CurTime() ) / self.Time
	fFraction = math.Clamp( fFraction, 0, 1 )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local Pos = EyePos() + EyeNormal * Distance * 0.01
	local bClipping = self:StartClip( entity, 0.6 )
	
	cam.Start3D( Pos, EyeAngles() )
		render.MaterialOverride( mat_glow )
		entity:DrawModel()
		render.MaterialOverride()
	cam.End3D()
	
	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )
	
--	local evilmath = 2 * 2 ^ ( fFractionReversed - fFraction )
--	evilmath = evilmath * 0.125

end

function EFFECT:RenderParent()

	local fx = self.SpawnEffect
	local fFraction = ( fx.LifeTime - CurTime() ) / ( fx.Time * 0.6 )
	fFraction = math.Clamp( fFraction, 0, 1 )

	local fFractionReversed = ( 1 - fFraction ) * 2
	
--	render.SetBlend( fFraction )

	local fBoneScalar = ( 1 - ( 1 - fFraction ) * 0.04 )

	local bones = self:GetBoneCount()
	for bone = 1, bones-1 do
		local scale = self:GetManipulateBoneScale( bone )
		self:ManipulateBoneScale( bone, scale * fBoneScalar )
	end	
	
	local bClipping = self.SpawnEffect:StartClip( self, 0.4 )
	
	render.SetColorModulation( 1 - fFractionReversed, 1 - fFractionReversed, 1 - fFractionReversed )
	
	mat_glow:SetFloat( "$FleshBorderWidth", math.max( 4 * fFraction - 4 * fFractionReversed, 0 ) )
	
	render.MaterialOverride()
	self:DrawModel()
	
	render.SetColorModulation( 1, 1, 1 )
	
--	render.SetBlend( 1 )
	
	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )

	self.SpawnEffect:RenderOverlay( self )
	
end

function EFFECT:StartClip( model, spd )

	local mn, mx = model:GetRenderBounds()
	local me = model:EyePos()
	local mc = model:OBBCenter()

	local Top, Bottom, Up
	
	if ( !self.DirectionSet ) then
		self.Direction = ( self.Origin:Dot( mc ) > 0 )
		self.DirectionSet = true
	end
	
	if ( self.Direction ) then
		Top = me + mn
		Bottom = me + mx
		Up = (mx-mn):GetNormal()
	else
		Top = me + mx
		Bottom = me + mn
		Up = (mn-mx):GetNormal()
	end

	local Fraction = ( self.LifeTime - CurTime() ) / self.Time
	Fraction = math.Clamp( Fraction / spd, 0, 1 )
	
	local Lerped = LerpVector( Fraction, Bottom, Top )
	
	local normal = ( Bottom - Top ):GetNormal() -- Up 
	local distance = normal:Dot( Lerped )
	local bEnabled = render.EnableClipping( true )
	render.PushCustomClipPlane( normal, distance )
	
	self.Edge = normal

	local mLight = DynamicLight( self.ParentEntity:EntIndex() * -1 )
	if ( mLight ) then
		local fLightFrac = ( self.LifeTime - CurTime() ) / ( self.Time * 0.5 )
		fLightFrac = math.Clamp( 1 - fLightFrac, 0, 1 )
		local mScale = math.sin( fLightFrac * 2 )

		mLight.pos = Lerped
		mLight.r = 230
		mLight.g = 60
		mLight.b = 40
		mLight.brightness = 1 * mScale
		mLight.Size = 80 + 200 * mScale
		mLight.Decay = 512
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end

	return bEnabled
	
end
--PATH lua/effects/effect_astw2_swrc_elite_laser_beam_impact/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/swbf/sparks" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/swrc/elite_beam_impact", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.5 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 25, 30 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--PATH lua/effects/effect_astw2_swrc_laser_blue_sniper/init.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_laser_green/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_blue_akimbo/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_blue_main" );
local MaterialFront			= Material( "effects/sw_laser_blue_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		local att = 2 - entity.AnimCycle or data:GetAttachment()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(att)

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_white_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_white_main" )
local MaterialFront			= Material( "effects/sw_laser_white_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_yellow/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_yellow_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_yellow_main")
local MaterialFront = Material("effects/sw_laser_yellow_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_yellow_old/init.lua:
return gluapack()()
--PATH lua/effects/eml_tracer_cryo.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"eml_tracer_cryo", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH addons/[miecze] moce i hilty/lua/effects/extinguish_effect.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_judgement_hit.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_judgementii.lua:

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 21
					dlight.g = 255
					dlight.b = 0
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect( "force_judgementii_hit", effectdata )

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 21
							dlight.g = 255
							dlight.b = 0
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 21, 255, 0) ) --Elden Cikan Yes
			render.DrawSprite( StartPos, 16, 16, Color( 21, 255, 0, 255) ) --Bilmiyorum

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 21, 255, 0) ) --Az Elektrik

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 21, 255 + 150 * Width, 0, 255 ) ) --Etraftaki Cok Fazla Elektrik

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 21, 255, 0, 255 ) ) --Aradakilerin yarisi 
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 21, 255, 0) ) --Kalanlar

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningiii_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 179, 0, 255, 255) ) -- DEĞİŞTİRİLECEK RENK
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningiv.lua:

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 179 --EDİT
					dlight.g = 0 --EDİT
					dlight.b = 255 --EDİT
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect( "force_lightningiv_hit", effectdata )

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 179 --EDİT
							dlight.g = 0 --EDİT
							dlight.b = 255 --EDİT
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 179, 0, 255) ) --Elden Cikan Yes
			render.DrawSprite( StartPos, 16, 16, Color( 255, 0, 0, 255) ) --Bilmiyorum

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 255, 0, 0) ) --Az Elektrik

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 179, 0 + 150 * Width, 255, 255 ) ) --Etraftaki Cok Fazla Elektrik

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 255, 0, 0, 255 ) ) --Aradakilerin yarisi 
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 179, 0, 255) ) --Kalanlar

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_replenish.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE


EFFECT.mat = Material( "sprites/light_glow02_add" )


function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()

	self.LifeTime = 1
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then return end

	self.Model = ClientsideModel( self.Ent:GetModel(), RENDERGROUP_TRANSLUCENT )

	self.Model:SetMaterial("models/alyx/emptool_glow")
	self.Model:SetColor( Color(255,0,0,255) )
	self.Model:SetParent( self.Ent, 0 )
	self.Model:SetMoveType( MOVETYPE_NONE )
	self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
	self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
	self.Model:AddEffects( EF_BONEMERGE )

	for i = 0,self.Ent:GetBoneCount() do
		self.Model:ManipulateBoneScale( i, Vector(1,1,1) * 1.1 )
	end

	for i = 0, self.Ent:GetNumBodyGroups() do
		self.Model:SetBodygroup(i, self.Ent:GetBodygroup(i))
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) or (self.Ent.Alive and not self.Ent:Alive()) then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end

	if IsValid( self.Model ) then
		self.Model:SetColor( Color(255 * (self.DieTime - CurTime()) / self.LifeTime,0,0,255) )
	end

	return true
end

function EFFECT:Render()
	if not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.mat )
	render.DrawSprite( self.Ent:LocalToWorld( Vector(0,0,40) ), 250 * Scale, 250 * Scale, Color( 150 * Scale, 0, 0, 150 * Scale ) )
end
	

--PATH lua/effects/gravrifle_hit.lua:
return gluapack()()
--PATH lua/effects/hmp_concussion_trail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "effects/select_ring" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		if particle then
			particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
			particle:SetVelocity( -self.Entity:GetForward() * 200  )
			particle:SetAirResistance( 600 ) 
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(5,6) )
			particle:SetEndSize( math.Rand(12,30) )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 255,255,255 )
			particle:SetCollide( false )
		end

		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(20,15) )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 0.25 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(6,10) )
			particle:SetEndSize( math.Rand(2,3) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity
	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )

	render.DrawSprite( pos, 100, 100, Color( 0, 0, 0, 0 ) )
end

--PATH lua/effects/lvs_bullet_impact_explosive.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	self.Dir = data:GetNormal()
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local scale = data:GetMagnitude() * 0.5

	self.Scale = 3 * scale

	local emitter = ParticleEmitter( self.Pos, false )

	local VecCol = (render.GetLightColor( self.Pos + self.Dir ) * 0.5 + Vector(0.1,0.09,0.075)) * 255

	local DieTime = math.Rand(0.8,1.6)

	local traceSky = util.TraceLine( {
		start = self.Pos,
		endpos = self.Pos + Vector(0,0,50000),
		filter = self,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = self.Pos - Vector(0,0,100),
		filter = self,
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	end

	local Pos = self.Pos
	local Dist = (traceWater.HitPos - Pos):Length()
	local ply = LocalPlayer():GetViewEntity()

	if not IsValid( ply ) then return end

	local delay = (Pos - ply:GetPos()):Length() / 13503.9

	if traceWater.Hit and Dist > 150 then
		timer.Simple( delay, function()
			local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
			util.Effect( "WaterSurfaceExplosion", effectdata, true, true )
		end )

		if Dist > 300 then return end
	else
		timer.Simple( delay, function()
			sound.Play( "LVS.BULLET_EXPLOSION", Pos )
			sound.Play( "LVS.BULLET_EXPLOSION_DYNAMIC", Pos )
		end )

		local trace = util.TraceLine( {
			start = self.Pos + Vector(0,0,100),
			endpos = self.Pos - Vector(0,0,100),
			mask = MASK_SOLID_BRUSHONLY,
		} )

		if trace.Hit and not trace.HitNonWorld then
			util.DecalEx( self.DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), self.Scale * 2.5, self.Scale * 2.5 )
		end
	end

	if self.Dir.z > 0.8 then
		for i = 1, 10 do
			for n = 0,6 do
				local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ], self.Pos )

				if not particle then continue end

				particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 25) * self.Scale )
				particle:SetDieTime( (i / 8) * DieTime )
				particle:SetAirResistance( 10 ) 
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * self.Scale )
				particle:SetEndSize( 20 * i * self.Scale )
				particle:SetRollDelta( math.Rand(-1,1) )
				particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
				particle:SetGravity( Vector(0,0,-600) * self.Scale )
				particle:SetCollide( false )
			end
		end

		for i = 1, 10 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ], self.Pos )

			if not particle then continue end

			particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 40) * self.Scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * self.Scale )
			particle:SetEndSize( 20 * i * self.Scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) * self.Scale )
			particle:SetCollide( false )
		end
	end

	for i = 1,24 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , self.Pos )
		
		if not particle then continue end

		local ang = i * 15
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		local Vel = Vector(X,Y,0) * math.Rand(800,1200)
		Vel:Rotate( self.Dir:Angle() + Angle(90,0,0) )

		particle:SetVelocity( Vel * self.Scale )
		particle:SetDieTime( math.Rand(1,3) )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 40 * self.Scale )
		particle:SetEndSize( 140 * self.Scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,60) * self.Scale )
		particle:SetCollide( true )
	end

	for i = 0, 15 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 * scale )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( 200 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 200 * scale )
			particle:SetEndSize( 600 * scale )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector( 0, 0, -600 ) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 800 * scale )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 120 * scale )
		particle:SetEndSize( 20 * scale )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( self.Dir * 2500 )
		particle:SetRollDelta( math.Rand(-5,5) )
		particle:SetAirResistance( 300 )
	end

	for i = 0, 5 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )

		if not particle then continue end

		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,0) )

		local size = math.Rand(8, 24) * scale
		particle:SetEndSize( size )
		particle:SetStartSize( size )

		particle:SetStartLength( 400 * scale )
		particle:SetEndLength( size )

		particle:SetDieTime( math.Rand(0.1,0.2) )
		particle:SetVelocity( (self.Dir * 4000 + VectorRand() * 2000) * scale )

		particle:SetAirResistance( 0 )
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/fire_embers"..math.random(1,2), self.Pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 800 * scale )
		particle:SetDieTime( math.Rand(0.4,0.6) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 40 * scale )
		particle:SetEndSize( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,600) )
		particle:SetRollDelta( math.Rand(-8,8) )
		particle:SetAirResistance( 300 )
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0, 40 do
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	if not self.Scale then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local R1 = 800 * self.Scale
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, R1 * Scale, R1 * Scale, Color( 255, 200, 150, 255) )
end

--PATH lua/effects/lvs_capital_explosion.lua:
return gluapack()()
--PATH lua/effects/lvs_explosion_bomb.lua:
return gluapack()()
--PATH lua/effects/lvs_explosion_small.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	for i = 0, 15 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 200 )
			particle:SetStartSize( 120 )
			particle:SetEndSize( 300 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( math.Rand(0.15,0.3) )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 25 )
			particle:SetEndSize( math.Rand(70,100) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", self.Pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(20,40) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( 0 )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 2000 * Scale, 2000 * Scale, Color( 255, 200, 150, 255) )
end

--PATH lua/effects/lvs_firetrail.lua:
return gluapack()()
--PATH lua/effects/lvs_hover_water.lua:
return gluapack()()
--PATH lua/effects/lvs_hsd_dish_projector.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_blue.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_green_short.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_green_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 300 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 100, 1, 0, Color( 0, 255, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 60, 1, 0, Color( 0, 255, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--PATH lua/effects/lvs_laser_impact.lua:
return gluapack()()
--PATH lua/effects/lvs_missiletrail.lua:
return gluapack()()
--PATH lua/effects/lvs_missiletrail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		if particle then
			particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
			particle:SetVelocity( -self.Entity:GetForward() * 200  )
			particle:SetAirResistance( 600 ) 
			particle:SetDieTime( math.Rand(1.5,2) )
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 20 )
			particle:SetEndSize( 60 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
			particle:SetColor(40,40,40)
			particle:SetCollide( false )
		end

		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 1 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 0.25 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 6 )
			particle:SetEndSize( 2 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity

	if not IsValid( ent ) then return end

	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )
	render.DrawSprite( pos, 100, 100, Color( 255, 200, 150, 255 ) )
end

--PATH lua/effects/lvs_muzzle.lua:
return gluapack()()
--PATH lua/effects/lvs_proton_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add(  Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(30,60) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 0,127,255 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( math.Rand(30,60) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--PATH lua/effects/lvs_proton_trail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "effects/select_ring" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 1 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,255 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 6 )
			particle:SetEndSize( 2 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,255 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity
	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )

	render.DrawSprite( pos, 100, 100, Color( 0, 127, 255, 50 ) )
end

--PATH lua/effects/lvs_shield_impact.lua:
return gluapack()()
--PATH lua/effects/lvs_tracer_green.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 225, 255, 225, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 150, 200, 150, 255 ) )
end

--PATH lua/effects/lvs_tracer_orange.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 125, 50, 0, 255 ) )
end

--PATH lua/effects/lvs_tracer_yellow.lua:
return gluapack()()
--PATH lua/effects/nio_dissolve.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/pulsar_tracer_noattach.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 6500 --16000
EFFECT.Length	= 64

function EFFECT:Init( data )

	self.StartPos = data:GetStart() --self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	util.ParticleTracerEx( 
		"pulsar_beam", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH addons/[miecze] moce i hilty/lua/effects/rb655_force_repulse_in.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	--local rad = data:GetRadius()
	local emitter = ParticleEmitter( pos )

	if ( !emitter ) then return end

	local particle = emitter:Add( "effects/rb655_splash_warpring1", pos )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.5 )

		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( 100 )
		particle:SetEndSize( 0 )

		particle:SetStartAlpha( 0 )
		particle:SetEndAlpha( 200 )

		particle:SetColor( 255, 255, 255 )
		--particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end

	--[[local particle = emitter:Add( "effects/select_ring", pos )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.3 )

		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( math.random( 38, 42 ) )
		particle:SetEndSize( math.random( 48, 52 ) )

		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 255 )

		particle:SetColor( 0, 255, 255 )
		--particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end]]

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/[miecze] moce i hilty/lua/effects/repulse.lua:
EFFECT.mat = Material( "sprites/heatwave" )
EFFECT.mat3 = Material( "particle/smokesprites_0001" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then self.Ready = true return end

	self.Pos = self.Ent:GetShootPos()
	self.mat3 = Material( "particle/smokesprites_000"..math.random(1,9) )

	self.Ready = true
end

function EFFECT:Think()
	if not self.Ready then return true end

	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

function EFFECT:Render()
	if not self.Ready or not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local InvScale =  (1 - Scale)
	
	render.SetMaterial( self.mat3 )
	render.DrawSprite( self.Pos, 33 * Scale * self.Ent:GetNWInt( "_RepulseCharge", 1 ), 33 * Scale * self.Ent:GetNWInt( "_RepulseCharge", 1 ), Color( 150,200,255,50 ) )
	
	for i = 1, 3 do
		local Scale = (self.DieTime - CurTime()) / self.LifeTime / 3 * i

		local Pos = self.Pos

		render.SetMaterial( self.mat )
		render.DrawSprite( Pos, 50 *  InvScale * self.Ent:GetNWInt( "_RepulseCharge", 1 ), 50 *  InvScale * self.Ent:GetNWInt( "_RepulseCharge", 1 ), Color( 255,255,255,255 ) )
	end
end
	

--PATH lua/effects/rw_rocket_explosion.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)
	
	for i = 1, 55 do
		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Start)
		p:SetDieTime(math.Rand((4/3), 4))
		p:SetStartAlpha(95)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(100, 140) * self.size)
		p:SetEndSize(55 * self.size)
		p:SetRoll(math.Rand(-1, 1))
		p:SetRollDelta(math.Rand(-1, 1))
		p:SetCollide(true)	
		p:SetVelocity(VectorRand():GetNormal()*220)
		p:SetColor(115, 115, 115)
	end

	for i = 1, math.random(20, 50) do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1,4), self.Start)
		p:SetDieTime(math.Rand(0.1, 0.25))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(50, 150) * self.size)
		p:SetEndSize(50 * self.size)
		p:SetRoll(math.Rand(-50, 50))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * math.random(25, 75) * self.size)
		p:SetColor(255, 150, 0)
	end

	for i = 1, math.random(40, 70) do
		local vec = VectorRand():GetNormal()
		vec.z = 0
		local pos = (self.Start + vec * 5)
		local p = self.Emitter:Add("sprites/orangeflare1", self.Start + vec * 10)
		p:SetDieTime(math.Rand(2, 3))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(15)
		p:SetEndSize(3)
		p:SetVelocity(((pos - self.Start):GetNormal() * math.random(200, 350)) + Vector(0, 0, math.random(50, 300)) * self.size)
		p:SetGravity( Vector( 0, 0, -1750 ) );
		p:SetColor(255, 255, 255)
		p:SetCollide(true)
	end

	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--PATH lua/effects/rw_sw_dual_laser_blue.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_lightblue.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_lightblue.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("cs574/tracers/rw_sw_laser_m_lightblue")
local MaterialFront 		= Material("cs574/tracers/rw_sw_laser_f_lightblue")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 210
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_dual_laser_orange.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_yellow.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_yellow_main")
local MaterialFront 		= Material("effects/sw_laser_yellow_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_impact_blue.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_blue" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_laser_purple.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material( "effects/sw_laser_purple_main" )
local MaterialFront			= Material( "effects/sw_laser_purple_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 125
			dlight.g = 0
			dlight.b = 255
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_muzzleflash_black.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_white.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_yellow.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_yellow.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(255,255,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH addons/[miecze] moce i hilty/lua/effects/saber_hitwall.lua:
return gluapack()()
--PATH lua/effects/scifi_emptyshell.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/serv_passive_poison.lua:
return gluapack()()
--PATH lua/effects/snx_passive_stun.lua:
EFFECT.BeatMat = Material( "sprites/tp_beam001" )
EFFECT.SprMat = Material( "particle/particle_ring_wave_8_15ob_nofog" )

function EFFECT:Init( data )
	self.StartPos = data:GetOrigin()
	self.Entity = data:GetEntity()
	self.FollowPlayer = self.Entity:GetPos()

	self.Duration = data:GetScale()*6
	self.HealingAm = 0

	self.Alpha = 255
	self.Life = 0

	self.Color = Color(150,150,250,255)
end

function EFFECT:Think()
	if !self.Entity:IsValid() then return end

	self.FollowPlayer = self.Entity:GetPos()+Vector(0,0,50)

	self.Life = self.Life + FrameTime() * 6

	self.Alpha = 255 * ( 1 - self.Life )

	return ( self.Life < self.Duration )
end

function EFFECT:Render()
	-- Particles

	render.SetMaterial( self.SprMat )
	render.DrawSprite( 
		self.FollowPlayer,
		math.min(self.Life*50,100)+math.random( -25, 25 ),
		math.min(self.Life*50,100)+math.random( -25, 25 ),
		self.Color
	)

	render.SetMaterial( self.BeatMat )
	for i = 1, 5 do
		local randvec = VectorRand()
		randvec.z = -2
		render.DrawBeam( 
			self.FollowPlayer + (VectorRand()*5),
			self.FollowPlayer + (randvec*(math.min(self.Life*5,50)+math.random( -15, 45 ))),
			math.random(8,14),
			5,
			3,
			self.Color
		)
	end

end
--PATH lua/effects/swrp_muzzleflash_blue/init.lua:
return gluapack()()
--PATH lua/effects/tfa_bullet_impact/init.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzle_smoketrail/init.lua:
local vector_origin = Vector()

local smokecol = Color(225, 225, 225, 200)
local smokemat = Material("trails/smoke")
smokemat:SetInt("$nocull", 1)

function EFFECT:AddPart()
	local pos, rawdat, norm
	pos = self.startpos
	norm = self.startnormal

	if self.targent and self.targatt then
		--pos = self:GetTracerShootPos(self.startpos, self.targent, self.targatt)
		rawdat = self.targent:GetAttachment(self.targatt)

		if rawdat then
			pos = rawdat.Pos
			norm = rawdat.Ang:Forward()
		end
	end

	local p = {}
	p.position = pos
	p.normal = norm
	p.velocity = p.normal * 5
	p.startlife = CurTime()
	p.lifetime = self.lifetime
	p.radius = self.radius

	if self.vparticles then
		table.insert(self.vparticles, #self.vparticles + 1, p)
	end
end

function EFFECT:ProcessFakeParticles()
	self.stepcount = self.stepcount + 1

	if self.vparticles then
		if CurTime() < self.emittime and self.stepcount % self.partinterval == 0 then
			self:AddPart()
		end

		for k, v in ipairs(self.vparticles) do
			v.position = v.position + v.velocity * FrameTime()
			v.velocity = v.velocity + self.grav * FrameTime()

			if CurTime() > v.startlife + v.lifetime then
				--print("Curtime:"..CurTime())
				--print("Lifetime:"..v.lifetime)
				--print("CTime:"..v.startlife)
				table.remove(self.vparticles, k)
			end
		end

		if #self.vparticles <= 0 then
			return false
		else
			return true
		end
	else
		return true
	end
end

local cv_gr = GetConVar("sv_gravity")

function EFFECT:Init(ef)
	self.lifetime = 1
	self.stepcount = 0
	self.partinterval = 3
	self.emittime = CurTime() + 3
	self.targent = ef:GetEntity()
	self.targatt = ef:GetAttachment()
	self.startpos = ef:GetOrigin()
	self.startnormal = ef:GetNormal()
	self.radius = ef:GetRadius()
	self.grav = Vector(0, 0, cv_gr:GetFloat() * 0.2)
	self.randfac = 1

	if not self.startpos then
		self.startpos = vector_origin

		if LocalPlayer():IsValid() then
			self.startpos = LocalPlayer():GetShootPos()
		end
	end

	if not self.startnormal then
		self.startnormal = vector_origin
	end

	if not self.radius or self.radius == 0 then
		self.radius = 1
	end

	self.vparticles = {}
	self:AddPart()
end

function EFFECT:Think()
	if self.vparticles and #self.vparticles <= 0 then return false end

	return true
end

function EFFECT:DrawBeam()
	render.StartBeam(#self.vparticles)

	for k, v in ipairs(self.vparticles) do
		local alphac = ColorAlpha(smokecol, (1 - (CurTime() - v.startlife) / v.lifetime) * 64)
		render.AddBeam(v.position, v.radius * (1 - k / #self.vparticles), k / #self.vparticles, alphac)
	end

	render.EndBeam()
end

function EFFECT:Render()
	self:ProcessFakeParticles()

	if self.vparticles and #self.vparticles >= 2 then
		render.SetMaterial(smokemat)
		self:DrawBeam()
	end
end

--PATH lua/effects/tfa_muzzleflash_fubar_aq/init.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_sniper_energy/init.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_fubar_light_blu/init.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_fubar_light_blu/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_beam_blu", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_orange/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_purple/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(148, 0, 211)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(148, 0, 211)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 148
        dlight.g = 0
        dlight.b = 211
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_blue/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_green/init.lua:
return gluapack()()
--PATH lua/effects/vj_laserrod_red/init.lua:
return gluapack()()
--PATH lua/effects/vj_laserrod_red/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
-- Based off of the GMod lasertracer
EFFECT.MainMat = Material("effects/spark")

function EFFECT:Init( data )
	self.StartPos = data:GetStart()
	self.EndPos = data:GetOrigin()
	local ent = data:GetEntity()
	local att = data:GetAttachment()

	if ( IsValid( ent ) && att > 0 ) then
		if (ent.Owner == LocalPlayer() && !LocalPlayer():GetViewModel() != LocalPlayer()) then ent = ent.Owner:GetViewModel() end
		att = ent:GetAttachment(att)
		if (att) then
			self.StartPos = att.Pos
		end
	end

	self.Dir = self.EndPos - self.StartPos
	self:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.TracerTime = math.min(1, self.StartPos:Distance(self.EndPos) / 10000) -- Calculate death time
	self.Length = 0.1

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	if (CurTime() > self.DieTime) then -- If it's dead then...
		util.Decal("fadingscorch", self.EndPos + self.Dir:GetNormalized(), self.EndPos - self.Dir:GetNormalized())

		local effectData = EffectData()
		effectData:SetOrigin(self.EndPos + self.Dir:GetNormalized() * -2)
		effectData:SetNormal(self.Dir:GetNormalized() * -3)
		effectData:SetMagnitude(0.1)
		effectData:SetScale(0.8)
		effectData:SetRadius(5)
		util.Effect("Sparks", effectData)
		return false
	end
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
	local fDelta = (self.DieTime - CurTime()) / self.TracerTime
	fDelta = math.Clamp(fDelta, 0, 1) ^ 0.5
	render.SetMaterial(self.MainMat)
	local sinWave = math.sin(fDelta * math.pi)
	render.DrawBeam(
		self.EndPos - self.Dir * (fDelta - sinWave * self.Length),
		self.EndPos - self.Dir * (fDelta + sinWave * self.Length),
		5 + sinWave * 35, 1, 0, Color(255, 0, 0, 255)
	)
end

--PATH lua/effects/vj_medium_explosion1/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
function EFFECT:Init(data)
	self.Pos = data:GetOrigin()
	local Emitter = ParticleEmitter(self.Pos)
	if Emitter == nil then return end
	
	/*local effectData = EffectData()
	effectData:SetOrigin( self.Pos )
	effectData:SetNormal( Vector(0, 0, 0) )
	effectData:SetMagnitude( 2.6 )
	effectData:SetScale( 2.6 )
	effectData:SetRadius( 93 )
	util.Effect( "Sparks", effectData, true, true )*/
	
	-- Fire
	for i=1,8 do
		local EffectCode = Emitter:Add("particles/flamelet1",self.Pos)
		EffectCode:SetVelocity(Vector(math.random(-30,30),math.random(-30,30),math.random(30,40)))
		EffectCode:SetDieTime(math.Rand(1,2)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(90,100)) -- Transparency
		EffectCode:SetStartSize(math.Rand(300,300)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(300,300)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(0) -- How fast it rolls
		EffectCode:SetColor(170,170,170) -- The color of the effect
		EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end

	-- Smoke screen
	for i = 1,12 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
		EffectCode:SetVelocity(Vector(math.random(-40,40),math.random(-40,40),math.random(5,15)))
		EffectCode:SetDieTime(math.Rand(15,17)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(220,230)) -- Transparency
		EffectCode:SetStartSize(math.Rand(130,170)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(300,350)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(0) -- How fast it rolls
		EffectCode:SetColor(100,100,100) -- The color of the effect
		EffectCode:SetGravity(Vector(0, 0, 0)) -- The Gravity
		EffectCode:SetAirResistance(15)
	end

	-- Cloud of smoke that goes up
	for i = 1,8 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
		EffectCode:SetVelocity(Vector(math.random(-60,70),math.random(-100,70),math.random(70,180)))
		EffectCode:SetDieTime(math.Rand(4,5)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(220,230)) -- Transparency
		EffectCode:SetStartSize(math.Rand(55,66)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(192,256)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
		EffectCode:SetColor(50,50,50) -- The color of the effect
		EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end
	Emitter:Finish()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
end
--PATH lua/effects/vj_small_dust1/init.lua:
return gluapack()()
--PATH lua/effects/vj_weapon_pistolshell1/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
function EFFECT:Init(data)
	local ent = data:GetEntity()
	if !IsValid(ent) then return end
	local effectData = EffectData()
	effectData:SetOrigin(self:GetTracerShootPos(data:GetOrigin(), ent, data:GetAttachment()))
	util.Effect("ShellEject", effectData, true, true)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
end
--PATH addons/[tfres] frest_levels/lua/fstands2/levels/cl_lvl.lua:
return gluapack()()
--PATH lua/prone/sh_prone.lua:
local PLAYER = FindMetaTable("Player")

---------------------------------
-- PLAYER.GetProneAnimationState
---------------------------------
-- Desc:		Gets the prone animation state of the given player.
-- Returns:		PRONE enum.
function PLAYER:GetProneAnimationState()
	return self:GetNW2Int("prone.AnimationState", PRONE_NOTINPRONE)
end

---------------------------------
-- PLAYER.SetProneAnimationState
---------------------------------
-- Desc:		Sets the prone animation state of the given player.
-- Arg One:		PRONE enum.
function PLAYER:SetProneAnimationState(state)
	return self:SetNW2Int("prone.AnimationState", state)
end

----------------------------------
-- PLAYER.GetProneAnimationLength
----------------------------------
-- Desc:		Returns the time when the current prone animation will end.
-- 				This value is: CurTime at start of anim + length of anim
-- Returns:		Number
function PLAYER:GetProneAnimationLength()
	return self:GetNW2Float("prone.AnimationLength", 0)
end

----------------------------------
-- PLAYER.SetProneAnimationLength
----------------------------------
-- Desc:		Sets at what time, relative to CurTime, the given prone animation will end.
-- Arg One:		Number, time.
function PLAYER:SetProneAnimationLength(length)
	self:SetNW2Float("prone.AnimationLength", length)
end

------------------
-- PLAYER.IsProne
------------------
-- Desc:		Is the player in prone.
-- Returns:		Boolean.
function PLAYER:IsProne()
	return self:GetProneAnimationState() ~= PRONE_NOTINPRONE
end

---------------------------
-- PLAYER.ProneIsGettingUp
---------------------------
-- Desc:		Is the player getting up out of prone.
-- Returns:		Boolean.
function PLAYER:ProneIsGettingUp()
	return self:GetProneAnimationState() == PRONE_GETTINGUP
end

-----------------------------
-- PLAYER.ProneIsGettingDown
-----------------------------
-- Desc:		Is the player getting down into prone.
-- Returns:		Boolean.
function PLAYER:ProneIsGettingDown()
	return self:GetProneAnimationState() == PRONE_GETTINGDOWN
end

------------------------
-- prone.HasRoomToGetUp
------------------------
-- Desc:		Does the player have enough room to get up, out of prone.
-- Arg One:		Player.
-- Returns:		Boolean.
function prone.HasRoomToGetUp(ply)
	if not ply:IsProne() then
		return true
	end

	local tr = util.TraceEntity({
		start = ply:GetPos(),
		endpos = ply:GetPos() + Vector(0, 0, 65 - prone.Config.HullHeight),
		filter = ply
	}, ply)
	
	if tr.Hit then
		if CLIENT and IsFirstTimePredicted() then
			prone.CantGetUpWarning()
		end
		return false
	else
		return true
	end
end

------------------
-- prone.CanEnter
------------------
-- Desc:		Can the given player enter prone.
-- Arg One:		Player
-- Returns:		Boolean
function prone.CanEnter(ply)
	-- prone.CanEnter hook takes precedence.
	local hookresult = hook.Run("prone.CanEnter", ply)
	if hookresult ~= nil then
		return hookresult

	-- Then check the player's state.
	elseif not ply:IsPlayer() or not ply:Alive() or ply:GetMoveType() == MOVETYPE_NOCLIP or not ply:OnGround() or ply:WaterLevel() > 1 then
		return false
	end

	return true
end

-----------------
-- prone.CanExit
-----------------
-- Desc:		Can the given player exit prone.
-- Arg One:		Player
-- Returns:		Boolean
function prone.CanExit(ply)
	if not (ply:IsPlayer() and ply:Alive()) then
		return false
	end

	local hookresult = hook.Run("prone.CanExit", ply)
	if hookresult ~= nil then
		return hookresult
	elseif not prone.HasRoomToGetUp(ply) then
		return false
	end

	return true
end

---------------
-- prone.Enter
---------------
-- Desc:		Begins the animation putting the given player into prone.
-- Arg One:		Player.
function prone.Enter(ply)
	local plyProneStateData = prone.PlayerStateData:New(ply)
	prone.PlayerStateDatas[ply:SteamID()] = plyProneStateData
	plyProneStateData:UpdateDataOnProneEnter()

	ply:SetHull(Vector(-16, -16, 0), Vector(16, 16, prone.Config.HullHeight))
	ply:SetHullDuck(Vector(-16, -16, 0), Vector(16, 16, prone.Config.HullHeight))

	local getDownTime = plyProneStateData:GetGetDownTime()
	ply:SetProneAnimationLength(getDownTime)

	-- Make sure they can't shoot while prone.
	local weapon = ply:GetActiveWeapon()
	if IsValid(weapon) then
		weapon:SetNextPrimaryFire(getDownTime)
		weapon:SetNextSecondaryFire(getDownTime)
	end

	ply:SetProneAnimationState(PRONE_GETTINGDOWN)
	ply:DoCustomAnimEvent(PLAYERANIMEVENT_CUSTOM, PRONE_CUSTOM_ANIM_EVENT_NUM)
	hook.Run("prone.OnPlayerEntered", ply, plyProneStateData:GetEnterProneAnimLength())
end

-------------
-- prone.End
-------------
-- Desc:		Begins the animation taking the given player out of prone.
-- Arg One:		Player.
function prone.End(ply)
	local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]
	if not plyProneStateData then
		plyProneStateData = prone.PlayerStateData:New(ply)
	end
	plyProneStateData:UpdateOnProneEnd()

	local getUpTime = plyProneStateData:GetGetUpTime()
	ply:SetProneAnimationLength(getUpTime)

	-- Make sure they can't shoot while getting up.
	local weapon = ply:GetActiveWeapon()
	if IsValid(weapon) then
		weapon:SetNextPrimaryFire(getUpTime)
		weapon:SetNextSecondaryFire(getUpTime)
	end

	-- Play the animation.
	ply:DoCustomAnimEvent(PLAYERANIMEVENT_CUSTOM, PRONE_CUSTOM_ANIM_EVENT_NUM)
	ply:SetProneAnimationState(PRONE_GETTINGUP)
end

--------------
-- prone.Exit
--------------
-- Desc:		Forces the player immediately out of prone with no animation.
-- Arg One:		Player.
function prone.Exit(ply)
	local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]

	if plyProneStateData then
		ply:SetViewOffset(plyProneStateData:GetOriginalViewOffset())
		ply:SetViewOffsetDucked(plyProneStateData:GetOriginalViewOffsetDucked())
	else
		-- Best guess in-case we somehow lose state data.
		ply:SetViewOffset(Vector(0, 0, 64))
		ply:SetViewOffsetDucked(Vector(0, 0, 28))
	end
	ply:ResetHull()

	prone.PlayerStateDatas[ply:SteamID()] = nil

	ply:SetProneAnimationState(PRONE_NOTINPRONE)
	hook.Run("prone.OnPlayerExitted", ply)
end

----------------
-- prone.Handle
----------------
-- Desc:		Toggles between the player entering and ending prone.
function prone.Handle(ply)
	if not IsValid(ply) then
		return
	end

	if ply:IsProne() then
		if prone.CanExit(ply) then
			prone.End(ply)
		end
	else
		if prone.CanEnter(ply) then
			prone.Enter(ply)
		end
	end
end

local proneMoveSpeed = CreateConVar("prone_movespeed", tostring(prone.Config.MoveSpeed), {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Sets the move speed while prone.")


-- Disable jumping in prone, set prone movement speed, handle weapon fire.
hook.Add("SetupMove", "prone.Handle", function(ply, cmd, cuc)
	if ply:IsProne() then
		-- Disables jumping, thanks meep.
		if cmd:KeyDown(IN_JUMP) then
			cmd:SetButtons(bit.band(cmd:GetButtons(), bit.bnot(IN_JUMP)))
		end
		-- Disabled crouching.
		if cmd:KeyDown(IN_DUCK) then
			cmd:SetButtons(bit.band(cmd:GetButtons(), bit.bnot(IN_DUCK)))
		end

		-- If they are getting up or down then set their speed to TransitionSpeed
		if ply:GetProneAnimationLength() >= CurTime() then
			cmd:SetMaxClientSpeed(prone.Config.TransitionSpeed)
			cmd:SetMaxSpeed(prone.Config.TransitionSpeed)

			-- SetMaxClientSpeed doesn't work if you are setting it to 0 so also do this.
			if prone.Config.TransitionSpeed <= 0 and ply:IsOnGround() then
				cmd:SetForwardSpeed(0)
				cmd:SetSideSpeed(0)
				cmd:SetVelocity(Vector(0, 0, 0))
			end
			return
		else	-- If they are in prone set their speed to MoveSpeed
			local moveSpeed = proneMoveSpeed:GetInt()
			if not isnumber(moveSpeed) then
				moveSpeed = prone.Config.MoveSpeed
			end

			cmd:SetMaxClientSpeed(moveSpeed)
			cmd:SetMaxSpeed(moveSpeed)
		end

		-- Make sure they can't shoot while prone and moving if that setting is enabled.
		local attack1 = cmd:KeyDown(IN_ATTACK)
		if attack1 or cmd:KeyDown(IN_ATTACK2) and prone.Config.MoveShoot_Restrict then
			local weapon = ply:GetActiveWeapon()
			if not IsValid(weapon) then
				return
			end

			local weaponclass = weapon:GetClass()
			if not prone.Config.MoveShoot_Whitelist[weaponclass] then
				local shouldStopMovement = true
				if attack1 then
					shouldStopMovement = weapon:Clip1() > 0
				else
					shouldStopMovement = weapon:Clip2() > 0
				end

				if (shouldStopMovement or weaponclass == "weapon_crowbar") and ply:IsOnGround() then
					cmd:SetForwardSpeed(0)
					cmd:SetSideSpeed(0)
					cmd:SetVelocity(Vector(0, 0, 0))
				end
			end
		end
	end

	if cuc:GetImpulse() == PRONE_IMPULSE and (ply:GetProneAnimationLength() < CurTime() + 0.5) then
		prone.Handle(ply)
	end
end)

-- Handles pose parameters and playback rates of animations.
hook.Add("UpdateAnimation", "prone.Animations", function(ply, velocity, maxSeqGroundSpeed)
	if ply:IsProne() then
		local length = velocity:Length()

		local rate = 1
		local plyAnimState = ply:GetProneAnimationState()
		if plyAnimState ~= PRONE_GETTINGDOWN and plyAnimState ~= PRONE_GETTINGUP then
			if not ply:IsOnGround() and length >= 750 then
				rate = 0.1
			else
				if length > 0.2 then
					rate = math.min(length / maxSeqGroundSpeed, 2)
				else
					rate = 1
				end
			end
		end

		if CLIENT then
			local EyeAngP = ply:EyeAngles().p
			if EyeAngP < 89 then
				ply:SetPoseParameter("body_pitch", math.Clamp(-EyeAngP, -10, 50))
				ply:SetPoseParameter("body_yaw", 0)
				ply:InvalidateBoneCache()
			end
		end

		-- Interesting code I saw in NutScript, doesn't seem to do anything in my case though.
		--local eyeAngles = ply:EyeAngles()
		--local yaw = velocity:Angle()[2]
		--local normalized = math.NormalizeAngle(yaw - eyeAngles[2])
		--ply:SetPoseParameter("move_yaw", normalized)

		ply:SetPlaybackRate(rate)
	end
end)

-- The animation handler of the addon.
local function GetSequenceForWeapon(holdtype, ismoving)
	return ismoving and prone.Animations.WeaponAnims.moving[holdtype] or prone.Animations.WeaponAnims.idle[holdtype]
end
local GetMainActivityAnimation = {
	[PRONE_GETTINGDOWN] = function(ply)
		if ply:GetProneAnimationLength() <= CurTime() then
			ply:SetViewOffset(prone.Config.View)
			ply:SetViewOffsetDucked(prone.Config.View)
			ply:SetProneAnimationState(PRONE_INPRONE)
		end
		
		return prone.Animations.gettingdown
	end,

	[PRONE_GETTINGUP] = function(ply)
		if ply:GetProneAnimationLength() <= CurTime() then
			local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]
			if plyProneStateData then
				ply:SetViewOffset(plyProneStateData:GetOriginalViewOffset())
				ply:SetViewOffsetDucked(plyProneStateData:GetOriginalViewOffsetDucked())
			else
				-- Best guess in-case we somehow lose state data.
				ply:SetViewOffset(Vector(0, 0, 64))
				ply:SetViewOffsetDucked(Vector(0, 0, 28))
			end

			prone.Exit(ply)

			-- If they get stuck in anything while exitting put them back in prone.
			local scanPos = ply:GetPos()
			local tr = util.TraceEntity({
				start = scanPos,
				endpos = scanPos,
				filter = ply
			}, ply)

			if tr.Hit then
				if CLIENT and ply == LocalPlayer() then
					prone.CantGetUpWarning()
				end
				prone.Enter(ply)
			end
		end

		return prone.Animations.gettingup
	end,

	[PRONE_INPRONE] = function(ply, velocity)
		local weapon = ply:GetActiveWeapon()
		local WeaponHoldType

		if IsValid(weapon) then
			WeaponHoldType = weapon:GetHoldType()
			if WeaponHoldType == "" then
				WeaponHoldType = weapon.HoldType
			end
		end

		return GetSequenceForWeapon(WeaponHoldType or "normal", velocity:LengthSqr() >= 225)
	end,

	-- Just in case this gets called for some reason.
	[PRONE_NOTINPRONE] = function()
		return prone.Animations.passive
	end
}
hook.Add("CalcMainActivity", "prone.Animations", function(ply, velocity)
	if IsValid(ply) and ply:IsProne() then
		local seq = GetMainActivityAnimation[ply:GetProneAnimationState()](ply, velocity)

		-- NEVER let this hook's second return parameter be a number less than 0.
		-- That crashes Linux servers for some reason.
		local seqid = ply:LookupSequence(seq or "")
		if seqid < 0 then
			return
		end

		return -1, seqid or nil
	end
end)

-- Fixes a bug where other players (not the one proning) might see the proning player's get up/down
-- animations starting at a random point in the animation.
hook.Add("DoAnimationEvent", "prone.ResetAnimation", function(ply, event, data)
	if event == PLAYERANIMEVENT_CUSTOM then
		if data == PRONE_CUSTOM_ANIM_EVENT_NUM then
			ply:AnimRestartMainSequence()
		end
	end
end)

------------------------------------------------------------
-- Check if the player should still be prone at these events
------------------------------------------------------------
hook.Add("PlayerNoClip", "prone.ExitOnNoclip", function(ply)
	if ply:IsProne() then
		prone.Exit(ply)
	end
end)
hook.Add("VehicleMove", "prone.ExitOnVehicleEnter", function(ply)
	if ply:IsProne() then
		prone.Exit(ply)
	end
end)
timer.Create("prone.Manage", 0.5, 0, function()
	for i, v in ipairs(player.GetAll()) do
		if v:IsProne() and (
			(v:WaterLevel() > 1 and not v:ProneIsGettingUp())
			or v:GetMoveType() == MOVETYPE_NOCLIP
			or v:GetMoveType() == MOVETYPE_LADDER
		) then
			prone.Exit(v)
		end
	end
end)

----------------
-- API Functions
----------------
-- Notice: Any API functions should be called in or after the prone.Initialized hook has been called.
function prone.AddNewHoldTypeAnimation(holdtype, movingSequenceName, idleSequenceName)
	prone.Animations.WeaponAnims.moving[holdtype] = movingSequenceName
	prone.Animations.WeaponAnims.idle[holdtype] = idleSequenceName
end

function prone.GetIdleAnimation(holdtype)
	return prone.Animations.WeaponAnims.idle[holdtype]
end
function prone.GetMovingAnimation(holdtype)
	return prone.Animations.WeaponAnims.moving[holdtype]
end
--PATH lua/prone/sh_thirdparty_compat.lua:
return gluapack()()
--PATH lua/rd_claim_boards/sh_config_wrapper.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/areszty.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/posw.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/zezw.lua:
local APP = {}

APP.Name = "Zezwolenia"                   -- Nazwa
APP.Restricted = true               -- Dosłownie nic nie zmienia

APP.Derma = function(parrent)
    local x,y = parrent:GetWide(),parrent:GetTall()
	local pan = vgui.Create("DPanel",parrent)
    pan:SetSize(x,y)
    pan:Center()
    pan:SetBackgroundColor(Color(0,0,0))
    local label = vgui.Create("DLabel",pan)
	label:SetText("WORK IN PROGRESS")
	label:SizeToContents()
	label:Center()
    label:SetTextColor(Color(255,255,255))

end

return APP