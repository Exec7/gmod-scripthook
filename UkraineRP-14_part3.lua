--Stealed clientside server code by exechack.cc
--Hostname: Ψ UkraineRP #1 ◈ Оновлення◈ Набiр ◈ M9K - Part 3/10 - 06/04/2025


--PATH addons/dash/lua/includes/init.lua:
-- Init
if (SERVER) then
	AddCSLuaFile()
	AddCSLuaFile 'dash/init.lua'
end
include 'dash/init.lua'

dash.IncludeSH '_init.lua'

-- Extensions
for k, v in pairs(dash.LoadDir('extensions')) do
	dash.IncludeSH(v)
end
for k, v in pairs(dash.LoadDir('extensions/server')) do
	dash.IncludeSV(v)
end
for k, v in pairs(dash.LoadDir('extensions/client')) do
	dash.IncludeCL(v)
end
--PATH addons/dash/lua/dash/preload/badmodules_example.lua:
-- This folder has total load priority over everything
-- This can be used to kill modules you dont use on your server
-- require 'example'  will now silently ignore this module
dash.BadModules['example'] = true
--PATH addons/dash/lua/dash/libraries/usermessage.lua:
if (SERVER) then
	local message 	= {}
	local pooled 	= {}
	local PLAYER = FindMetaTable('Player')

	util.AddNetworkString 'umsg.SendLua'
	util.AddNetworkString 'umsg.UnPooled'

	function SendUserMessage(name, recipients, ...)
		umsg.Start(name, recipients)
		for k, v in pairs({...}) do
			local t = type(v)
			if (t == 'string') then
				umsg.String(v)
			elseif IsEntity(v) then
				umsg.Entity(v)
			elseif (t == 'number') then
				umsg.Long(v)
			elseif (t == 'Vector') then
				umsg.Vector(v)
			elseif (t == 'Angle') then
				umsg.Angle(v)
			elseif (t == 'boolean') then
				umsg.Bool(v)
			else
				ErrorNoHalt('SendUserMessage: Couldn\'t send type ' .. t .. '\n')
			end
		end
		umsg.End()
	end

	function BroadcastLua(lua)
		net.Start 'umsg.SendLua'
			net.WriteString(lua)
		net.Broadcast()
	end

	PLAYER.SendLua = function(self, lua)
		net.Start 'umsg.SendLua'
			net.WriteString(lua)
		net.Send(self)
	end	

	function umsg.PoolString(name)
		if (not pooled[name]) then
			util.AddNetworkString('umsg.' .. name)
			pooled[name] = true
		end
	end

	function umsg.Start(name, recipients)
		local t = type(recipients)

		if (t == 'CRecipientFilter') then
			message = recipients:GetPlayers()
		elseif (t == 'Player') or (t == 'table') then
			message = recipients
		else
			message = player.GetAll()
		end

		if pooled[name] then
			net.Start('umsg.' .. name)
		else
			umsg.PoolString(name)
			net.Start 'umsg.UnPooled'
			net.WriteString(name)
		end
	end

	function umsg.End()
		net.Send(message)
	end

	function umsg.Angle(value)
		net.WriteAngle(value)
	end

	function umsg.Bool(value)
		net.WriteBool(value)
	end

	function umsg.Char(value)
		net.WriteInt((isstring(value) and string.char(value) or value), 8)
	end

	function umsg.Entity(value)
		net.WriteEntity(value)
	end

	function umsg.Float(value)
		net.WriteFloat(value)
	end

	function umsg.Long(value)
		net.WriteInt(value, 32)
	end

	function umsg.Short(value)
		net.WriteInt(value, 16)
	end

	function umsg.String(value)
		net.WriteString(value)
	end

	function umsg.Vector(value)
		net.WriteVector(value)
	end

	function umsg.VectorNormal(value)
		net.WriteVector(value)
	end
else
	usermessage = {}
	local hooks = {}

	net.Receive('umsg.SendLua', function()
		RunString(net.ReadString())
	end)

	net.Receive('umsg.UnPooled', function(len, ...)
		usermessage.IncomingMessage(net.ReadString())
	end)

	function usermessage.Hook(name, callback, ...)
		if (SERVER) then
			umsg.PoolString(name)
			return
		end

		hooks[name] = {}
		hooks[name].Function = function()
			callback(usermessage, unpack(hooks[name].PreArgs))
		end
		hooks[name].PreArgs	= {...}

		net.Receive('umsg.' .. name, function(len)
			usermessage.IncomingMessage(name)
		end)
	end

	function usermessage.GetTable()
		return hooks
	end

	function usermessage.IncomingMessage(name)
		if hooks[name] then
			hooks[name].Function()
		else
			Msg('Warning: Unhandled usermessage \'' .. name .. '\'\n')
		end
	end

	function usermessage:ReadAngle()
		return net.ReadAngle()
	end

	function usermessage:ReadBool()
		return net.ReadBool()
	end

	function usermessage:ReadChar()
		return net.ReadInt(8)
	end

	function usermessage:ReadEntity()
		return net.ReadEntity()
	end

	function usermessage:ReadFloat()
		return net.ReadFloat()
	end

	function usermessage:ReadLong()
		return net.ReadInt(32)
	end

	function usermessage:ReadShort()
		return net.ReadInt(16)
	end

	function usermessage:ReadString()
		return net.ReadString()
	end

	function usermessage:ReadVector()
		return net.ReadVector()
	end

	function usermessage:ReadVectorNormal()
		local v = net.ReadVector()
		v:Normalize()
		return v
	end

	function usermessage:Reset()
		ErrorNoHalt('usermessage:Reset() is not supported!')
	end
end

--PATH addons/dash/lua/dash/extensions/string.lua:
function string.Random(chars)
	local str = ''
	for i = 1, (chars or 10) do
		str = str .. string.char(math.random(97, 122))
	end
	return str
end

function string:IsAlphaNumeric()
	return (not self:match('%W'))
end

function string:StartsWith(str)
	return (self:sub(1, str:len()) == str)
end

function string:Apostrophe()
	local len = self:len()
	return (self:sub(len, len):lower() == 's') and '\'' or '\'s'
end

function string:AOrAn()
	return self:match('^h?[AaEeIiOoUu]') and 'an' or 'a'
end

function string:IsSteamID32(str)
	return self:match('^STEAM_%d:%d:%d+$')
end

function string:IsSteamID64()
	return (self:len() == 17) and (self:sub(1, 4) == '7656')
end

function string:HtmlSafe()
	return self:gsub('&', '&amp;'):gsub('<', '&lt;'):gsub('>', '&gt;')
end

local formathex = '%%%02X'
function string:URLEncode()
	return string.gsub(string.gsub(string.gsub(self, '\n', '\r\n'), '([^%w ])', function(c)
		return string.format(formathex, string.byte(c))
	end), ' ', '+')
end

function string:URLDecode()
	return self:gsub('+', ' '):gsub('%%(%x%x)', function(hex)
		return string.char(tonumber(hex, 16))
	end)
end

function string:ParseURL()
	local ans = {}
	for k, v in self:gmatch('([^&=?]-)=([^&=?]+)' ) do
		ans[k] = v:URLDecode()
	end
	return ans
end

function string.ExplodeQuotes(str) -- Re-do this one of these days
	str = ' ' .. str .. ' '
	local res = {}
	local ind = 1
	while true do
		local sInd, start = str:find('[^%s]', ind)
		if not sInd then break end
		ind = sInd + 1
		local quoted = str:sub(sInd, sInd):match('["\']') and true or false
		local fInd, finish = str:find(quoted and '["\']' or '[%s]', ind)
		if not fInd then break end
		ind = fInd + 1
		local str = str:sub(quoted and sInd + 1 or sInd, fInd - 1)
		res[#res + 1] = str
	end
	return res
end

function string:StripPort()
	local p = self:find(':')
	return (not p) and ip or self:sub(1, p - 1)
end

function string.FromNumbericIP(ip)
	ip = tonumber(ip)
	return bit.rshift(bit.band(ip, 0xFF000000), 24) .. '.' .. bit.rshift(bit.band(ip, 0x00FF0000), 16) .. '.' .. bit.rshift(bit.band(ip, 0x0000FF00), 8) .. '.' .. bit.band(ip, 0x000000FF)
end

-- Stolen from maestro
local TIME_SECOND 	= 1
local TIME_MINUTE 	= TIME_SECOND * 60
local TIME_HOUR 	= TIME_MINUTE * 60
local TIME_DAY 		= TIME_HOUR * 24
local TIME_WEEK 	= TIME_DAY * 7
local TIME_MONTH 	= TIME_DAY * (365.2425/12)
local TIME_YEAR 	= TIME_DAY * 365.2425

local function plural(a, n)
	return (n == 1) and a or  a .. 's'
end

function string.FormatTime(num, limit)
	local ret = {}
	while (not limit) or (limit ~= 0) do
		local templimit = limit or 0

		if (num >= TIME_YEAR) or (templimit <= -7) then
			local c = math.floor(num / TIME_YEAR)
			ret[#ret + 1] = c .. ' ' .. plural('year', c)
			num = num - TIME_YEAR * c
		elseif (num >= TIME_MONTH) or (templimit <= -6) then
			local c = math.floor(num / TIME_MONTH)
			ret[#ret + 1] = c .. ' ' .. plural('month', c)
			num = num - TIME_MONTH * c
		elseif (num >= TIME_WEEK) or (templimit <= -5) then
			local c = math.floor(num / TIME_WEEK)
			ret[#ret + 1] = c .. ' ' .. plural('week', c)
			num = num - TIME_WEEK * c
		elseif (num >= TIME_DAY) or (templimit <= -4)then
			local c = math.floor(num / TIME_DAY)
			ret[#ret + 1] = c .. ' ' .. plural('day', c)
			num = num - TIME_DAY * c
		elseif (num >= TIME_HOUR) or (templimit <= -3) then
			local c = math.floor(num / TIME_HOUR)
			ret[#ret + 1] = c .. ' ' .. plural('hour', c)
			num = num - TIME_HOUR * c
		elseif (num >= TIME_MINUTE) or (templimit <= -2) then
			local c = math.floor(num / TIME_MINUTE)
			ret[#ret + 1] = c .. ' ' .. plural('minute', c)
			num = num - TIME_MINUTE * c
		elseif num >= TIME_SECOND or (templimit <= -1) then
			local c = math.floor(num / TIME_SECOND)
			ret[#ret + 1] = c .. ' ' .. plural('second', c)
			num = num - TIME_SECOND * c
		else
			break
		end

		if limit then
			if limit > 0 then
				limit = limit - 1
			else
				limit = limit + 1
			end
		end
	end

	local str = ''
	for i = 1, #ret do
		if i == 1 then
			str = str .. ret[i]
		elseif i == #ret then
			str = str .. ' and ' .. ret[i]
		else
			str = str .. ', ' .. ret[i]
		end
	end

	return str
end

-- Faster implementation
local totable = string.ToTable
local string_sub = string.sub
local string_find = string.find
local string_len = string.len
function string.Explode(separator, str, withpattern)
	if (separator == '') then return totable(str) end

	if withpattern == nil then
		withpattern = false
	end

	local ret = {}
	local current_pos = 1

	for i = 1, string_len(str) do
		local start_pos, end_pos = string_find(str, separator, current_pos, not withpattern)
		if not start_pos then break end
		ret[i] = string_sub(str, current_pos, start_pos - 1)
		current_pos = end_pos + 1
	end

	ret[#ret + 1] = string_sub(str, current_pos)

	return ret
end

function string:MaxCharacters(num, withellipses)
	if (#self <= num) then return self end

	local str = self:sub(1, num)

	return withellipses and (str .. '...') or str
end

local simpleTimestampPattern = "(%d+)-(%d+)-(%d+) (%d+):(%d+):(%d+)"
function string.ToTime(str)
    local year, month, day, hour, min, sec = str:match(simpleTimestampPattern)

    return os.time({
        year = year,
        month = month,
        day = day,
        hour = hour,
        min = min,
        sec = sec
    })
end

-- Like string.NiceTime but for timestamps: 2021-04-08 00:56:24
function string.NiceDate(str)
    return string.NiceTime(string.ToTime(str))
end

--PATH addons/dash/lua/dash/extensions/weapon.lua:
//
--PATH addons/dash/lua/dash/extensions/client/player.lua:
local pl
local _LocalPlayer = LocalPlayer
function LocalPlayer()
	pl = _LocalPlayer()
	if IsValid(pl) then
		LocalPlayer = function()
			return pl
		end
	end
	return pl
end
--PATH addons/dash/lua/dash/extensions/client/draw.lua:
local surface_SetDrawColor 	= surface.SetDrawColor
local surface_SetMaterial 	= surface.SetMaterial
local surface_DrawRect 		= surface.DrawRect
local surface_DrawTexturedRect = surface.DrawTexturedRect
local render_UpdateScreenEffectTexture = render.UpdateScreenEffectTexture
local render_SetScissorRect = render.SetScissorRect
local ScrW = ScrW
local ScrH = ScrH
local SysTime = SysTime
local FrameTime = FrameTime
local Vector = Vector
local Matrix = Matrix

local function DrawRect(x, y, w, h, t)
	if not t then t = 1 end
	surface_DrawRect(x, y, w, t)
	surface_DrawRect(x, y + (h - t), w, t)
	surface_DrawRect(x, y, t, h)
	surface_DrawRect(x + (w - t), y, t, h)
end

function draw.Box(x, y, w, h, col)
	surface_SetDrawColor(col)
	surface_DrawRect(x, y, w, h)
end

function draw.Outline(x, y, w, h, col, thickness)
	surface_SetDrawColor(col)
	DrawRect(x, y, w, h, thickness)
end

function draw.OutlinedBox(x, y, w, h, col, bordercol, thickness)
	surface_SetDrawColor(col)
	surface_DrawRect(x + 1, y + 1, w - 2, h - 2)

	surface_SetDrawColor(bordercol)
	DrawRect(x, y, w, h, thickness)
end

local blurboxes = {}
local blur = Material 'pp/blurscreen'
function draw.BlurResample(amount)
	surface_SetDrawColor(255, 255, 255)
	surface_SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat('$blur', (i / 3) * (amount or 8))
		blur:Recompute()
		render_UpdateScreenEffectTexture()

		for k, v in ipairs(blurboxes) do
			render_SetScissorRect(v.x, v.y, v.x + v.w, v.y + v.h, true)
				surface_DrawTexturedRect(0, 0, ScrW(), ScrH())
			render_SetScissorRect(0, 0, 0, 0, false)
			blurboxes[k] = nil
		end

	end
end

function draw.BlurBox(x, y, w, h)
	blurboxes[#blurboxes + 1] = {
		x = x,
		y = y,
		w = w,
		h = h
	}
end

function draw.BlurPanel(panel)
	draw.BlurBox(panel:GetBounds())
end
draw.Blur = draw.BlurPanel -- Backward support

function draw.TextRotated(text, x, y, color, font, ang)
	--render.PushFilterMag(TEXFILTER.ANISOTROPIC)
	--render.PushFilterMin(TEXFILTER.ANISOTROPIC)
	surface.SetFont(font)
	surface.SetTextColor(color)
	local textWidth, textHeight = surface.GetTextSize(text)
	local rad = -math.rad(ang)
	local halvedPi = math.pi * 0.5
	local m = Matrix()
	m:SetAngles(Angle(0, ang, 0))
	m:SetTranslation(Vector(x, y, 0))
	cam.PushModelMatrix(m)
		surface.SetTextPos(0, 0)
		surface.DrawText(text)
	cam.PopModelMatrix()
	--render.PopFilterMag()
	--render.PopFilterMin()
end
--PATH addons/__________tperson/lua/3tcore/vgui/cl_3trow.lua:
local PANEL = {}
local col1 = Color(32, 32, 32)
function PANEL:Init()
    self:SetText('')
    -- UI
    self.Title = 'My Row'
    self.Font = 'Trebuchet24'
    self.Color = color_white
    self.Description = ''
    self.titleWidth = 0
    self.Info = vgui.Create('DButton', self)
    self.Info:SetSize(0, 0)
    self.Info:SetPos(0, 0)
    self.Info:SetText('')
    self.Info.Paint = function(_, w, h) draw.SimpleText('?', 'comfortaa15', w * 0.5 - 3, h * 0.5, color_white, nil, TEXT_ALIGN_CENTER) end
    self.Info.OnCursorEntered = function()
        local body = vgui.Create('DPanel')
        local x, y = self:LocalToScreen(self.Info:GetPos())
        surface.SetFont('comfortaa15')
        local wT, hT = surface.GetTextSize(self.Description)
        local margin = 5
        local wide = 300
        local tall = (hT + margin * 2) * (wT / wide > 1 and wT / wide or 1)
        body:SetSize(wide + margin * 2, tall)
        body:SetPos(x + self.Info:GetWide(), y + self.Info:GetTall())
        body:MakePopup()
        local desc = vgui.Create('DLabel', body)
        desc:SetSize(wide, tall)
        desc:SetPos(margin, 0)
        desc:SetText(self.Description)
        desc:SetFont('comfortaa15')
        desc:SetWrap(true)
        body.Paint = function(_, w, h) draw.RoundedBox(6, 0, 0, w, h, col1) end
        self.Info.Menu = body
    end

    self.Info.OnCursorExited = function() if IsValid(self.Info.Menu) then self.Info.Menu:Remove() end end
    self.Info:SetVisible(false)
    self.OnRemove = function() if IsValid(self.Info.Menu) then self.Info.Menu:Remove() end end
end

function PANEL:SetTitle(title)
    if not title or not isstring(title) then return end
    self.Title = title
    surface.SetFont(self.Font)
    self.titleWidth = surface.GetTextSize(self.Title)
    self.Info:SetPos(self.titleWidth, 0)
end

function PANEL:SetTitleColor(color)
    if not color or not IsColor(color) then return end
    self.Color = color
end

function PANEL:SetFont(font)
    if not font or not isstring(font) then return end
    self.Font = font
    surface.SetFont(self.Font)
    self.titleWidth = surface.GetTextSize(self.Title)
    self.Info:SetPos(self.titleWidth, self:GetTall() * 0.125)
end

function PANEL:SetDescription(sText)
    if not sText or not isstring(sText) then return end
    self.Description = sText
    self.Info:SetVisible(self.Description ~= '')
end

function PANEL:Paint(w, h)
    draw.SimpleText(self.Title, self.Font, 0, h * 0.5, self.Color, nil, TEXT_ALIGN_CENTER)
end

function PANEL:PerformLayout(w, h)
    self.Info:SetSize(h * 0.5, h * 0.5)
end

vgui.Register('3T:Row', PANEL, 'DPanel')
--PATH addons/shaccessorysystem/lua/accessory_config.lua:
/****
	GENERAL CONFIGURATION
	General
****/

-- Whether to use the server's database (sv.db) or MySQL. Restart the map after changing database mode.
-- WARNING: You cannot transfer items from one database to another.
-- 0: sv.db (local)
-- 1: MySQL via gmsv_mysqloo (https://facepunch.com/showthread.php?t=1515853)
--	  Configure the DB settings in accessory/sv_database.lua
-- 2: MySQL via gmsv_tmysql4
--	  Configure the DB settings in accessory/sv_database.lua
SH_ACC.DatabaseMode = 0

-- Set to true to allow players to run a command (defined below) to bring up the menu.
-- AKA players can change their accessories at any time given.
SH_ACC.FreeAccess = false

-- Commands to open the accessory menu. Only works when FreeAccess is true.
-- ! is automatically replaced to / so you don't have to include them.
SH_ACC.FreeAccessCommand = {
	"/accessory",
	"/accessories",
	"/acc",
}

-- Which usergroups are allowed to use the system.
-- Leave the table empty to allow everyone to use the add-on.
SH_ACC.AllowedUsergroups = {
	// Remove the -- below to allow only "vip" players to use the add-on.
	-- ["vip"] = true,
}

-- Fraction of an accessory's price.
-- Anything below 0 will result in unintended behavior!
SH_ACC.PurchaseFrac = 1

-- Different purchase price fractions for specific usergroups.
-- If available, this overrides the PurchaseFrac option but is overriden by PurchaseFracPlayers.
SH_ACC.PurchaseFracUsergroups = {
	["vip"] = 0.97
}

-- Different purchase price fractions for specific players.
-- SteamID only.
-- If available, this overrides the PurchaseFrac and PurchaseFracUsergroups options.
SH_ACC.PurchaseFracPlayers = {
	-- ["STEAM_0:0:0"] = 0.1,
}

-- How many accessories a player can wear at a time.
-- Set to 0 to remove the limit.
SH_ACC.MaximumWearable = 0

-- Different wearable accessory limit for specific usergroups.
-- If available, this overrides the MaximumWearable option but is overriden by MaximumWearablePlayers.
SH_ACC.MaximumWearableUsergroups = {
	-- ["admin"] = 100,
	-- ["superadmin"] = 100,
}

-- Different wearable accessory limit for specific players.
-- SteamID only.
-- If available, this overrides the MaximumWearable and MaximumWearableUsergroups options.
SH_ACC.MaximumWearablePlayers = {
	-- ["STEAM_0:0:0"] = 100,
}

-- Disable key shortcuts when using the shop.
-- TAB = toggle navigation bar
-- 1-9 = browse categories
-- Ctrl+F = open search bar
-- MOUSE4 (in adjust menu) = close adjust menu
SH_ACC.DisableKeyShortcuts = false

-- Disable the info tab.
-- Shows name, credits, version, add-ons enabled, how many accessories are installed and a link to the ScriptFodder page.
SH_ACC.DisableInfoTab = false

-- Where to spawn Accessories Vendor NPCs on the map.
-- Use the "sh_accessories_mypos" console command to get your current position and angle.
SH_ACC.NPCSpawns = {
	-- {pos = Vector(0, 0, 0), ang = Angle(0, 0, 0)},
}

-- How long equipping an accessory from the SWEP takes in seconds.
SH_ACC.DelayedEquipTime = 6

-- How long unequipping an accessory from the SWEP takes in seconds.
SH_ACC.DelayedUnequipTime = 1

-- Whether to send the (interface) content used by the script via Steam Workshop or FastDL.
SH_ACC.UseWorkshop = false

/****
	GENERAL CONFIGURATION
	Adjusting
****/

-- Should players be allowed to adjust their accessories?
-- Adjusting is moving, rotating or scaling an accessory slightly in case it doesn't or barely fits a player model.
SH_ACC.AllowAdjusting = true

-- Specific usergroups allowed (or not) to adjust accessories.
-- If available, this overrides the AllowAdjusting option but is overriden by AllowAdjustingPlayers.
SH_ACC.AllowAdjustingUsergroups = {
	-- ["vip"] = true,
	-- ["root"] = true,
	-- ["superadmin"] = true,
}

-- Allow specific players to adjust or not.
-- SteamID only.
-- If available, this overrides the AllowAdjusting and AllowAdjustingUsergroups options.
SH_ACC.AllowAdjustingPlayers = {
	-- ["STEAM_0:0:0"] = false,
}

-- Factor determining how much a player can adjust their accessory.
-- The smaller the value, the less the player will be able to adjust their accessory.
-- The higher, the (potentially) further they can move, rotate or scale it from their body, resulting in hilarious consequences.
-- Anything below or equal to 0 will produce unexpected results, so don't do that.
SH_ACC.AdjustFactor = 5

-- Different adjusting factors for specific usergroups.
-- If available, this overrides the AdjustFactor option but is overriden by AdjustFactorPlayers.
SH_ACC.AdjustFactorUsergroups = {
	-- ["admin"] = 100,
	-- ["superadmin"] = 100,
}

-- Different adjusting factors for specific players.
-- SteamID only.
-- If available, this overrides the AdjustFactor and AdjustFactorUsergroups options.
SH_ACC.AdjustFactorPlayers = {
	-- ["STEAM_0:0:0"] = 100,
}

-- How much translating, rotating and scaling are affected by adjustment.
-- Don't touch unless you've got a good reason to.
SH_ACC.IndividiualAdjustFactor = {
	translate = 0.5,
	rotate = 1,
	scale = 0.01,
}

/****
	GENERAL CONFIGURATION
	Selling
****/

-- Can players sell their accessories?
SH_ACC.AllowSelling = true

-- Allow specific usergroups to sell or not.
-- If available, this overrides the AllowSelling option but is overriden by AllowSellingPlayers.
SH_ACC.AllowSellingUsergroups = {
	-- ["admin"] = true,
	-- ["superadmin"] = true,
}

-- Allow specific players to sell or not.
-- SteamID only.
-- If available, this overrides the AllowSelling and AllowSellingUsergroups options.
SH_ACC.AllowSellingPlayers = {
	-- ["STEAM_0:0:0"] = false,
}

-- Fraction of money players get by selling an accessory
-- Anything below 0 will result in unintended behavior!
SH_ACC.SellFrac = 0.001

-- Different sell value fractions for specific usergroups.
-- If available, this overrides the SellFrac option but is overriden by SellFracPlayers.
SH_ACC.SellFracUsergroups = {
	-- ["vip"] = 0.75,
	-- ["admin"] = 1,
	-- ["superadmin"] = 1,
}

-- Different sell value fractions for specific players.
-- SteamID only.
-- If available, this overrides the SellFrac and SellFracUsergroups options.
SH_ACC.SellFracPlayers = {
	-- ["STEAM_0:0:0"] = 100,
}

/****
	GENERAL CONFIGURATION
	Rendering
****/

-- Draw accessories on player bodies
SH_ACC.DrawOnBodies = true

-- Draw accessories on arrested players
SH_ACC.DrawOnArrested = false

-- Draw accessories even if they can't find the player's bone
-- (often they will be badly positionned, like real bad)
SH_ACC.DisplayWithEmptyBone = false

-- Maximum distance at which the accessories can be rendered. In units.
-- Set to 0 for infinite distance
SH_ACC.RenderDistance = 0

/****
	GENERAL CONFIGURATION
	Interface
****/

-- Blur the blackground in black when the menu is open
SH_ACC.DrawBackgroundBlur = true

-- Show messages when equipping/unequipping something
SH_ACC.EquipMessages = true

-- Categories displayed in the Shop.
-- Here you can move categories around or even delete them.
SH_ACC.ShopCategories = {
	{text = "head", slot = SH_SLOT_HEAD, icon = Material("shenesis/accessory/hat.png", "noclamp smooth")},
	{text = "eyes", slot = SH_SLOT_EYES, icon = Material("shenesis/accessory/sunglasses.png", "noclamp smooth")},
	{text = "mouth", slot = SH_SLOT_MOUTH, icon = Material("shenesis/accessory/mask.png", "noclamp smooth")},
	{text = "neck", slot = SH_SLOT_NECK, icon = Material("shenesis/accessory/scarf.png", "noclamp smooth")},
	{text = "back", slot = SH_SLOT_BACK, icon = Material("shenesis/accessory/backpack.png", "noclamp smooth")},
}

/****
	STYLE CONFIGURATION
****/

-- Font to use for normal text throughout the interface.
SH_ACC.Font = "Circular Std Medium"

-- Font to use for bold text throughout the interface.
SH_ACC.FontBold = "Circular Std Bold"

-- Color sheet. Only modify if you know what you're doing
SH_ACC.Style = {
	header = Color(52, 152, 219),
	bg = Color(52, 73, 94),
	inbg = Color(44, 62, 80),

	close_hover = Color(231, 76, 60),
	hover = Color(255, 255, 255, 10),
	hover2 = Color(255, 255, 255, 5),

	text = Color(255, 255, 255),
	text_down = Color(0, 0, 0),
	can_afford = Color(46, 204, 17),
	cant_afford = Color(231, 76, 60),
	equipped = Color(52, 152, 219),
	possessed = Color(241, 196, 15),
	restricted = Color(230, 126, 34),

	menu = Color(127, 140, 141),
}

/****
	LANGUAGE CONFIGURATION
****/

-- Names corresponding to each accessory slot.
-- You shouldn't have to modify this. Modify the Language table instead.
-- If you (manage to) add a new slot, make sure to register it here or the add-on will not work!
SH_ACC.SlotText = {
	[SH_SLOT_HEAD] = "head",
	[SH_SLOT_EYES] = "eyes",
	[SH_SLOT_MOUTH] = "mouth",
	[SH_SLOT_BACK] = "back",
	[SH_SLOT_NECK] = "neck",
}

-- Various strings used throughout the add-on. Change them to your language here.
-- %s and %d are special strings replaced with relevant info, keep them in the string!

-- French translation: http://pastebin.com/aHGFnN5A

SH_ACC.Language = {
	accessory_vendor = "Продавець аксесуарів",
	accessory_changer = "Зміна аксесуарів",

	toggle = "Перемикач",
	purchase = "Придбати",
	sell = "Продати",
	equip = "Одягнути",
	unequip = "Зняти",
	adjust = "Регулювати",
	adjust_desc = "Регулювання вашого аксесуара дозволяє перемістити, повернути або трохи масштабувати модель, якщо вона не підходить ідеально. Зверніть увагу, що налаштування застосовуються до всіх моделей гравців.",
	quick_switch = "Швидке перемикання..",
	accessory_limit = "Ліміт аксесуарів",
	search = "Пошук",

	none = "Жодного",
	free = "Безкоштовно",
	equipped = "Обладнаний",
	possessed = "Куплено",
	restricted = "Обмежений",
	job_specific = "Особлива робота",
	yes = "Так",
	no = "Ні",
	info = "Інформація",

	translate = "Перекласти", -- "Move"
	rotate = "Обертати",
	scale = "Масштаб",
	reset_adjustments = "Скидання налаштувань",

	confirm_action = "Підтвердити дію",
	buy_confirm = "Ви дійсно бажаєте придбати аксесуар %s за %s?",
	sell_confirm = "Ви дійсно хочете продати аксесуар %s за %s? Його автоматично буде знято з обладнання.",
	this_accessory_covers_x = "Заповнює кілька слотів: %s",
	failed_to_perform_action = "Не вдалося виконати дію.",
	cant_afford_x = "У вас недостатньо грошей, щоб купити %s!",
	reached_acc_limit = "Ви досягли ліміту аксесуарів, які можете носити.",
	cannot_purchase_accessory = "Неможливо придбати аксесуар",
	cannot_sell_accessory = "Неможливо продати аксесуар",
	bad_usergroup = "Ваша група користувачів не дозволяє вам носити аксесуари.",

	you_equipped_x = "Тепер ви носите %s.",
	you_equipped_x_swapped_with_y = "Тепер ви носите %s (замінено на %s).",
	you_unequipped_x = "Ви більше не носите %s.",
	you_purchased_x = "Ви придбали %s!",
	you_sold_x_for_y = "Ви продали %s за %s!",
	equipping_to_acc = "Спорядження %s, зачекайте..",
	unequipping_acc = "Знімається %s, зачекайте..",

	-- model panel instructions
	left_click_help = "ЛКМ: Горизонтальний поворот",
	right_click_help = "ПКМ: Збільшити",
	middle_click_help = "СКМ: Перетягніть перегляд",

	-- slots
	overview = "Огляд",
	head = "Голова",
	eyes = "Очі",
	mouth = "Рот",
	back = "Спина",
	neck = "Шия",
}

--PATH addons/shaccessorysystem/lua/accessory/sh_obj_player_extend.lua:
local meta = FindMetaTable("Player")

--
function meta:SH_NearAccessoryVendor()
	if SH_ACC.FreeAccess then return true end
	local pos = self:GetPos()

	for _, v in ipairs(ents.FindByClass("npc_accessory_vendor")) do
		if v:GetPos():Distance(pos) <= 256 then return true end
	end

	return false
end

function meta:SH_HasAccessoryChanger()
	local swep = self:GetActiveWeapon()
	if IsValid(swep) and swep:GetClass() == "sh_accessory_changer" then return swep end

	return false
end

function meta:SH_HasAccessory(id)
	if not self.SH_AccessoryInfo then return false end

	return self.SH_AccessoryInfo.inventory[id] ~= nil
end

function meta:SH_HasAccessoryEquipped(id)
	if not self.SH_AccessoryInfo then return false end

	return self.SH_AccessoryInfo.equipped[id] ~= nil
end

function meta:SH_CanAdjustAccessories()
	local ap = SH_ACC.AllowAdjustingPlayers[self:SteamID()]
	if ap ~= nil then return ap end
	local au = SH_ACC.AllowAdjustingUsergroups[self:GetUserGroup()]
	if au ~= nil then return au end

	return SH_ACC.AllowAdjusting
end

function meta:SH_GetAccessoryPurchaseFrac()
	return SH_ACC.PurchaseFracPlayers[self:SteamID()] or SH_ACC.PurchaseFracUsergroups[self:GetUserGroup()] or SH_ACC.PurchaseFrac
end

function meta:SH_GetAccessorySellFrac()
	return SH_ACC.SellFracPlayers[self:SteamID()] or SH_ACC.SellFracUsergroups[self:GetUserGroup()] or SH_ACC.SellFrac
end

function meta:SH_GetAccessoryAdjustFactor()
	return SH_ACC.AdjustFactorPlayers[self:SteamID()] or SH_ACC.AdjustFactorUsergroups[self:GetUserGroup()] or SH_ACC.AdjustFactor
end

function meta:SH_GetAccessoryLimit()
	return SH_ACC.MaximumWearablePlayers[self:SteamID()] or SH_ACC.MaximumWearableUsergroups[self:GetUserGroup()] or SH_ACC.MaximumWearable
end

function meta:SH_CanSellAccessories()
	local sp = SH_ACC.AllowSellingPlayers[self:SteamID()]
	if sp ~= nil then return sp end
	local su = SH_ACC.AllowSellingUsergroups[self:GetUserGroup()]
	if su ~= nil then return su end

	return SH_ACC.AllowSelling
end

function meta:SH_GetNumEquippedAccessories()
	if not self.SH_AccessoryInfo then return 0 end

	return table.Count(self.SH_AccessoryInfo.equipped)
end

function SH_ACC.CanAfford(ply, i)
	return ply:CanAfford(i)
end

-- boo
local function attachCurrency(str)
	local config = GAMEMODE.Config
	if not config then return "$" .. str end
	local cr = config.currency or "$"

	return config.currencyLeft and cr .. str or str .. cr
end

function SH_ACC.formatMoney(n)
	return rp.FormatMoney(n)
end
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_lang.lua:
include( "ballistic_shields/sh_bs_util.lua" )
bshields.lang = {
	["English"] = {
		["sec"] = "[RMB] VISIBILITY",
		["dshieldprim"] = "[LMB] DEPLOY",
		["hshieldprim"] = "[LMB] BREACH DOOR",
		["rshieldprim"] = "[LMB] ATTACK",
		["hshieldcd1"] = "Wait ",
		["hshieldcd2"] = " seconds to breach next door!"
	},
	["German"] = {
		["sec"] = "[RMB] SICHTBARKEIT",
		["dshieldprim"] = "[LMB] PLAZIEREN",
		["hshieldprim"] = "[LMB] TÜR AUFBRECHEN",
		["rshieldprim"] = "[LMB] ANGREIFEN",
		["hshieldcd1"] = "Warte ",
		["hshieldcd2"] = " Sekunden für das Aufbrechen der nächsten Tür!"
	},
	["French"] = {
		["sec"] = "[RMB] VISIBILITÉ",
		["dshieldprim"] = "[LMB] DÉPLOYER",
		["hshieldprim"] = "[LMB] FORCER LA PORTE",
		["rshieldprim"] = "[LMB] ATTAQUER",
		["hshieldcd1"] = "Attendez ",
		["hshieldcd2"] = " secondes pour forcer la porte !"
	},
	["Danish"] = {
		["sec"] = "[RMB] SIGTBARHED",
		["dshieldprim"] = "[LMB] SÆT",
		["hshieldprim"] = "[LMB] BREACH DØR",
		["rshieldprim"] = "[LMB] ANGRIB",
		["hshieldcd1"] = "Vent ",
		["hshieldcd2"] = " sekunder at bryde ved siden af!"
	},
	["Turkish"] = {
		["sec"] = "[RMB] GORUNURLUK",
		["dshieldprim"] = "[LMB] YERLESTIR",
		["hshieldprim"] = "[LMB] BREACH DOOR",
		["rshieldprim"] = "[LMB] SALDIR",
		["hshieldcd1"] = "Bekle ",
		["hshieldcd2"] = " bir sonraki kapıyı kırmaya saniye kaldı!"
	},
	["Russian"] = {
		["sec"] = "[ПКМ] ВИДИМОСТЬ",
		["dshieldprim"] = "[ЛКМ] ПОСТАВИТЬ",
		["hshieldprim"] = "[ЛКМ] ВЫБИТЬ ДВЕРЬ",
		["rshieldprim"] = "[ЛКМ] УДАРИТЬ",
		["hshieldcd1"] = "Подождите ",
		["hshieldcd2"] = " секунд чтоб выбить дверь!"
	},
	["Ukrainian"] = {
		["sec"] = "[ПКМ] ВИДИМІСТЬ",
		["dshieldprim"] = "[ЛКМ] ПОСТАВИТИ",
		["hshieldprim"] = "[ЛКМ] ВИБИТИ ДВЕРІ",
		["rshieldprim"] = "[ЛКМ] ВДАРИТИ",
		["hshieldcd1"] = "Зачекайте ",
		["hshieldcd2"] = " секунд щоб вибити двері!"
	}
}

if bshields.lang[bshields.config.language] == nil then bshields.config.language = "English" end
--PATH addons/__main/lua/autorun/codmw_velikan.lua:
player_manager.AddValidModel("CoD: MW Velikan", "models/kuma96/codmw/characters/velikan/velikan_pm.mdl")
player_manager.AddValidHands("CoD: MW Velikan", "models/weapons/velarms.mdl", 0, "0")

--PATH addons/_drones/lua/dronesrewrite/main.lua:
--[[
	Drones Rewrite
]]

DRONES_REWRITE = { }

DRONES_REWRITE.Version = 5

DRONES_REWRITE.HUD = { }
DRONES_REWRITE.Overlay = { }
DRONES_REWRITE.Weapons = { }

DRONES_REWRITE.Keys = {
	["Forward"] = KEY_W,
	["Back"] = KEY_S,
	["Right"] = KEY_D,
	["Left"]  = KEY_A,
	["Down"]  = KEY_LCONTROL,
	["Up"] = KEY_SPACE,
	["Sprint"] = KEY_LSHIFT,
	["MoveSlowly"] = KEY_LALT,

	["Exit"] = KEY_E,
	["ThirdPerson"] = KEY_I,
	["Enable"] = KEY_G,
	["Fire1"] = MOUSE_LEFT,
	["Fire2"] = MOUSE_RIGHT,
	["SelfDestruct"] = KEY_J,
	["NightVision"] = KEY_R,
	["Flashlight"] = KEY_F,
	
	["SpecialKey"] = MOUSE_MIDDLE,
	["WeaponView"] = KEY_T,
	["Zoom"] = KEY_H,

	["StrafeRight"] = KEY_0, -- By default Strafes are not enabled
	["StrafeLeft"] = KEY_0
}

DRONES_REWRITE.SortedKeys = {
	"Forward",
	"Back",
	"Right",
	"Left",
	"Down",
	"Up",
	"Sprint",
	"MoveSlowly",

	"Exit",
	"ThirdPerson",
	"Enable",
	"Fire1",
	"Fire2",
	"SelfDestruct",
	"NightVision",
	"Flashlight",
	
	"SpecialKey",
	"WeaponView",
	"Zoom",

	"StrafeRight",
	"StrafeLeft"
}

DRONES_REWRITE.GetDrones = function()
	local tab = { }

	for _, v in ents.Iterator() do
		if v.IS_DRONE then tab[#tab + 1] = v end
	end

	return tab
end

DRONES_REWRITE.GetDronesRewrite = function()
	local tab = { }

	for _, v in ents.Iterator() do
		if v.IS_DRR then tab[#tab + 1] = v end
	end

	return tab
end

DRONES_REWRITE.FindDroneByUnit = function(unit)
	for _, v in ipairs(DRONES_REWRITE.GetDronesRewrite()) do
		if string.find(string.lower(v:GetUnit()), string.lower(unit)) then return v end
	end

	return NULL
end

DRONES_REWRITE.IncludeFolder = function(path, recursive, str, fileFilter)
	str = str or "sh"
	fileFilter = fileFilter or { }

	local f, p = file.Find(path .. "/*", "LUA")

	for _, v in ipairs(f) do
		if table.HasValue(fileFilter, v) then continue end

		local file = path .. "/" .. v

		if CLIENT and (str == "cl" or str == "sh") then
			include(file)
		end

		if SERVER then
			if str == "sv" or str == "sh" then
				include(file)
			end

			AddCSLuaFile(file)
		end
	end

	if recursive then
		for _, v in ipairs(p) do
			DRONES_REWRITE.IncludeFolder(path .. "/" .. v, str)
		end
	end
end

DRONES_REWRITE.LoadFile = function(path)
	if SERVER then AddCSLuaFile(path) end
	include(path)
end

DRONES_REWRITE.LoadFile("dronesrewrite/receiver.lua")
DRONES_REWRITE.LoadFile("dronesrewrite/cvars.lua")
DRONES_REWRITE.IncludeFolder("dronesrewrite", false, "sh", { "main.lua", "receiver.lua", "cvars.lua" })
DRONES_REWRITE.IncludeFolder("dronesrewrite/client", true, "cl")
DRONES_REWRITE.IncludeFolder("dronesrewrite/weapons", true)

DRONES_REWRITE.DoPrecache = function()
	local a, models = file.Find("models/dronesrewrite/*", "GAME")

	local count = 0

	for _, mdlName in ipairs(models) do
		local path = Format("models/dronesrewrite/%s/", mdlName)
		local mdlf, emp = file.Find(path .. "*", "GAME")
			
		for __, mdl in ipairs(mdlf) do
			if string.find(mdl, ".mdl") then
				util.PrecacheModel(path .. mdl)
				count = count + 1
				break
			end
		end
	end

	print(Format("Precached %i Drones Rewrite models", count))
end

if SERVER then
	hook.Add("Initialize", "dronesrewrite_inithook", function()
		timer.Simple(0, function()
			-- http.Fetch("https://raw.githubusercontent.com/calafex/DronesRewrite/master/version.txt",
			-- 	function(body, len, headers, code)
			-- 		local version = tonumber(body)

			-- 		if version == DRONES_REWRITE.Version then
			-- 			MsgC(Color(0, 255, 0), "\nDrones Rewrite is up to date!\n")
			-- 		else
			-- 			local msg1 = "\nSeems like Drones Rewrite is outdated!"
			-- 			local msg2 = "\nNew version: " .. body
			-- 			local msg3 = "\nYour version: " .. DRONES_REWRITE.Version .. "!\n"
			-- 			MsgC(Color(255, 100, 80), msg1, msg2, msg3)

			-- 			print("Please download new version here: http://steamcommunity.com/sharedfiles/filedetails/?id=669642096")
			-- 		end
			-- 	end,

			-- 	function(error)
			-- 		print("Cannot check version of Drones Rewrite!")
			-- 	end
			-- )

			DRONES_REWRITE.DoPrecache()
		end)
	end)
end

DRONES_REWRITE.Loaded = true

if SERVER then MsgC(Color(0, 255, 0), "\nDrones Rewrite has been loaded! Addon version: " .. DRONES_REWRITE.Version .. "\n") end
--PATH addons/_drones/lua/dronesrewrite/client/overlay/blackandwhite.lua:
DRONES_REWRITE.Overlay["Black and white"] = function(drone)
	local tab = {
		["$pp_colour_addr"] = 0,
		["$pp_colour_addg"] = 0,
		["$pp_colour_addb"] = 0,
		["$pp_colour_brightness"] = 0,
		["$pp_colour_contrast"] = 1,
		["$pp_colour_colour"] = 0,
		["$pp_colour_mulr"] = 0,
		["$pp_colour_mulg"] = 0,
		["$pp_colour_mulb"] = 0
	}
	
	DrawColorModify(tab)
end
--PATH addons/_drones/lua/dronesrewrite/client/overlay/default.lua:
DRONES_REWRITE.Overlay["Default"] = function(drone)
	local eff_tab = {
		["$pp_colour_addr"] = 0,
		["$pp_colour_addg"] = 0.1,
		["$pp_colour_addb"] = 0.1,
		["$pp_colour_brightness"] = -0.1,
		["$pp_colour_contrast"] = 1,
		["$pp_colour_colour"] = 1,
		["$pp_colour_mulr"] = 0,
		["$pp_colour_mulg"] = 0,
		["$pp_colour_mulb"] = 0
	}

	DrawColorModify(eff_tab)
end
--PATH addons/_drones/lua/dronesrewrite/client/overlay/drones2.lua:
DRONES_REWRITE.Overlay["Drones 2"] = function(drone)
	local eff_tab = {
		["$pp_colour_addr"] = 0.2,
		["$pp_colour_addg"] = 0,
		["$pp_colour_addb"] = 0.2,
		["$pp_colour_brightness"] = -0.2,
		["$pp_colour_contrast"] = 1,
		["$pp_colour_colour"] = 1.5,
		["$pp_colour_mulr"] = 0,
		["$pp_colour_mulg"] = 0,
		["$pp_colour_mulb"] = 1
	}

	DrawColorModify(eff_tab)
	DrawMaterialOverlay("effects/combine_binocoverlay.vmt", 0)
end
--PATH addons/_drones/lua/dronesrewrite/weapons/blaster4.lua:
DRONES_REWRITE.Weapons["Blue Blaster"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/blaster/blaster.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		ent.PrimaryAmmo = 800
		ent.PrimaryAmmoMax = 800
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Plasma }

		ent.WaitTime = 0

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)

		if gun.PlaySound and CurTime() > gun.NextShoot2 then
			gun:EmitSound("vehicles/tank_readyfire1.wav", 78, 255, 1, CHAN_WEAPON)
			gun.PlaySound = false
		end
	end,

	Attack = function(self, gun)
		if not self:IsKeyDown("Fire2") and  CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local src = gun:GetPos() + gun:GetForward() * 64 + gun:GetUp()

			local ammo = ents.Create("dronesrewrite_bl2_laser")
			ammo:SetPos(src)
			ammo:SetAngles(gun:GetAngles() + AngleRand() * 0.004)
			ammo:Spawn()
			ammo.Owner = self:GetDriver()
			
			constraint.NoCollide(ammo, self, 0, 0)

			ammo:EmitSound("drones/alien_fire.wav", 85, 100, 1, CHAN_WEAPON)

			local ef = EffectData()
			ef:SetOrigin(src - gun:GetForward() * 20)
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_muzzleflashblaster4", ef)
	
			gun:SetPrimaryAmmo(-1)
			gun.NextShoot = CurTime() + 0.1
		end
	end,

	Attack2 = function(self, gun)
		if not self:IsKeyDown("Fire1") and CurTime() > gun.NextShoot2 and gun:HasPrimaryAmmo() then
			local src = gun:GetPos() + gun:GetForward() * 64 - gun:GetUp() * 2.5

			local ammo = ents.Create("dronesrewrite_bl2_laser_sm")
			ammo:SetPos(src)
			ammo:SetAngles(gun:GetAngles() + AngleRand() * 0.02)
			ammo:Spawn()
			ammo.Owner = self:GetDriver()
			
			constraint.NoCollide(ammo, self, 0, 0)

			ammo:EmitSound("drones/alien_fire.wav", 85, math.random(90, 120), 1, CHAN_WEAPON)

			local ef = EffectData()
			ef:SetOrigin(src - gun:GetForward() * 21)
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_muzzleflashblaster4", ef)	

			gun:SetPrimaryAmmo(-1)
			gun.NextShoot2 = CurTime() + 0.02

			gun.WaitTime = math.Approach(gun.WaitTime, 1, 0.01)
			if gun.WaitTime >= 1 then 
				gun.PlaySound = true
				gun.NextShoot2 = CurTime() + 3.6
				gun.WaitTime = 0
			end
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/minigunlight.lua:
DRONES_REWRITE.Weapons["Light Minigun"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/minigunlight/minigunlight.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		DRONES_REWRITE.Weapons["Template"].SpawnSource(ent, Vector(50, 0, 3))

		ent.Rotate = 0
		ent.Angle = 0

		ent.PrimaryAmmo = 2500
		ent.PrimaryAmmoMax = 2500
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Pistol }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)

		if gun.StopRotating then
			gun.Rotate = math.Approach(gun.Rotate, 0, 0.025)
		end

		gun.Angle = gun.Angle + (gun.Rotate * 20)
		gun:ManipulateBoneAngles(gun:LookupBone("barr"), Angle(0, gun.Angle, 0))
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot then
			if gun:HasPrimaryAmmo() then
				local tr = self:GetCameraTraceLine()

				local bullet = {}
				bullet.Num = 1
				bullet.Src = gun.Source:GetPos()
				bullet.Dir = gun:GetLocalCamDir()
				bullet.Spread = Vector(0.01, 0.01, 0.01)
				bullet.Tracer = math.random(5, 12)
				bullet.Force = 5
				bullet.Damage = 4
				bullet.Attacker = self:GetDriver()
				
				gun:EmitSound("weapons/ar2/fire1.wav", 80, math.random(100, 120), 1, CHAN_WEAPON)
				gun.Source:FireBullets(bullet)
				self:SwitchLoopSound("Minigun", true, "drones/minigunshoot.wav", 110, 1, 80)

				local phys = self:GetPhysicsObject()
				phys:ApplyForceCenter((gun:GetPos() - tr.HitPos):GetNormal() * 200000 / self.Weight)
				phys:AddAngleVelocity(VectorRand() * 600 / self.Weight)

				local ef = EffectData()
				ef:SetOrigin(gun.Source:GetPos())
				ef:SetNormal(gun:GetForward())
				util.Effect("dronesrewrite_muzzleflash", ef)

				gun:SetPrimaryAmmo(-1)
			else
				self:SwitchLoopSound("Minigun", false)
			end

			self:SetFuel(self:GetFuel() - 0.02)
			self:SwitchLoopSound("MinigunSpin", true, "vehicles/crane/crane_idle_loop3.wav", 120, 1, 89)

			gun.StopRotating = false
			gun.Rotate = 1
			gun.NextShoot = CurTime() + 0.01
		end
	end,

	OnAttackStopped = function(self, gun)
		gun.StopRotating = true
		gun:EmitSound("vehicles/apc/apc_shutdown.wav", 65, 80)

		self:SwitchLoopSound("Minigun", false)
		self:SwitchLoopSound("MinigunSpin", false)
	end,

	Holster = function(self, gun)
		gun.StopRotating = true
		gun:EmitSound("vehicles/apc/apc_shutdown.wav", 65, 80)

		self:SwitchLoopSound("Minigun", false)
		self:SwitchLoopSound("MinigunSpin", false)
	end,

	OnRemove = function(self, gun)
		self:SwitchLoopSound("Minigun", false)
		self:SwitchLoopSound("MinigunSpin", false)
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/user.lua:
DRONES_REWRITE.Weapons["User"] = {
	Initialize = function(self)
		return DRONES_REWRITE.Weapons["Template"].InitializeNoDraw(self)
	end,

	Attack = function(self, gun)
		if self:WasKeyPressed("Fire1") and CurTime() > gun.NextShoot then
			local ent = self:GetCameraTraceLine(100).Entity

			if ent:IsValid() and not ent.IS_DRONE then
				ent:Use(self, self, 1, 1)
			end

			gun.NextShoot = CurTime() + 0.5
		end
	end
}
--PATH addons/____echat/lua/autorun/echat_loader.lua:
echat = echat or {} -- initialize
echat.EmojiMaterials = echat.EmojiMaterials or {}
echat.Materials = echat.Materials or {}

local errorMat = Material("error")
function echat:GetMaterial(filename)
	return echat.Materials[filename] or errorMat
end

if ( SERVER ) then
	--content (materials)
	--resource.AddWorkshop( "3152189815" ) -- https://steamcommunity.com/sharedfiles/filedetails/?id=3152189815
end

local function load_emojies(load)
	local emoji = {}

	--copy
	local copied_mats = table.Copy(load.Materials)
	table.Empty(load.Materials)

	load:MaterialFolder("materials/echat/emoji",true,false) --path, recurse, share with clients
	esclib:SafeMerge(emoji, load.Materials, true)
	table.Empty(load.Materials)

	--restore
	load.Materials = table.Copy(copied_mats)

	local result = {}
	local count = 0
	for name,mat in pairs(emoji) do
		local sname = string.TrimRight(name,".png")
		sname = string.TrimRight(sname,".jpeg")
		sname = string.TrimRight(sname,".jpg")
		sname = sname or "Unknown"

		result[sname] = mat
		count = count + 1
	end

	load:Print("[echat] Loaded "..count.." emoji")

	esclib:SafeMerge(echat.EmojiMaterials, result, true)
end

local function loader()
	print("[echat loader]")
	--Using esclib loader system

	esclib.loader:New("echat","echat/",function(load)
		--fonts used in addon
		-- load:Resource("resource/fonts/inter_regular.ttf")
		-- load:Resource("resource/fonts/robotomono_regular.ttf")

		--In workshop content

		--load all emoji, and clears current materials table (to split them)
		load_emojies(load)

		load:MaterialFolder("materials/echat",false,false) --load.Materials params: path, isrecurse, download
		esclib:SafeMerge(echat.Materials, load.Materials, true)

		--CONFIGS
		load:Shared("config/meta.lua") -- creating addon instance
		load:Shared("config/config.lua")
		load:Shared("config/ingame_config.lua")
		load:Client("config/themes.lua")
		load:Client("config/languages.lua")

		--VGUI
		load:ClientFolder("vgui")

		--MAIN FILES
		load:Shared("core/tools/fonts.lua")
		load:Client("core/tools/module_loader.lua")
		load:Shared("core/tools/parsers_core.lua")
		load:Client("core/tools/auto_complete.lua")
		load:Server("core/tools/server_funcs.lua")
		
		load:Shared("core/parsers.lua")
		load:Client("core/complete_helpers.lua")

		--load all files from modules folder
		load:SharedFolder("core/modules")

		--Main app
		load:Client("core/__core_build__.lua")
		load:Client("core/__core_funcs__.lua")

	end)
end

--lua refresh compat
if esclib && esclib.loader then
	if esclib.loader:IsLoaded("echat") then
		loader()
	end
end

hook.Add("esclib_loaded", "echat_load", function()
	loader()
end)
--PATH addons/ukrp_main_content/lua/autorun/kazumakiryu.lua:
/*
	Addon by Voikanaa	
*/

player_manager.AddValidModel( "Kazuma Kiryu", 	"models/player/voikanaa/kazuma_kiryu.mdl" );
player_manager.AddValidHands( "Kazuma Kiryu", 	"models/player/voikanaa/kazuma_kiryu_arms.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Kazuma Kiryu", "models/player/voikanaa/kazuma_kiryu.mdl" );
--PATH addons/ukrp_1_content/lua/autorun/krsn_dd2_jester_pm.lua:
player_manager.AddValidModel( "Darkest Dungeon 2 - Jester", "models/kerosenn/darkest_dungeon/heroes/Jester/playermodel/dd2_Jester_pm.mdl" )
player_manager.AddValidHands( "Darkest Dungeon 2 - Jester", "models/kerosenn/darkest_dungeon/heroes/Jester/viewmodel/dd2_Jester_vm.mdl", 0, "00000000" )
--PATH addons/igs-core/lua/igs/utils/ut_sh.lua:
-- #todo нужно переделывать, но только так:
-- https://trello.com/c/WfVYTIOF/544 (комменты)
CreateConVar("igs_debug", 0, FCVAR_NOTIFY)
cvars.AddChangeCallback("igs_debug", function(_, old, new)
	IGS.DEBUG = tobool(new)
	IGS.print("PEZuM OTJIA9Ku " .. (IGS.DEBUG and "AKTuBuPOBAH" or "BbIKJII04EH"))
end, "main")


local PLAYER = FindMetaTable("Player")

function PLAYER:IGSFunds()
	return self:GetIGSVar("igs_balance") or 0
end

function PLAYER:HasPurchase(sUID)
	return IGS.PlayerPurchases(self)[sUID]
end

-- ITEM, если человек имеет хоть один итем из списка
-- nil, если итем не отслеживается
-- false, если нет права
function IGS.PlayerHasOneOf(pl, tItems)
	if not tItems then return end

	for _,ITEM in ipairs(tItems) do
		if pl:HasPurchase( ITEM:UID() ) then
			return ITEM
		end
	end

	return false
end

function IGS.isUser(pl) -- возвращает false, если чел никогда не юзал автодонат
	return pl:GetIGSVar("igs_balance") ~= nil
end


-- Может ли чел себе позволить покупку итема, ценой в sum IGS?
function IGS.CanAfford(pl,sum,assert)
	if sum >= 0 and pl:IGSFunds() - sum >= 0 then
		return true
	end

	if not assert then
		return false
	end

	if isfunction(assert) then
		assert()
	else
		local rub = IGS.RealPrice(sum)
		if SERVER then
			IGS.WIN.Deposit(pl,rub)
		else
			IGS.WIN.Deposit(rub)
		end
	end

	return false
end

-- Список активных покупок игрока
-- uid > amount
function IGS.PlayerPurchases(pl)
	if not IsValid(pl) then return {} end
	return CLIENT and (pl:GetIGSVar("igs_purchases") or {}) or pl:GetVar("igs_purchases",{})
end

-- Сумма в донат валюте всех операций пополнения счета (включая купоны и выдачу денег администратором)
function IGS.TotalTransaction(pl)
	return pl:GetIGSVar("igs_total_transactions") or 0
end

-- возврат объекта ЛВЛ на клиенте, номера уровня на сервере
function IGS.PlayerLVL(pl)
	return pl:GetIGSVar("igs_lvl")
end


-- Конвертирует IGS в реальную валюту
function IGS.RealPrice(iCurrencyAmount)
	return iCurrencyAmount * IGS.GetCurrencyPrice()
end

-- Реальная валюта в IGS по текущему курсу
function IGS.PriceInCurrency(iRealPrice)
	return iRealPrice / IGS.GetCurrencyPrice()
end


function IGS.IsCurrencyEnabled()
	return IGS.GetCurrencyPrice() ~= 1
end

local function getSettings()
	return IGS.nw.GetGlobal("igs_settings")
end

-- Минимальная сумма пополнения в рублях
function IGS.GetMinCharge()
	return 15
end

-- Стоимость 1 донат валюты в рублях
function IGS.GetCurrencyPrice()
	return getSettings()[2]
end

-- Не смог загрузиться или выключен в панели, меню открывать нельзя
function IGS.IsLoaded()
	return getSettings() and IGS.SERVERS:ID() and not GetGlobalBool("IGS_DISABLED")
end




local terms = {
	[1] = "безкінечно",
	[2] = "одноразово",
	[3] = "%s"
}

function IGS.TermType(term)
	return
		not term  and 1 or -- бесконечно
		term == 0 and 2 or -- мгновенно
		term      and 3    -- кол-во дней
end

function IGS.TermToStr(term)
	return terms[ IGS.TermType(term) ]:format(term and PL_DAYS(term))
end

function IGS.TimestampToDate(ts,bShowFull) -- в "купил до"
	if not ts then return end
	return os.date(bShowFull and IGS.C.DATE_FORMAT or IGS.C.DATE_FORMAT_SHORT,ts)
end


function IGS.FormItemInfo(ITEM)
	return {
		["Категорія"] = ITEM:Category(),
		["Діє"] = IGS.TermToStr(ITEM:Term()),
		["Ціна"]       = PL_MONEY(ITEM:Price()),
		["Без скидки"] = ITEM.discounted_from and PL_MONEY(ITEM.discounted_from) or nil,
		["Покупки сумують"]  = ITEM:IsStackable() and "так" or "ні",
	}
end


function IGS.print(...)
	local args = {...}
	if not IsColor(args[1]) then
		table.insert(args,1,color_white)
	end

	args[#args] = args[#args] .. "\n"
	MsgC(Color(50,200,255), "[IGS] ", unpack(args))
end

function IGS.dprint(...)
	if IGS.DEBUG then
		IGS.print("DEBUG: ", Color(50,250,50), ...)
	end
end




function IGS.SignPrice(iPrice) -- 10 Alc
	return math.Truncate(tonumber(iPrice),2) .. " " .. IGS.C.CURRENCY_SIGN
end

local rubs = {"₴", "₴", "₴"}
PL_MONEY = PLUR(rubs)
PL_IGS   = PLUR(IGS.C.CurrencyPlurals or rubs)
PL_DAYS  = PLUR({"день", "дня", "днів"})


local PL_IGS_ORIGINAL
hook.Add("IGS.OnSettingsUpdated","PL_IGS = PL_MONEY",function()
	if not IGS.IsCurrencyEnabled() then -- Если донат валюта отключена
		PL_IGS_ORIGINAL = PL_IGS -- а это не таблица случайно? Мб table.copy?
		PL_IGS = PL_MONEY

	-- Валюта уже отключалась. Сейчас включилась
	elseif PL_IGS_ORIGINAL then
		PL_IGS = PL_IGS_ORIGINAL
	end
end)

--PATH addons/igs-core/lua/igs/extensions/serverguard.lua:
local STORE_ITEM = FindMetaTable("IGSItem")

local is_on_sale_ranks = {}

function STORE_ITEM:SetSGGroup(sUserGroup)
	is_on_sale_ranks[sUserGroup] = true

	return self:SetInstaller(function(pl)
		local rankData = serverguard.ranks:GetRank(sUserGroup)
		assert(rankData, "IGS: У SetSGGroup вказана неіснуюча група")
		serverguard.player:SetRank(pl, sUserGroup, 0)
		serverguard.player:SetImmunity(pl, rankData.immunity)
		serverguard.player:SetTargetableRank(pl, rankData.targetable)
		serverguard.player:SetBanLimit(pl, rankData.banlimit)
	end):SetMeta("sggroup", sUserGroup)
end

if CLIENT then return end

-- addhook не подойдет (не будет автоснятия. Можно и отдельно, конечно)
hook.Add("IGS.PlayerPurchasesLoaded", "sggroup", function(pl, purchases)
	if not serverguard then hook.Remove("IGS.PlayerPurchasesLoaded", "sggroup") return end
	local prior

	for uid in pairs(purchases or {}) do
		local ITEM = IGS.GetItemByUID(uid)
		if ITEM:GetMeta("sggroup") and (not prior or ITEM.id >= prior.id) then
			prior = ITEM
		end
	end

	if prior then
		prior:Setup(pl)
	else -- ни один не куплен (срок истек?)
		local player_rank = serverguard.player:GetRank(pl) -- default: user
		if is_on_sale_ranks[player_rank] then -- но ранг, который у игрока продается
			serverguard.player:SetRank(pl, "user", 0) -- снимаем
		end
	end
end)

--PATH addons/igs-modification/lua/igs/settings/sh_addlevels.lua:
--[[-------------------------------------------------------------------------
	Цены в .Add указываются в рублях
---------------------------------------------------------------------------]]

-- Уровни сработают только, если не произойдет ошибки при пополнении счета
-- Правда я не представляю что нужно сделать, чтобы произошла ошибка (Не пришел сигнал PAY с автодоната)
IGS.LVL.Add(1, "Новичок")
	:SetDescription("Вы новичок!") -- выше в catchDSHints еще


IGS.LVL.Add(100, "Стартанувший")
IGS.LVL.Add(500, "В теме")

IGS.LVL.Add(1000, "Бывалый")
	:SetDescription("Позволяет получить уникальный статус \"Мегалодон\" на форуме")

IGS.LVL.Add(1500, "Вроде не бомж")
	:SetDescription("Скоро новый бонус")


IGS.LVL.Add(2000, "Точно не бомж")
	:SetDescription("Еще капельку и бонус. Следующий лвл")


IGS.LVL.Add(3000, "Щедрый")
	:SetDescription("Премиум поддержка от правительства")

IGS.LVL.Add(4000, "Очень щедрый")
	:SetDescription("На след. лвл новый бонус")

IGS.LVL.Add(5000, "Пиздец щедрый")
	:SetDescription("Статус Убердон на форуме")

IGS.LVL.Add(6000, "Мажор")
	:SetDescription("Предложение о сотрудничестве")


IGS.LVL.Add(7000, "Супермажик")
IGS.LVL.Add(8000, "Гипермажик")
IGS.LVL.Add(9000, "Убермажор")
IGS.LVL.Add(10000, "Миллионер")
	:SetDescription("Премиум поддержка от основателя в любое время суток")

IGS.LVL.Add(12000, "МультиМиллионер")
IGS.LVL.Add(15000, "Миллиардер")
IGS.LVL.Add(20000, "МультиМиллиардер")
IGS.LVL.Add(25000, "Кыш с дороги")
IGS.LVL.Add(30000, "Сядь в лужу, я пройду")
IGS.LVL.Add(35000, "Я тебя куплю")
IGS.LVL.Add(40000, "Я куплю тебя и твою семью")
IGS.LVL.Add(50000, "Бог один и это Я")

--PATH addons/igs-core/lua/igs/interface/vgui/igs_panels_layout.lua:
-- http://joxi.ru/Vm6bbvlipXRZmZ

-- TODO переписать. СНОВА. Чтобы норм вставляло эллементы с разной шириной, не выходя за пределы строки
local PANEL = {}

function PANEL:Init()
	self.name  = "Untitled"
	self.panels = {} -- line, panels

	self.current_line = 1

	--self.elements_tall = 80
end

function PANEL:SetName(sName)
	if not sName then return end

	self.name = sName

	self.title = self.title or uigs.Create("DLabel", function(title)
		title:SetSize(self:GetWide() - 10 - 10,30)
		title:SetPos(10,10)
		title:SetFont("igs.24")

		-- 30 is label height, 10 is margins
		self.last_y = 10 + 30
	end, self)

	self.title:SetText(self.name)

	return self.title
end

function PANEL:GetLineWide(iLine)
	local w = 0
	for _,pan in ipairs(self.panels[iLine]) do
		w = w + pan:GetWide()
	end

	-- 10 - размер отступа
	return w + (#self.panels[iLine] - 1) * 10
end

-- Возвращает панели в строке
-- function PANEL:GetLine(iLine)
-- 	return self.panels[iLine]
-- end

function PANEL:GetCurrentLine()
	return self.panels[self.current_line]
end

-- Y для следующего ряда панелек
function PANEL:GetY()
	local y = (#self.panels - 1) * (self.elements_tall + 10) -- в #self.panels кол-во линий

	return self.title and (y + 10 + 30) or y
end

function PANEL:Add(panel)
	panel:SetParent(self)

	-- Все эллементы в лэйауте должны быть одинаковой высоты, хотя могут быть разной ширины
	self.elements_tall = self.elements_tall or panel:GetTall()

	self.panels[self.current_line] = self.panels[self.current_line] or {}
	table.insert(self.panels[self.current_line],panel)

	local line_wide = self:GetLineWide(self.current_line)

	local borders = not self.disabled_align and (self:GetWide() - line_wide) * 0.5 -- отступы по сторонам
	local line_panels = self:GetCurrentLine()

	for i,pan in ipairs(line_panels) do

		-- Если первая панель, то делаем отступ, чтобы в конце все было по середине
		if i == 1 then
			pan:SetPos(self.disabled_align and 10 or borders, self:GetY())
		else
			local x,y = line_panels[i - 1]:GetPos()
			pan:SetPos(x + line_panels[i - 1]:GetWide() + 10,y)
		end
	end

	-- Если размер существующих компонентов + еще один <= размер лэйаута, то вставляем эллемент
	-- if panel.tag then
	-- 	print("\n\n")
	-- 	print("self:GetWide()",self:GetWide())
	-- 	print("panel:GetWide()",panel:GetWide())
	-- 	print("line_wide",line_wide)
	-- 	print(panel)
	-- end
	if line_wide + 10 + panel:GetWide() > self:GetWide() then
		-- if panel.tag then
		-- 	PrintTable(self.panels)
		-- 	print("Перешли на след. ряд")
		-- 	--panel:SetPos(self.disabled_align and 10 or borders, self:GetY())
		-- end
		self.current_line = self.current_line + 1
	end

	self:PerformLayout()
end

function PANEL:PerformLayout()
	self:SetHeight(self:GetY() + self.elements_tall) -- + 10 margin
end

-- Отключает центрирование эллементов
function PANEL:DisableAlignment(bDisable)
	self.disabled_align = bDisable
end


vgui.Register("igs_panels_layout", PANEL, "Panel")
--IGS.UI()

--PATH addons/igs-core/lua/igs/interface/activities/inventory.lua:
local function loadTab(activity,sidebar,dat)
	local bg = sidebar:AddPage("Дії над ітемами")
	IGS.AddTextBlock(bg.side, nil, #dat > 0 and
		"Виберіть предмет, щоб отимати по ньому список дій" or

		"Куплені предмети будуть знаходитися тут." ..
		"\n\nЗавдяки інвентарю ви можете поділитися покупкою зі своїм другом, у якого не вистачає грошей на покупку послуги. " ..
			"Просто купіть її замість нього та киньте на пол. Після активації предмета він з'явиться у нього в інвентарі." ..
		"\n\nДобрі саморитяни використовують інвентарь для влаштовування крутих конкурсів. " ..
			"Вони набивають свій інвентарь предметами, а потім при певних умовах їх раздають"
	)

	bg.OnRemove = function()
		hook.Remove("IGS.PlayerPurchasedItem","UpdateInventoryView")
	end

	local act_tall = activity:GetTall() - activity.tabBar:GetTall()

	local infpan = uigs.Create("igs_iteminfo", function(p)
		p:SetSize(300,act_tall) -- Dock(LEFT) SetWide(300)
		p:SetPos(0,0)
		p:SetIcon()
		p:SetName("")
		p:SetDescription("Тут буде Відображена інформація про вашу покупку, коли ви її зробите")
	end, bg)

	local scr = uigs.Create("igs_scroll", bg)
	scr:SetSize(activity:GetWide() - infpan:GetWide(),act_tall)
	scr:SetPos(infpan:GetWide(),0) -- Dock(FILL)

	IGS.AddTextBlock(scr,"Ваш інвентарь","Щось тут порожньо. Потрібно б купити щось, правда?")

	scr:AddItem( uigs.Create("DIconLayout", function(icons)
		icons:SetWide(scr:GetWide())
		icons:SetSpaceX(2)
		icons:SetSpaceY(2)
		icons.Paint = function() end

		local function removeFromCanvas(itemPan)
			if IsValid(itemPan) then -- не закрыли окно
				bg.side:Reset()
				infpan:Reset()
				itemPan:Remove()
			end
		end

		function icons:AddItem(ITEM, dbID)
			local item = icons:Add("igs_item")
			item:SetSize(icons:GetWide(),60)
			item:SetIcon(ITEM:ICON())
			item:SetName(ITEM:Name())
			item:SetSign("Діє " .. IGS.TermToStr(ITEM:Term()))
			item.DoClick = function()
				infpan:Reset()
				infpan:SetIcon(ITEM:ICON())
				infpan:SetName(ITEM:Name())
				infpan:SetImage(ITEM:IMG())
				infpan:SetSubNameButton(ITEM:Group() and ITEM:Group():Name(), function()
					IGS.WIN.Group(ITEM:Group():UID())
				end)
				infpan:SetDescription(ITEM:Description())
				infpan:SetInfo(IGS.FormItemInfo(ITEM))


				bg.side:Reset()

				local act_btn = IGS.AddButton(bg.side, "",function()
					IGS.ProcessActivate(dbID, function(ok) -- iPurchID, sMsg_
						if not ok then return end

						removeFromCanvas(item)
					end)
				end).button
				act_btn:SetActive(true)
				act_btn:SetText("Активувати")

				if IGS.C.Inv_AllowDrop then
					IGS.AddButton(bg.side,"Викинути на пол",function()
						IGS.DropItem(dbID,function()
							removeFromCanvas(item)
						end)
					end)
				end
			end
		end

		for _,v in ipairs(dat) do
			icons:AddItem(v.item, v.id)
		end

		hook.Add("IGS.PlayerPurchasedItem","UpdateInventoryView",function(_, ITEM, invDbID)
			icons:AddItem(ITEM, invDbID)
		end)


	end) )

	scr:AddItem(uigs.Create("Panel", function(end_margin)
		end_margin:SetTall(5)
	end))

	activity:AddTab("Інвентарь",bg,"materials/ukrainerp/cart.png")
end

hook.Add("IGS.CatchActivities","inventory",function(activity,sidebar)
	if not IGS.C.Inv_Enabled then return end

	IGS.GetInventory(function(items)
		if not IsValid(sidebar) then return end
		loadTab(activity,sidebar,items)
	end)
end)

-- IGS.UI()

--PATH addons/igs-core/lua/igs/interface/windows/item_info.lua:
local m

local function purchase(ITEM, buy_button)
	IGS.Purchase(ITEM:UID(), function(errMsg,dbID)
		if not IsValid(buy_button) then return end

		if errMsg then
			IGS.ShowNotify(errMsg, "Помилка покупки")
			surface.PlaySound("ambient/voices/citizen_beaten1.wav") -- еще есть
			return
		end

		buy_button.purchased = buy_button.purchased or 0
		buy_button.purchased = buy_button.purchased + 1


		if ITEM:IsStackable() then
			buy_button:SetText("Куплено " .. buy_button.purchased .. " шт")
		else
			if IsValid(m) then
				m:Close()
			end

			if not IGS.C.Inv_Enabled then
				IGS.ShowNotify("дякуємо за покупку. Це було просто, правда? :)", "Успішна покупка")
				return
			end

			IGS.BoolRequest("Успішна покупка",
				"Дякуємо за покупку. Вона знаходиться у вашому /donate інвентарі.\n\nАктивувати її зараз?",
			function(yes)
				if not yes then return end

				IGS.ProcessActivate(dbID)
			end)
		end

		surface.PlaySound("ambient/office/coinslot1.wav")
	end)
end






local function move(f, x, sp, cb)
	local _,y = f:GetPos()
	f:MoveTo(x,y, sp,nil,nil,cb)
end

local function shakeFrame(f, amplitude, speed, cb)
	if not IsValid(f) then return end

	local x = f:GetPos()
	move(f, x + amplitude, speed, function()
		move(f, x - amplitude, speed, function()
			move(f, x, speed, cb)
		end)
	end)
end

function IGS.WIN.Item(uid)
	local ITEM = IGS.GetItemByUID(uid)
	if IsValid(m) then
		if m.item_uid == uid then -- попытка повторного открытия того же фрейма

			m:MoveToFront()
			shakeFrame(m, 20, .1)

			return
		end

		-- Открытия другого
		m:Close()
		m = nil
	end

	surface.PlaySound("ambient/weather/rain_drip1.wav")

	m = uigs.Create("igs_frame", function(self)
		self:SetSize(330,550)
		self:RememberLocation("igs_item")
		self:MakePopup()
		self:SetTitle(ITEM:Name())

		self.item_uid  = uid -- для предотвращения повторного открытия двух одинаковых фреймов
	end)


	uigs.Create("igs_iteminfo", function(p)

		--[[-------------------------------------------------------------------------
			Очень не красивый, но очень полезный код
			Заставляет ползунок помигать для заметности
		---------------------------------------------------------------------------]]
		local viewed = tonumber( bib.get("igs:items_viewed",0) )
		bib.set("igs:items_viewed",viewed + 1)

		-- Если мигали 3+ раза, то больше не надо
		if viewed < 3 then
			local oldThink = p.scroll.scrollBar.Think
			timer.Simple(.5,function() -- 0.5 = время, которое скролл будет мигать
				if not IsValid(p) then return end

				p.scroll.scrollBar.Think = oldThink
			end)

			p.scroll.scrollBar.Think = function() --              \/ скорость мигания
				p.scroll.scrollBar.addWidth = (math.sin( CurTime() * 20 ) + 1) * 0.5 * 8 -- 8 лимит ширины скролла
				p.scroll.scrollBar:InvalidateLayout()
			end
		end
		-----------------------------------------------------------------------------



		p:Dock(FILL)
		p:SetIcon(ITEM:ICON())
		p:SetName("Діє " .. IGS.TermToStr(ITEM:Term()))
		p:SetImage(ITEM:IMG())
		p:SetSubNameButton(ITEM:Group() and ITEM:Group():Name(), function()
			IGS.WIN.Group(ITEM:Group():UID())
		end)
		p:SetDescription( ITEM:Description() )
		p:SetInfo(IGS.FormItemInfo(ITEM))

		m.act = p:CreateActivity() -- панелька для кастом эллементов
		m.buy = uigs.Create("igs_button", function(buy)
			local cur_price = ITEM:PriceInCurrency()

			buy:Dock(TOP)
			buy:SetTall(20)
			buy:SetText( "Купити за " .. PL_IGS(cur_price) )
			buy:SetActive( IGS.CanAfford(LocalPlayer(), cur_price) )
			buy.DoClick = function(s)
				if not s:IsActive() then
					local need = cur_price - LocalPlayer():IGSFunds()

					surface.PlaySound("ambient/voices/citizen_beaten1.wav") -- еще есть
					IGS.BoolRequest(
						"Недостатньо грошей",
						("Вам не вистачає %s для покупки %s.\nБажаєте миттєво поповнити рахунок?"):format( PL_IGS(need), ITEM:Name()),
						function(yes)
							if yes then
								IGS.WIN.Deposit(IGS.RealPrice(need), true)
								surface.PlaySound("vo/npc/male01/yeah02.wav")
							end
						end
					):ShowCloseButton(true)

					return
				end

				purchase(ITEM, s)
			end
		end, m.act)
	end, m)

	hook.Run("IGS.OnItemInfoOpen", ITEM, m)
end
-- IGS.WIN.Item("permission_model_30d")

--PATH addons/lvs_base-main/lua/lvs_framework/autorun/cl_hud.lua:

--LVS.HudForceDefault = true

LVS.HudEditors = LVS.HudEditors or {}
LVS.HudEditorsHide = {}

local function ResetFrame( id )
	if not LVS.HudEditors[ id ] then return end

	LVS.HudEditors[ id ].w = LVS.HudEditors[ id ].DefaultWidth
	LVS.HudEditors[ id ].h = LVS.HudEditors[ id ].DefaultHeight
	LVS.HudEditors[ id ].X = LVS.HudEditors[ id ].DefaultX
	LVS.HudEditors[ id ].Y = LVS.HudEditors[ id ].DefaultY
	LVS.HudEditorsHide[ id ] = nil
end

local function MakeFrame( id, X, Y, w, h, minw, minh, text )
	local Frame = vgui.Create("DFrame")
	Frame:SetSize( w, h )
	Frame:SetPos( X, Y )
	Frame:SetTitle( text )
	Frame:SetScreenLock( true )
	Frame:MakePopup()
	Frame:SetSizable( true )
	Frame:SetMinWidth( minw )
	Frame:SetMinHeight( minh )
	Frame.id = id
	Frame.OnClose = function( self )
		ResetFrame( self.id )
	end
	Frame.Paint = function(self, w, h )
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0, 0, w, h)

		surface.SetDrawColor(80,80,80,255)
		surface.DrawRect(0, 0, 2, h)
		surface.DrawRect(w - 2, 0, 2, h)
		surface.DrawRect(0, 0, w, 2)
		surface.DrawRect(0, h - 2, w, 2)

		if not LVS.HudEditors[ self.id ] then return end

		local Width = self:GetWide()
		local Height = self:GetTall()

		LVS.HudEditors[ self.id ].w = Width
		LVS.HudEditors[ self.id ].h = Height

		LVS.HudEditors[ self.id ].X = math.min( self:GetX(), ScrW() - Width )
		LVS.HudEditors[ self.id ].Y = math.min( self:GetY(), ScrH() - Height )

		if self:IsDragging() or input.IsMouseDown( MOUSE_LEFT ) then return end

		local Ratio = LVS.HudEditors[ self.id ].DefaultHeight / LVS.HudEditors[ self.id ].DefaultWidth

		if math.Round( Height / Width, 2 ) ~= math.Round( Ratio ,2 ) then
			local NewHeight = Width * Ratio

			self:SetHeight( NewHeight )

			LVS.HudEditors[ self.id ].h = NewHeight
		end
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", Frame )
	DCheckbox:Dock( RIGHT )
	DCheckbox:DockMargin( 0, 0, 0, 0 )
	DCheckbox:SetText("Hide")	
	DCheckbox:SizeToContents()
	DCheckbox.id = id
	DCheckbox:SetChecked( LVS.HudEditorsHide[ id ] == true )
	DCheckbox.OnChange = function( self, bVal )
		if not self.id then return end

		if bVal then LVS.HudEditorsHide[ self.id ] = true return end

		LVS.HudEditorsHide[ self.id ] = nil
	end

	LVS.HudEditors[ id ].Frame = Frame

	return Frame
end

local ScreenWidth = ScrW()
local ScreenHeight = ScrH()

local function SaveEditors()
	if LVS.HudForceDefault then return end

	if ScreenWidth ~= ScrW() or ScreenHeight ~= ScrH() then return end -- player changed resolution while ingame... don't save because everything is fucked up now...

	local SaveString = ""
	for id, data in pairs( LVS.HudEditors ) do
		local w = data.w
		local h = data.h

		local X = math.min( data.X / ScrW(), 1 )
		local Y = math.min( data.Y / ScrH(), 1 )

		local hide = LVS.HudEditorsHide[ id ] and "?" or " "

		SaveString = SaveString..id.."~"..hide.."~"..w.."#"..h.."/"..X.."#"..Y.."\n"
	end

	file.Write( "lvs_hud_settings.txt", SaveString )
end

local function LoadEditors()
	if LVS.HudForceDefault then return end

	local LoadString = file.Read( "lvs_hud_settings.txt" )

	if not LoadString then return end

	for _, garbage in pairs( string.Explode( "\n", LoadString ) ) do
		local data1 = string.Explode( "~", garbage )

		if not data1[3] then continue end

		local data2 =  string.Explode( "/", data1[3] )

		local size = string.Explode( "#", data2[1] )
		local pos = string.Explode( "#", data2[2] )

		local ID = data1[1]

		if not LVS.HudEditors[ ID ] or not size[1] or not size[2] or not pos[1] or not pos[2] then continue end

		LVS.HudEditors[ ID ].w = math.max( LVS.HudEditors[ ID ].minw, size[1] )
		LVS.HudEditors[ ID ].h = math.max( LVS.HudEditors[ ID ].minh, size[2] )
		LVS.HudEditors[ ID ].X = math.min( pos[1] * ScrW(), ScrW() - size[1] )
		LVS.HudEditors[ ID ].Y = math.min( pos[2] * ScrH(), ScrH() - size[2] )

		if data1[2] == "?" then
			LVS.HudEditorsHide[ ID ] = true
		end
	end
end

function LVS:AddHudEditor( id, X, Y, w, h, minw, minh, text, func )
	LVS.HudEditors[ id ] = {
		DefaultX = X,
		DefaultY = Y,
		DefaultWidth = w,
		DefaultHeight = h,
		X = X,
		Y = Y,
		w = w,
		h = h,
		minw = minw,
		minh = minh,
		text = text,
		func = func,
	}
end

hook.Add( "OnContextMenuOpen", "!!!!!LVS_hud", function()
	if not IsValid( LocalPlayer():lvsGetVehicle() ) then return end

	if not GetConVar( "lvs_edit_hud" ):GetBool() then return end

	LVS:OpenEditors()

	return false
end )

hook.Add( "InitPostEntity", "!!!lvs_load_hud", function()
	LoadEditors()
end )

function LVS:OpenEditors()
	for id, editor in pairs( LVS.HudEditors ) do
		if IsValid( editor.Frame ) then continue end

		MakeFrame( id, editor.X, editor.Y, editor.w, editor.h, editor.minw, editor.minh, editor.text )
	end

	local T = CurTime()
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()

	ply.SwitcherTime = T + 9999

	if not IsValid( pod ) then return end

	pod._SelectActiveTime = T + 9999
end

function LVS:CloseEditors()
	SaveEditors()

	for id, editor in pairs( LVS.HudEditors ) do
		if not IsValid( editor.Frame ) then continue end
		editor.Frame:Remove()
	end

	local T = CurTime()
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()

	ply.SwitcherTime = T

	if not IsValid( pod ) then return end

	pod._SelectActiveTime = T
end

hook.Add( "OnContextMenuClose", "!!!!!LVS_hud", function()
	LVS:CloseEditors()
end )

function LVS:DrawDiamond( X, Y, radius, perc )
	if perc <= 0 then return end

	local segmentdist = 90

	draw.NoTexture()

	for a = 90, 360, segmentdist do
		local Xa = math.Round( math.sin( math.rad( -a ) ) * radius, 0 )
		local Ya = math.Round( math.cos( math.rad( -a ) ) * radius, 0 )

		local C = math.sqrt( radius ^ 2 + radius ^ 2 )

		if a == 90 then
			C = C * math.min(math.max(perc - 0.75,0) / 0.25,1)
		elseif a == 180 then
			C = C * math.min(math.max(perc - 0.5,0) / 0.25,1)
		elseif a == 270 then
			C = C * math.min(math.max(perc - 0.25,0) / 0.25,1)
		elseif a == 360 then
			C = C * math.min(math.max(perc,0) / 0.25,1)
		end

		if C > 0 then
			local AxisMoveX = math.Round( math.sin( math.rad( -a + 135) ) * (C + 3) * 0.5, 0 )
			local AxisMoveY =math.Round( math.cos( math.rad( -a + 135) ) * (C + 3) * 0.5, 0 )

			surface.DrawTexturedRectRotated(X - Xa - AxisMoveX, Y - Ya - AxisMoveY,3, math.ceil( C ), a - 45)
		end
	end
end

local function PaintIdentifier( ent )
	if not LVS.ShowIdent or LVS:IsIndicatorForced() then return end

	local VehicleIdentifierRange = ent.VehicleIdentifierRange
	local MyPos = ent:GetPos()
	local MyTeam = ent:GetAITEAM()

	for _, v in pairs( LVS:GetVehicles() ) do
		if not IsValid( v ) or v == ent then continue end

		local rPos = v:LocalToWorld( v:OBBCenter() )

		local Pos = rPos:ToScreen()
		local Dist = (MyPos - rPos):Length()

		if Dist > VehicleIdentifierRange or util.TraceLine( {start = ent:LocalToWorld( ent:OBBCenter() ),endpos = rPos,mask = MASK_NPCWORLDSTATIC,} ).Hit then continue end

		local Alpha = 255 * (1 - (Dist / VehicleIdentifierRange) ^ 2)
		local Team = v:GetAITEAM()
		local IndicatorColor = Color( 255, 0, 0, Alpha )

		if Team == 0 then
			if MyTeam == 0 then continue end

			IndicatorColor = Color( 0, 255, 0, Alpha )
		else
			if Team == 1 or Team == 2 then
				if Team ~= MyTeam and MyTeam ~= 0 then
					IndicatorColor = Color( 255, 0, 0, Alpha )
				else
					IndicatorColor = Color( 0, 127, 255, Alpha )
				end
			end
		end

		if Team > 3 then continue end

		v:LVSHudPaintVehicleIdentifier( Pos.x, Pos.y, IndicatorColor )
	end
end

hook.Add( "HUDPaint", "!!!!!LVS_hud", function()
	local ply = LocalPlayer()

	if ply:GetViewEntity() ~= ply then return end

	local Pod = ply:GetVehicle()
	local Parent = ply:lvsGetVehicle()

	if not IsValid( Pod ) or not IsValid( Parent ) then
		ply._lvsoldPassengers = {}

		return
	end

	local X = ScrW()
	local Y = ScrH()

	PaintIdentifier( Parent )
	Parent:LVSHudPaint( X, Y, ply )

	local base = Pod:lvsGetWeapon()
	if IsValid( base ) then
		local weapon = base:GetActiveWeapon()
		if weapon and weapon.HudPaint then
			weapon.HudPaint( base, X, Y, ply )
		end
	else
		local weapon = Parent:GetActiveWeapon()
		if ply == Parent:GetDriver() and weapon and weapon.HudPaint then
			weapon.HudPaint( Parent, X, Y, ply )
		end
	end

	for id, editor in pairs( LVS.HudEditors ) do
		if LVS.HudEditorsHide[ id ] then continue end

		local ScaleX = editor.w / editor.DefaultWidth
		local ScaleY = editor.h / editor.DefaultHeight

		local PosX = editor.X / ScaleX
		local PosY = editor.Y / ScaleY

		local Width = editor.w / ScaleX
		local Height = editor.h / ScaleY

		local ScrW = X / ScaleX
		local ScrH = Y / ScaleY

		if ScaleX == 1 and ScaleY == 1 then
			editor:func( Parent, PosX, PosY, Width, Height, ScrW, ScrH, ply )
		else
			local m = Matrix()
			m:Scale( Vector( ScaleX, ScaleY, 1 ) )

			cam.PushModelMatrix( m )
				editor:func( Parent, PosX, PosY, Width, Height, ScrW, ScrH, ply )
			cam.PopModelMatrix()
		end
	end
end )
--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_damagenotify.lua:

if CLIENT then 
	net.Receive( "lvs_hurtmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) then return end

		vehicle:HurtMarker( net.ReadFloat() )
	end )

	net.Receive( "lvs_hitmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		local IsCrit = net.ReadBool()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply,  IsCrit and "crit" or "hit" )

			return
		end

		if IsCrit then
			vehicle:CritMarker()
		else
			vehicle:HitMarker()
		end
	end )

	net.Receive( "lvs_killmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply, "kill" )

			return
		end

		vehicle:KillMarker()
	end )

	net.Receive( "lvs_armormarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		local IsDamage = net.ReadBool()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply, IsDamage and "armorcrit" or "armor" )

			return
		end

		vehicle:ArmorMarker( IsDamage )
	end )

	return
end

util.AddNetworkString( "lvs_hitmarker" )
util.AddNetworkString( "lvs_hurtmarker" )
util.AddNetworkString( "lvs_killmarker" )
util.AddNetworkString( "lvs_armormarker" )
--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_pod.lua:

local meta = FindMetaTable( "Vehicle" )

if CLIENT then
	function meta:lvsGetPodIndex()
		local id = self:GetNWInt( "pPodIndex", -1 )

		if id ~= -1 then return id end

		-- code below is bandaid fix for ent:GetNWInt taking up to 5 minutes to update on client...

		local col = self:GetColor()
		local id_by_color = col.r

		-- 255 or 0 is suspicous...
		if id_by_color == 255 or id_by_color == 0 then return -1 end

		-- lets just assume its right... right?
		if id_by_color == col.g and id_by_color == col.b then
			return id_by_color
		end

		return -1
	end

	function meta:GetCameraHeight()
		if not self._lvsCamHeight then
			self._lvsCamHeight = 0

			net.Start("lvs_camera")
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self._lvsCamHeight
	end

	function meta:SetCameraHeight( newheight )
		self._lvsCamHeight = newheight
	end

	function meta:lvsGetWeapon()
		if self._lvsWeaponEntChecked then
			return self._lvsWeaponEnt
		end

		local found = false

		for _, ent in ipairs( self:GetChildren() ) do
			if not ent.LVS_GUNNER then continue end

			self._lvsWeaponEntChecked = true
			self._lvsWeaponEnt = ent

			found = true

			break
		end

		return found and self._lvsWeaponEnt or NULL
	end

	net.Receive( "lvs_select_weapon", function( length)
		local ply = LocalPlayer()
		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) or vehicle:GetDriver() ~= ply then return end

		vehicle._SelectActiveTime = CurTime() + 2
	end)

	
	net.Receive( "lvs_camera", function( length, ply )
		local pod = net.ReadEntity()

		if not IsValid( pod ) then return end

		pod:SetCameraHeight( net.ReadFloat() )
	end)

	return
end

function meta:lvsGetPodIndex()
	return self:GetNWInt( "pPodIndex", -1 )
end

function meta:GetCameraHeight()
	return (self._lvsCamHeight or 0)
end

util.AddNetworkString( "lvs_select_weapon" )
util.AddNetworkString( "lvs_camera" )

net.Receive( "lvs_select_weapon", function( length, ply )
	if not IsValid( ply ) then return end

	local ID = net.ReadInt( 5 )
	local Increment = net.ReadBool()

	local base = ply:lvsGetWeaponHandler()

	if not IsValid( base ) then return end

	if Increment then
		base:SelectWeapon( base:GetSelectedWeapon() + ID )
	else
		base:SelectWeapon( ID )
	end
end)

net.Receive( "lvs_camera", function( length, ply )
	if not IsValid( ply ) then return end

	local pod = net.ReadEntity()

	if not IsValid( pod ) then return end

	net.Start("lvs_camera")
		net.WriteEntity( pod )
		net.WriteFloat( pod:GetCameraHeight() )
	net.Send( ply )
end)

function meta:SetCameraHeight( newheight )
	self._lvsCamHeight = newheight

	net.Start("lvs_camera")
		net.WriteEntity( self )
		net.WriteFloat( newheight )
	net.Broadcast()
end

function meta:lvsAddWeapon( ID )
	if IsValid( self._lvsWeaponEnt ) then
		return self._lvsWeaponEnt
	end

	local weapon = ents.Create( "lvs_base_gunner" )

	if not IsValid( weapon ) then return NULL end

	weapon:SetPos( self:LocalToWorld( Vector(0,0,33.182617) ) ) -- location exactly where ply:GetShootPos() is. This will make AI-Tracing easier.
	weapon:SetAngles( self:LocalToWorldAngles( Angle(0,90,0) ) )
	weapon:SetOwner( self )
	weapon:Spawn()
	weapon:Activate()
	weapon:SetParent( self )
	weapon:SetPodIndex( ID )
	weapon:SetDriverSeat( self )

	self._lvsWeaponEnt = weapon

	weapon:SetSelectedWeapon( 1 )

	return weapon
end

function meta:lvsGetWeapon()
	return self._lvsWeaponEnt
end

function meta:lvsSetPodIndex( index )
	-- garbage networking
	self:SetNWInt( "pPodIndex", index )

	self:SetMaterial( "null" )

	-- more reliable networking, lol
	self:SetColor( Color( index, index, index, 0 ) )
end

--PATH addons/_mayor_voting_systems/lua/sh_votingconfig.lua:
VOTING.Theme = {}
--
-- Mayor Voting Theme
--

VOTING.Theme.WindowColor = Color(26, 30, 38, 255 * .5) --Main window color
VOTING.Theme.ControlColor = Color( 38, 41, 49, 255) --Main window control color
VOTING.Theme.TitleTextColor = color_white --Main title text color

VOTING.Theme.NoticePrefixColor = Color(0,0,255) --Chat text color of notice prefix
VOTING.Theme.NoticeTextColor = Color(255,51,51) --Chat text color of notices

VOTING.Settings = {}
--
-- Mayor Voting Configuration Options
--

VOTING.MaximumCandidates = 8 --Maximum candidates allowed in vote
VOTING.MinimumCandidates = 1 --Minimum candidates needed to trigger vote
VOTING.AboutToBeginTime = 60 --Time (in seconds) between vote triggered and started
VOTING.VoteTime = 30 --Time (in seconds) that a vote will last
VOTING.AllowCandidatesToVote = false --Allow candidates to participate in the vote?
VOTING.CandidateCost = 10000 --Cost of vote entry. Set to 0 to disable entry fee.
VOTING.MinutesUntilNextElection = 0 --Cooldown (in minutes) for new mayor vote
VOTING.AllowNewElectionOnDeath = true --Reset cooldown if the mayor dies
VOTING.AllowNewElectionWithMayor = false --Allow new votes if there is already a mayor
VOTING.DemoteOtherMayorsOnWin = true --Demote current mayors when there is a new mayor

--Custom Vote Entry Check
--Developers can also add a custom vote entry check, this will be called when
--a player tries to enter the mayor election. Return true/false to allow/disallow.
--You can also set a custom failure message to show to the player.
--Example
//VOTING.CanEnterVotingCustomFunction = function(ply) if ply:Level() > 5 then return true end end
//VOTING.CustomFunctionFailed = "You are not high enough level to enter a mayor election!"

--PATH addons/media_player/lua/mediaplayer/controls/dmediaplayerhtml.lua:
--
-- DMediaPlayerHTML
--
-- Improves upon the Cinema HTML control by adding:
-- Window object callbacks, HTML and JS console filtering, URL polling,
-- simulated mouse clicks, and proper fullscreen resizing.
--
-- Cinema HTML control reference:
-- https://github.com/pixeltailgames/cinema/blob/master/cinema/gamemode/modules/scoreboard/controls/cl_html.lua
--

local PANEL = {}

DEFINE_BASECLASS( "Panel" )

local DEBUG = false

local JS_CallbackHack = [[(function(){
	var funcname = '%s';
	window[funcname] = function(){
		_gm[funcname].apply(_gm,arguments);
	}
})();]]

local FilterCVar = CreateClientConVar( "js_console_filter", 0, true, false )

local FILTER_ALL = 0
local FILTER_NONE = 1

--[[---------------------------------------------------------

-----------------------------------------------------------]]

function PANEL:Init()

	self.JS = {}
	self.Callbacks = {}
	self.MouseActions = {}

	self.URL = "data:text/html,"

	hook.Add( "HUDPaint", self, function() self:HUDPaint() end )

end


function PANEL:OnDocumentReady( url )

	--
	-- Implement a console - because awesomium doesn't provide it for us anymore
	--
	local console_funcs = {'log','error','debug','warn','info'}
	for _, func in pairs(console_funcs) do
		self:AddFunction( "console", func, function(param)
			self:ConsoleMessage( param, func )
		end )
	end

	self:AddFunction( "gmod", "getUrl", function( url )
		self:SetURL( url )
	end )

end

function PANEL:Think()

	if self:IsLoading() then

		-- Call started loading
		if not self._loading then

			-- Get the page URL
			self:FetchPageURL()

			self._loading = true
			self:OnStartLoading()

		end

	else

		-- Call finished loading
		if self._loading then

			-- Get the page URL
			self:FetchPageURL()

			-- Hack to add window object callbacks
			if self.Callbacks.window then
				for funcname, callback in pairs(self.Callbacks.window) do
					self:RunJavascript( JS_CallbackHack:format(funcname) )
				end
			end

			self._loading = nil
			self:OnFinishLoading()

		end

		-- Run queued javascript
		if self.JS then
			for k, v in pairs( self.JS ) do
				self:RunJavascript( v )
			end
			self.JS = nil
		end

	end

	-- HACK: Poll page for URL change
	if not self._nextUrlPoll or self._nextUrlPoll < RealTime() then
		self:FetchPageURL()
		self._nextUrlPoll = RealTime() + 1
	end

end

function PANEL:FetchPageURL()
	local js = [[
		if (typeof gmod === 'object' && typeof gmod.getUrl === 'function') {
			gmod.getUrl(window.location.href);
		}
	]]
	self:RunJavascript(js)
end

function PANEL:GetURL()
	return self.URL
end

function PANEL:SetURL( url )
	local current = self.URL

	if current ~= url then
		self:OnURLChanged( url, current )
	end

	self.URL = url
end

function PANEL:OnURLChanged( new, old )
	if FilterCVar:GetInt() > FILTER_ALL then
		print( "URL Changed: " .. tostring(new) )
	end
end


--[[---------------------------------------------------------
	Awesomium Override Functions
-----------------------------------------------------------]]

function PANEL:SetSize( w, h, fullscreen )

	local keyboardEnabled = self:IsKeyboardInputEnabled()
	local mouseEnabled = self:IsMouseInputEnabled()

	if fullscreen then

		-- Cache fullscreen size
		local cw, ch = self:GetSize()
		self._OrigSize = { w = cw, h = ch }

		-- Render before the HUD
		self:ParentToHUD()

	elseif self._OrigSize then

		-- Restore cached size
		w = self._OrigSize.w
		h = self._OrigSize.h
		self._OrigSize = nil

		-- Reparent due to hud parented panels sometimes being inaccessible
		-- from Lua.
		self:SetParent( vgui.GetWorldPanel() )

	else
		self._OrigSize = nil
	end

	self:SetKeyBoardInputEnabled( keyboardEnabled )
	self:SetMouseInputEnabled( mouseEnabled )

	if not (w and h) then return end

	BaseClass.SetSize( self, w, h )

end

function PANEL:OpenURL( url )

	if DEBUG then
		print("DMediaPlayerHTML.OpenURL", url)
	end

	self:SetURL( url )

	BaseClass.OpenURL( self, url )

end

function PANEL:SetHTML( html )

	if DEBUG then
		print("DMediaPlayerHTML.SetHTML")
		print(html)
	end

	BaseClass.SetHTML( self, html )

end


--[[---------------------------------------------------------
	Window loading events
-----------------------------------------------------------]]

--
-- Called when the page begins loading
--
function PANEL:OnStartLoading()

end

--
-- Called when the page finishes loading all assets
--
function PANEL:OnFinishLoading()

end


--[[---------------------------------------------------------
	Lua => JavaScript queue

	This code only runs when the page is finished loading;
	this means all assets (images, CSS, etc.) must load first!
-----------------------------------------------------------]]

function PANEL:QueueJavascript( js )

	--
	-- Can skip using the queue if there's nothing else in it
	--
	if not ( self.JS or self:IsLoading() ) then
		return self:RunJavascript( js )
	end

	self.JS = self.JS or {}

	table.insert( self.JS, js )
	self:Think()

end

PANEL.QueueJavaScript = PANEL.QueueJavascript
PANEL.Call = PANEL.QueueJavascript


--[[---------------------------------------------------------
	Handle console logging from JavaScript
-----------------------------------------------------------]]

PANEL.ConsoleColors = {
	["default"]	= Color(255,160,255),
	["text"]	= Color(255,255,255),
	["error"]	= Color(235,57,65),
	["warn"]	= Color(227,181,23),
	["info"]	= Color(100,173,229),
}

function PANEL:ConsoleMessage( ... )

	local filterLevel = FilterCVar:GetInt()

	local args = {...}
	local msg = args[1]

	-- Three arguments are passed in if an error occured
	if #args == 3 and filterLevel > FILTER_ALL then

		local script = args[2]
		local linenum = args[3]
		local col = self.ConsoleColors.error

		local out = {
			"[JavaScript]",
			msg,
			",",
			script,
			":",
			linenum,
			"\n"
		}

		MsgC( col, table.concat(out, " ") )

	else

		if not isstring( msg ) then
			msg = "*js variable* (" .. type(msg) .. ": " .. tostring(msg) .. ")"
		end

		-- Run Lua from JavaScript console logging (POTENTIALLY HARMFUL!)
		--[[if msg:StartWith( "RUNLUA:" ) then
			local strLua = msg:sub( 8 )

			SELF = self
			RunString( strLua )
			SELF = nil

			return
		end]]

		-- Play a sound from JavaScript console logging
		if msg:StartWith( "PLAY:" ) then
			local soundpath = msg:sub( 7 )
			surface.PlaySound( soundpath )
			return
		end

		if filterLevel == FILTER_ALL then return end

		local func = args[2]

		-- Output console message with prefix
		local prefixColor = self.ConsoleColors.default
		local prefix = "[HTML"
		if func and func:len() > 0 and func ~= "log" then
			if self.ConsoleColors[func] then
				prefixColor = self.ConsoleColors[func]
			end
			prefix = prefix .. ":" .. func:upper()
		end
		prefix = prefix .. "] "

		MsgC( prefixColor, prefix )
		MsgC( self.ConsoleColors.text, msg, "\n" )

	end

end


--[[---------------------------------------------------------
	JavaScript callbacks
-----------------------------------------------------------]]

local JSObjects = {
	window	= "_gm",
	this	= "_gm",
	_gm		= "window"
}

--
-- Called by the engine when a callback function is called
--
function PANEL:OnCallback( obj, func, args )

	-- Hack for adding window callbacks
	obj = JSObjects[obj] or obj

	if not self.Callbacks[ obj ] then return end

	--
	-- Use AddFunction to add functions to this.
	--
	local f = self.Callbacks[ obj ][ func ]

	if ( f ) then
		return f( unpack( args ) )
	end

end

--
-- Add a function to Javascript
--
function PANEL:AddFunction( obj, funcname, func )

	-- Hack for adding window callbacks
	-- obj = JSObjects[obj] or obj

	if obj == "this" then
		obj = "window"
	end

	-- Create the `object` if it doesn't exist
	if not self.Callbacks[ obj ] then
		self:NewObject( obj )
		self.Callbacks[ obj ] = {}
	end

	-- This creates the function in javascript (which redirects to c++ which calls OnCallback here)
	self:NewObjectCallback( JSObjects[obj] or obj, funcname )

	-- Store the function so OnCallback can find it and call it
	self.Callbacks[ obj ][ funcname ] = func

end


--[[---------------------------------------------------------
	Scrolling
-----------------------------------------------------------]]

local JS_RemoveScrollbars = "document.body.style.overflow = 'hidden';"
local JS_ScrollBy = "window.scrollBy(0, %d);"

function PANEL:RemoveScrollbars()
	self:QueueJavascript(JS_RemoveScrollbars)
end

function PANEL:Scroll( amount )
	self:QueueJavascript( JS_ScrollBy:format(amount) )
end


--[[---------------------------------------------------------
	Compatibility functions
-----------------------------------------------------------]]

function PANEL:OpeningURL( url )
end

function PANEL:FinishedURL( url )
end


--[[---------------------------------------------------------
	Simulated mouse clicks
-----------------------------------------------------------]]

function PANEL:HUDPaint()
	self:HandleMouseActions()
end

function PANEL:InjectMouseClick( x, y )
	if self._handlingMouseAction then
		return
	end

	local w, h = self:GetSize()
	table.insert( self.MouseActions, {
		x = math.Round(x * w),
		y = math.Round(y * h),
		tick = 0
	} )
end

function PANEL:HandleMouseActions()
	if #self.MouseActions == 0 then
		return
	end

	local action = self.MouseActions[1]
	action.tick = action.tick + 1

	if action.tick == 1 then
		-- show cursor
		self._handlingMouseAction = true
		self:SetZPos( 32767 )
		self:MoveToCursor( action.x, action.y )
		self:MakePopup()
		gui.EnableScreenClicker( true )
		gui.InternalCursorMoved( 0, 0 )
	elseif action.tick == 2 then
		local cx, cy = input.GetCursorPos()
		gui.InternalCursorMoved( cx, cy )
	elseif action.tick == 3 then
		-- simulate click; need to wait at least one frame
		gui.InternalMousePressed( MOUSE_LEFT )
		gui.InternalMouseReleased( MOUSE_LEFT )
	elseif action.tick > 3 then
		-- hide cursor
		gui.EnableScreenClicker( false )
		self:SetKeyboardInputEnabled( false )
		self:SetMouseInputEnabled( false )
		self:SetZPos( -32768 )
		table.remove( self.MouseActions, 1 )
		self._handlingMouseAction = nil
	end
end

function PANEL:MoveToCursor( xoffset, yoffset )
	xoffset = xoffset or 0
	yoffset = yoffset or 0

	local cx, cy = input.GetCursorPos()
	self:SetPos( cx - xoffset, cy - yoffset )
end

derma.DefineControl( "DMediaPlayerHTML", "", PANEL, "Awesomium" )

--PATH addons/media_player/lua/mediaplayer/shared.lua:
MediaPlayer = MediaPlayer or {}
MP = MediaPlayer

include "utils.lua"
include "sh_cvars.lua"

--[[---------------------------------------------------------
	Config

	Store service API keys, etc.
-----------------------------------------------------------]]

MediaPlayer.config = {}

---
-- Apply configuration values to the mediaplayer config.
--
-- @param config	Table with configuration values.
--
function MediaPlayer.SetConfig( config )
	table.Merge( MediaPlayer.config, config )
end

---
-- Method for easily grabbing config value without checking that each fragment
-- exists.
--
-- @param key	e.g. "json.key.fragments"
--
function MediaPlayer.GetConfigValue( key )
	local value = MediaPlayerUtils.TableLookup( MediaPlayer.config, key )

	if type(value) == 'nil' then
		ErrorNoHalt("WARNING: MediaPlayer config value not found for key `" .. tostring(key) .. "`\n")
	end

	return value
end

if SERVER then
	AddCSLuaFile "config/client.lua"
	include "config/server.lua"
else
	include "config/client.lua"
end


--[[---------------------------------------------------------
	Shared includes
-----------------------------------------------------------]]

include "sh_events.lua"
include "sh_mediaplayer.lua"
include "sh_services.lua"
include "sh_history.lua"
include "sh_metadata.lua"

hook.Add("Initialize", "InitMediaPlayer", function()
	hook.Run("InitMediaPlayer", MediaPlayer)
end)

-- No fun allowed
hook.Add( "CanDrive", "DisableMediaPlayerDriving", function(ply, ent)
	if IsValid(ent) and ent.IsMediaPlayerEntity then
		return IsValid(ply) and ply:IsAdmin()
	end
end)

--PATH addons/media_player/lua/mediaplayer/services/base/shared.lua:
local string = string
local urllib = url
local os = os

local FormatSeconds = MediaPlayerUtils.FormatSeconds

SERVICE.Name 	= "Base Service"
SERVICE.Id 		= "base"
SERVICE.Abstract = true

-- Inherit EventEmitter for all service instances
EventEmitter:new(SERVICE)

local OwnerInfoPattern = "%s [%s]"

function SERVICE:New( url )
	local obj = setmetatable( {}, {
		__index = self,
		__tostring = self.__tostring
	} )

	obj.url = url

	local success, urlinfo = pcall(urllib.parse2, url)
	obj.urlinfo = success and urlinfo or {}

	if CLIENT then
		obj._playing = false
		obj._volume = 0.33
	end

	return obj
end

function SERVICE:__tostring()
	return string.format( '%s, %s, %s',
		self:Title(),
		FormatSeconds(self:Duration()),
		self:OwnerName() )
end

--
-- Determines if the media is valid.
--
-- @return boolean
--
function SERVICE:IsValid()
	return true
end

--
-- Determines if the media supports the given URL.
--
-- @param url URL.
-- @return boolean
--
function SERVICE:Match( url )
	return false
end

--
-- Gives the unique data used as part of the primary key in the metadata
-- database.
--
-- @return String
--
function SERVICE:Data()
	return self._data
end

function SERVICE:Owner()
	return self._Owner
end

SERVICE.GetOwner = SERVICE.Owner

function SERVICE:OwnerName()
	return self._OwnerName or ""
end

function SERVICE:OwnerSteamID()
	return self._OwnerSteamID or ""
end

function SERVICE:OwnerInfo()
	return OwnerInfoPattern:format( self._OwnerName, self._OwnerSteamID )
end

function SERVICE:IsOwner( ply )
	return ply == self:GetOwner() or
		ply:SteamID() == self:OwnerSteamID()
end

function SERVICE:Title()
	return self._metadata and self._metadata.title or "Unknown"
end

function SERVICE:Duration( duration )
	if duration then
		self._metadata = self._metadata or {}
		self._metadata.duration = duration
	end

	return self._metadata and self._metadata.duration or -1
end

--
-- Determines whether the media is timed.
--
-- @return boolean
--
function SERVICE:IsTimed()
	return true
end

function SERVICE:Thumbnail()
	return self._metadata and self._metadata.thumbnail
end

function SERVICE:Url()
	return self.url
end

SERVICE.URL = SERVICE.Url

function SERVICE:SetMetadata( metadata, new )
	self._metadata = metadata

	if new then
		local title = self._metadata.title or "Unknown"
		title = title:sub(1, MaxTitleLength)

		-- Escape any '%' char with a letter following it
		title = title:gsub('%%%a', '%%%%')

		self._metadata.title = title
	end
end

function SERVICE:SetMetadataValue( key, value )
	if not self._metadata then
		self._metadata = {}
	end

	self._metadata[key] = value
end

function SERVICE:GetMetadataValue( key )
	return self._metadata and self._metadata[key]
end

function SERVICE:UniqueID()
	if not self._id then
		local data = self:Data()
		if not data then
			data = util.CRC(self.url)
		end

		-- e.g. yt-G2MORmw703o
		self._id = string.format( "%s-%s", self.Id, data )
	end

	return self._id
end

--[[----------------------------------------------------------------------------
	Playback
------------------------------------------------------------------------------]]

function SERVICE:StartTime( seconds )
	if type(seconds) == 'number' then
		if self._PauseTime then
			self._PauseTime = RealTime()
		end

		self._StartTime = seconds
	end

	if self._PauseTime then
		local diff = self._PauseTime - self._StartTime
		return RealTime() - diff
	else
		return self._StartTime
	end
end

function SERVICE:CurrentTime()
	if self._StartTime then
		if self._PauseTime then
			return self._PauseTime - self._StartTime
		else
			return RealTime() - self._StartTime
		end
	else
		return -1
	end
end

function SERVICE:ResetTime()
	self._StartTime = nil
	self._PauseTime = nil
end

function SERVICE:IsPlaying()
	return self._playing
end

function SERVICE:Play()
	if self._PauseTime then
		-- Update start time to match the time when paused
		self._StartTime = RealTime() - (self._PauseTime - self._StartTime)
		self._PauseTime = nil
	end

	self._playing = true

	if CLIENT then
		self:emit('play')
	end
end

function SERVICE:Pause()
	self._PauseTime = RealTime()
	self._playing = false

	if CLIENT then
		self:emit('pause')
	end
end

--PATH addons/media_player/lua/mediaplayer/services/resource/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_browser" )

function SERVICE:OnBrowserReady( browser )
	BaseClass.OnBrowserReady( self, browser )

	local html = self:GetHTML()
	html = self.WrapHTML( html )

	self.Browser:SetHTML( html )
end

function SERVICE:GetHTML()
	return "<h1>SERVICE.GetHTML not yet implemented</h1>"
end

--PATH addons/media_player/lua/mediaplayer/services/html5_video.lua:
SERVICE.Name	= "HTML5 Video"
SERVICE.Id		= "h5v"
SERVICE.Base	= "res"

SERVICE.FileExtensions = {
	'webm',
	-- 'mp4',	-- not yet supported by Awesomium
	-- 'ogg'	-- already registered as audio, need a work-around :(
}

DEFINE_BASECLASS( "mp_service_base" )

if CLIENT then
	
	local MimeTypes = {
		webm = "video/webm",
		mp4 = "video/mp4",
		ogg = "video/ogg"
	}

	local EmbedHTML = [[
<video id="player" autoplay loop style="
		width: 100%%;
		height: 100%%;">
	<source src="%s" type="%s">
</video>
]]

	local JS_Volume = [[(function () {
	var elem = document.getElementById('player');
	if (elem) {
		elem.volume = %s;
	}
}());]]

	function SERVICE:GetHTML()
		local url = self.url

		local path = self.urlinfo.path
		local ext = path:match("[^/]+%.(%S+)$")

		local mime = MimeTypes[ext]

		return EmbedHTML:format(url, mime)
	end

	function SERVICE:Volume( volume )
		local origVolume = volume

		volume = BaseClass.Volume( self, volume )

		if origVolume and ValidPanel( self.Browser ) then
			self.Browser:RunJavascript(JS_Volume:format(volume))
		end
	end

end
--PATH addons/media_player/lua/autorun/properties/mediaplayer.lua:
local mporder = 3200

--
-- Adds a media player property.
--
-- Blue icons correspond to admin actions.
--
local function AddMediaPlayerProperty( name, config )
	-- Assign incrementing order ID
	config.Order = mporder
	mporder = mporder + 1

	properties.Add( name, config )
end

local function IsMediaPlayer( self, ent, ply )
	return IsValid(ent) and IsValid(ply) and
			IsValid(ent:GetMediaPlayer()) and
			gamemode.Call( "CanProperty", ply, self.InternalName, ent )
end

local function IsPrivilegedMediaPlayer( self, ent, ply )
	return IsMediaPlayer( self, ent, ply ) and
		( ply:IsAdmin() or ent:GetOwner() == ply )
end

local function HasMedia( mp )
	return mp:GetPlayerState() >= MP_STATE_PLAYING
end

AddMediaPlayerProperty( "mp-pause", {
	MenuLabel	=	"Pause",
	MenuIcon	=	"icon16/control_pause_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and mp:GetPlayerState() == MP_STATE_PLAYING
	end,

	Action		=	function( self, ent )
		MediaPlayer.Pause( ent )
	end
})

AddMediaPlayerProperty( "mp-resume", {
	MenuLabel	=	"Resume",
	MenuIcon	=	"icon16/control_play_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and mp:GetPlayerState() == MP_STATE_PAUSED
	end,

	Action		=	function( self, ent )
		MediaPlayer.Pause( ent )
	end
})

AddMediaPlayerProperty( "mp-skip", {
	MenuLabel	=	"Skip",
	MenuIcon	=	"icon16/control_end_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and HasMedia(mp)
	end,

	Action		=	function( self, ent )
		MediaPlayer.Skip( ent )
	end
})

AddMediaPlayerProperty( "mp-seek", {
	MenuLabel	=	"Seek",
	-- MenuIcon	=	"icon16/timeline_marker.png",
	MenuIcon	=	"icon16/control_fastforward_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and HasMedia(mp)
	end,

	Action		=	function( self, ent )

		Derma_StringRequest(
			"Media Player",
			"Enter a time in HH:MM:SS format (hours, minutes, seconds):",
			"", -- Default text
			function( time )
				MediaPlayer.Seek( ent, time )
			end,
			function() end,
			"Seek",
			"Cancel"
		)

	end
})

AddMediaPlayerProperty( "mp-request-url", {
	MenuLabel	=	"Request URL",
	MenuIcon	=	"icon16/link_add.png",
	Filter		=	IsMediaPlayer,

	Action		=	function( self, ent )

		MediaPlayer.OpenRequestMenu( ent )

	end
})

AddMediaPlayerProperty( "mp-copy-url", {
	MenuLabel	=	"Copy URL to clipboard",
	MenuIcon	=	"icon16/paste_plain.png",

	Filter		=	function( self, ent, ply )
		if not IsMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and HasMedia(mp)
	end,

	Action		=	function( self, ent )

		local mp = ent:GetMediaPlayer()
		local media = mp and mp:CurrentMedia()
		if not IsValid(media) then return end

		SetClipboardText( media:Url() )
		LocalPlayer():ChatPrint( "Media URL has been copied into your clipboard." )

	end
})

AddMediaPlayerProperty( "mp-enable", {
	MenuLabel	=	"Turn On",
	MenuIcon	=	"icon16/lightbulb.png",

	Filter		=	function( self, ent, ply )
		return IsValid(ent) and IsValid(ply) and
				ent.IsMediaPlayerEntity and
				not IsValid(ent:GetMediaPlayer()) and
				gamemode.Call( "CanProperty", ply, self.InternalName, ent )
	end,

	Action		=	function( self, ent )
		MediaPlayer.RequestListen( ent )
	end
})

AddMediaPlayerProperty( "mp-disable", {
	MenuLabel	=	"Turn Off",
	MenuIcon	=	"icon16/lightbulb_off.png",

	Filter		=	function( self, ent, ply )
		return IsValid(ent) and IsValid(ply) and
				ent.IsMediaPlayerEntity and
				IsValid(ent:GetMediaPlayer()) and
				gamemode.Call( "CanProperty", ply, self.InternalName, ent )
	end,

	Action		=	function( self, ent )
		MediaPlayer.RequestListen( ent )
	end
})

--PATH addons/media_player/lua/mp_menu/common.lua:
local ceil = math.ceil
local clamp = math.Clamp

local FormatSeconds = MediaPlayerUtils.FormatSeconds

--[[--------------------------------------------
	Sidebar fonts
----------------------------------------------]]

local FontTbl = {
	font = "Roboto Medium",
	size = 21,
	weight = 400,
	antialias = true
}

surface.CreateFont( "MP.MediaTitle", FontTbl )

FontTbl.font = "Roboto Medium"
FontTbl.size = 18
surface.CreateFont( "MP.MediaTime", FontTbl )

FontTbl.font = "Roboto Medium"
FontTbl.size = 18
surface.CreateFont( "MP.QueueHeader", FontTbl )

FontTbl.font = "Roboto Light"
FontTbl.size = 18
surface.CreateFont( "MP.MediaDuration", FontTbl )

FontTbl.font = "Roboto Light"
FontTbl.size = 13
surface.CreateFont( "MP.Prefix", FontTbl )

FontTbl.font = "Roboto Light"
FontTbl.size = 13
surface.CreateFont( "MP.VoteCount", FontTbl )

FontTbl.font = "Roboto Bold"
FontTbl.size = 16
surface.CreateFont( "MP.AddedByName", FontTbl )


--[[--------------------------------------------
	Common media player panels
----------------------------------------------]]

local MEDIA_TITLE = {}

function MEDIA_TITLE:Init()
	self.BaseClass.Init( self )
	self:SetFont( "MP.MediaTitle" )
	self:SetTextColor( color_white )
end

derma.DefineControl( "MP.MediaTitle", "", MEDIA_TITLE, "DLabel" )


local MEDIA_TIME = {}

AccessorFunc( MEDIA_TIME, "m_Media", "Media" )
AccessorFunc( MEDIA_TIME, "m_bShowCurrentTime", "ShowCurrentTime" )
AccessorFunc( MEDIA_TIME, "m_bShowDuration", "ShowDuration" )

function MEDIA_TIME:Init()

	self.TimeLbl = vgui.Create( "DLabel", self )
	self.TimeLbl:SetFont( "MP.MediaTime" )
	self.TimeLbl:SetText( "" )
	self.TimeLbl:SetTextColor( color_white )

	self.DividerLbl = vgui.Create( "DLabel", self )
	self.DividerLbl:SetText( "" )
	self.DividerLbl:SetFont( "MP.MediaDuration" )
	-- self.DividerLbl:SetTextColor( color_white )

	self.DurationLbl = vgui.Create( "DLabel", self )
	self.DurationLbl:SetText( "" )
	self.DurationLbl:SetFont( "MP.MediaDuration" )
	-- self.DurationLbl:SetTextColor( color_white )

	self:SetShowCurrentTime( false )
	self:SetShowDuration( true )

	self.NextThink = 0

end

function MEDIA_TIME:SetMedia( media )
	self.m_Media = media

	if media then
		self.DurationLbl:SetText( FormatSeconds( media:Duration() ) )
		self:UpdateDivider()
	end
end

function MEDIA_TIME:UpdateDivider()
	local text = (self.m_bShowCurrentTime and self.m_bShowDuration) and "/" or ""
	self.DividerLbl:SetText( text )
end

function MEDIA_TIME:SetListenForSeekEvents( listen )
	if listen and not self._listening then
		hook.Add( MP.EVENTS.UI.START_SEEKING, self, function(_, pnl) self:OnStartSeeking(pnl) end )
		hook.Add( MP.EVENTS.UI.STOP_SEEKING, self, function() self:OnStopSeeking() end )
	elseif not listen and self._listening then
		self:StopListeningForSeekEvents()
	end

	self._listening = listen
end

function MEDIA_TIME:StopListeningForSeekEvents()
	hook.Remove( MP.EVENTS.UI.START_SEEKING, self )
	hook.Remove( MP.EVENTS.UI.STOP_SEEKING, self )
end

function MEDIA_TIME:OnStartSeeking( seekbarPnl )
	self._seekbar = seekbarPnl
end

function MEDIA_TIME:OnStopSeeking()
	self._seekbar = nil
end

function MEDIA_TIME:OnRemove()
	if self._listening then
		self:StopListeningForSeekEvents()
	end
end

function MEDIA_TIME:Think()

	local rt = RealTime()

	if self.NextThink > rt then return end

	if self.m_Media then

		if self.m_bShowCurrentTime then
			local mediaTime
			local duration = self.m_Media:Duration()

			if self._seekbar then
				local progress = self._seekbar.m_fSlideX or 0
				mediaTime = progress * duration
			else
				mediaTime = self.m_Media:CurrentTime()
			end

			mediaTime = clamp(mediaTime, 0, duration)
			self.TimeLbl:SetText( FormatSeconds( mediaTime ) )
			self:UpdateDivider()
		end

	else
		-- TODO: hide info?
	end

	self:InvalidateLayout(true)

	self.NextThink = rt + 0.1

end

function MEDIA_TIME:PerformLayout()

	self.TimeLbl:SizeToContents()
	self.DividerLbl:SizeToContents()
	self.DurationLbl:SizeToContents()

	self.TimeLbl:CenterVertical()
	self.TimeLbl:AlignLeft( 0 )

	self.DividerLbl:CenterVertical()
	self.DividerLbl:MoveRightOf( self.TimeLbl )

	self.DurationLbl:CenterVertical()
	self.DurationLbl:MoveRightOf( self.DividerLbl )

	local totalwidth = self.DurationLbl:GetPos() + self.DurationLbl:GetWide()
	self:SetWide( totalwidth )

end

derma.DefineControl( "MP.MediaTime", "", MEDIA_TIME, "Panel" )


local ADDED_BY = {}

ADDED_BY.Height = 21
ADDED_BY.NameOffset = 4

function ADDED_BY:Init()

	self.PrefixLbl = vgui.Create( "DLabel", self )
	self.PrefixLbl:SetFont( "MP.Prefix" )
	self.PrefixLbl:SetText( "ADDED BY" )
	self.PrefixLbl:SetTextColor( color_white )
	self.PrefixLbl:SetContentAlignment( 8 )

	self.NameLbl = vgui.Create( "DLabel", self )
	self.NameLbl:SetFont( "MP.AddedByName" )
	self.NameLbl:SetText( "Unknown" )
	self.NameLbl:SetTextColor( color_white )
	self.NameLbl:SetContentAlignment( 8 )

end

function ADDED_BY:SetPlayer( ply, name, steamId )
	self.NameLbl:SetText( name )
	self.NameLbl:SetTooltip( steamId )
end

function ADDED_BY:SetMaxWidth( width )
	self.maxWidth = width
	self:InvalidateLayout(true)
end

function ADDED_BY:PerformLayout()

	local name = self.NameLbl:GetText()
	if name == "" then
		self:SetSize( 0, self.Height )
		return
	end

	self.PrefixLbl:SizeToContents()
	self.NameLbl:SizeToContents()

	local pw = self.PrefixLbl:GetWide()
	local nw = self.NameLbl:GetWide()
	local w = pw + nw + self.NameOffset

	if self.maxWidth then
		w = math.min( w, self.maxWidth )

		-- Clips name label to the maximum width; looks kind of bad since the
		-- ellipsis start too early for some reason.
		-- nw = math.max( 0, w - self.NameOffset - pw )
		-- self.NameLbl:SetWide( nw )
	end

	self:SetSize( w, self.Height )

	self.PrefixLbl:AlignLeft( 0 )
	self.NameLbl:MoveRightOf( self.PrefixLbl, self.NameOffset )

	-- align text baselines
	self.PrefixLbl:AlignBottom( 3 )
	self.NameLbl:AlignBottom( 3 )

end

derma.DefineControl( "MP.AddedBy", "", ADDED_BY, "Panel" )

--[[--------------------------------------------
	Sidebar buttons
----------------------------------------------]]

local BTN_ALPHA_HIGHLIGHTED = 255
local BTN_ALPHA_NORMAL = 84 -- 33% opacity

local SIDEBAR_BTN = {
	Width = 21
}

AccessorFunc( SIDEBAR_BTN, "m_Media", "Media" )
AccessorFunc( SIDEBAR_BTN, "m_bHighlighted", "Highlighted" )
AccessorFunc( SIDEBAR_BTN, "m_HighlightColor", "HighlightColor" )

function SIDEBAR_BTN:Init()
	self:SetSize( self.Width, self.Width )
	self:SetAlpha( BTN_ALPHA_NORMAL )
end

function SIDEBAR_BTN:Think()
	if self.m_bHighlighted or self:IsHovered() and not self.m_bDisabled then
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	elseif self.m_HighlightColor then
		self:SetColor( self.m_HighlightColor )
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	else
		self:SetAlpha( BTN_ALPHA_NORMAL )
	end
end

-- function SIDEBAR_BTN:Paint(w,h)
-- 	surface.SetDrawColor(255,0,0)
-- 	surface.DrawRect(0,0,w,h)
-- end

derma.DefineControl( "MP.SidebarButton", "", SIDEBAR_BTN, "DIconButton" )


local SIDEBAR_TOGGLE_BTN = {
	m_EnabledColor = color_white
}

AccessorFunc( SIDEBAR_TOGGLE_BTN, "m_bEnabled", "Enabled" )
AccessorFunc( SIDEBAR_TOGGLE_BTN, "m_EnabledColor", "EnabledColor" )

function SIDEBAR_TOGGLE_BTN:Think()
	if self.m_bEnabled then
		self:SetColor( self.m_EnabledColor )
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	elseif self.m_bHighlighted or self:IsHovered() and not self.m_bDisabled then
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	elseif self.m_HighlightColor then
		self:SetColor( self.m_HighlightColor )
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	else
		self:SetAlpha( BTN_ALPHA_NORMAL )
	end
end

function SIDEBAR_TOGGLE_BTN:DoClick()
	local enabled = not self:GetEnabled()
	self:SetEnabled( enabled )

	if not enabled then
		self:SetColor( color_white )
	end
end

derma.DefineControl( "MP.SidebarToggleButton", "", SIDEBAR_TOGGLE_BTN, "MP.SidebarButton" )


local FAVORITE_BTN = {}

AccessorFunc( FAVORITE_BTN, "Favorited", "Favorited" )

function FAVORITE_BTN:Init()
	self.BaseClass.Init( self )

	self:SetIcon( "mp-favorite-outline" )
	self:SetFavorited( false )
	self.Outlined = true
end

function FAVORITE_BTN:Think()
	self.BaseClass.Think(self)

	if not self.Favorited then
		local hovered = self:IsHovered()

		if self.Outlined then
			if hovered then
				self:SetIcon( "mp-favorite" )
				self:SetHighlighted( true )
				self.Outlined = false
			end
		else
			if not hovered then
				self:SetIcon( "mp-favorite-outline" )
				self:SetHighlighted( false )
				self.Outlined = true
			end
		end
	end
end

function FAVORITE_BTN:DoClick()
	hook.Run( MP.EVENTS.UI.FAVORITE_MEDIA, self.m_Media )
end

derma.DefineControl( "MP.FavoriteButton", "", FAVORITE_BTN, "MP.SidebarButton" )


local REMOVE_BTN = {}

function REMOVE_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-delete" )
end

function REMOVE_BTN:DoClick()
	hook.Run( MP.EVENTS.UI.REMOVE_MEDIA, self.m_Media )
end

derma.DefineControl( "MP.RemoveButton", "", REMOVE_BTN, "MP.SidebarButton" )


local SKIP_BTN = {}

function SKIP_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-skip" )
end

function SKIP_BTN:DoClick()
	hook.Run( MP.EVENTS.UI.SKIP_MEDIA )
end

derma.DefineControl( "MP.SkipButton", "", SKIP_BTN, "MP.SidebarButton" )


--[[--------------------------------------------
	Vote controls
----------------------------------------------]]

local VOTE_POSITIVE = 1
local VOTE_NEGATIVE = -1

local VOTE_CONTROLS = {
	Width = 60,
	Height = 21,
	VoteCountPadding = 5
}

AccessorFunc( VOTE_CONTROLS, "m_iVoteCount", "VoteCount" )
AccessorFunc( VOTE_CONTROLS, "m_iVoteValue", "VoteValue" )

AccessorFunc( VOTE_CONTROLS, "m_bUpvoteEnabled", "UpvoteEnabled" )
AccessorFunc( VOTE_CONTROLS, "m_bDownvoteEnabled", "DownvoteEnabled" )

function VOTE_CONTROLS:Init()
	self:SetSize( self.Width, self.Height )

	self.UpvoteBtn = vgui.Create( "MP.UpvoteButton", self )
	self.UpvoteBtn.OnVote = function(btn) self:OnUpvote(btn) end

	self.DownvoteBtn = vgui.Create( "MP.DownvoteButton", self )
	self.DownvoteBtn.OnVote = function(btn) self:OnDownvote(btn) end

	self.VoteCountLbl = vgui.Create( "DLabel", self )
	self.VoteCountLbl:SetTextColor( color_white )
	self.VoteCountLbl:SetFont( "MP.VoteCount" )

	-- TODO: setup event handlers for voting and set the vote count

	-- TODO: listen for global media vote events and update count

	self:SetVoteCount( 0 )
	self:SetVoteValue( 0 )

	self:SetUpvoteEnabled( true )
	self:SetDownvoteEnabled( true )
end

function VOTE_CONTROLS:SetMedia( media )
	self.m_Media = media

	local voteCount = media:GetMetadataValue("votes") or 0
	self:SetVoteCount(voteCount)

	local localVote = media:GetMetadataValue("localVote") or 0
	self:SetVoteValue( localVote )

	self.UpvoteBtn:SetMedia( media )
	self.DownvoteBtn:SetMedia( media )
end

function VOTE_CONTROLS:SetVoteCount( count )
	self.m_iVoteCount = count
	self.VoteCountLbl:SetText( count )
	self:InvalidateLayout(true)
end

function VOTE_CONTROLS:SetVoteValue( value )
	self.m_iVoteValue = value

	if value > 0 then
		-- highlight upvote button
		self.UpvoteBtn:SetHighlighted( true )
		self.DownvoteBtn:SetHighlighted( false )
	elseif value < 0 then
		-- highlight downvote button
		self.UpvoteBtn:SetHighlighted( false )
		self.DownvoteBtn:SetHighlighted( true )
	else
		-- don't highlight either button
		self.UpvoteBtn:SetHighlighted( false )
		self.DownvoteBtn:SetHighlighted( false )
	end
end

function VOTE_CONTROLS:OnUpvote()
	local value = self:GetVoteValue()

	if value > 0 then
		value = 0 -- remove vote
	else
		value = 1 -- set vote
	end

	self:SetVoteCount( self:GetVoteCount() + value )
	self:SetVoteValue( value )

	hook.Run( MP.EVENTS.UI.VOTE_MEDIA, self.m_Media, value )
end

function VOTE_CONTROLS:OnDownvote()
	local value = self:GetVoteValue()

	if value < 0 then
		value = 0 -- remove vote
	else
		value = -1 -- set vote
	end

	self:SetVoteCount( self:GetVoteCount() + value )
	self:SetVoteValue( value )

	hook.Run( MP.EVENTS.UI.VOTE_MEDIA, self.m_Media, value )
end

function VOTE_CONTROLS:PerformLayout()
	local align
	local w = self.Width

	local upvoteEnabled = self:GetUpvoteEnabled()
	local downvoteEnabled = self:GetDownvoteEnabled()

	if upvoteEnabled and downvoteEnabled then
		align = TEXT_ALIGN_CENTER
		w = w - SIDEBAR_BTN.Width * 2
	elseif upvoteEnabled then
		align = TEXT_ALIGN_RIGHT
		w = w - SIDEBAR_BTN.Width
	else
		align = TEXT_ALIGN_LEFT
		w = w - SIDEBAR_BTN.Width
	end

	self:SetSize( w, self.Height )

	if upvoteEnabled then
		self.UpvoteBtn:Show()
		self.UpvoteBtn:AlignLeft()
		self.UpvoteBtn:CenterVertical()
	else
		self.UpvoteBtn:Hide()
	end

	if downvoteEnabled then
		self.DownvoteBtn:Show()
		self.DownvoteBtn:AlignRight()
		self.DownvoteBtn:CenterVertical()
	else
		self.DownvoteBtn:Hide()
	end

	self.VoteCountLbl:SizeToContents()
	self.VoteCountLbl:CenterVertical()

	if align == TEXT_ALIGN_LEFT then
		self.VoteCountLbl:SetContentAlignment(4)
		self.VoteCountLbl:AlignLeft( self.VoteCountPadding )
	elseif align == TEXT_ALIGN_RIGHT then
		self.VoteCountLbl:SetContentAlignment(6)
		self.VoteCountLbl:AlignRight( self.VoteCountPadding )
	else -- TEXT_ALIGN_CENTER
		self.VoteCountLbl:SetContentAlignment(5)
		self.VoteCountLbl:CenterHorizontal()
	end

end

derma.DefineControl( "MP.VoteControls", "", VOTE_CONTROLS, "DPanel" )


local UPVOTE_BTN = {}

function UPVOTE_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-thumbs-up" )
end

function UPVOTE_BTN:DoClick()
	self:OnVote( VOTE_POSITIVE )
end

function UPVOTE_BTN:OnVote( value )
end

derma.DefineControl( "MP.UpvoteButton", "", UPVOTE_BTN, "MP.SidebarButton" )


local DOWNVOTE_BTN = {}

function DOWNVOTE_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-thumbs-down" )
end

function DOWNVOTE_BTN:DoClick()
	self:OnVote( VOTE_NEGATIVE )
end

function DOWNVOTE_BTN:OnVote( value )
end

derma.DefineControl( "MP.DownvoteButton", "", DOWNVOTE_BTN, "MP.SidebarButton" )

--PATH addons/ukrp_main_content/lua/autorun/miner.lua:
player_manager.AddValidModel( "Miner", "models/player/miner_m.mdl" );
list.Set( "PlayerOptionsModel", "Miner", "models/player/miner_m.mdl" );
player_manager.AddValidModel( "Minerf", "models/player/miner_f.mdl" );
list.Set( "PlayerOptionsModel", "Minerf", "models/player/miner_f.mdl" );
--PATH addons/____onyx_framework_2/lua/autorun/onyx_autorun.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

onyx = {}
onyx.cfg = {}

AddCSLuaFile('onyx/util.lua')
include('onyx/util.lua')
AddCSLuaFile('onyx/init.lua')
include('onyx/init.lua')
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/cl_lang.lua:
--[[

Author: tochonement
Email: tochonement@gmail.com

28.09.2021

--]]

onyx.lang = onyx.lang or {}
onyx.lang.phrases = onyx.lang.phrases or {}
onyx.lang.id = onyx.lang.id or 'default'

local lang = onyx.lang

function lang:AddPhrase(langID, phraseID, text)
    self.phrases[langID] = self.phrases[langID] or {}
    self.phrases[langID][phraseID] = text
end

function lang:AddPhrases(langID, phrasesTable)
    for phraseID, text in pairs(phrasesTable) do
        self:AddPhrase(langID, phraseID, text)
    end
end

do
    local gsub = string.gsub
    local tostring = tostring
    local pairs = pairs

    function lang:Get(phraseID, arguments, translateArguments)
        local basePhrases = self.phrases.english or {}
        local localPhrases = self.phrases[self.id] or {}
        local text

        -- Search in the local phrases table
        if localPhrases[phraseID] then
            text = localPhrases[phraseID]
            goto process
        end

        -- Search in the base phrases table
        if basePhrases[phraseID] then
            text = basePhrases[phraseID]
            goto process
        end

        ::process::

        -- Place the arguments into the found text
        if text and arguments then
            for key, value in pairs(arguments) do
                value = tostring(value)

                local argument = translateArguments and lang:Get(value) or value

                text = gsub(text, '{' .. key .. '}', argument, 1)
            end
        end

        return text or phraseID
    end

    function lang:GetWFallback(phraseID, fallback)
        local phrase = self:Get(phraseID)
        if (phrase == phraseID) then
            return (fallback or phrase)
        else
            return phrase
        end
    end
end

do
    local languageReference = {
        en = 'english',
        de = 'german',
        fr = 'french',
        ua = 'ukrainian',
        it = 'italian',
        tr = 'turkish',
        da = 'danish',
        pl = 'polish',
        ['es-ES'] = 'spanish'
    }

    function lang:GetGameLanguage()
        local current = GetConVar('gmod_language'):GetString()
        return languageReference[current]
    end

    function lang:SetBestLanguage()
        self.id = 'ukrainian'
    end

    lang:SetBestLanguage()

    cvars.AddChangeCallback('gmod_language', function()
        lang:SetBestLanguage()
    end, 'onyx.lang')
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/cfg/cl_config.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

onyx.cfg.fontFamily = 'Comfortaa' -- probably does nothing, but I keep it just in case I missed something

local function hexcolor(hex)
	local r, g, b = string.match(hex, '#(..)(..)(..)')
	local a = string.len(hex) > 7 and string.Right(hex, 2) or "FF"

	return Color(tonumber(r, 16), tonumber(g, 16), tonumber(b, 16), tonumber(a, 16))
end

onyx.cfg.colors = {}
onyx.cfg.colors.primary = hexcolor('#26272E')
onyx.cfg.colors.secondary = hexcolor('#2A2C33')
onyx.cfg.colors.tertiary = hexcolor('#30323B')
onyx.cfg.colors.quaternary = hexcolor('#26272E')
onyx.cfg.colors.accent = Color(74, 172, 252)
onyx.cfg.colors.lightgray = Color(235, 235, 235)
onyx.cfg.colors.gray = Color(144, 144, 144)
onyx.cfg.colors.positive = Color(39, 174, 96)
onyx.cfg.colors.negative = Color(235, 77, 75)

onyx.wimg.Register('user', 'https://i.imgur.com/J1fNKdK.png')
onyx.wimg.Register('dashboard', 'https://i.imgur.com/9jAEe6f.png')
onyx.wimg.Register('home', 'https://i.imgur.com/Tv1U4pn.png')
onyx.wimg.Register('close', 'https://i.imgur.com/0jZwhKu.png')
onyx.wimg.Register('close-circle', 'https://i.imgur.com/Ee3TAhI.png')
onyx.wimg.Register('gear', 'https://i.imgur.com/njRQmA5.png')

hook.Call('onyx.ui.LoadedConfig')
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_color_wheel.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

13/06/2023

--]]

onyx.wimg.Register('color_wheel', 'https://i.imgur.com/i0asO69.png')

local wimgColorCircle = onyx.wimg.Create('color_wheel', 'mips')

local PANEL = {}

AccessorFunc(PANEL, 'm_Saturation', 'Saturation', FORCE_NUMBER)
AccessorFunc(PANEL, 'm_Hue', 'Hue', FORCE_NUMBER)
AccessorFunc(PANEL, 'm_Value', 'Value', FORCE_NUMBER)

function PANEL:Init()
    self:SetSaturation(0)
    self:SetHue(0)
    self:SetValue(1)
    self.dragging = false
end

function PANEL:SetValue(value)
    self.m_Value = math.Clamp(value, 0, 1)

    local brightness = 255 * self.m_Value
    local crosshairBrightness = 255 - brightness

    self.wheelColor = Color(brightness, brightness, brightness)
    self.crosshairColor = Color(crosshairBrightness, crosshairBrightness, crosshairBrightness)
end

function PANEL:Paint(w, h)
    local saturation = self.m_Saturation
    local hue = self.m_Hue

    -- draw circle with smooth edges
    render.PushFilterMin(TEXFILTER.ANISOTROPIC)
    render.PushFilterMag(TEXFILTER.ANISOTROPIC)
    wimgColorCircle:Draw(0, 0, w, h, self.wheelColor)
    render.PopFilterMin()
    render.PopFilterMag()

    -- draw crosshair
    local x0, y0 = w * .5, h * .5
    local x, y = x0, y0

    local r = h * .5 * saturation
    local rad = math.rad((hue - 90) % 360)
    local sin, cos = math.sin(rad), math.cos(rad)

    x = x0 + r * cos
    y = y0 + r * sin

    surface.SetDrawColor(self.crosshairColor)
    surface.DrawRect(x - 4, y - 1, 8, 2)
    surface.DrawRect(x - 1, y - 4, 2, 8)
end

function PANEL:OnMousePressed()
    self.dragging = true
    self:MouseCapture(true)
end

function PANEL:OnMouseReleased()
    self.dragging = false
    self:MouseCapture(false)
end

function PANEL:Think()
    if (self.dragging) then
        local x, y = self:ScreenToLocal(input.GetCursorPos())
        local w, h = self:GetSize()
        local radius = w * .5

        x = math.Clamp(x, 0, w)
        y = math.Clamp(y, 0, h)

        local xRelative0, yRelative0 = x - radius, y - radius

        local rad = math.atan2(yRelative0, xRelative0)
        local length = math.sqrt( math.pow(xRelative0, 2) + math.pow(yRelative0, 2) )

        self.m_Hue = (math.deg(rad) + 90) % 360
        self.m_Saturation = math.min(1, length / radius)
    end
end

function PANEL:GetColor()
    -- https://github.com/facepunch/garrysmod-issues/issues/2407
    local colorTable = HSVToColor(self.m_Hue, self.m_Saturation, self.m_Value)
    local colorObject = Color(colorTable.r, colorTable.g, colorTable.b)
    return colorObject
end

function PANEL:SetColor(color)
    local h, s, v = ColorToHSV(color)

    self:SetHue(h)
    self:SetSaturation(s)
    self:SetValue(v)
end

onyx.gui.Register('onyx.ColorWheel', PANEL)

-- onyx.gui.Test('DFrame', .5, .5, function(self)
--     self:MakePopup()

--     local mixer = self:Add('onyx.ColorWheel')
--     mixer:SetSize(64, 64)
--     mixer:Center()
--     mixer:SetSaturation(.5)
--     mixer:SetValue(1)
--     mixer:SetColor(Color(255, 53, 53))

--     local panel = self:Add('Panel')
--     panel:SetSize(48, 48)
--     panel.Paint = function(p, w, h)
--         surface.SetDrawColor(mixer:GetColor())
--         surface.DrawRect(0, 0, w, h)
--     end
-- end)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_rounded_avatar.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/04/2023

--]]

local PANEL = {}

function PANEL:Init()
    self.avatar = self:Add('AvatarImage')
    self.avatar:Dock(FILL)
    self.avatar:SetPaintedManually(true)

    self:Combine(self.avatar, 'SetPlayer')
    self:Combine(self.avatar, 'SetSteamID')
end

function PANEL:PerformLayout(w, h)
    self.mask = onyx.CalculateCircle(w * .5, h * .5, math.Round(h * .5) - 1, 24)
end

function PANEL:Paint(w, h)
    local mask = self.mask
    if (mask) then
        onyx.MaskFn(function()
            onyx.DrawPoly(mask)
        end, function()
            self.avatar:PaintManual()
        end)
    end
end

onyx.gui.Register('onyx.RoundedAvatar', PANEL)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_scroll.lua:
--[[

Author: tochonement
Email: tochonement@gmail.com

22.08.2021

--]]

local PANEL = {}

function PANEL:Init()
    onyx.gui.Extend(self.btnGrip)

    self:Import('smoothscroll')
    self:SetHideButtons(true)

    self.bgColor = ColorAlpha(onyx.cfg.colors.accent, 40)

    self.btnGrip.color = Color(0, 0, 0)
    self.btnGrip:Import('hovercolor')
    self.btnGrip:SetColorKey('color')
    self.btnGrip:SetColorIdle(onyx.cfg.colors.accent)
    self.btnGrip:SetColorHover(onyx.OffsetColor(onyx.cfg.colors.accent, -30))
    self.btnGrip.Paint = function(panel, w, h)
        draw.RoundedBox(4, 0, 0, w, h, panel.color)
    end
end

function PANEL:Paint(w, h)
    draw.RoundedBox(4, 0, 0, w, h, self.bgColor)
end

function PANEL:OnMouseWheeled(delta)
    local hovered = vgui.GetHoveredPanel()

    if IsValid(hovered) and hovered ~= self and hovered.OnMouseWheeled then
        return
    end

    self.BaseClass.OnMouseWheeled(self, delta)
end

onyx.gui.Register('onyx.Scroll', PANEL, 'DVScrollBar')
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_text_entry.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorBG = colorPrimary

AccessorFunc(PANEL, 'm_PlaceholderText', 'PlaceholderText')
AccessorFunc(PANEL, 'm_colPlaceholderColor', 'PlaceholderColor')
AccessorFunc(PANEL, 'm_PlaceholderFont', 'PlaceholderFont')
AccessorFunc(PANEL, 'm_iTextSpace', 'TextSpace')

local MUTATORS = {
    'Font',
    'HistoryEnabled',
    'Multiline',
    'Numeric',
    -- 'PlaceholderColor',
    -- 'PlaceholderText',
    'TabbingDisabled',
    'TextColor',
    'UpdateOnType',
    'Value'
}

local DISPATCH = {
    'OnLoseFocus',
    'OnGetFocus',
    'AllowInput',
    'OnChange',
    'OnEnter',
    'OnKeyCode',
    'OnValueChange',
    'OnCursorEntered',
    'OnCursorExited',
}

function PANEL:Init()
    self:SetTextSpace(onyx.ScaleWide(10))
    self:SetTall(onyx.ScaleTall(30))
    self.colors = {
        outline = colorSecondary,
        accent = colorAccent
    }

    self.textEntry = self:Add('DTextEntry')
    self.textEntry:Dock(FILL)
    self.textEntry:DockPadding(0, 0, 0, 0)
    self.textEntry:DockMargin(0, 0, 0, 0)
    self.textEntry.Paint = function(panel, w, h)
        panel:DrawTextEntryText(panel:GetTextColor(), colorAccent, panel:GetTextColor())
    end

    for _, name in ipairs(MUTATORS) do
        self:CombineMutator(self.textEntry, name)
    end

    for _, name in ipairs(DISPATCH) do
        self:MakeDispatchFn(self.textEntry, name)
    end

    self:SetFont(onyx.Font('Comfortaa@16'))
    self:SetTextColor(color_white)
    self:SetPlaceholderFont(self:GetFont())
    self:SetPlaceholderColor(Color(125, 125, 125))

    self:Import('hovercolor')
    self:SetColorKey('colorBackground')
    self:SetColorIdle(colorBG)
    self:SetColorHover(onyx.OffsetColor(colorBG, -5))

    self.focusAnimFraction = 0
    self.currentOutlineColor = onyx.CopyColor( self.colors.outline )
end

function PANEL:SetDisabled(bool)
    self.textEntry:SetDisabled(bool)
    self.textEntry:SetCursor(bool and 'no' or 'beam')
    self.m_bDisabled = bool

    if (bool) then
        self:Call('OnDisabled')
    else
        self:Call('OnEnabled')
    end
end

function PANEL:GetDisabled()
    return self.m_bDisabled
end

function PANEL:OnDisabled()
    local offset = -5
    self.onyxAnims = {}
    self:SetColorIdle(onyx.OffsetColor(colorBG, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:OnEnabled()
    local offset = 0
    self.onyxAnims = {}
    self:SetColorIdle(onyx.OffsetColor(colorBG, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:PerformLayout(w, h)
    local gmodOffset = 2 -- lol, there's is slight text offset in dtextentryy (for 1920x1080)

    self:DockPadding(self.m_iTextSpace - gmodOffset, 0, self.m_iTextSpace - gmodOffset, 0)
    self:DockMargin(0, 0, 0, 0)
end

function PANEL:SetPlaceholderIcon(icon, params)
    self.placeholderWebImage = onyx.wimg.Simple(icon, params)
end

function PANEL:OnGetFocus()
    self:SetHoverBlocked(true)
    self:ResetHighlight()

    onyx.anim.Simple(self, .25, {
        focusAnimFraction = 1,
        currentOutlineColor = self.colors.accent
    }, 1, nil, nil, 'inQuad')
end

function PANEL:OnLoseFocus()
    self:SetHoverBlocked(false)
    self:OnCursorExited()

    onyx.anim.Simple(self, .25, {
        focusAnimFraction = 0,
        currentOutlineColor = self.colors.outline
    }, 1, nil, nil, 'outQuad')
end

function PANEL:Paint(w, h)
    local text = self:GetPlaceholderText()
    local color = self:GetPlaceholderColor()
    local thickness = 1
    local currentOutlineColor = self.currentOutlineColor

    if (self.highlight) then
        currentOutlineColor = ColorAlpha(self.highlightColor, math.abs(math.sin(CurTime() * 6)) * 200 + 55)
        if (self.highlightEndTime and self.highlightEndTime <= CurTime()) then
            self:ResetHighlight()
        end
    end

    draw.RoundedBox(8, 0, 0, w, h, currentOutlineColor)
    draw.RoundedBox(8, thickness, thickness, w - thickness * 2, h - thickness * 2, self.colorBackground)

    if (self:GetValue() == '' and text and text ~= '') then
        local placeholderWebImage = self.placeholderWebImage
        local x = self.m_iTextSpace

        if (placeholderWebImage) then
            local size = onyx.ScaleTall(12)

            placeholderWebImage:Draw(x, h * .5 - size * .5, size, size, colorAccent)

            x = x + size + onyx.ScaleWide(5)
        end

        draw.SimpleText(text, self:GetPlaceholderFont(), x, h * .5, color, 0, 1)
    end
end

function PANEL:Highlight(color, time)
    self.highlightColor = color
    self.highlightStartTime = CurTime()
    if (time) then
        self.highlightEndTime = CurTime() + time
    end
    self.highlight = true
end

function PANEL:ResetHighlight()
    self.highlightColor = nil
    self.highlightStartTime = nil
    self.highlightEndTime = nil
    self.highlight = nil
end

onyx.gui.Register('onyx.TextEntry', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     local content = self:Add('Panel')
--     content:Dock(FILL)
--     content:DockMargin(5, 5, 5, 5)

--         local btn = content:Add('onyx.ComboBox')
--         btn:Dock(TOP)
--         btn:DockMargin(0, 0 ,0 ,5)
--     btn:Highlight(Color(212, 72, 72))

--         local btn = content:Add('onyx.TextEntry')
--         btn:Dock(TOP)
--         btn:DockMargin(0, 0 ,0 ,5)
--         btn:SetPlaceholderText('Tset')
--     btn:Highlight(Color(212, 72, 72))

-- end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/types/sh_booster.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

08/05/2023

--]]

local BOOSTER_HEALTH = 0
local BOOSTER_ARMOR = 1
local BOOSTER_SPEED = 2
local BOOSTER_DAMAGE = 3
local BOOSTER_JUMP = 4

onyx.creditstore:RegisterType('permbooster', {
    name = 'Permanent Booster',
    color = Color(233, 94, 69),
    noDuplicates = true,
    equip = true,
    settings = {
        {
            key = 'action',
            name = 'VARIABLE',
            desc = 'What variable to edit',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'combo',
            options = {
                {text = 'Health', data = BOOSTER_HEALTH},
                {text = 'Armor', data = BOOSTER_ARMOR},
                {text = 'Speed', data = BOOSTER_SPEED},
                {text = 'Damage', data = BOOSTER_DAMAGE},
                {text = 'Jump', data = BOOSTER_JUMP}
            },
            validateOption = function(data)
                -- do not be lazy to do this function, it is also used on the server side to validate value
                if (data == nil) then return false, 'You must choose a variable type!' end
                if (not isnumber(data)) then return false end
                if (data < 0 or data > 4) then return false end
        
                return true
            end
        },
        {
            key = 'percents',
            name = 'PERCENTAGE',
            desc = 'The percentage.',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'number',
            placeholder = '20',
            validateOption = function(value)
                if (not isnumber(value)) then
                    return false, 'The amount must be a number!'
                end
                if (value < 1) then
                    return false, 'The amount must be higher than 1!'
                end
                if (value > 100) then
                    return false, 'The amount must be lower than 100!'
                end
                return true
            end
        }
    }
})

if (CLIENT) then
    return
end

local functions = {
    [BOOSTER_HEALTH] = function(ply, fraction)
        local maxHealth = ply:GetMaxHealth()
        local curHealth = ply:Health()
        local addHealth = math.floor(maxHealth * fraction)

        ply:SetHealth(curHealth + addHealth)
        ply:SetMaxHealth(maxHealth + addHealth)
    end,
    [BOOSTER_ARMOR] = function(ply, fraction)
        local maxArmor = ply:GetMaxArmor()
        local curArmor = ply:Armor()
        local addArmor = math.floor(maxArmor * fraction)

        ply:SetArmor(curArmor + addArmor)
    end,
    [BOOSTER_SPEED] = function(ply, fraction)
        ply:SetWalkSpeed(math.floor(ply:GetWalkSpeed() * (1 + fraction)))
        ply:SetRunSpeed(math.floor(ply:GetRunSpeed() * (1 + fraction)))
    end,
    [BOOSTER_DAMAGE] = function(ply, fraction)
        ply.onyx_DamageScale = (1 + fraction)
    end,
    [BOOSTER_JUMP] = function(ply, fraction)
        ply:SetJumpPower(math.floor(ply:GetJumpPower() * (1 + fraction)))
    end
}

hook.Add('PlayerLoadout', 'onyx.creditstore.booster', function(ply)
    local inv = onyx.creditstore:GetPlayerInventory(ply)
    for _, it in ipairs(inv) do
        local id = it.id
        local item = onyx.creditstore.items[id]
        if (item and item.type == 'permbooster') then
            local data = item.data
            local action = data.action
            local percents = data.percents
            local func = functions[action]
            if (func and it.data and it.data.equipped) then
                func(ply, (percents / 100))
            end
        end
    end
end)

hook.Add('EntityTakeDamage', 'onyx.creditstore.booster', function(ent, dmg)
    local attacker = dmg:GetAttacker()
    if (IsValid(attacker) and attacker.onyx_DamageScale) then
        dmg:ScaleDamage(attacker.onyx_DamageScale)
    end
end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/types/sh_trail.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/05/2023

--]]

onyx.creditstore:RegisterType('trail', {
    name = 'Trail',
    color = Color(85, 69, 233),
    noDuplicates = true,
    equip = true,
    uniqueEquip = true,
    defaultIcon = 'https://i.imgur.com/LNjxkeD.png',
    onEquip = function(ply, itemTableData)
        if (IsValid(ply.onyx_TrailEnt)) then
            ply.onyx_TrailEnt:Remove()
        end

        ply.onyx_TrailEnt = util.SpriteTrail(ply, 0, Color( 255, 255, 255 ), false, 15, 1, 4, 1 / 16 * 0.5, itemTableData.texture)
    end,
    onUnequip = function(ply, itemTableData)
        if (IsValid(ply.onyx_TrailEnt)) then
            ply.onyx_TrailEnt:Remove()
        end
    end,
    onLoadout = function(ply, itemTableData)
        ply.onyx_TrailEnt = ply:GetModel()
    end,
    settings = {
        {
            key = 'texture',
            name = 'TEXTURE',
            desc = 'The texture/material path.',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'combo',
            getOptions = function()
                local options = {}
        
                for name, texture in pairs(list.Get('trail_materials')) do
                    local printName = language.GetPhrase(name)
    
                    table.insert(options, {
                        text = printName,
                        data = texture
                    })
                end
        
                table.sort(options, function(a, b)
                    return a.text < b.text
                end)
        
                return options
            end,
            validateOption = function(data)
                -- do not be lazy to do this function, it is also used on the server side to validate value
                if (not data) then return false, 'You must choose a trail!' end
        
                return true
            end
        }
    }
})
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/ui/cl_admin_player_inventory.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

19/04/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local colorQuaternary = onyx:Config('colors.quaternary')
local colorGray = Color(155, 155, 155)
local colorRed = Color(196, 77, 77)
local wimgCoin = onyx.wimg.Create('creditstore_currency', 'smooth mips')

local font0 = onyx.Font('Comfortaa Bold@16')
local font1 = onyx.Font('Comfortaa Bold@20')
local font2 = onyx.Font('Comfortaa@16')

function PANEL:Init()
    local margin = onyx.ScaleTall(10)
    local padding = onyx.ScaleTall(5)

    self.list = self:Add('Panel')
    self.list:Dock(FILL)
    self.list:DockMargin(margin, margin, margin, margin)

    self.header = self.list:Add('DPanel')
    self.header:Dock(TOP)
    self.header:SetTall(onyx.ScaleTall(45))
    self.header:DockPadding(padding, padding, padding, padding)
    self.header:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.header.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end

    self.avatar = self.header:Add('onyx.RoundedAvatar')
    self.avatar:Dock(LEFT)
    self.avatar:SetWide(self.header:GetTall() - padding * 2 )
    self.avatar:DockMargin(0, 0, margin, 0)

    self.lblName = self.header:Add('onyx.Label')
    self.lblName:Dock(TOP)
    self.lblName:SetText('UNKNOWN')
    self.lblName:SetTall((self.header:GetTall() - padding * 2) * .5)
    self.lblName:Font('Comfortaa Bold@18')

    self.lblSteamID = self.header:Add('onyx.Label')
    self.lblSteamID:Dock(FILL)
    self.lblSteamID:SetText('UNKNOWN')
    self.lblSteamID:Font('Comfortaa@16')
    self.lblSteamID:SetTextColor(colorGray)

    self.inventory = self.list:Add('onyx.creditstore.Inventory')
    self.inventory:Dock(FILL)
    self.inventory.DoSlotClick = function(_, panel, it)
        if (not self.canTakeItems) then
            return
        end

        local menu = vgui.Create('onyx.Menu')
        menu:ToCursor()

        local submenu, option = menu:AddSubMenu(onyx.lang:Get('delete'))
        option:SetIconURL('https://i.imgur.com/CZH6F2I.png')

        local function delete(amt)
            local multiple = amt > 1
            net.Start('onyx.creditstore:AdminTakeItem')
                net.WriteString(self.steamid64)
                net.WriteBool(multiple)
                if (multiple) then
                    net.WriteUInt(amt, 8)
                    net.WriteString(panel.itemTable.id)
                else
                    net.WriteUInt(it.index, 16)
                end
            net.SendToServer()
        end

        submenu:AddOption(onyx.lang:Get('single') .. ' (1)', function()
            delete(1)
        end)

        local amount = panel.amount
        if (amount > 1) then
            local half = math.floor(amount * .5)
            submenu:AddOption(onyx.lang:Get('half') .. ' (' .. half .. ')', function()
                delete(half)
            end)
            
            submenu:AddOption(onyx.lang:Get('all') .. ' (' .. amount .. ')', function()
                delete(amount)
            end)
        end

        menu:Open()
    end

    local money = self.header:Add('onyx.Label')
    money:Font('Comfortaa Bold@20')
    money:SetTextColor(color_white)
    money:Dock(RIGHT)
    money:SetZPos(-1)
    money:SetContentAlignment(4)
    money:SetMouseInputEnabled(true)
    money.Paint = function(p, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorPrimary, nil, true, nil, true)
    end
    self.money = money

    local icon = self.header:Add('onyx.Image')
    icon:Dock(RIGHT)
    icon:SetZPos(-1)
    icon:SetImageWide(onyx.ScaleTall(16))
    icon:SetImageTall(icon:GetImageWide())
    icon:SetWide(self.inventory.toolbar:GetTall() - padding * 2)
    icon:DockMargin(0, 0, 0, 0)
    icon:SetColor(colorAccent)
    icon:DockMargin(onyx.ScaleWide(5), 0, 0, 0)
    icon.m_WebImage = wimgCoin
    icon.PaintBackground = function(p, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorPrimary, true, nil, true)
    end

    self.btnCreate = self.inventory.toolbar:Add('onyx.Button')
    self.btnCreate:Dock(RIGHT)
    self.btnCreate:SetText(onyx.lang:Get('giveItem'))
    self.btnCreate:SizeToContentsX(onyx.ScaleWide(20))
    self.btnCreate:SetFont(onyx.Font('Comfortaa@16'))
    self.btnCreate:SetVisible(false)
    self.btnCreate.DoClick = function()
        self:StartItemGive()
    end

    CAMI.PlayerHasAccess(LocalPlayer(), 'onyx_creditstore_give_items', function(bAllowed)
        if (IsValid(self.btnCreate)) then
            self.btnCreate:SetVisible(bAllowed)
        end
    end)

    CAMI.PlayerHasAccess(LocalPlayer(), 'onyx_creditstore_take_items', function(bAllowed)
        if (IsValid(self)) then
            self.canTakeItems = bAllowed
        end
    end)
end

function PANEL:Request(steamid64)
    self.avatar:SetSteamID(steamid64, 64)
    self.lblSteamID:SetText(util.SteamIDFrom64(steamid64))
    self.steamid64 = steamid64

    steamworks.RequestPlayerInfo(steamid64, function(steamName)
        self.lblName:SetText(steamName)
    end)

    onyx.AdminPlayerInventoryPanel = self

    net.Start('onyx.creditstore:AdminRequestInventory')
        net.WriteString(steamid64)
    net.SendToServer()
end

function PANEL:StartItemGive()
    local margin = onyx.ScaleTall(10)
    local frame = vgui.Create('onyx.Frame')
    frame:SetSize(ScrW() * .25, ScrH() * .5)
    frame:Center()
    frame:MakePopup()
    frame:Focus()
    frame:SetTitle('CHOOSE ITEM')

    local content = frame:Add('Panel')
    content:Dock(FILL)
    content:DockMargin(margin, margin, margin, margin)

    local toolbar = content:Add('Panel')
    toolbar:Dock(TOP)
    toolbar:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    toolbar:SetTall(onyx.ScaleTall(30))
    -- toolbar.Paint = function(p, w, h)
    --     draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    -- end

    local plist
    local psearch = toolbar:Add('onyx.TextEntry')
    psearch:SetPlaceholderText(onyx.lang:Get('searchName'))
    psearch:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    psearch:Dock(FILL)
    psearch:SetWide(onyx.ScaleWide(150))
    psearch:SetUpdateOnType(true)
    psearch.OnValueChange = function(panel, value)
        value = onyx.utf8.lower(value)

        for _, item in ipairs(plist:GetItems()) do
            if (onyx.utf8.lower(item.itemName):find(value, nil, true)) then
                item:SetVisible(true)
            else
                item:SetVisible(false)
            end
        end

        plist:InvalidateLayout(true)
    end

    plist = content:Add('onyx.ScrollPanel')
    plist:Dock(FILL)

    local sorted = {}
    for itemID, itemTable in pairs(onyx.creditstore.items) do
        table.insert(sorted, itemTable)
    end
    
    table.sort(sorted, function(a, b)
        if (a.type == b.type) then
            return a.name < b.name
        end

        return a.type < b.type
    end)

    for _, itemTable in ipairs(sorted) do
        local itemID = itemTable.id
        local itemTypeData = onyx.creditstore.types[itemTable.type]
        if (not itemTypeData) then continue end

        local itemTypeName = onyx.lang:Get(itemTypeData.name)
        local itemTypeColor = itemTypeData.color
        local model = itemTable.model
        local icon = itemTable.icon
        local padding = onyx.ScaleTall(5)

        local row = plist:Add('onyx.Button')
        row:SetTall(onyx.ScaleTall(50))
        row:Dock(TOP)
        row:SetColorIdle(colorSecondary)
        row:SetColorHover(colorTertiary)
        row:SetText('')
        row:InjectEventHandler('Paint')
        row:Padding(padding)
        row:AddClickEffect()
        row:AddHoverSound()
        row:On('Paint', function(panel, w, h)
            draw.SimpleText(itemTable.name, font1, h + onyx.ScaleWide(5), h * .5, color_white, 0, 4)
            draw.SimpleText(itemTypeName, font2, h + onyx.ScaleWide(5), h * .5, itemTypeColor, 0, 0)
        end)
        row.DoClick = function()
            net.Start('onyx.creditstore:AdminGiveItem')
                net.WriteString(self.steamid64)
                net.WriteString(itemID)
            net.SendToServer()

            frame:Remove()
        end

        local slot = row:Add('Panel')
        slot:Dock(LEFT)
        slot:SetWide(row:GetTall() - padding * 2)
        slot.Paint = function(p, w, h)
            draw.RoundedBox(8, 0, 0, w, h, colorPrimary)

            if (p.icon) then
                local sz = math.ceil(h * .66)
                p.icon:Draw(w * .5 - sz * .5, h * .5 - sz * .5, sz, sz)
            end
        end

        row.itemName = itemTable.name

        if (icon) then
            slot.icon = onyx.wimg.Simple(icon, '')
        elseif (model) then
            row.dmodel = slot:Add('DModelPanel')
            row.dmodel:Dock(FILL)
            row.dmodel:SetMouseInputEnabled(false)
            row.dmodel:SetModel(model)

            local ent = row.dmodel.Entity
            if (IsValid(ent)) then
                local min, max = ent:GetRenderBounds()
                local center = (min + max) * 0.5
                local distance = 0

                for _, key in ipairs({"x", "y", "z"}) do
                    distance = math.max(distance, max[key])
                end

                row.dmodel:SetLookAt(center)
                row.dmodel:SetFOV(distance + 5)
                row.dmodel.LayoutEntity = function() end
            end
        end
    end
end

function PANEL:LoadBalance(balance)
    self.money:SetText(onyx.creditstore.FormatMoney(balance))
    self.money:SizeToContentsX(onyx.ScaleWide(10))
end

onyx.gui.Register('onyx.creditstore.AdminPlayerInventory', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .5, .75, function(self)
--     self:MakePopup()

--     local content = self:Add('onyx.creditstore.AdminPlayerInventory')
--     content:Dock(FILL)
--     content:Request('76561198086200873')
-- end)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/cfg/cl_tabs.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

onyx.f4.tabs = {}

onyx.f4:RegisterTab('dashboard', {
    order = 1,
    name = 'f4_dashboard_u',
    desc = 'f4_dashboard_desc',
    icon = 'https://i.imgur.com/L6Dbwjm.png',
    class = 'onyx.f4.Dashboard'
})

onyx.f4:RegisterTab('jobs', {
    order = 2,
    name = 'f4_jobs_u',
    desc = 'f4_jobs_desc',
    icon = 'https://i.imgur.com/B5jmfXa.png',
    class = 'onyx.f4.Jobs'
})

onyx.f4:RegisterTab('shop', {
    order = 3,
    name = 'f4_shop_u',
    desc = 'f4_shop_desc',
    icon = 'https://i.imgur.com/duyBVAS.png',
    class = 'onyx.f4.Shop'
})

onyx.f4:RegisterTab('other', {
    order = 4,
    name = 'f4_other_u',
    desc = 'f4_other_desc',
    icon = 'https://i.imgur.com/ECLKU9s.png',
    class = 'onyx.f4.Other'
})

local col1 = Color(138, 43, 226)
onyx.f4:RegisterTab('case', {
    order = 5,
    name = 'f4_case_u',
    desc = 'f4_case_desc',
    icon = 'https://i.imgur.com/Nbiwnmd.png',
    nameColor = col1,
    descColor = col1,
    iconColor = col1,
    onClick = function()
        RunConsoleCommand('unboxing2_open')
        onyx.f4.frame:Close()
    end
})

local col2 = Color(183, 50, 183)
onyx.f4:RegisterTab('contracts', {
    order = 6,
    name = 'f4_contracts_u',
    desc = 'f4_contracts_desc',
    icon = 'https://i.imgur.com/RLApU0h.png',
    nameColor = col2,
    descColor = col2,
    iconColor = col2,
    onClick = function()
        RunConsoleCommand('TESTCONTRUCT')
        onyx.f4.frame:Close()
    end
})

local col3 = Color(255, 15, 163)
onyx.f4:RegisterTab('battlepass', {
    order = 7,
    name = 'f4_battlepass_u',
    desc = 'f4_battlepass_desc',
    icon = 'https://i.imgur.com/zXeY9XX.png',
    nameColor = col3,
    descColor = col3,
    iconColor = col3,
    onClick = function()
        RunConsoleCommand('battlepass')
        onyx.f4.frame:Close()
    end
})

local col4 = Color(22, 134, 0)
onyx.f4:RegisterTab('clan', {
    order = 7,
    name = 'f4_clan_u',
    desc = 'f4_clan_desc',
    icon = 'https://i.imgur.com/672bM8d.png',
    nameColor = col4,
    descColor = col4,
    iconColor = col4,
    onClick = function()
        RunConsoleCommand('gang')
        onyx.f4.frame:Close()
    end
})
--PATH addons/____onyx_hud/lua/onyx/modules/hud/core/cl_core.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

onyx.hud.elements = onyx.hud.elements or {}
onyx.hud.sortedElements = onyx.hud.sortedElements or {}

local CONVAR_ROUNDNESS = CreateClientConVar( 'cl_onyx_hud_roundness', '8', true, false, '', 0, 16 )
local CONVAR_PADDING = CreateClientConVar( 'cl_onyx_hud_screen_padding', '30', true, false, '', 5, 40 )

RunConsoleCommand( 'mp_show_voice_icons', '0' )

local function updateSortedElements()
    onyx.hud.sortedElements = {}

    for id, element in pairs( onyx.hud.elements ) do
        table.insert( onyx.hud.sortedElements, element )        
    end

    table.sort( onyx.hud.sortedElements, function( a, b )
        return a.priority < b.priority -- reverse
    end )
end

do
    local cachedPadding = CONVAR_PADDING:GetInt()
    
    cvars.AddChangeCallback( 'cl_onyx_hud_screen_padding', function( _, _, new )
        cachedPadding = tonumber( new ) or CONVAR_PADDING:GetDefault()
    end, 'onyx.hud.internal' )

    function onyx.hud.GetScreenPadding()
        return onyx.ScaleTall( cachedPadding )
    end
end

do
    local parseRoundness = function( value ) return ( math.floor( value / 4 ) * 4 ) end
    local cachedRoundness = parseRoundness( CONVAR_ROUNDNESS:GetInt() )
    
    cvars.AddChangeCallback( 'cl_onyx_hud_roundness', function( _, _, new )
        cachedRoundness = parseRoundness( tonumber( new ) or CONVAR_ROUNDNESS:GetDefault() )
    end, 'onyx.hud.internal' )

    function onyx.hud.GetRoundness()
        return cachedRoundness
    end
end

function onyx.hud.IsElementEnabled( id )
    local optionID = 'hud_display_' .. id
    local optionTable = onyx.inconfig.options[ optionID ]

    if ( optionTable ) then
        return onyx.hud:GetOptionValue( 'display_' .. id )
    end

    return true
end

function onyx.hud.UpdateModelIcon( modelIcon, modelData )
    local is2D = modelIcon.ClassName == 'SpawnIcon'
    local model = modelData.model
    local skin = modelData.skin
    local bodygroups = modelData.bodygroups
    
    if ( is2D ) then
        -- This one is always rebuilding spawnicons...
        -- local bodygroupsStr = ''
        -- for index = 1, 9 do
        --     local id = index - 1
        --     local value = bodygroups[ id ] or 0            

        --     bodygroupsStr = bodygroupsStr .. tostring( value )
        -- end
        
        -- modelIcon:SetModel( model, skin, bodygroupsStr )

        if ( modelIcon:GetModelName() ~= model ) then
            modelIcon:SetModel( model )
        end
    else
        if ( modelIcon:GetModel() ~= model ) then
            modelIcon:SetModel( model ) 
        end

        local ent = modelIcon.Entity
        if ( IsValid( ent ) ) then
            ent:SetSkin( skin )

            for id, value in pairs( bodygroups ) do
                ent:SetBodygroup( id, value )
            end
        end
    end
end

function onyx.hud.GetModelData( ent )
    local bodygroups = {}
    for _, bodygroup in ipairs( ent:GetBodyGroups() ) do
        local id = bodygroup.id
        local value = ent:GetBodygroup( bodygroup.id )
    
        bodygroups[ id ] = value
    end
    
    return {
        model = ent:GetModel(),
        skin = ent:GetSkin(),
        bodygroups = bodygroups
    }
end

function onyx.hud.CompareModelData( modelData1, modelData2 )
    for key, value in pairs( modelData1 ) do
        local otherValue = modelData2[ key ]

        if ( istable( value ) ) then
            for key2, value2 in pairs( value ) do
                local otherValue2 = otherValue[ key2 ]
                if ( not otherValue2 or otherValue2 ~= value2 ) then
                    return false
                end
            end
        else
            if ( value ~= otherValue ) then
                return false
            end
        end
    end

    return true
end

do
    local COLOR_RED = Color( 255, 52, 52)
    local COLOR_BLUE = Color( 55, 52, 255)
    function onyx.hud.GetAnimColor( id )
        if ( id == 0 ) then
            return onyx.LerpColor( math.abs( math.sin( CurTime() ) ), COLOR_RED, COLOR_BLUE )
        end
    end
end

function onyx.hud.OverrideGamemode( id, fn )
    if ( GM or GAMEMODE ) then
        fn()
    end

    -- it's a bit harder to override darkrp func
    -- lol I've had super weird bug on my laptop, that not all InitPostEntity hooks were initiated (without any errors) so I've found this solution
    hook.Add( 'Think', id, function()
        hook.Remove( 'Think', id )
        timer.Create( id, engine.TickInterval(), 1, function()
            fn()
        end )
    end )
end

function onyx.hud.GetMaxProps( client )
    -- SAM / Other admin mod support, however source is unknown so we should avoid errors and stuff :\
    if ( client.GetLimit ) then
        local success, value = pcall( client.GetLimit, client, 'props' )
        if ( success and isnumber( value ) ) then
            return value
        end
    end

    return GetConVar( 'sbox_maxprops' ):GetInt()
end

do
    -- Because draw.SimpleText and other functions have surface.GetTextSize & we do not need it.
    local SetTextColor = surface.SetTextColor
    local SetTextPos = surface.SetTextPos
    local SetFont = surface.SetFont
    local DrawText = surface.DrawText
    function onyx.hud.DrawCheapText( text, font, x, y, color )
        local color = color or color_white

        SetTextColor( color.r, color.g, color.b, color.a )
        SetTextPos( x, y )
        SetFont( font )
        DrawText( text )
    end
end

do
    -- Micro-optimization since we are drawing it a lot of times
    local Clamp = math.Clamp
    local SetDrawColor = surface.SetDrawColor
    local DrawRect = surface.DrawRect
    local RoundedBoxEx = draw.RoundedBoxEx
    local GetRoundness = onyx.hud.GetRoundness
    function onyx.hud.DrawRoundedBoxEx( x, y, w, h, color, co1, co2, co3, co4 )
        local roundness = Clamp( GetRoundness(), 0, h * .5 )
        if ( roundness == 0 ) then
            SetDrawColor( color )
            DrawRect( x, y, w, h )
        else
            RoundedBoxEx( roundness, x, y, w, h, color, co1, co2, co3, co4 )
        end
    end
end

do
    local GetAlphaMultiplier = surface.GetAlphaMultiplier
    local SetAlphaMultiplier = surface.SetAlphaMultiplier
    function onyx.hud.OverrideAlpha( alpha, callback )
        local prev = GetAlphaMultiplier()

        SetAlphaMultiplier( math.min( alpha, prev ) )
            callback()
        SetAlphaMultiplier( prev )
    end
end

do
    local SetScissorRect = render.SetScissorRect
    function onyx.hud.ScissorRect( x, y, w, h, callback )
        SetScissorRect( x, y, x + w, y + h, true )
            callback()
        SetScissorRect( 0, 0, 0, 0, false )
    end
end

function onyx.hud.DrawRoundedBox( x, y, w, h, color )
    onyx.hud.DrawRoundedBoxEx( x, y, w, h, color, true, true, true, true )
end

do
    function onyx.hud.DrawShadowText( text, font, x, y, color, ax, ay )
        local textW, textH
    
        -- Calculate & return size only if required
        if ( ax or ay ) then
            surface.SetFont( font )
            textW, textH = surface.GetTextSize( text )
        
            if ( ax == 1 ) then
                x = x - textW * .5
            end
        
            if ( ay == 1 ) then
                y = y - textH * .5
            end
        end
        
        onyx.hud.DrawCheapText( text, font .. '.Blur', x + 2, y + 2, color_black, ax, ay )
        onyx.hud.DrawCheapText( text, font, x, y, color, ax, ay )
    
        return textW, textH
    end
end

do
    function onyx.hud.DrawShadowText2D( text, font, x, y, color, ax, ay )
        local textW, textH
    
        -- Calculate & return size only if required
        if ( ax or ay ) then
            surface.SetFont( font )
            textW, textH = surface.GetTextSize( text )
        
            if ( ax == 1 ) then
                x = x - textW * .5
            end
        
            if ( ay == 1 ) then
                y = y - textH * .5
            end
        end
        
        onyx.hud.DrawCheapText( text, font, x + 1, y + 1, color_black, ax, ay )
        onyx.hud.DrawCheapText( text, font, x, y, color, ax, ay )
    
        return textW, textH
    end
end

do
    local ELEMENT_MT = {}
    ELEMENT_MT.__index = ELEMENT_MT

    AccessorFunc( ELEMENT_MT, 'm_bInitiliazed', 'Initialized' )

    function ELEMENT_MT:GetID()
        return tostring( self.id )
    end

    function ELEMENT_MT:IsEnabled()
        return onyx.hud.IsElementEnabled( self:GetID() )
    end

    function ELEMENT_MT:Draw( client, scrW, scrH )
        local drawFn = self.drawFn
        assert( drawFn, '\'' .. self:GetID() .. '\' missing draw function' )
        
        drawFn( self, client, scrW, scrH )
    end

    function onyx.hud:RegisterElement( id, data )
        onyx.AssertType( id, 'string', 'RegisterElement', 1 )
        onyx.AssertType( data, 'table', 'RegisterElement', 2 )
    
        data.id = id
        data.priority = data.priority or 50

        self.elements[ id ] = setmetatable( data, ELEMENT_MT )

        updateSortedElements()

        return self.elements[ id ]
    end
end

hook.Add( 'HUDPaint', 'onyx.hud.Paint', function()
    local client = LocalPlayer()
    local scrW, scrH = ScrW(), ScrH()

    if ( IsValid( client ) ) then
        if ( not onyx.hud.builtFonts ) then
            onyx.hud.BuildFonts()
        end

        for _, element in ipairs( onyx.hud.sortedElements ) do
            local id = element.id

            if ( not element:GetInitialized() ) then
                element:SetInitialized( true )
                if ( element.initFunc ) then
                    element:initFunc( client )
                end
            end
            
            if ( element:IsEnabled() ) then
                onyx.hud.StartScaling( id )
                    ProtectedCall( element.Draw, element, client, scrW, scrH ) -- it won't break the whole cycle
                onyx.hud.EndScaling()
            end
        end
    end
end )

do
    local HIDE = {
        [ 'DarkRP_HUD' ] = true,
        [ 'DarkRP_LocalPlayerHUD' ] = true,
        [ 'DarkRP_EntityDisplay' ] = true,
        [ 'DarkRP_Hungermod' ] = true,
        [ 'CHudHealth' ] = true,
        [ 'CHudBattery' ] = true,
        [ 'CHudDamageIndicator' ] = true,
        [ 'CHUDQuickInfo' ] = true,
        [ 'CHudSuitPower' ] = true,
        [ 'CHudPoisonDamageIndicator' ] = true
    }

    hook.Add( 'HUDShouldDraw', 'onyx.hud.Hide', function( name )
        if ( HIDE[ name ] ) then
            return false
        else
            for id, element in pairs( onyx.hud.elements ) do
                if ( element.hideElements and element.hideElements[ name ] ) then
                    return false
                end
            end
        end
    end )

    hook.Add( 'HUDDrawTargetID', 'onyx.hud.Hide', function()
        return false
    end )

    hook.Add( 'DrawDeathNotice', 'onyx.hud.Hide', function()
        return false
    end )
end
--PATH addons/____onyx_hud/lua/onyx/modules/hud/cfg/cl_themes.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

21/08/2024

--]]

--[[
    ***************
      WARNING
      This configuration is intended for advanced users familiar with Lua scripting. 
      Modifying this file without proper knowledge may result in unintended behavior or instability.
    ***************
]]

onyx.hud:CreateTheme( 'default', {
    colors = {
        primary = onyx:Config( 'colors.primary' ),
        secondary = onyx:Config( 'colors.secondary' ),
        tertiary = onyx:Config( 'colors.tertiary' ),
        accent = onyx:Config( 'colors.accent' ),
    }
} )

onyx.hud:CreateTheme( 'gray', {
    colors = {
        primary = Color( 172, 172, 172),
        secondary = Color( 197, 197, 197),
        tertiary = Color( 225, 225, 225),
        accent = Color( 101, 40, 206),
    }
} )

onyx.hud:CreateTheme( 'golden_dawn', {
    colors = {
        primary = Color( 195, 189, 154),
        secondary = Color( 224, 207, 143),
        tertiary = Color( 230, 205, 129),
        accent = Color( 44, 44, 255),
        textPrimary = Color( 40, 35, 19),
        textSecondary = Color( 59, 50, 14),
        textTertiary = Color( 90, 83, 53),
    }
} )

onyx.hud:CreateTheme( 'sky_blue', {
    colors = {
        primary = Color(186, 227, 252),
        secondary = Color(210, 235, 255),
        tertiary = Color(232, 243, 255),
        accent = Color(0, 89, 255),
        textPrimary = Color(25, 45, 60),
        textSecondary = Color(50, 75, 100),
        textTertiary = Color(80, 110, 140),
    }
} )

onyx.hud:CreateTheme( 'mint_light', {
    colors = {
        primary = Color(202, 230, 217),
        secondary = Color(223, 241, 232),
        tertiary = Color(240, 250, 244),
        accent = Color(0, 162, 78),
        textPrimary = Color(34, 52, 42),
        textSecondary = Color(57, 82, 69),
        textTertiary = Color(92, 118, 104),
    }
} )

onyx.hud:CreateTheme( 'lavender', {
    colors = {
        primary = Color(230, 230, 250),
        secondary = Color(245, 245, 255),
        tertiary = Color(255, 250, 255),
        accent = Color(138, 43, 226),
        textPrimary = Color(50, 50, 80),
        textSecondary = Color(70, 70, 100),
        textTertiary = Color(100, 100, 130),
    }
} )

onyx.hud:CreateTheme( 'green_apple', {
    colors = {
        primary = Color(144, 238, 144),
        secondary = Color(168, 255, 168),
        tertiary = Color(192, 255, 192),
        accent = Color(218, 24, 24),  -- Насыщенный зеленый
        textPrimary = Color(40, 70, 40),
        textSecondary = Color(60, 90, 60),
        textTertiary = Color(90, 120, 90),
    }
} )

onyx.hud:CreateTheme( 'elegance', {
    colors = {
        primary = Color(34, 40, 48),
        secondary = Color(32, 36, 42),
        tertiary = Color(40, 45, 53),
        accent = Color(60, 179, 113),
    }
} )

onyx.hud:CreateTheme( 'ocean_wave', {
    colors = {
        primary = Color(24, 32, 44),
        secondary = Color(30, 40, 52),
        tertiary = Color(37, 50, 61),
        quaternary = Color(24, 32, 44),
        accent = Color(70, 130, 180),
    }
} )

onyx.hud:CreateTheme( 'violet_night', {
    colors = {
        primary = Color(48, 25, 52),
        secondary = Color(58, 31, 63),
        tertiary = Color(72, 40, 78),
        quaternary = Color(48, 25, 52),
        accent = Color(186, 85, 211),
    }
} )

onyx.hud:CreateTheme( 'forest', {
    colors = {
        primary = Color(34, 44, 34),
        secondary = Color(42, 54, 42),
        tertiary = Color(50, 64, 50),
        quaternary = Color(34, 44, 34),
        accent = Color(152, 251, 152),
    }
} )

onyx.hud:CreateTheme( 'rose_garden', {
    colors = {
        primary = Color(44, 24, 34),
        secondary = Color(52, 28, 42),
        tertiary = Color(61, 33, 50),
        quaternary = Color(44, 24, 34),
        accent = Color(255, 105, 180),
    }
} )

onyx.hud:CreateTheme( 'rustic_ember', {
    colors = {
        primary = Color(44, 29, 24),
        secondary = Color(52, 34, 29),
        tertiary = Color(61, 40, 34),
        quaternary = Color(44, 29, 24),
        accent = Color(255, 99, 71),
    }
} )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_main.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

local hud = onyx.hud
local COLOR_BAR = Color( 200, 200, 200, 10 )
local COLOR_GRAY = Color( 183, 183, 183)
local COLOR_XP = Color( 202, 183, 14)

local WIMG_HEART = onyx.wimg.Create( 'hud_heart', 'smooth mips' )
local WIMG_SHIELD = onyx.wimg.Create( 'hud_shield', 'smooth mips' )
local WIMG_FOOD = onyx.wimg.Create( 'hud_food', 'smooth mips' )
local WIMG_LICENSE = onyx.wimg.Create( 'hud_license', 'smooth mips' )
local WIMG_STAR = onyx.wimg.Create( 'hud_wanted', 'smooth mips' )
local WIMG_MICROPHONE = onyx.wimg.Create( 'hud_microphone', 'smooth mips' )
local CONVAR_COMPACT = CreateClientConVar( 'cl_onyx_hud_compact', '0', true, false, '', 0, 1 )
local CONVAR_3D = CreateClientConVar( 'cl_onyx_hud_3d_models', '0', true, false, '', 0, 1 )
local CONVAR_HELP = CreateClientConVar( 'cl_onyx_hud_show_help', '1', true, false, '', 0, 1 )

-- They are scaled after
local UNSCALED_BAR_H = 6
local UNSCALED_BAR_ICON_SIZE = 12
local UNSCALED_ICON_SIZE = 18
local UNSCALED_SPACE = 5

local slowLabels = {}
local lastMaskY
local lerpHealth, lerpArmor, lerpHunger
local lerpMoney

local function formatSalary( salary )
    -- local iters = ( 3600 / GAMEMODE.Config.paydelay )
    -- local full = math.Round( salary * iters )
    -- local formatted = '+' .. DarkRP.formatMoney( full ) .. '/h'
    return '+ ' .. rp.FormatMoney( salary )
end

local function drawIndicator( x, y, w, h, material, color, fraction, value )
    local iconSize = h
    local iconSpace = hud.ScaleTall( UNSCALED_SPACE )

    local theme = hud:GetCurrentTheme()
    local isDark = theme.isDark
    local colors = theme.colors
    local colorTextPrimary = colors.textPrimary
    local colorTextSecondary = colors.textSecondary

    local contentW = w - ( iconSize + iconSpace )
    local rectX, rectW = x + ( iconSize + iconSpace ), contentW
    local rectH = math.min( h, hud.ScaleTall( UNSCALED_BAR_H ) )
    local rectY = math.floor( y + iconSize * .5 - rectH * .5 )
    
    local showNumbers = hud:GetOptionValue( 'hud_bar_type' ) or 0
    local valueText, valueWidth

    if ( showNumbers > 0 ) then
        valueText = math.Round( value ) .. ''

        surface.SetFont( hud.fonts.SmallBold )
        valueWidth = surface.GetTextSize( valueText )
        
        rectW = rectW - valueWidth - iconSpace * 2
    end

    material:Draw( x, y, iconSize, iconSize, color )
    
    hud.DrawRoundedBox( rectX, rectY, rectW, rectH, ColorAlpha( colorTextPrimary, isDark and 10 or 200 ) )

    render.SetScissorRect( rectX, rectY, rectX + rectW * fraction, rectY + rectH, true )
        hud.DrawRoundedBox( rectX, rectY, rectW, rectH, color )
    render.SetScissorRect( 0, 0, 0, 0, false )

    if ( showNumbers > 0 ) then
        draw.SimpleText( valueText, hud.fonts.SmallBold, rectX + contentW, y + h * .5, ( showNumbers == 2 and color or colorTextPrimary ), 2, 1 )
    end
end

local function drawStatusIcon( x, y, w, h, material, color )
    material:Draw( x, y, w, h, color or hud:GetColor( 'textTertiary' ) )
end

local function recreateAvatar( self )
    local bUse3DModel = CONVAR_3D:GetBool()
    local bUseModel = hud:GetOptionValue( 'main_avatar_mode' ) == 1
    local client = LocalPlayer()

    if ( IsValid( self.AvatarPanel ) ) then
        self.AvatarPanel:Remove()
    end

    if ( bUseModel ) then
        if ( bUse3DModel ) then
            self.AvatarPanel = vgui.Create( 'DModelPanel' )
            self.AvatarPanel.LayoutEntity = function() end
            self.AvatarPanel.PostUpdateLook = function( panel, model )
                local ent = panel.Entity
    
                if ( IsValid( ent ) ) then
                    local boneID = ent:LookupBone( 'ValveBiped.Bip01_Head1' )
                    if ( boneID ) then       
                        local bonePos = ent:GetBonePosition( boneID )
                        if ( bonePos ) then
                            bonePos:Add( Vector( 0, 0, 2 ) )
                    
                            panel:SetLookAt (bonePos)
                            panel:SetCamPos( bonePos - Vector(-20, 0, 0) )
                            panel:SetFOV( 45 )
                    
                            ent:SetEyeTarget( bonePos - Vector(-20, 0, 0) )
                        end
                    end
                end
            end
        else
            self.AvatarPanel = vgui.Create( 'SpawnIcon' )
        end

        self.AvatarPanel.UpdateLook = function( panel, modelData )
            panel.modelData = modelData

            hud.UpdateModelIcon( panel, modelData )

            if ( panel.PostUpdateLook ) then
                panel:PostUpdateLook()
            end
        end

        local nextComparison = 0
        self.AvatarPanel.Think = function( panel )
            if ( nextComparison <= CurTime() ) then
                nextComparison = CurTime() + 1
            
                local actualData = hud.GetModelData( LocalPlayer() )
                local currentData = panel.modelData
    
                if ( not currentData or not hud.CompareModelData( currentData, actualData ) ) then
                    panel:UpdateLook( actualData )
                end
            end
        end
    else
        self.AvatarPanel = vgui.Create( 'AvatarImage' )
        self.AvatarPanel:SetPlayer( client, 128 )
    end

    self.AvatarPanel:SetPaintedManually( true )
    self.AvatarPanel:ParentToHUD()
end

local updateSlowLabels do
    local nextUpdate = 0
    local thinkRate = 1 / 10

    local function findBestFont( text, maxWidth, ... )
        local bestFont = select( 1, ... )
        assert( bestFont, 'no fonts given' )

        local lastWidth = math.huge
        for _, font in ipairs( { ... } ) do
            local width = onyx.GetTextSize( text, font )
            local isGood = width <= maxWidth

            if ( isGood or width < lastWidth ) then
                bestFont = font
                lastWidth = width

                if ( isGood ) then
                    break
                end
            end
        end

        return bestFont
    end

    function updateSlowLabels( client, maxWidth )
        if ( nextUpdate <= CurTime() ) then
            nextUpdate = CurTime() + thinkRate
            slowLabels = {}

            local name = client:Name()
            local job = ( client:GetJob() or team.GetName( client:Team() ) )

            slowLabels.name = {
                text = name,
                font = findBestFont( name, maxWidth, hud.fonts.Name, hud.fonts.SmallBold, hud.fonts.TinyBold, hud.fonts.ExtraTinyBold )
            }

            slowLabels.job = {
                text = job,
                font = findBestFont( job, maxWidth, hud.fonts.Small, hud.fonts.Tiny )
            }
        end
    end
end

local function drawMainHUD( self, client, scrW, scrH )
    local showJob = not CONVAR_COMPACT:GetBool()
    local space = hud.GetScreenPadding()
    local padding = hud.ScaleTall( 10 )
    local w, h = hud.ScaleWide( 300 ), hud.ScaleTall( showJob and 120 or 100 )
    local x, y = space, scrH - h - space

    -- Colors
    local theme = hud:GetCurrentTheme()
    local colors = theme.colors

    local colorPrimary = colors.primary
    local colorSecondary = colors.secondary
    local colorTertiary = colors.tertiary
    local colorTextPrimary = colors.textPrimary
    local colorTextSecondary = colors.textSecondary
    local isDark = theme.isDark

    -- Player variables
    local animSpeed = FrameTime() * 16

    local healthValue = client:Health()
    local armorValue = client:Armor()

    local healthFraction = math.Clamp( healthValue / client:GetMaxHealth(), 0, 1 )
    local armorFraction = math.Clamp( armorValue / client:GetMaxArmor(), 0, 1 )
    local money = client:GetMoney() or 0

    lerpHealth = Lerp( animSpeed, lerpHealth or healthFraction, healthFraction )
    lerpArmor = Lerp( animSpeed, lerpArmor or armorFraction, armorFraction )
    lerpMoney = Lerp( animSpeed, lerpMoney or money, money )

    local name = client:Name()
    local teamColor = client:GetJobColor()
    if ply:onyx_GetNetVar('Disguise_G') then
        teamColor = sam.player.get_nwvar(client, 'Job_Color') or color_white
    end
    local moneyFormatted = rp.FormatMoney( math.Round( lerpMoney ) )
    local salary = client:GetSalary() or 0
    local salaryFormatted = formatSalary( salary )
    local hasHunger = true
    local hasArmor = math.Round( lerpArmor, 2 ) > 0
    local rectAmount = ( hasHunger or hasArmor ) and 2 or 1
    local rectH = hud.ScaleTall( UNSCALED_BAR_ICON_SIZE )

    -- Increase HUD height if there is multiple bars
    if ( rectAmount > 1 ) then
        local extraHeight = hud.ScaleTall( 10 )
        h = h + extraHeight
        y = y - extraHeight
    end

    local avatarSpaceWidth = hud.ScaleWide( 80 )
    local labelX = x + avatarSpaceWidth + padding
    local labelY = y + padding

    -- Draw background
    hud.DrawRoundedBox( x, y, w, h, colorPrimary )
    hud.DrawRoundedBoxEx( x, y, avatarSpaceWidth, h, colorSecondary, true, false, true )

    -- Draw labels
    local labelMaxW = w - avatarSpaceWidth - padding * 2
    
    updateSlowLabels( client, labelMaxW )
    
    -- Limited render bounds for labels
    render.SetScissorRect( 0, 0, labelX + labelMaxW, ScrH(), true )

    local _, nameHeight = draw.SimpleText( slowLabels.name.text, slowLabels.name.font, labelX, labelY, colorTextPrimary, 0, 0 )

    local teamHeight
    if ( showJob ) then
        _, teamHeight = draw.SimpleText( slowLabels.job.text, slowLabels.job.font, labelX, labelY + nameHeight, teamColor, 0, 0 )
    else
        teamHeight = 0
    end

    local _, moneyHeight = draw.SimpleText( moneyFormatted, hud.fonts.Small, labelX, labelY + nameHeight + teamHeight, colorTextSecondary, 0, 0 )
    draw.SimpleText( salaryFormatted, hud.fonts.Small, x + w - padding, labelY + nameHeight + teamHeight, colorTextSecondary, 2, 0 )

    render.SetScissorRect( 0, 0, 0, 0, false )

    local contentH = nameHeight + teamHeight + moneyHeight
    local topPartH = contentH + padding * 2
    local lineY = labelY + contentH + padding
    local lineW = w - avatarSpaceWidth - padding * 2
    local lineH = math.max( 1, hud.ScaleTall( 2 ) )
    
    -- Prepare a mask for avatar
    local avatarY = y + padding
    local avatarSize = math.min( contentH, avatarSpaceWidth - padding * 2 )
    local circleRadius = math.Round( avatarSize * .5 )
    local circleOutlineThickness = hud.ScaleTall( 2.5 )

    local maskX0 = x + math.Round( avatarSpaceWidth * .5 )
    local maskY0 = avatarY + circleRadius
    local maskX, maskY = maskX0 - circleRadius, avatarY

    if ( not self.AvatarMask or not lastMaskY or lastMaskY ~= maskY0 ) then
        lastMaskY = maskY0
        self.AvatarMask = onyx.CalculateCircle( maskX0, maskY0, circleRadius, 32 )
    end

    -- Draw avatar
    if ( IsValid( self.AvatarPanel ) ) then
        onyx.DrawWithPolyMask( self.AvatarMask, function()
            if ( self.AvatarPanel:GetClassName() ~= 'AvatarImage' ) then
                -- Draw fancy background for model icons
                onyx.DrawCircle( maskX0, maskY0, circleRadius, colorPrimary )
                onyx.DrawMatGradient( maskX, maskY, avatarSize, avatarSize, BOTTOM, ColorAlpha( teamColor, isDark and 25 or 150 )  )
            end

            self.AvatarPanel:SetPos( maskX, maskY )
            self.AvatarPanel:SetSize( avatarSize, avatarSize )
            self.AvatarPanel:PaintManual()

            if ( client:IsSpeaking() ) then
                local micSize = avatarSize * .5

                micSize = micSize + ( micSize * .2 * math.abs( math.sin( CurTime() * 2 ) ) )

                surface.SetDrawColor( 0, 0, 0, 225 )
                surface.DrawRect( maskX, maskY, avatarSize, avatarSize )
                
                WIMG_MICROPHONE:DrawRotated( maskX0, maskY0, micSize, micSize, 0 )
            end
        end )

        onyx.DrawOutlinedCircle( maskX0, maskY0, circleRadius + circleOutlineThickness * .5, circleOutlineThickness, teamColor )
    end

    -- Draw separator
    if ( isDark ) then
        surface.SetDrawColor( 0, 0, 0, 50 )
    else
        surface.SetDrawColor( 100, 100, 100, 100 )
    end
    surface.DrawRect( x, lineY, w, lineH )

    local footerH = h - topPartH
    local footerY0 = lineY + footerH * .5

    -- Draw icons
    local iconSize = hud.ScaleTall( UNSCALED_ICON_SIZE )
    local iconSpace = hud.ScaleTall( UNSCALED_SPACE ) * .75
    local iconX0 = x + avatarSpaceWidth * .5
    local iconY0 = footerY0 - iconSize * .5
    
    drawStatusIcon( iconX0 - iconSize - iconSpace, iconY0, iconSize, iconSize, WIMG_LICENSE, client:HasLicense() and hud:GetColor( 'accent' )  )
    drawStatusIcon( iconX0 + iconSpace, iconY0, iconSize, iconSize, WIMG_STAR, client:IsWanted() and hud.GetAnimColor( 0 ) )

    -- Draw indicators
    local rectSpace = hud.ScaleTall( 3 )
    local totalIndictatorsH = rectAmount * rectH + ( rectAmount - 1 ) * rectSpace
    local rectY = footerY0 - totalIndictatorsH * .5
    
    drawIndicator( labelX, rectY, lineW, rectH, WIMG_HEART, Color( 197, 54, 54), lerpHealth, healthValue )

    rectY = rectY + rectH + rectSpace

    if ( hasHunger ) then
        local iconSpace = hud.ScaleTall( UNSCALED_SPACE * 1 )
        local halfLineWidth = lineW * .5 - iconSpace * .5
        local hungerValue = client:GetHunger()
        local hungerFraction = math.Clamp( hungerValue / 100, 0, 1 )

        lerpHunger = Lerp( animSpeed, lerpHunger or hungerFraction, hungerFraction )
        
        drawIndicator( labelX, rectY, halfLineWidth, rectH, WIMG_FOOD, Color( 197, 157, 54), lerpHunger, hungerValue )
        drawIndicator( labelX + halfLineWidth + iconSpace, rectY, halfLineWidth, rectH, WIMG_SHIELD, Color( 54, 102, 197), lerpArmor, armorValue )
    elseif ( hasArmor ) then
        drawIndicator( labelX, rectY, lineW, rectH, WIMG_SHIELD, Color( 54, 102, 197), lerpArmor, armorValue )
    end

    -- Draw help
    local addBlockSpace = hud.ScaleTall( 7.5 )

    if ( CONVAR_HELP:GetBool() ) then
        local addBlockH = hud.ScaleTall( 50 )
        local blockY = y - addBlockH - addBlockSpace
    
        hud.OverrideAlpha( 0.5 + 0.5 * math.abs( math.sin( CurTime() * 2 ) ), function()
            local helpFont = hud.fonts.Small
            local helpText1 = onyx.lang:Get( 'hud_help_type' ) .. ' '
            local helpText2 = '!hud'
            local helpText3 = ' ' .. onyx.lang:Get( 'hud_help_to' )
        
            surface.SetFont( helpFont )
            local helpTextW1 = surface.GetTextSize( helpText1 )
            local helpTextW3 = surface.GetTextSize( helpText3 )
            surface.SetFont( hud.fonts.SmallBold )
            local helpTextW2 = surface.GetTextSize( helpText2 )
            local helpTextTotalW = ( helpTextW1 + helpTextW2 + helpTextW3 )
            local helpTextX = x + w * .5 - helpTextTotalW * .5
            
            hud.DrawRoundedBox( x, blockY, w, addBlockH, colorPrimary )
    
            draw.SimpleText( onyx.lang:Get( 'introduction_u' ), hud.fonts.TinyBold, x + w * .5, blockY + addBlockH * .5, colorTextSecondary, 1, 4 )
    
            draw.SimpleText( helpText1, helpFont, helpTextX, blockY + addBlockH * .5, colorTextPrimary, 0, 0 )
            draw.SimpleText( helpText2, hud.fonts.SmallBold, helpTextX + helpTextW1, blockY + addBlockH * .5, colors.accent, 0, 0 )
            draw.SimpleText( helpText3, helpFont, helpTextX + helpTextW1 + helpTextW2, blockY + addBlockH * .5, colorTextPrimary, 0, 0 )
        end )
    elseif ( onyx.hud:GetOptionValue( 'display_level' ) and onyx.hud.IsLevellingEnabled() ) then
        local addBlockH = hud.ScaleTall( 47.5 )
        local blockY = y - addBlockH - addBlockSpace
        local level, xp, maxXP = onyx.hud.GetLevelData( client )
        local nextLevelFraction = xp / maxXP
        local rectH = math.min( h, hud.ScaleTall( UNSCALED_BAR_H ) )

        hud.DrawRoundedBox( x, blockY, w, addBlockH, colorPrimary )

        local textW = draw.SimpleText( onyx.lang:Get( 'hud.level.name' ) .. ': ', hud.fonts.Tiny, x + padding, blockY + padding, colorTextSecondary, 0, 0 )
        draw.SimpleText( level, hud.fonts.SmallBold, x + padding + textW, blockY + padding, ( isDark and COLOR_XP or colorTextPrimary ), 0, 0 )

        local textW2 = draw.SimpleText( ' / ' .. maxXP, hud.fonts.Tiny, x + w - padding, blockY + padding, colorTextSecondary, 2, 0 )
        draw.SimpleText( xp, hud.fonts.TinyBold, x + w - padding - textW2, blockY + padding, colorTextPrimary, 2, 0 )

        hud.DrawRoundedBox( x + padding, blockY + addBlockH - padding - rectH, w - padding * 2, rectH, ColorAlpha( colorTextPrimary, isDark and 10 or 200 ) )
        onyx.hud.ScissorRect( x + padding, blockY + addBlockH - padding - rectH, ( w - padding * 2 ) * nextLevelFraction, rectH, function()
            hud.DrawRoundedBox( x + padding, blockY + addBlockH - padding - rectH, w - padding * 2, rectH, COLOR_XP )
        end )
    end
end

cvars.AddChangeCallback( 'cl_onyx_hud_3d_models', function()
    recreateAvatar( hud.elements[ 'main' ] )
end, 'hud.internal' )

hook.Add( 'onyx.inconfig.Updated', 'hud.RecreateAvatar', function( id, old, new )
    if ( id and id == 'hud_main_avatar_mode' ) then
        recreateAvatar( hud.elements[ 'main' ] )
    end
end )

hook.Add( 'onyx.inconfig.Synchronized', 'hud.RecreateAvatar', function( id )
    recreateAvatar( hud.elements[ 'main' ] )
end )

hud:RegisterElement( 'main', {
    priority = 100,
    drawFn = drawMainHUD,
    initFunc = recreateAvatar,
    onSizeChanged = function( self )
        self.AvatarMask = nil -- It will force to recalculate the circle mask
    end
} )
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_german.lua:
--[[

Übersetzer: thestarhd
G-Profile: https://www.gmodstore.com/users/76561198801156110

12.03.2024 - German Translation

--]]

local LANG = {}

-- Phrasen
LANG['copied_clipboard'] = 'In die Zwischenablage kopiert'
LANG['scoreboard_search'] = 'Suchen... (Name/SteamID)'
LANG['you'] = 'Du'
LANG['friend'] = 'Freund'
LANG['addon_return_u'] = 'ZURÜCK'

-- Spalten
LANG['scoreboard_col_team'] = 'Team'
LANG['scoreboard_col_job'] = 'Job'
LANG['scoreboard_col_money'] = 'Geld'
LANG['scoreboard_col_rank'] = 'Rang'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Spielzeit'
LANG['scoreboard_col_health'] = 'Gesundheit'
LANG['scoreboard_col_level'] = 'Level'
LANG['scoreboard_col_none'] = 'Keiner'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Abzeichen'

-- Namen-Effekte
LANG['scoreboard_eff_default'] = 'Standard'
LANG['scoreboard_eff_glow'] = 'Leuchten'
LANG['scoreboard_eff_rainbow'] = 'Regenbogen'
LANG['scoreboard_eff_scanning_vertical'] = 'Scannen (Vertikal)'
LANG['scoreboard_eff_scanning_horizontal'] = 'Scannen (Horizontal)'
LANG['scoreboard_eff_gradient_invert'] = 'Gradient (Farben umkehren)'
LANG['scoreboard_eff_wavy_dual'] = 'Wellenförmig (Zweifarbig)'

-- Tasten
LANG['scoreboard_btn_profile'] = 'Profil öffnen'
LANG['scoreboard_btn_freeze'] = 'Einfrieren'
LANG['scoreboard_btn_goto'] = 'Gehen zu'
LANG['scoreboard_btn_bring'] = 'Bringen'
LANG['scoreboard_btn_return'] = 'Zurück'
LANG['scoreboard_btn_respawn'] = 'Wiederbeleben'
LANG['scoreboard_btn_slay'] = 'Töten'
LANG['scoreboard_btn_spectate'] = 'Zuschauen'

-- Wörter
LANG['rank_id'] = 'Rang-Identifikator'
LANG['name'] = 'Name'
LANG['effect'] = 'Effekt'
LANG['color'] = 'Farbe'
LANG['preview'] = 'Vorschau'
LANG['creation'] = 'Erstellung'
LANG['save'] = 'Speichern'
LANG['dead'] = 'Tot'
LANG['create_new'] = 'Neu erstellen'
LANG['column'] = 'Spalte'

-- Einstellungen
LANG['addon_settings_u'] = 'EINSTELLUNGEN'
LANG['scoreboard_ranks_u'] = 'RÄNGE'
LANG['scoreboard_columns_u'] = 'SPALTEN'

LANG['scoreboard.title.name'] = 'Titel'
LANG['scoreboard.title.desc'] = 'Gib den Titel für den Rahmen ein'

LANG['scoreboard.group_teams.name'] = 'Teamgruppen'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Gruppiere Teams nach Jobkategorien'

LANG['scoreboard.colored_players.name'] = 'Farbverlauf'
LANG['scoreboard.colored_players.desc'] = 'Zeige farbigen Verlauf auf Spielerzeile'

LANG['scoreboard.blur.name'] = 'Unschärfe-Design'
LANG['scoreboard.blur.desc'] = 'Aktiviere Unschärfe-Design'

LANG['scoreboard.scale.name'] = 'Rahmengröße skalieren'
LANG['scoreboard.scale.desc'] = 'Skaliere die Rahmengröße des Scoreboards'

onyx.lang:AddPhrases('german', LANG)
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/cfg/sh_columns.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/03/2024

--]]

--[[------------------------------
**WARNING**
This is an advanced config.
Most of the things you need should be configurable through the game.
Do not edit anything if you do not understand what you are doing.
--------------------------------]]

onyx.scoreboard.columns = {}

--[[------------------------------
Default ones
--------------------------------]]
onyx.scoreboard:RegisterColumn('team', {
    getValue = function(client)
        if (onyx.scoreboard.IsTTT()) then
            return select(2, onyx.scoreboard.GetTeamTTT(client))
        end

        return client:GetJob()
    end,
    formatValue = function(value)
        if (onyx.scoreboard.IsTTT()) then
            return value
        end

        return value
    end,
    getColor = function(client)
        if (onyx.scoreboard.IsTTT()) then
            return select(3, onyx.scoreboard.GetTeamTTT(client))
        end

        local teamColor = client:GetJobColor()
        if ply:onyx_GetNetVar('Disguise_G') then
            teamColor = sam.player.get_nwvar(client, 'Job_Color') or client:GetJobColor()
        end

        return onyx.scoreboard.ConvertTeamColor(teamColor)
    end
})

onyx.scoreboard:RegisterColumn('rank', {
    getValue = function(client)
        local rank = client:GetUserGroup()
        local data = onyx.scoreboard:GetRankData(rank)
        if (data) then
            return data.name
        end
        return rank
    end
})

onyx.scoreboard:RegisterColumn('health', {
    getValue = function(client)
        local health = client:Alive() and client:Health() or -1
        return health
    end,
    formatValue = function(value)
        if (value > 0) then
            return string.Comma(value) .. ' HP'
        else
            return onyx.lang:Get('dead')
        end
    end
})

--[[------------------------------
DarkRP
--------------------------------]]
onyx.scoreboard:RegisterColumn('money', {
    getValue = function(client)
        return (client:GetMoney() or 0)
    end,
    formatValue = function(value)
        return rp.FormatMoney(value)
    end,
    customCheck = function()
        return DarkRP ~= nil
    end
})

--[[------------------------------
TTT
--------------------------------]]
onyx.scoreboard:RegisterColumn('karma', {
    getValue = function(client)
        return client:GetBaseKarma()
    end,
    formatValue = function(value)
        return string.Comma(math.Round(value))
    end,
    customCheck = function()
        return (engine.ActiveGamemode() == 'terrortown')
    end
})

--[[------------------------------
Custom
--------------------------------]]
do
    local handlers = {
        {
            key = 'GlorifiedLeveling',
            func = function(ply)
                return ply:getLevel()
            end
        },
        {
            key = 'LevelSystemConfiguration',
            func = function(ply)
                -- Vrondakis
                if (ply.getDarkRPVar) then
                    return ply:getDarkRPVar('level')
                end
            end
        },
        {
            key = 'levelup',
            func = function(ply)
                return levelup.getLevel(ply)
            end
        }
    }

    onyx.scoreboard:RegisterColumn('level', {
        getValue = function(client)
            for _, data in ipairs(handlers) do
                if (_G[data.key]) then
                    local value = data.func(client)
                    return (value or 0)
                end
            end
            return 0
        end,
        formatValue = function(level)
            return string.Comma(level)
        end,
        customCheck = function()
            for _, data in ipairs(handlers) do
                if (_G[data.key]) then
                    return true
                end
            end

            return false
        end
    })
end

do
    local handlers = {
        {
            -- SAM
            valid = function()
                return sam ~= nil
            end,
            func = function(ply)
                return ply:sam_get_play_time() -- seconds
            end
        },
        {
            -- Utime
            valid = function()
                return Utime ~= nil
            end,
            func = function(ply)
                return ply:GetUTimeTotalTime()
            end
        },
        {
            -- sAdmin
            valid = function()
                return sAdmin ~= nil
            end,
            func = function(ply)
                return sAdmin.getTotalPlaytime( ply )
            end
        },
    }

    onyx.scoreboard:RegisterColumn('playtime', {
        getValue = function(client)
            for _, data in ipairs(handlers) do
                if (data.valid()) then
                    local value = data.func(client)
                    return (value or 0)
                end
            end
            return 0
        end,
        formatValue = function(seconds)
            local minutes = math.Round(seconds / 60)
            local hours = math.Round(minutes / 60)
            if (hours < 1) then
                return string.Comma(minutes) .. 'm'
            else
                return string.Comma(hours) .. 'h'
            end
        end,
        customCheck = function()
            for _, data in ipairs(handlers) do
                if (data.valid()) then
                    return true
                end
            end

            return false
        end
    })
end

-- Ashop
onyx.scoreboard:RegisterColumn('ashop_badges', {
    getValue = function(client)
        local badges = ashop.GetPlayerBadges(client) or {}
        return table.Count(badges)
    end,
    buildFunc = function(columnPanel, ply)
        local badges = ashop.GetPlayerBadges(ply) or {}

        columnPanel.PerformLayout = function(panel, w, h)
            local space = onyx.ScaleTall(5)
            local children = panel:GetChildren()
            local amount = #children
            local size = math.min(h, (w - space * (amount - 1)) / amount)
            local totalWidth = size * amount + space * (amount - 1)
            local x = w * .5 - totalWidth * .5

            for index, child in ipairs(children) do
                if (IsValid(child)) then
                    child:SetSize(size, size)
                    child:SetPos(x, 0)
                    child:CenterVertical()

                    x = x + size + space
                end
            end
        end

        for slot, data in pairs(badges) do
            local badge = vgui.Create("DPanel", columnPanel)
            badge.Paint = function(panel, w, h)
                xpcall(function()
                    local mat = data.mat()
                    if (mat) then
                        surface.SetMaterial(mat)
                        surface.SetDrawColor(color_white)
                        surface.DrawTexturedRect(0, 0, w, h)
                    end
                end, function(errText)
                    onyx.scoreboard:PrintError('(AShop) Error during badge display: #', errText)
                end)
            end
        end
    end,
    customCheck = function()
        return ashop ~= nil
    end
})

-- Brick's Gangs
onyx.scoreboard:RegisterColumn('gang', {
    getValue = function(client)
        local gangID = client:GetGangID()
        local gangName = onyx.scoreboard.GetBricksGangName(gangID)
        return gangName
    end,
    customCheck = function()
        if (BRICKS_SERVER and BRICKS_SERVER.GANGS) then
            return true
        end
        return false
    end
})

-- VoidFactions
onyx.scoreboard:RegisterColumn('faction', {
    getValue = function(client)
        return client:VF_GetFactionName('')
    end,
    getColor = function(client)
        return client:VF_GetFactionColor(color_white)
    end,
    customCheck = function()
        return VoidFactions ~= nil
    end
})
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_column_editor.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_ACCENT = onyx:Config('colors.accent')
local COLOR_BG = onyx.ColorBetween(COLOR_PRIMARY, COLOR_SECONDARY)
local COLOR_NEGATIVE = onyx:Config('colors.negative')

local WIMG_SAVE = onyx.wimg.Simple('https://i.imgur.com/ycSNF3m.png', 'smooth mips')
local PANEL = {}

function PANEL:Init()
    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)

    self.grid = self.list:Add('onyx.Grid')
    self.grid:SetColumnCount(2)
    self.grid:SetSpace(onyx.ScaleTall(5))

    self.columns = {}
    self.default = {}
    self.changes = {}

    hook.Add('onyx.scoreboard.SyncedColumns', self, function(panel)
        panel.grid:Clear()
        panel.columns = {}
        panel.default = {}
        panel.changes = {}
        panel:LoadColumns()
    end)

    self:LoadColumns()
    self:AddSavePopup()
end

function PANEL:AddSavePopup()
    local font0 = onyx.Font('Comfortaa Bold@16')
    local font3 = onyx.Font('Comfortaa@14')

    self.confirmPopup = self:Add('DPanel')
    self.confirmPopup:SetWide(onyx.ScaleWide(225))
    self.confirmPopup:SetTall(onyx.ScaleTall(75))
    self.confirmPopup.Paint = function(panel, w, h)
        local x, y = panel:LocalToScreen(0, 0)

        if (panel.anim == 0 or panel.anim == 1) then
            onyx.bshadows.BeginShadow()
                draw.RoundedBox(8, x, y, w, h, COLOR_SECONDARY)
            onyx.bshadows.EndShadow(1, 2, 2)
        else
            draw.RoundedBox(8, 0, 0, w, h, COLOR_SECONDARY)
        end
    end
    self.confirmPopup.PerformLayout = function(panel, w, h)
        local padding = ScreenScale(2)

        panel:DockPadding(padding, padding, padding, padding)

        panel.info:Dock(FILL)
        panel.info:DockMargin(0, 0, 0, onyx.ScaleTall(5))
        panel.button:Dock(BOTTOM)
        panel.button:SetTall(onyx.ScaleTall(20))
    end

    self.confirmPopup.info = self.confirmPopup:Add('Panel')
    self.confirmPopup.info.text1 = onyx.lang:GetWFallback('unsavedSettings', 'UNSAVED SETTINGS')
    self.confirmPopup.info.text2 = onyx.lang:GetWFallback('confirmSave', 'Confirm to save the changes')
    self.confirmPopup.info.Paint = function(panel, w ,h)
        local size = math.ceil(h * .5)

        WIMG_SAVE:Draw(h * .5 - size * .5, h * .5 - size * .5, size, size, COLOR_NEGATIVE)

        draw.SimpleText(panel.text1, font0, h, h * .5, COLOR_NEGATIVE, 0, 4)
        draw.SimpleText(panel.text2, font3, h, h * .5, color_white, 0, 0)
    end

    self.confirmPopup.button = self.confirmPopup:Add('onyx.Button')
    self.confirmPopup.button:SetText(onyx.lang:GetWFallback('save_u', 'SAVE'))
    self.confirmPopup.button:SetFont(font0)
    self.confirmPopup.button:SetColorIdle(COLOR_NEGATIVE)
    self.confirmPopup.button:SetColorHover(onyx.OffsetColor(COLOR_NEGATIVE, -20))
    self.confirmPopup.button.DoClick = function()
        local changes = self:GetChanges()
        if (changes) then
            local amount = table.Count(changes)
            if (amount > 0) then
                net.Start('onyx.scoreboard:SetColumns')
                    net.WriteUInt(amount, 6)
                    for index, value in pairs(changes) do
                        net.WriteUInt(index, 8)
                        net.WriteString(value)
                    end
                net.SendToServer()
            end
        end
    end
end

function PANEL:GetChanges()
    return self.changes
end

function PANEL:Think()
    if ((self.nextThink or 0) <= CurTime()) then
        local changes = self:GetChanges()
        local anim = table.IsEmpty(changes) and 1 or 0
        local confirmPopup = self.confirmPopup

        if ((confirmPopup.targetAnim or -1) ~= anim) then
            confirmPopup.anim = confirmPopup.anim or anim -- skip first anim

            if (anim < 1) then
                confirmPopup:SetVisible(true)
            end

            onyx.anim.Create(confirmPopup, .33, {
                index = 2,
                easing = 'inQuad',
                target = {
                    anim = anim
                },
                think = function(anim, panel)
                    panel:AlignBottom(panel.anim * -panel:GetTall())
                end,
                onFinished = function(anim, panel)
                    panel:SetVisible(panel.anim < 1)
                end
            })

            confirmPopup.targetAnim = anim
        end

        self.nextThink = CurTime() + .5
    end
end

function PANEL:LoadColumns()
    for index = 1, onyx.scoreboard.columnsMaxAmount do
        self:AddColumn(index)
    end
end

function PANEL:AddColumn(index)
    local padding = onyx.ScaleTall(10)

    local panel = self.grid:Add('Panel')
    panel:SetTall(onyx.ScaleTall(70))
    panel:DockPadding(padding, padding, padding, padding)
    panel.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, COLOR_BG)
    end

    self.grid:AddItem(panel)

    local lblTitle = panel:Add('onyx.Label')
    lblTitle:SetText(onyx.lang:Get('column') .. ' #' .. index)
    lblTitle:Dock(TOP)
    lblTitle:Font('Comfortaa Bold@16')
    lblTitle:SizeToContentsY()
    lblTitle:DockMargin(0, 0, 0, onyx.ScaleTall(5))

    local comboType = panel:Add('onyx.ComboBox')
    comboType:Dock(FILL)
    comboType:AddOption(onyx.lang:Get('scoreboard_col_none'), 'none')
    comboType.OnSelect = function(panel, _, text, data)
        if (not self.default[index] or self.default[index] ~= data) then
            self.changes[index] = data
        else
            self.changes[index] = nil
        end
    end

    for columnID, columnData in pairs(onyx.scoreboard.columns) do
        if (not columnData.customCheck or columnData.customCheck()) then
            comboType:AddOption(onyx.lang:Get(columnData.name), columnID)
        end
    end

    local currentID = onyx.scoreboard.columnsCustomizable[index] or onyx.scoreboard.columnsDefault[index] or 'none'

    if (currentID) then
        local optionData, optionIndex = comboType:FindOptionByData(currentID)
        if (optionIndex) then
            comboType:ChooseOptionID(optionIndex, true)
            self.default[index] = currentID
        else
            comboType:SetCurrentOptionText('invalid : ' .. currentID)
            comboType:Highlight(Color(255, 78, 78))
        end
    end

end

onyx.gui.Register('onyx.scoreboard.ColumnEditor', PANEL)

-- if (IsValid(DebugPanel)) then
--     DebugPanel:Remove()
-- end

-- DebugPanel = onyx.scoreboard.OpenAdminSettings(3)
--PATH addons/_outfitter/lua/includes/modules/netobj.lua:
AddCSLuaFile()

require'netqueue'

local net=net

local netobj={}

local function StartWrite(tag,unreliable,...)
	net.Start(tag,unreliable)
	net.WriteTable{...}
end


local function netobj_process(self,mt,shouldfunc,name,id,dat)
	if not shouldfunc then return end
	
	local unreliable = dat and dat[2]
	local notable = dat and dat[3]
	
	local ourfuncs = mt.__index
	ourfuncs[name]=function(...)
		net.Start(mt.tag,unreliable)
			net.WriteUInt(id,mt.bits)
			if not notable then
				net.WriteTable{...}
			else
				assert(false,"unimplemented")
			end
		return net
	end
end

--- Set up structures to send and receive the messages
local function netobj_processto(self,shouldfunc,...)
	local mt=getmetatable(self)
	local mapping=mt.mapping

	for i=1,select('#',...) do
		local v=select(i,...)
		local funcname=istable(v) and v[1] or v
		table.insert(mapping,funcname)
		local nmappings = #mapping
		
		local bits=math.floor(math.log(nmappings,2))+1
		mt.bits = bits
		
		netobj_process(self,mt,shouldfunc,funcname,nmappings,istable(v) and v)
	end
end

--- Expose server functions
function netobj:sv(...)
	netobj_processto(self,CLIENT,...)
	return self
end

--- Expose client functions

function netobj:cl(...)
	netobj_processto(self,SERVER,...)
	return self
end

local netobj_fallback={__index=netobj}

function net.new(tag,target,key)
	local mapping={}
	local ourfuncs=setmetatable({},netobj_fallback)

	local mt={__index=ourfuncs,tag=tag,target=target,mapping=mapping}
	local obj=setmetatable({},mt)
	if SERVER then
		
		util.AddNetworkString(tag)
		
	end
	
	net.Receive(tag,function(len,pl)
		local id = net.ReadUInt(mt.bits)
		local t = mapping[id]
		
		if t==nil then
			ErrorNoHalt(("NetObj '%s' received invalid id %s%s\n"):format(tostring(tag),tostring(id),SERVER and (" From "..tostring(pl)) or ""))
			return
		end
		
		local name = t
		local notable
		if istable(t) then
			name = t[1]
			notable=t[3]
		end
		
		local funct = target[name]
		if not isfunction(funct) then
			ErrorNoHalt(("NetObj '%s' unable to call '%s'%s\n"):format(tostring(tag),tostring(name),SERVER and (" From "..tostring(pl)) or ""))
			return
		end
		
		if notable then
			if SERVER then
				funct(target,pl)
			else
				funct(target)
			end
		else
			local t=net.ReadTable()
			
			if SERVER then
				funct(target,pl,unpack(t))
			else
				funct(target,unpack(t))
			end
		end
	end)
	
	if key~=nil then
		target[key]=obj
	end
	
	return obj
end
--PATH addons/_outfitter/lua/outfitter/cows.lua:
-- coroutine workshop --

local Tag='outfitter'
module(Tag,package.seeall)

function IsUGCFilePath(path)
	if path:find("^.:") or path:find("^[%\\%/]") then
		return true
	end

	if path:find("content[\\/]4000[\\/]") then
		-- TODO: better way to check for UGC?
		return true
	end

	return false
end

-- External decompression helper (nerfed by http.Fetch)

local outfitter_disable_decompress_helper = CreateClientConVar("outfitter_disable_decompress_helper",'1',true)
if not outfitter_disable_decompress_helper:GetBool() then
	file.Write("decomp_in_steamworks.dat",'INIT')
end
local has_decompress_helper
function HasDecompressHelper()
	if outfitter_disable_decompress_helper:GetBool() then return false end
	return os.time()-(file.Time("of_dchelper.dat",'DATA') or 0)<120
end
---------------------------------

-- shadowing "dbge" because showing errors to expected behaviors in
-- user targeted code is highly stupid
local function dbge(...)
	Msg("[Outfitter] ")
	print(...)
end

local fetching = {}

local res = {}
local skip_maxsizes = {}
local function SYNC(cbs,...)
	for k,cb in next,cbs do
		cb(...)
		co.waittick()
	end
	return ...
end

local function steamworks_Download_work( fileid )
	local instant
	local path,fd
	local cb
	local done
	
	-- retry
	for i=0,4 do
		if path then break end

		instant,path,fd,cb = nil,nil,nil,nil

		if i~=0 then
			dbg("DownloadUGC","retry attempt ====",i)
			co.sleep(math.random()*3+1)
		end

		cb = co.newcb()
		local function cb2(a,b)
			SafeRunHook("OutfitterDownloadUGCResult",fileid,a,b)
			if done then return end
			
			dbg("DownloadUGC",fileid,instant==false and "" or "instant?","result",a,b)
			if instant==nil then
				path = a
				fd = b
				instant = true
				return
			end
			done = true
			cb(a,b)
		end
		dbgn(2,"DownloadUGC",fileid,"START")
		steamworks.DownloadUGC( fileid, cb2 )
		if instant==nil then
			timer.Simple(60*3,function()
				if done then return end
				dbg("DownloadUGC",fileid,"TIMEOUT (WIP)")
				UIWarnDownloadFailures(wsid)

				--cb2(false,false)
				--done=true
			end)
			instant = false
			path,fd = co.waitcb(cb)
		end
	end

	dbg("DownloadUGC",fileid,"returning",path,fd,instant and "<CACHED>" or "")
	
	return path,fd
end

DownloadUGC = co.worker(steamworks_Download_work)

local lme
local lwsid
function GetLastMountErr(wsid)
	if lwsid and lwsid~=wsid then return end
	return lme
end

local function cantmount(wsid,reason,...)
	fetching[wsid] = false
	res[wsid] = reason or "failed?"
	if reason~='oversize' or outfitter_maxsize == 100 then
		dbgn(3,"FetchWS","downloading",wsid,"failed for reason:",reason,...)

		local err_msg = ("FetchWS downloading %s failed for reason: %s"):format(tostring(wsid), reason)
		Msg("[Outfitter] ")
		print(err_msg)

		notification.AddLegacy(err_msg, NOTIFY_ERROR, 5)
	end

	lme= reason or "?"
	lwsid=wsid
	return false,reason
end

do -- steamworks fileinfo worker
	local worker,cache = co.work_cacher_filter(
		function(key,fileinfo)
			return (not key) or fileinfo
		end,

		co.work_cacher(
			function(wsid)
				local cb = co.newcb()
					steamworks.FileInfo(wsid,cb)
				local fileinfo = co.waitcb(cb)

				return fileinfo

			end)
		)
	co_steamworks_FileInfo = co.worker(worker)
end


do
	local worker,cache = co.work_cacher_filter(
		function(key,fileinfo)
			return (not key) or fileinfo
		end,

		co.work_cacher(
			function(wsid)
				local cb = co.newcb()
					steamworks.VoteInfo(wsid,cb)
				local fileinfo = co.waitcb(cb)

				return fileinfo

			end)
		)
	co_steamworks_VoteInfo = co.worker(worker)
end


function coFetchWS(wsid,skip_maxsize)

	if skip_maxsize then
		skip_maxsizes[wsid] = true
	end

	-- fetch cache ("promise/future") (no double-fetching)
	local dat = fetching[wsid]

	if dat then
		if dat==true then
			-- true: already fetched
			return res[wsid] or true
		elseif istable(dat) then
			-- become a waiter
			local cb = co.newcb()
			dat[#dat+1] = cb
			return co.waitcb()
		elseif dat==false then
			-- already failed, retry or cancel if because of size (TODO: retry at most every N seconds?)
			local res = res[wsid]
			local canskip = res=="oversize" and skip_maxsize
			if not canskip then
				return false,res
			end
		end
	end

	local isdbg = isdbg()

	if isdbg then dbg("FetchWS",wsid) end

	dat = {}
	fetching[wsid] = dat

	local fileinfo = co_steamworks_FileInfo(wsid)

	dbg("steamworks.FileInfo",wsid,"->",fileinfo)
	if istable(fileinfo) then
		dbg("","title",fileinfo.title)
		if fileinfo.error then
			dbg("","error",fileinfo.error)
		end
		dbg("","owner",fileinfo.owner)
		dbg("","tags",fileinfo.tags)
		dbg("","size",string.NiceSize(fileinfo.size or 0))
		dbg("","fileid",fileinfo.fileid)
		local created = os.time() - (fileinfo.created or 0)

		dbg("","created ago",string.NiceTime(created))

		--TODO: Check banned
		--TODO: Check popularity before mounting

		local installed = fileinfo.installed
		local disabled = fileinfo.disabled
		
		if fileinfo.banned then
			dbge(wsid,"BANNED!?")
			return SYNC(dat,cantmount(wsid,"banned"))
		end
		
		if next(fileinfo.children or {}) then
			dbg(wsid,"has dependencies, these will not be mounted")
			--return SYNC(dat,cantmount(wsid,"dependencies"))
		end
		
		if created<60*60*24*7 then
			dbg(wsid,"WARNING: ONE WEEK OLD ADDON. NOT ENOUGH TIME FOR WORKSHOP MODERATORS.")
			if IsParanoidMode(1) then
				return SYNC(dat,cantmount(wsid,"new_addon"))
			end
		end
		if disabled then
			dbgn(3,"FileInfo",wsid,"Disabled?")
		end
		if installed then
			dbgn(3,"FileInfo",wsid,"installed? We shouldn't get this far if not disabled")
		end
	end

	if not fileinfo or not fileinfo.title then
		return SYNC(dat,cantmount(wsid,"fileinfo"))
	end
	if IsTitleBlocked(fileinfo.title) then
		return SYNC(dat,cantmount(wsid,"blocked title"))
	end

	if fileinfo.error and fileinfo.error ~="" then
		return SYNC(dat,cantmount(wsid,"fileinfo: "..tostring(fileinfo.error)))
	end
	
	if tonumber(fileinfo.size or 0)==0 or tonumber(fileinfo.size or 0)==0 then
		return SYNC(dat,cantmount(wsid,"undownloadable"))
	end
	
	local maxsz = 100
	maxsz = maxsz*1000*1000

	if maxsz>0.1 and ((fileinfo.size or 0)-1024*1024) > maxsz then
		skip_maxsize = skip_maxsize or skip_maxsizes[wsid]

		dbg("FetchWS","MAXSIZE",skip_maxsize and "OVERRIDE" or "",wsid,string.NiceSize(fileinfo.size or 0))

		if not skip_maxsize then
			return SYNC(dat,cantmount(wsid,"oversize"))
		end
	end

	co.wait(.3)

	local decomp_in_steamworks = true --not HasDecompressHelper()

	local TIME = isdbg and SysTime()
	local path,fd = DownloadUGC( wsid )
	if isdbg then dbg("Download",wsid,"to",path or "<ERROR>","took",SysTime()-TIME) end

	assert(path~=true)

	if not path then
		return SYNC(dat,cantmount(wsid,"download"))
	end

	if not IsUGCFilePath(path) and file.Size(path,'MOD')<=512 then
		return SYNC(dat,cantmount(wsid,"file"))
	end

	-- Decompress manually
	if not decomp_in_steamworks then
		local err
		path,err = coDecompress(path)
		if not path then
			return SYNC(dat,cantmount(wsid,'decompress'))
		end

		if not IsUGCFilePath(path) and not file.Exists(path,'MOD') then
			dbg(path,"IsUGCFilePath",IsUGCFilePath(path),"file.Exists",file.Exists(path,'MOD'))
			return SYNC(dat,cantmount(wsid,"file"))
		end
	end

	-- Strip lua files for exploit protection
	-- TODO: decompression
	if ShouldStripLuaFromDownloads() and fd then
		local accu=0
		collectgarbage('step',40000)
		local ok,ret,err,err2 = xpcall(gma.rebuild_nolua,debug.traceback,fd,wsid,false,function(sz)
			if sz==true or sz==false then
				collectgarbage('step',40000)
			end
			accu=accu+(tonumber(sz) or 0)
			if accu>1024*1024 then
				accu=0
				collectgarbage('step',20000)
			end
		end)
		dbg("gma.rebuild_nolua",ok,ret,err,err2)
		if not ok then
			err=ret
			ret=nil
		end
		if isstring(ret) then
			path=ret
		elseif ret==true then
			dbg("coFetchWS","gma.rebuild_nolua","No rebuild necessary or possible")
		else
			dbge("coFetchWS","gma.rebuild_nolua",wsid,err,err2)
			return SYNC(dat,cantmount(wsid,"gmarebuild"))
		end
	end

	local result = path

	-- mark as fetched
	fetching[wsid] = true
	res[wsid] = result

	return SYNC(dat,result)

end

function FetchWS(wsid,cb)
	if co.make(wsid,cb) then return end
	cb(coFetchWS(wsid))
end

function MountWS( path )

	--TODO: Check blacklist
	--[[ TODO: 	think I found a fix
				if something mounts fine once
				it gets whitelisted
		]]

	assert(path,'no file given')
	assert(DidCrash,"Outfitter has not initialized properly??? Contact Python1320")
	local crashed = DidCrash("mountws",path)

	dbg("MountWS",path,crashed and "CRASHED, BAILING OUT")

	if crashed then return nil,"crashed" end

	local TIME = SysTime()
	CRITICAL("mountws",path)
	local ok, files = MountGMA( path )
	CRITICAL(false)
	local took = SysTime() - TIME
	if isdbg() then dbg("MountGMA",path,"took",math.Round(took*1000)..' ms') end

	result = ok or false
	return result,files,took
end

local function _coMountWS(path)
	UIMounting(true)
	co.sleep(.3)
		local res,files,took = MountWS( path )
	UIMounting(false)
	co.sleep(math.Clamp((took or 0)*2.4,.2,2))

	return res,files,took
end
local worker,cache = co.work_cacher_filter(
	function(key,ok)
		return (not key) or ok
	end,
	co.work_cacher(_coMountWS)
)
coMountWS = co.worker(worker)




function _coDecompressExt(path)
	if not HasDecompressHelper() then return nil,'no helper' end
	if not path then return nil,'invalid parameter' end
	dbgn(2,"coDecompressExt",path)

	local ok,data,len,hdr,code = co.post('http://localhost:27099/decompress',{
		file = path
	})

	if not ok or code~=200 then
		has_decompress_helper = false
		dbge("_coDecompressExt",data,code)
		return nil,data
	end


	if code ~= 200 then
		dbge(data)
		return nil,'idk'
	end

	local resultpath = path..'.decompressed'
	local ex = file.Exists(resultpath,'GAME')
	if not ex then dbge("coDecompress","File not found",path,'->',resultpath) return nil,'missing decompress' end
	return resultpath
end

-- TODO rework if even needed anymore
function coDecompress(path)
	if not path then return nil,'invalid parameter' end
	if IsUGCFilePath(path) then return nil,'new workshop file' end

	dbgn(2,"coDecompress",path)

	local ok,ret = _coDecompressExt(path)
	if ok then return ok,ret end

	local safepath = path:gsub("%.cache$",".dat")
	if safepath==path then
		safepath = path..'.d.dat'
	end
	--assert(safepath~=path,"path change failed")
	if not file.Exists(safepath,'DATA') then

		file.CreateDir("cache",'DATA')
		file.CreateDir("cache/workshop",'DATA')

		dbgn(2,'coDecompress','finished collecting 1',coMinimizeGarbage())

		local data = file.Read(path,'GAME')				co.sleep(.3)
		if not data then dbge("coDecompress","File Read",path) return nil,'read' end

		local decomp_in_steamworks,err = util.Decompress(data) data = nil	co.sleep(.3)
		if not decomp_in_steamworks then dbge("coDecompress","LZMA Decompress",path,err or "failed :(") return nil,'decompress' end
		local sz = #decomp_in_steamworks

		file.Write(safepath,decomp_in_steamworks)	decomp_in_steamworks = nil 		co.sleep(.3)

		dbgn(2,'coDecompress','finished collecting 2',coMinimizeGarbage())

		if file.Size('data/'..safepath,'GAME')~=sz then
			dbge("coDecompress","LZMA Decompress SZ",
				file.Size('data/'..safepath,'GAME') or "FILE NO EXIST?",
				sz,path,safepath)
			return nil,'decompress'
		end

		co.sleep(.2)
	end

	return 'data/'..safepath
end

--TODO: own cache
function NeedWS(wsid,pl,mdl)
	assert(tonumber(wsid),"NeedWS invalid wsid: "..tostring(wsid))
	if co.make(wsid,pl,mdl) then return end

	-- already mounted, don't mount again
	if steamworks.IsSubscribed(wsid) and file.Exists(mdl,'GAME') then return true end

	SetUIFetching(wsid,true)

		co.sleep(.1)

		local path,err,err2 = coFetchWS( wsid ) -- also decompresses

		co.sleep(1)

	SetUIFetching(wsid,false,not path and (err and tostring(err) or "FAILED?"))

	if not path then
		if err~='oversize' then
			dbge("NeedWS",wsid,"fail",err,err2)
		end
		return nil,err or "fetchws",err2
	end

	local ok,err = GMABlacklist(path)
	if not ok and err=='notgma' and TestLZMA(path) then
		local newpath,err = coDecompress(path)
		if not newpath then
			dbge("NeedWS",wsid,"fail",err)
			return nil,err or "decompress"
		end
		path = newpath

		-- retry --
		ok,err = GMABlacklist(path)
		-----------
	end

	if not ok then
		dbge("NeedWS","GMABlacklist",wsid,"->",err)
		return
	end

	local mdls,extra,errlist = GMAPlayerModels(path)

	if not mdls then
		dbge("NeedWS","GMAPlayerModels",wsid,"fail",extra)
		return false,"mdlparse",extra
	end

	if not mdls[1] then
		dbge("NeedWS","GMAPlayerModels",wsid,"has no models")
		return false,"nomdls"
	end

	local has = not mdl
	if not has then
		has = extra.playermodels[mdl] or extra.hands[mdl]
		if not has then
			-- TODO: Make enforced
			local bad = extra.potential[mdl] or extra.discards[mdl]
			if bad then
				dbge("NeedWS",wsid,path,"requested mdl was discarded",mdl)
--			elseif GMAHasFile()
			else
				dbge("NeedWS",wsid,path,"missing requested mdl",mdl)
			end

		end
	end

	local ok,err = coMountWS( path )

	if not ok then
		dbg("NeedWS",wsid,"mount fail",err)
		return nil,err or "mount"
	end

	return true

end


function GetQueryUGCChildren(workshopid)
	local ok,ret,len,hdrs,retcode = co.fetch("http://steamcommunity.com/sharedfiles/filedetails/?id="..workshopid)
	if not ok then return nil,ret end
	if retcode==404 then return false end
	if retcode~=200 then return nil,retcode,ret end

	local _,posa = ret:find('id="RequiredItems">',1,true)
	if not posa then
		if ret:find('publishedfileid',1,true) then
			return {} -- probably just no require items
		end
		if ret:find("store.steampowered.com",1,true) then
			return false -- 404
		end
		return nil,"internal error: steam format changed"
	end

	local posb
	for i=0,6 do
		local _,new_posb = ret:find('<div class="requiredItem">',posb or posa,true)
		if not new_posb then break end
		posb = new_posb
	end
	if not posb then return nil,"internal error: format changed" end

	local t = {}
	for id in ret:sub(posa,posb):gmatch'id%=(%d+)' do
		t[#t+1]=id
	end
	return t
end

-- TODO: move


local function http_wrap(ok,err,okerr,...)
	if okerr==ok then
		return true,...
	elseif okerr==err then
		return false,...
	else
		error"Invalid fetch callback called"
	end
end


function co_head(url,data,hdr)
	hdr=hdr or {}
	--hdr["Accept-Encoding"] = hdr["Accept-Encoding"] or "none"

	local ok,err = co.newcb(),co.newcb()
	HTTP({
		method = "HEAD",
		url = url,
		headers = hdr,
		success = function(code, data, headers,...)
			ok(data, #data, headers,code,...)
		end,
		failed = function(...)
			err(...)
		end
	})
	return http_wrap(ok,err,co.waitone())
end

-- TODO: MOVE
-- TODO: cache


local function checkhttp(ok,ret,len,hdrs,retcode)
	if retcode==404 then return nil,'not found' end
	if retcode~=200 then return nil,"http error",retcode end
	local size = hdrs["Content-Length"] and tonumber(hdrs["Content-Length"])
	

	local maxsz = 100
	maxsz = maxsz*1000*1000

	if size and maxsz>=1 and size > math.min(maxsz,1024*1024*1024) then
		skip_maxsize = skip_maxsize or skip_maxsizes[wsid]

		dbg("NeedHTTPGMA","MAXSIZE",skip_maxsize and "OVERRIDE" or "",wsid,string.NiceSize(size))

		if not skip_maxsize then
			return nil,"oversize"
		end
	end
	return true
end


function URLFilename(url)
	return url:match( "([^/]+)$" )
end

local http_downloaded={}
function coFetchGMA(download_info,pl,mdl)
	if http_downloaded[download_info] then
		return http_downloaded[download_info]
	end


	local download_info_actual = MakeURLDownloadable(download_info)
	local filename = URLFilename(download_info) or "noname"..util.CRC(download_info)

	-- 1. first try getting header info to see if we are downloading insanity
	local ok,ret,len,hdrs,retcode = co_head(download_info_actual)
	if ok then
		local size = hdrs["Content-Length"] and tonumber(hdrs["Content-Length"])
		local ETag = hdrs["ETag"]
		local can_range = hdrs["Accept-Ranges"] and hdrs["Accept-Ranges"]:find"bytes" and true or false
		dbg("NeedHTTPGMA Header",download_info,"ETag=",ETag,"Size=",size,"can_range=",can_range,table.ToString(hdrs))

		local ok,err,err2 = checkhttp(ok,ret,len,hdrs,retcode)
		if not ok then
			return ok,err,err2
		end
	end

	
	co.sleep(.1)

	-- 2. then actually download the thing
	SetUIFetching(filename,true,nil,true)
	--dbgn(2,'NeedHTTPGMA','minimized garbage for download',coMinimizeGarbage())
	local ok,data,len,hdrs,retcode = co.fetch( download_info_actual )	
	SetUIFetching(filename,false,not ok and ddata or retcode~=200 and "server returned an error" or nil,true)
	if not ok then return nil,data or 'download failed' end

	-- TODO: lower memory usage instantly rather than this?
	--dbgn(2,'NeedHTTPGMA','minimized garbage after download',coMinimizeGarbage())

	-- TODO: cache
	local ETag = hdrs["ETag"]
	local LastModified = hdrs["Last-Modified"]
	local can_range = hdrs["Accept-Ranges"] and hdrs["Accept-Ranges"]:find"bytes" and true or false
	dbg("NeedHTTPGMA Downloaded",download_info,"ETag=",ETag,"LastModified=",LastModified,"Size=",string.NiceSize(len),"can_range=",can_range,table.ToString(hdrs))

	local ok,err,err2 = checkhttp(ok,data,len,hdrs,retcode)
	if not ok then
		return ok,err,err2
	end
	file.CreateDir("cache",'DATA')
	file.CreateDir("cache/httpgma",'DATA')

	local sha1 = util.SHA1(data)
	
	local path_DATA = ("cache/httpgma/%s.dat"):format(sha1)
	file.Write(path_DATA,data)
	data=nil
	dbgn(2,'NeedHTTPGMA','minimized garbage after data discard',coMinimizeGarbage())
	local path="data/"..path_DATA
	
	local ok,err = GMABlacklist(path)
	if not ok and err=='notgma' and TestLZMA(path) then
		local newpath,err = coDecompress(path)
		if not newpath then
			dbge("NeedWS",download_info,"fail",err)
			return nil,err or "decompress"
		end
		path = newpath

		-- retry --
		ok,err = GMABlacklist(path)
		-----------
	end

	if not ok then
		dbge("NeedHTTPGMA","GMABlacklist",download_info,"->",err)
		return
	end

	local mdls,extra,errlist = GMAPlayerModels(path)

	if not mdls then
		dbge("NeedHTTPGMA","GMAPlayerModels",download_info,"fail",extra)
		return false,"mdlparse",extra
	end

	if not mdls[1] then
		dbge("NeedHTTPGMA","GMAPlayerModels",download_info,"has no models")
		return false,"nomdls"
	end

	local has = not mdl
	if not has then
		has = extra.playermodels[mdl] or extra.hands[mdl]
		if not has then
			-- TODO: Make enforced
			local bad = extra.potential[mdl] or extra.discards[mdl]
			if bad then
				dbge("NeedHTTPGMA",download_info,path,"requested mdl was discarded",mdl)
--			elseif GMAHasFile()
			else
				dbge("NeedHTTPGMA",download_info,path,"missing requested mdl",mdl)
			end

		end
	end

	if ShouldStripLuaFromDownloads() then
		local accu=0
		collectgarbage('step',20000)
		local target_id=sha1:sub(1,32)
		local fd = file.Open(path_DATA,'rb','DATA')
		if not fd then
			return false,"no file"
		end
		local ret,err,err2 = gma.rebuild_nolua(fd,target_id,false,function(sz)
			if sz==true or sz==false then
				co.waittick()
				collectgarbage('step',40000)
				co.waittick()
			end
			accu=accu+(tonumber(sz) or 0)
			if accu>1024*1024 then
				accu=0
				collectgarbage('step',20000)
				co.waittick()
			end
		end)
		
		fd:Close()

		dbg("gma.rebuild_nolua",ret,err,err2)
		if isstring(ret) then
			path=ret
		elseif ret==true then
			dbg("gma.rebuild_nolua","No rebuild necessary or possible")
		else
			dbge("gma.rebuild_nolua",err,err2)
			return
		end
	end
	
	if not path or path==true then return path end

	local ret={path=path,sha1=sha1}
	http_downloaded[download_info]=ret
	return ret

end

function NeedHTTPGMA(download_info,pl,mdl)
	if co.make(download_info,pl,mdl) then return end
	
	local data,err,err2,ok = coFetchGMA(download_info,pl,mdl)
	
	if not data then return data,err,err2 end
	if not data.path then return nil,'nopath' end

	ok,err = coMountWS( data.path )

	if not ok then
		dbg("NeedHTTPGMA",download_info,"mount fail",err)
		return nil,err or "mount"
	end

	return true

end

--[[
co(function()
	Msg"no children:"
	PrintTable(GetQueryUGCChildren '1100368137')
	Msg"1 children:"
	PrintTable(GetQueryUGCChildren '848953556')
	Msg"2 children:"
	PrintTable(GetQueryUGCChildren '918084741')
	Msg"no exist:"
	PrintTable(GetQueryUGCChildren '123')
end)

no children:{
}
1 children:{
	[1] = "757604550",
}
2 children:{
	[1] = "757604550",
	[2] = "775573383",
}
no exist:false
]]
--PATH addons/_outfitter/lua/outfitter/skin.lua:
local surface = surface
local draw = draw
local Color = Color

local SKIN = {}

SKIN.PrintName 		= "Outfitter"
SKIN.Author 		= "Python1320"
SKIN.DermaVersion	= 1
SKIN.GwenTexture	= Material( "gwenskin/GModDefault.png" )

SKIN.Colours = setmetatable({},{__index=function(t,k)
	setmetatable(t,{__index=error})
	SKIN.Colours = nil
	SKIN.Colours = table.Copy(SKIN.Colours)
	SKIN.Colours.Window.TitleActive		= Color(0,0,0,255)
	SKIN.Colours.Window.TitleInactive		= Color(0,0,0,255)
	
	return SKIN.Colours[k]
end})

pcall(require,'urlimage')
local function URLImage(m)
	local first=true
	local img
	local function initator(...)
		if first then
			first = false
			img = surface.URLImage and surface.URLImage(m) -- begin fetching
		end
		if not img then return end 
		if img then
			return img(...)
		end
	end
	return initator
end
local xmashat = URLImage "https://metastruct.github.io/outfitter/xmashat.png"
function SKIN:PaintFrame( panel, w, h )
	
	if ( panel.m_bPaintShadow ) then
	
		DisableClipping( true )
		
		surface.SetDrawColor(36,35,33,150)
		surface.DrawRect(w,4,4,h)
		surface.DrawRect(4,h,w-4,4)
		
		DisableClipping( false )
	
	end
	
	if ( panel:HasHierarchicalFocus() ) then
	
		surface.SetDrawColor(200,200,200,190)
		surface.DrawRect(1,1,w-2,24)
		
	else
		
		surface.SetDrawColor(180,180,190,100)
		surface.DrawRect(1,1,w-2,24)
	
	end
	
	surface.SetDrawColor(150,147,147,200)
	surface.DrawRect(1,24,w-2,h-1-24)
	surface.SetDrawColor(130,130,130,200)
	surface.DrawOutlinedRect(0,0,w,h)

	if ( panel.m_bPaintHat ) then
		
		DisableClipping( true )
		
		local w,h = xmashat()
		if w then
			local now = RealTime()
			local startt = panel.skin_xhat_startt
			if startt==nil then 
				startt = now 
				panel.skin_xhat_startt = startt 
			end
			local f = now-startt
			f=f>1 and 1 or f
			surface.SetDrawColor(255,255,255,f*255)
			surface.DrawTexturedRect(-30,-32-8,64,64)
		end
		DisableClipping( false )
	
	end	
	
end

function SKIN:PaintTab( panel, w, h )
	
	
	if ( !panel.m_bBackground ) then return end
	
	h=h-(panel:GetPropertySheet():GetActiveTab() == panel and 6 or 0)
		
	if ( panel.Depressed ) then
		surface.SetDrawColor(122,122,122,200)
		surface.DrawRect(1,1,w-2,h-2)
		surface.SetDrawColor(130,130,130,200)
		surface.DrawOutlinedRect(0,0,w,h)
		return
	end
	
	if ( panel.Hovered ) then
		surface.SetDrawColor(190,190,190,200)
		surface.DrawRect(1,1,w-2,h-2)
		surface.SetDrawColor(130,130,130,200)
		surface.DrawOutlinedRect(0,0,w,h)
		return
	end
	if ( panel:GetPropertySheet():GetActiveTab() == panel ) then
		surface.SetDrawColor(190,180,180,200)
		surface.DrawRect(1,1,w-2,h-2)
		surface.SetDrawColor(130,130,130,200)
		surface.DrawOutlinedRect(0,0,w,h)
	else
		surface.SetDrawColor(190,180,180,200)
		surface.DrawRect(1,1,w-2,h-2)
		surface.SetDrawColor(130,130,130,200)
		surface.DrawOutlinedRect(0,0,w,h)
	end
end

function SKIN:PaintPropertySheet( panel, w, h )

	-- TODO: Tabs at bottom, left, right

	local ActiveTab = panel:GetActiveTab()
	
	
	surface.SetDrawColor(140,137,135,200)
	surface.DrawRect(1,24,w-2,h-2)
	
	surface.SetDrawColor(60,60,60,200)
	surface.DrawOutlinedRect(0,0,w,h)

end

function SKIN:PaintCheckBox( panel, w, h )


	if ( panel:GetDisabled() ) then
	
		local q=0.6
		
		if ( panel:GetChecked() ) then
			surface.SetDrawColor(200*q,255*q,135*q,200)
			surface.DrawRect(1,1,w-2,h-2)
		else
			surface.SetDrawColor(200*q,215*q,200*q,200)
			surface.DrawRect(1,1,w-2,h-2)
		end
	
	else
	
		surface.SetDrawColor(60,60,60,200)
		surface.DrawOutlinedRect(0,0,w,h)
		
		if ( panel:GetChecked() ) then
			surface.SetDrawColor(200,255,135,200)
			surface.DrawRect(1,1,w-2,h-2)
		else
			surface.SetDrawColor(200,215,200,200)
			surface.DrawRect(1,1,w-2,h-2)
		end
		
	end
		
	
	

end


function SKIN:PaintButton( panel, w, h )

	if ( !panel.m_bBackground ) then return end
	
	if ( panel.Depressed || panel:IsSelected() || panel:GetToggle() ) then
		surface.SetDrawColor(190,180,180,200)
		surface.DrawRect(1,1,w-2,h-2)
		surface.SetDrawColor(130,130,130,200)
		surface.DrawOutlinedRect(0,0,w,h)
		return
	end
	
	if ( panel:GetDisabled() ) then
		surface.SetDrawColor(111,111,111,222)
		surface.DrawRect(1,1,w-2,h-2)
		surface.SetDrawColor(79,78,77,222)
		surface.DrawOutlinedRect(0,0,w,h)
		return
	end
	
	if ( panel.Hovered ) then
		surface.SetDrawColor(190,190,190,200)
		surface.DrawRect(1,1,w-2,h-2)
		surface.SetDrawColor(130,130,130,200)
		surface.DrawOutlinedRect(0,0,w,h)
		return
	end

	surface.SetDrawColor(250,248,246,200)
	surface.DrawRect(1,1,w-2,h-2)
	surface.SetDrawColor(130,130,130,200)
	surface.DrawOutlinedRect(0,0,w,h)

end

derma.DefineSkin( "Outfitter", "Agh?", SKIN )
--derma.RefreshSkins()
--PATH addons/_outfitter/lua/outfitter/gui_bodygroups.lua:
local Tag='outfitter'

-- lua_openscript_cl srv/outfitter/lua/outfitter/ui.lua;lua_openscript_cl srv/outfitter/lua/outfitter/gui.lua;outfitter_open

module(Tag,package.seeall)



local PANEL={}
function PANEL:Init()
	self:SetSize(24,24)
	--self:Dock(RIGHT)
end

local CCHECKED = Color(111,255,111,255)
local CNORMAL  = Color(66,66,66,255)
local CBG  = Color(30,30,30,255)
function PANEL:Paint(w,h)
	if self.checked then
		surface.SetDrawColor(100,255,100,255)
	else
		surface.SetDrawColor(150,150,150,255)
	end
	draw.RoundedBox(h*0.5,0,0,h,h,CBG)
	draw.RoundedBox(h*0.5,1,1,h-2,h-2,self.checked and CCHECKED or CNORMAL)
	surface.SetFont"BudgetLabel"
	local txt = self.letter or ""
	local tw,th = surface.GetTextSize(txt)
	surface.SetTextColor(255,255,255,255)
	surface.SetTextPos(-tw*.5+h*.5,h*.5-th*.5)
	surface.DrawText(txt)
end

function PANEL:OnMouseReleased()
	self:GetParent():SetChecked(self.n)
end

function PANEL:SetChecked(checked)
	self.checked = checked
end

function PANEL:PerformLayout()
	--self:SetSize(16,16)
	--self:SetWide(self:GetTall())
end

local radiobtn=vgui.RegisterTable(PANEL,"EditablePanel")




local PANEL={}
function PANEL:Init()
	self.lbl = vgui.Create('DLabel',self,'description')
	--self.lbl:Dock(FILL)
	self.lbl:SetTextColor(Color(255,255,255,255))
	self.lbl:SetFont("BudgetLabel")	
	self:SetSpaceX( 2 )
	self:SetSpaceY( 2 )
	self:SetBorder( 2 )
	
	self.lbl:SetText"Radio buttons tester"
	--self:SetLayoutDir( LEFT )
	self.lbl.Paint=function(self,w,h)
		self:NoClipping(false)
	end
end

function PANEL:OnSelected(n,pnl)
	print(self,"OnSelected",n,pnl)
end

function PANEL:SetText(t)
	self.lbl:SetText(t)
	self.lbl:SizeToContents()
	self.lbl:SetContentAlignment(5)
	self.lbl:SetWide(8+self.lbl:GetWide())
	self.lbl:SetTooltip(t)
	
	self:InvalidateLayout()
	
end

function PANEL:AddOption(description,letter)
	self.n=self.n or 0
	self.n=self.n + 1
	local n = self.n
	
	local pnl = vgui.CreateFromTable(radiobtn,self,'radiolist')
	pnl.n=n
	pnl.letter = letter
	
	pnl:SetTooltip(description)
	pnl.d = description:sub(1,1)
	pnl:DockMargin(n>1 and 2 or 1,1,1,1)

	self.radios=self.radios or {}
	self.radios[n]=pnl
	return n,pnl
end


--function PANEL:Think()
--end

function PANEL:SetChecked(n)
	for k,v in next,self.radios do
		v:SetChecked(k==n)
	end
	self:OnSelected(n)
end

--function PANEL:PerformLayout()
--	self:SizeToChildren(true,true)
--end



vgui.Register('OFRadioBatton',PANEL,"DIconLayout")


 
 

local vgui = GetVGUI()
 
 
 
 
 

local PANEL={}
function PANEL:Init()
end

function PANEL:Think()
end

function PANEL:Clear()
	for k,v in next,self:GetChildren() do v:Remove() end
end

function PANEL:Refresh()
	self:Clear()
	dbg("self.model")
	local a = mdlinspect.Open(self.model)
	a:ParseHeader()
	local parts = a:BodyPartsEx()
	self.parts = parts

	self.skins = a:ParseSkins()

	self:CreatePanels()	
	self:InvalidateLayout()
end

function PANEL:UpdateBG()
	local t = {}
	for k,v in next,self.parts do
		if v.n then
			t[#t+1] = ("%s=%s"):format(v.name,v.n)
		end
	end
	
	RunConsoleCommand("outfitter_bodygroups_set",table.concat(t,","))
end

function PANEL:OnSelected(part,n)
	part.n=n
	self:UpdateBG()
end

function PANEL:CreatePanels()


	-- skin
	local r = self:Add("OFRadioBatton")
	r.OnSelected=function(r,setskin_id) 
		RunConsoleCommand("outfitter_skin_set",tostring(setskin_id))
		LocalPlayer().outfitter_skin = setskin_id
	end
	
	r:SetText("#skin")
	r:Dock(TOP)
	r:SizeToContents()

	for id,skindata in pairs(self.skins) do
		r:AddOption(skindata[1][1],tostring(id-1))
	end
	
	r:SetChecked(LocalPlayer().outfitter_skin or 1)

	local divider = self:Add("EditablePanel")
	divider:SetSize(1,16)
	divider:Dock(TOP)
	-- bodygroups
	local activeBodyGroups = LocalPlayer().outfitter_bodygroups or {}
	
	for k,part in next,self.parts do
		
		
		if #part.models<2 then continue end
		
		local r = self:Add("OFRadioBatton")
		r.OnSelected=function(r,n) self:OnSelected(part,n-1) end
		
		r:SetText(part.name:gsub("%.smd$","")
							:gsub("([a-z0-9])([A-Z])([a-z])",
								function(q,a,b) 
									return q..' '..a:lower()..b 
								end)
							:gsub("[_%.%-]"," ")
							:gsub("(%s)%s*","%1"))
		r:Dock(TOP)
		--r:SizeToContents()
		local n=0
		for k,partmdl in next,part.models do
			local name = partmdl.name
							:gsub("%.smd$","")
							:gsub("([a-z0-9])([A-Z])([a-z])",
								function(q,a,b) 
									return q..' '..a:lower()..b 
								end)
							:gsub("[_%.%-]"," ")
							:gsub("(%s)%s*","%1")
			name = name=="" and "" or name
			if name~="" then
				n=n+1
			end
			local n,pnl = r:AddOption(name=="" and "disable" or name,name=="" and "" or n)
			if name=="" then
				pnl:SetZPos(-10)
			end
		
		end
		
		r:SetChecked((activeBodyGroups[part.name] or 0)+1)
	end



end


function PANEL:SetModel(mdl)
	self.model = mdl
	self:Refresh()
end

function PANEL:PerformLayout()
	self:SizeToChildren(false,true)
end



bodygroups_factor=vgui.RegisterTable(PANEL,"EditablePanel")



function GUIOpenBodyGroupOverlay(owner,mdl)
	if not mdl then
		local l = UIGetMDLList()
		if not l then return end
		--print(l)
		local chosen = UIGetChosenMDL()
		if not chosen then return false end
		--print(chosen)
		mdl = l[chosen]
		if not mdl then return false end
		mdl = mdl.Name
		
		if not mdl then return false end
		if not file.Exists(mdl,'workshop') and not file.Exists(mdl,'GAME') then return false end
	end
	
	dbg("GUIOpenBodyGroupOverlay",mdl)
	
	local frame=vgui.Create('DFrame',nil,'bodygroups selector')
	frame:SetDraggable( false )
	frame:SetSizable( false )
	frame:SetScreenLock( true )
	frame:SetDeleteOnClose( true )
	frame:SetTitle( "Bodygroup and skin selector" )
	frame:ShowCloseButton(false)
	frame:SetIcon('icon16/group_edit.png')
	frame.pnlOwner = owner
	frame:MakePopup()
	frame:RequestFocus()
	function frame:Think()
		if not self.fframe then self.fframe=true return end
		
		if not self:IsActive() then print"noactive" self:Remove() return end
		if self.pnlOwner and (not self.pnlOwner:IsValid() or not self.pnlOwner:IsVisible()) then self:Remove() print"noparent" return end
		local x,y = self:GetPos()
		
		local w,h = self:GetSize()
		local sw,sh =ScrW(),ScrH()
		local nx,ny = (x+w)>sw and (sw-w) or x,
					  (y+h)>sh and (sh-h) or y
		if x~=nx or y~=ny then
			self:SetPos(nx,ny)
		end
	end
	

	local W,H=250,400 -- TODO: Autoscale GUI
	frame:SetSize(W,H)
	frame:SetPos(gui.MousePos())
	timer.Simple(60,function() 
		if IsValid(frame) then frame:Remove() end
	end)
	 
	local scrollpanel=vgui.Create('DScrollPanel',frame)
	scrollpanel:Dock(FILL)
	
	local bodygrouper=vgui.CreateFromTable(bodygroups_factor,scrollpanel)
	bodygrouper:Dock(TOP)
	bodygrouper:SetModel(mdl)
	return true
end


 
--GUIOpenBodyGroupOverlay()
--PATH addons/_pcasino/lua/autorun/pcasino_init.lua:
PerfectCasino = {}
PerfectCasino.Config = {}
PerfectCasino.Log = {}
PerfectCasino.Translation = {}
PerfectCasino.Core = {}
PerfectCasino.Sound = {}
PerfectCasino.UI = {}
PerfectCasino.Database = {}
PerfectCasino.Cooldown = {}
PerfectCasino.Chips = {}
PerfectCasino.MachineLimits = {}
if CLIENT then
	PerfectCasino.Spins = 0
else
	PerfectCasino.Spins = {}
end

print("Loading PerfectCasino")

local path = "PerfectCasino/"
if SERVER then
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
		print("Loading folder:", folder)
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        AddCSLuaFile(path .. folder .. "/" .. File)
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sv_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        AddCSLuaFile(path .. folder .. "/" .. File)
	    end
	end
end

if CLIENT then
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
		print("Loading folder:", folder)
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end

	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	    	print("	Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end
	end

	
	hook.Add("PostDrawHUD", "_pcasino_fixfonts", function()
		include(path.."derma/cl_fonts.lua") 
		hook.Remove("PostDrawHUD", "_pcasino_fixfonts")
	end)
end
print("Loaded PerfectCasino")



--PATH addons/____plogs/lua/plogs/core_sh.lua:
--[[
addons/lgos/lua/plogs/core_sh.lua
--]]

CAMI.RegisterPrivilege({
    Name = 'plogs_access',
    MinAccess = 'superadmin',
    Description = 'Access Logs'
})

CAMI.RegisterPrivilege({
    Name = 'plogs_ip_access',
    MinAccess = 'superadmin',
    Description = 'Access Logs IP'
})

function plogs.Register(type, network, color)
	plogs.types[type] = plogs.types[type] or {
		Type 	= type, 
		Network = network and plogs.cfg.EchoServer or network, 
		Color 	= color
	}
	plogs.data[type] = plogs.data[type] or {}
	return t
end

local count = 0
function plogs.AddHook(hook_name, func)
	if (SERVER) then
		hook.Add(hook_name, 'plogs.loghook.' .. count .. '.' .. hook_name, func)
		count = count + 1
	end
end

function plogs.Encode(data)
	return util.Compress(pon1.encode(data))
end

function plogs.Decode(data)
	return pon1.decode(util.Decompress(data))
end

function plogs.GetSaves()
	local files = file.Find('plogs/saves/*.dat', 'DATA', 'datedesc')
	for k, v in ipairs(files) do
		files[k] = string.StripExtension(v)
	end
	return files
end

function plogs.OpenSave(name)
	return plogs.Decode(file.Read('plogs/saves/' .. name .. '.dat', 'DATA'))
end

function plogs.DeleteSave(name)
	file.Delete('plogs/saves/' .. name .. '.dat')
end

function plogs.SaveExists(name)
	return file.Exists('plogs/saves/' .. string.Trim(name) .. '.dat', 'DATA')
end

function plogs.SaveLog(name, tbl)
	file.Write('plogs/saves/' .. string.Trim(name) .. '.dat', plogs.Encode(tbl)) 
end


--PATH addons/____sam/lua/sam/libs/sh_types.lua:
if SAM_LOADED then return end

-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sam.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sam["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sam.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sam.IsEntity = sam.isentity

local type = sam.type
function sam.istable(value)
	return type(value) == "table"
end
--PATH addons/____sam/lua/sam/libs/sh_pon.lua:
if SAM_LOADED then return end

--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  -		 k,v - pointers
 - strings -		 k,v - pointers
 - numbers -		k,v
 - booleans-		 k,v

 - Vectors -		 k,v
 - Angles  -		k,v
 - Entities-		 k,v
 - Players -		 k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]
local pon = {}
sam.pon = pon

do
	local type = sam.type
	local IsColor = IsColor
	local tonumber = tonumber
	local format = string.format
	local encode = {}
	local cacheSize = 0

	encode['table'] = function(self, tbl, output, cache)
		if cache[tbl] then
			output[#output + 1] = format('(%x)', cache[tbl])

			return
		else
			cacheSize = cacheSize + 1
			cache[tbl] = cacheSize
		end

		local first = next(tbl, nil)
		local predictedNumeric = 1

		-- starts with a numeric dealio
		if first == 1 then
			output[#output + 1] = '{'

			for k, v in next, tbl do
				if k == predictedNumeric then
					predictedNumeric = predictedNumeric + 1
					local tv = type(v)

					if tv == 'string' then
						local pid = cache[v]

						if pid then
							output[#output + 1] = format('(%x)', pid)
						else
							cacheSize = cacheSize + 1
							cache[v] = cacheSize
							self.string(self, v, output, cache)
						end
					elseif IsColor(v) then
						self.Color(self, v, output, cache)
					else
						self[tv](self, v, output, cache)
					end
				else
					break
				end
			end

			predictedNumeric = predictedNumeric - 1
		else
			predictedNumeric = nil
		end

		if predictedNumeric == nil then
			output[#output + 1] = '[' -- no array component
		else
			output[#output + 1] = '~' -- array component came first so shit needs to happen
		end

		for k, v in next, tbl, predictedNumeric do
			local tk, tv = type(k), type(v)
			if not self[tk] or not self[tv] then continue end

			-- WRITE KEY
			if tk == 'string' then
				local pid = cache[k]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[k] = cacheSize
					self.string(self, k, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tk](self, k, output, cache)
			end

			-- WRITE VALUE
			if tv == 'string' then
				local pid = cache[v]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[v] = cacheSize
					self.string(self, v, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tv](self, v, output, cache)
			end
		end

		output[#output + 1] = '}'
	end

	--	ENCODE STRING
	local gsub = string.gsub

	encode['string'] = function(self, str, output)
		--if tryCache(str, output then return end
		local estr, count = gsub(str, ';', "\\;")

		if count == 0 then
			output[#output + 1] = '\'' .. str .. ';'
		else
			output[#output + 1] = '"' .. estr .. '";'
		end
	end

	--	ENCODE NUMBER
	encode['number'] = function(self, num, output)
		if num % 1 == 0 then
			if num < 0 then
				output[#output + 1] = format('x%x;', -num)
			else
				output[#output + 1] = format('X%x;', num)
			end
		else
			output[#output + 1] = tonumber(num) .. ';'
		end
	end

	--	ENCODE BOOLEAN
	encode['boolean'] = function(self, val, output)
		output[#output + 1] = val and 't' or 'f'
	end

	--	ENCODE VECTOR
	encode['Vector'] = function(self, val, output)
		output[#output + 1] = ('v' .. val.x .. ',' .. val.y) .. (',' .. val.z .. ';')
	end

	--	ENCODE ANGLE
	encode['Angle'] = function(self, val, output)
		output[#output + 1] = ('a' .. val.p .. ',' .. val.y) .. (',' .. val.r .. ';')
	end

	encode['Entity'] = function(self, val, output)
		output[#output + 1] = 'E' .. (IsValid(val) and (val:EntIndex() .. ';') or '#')
	end

	encode['Player'] = encode['Entity']
	encode['Vehicle'] = encode['Entity']
	encode['Weapon'] = encode['Entity']
	encode['NPC'] = encode['Entity']
	encode['NextBot'] = encode['Entity']
	encode['PhysObj'] = encode['Entity']

	encode['Color'] = function(self, val, output)
		output[#output + 1] = ('C' .. val.r .. ',' .. val.g .. ',' .. val.b) .. (',' .. val.a .. ';')
	end

	encode['console'] = function(self, val, output)
		output[#output + 1] = 's'
	end

	encode['nil'] = function(self, val, output)
		output[#output + 1] = '?'
	end

	encode.__index = function(key)
		ErrorNoHalt('Type: ' .. key .. ' can not be encoded. Encoded as as pass-over value.')

		return encode['nil']
	end

	do
		local concat = table.concat

		function pon.encode(tbl)
			local output = {nil, nil, nil, nil, nil, nil, nil, nil}
			cacheSize = 0
			encode['table'](encode, tbl, output, {})

			return concat(output)
		end
	end
end

do
	local tonumber = tonumber
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode
	local Vector, Angle, Entity = Vector, Angle, Entity
	local decode = {}

	decode['{'] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tv = sub(str, index, index)

			if not tv or tv == '~' then
				index = index + 1
				break
			end

			if tv == '}' then return index + 1, cur end
			-- READ THE VALUE
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
			k = k + 1
		end

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	decode['['] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			if not k then continue end
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1

			if not self[tv] then
				print('did not find type: ' .. tv)
			end

			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	-- STRING
	decode['"'] = function(self, index, str, cache)
		local finish = find(str, '";', index, true)
		local res = gsub(sub(str, index, finish - 1), '\\;', ';')
		index = finish + 2
		cache[#cache + 1] = res

		return index, res
	end

	-- STRING NO ESCAPING NEEDED
	decode['\''] = function(self, index, str, cache)
		local finish = find(str, ';', index, true)
		local res = sub(str, index, finish - 1)
		index = finish + 1
		cache[#cache + 1] = res

		return index, res
	end

	-- NUMBER
	decode['n'] = function(self, index, str)
		index = index - 1
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, num
	end

	decode['0'] = decode['n']
	decode['1'] = decode['n']
	decode['2'] = decode['n']
	decode['3'] = decode['n']
	decode['4'] = decode['n']
	decode['5'] = decode['n']
	decode['6'] = decode['n']
	decode['7'] = decode['n']
	decode['8'] = decode['n']
	decode['9'] = decode['n']
	decode['-'] = decode['n']

	-- positive hex
	decode['X'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- negative hex
	decode['x'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = -tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- POINTER
	decode['('] = function(self, index, str, cache)
		local finish = find(str, ')', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, cache[num]
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode['t'] = function(self, index) return index, true end
	decode['f'] = function(self, index) return index, false end

	-- VECTOR
	decode['v'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local vecStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', vecStr, false)

		return index, Vector(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ANGLE
	decode['a'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local angStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', angStr, false)

		return index, Angle(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ENTITY
	decode['E'] = function(self, index, str)
		if str[index] == '#' then
			index = index + 1

			return index, NULL
		else
			local finish = find(str, ';', index, true)
			local num = tonumber(sub(str, index, finish - 1))
			index = finish + 1

			return index, Entity(num)
		end
	end

	-- COLOR
	decode['C'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local colStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', colStr, false)

		return index, Color(segs[1], segs[2], segs[3], segs[4])
	end

	-- PLAYER
	decode['P'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, Entity(num) or NULL
	end

	-- NIL
	decode['?'] = function(self, index) return index + 1, nil end
	-- SAM CONSOLE
	decode['s'] = function(self, index) return index, sam.console end

	function pon.decode(data)
		local _, res = decode[sub(data, 1, 1)](decode, 2, data, {})

		return res
	end
end
--PATH addons/____sam/lua/sam/sh_lang.lua:
if SAM_LOADED then return end

local lang = sam.load_file("sam_language.lua", "sh")

local original = lang
if not isstring(lang) then
	lang = "english"
end

local lang_path = "sam_languages/" .. lang .. ".lua"

if not file.Exists(lang_path, "LUA") then
	lang_path = "sam_languages/english.lua"
	if not file.Exists(lang_path, "LUA") then
		-- maybe they deleted english lang????
		sam.print("SAM is broken!")
		sam.print("Language '" .. tostring(original) .. "' doesn't exist and 'english' language file doesn't exist")
		return false
	else
		sam.print("Language '" .. tostring(original) .. "' doesn't exist falling back to english")
	end
end

local Language = sam.load_file(lang_path, "sh_")

local sub, find = string.sub, string.find

local white_color = Color(236, 240, 241)

do
	local args = {}
	function sam.add_message_argument(arg, func)
		if isstring(arg) and isfunction(func) then
			args[arg] = func
		end
	end

	local insert = function(t, v)
		t.__cnt = t.__cnt + 1
		t[t.__cnt] = v
	end

	function sam.format_message(msg, tbl, result, result_n)
		msg = Language[msg] or msg

		result = result or {}
		result.__cnt = result_n or 0

		local pos = 0
		local start, _end, arg, arg2 = nil, 0, nil, nil

		while true do
			start, _end, arg, arg2 = find(msg, "%{ *([%w_%#]+)([^%{}]-) *%}", _end)
			if not start then break end

			if pos ~= start then
				local txt = sub(msg, pos, start - 1)
				if txt ~= "" then
					insert(result, white_color)
					insert(result, txt)
				end
			end

			local ma = args[sub(arg, 1, 1)]
			if not ma then
				insert(result, "{" .. arg .. " " .. arg2 .. "}")
			else
				ma(result, tbl and tbl[arg], arg, unpack(arg2:Trim():Split(" ")))
			end

			pos = _end + 1
		end

		if pos <= #msg then
			insert(result, white_color)
			insert(result, sub(msg, pos))
		end

		return result
	end

	/*
		Admin
	*/
	sam.add_message_argument("A", function(result, admin)
		if sam.isconsole(admin) then
			-- we need to show that it's the real console!!!!!
			insert(result, Color(236, 240, 241))
			insert(result, "*")
			insert(result, Color(13, 130, 223))
			insert(result, "Console")
		else
			if sam.type(admin) == "Player" then
				if CLIENT and LocalPlayer() == admin then
					insert(result, Color(255, 215, 0))
					insert(result, sam.language.get("You"))
				else
					insert(result, Color(13, 130, 223))
					insert(result, admin:Name())
				end
			else
				insert(result, Color(13, 130, 223))
				insert(result, admin)
			end
		end
	end)

	/*
		Target(s)
	*/
	sam.add_message_argument("T", function(result, targets)
		for k, v in ipairs(sam.get_targets_list(targets)) do
			insert(result, v)
		end
	end)

	/*
		Value(s)
	*/
	sam.add_message_argument("V", function(result, value)
		insert(result, Color(0, 230, 64))
		insert(result, tostring(value))
	end)

	/*
		Text(s)
	*/
	sam.add_message_argument("S", function(result, text, _, color)
		insert(result, sam.get_color(color) or white_color)
		insert(result, tostring(text))
	end)

	-- https://gist.github.com/fernandohenriques/12661bf250c8c2d8047188222cab7e28
	local hex_rgb = function(hex)
		local r, g, b
		if #hex == 4 then
			r, g, b = tonumber(hex:sub(2, 2), 16) * 17, tonumber(hex:sub(3, 3), 16) * 17, tonumber(hex:sub(4, 4), 16) * 17
		else
			r, g, b = tonumber(hex:sub(2, 3), 16), tonumber(hex:sub(4, 5), 16), tonumber(hex:sub(6, 7), 16)
		end

		if not r or not g or not b then
			return color_white
		end

		return Color(r, g, b)
	end

	/*
		Colored Text(s)
	*/
	sam.add_message_argument("#", function(result, _, color, ...)
		local text = table.concat({...}, " ")
		insert(result, hex_rgb(color))
		insert(result, text)
	end)
end

function sam.get_message(msg)
	msg = Language[msg]
	if not msg then
		return false
	else
		return {Color(236, 240, 241), msg}
	end
end

function sam.language.get(key)
	return Language[key]
end

function sam.language.Add(key, value)
	Language[key] = value
end
--PATH addons/____sam/lua/sam_language.lua:
return "ukrainian"
--PATH addons/____sam/lua/sam/config/sh_config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

sam.permissions.add("manage_config", nil, "superadmin")

local updates = {}
function config.hook(keys, func)
	for i = #keys, 1, -1 do
		keys[keys[i]] = true
		keys[i] = nil
	end

	local id = table.insert(updates, {
		keys = keys,
		func = func
	})

	if config.loaded then
		func()
	end

	return id
end

function config.get_updated(key, default)
	local setting = {}
	config.hook({key}, function()
		setting.value = config.get(key, default)
	end)
	return setting
end

function config.remove_hook(key)
	updates[key] = nil
end

hook.Add("SAM.LoadedConfig", "RunHooks", function()
	for k, v in pairs(updates) do
		v.func()
	end
end)

hook.Add("SAM.UpdatedConfig", "RunHooks", function(key, value, old)
	for k, v in pairs(updates) do
		if v.keys[key] then
			v.func(value, old)
		end
	end
end)
--PATH addons/____sam/lua/sam/command/cl_command.lua:
if SAM_LOADED then return end

local sam = sam
local command = sam.command

local get_syntax = function(args, cmd_args, cmd_str)
	for i = 1, #cmd_args do
		cmd_str = cmd_str .. " "

		local cmd_arg = cmd_args[i]
		local arg = args[i]

		if arg == "" then
			arg = nil
		end

		local optional = cmd_arg.optional
		local c_1, c_2 = "<", ">"
		if optional then
			c_1, c_2 = "[", "]"
		end

		cmd_str = cmd_str .. (arg and "\"" or c_1)

		cmd_str = cmd_str .. (arg or cmd_arg.hint or cmd_arg.name)

		if not arg then
			local default = cmd_arg.default
			if default then
				cmd_str = cmd_str .. " = " .. tostring(default)
			end
		end

		cmd_str = cmd_str .. (arg and "\"" or c_2)
	end

	return cmd_str
end

--
-- Auto Complete
--
concommand.Add("sam", function(_, _, _, text)
	LocalPlayer():ConCommand("sam_run " .. text)
end, function(_, text)
	local ply = LocalPlayer()
	local result = {}

	local new_arg = text:EndsWith(" ")
	local args = sam.parse_args(text)

	local cmd_name = (args[1] or ""):lower()
	local cmd = command.get_command(cmd_name)

	if not cmd or (#args == 1 and not new_arg) then
		local commands = command.get_commands()

		for _, v in ipairs(commands) do
			local name = v.name
			if name:find(cmd_name, nil, true) and ply:HasPermission(name) then
				table.insert(result, "sam " .. name)
			end
		end

		return result
	end

	if not ply:HasPermission(cmd_name) then return end

	table.remove(args, 1)

	if new_arg then
		local syntax = get_syntax(args, cmd.args, "sam " .. cmd.name)
		if #args == 0 then
			print(syntax)
		end
		table.insert(result, syntax)
		return result
	end

	local arg_index = new_arg and #args + 1 or #args

	local cmd_args = cmd.args
	local cmd_args_n = #cmd_args
	if cmd_args_n == 0 then return end

	if arg_index >= cmd_args_n then
		arg_index = cmd_args_n

		if cmd.get_rest_args then
			local arg = table.concat(args, " ", cmd_args_n)
			if arg ~= "" then
				args[cmd_args_n] = arg
				for i = cmd_args_n + 1, #args do
					args[i] = nil
				end
			end
		end
	end

	local arguments = command.get_arguments()
	local cmd_arg = cmd_args[arg_index]
	local func = arguments[cmd_arg.name].auto_complete
	if func then
		func(cmd_arg, result, args[arg_index] or "")
	end

	local cmd_str = "sam " .. cmd_name .. " "
	if arg_index - 1 > 0 then
		cmd_str = cmd_str .. "\"" .. table.concat(args, "\" ", 1, arg_index - 1) .. "\" "
	end

	for k, v in ipairs(result) do
		result[k] = cmd_str .. "\"" .. v .. "\""
	end

	return result
end)

concommand.Add("ba", function(_, _, _, text)
	LocalPlayer():ConCommand("ba_run " .. text)
end, function(_, text)
	local ply = LocalPlayer()
	local result = {}

	local new_arg = text:EndsWith(" ")
	local args = sam.parse_args(text)

	local cmd_name = (args[1] or ""):lower()
	local cmd = command.get_command(cmd_name)

	if not cmd or (#args == 1 and not new_arg) then
		local commands = command.get_commands()

		for _, v in ipairs(commands) do
			local name = v.name
			if name:find(cmd_name, nil, true) and ply:HasPermission(name) then
				table.insert(result, "sam " .. name)
			end
		end

		return result
	end

	if not ply:HasPermission(cmd_name) then return end

	table.remove(args, 1)

	if new_arg then
		local syntax = get_syntax(args, cmd.args, "sam " .. cmd.name)
		if #args == 0 then
			print(syntax)
		end
		table.insert(result, syntax)
		return result
	end

	local arg_index = new_arg and #args + 1 or #args

	local cmd_args = cmd.args
	local cmd_args_n = #cmd_args
	if cmd_args_n == 0 then return end

	if arg_index >= cmd_args_n then
		arg_index = cmd_args_n

		if cmd.get_rest_args then
			local arg = table.concat(args, " ", cmd_args_n)
			if arg ~= "" then
				args[cmd_args_n] = arg
				for i = cmd_args_n + 1, #args do
					args[i] = nil
				end
			end
		end
	end

	local arguments = command.get_arguments()
	local cmd_arg = cmd_args[arg_index]
	local func = arguments[cmd_arg.name].auto_complete
	if func then
		func(cmd_arg, result, args[arg_index] or "")
	end

	local cmd_str = "sam " .. cmd_name .. " "
	if arg_index - 1 > 0 then
		cmd_str = cmd_str .. "\"" .. table.concat(args, "\" ", 1, arg_index - 1) .. "\" "
	end

	for k, v in ipairs(result) do
		result[k] = cmd_str .. "\"" .. v .. "\""
	end

	return result
end)
--PATH addons/____sam/lua/sam/command/arguments/dropdown.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("dropdown")
    :OnExecute(function(arg, input, ply, _, result)
        if not arg.options or table.Empty(arg.options) then
            ply:sam_send_message("no data", {S = "dropdown", S_2 = input})
            return
        end

        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value)
            set_result(value)
            default = value
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            if not arg.options then
                LocalPlayer():sam_send_message("dropdown has no options data")
                return
            end

            for k, v in pairs(arg.options) do
                self:AddChoice(v)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()
--PATH addons/____sam/lua/sam/command/arguments/length.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local get_length = function(arg, input)
	if (input == "" or input == nil) and arg.optional then
		if arg.default ~= nil then
			return arg.default
		end

		return ""
	end

	return sam.parse_length(input)
end

command.new_argument("length")
	:OnExecute(function(arg, input, ply, _, result, i)
		local length = get_length(arg, input)
		if length == "" then
			result[i] = nil
		elseif not length then
			ply:sam_send_message("invalid", {
				S = "length", S_2 = input
			})
			return false
		else
			if arg.min and length ~= 0 then
				length = math.max(length, arg.min)
			end

			if arg.max then
				if length == 0 then
					length = arg.max
				else
					length = math.min(length, arg.max)
				end
			end

			result[i] = length
		end
	end)

	:Menu(function(set_result, body, buttons, argument)
		local length_input = buttons:Add("SAM.TextEntry")
		length_input:SetTall(25)

		length_input:SetCheck(function(new_limit)
			new_limit = get_length(argument, new_limit) or nil
			set_result(new_limit)
			return new_limit or false
		end)

		local hint = argument.hint or "length"
		if argument.default then
			hint = hint .. " = " .. tostring(argument.default)
		end

		length_input:SetPlaceholder(hint)
		return length_input
	end)
:End()
--PATH addons/____sui/lua/sui/vgui/sui_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_bValue", "Value", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMin", "Min", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMax", "Max", FORCE_NUMBER)
AccessorFunc(Panel, "m_bDecimals", "Decimals", FORCE_NUMBER)


AccessorFunc(Panel, "m_fSlideX", "SlideX")
AccessorFunc(Panel, "m_fSlideY", "SlideY")

AccessorFunc(Panel, "m_iLockX", "LockX")
AccessorFunc(Panel, "m_iLockY", "LockY")

AccessorFunc(Panel, "Dragging", "Dragging")

function Panel:Init()
	self:ScaleInit()

	self:SetSlideX(0.5)
	self:SetSlideY(0.5)

	self:SetMouseInputEnabled(true)
	self:SetMin(0)
	self:SetMax(10)
	self:SetValue(1)
	self:SetDecimals(1)

	self:SetSize(100, 12)

	self.rounded_box = {}

	self.Knob = vgui.Create("DButton", self)
	self.Knob:SetText("")
	self.Knob:SetSize(15, 15)
	self.Knob:NoClipping(true)
	self.Knob.Paint = self.KnobPaint
	self.Knob.OnCursorMoved = function(panel, x, y)
		x, y = panel:LocalToScreen(x, y)
		x, y = self:ScreenToLocal(x, y)
		self:OnCursorMoved(x, y)
	end
	self.Knob.circle = {}

	self:SetLockY(0.5)
end

function Panel:IsEditing()
	return self.Dragging or self.Knob.Depressed
end

function Panel:SetEnabled(b)
	self.Knob:SetEnabled(b)
	FindMetaTable("Panel").SetEnabled(self, b) -- There has to be a better way!
end

function Panel:OnCursorMoved(x, y)
	if (not self.Dragging and not self.Knob.Depressed) then return end

	local w, h = self:GetSize()
	local iw, ih = self.Knob:GetSize()

	w = w - iw
	h = h - ih

	x = x - iw * 0.5
	y = y - ih * 0.5

	x = math.Clamp(x, 0, w) / w
	y = math.Clamp(y, 0, h) / h

	if self.m_iLockX then x = self.m_iLockX end
	if self.m_iLockY then y = self.m_iLockY end

	x, y = self:TranslateValues(x, y)

	self:SetSlideX(x)
	self:SetSlideY(y)

	self:InvalidateLayout()
end

function Panel:OnMousePressed(mcode)
	if not self:IsEnabled() then return true end

	-- When starting dragging with not pressing on the knob.
	self.Knob.Hovered = true

	self:SetDragging(true)
	self:MouseCapture(true)

	local x, y = self:CursorPos()
	self:OnCursorMoved(x, y)
end

function Panel:OnMouseReleased(mcode)
	-- This is a hack. Panel.Hovered is not updated when dragging a panel (Source's dragging, not Lua Drag'n'drop)
	self.Knob.Hovered = vgui.GetHoveredPanel() == self.Knob

	self:SetDragging(false)
	self:MouseCapture(false)
end

function Panel:SetMinMax(min, max)
	self:SetMin(min)
	self:SetMax(max)
end

function Panel:TranslateValues(x, y)
	self:SetValue(self:GetMin() + (x * self:GetRange()))
	return self:GetFraction(), y
end

function Panel:GetFraction()
	return (self:GetValue() - self:GetMin()) / self:GetRange()
end

function Panel:SetValue(val)
	val = math.Clamp(val, self:GetMin(), self:GetMax())
	val = math.Round(val, self:GetDecimals())

	self.m_bValue = val
	self:SetSlideX((val - self:GetMin()) / self:GetRange())

	self:OnValueChanged(val)
end

function Panel:OnValueChanged(val)
end

function Panel:GetRange()
	return self:GetMax() - self:GetMin()
end

function Panel:Paint(w, h)
	local _h = SUI.Scale(2)
	TDLib.RoundedBox(self.rounded_box, 3, 0, h * 0.5 - _h * 0.5, w, _h, SUI.GetColor("slider_track"))
end

function Panel:KnobPaint(w, h)
	if self.Depressed then
		TDLib.DrawCircle(self.circle, w * 0.5, h * 0.5, h / 1.1, SUI.GetColor("slider_pressed"))
	elseif self.Hovered then
		TDLib.DrawCircle(self.circle, w * 0.5, h * 0.5, h / 1.1, SUI.GetColor("slider_hover"))
	end

	TDLib.DrawCircle(self.circle, w * 0.5, h * 0.5, h * 0.5, SUI.GetColor("slider_knob"))
end

function Panel:PerformLayout(w, h)
	local knob_size = SUI.Scale(12)
	self.Knob:SetSize(knob_size, knob_size)

	w = w - knob_size
	h = h - knob_size
	self.Knob:SetPos((self.m_fSlideX or 0) * w, (self.m_fSlideY or 0) * h)
end

function Panel:SetSlideX(i)
	self.m_fSlideX = i
	self:InvalidateLayout()
end

function Panel:SetSlideY(i)
	self.m_fSlideY = i
	self:InvalidateLayout()
end

function Panel:GetDragging()
	return self.Dragging or self.Knob.Depressed
end

sui.register("Slider", Panel, "Panel")

--PATH addons/____sam/lua/sam/modules/utime.lua:
if SAM_LOADED then return end

local PLAYER = FindMetaTable("Player")

function PLAYER:GetUTime()
	return self:sam_get_nwvar("TotalUTime")
end

function PLAYER:SetUTime(time)
	self:sam_set_nwvar("TotalUTime", time)
end

function PLAYER:GetUTimeStart()
	return self:sam_get_nwvar("UTimeStart")
end

function PLAYER:SetUTimeStart(time)
	self:sam_set_nwvar("UTimeStart", time)
end

function PLAYER:GetUTimeSessionTime()
	return CurTime() - self:GetUTimeStart()
end

function PLAYER:GetUTimeTotalTime()
	return self:GetUTime() + CurTime() - self:GetUTimeStart()
end

if SERVER then
	hook.Add("SAM.AuthedPlayer", "SAM.UTime", function(ply)
		ply:SetUTime(ply:sam_get_play_time())
		ply:SetUTimeStart(CurTime())
	end)
end
--PATH addons/____sam/lua/sam/cl_adverts.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local times = {}

local entry_OnValueChange = function(s)
	s:SetTall(s:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
end

local entry_OnEnter = function(s)
	local ads = config.get("Adverts", {})
	local txt = s:GetText()
	if txt == "" then
		s:Remove()
		if s.i then
			table.remove(ads, s.i)
		end
	else
		if txt == s.ad then return end
		ads[s.i] = txt
		s.ad = txt
	end
	config.set("Adverts", ads, true)
end

local entry_OnKeyCodeTyped = function(s, code)
	if code == KEY_ENTER then
		s:old_OnKeyCodeTyped(code)
		return true
	else
		return s:old_OnKeyCodeTyped(code)
	end
end

config.add_menu_setting("Adverts", function(body)
	local adverts_body

	local adverts = body:Add("SAM.LabelPanel")
	adverts:Dock(TOP)
	adverts:DockMargin(8, 6, 8, 0)
	adverts:SetLabel("Adverts\n- Random adverts print every 60 seconds\n- Timed adverts can be done like this: {1m} This advert prints every 1 minute")

	local add_advert = adverts:Add("SAM.Button")
	add_advert:SetText("+")
	add_advert:SetSize(25, 25)

	local zpos = 0
	local add_func = function(ad, ad_i)
		zpos = zpos + 1

		local entry = adverts_body:Add("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetNoBar(true)
		entry:Dock(TOP)
		entry:DockMargin(8, 6, 8, 0)
		entry:SetZPos(zpos)
		entry.ad = ad
		entry.no_scale = true

		if not sam.ispanel(ad) then
			entry.i = ad_i
			entry:SetValue(ad)
		else
			entry.i = #config.get("Adverts", {}) + 1
		end

		entry.OnValueChange = entry_OnValueChange
		entry.OnEnter = entry_OnEnter
		entry.old_OnKeyCodeTyped = entry.OnKeyCodeTyped
		entry.OnKeyCodeTyped = entry_OnKeyCodeTyped
	end
	add_advert:On("DoClick", add_func)

	adverts_body = body:Add("Panel")
	adverts_body:Dock(TOP)

	function adverts_body:PerformLayout(w, h)
		for k, v in ipairs(self:GetChildren()) do
			entry_OnValueChange(v)
		end
		self:SizeToChildren(false, true)
	end

	sam.config.hook({"Adverts"}, function()
		if not IsValid(adverts_body) then return end
		adverts_body:Clear()

		for k, v in ipairs(config.get("Adverts", {})) do
			add_func(v, k)
		end
	end)
end)

local random = {}

timer.Create("SAM.Advert.RandomAdverts", 60, 0, function()
	local ad = random[math.random(1, #random)]
	if not ad then return end
	sam.player.send_message(nil, ad)
end)

sam.config.hook({"Adverts"}, function()
	for i = #times, 1, -1 do
		times[i] = nil
		timer.Remove("SAM.Adverts." .. i)
	end

	random = {}
	for k, v in ipairs(config.get("Adverts", {})) do
		if v:sub(1, 1) == "{" then
			local time, message = v:match("(%b{}) *(.*)")
			time = sam.parse_length(time)
			if time then
				timer.Create("SAM.Adverts." .. table.insert(times, true), time * 60, 0, function()
					sam.player.send_message(nil, message)
				end)
			else
				table.insert(random, v)
			end
		else
			table.insert(random, v)
		end
	end
end)

--PATH addons/__________911emergencyresponse/lua/emergencyresponse/sh_config.lua:
EmergencyDispatch = EmergencyDispatch or {}
EmergencyResponse = EmergencyResponse or {}
EmergencyDispatch.Sound = {}
EmergencyDispatch.DispatchCallouts = {}
EmergencyDispatch.ColorsConfiguration = {}
emergencymodNotificationSave = emergencymodNotificationSave or {}
--PATH addons/protection/lua/autorun/sh_better_logs.lua:

local select = select
local tostring = tostring
local type = type
local MsgC = MsgC
local IsColor = IsColor
local os_date = os.date
local debug_getinfo = debug.getinfo

Logging = Logging or {}
Logging.fileColors = Logging.fileColors or {}
Logging.fileColorsIncr = Logging.fileColorsIncr or 0
Logging.colors = {
    NIL      = "#ed8796",
    NUMBER   = "#f5a97f",
    NICK     = "#91d7e3",
    DATE     = "#a6da95",
    LOCATION = "#5b6078",
    OTHER    = "#cad3f5"
}

for colorName, hexCode in pairs(Logging.colors) do
    hexCode = hexCode:sub(2)

    local r = tonumber(hexCode:sub(1, 2), 16)
    local g = tonumber(hexCode:sub(3, 4), 16)
    local b = tonumber(hexCode:sub(5, 6), 16)

    Logging.colors[colorName] = Color(r, g, b)
end

local function prettify(tbl, len)
    local result = {}
    local j = 1
    for i = 1, len do
        local value = tbl[i]
        local valueType = type(value)
        if value == nil then
            result[j] = Logging.colors.NIL
            result[j + 1] = "nil "
            j = j + 1
        elseif valueType == "number" then
            result[j] = Logging.colors.NUMBER
            result[j + 1] = tostring(value) .. " "
            j = j + 1
        elseif valueType == "table" then
            if IsColor(value) then
                result[j] = value
                result[j + 1] = "Color"
                result[j + 2] = Logging.colors.OTHER

                result[j + 3] = "("

                result[j + 4] = Logging.colors.NUMBER
                result[j + 5] = value.r
                result[j + 6] = Logging.colors.OTHER
                result[j + 7] = ", "

                result[j + 8] = Logging.colors.NUMBER
                result[j + 9] = value.g
                result[j + 10] = Logging.colors.OTHER
                result[j + 11] = ", "

                result[j + 12] = Logging.colors.NUMBER
                result[j + 13] = value.b
                result[j + 14] = Logging.colors.OTHER

                j = j + 15
                if value.a != 255 then
                    result[j    ] = ", "
                    result[j + 1] = Logging.colors.NUMBER
                    result[j + 2] = value.a
                    result[j + 3] = Logging.colors.OTHER
                    j = j + 3
                end

                result[j] = ") "
            else
                result[j    ] = Logging.colors.OTHER
                result[j + 1] = "table#"
                result[j + 2] = Logging.colors.NUMBER
                result[j + 3] = #value
                result[j + 4] = Logging.colors.OTHER
                result[j + 5] = "->"
                result[j + 6] = Logging.colors.NUMBER
                result[j + 7] = ("%p "):format(value)
                j = j + 7
            end
        elseif valueType == "Player" then
            result[j    ] = Logging.colors.OTHER
            result[j + 1] = "Player ["
            result[j + 2] = Logging.colors.NUMBER
            result[j + 3] = IsValid(value) and value:UserID() or 'NONE'
            result[j + 4] = Logging.colors.OTHER
            result[j + 5] = "]["
            result[j + 6] = Logging.colors.NICK
            result[j + 7] = IsValid(value) and value:Nick() or 'NONE'
            result[j + 8] = Logging.colors.OTHER
            result[j + 9] = "] "
            j = j + 9
        elseif valueType == "Vector" then
            result[j    ] = Logging.colors.OTHER

            result[j + 1] = "Vector("

            result[j + 2] = Logging.colors.NUMBER
            result[j + 3] = ("%.2f"):format(value.x)
            result[j + 4] = Logging.colors.OTHER
            result[j + 5] = ", "

            result[j + 6] = Logging.colors.NUMBER
            result[j + 7] = ("%.2f"):format(value.y)
            result[j + 8] = Logging.colors.OTHER
            result[j + 9] = ", "

            result[j + 10] = Logging.colors.NUMBER
            result[j + 11] = ("%.2f"):format(value.z)
            result[j + 12] = Logging.colors.OTHER
            result[j + 13] = ") "
            j = j + 13
        elseif valueType == "Angle" then
            result[j    ] = Logging.colors.OTHER

            result[j + 1] = "Angle("

            result[j + 2] = Logging.colors.NUMBER
            result[j + 3] = ("%.1f"):format(value.p)
            result[j + 4] = Logging.colors.OTHER
            result[j + 5] = ", "

            result[j + 6] = Logging.colors.NUMBER
            result[j + 7] = ("%.1f"):format(value.y)
            result[j + 8] = Logging.colors.OTHER
            result[j + 9] = ", "

            result[j + 10] = Logging.colors.NUMBER
            result[j + 11] = ("%.1f"):format(value.r)
            result[j + 12] = Logging.colors.OTHER
            result[j + 13] = ") "
            j = j + 13
        else
            result[j] = Logging.colors.OTHER
            result[j + 1] = tostring(value) .. " "
            j = j + 1
        end

        j = j + 1
    end

    result[j] = "\n"

    return result
end

function print(...)
    local numArgs = select("#", ...)
    local args = {...}
    args = prettify(args, numArgs)

    local info = debug_getinfo(2, "nS")
    local srcPath = "???"
    local funcName = info and info.name or "UNK"
    local lineDefined = info and info.linedefined or "?"
    if info and info.source then
        srcPath = info.source:sub(2)
        srcPath = srcPath:match(".+/(.+)$") or srcPath
    end

    local timeZone = os_date("%z")
    local timeUtc = os_date("!%X")
    local timeFormatted = ("[%s%s] "):format(timeUtc, timeZone)

    local srcPathColor = Logging.fileColors[srcPath]
    if !srcPathColor then
        srcPathColor = HSVToColor(Logging.fileColorsIncr * 100 % 360, 0.8, 1)
        Logging.fileColors[srcPath] = srcPathColor
        Logging.fileColorsIncr = Logging.fileColorsIncr + 1
    end

    MsgC(Logging.colors.DATE, timeFormatted,
         srcPathColor, srcPath,
         Logging.colors.OTHER, ":",
         Logging.colors.LOCATION, funcName,
         Logging.colors.OTHER, ":",
         Logging.colors.NUMBER, lineDefined, " ",
         unpack(args))
end

/*
if SERVER then
    concommand.Add("__gibfps", function(ply, _, args)
        -- if tonumber(args[1]) < 17 then return end
        -- print(ply, args[1])
    end)
elseif system.HasFocus() then
    RunConsoleCommand("__gibfps", 1 / FrameTime())
end
*/

--PATH addons/__________skeypads/lua/skeypads/main/cl_super_secure.lua:
sKeypads.SuperSecure = {}
local ply
local newAngle
local secureEnabled = false
function sKeypads.SuperSecure.GetRealEyeTrace()
    if not ply then return end
    if not secureEnabled then return ply:GetEyeTrace() end
    local eyePos = ply:EyePos()
    local tr = util.TraceLine( {
        start = eyePos,
        endpos = eyePos + newAngle:Forward() * 10000,
        filter = function( ent ) if ent:GetClass() == 'skeypad' then return true end end
    } )
    return tr
end

local startAngle
local finalAngle
hook.Add( 'Think', 'sKeypads::SuperSecureThink', function()
    if not ply then ply = LocalPlayer() end
    local tr = sKeypads.SuperSecure.GetRealEyeTrace()
    if not tr then return end
    if not ( tr.Hit and IsValid( tr.Entity ) ) then
        if not secureEnabled then return end
        finalAngle = Angle( 0, 0, 0 )
        finalAngle:Set( newAngle )
        secureEnabled = false
        startAngle = nil
        newAngle = nil
        return
    end

    if tr.Entity:GetClass() ~= 'skeypad' then
        if not secureEnabled then return end
        finalAngle = Angle( 0, 0, 0 )
        finalAngle:Set( newAngle )
        secureEnabled = false
        startAngle = nil
        newAngle = nil
        return
    end

    if secureEnabled then return end
    secureEnabled = true
end )

local mouseMultiplier = 0.0075
hook.Add( 'CreateMove', 'sKeypads::SuperSecureMovement', function( cmd )
    if finalAngle then
        cmd:SetViewAngles( finalAngle )
        finalAngle = nil
        return
    end

    if not secureEnabled then return end
    if not ply then return end
    if not startAngle then
        startAngle = cmd:GetViewAngles()
        newAngle = Angle( 0, 0, 0 )
        newAngle:Set( startAngle )
    end

    newAngle:Add( Angle( cmd:GetMouseY() * mouseMultiplier, cmd:GetMouseX() * -mouseMultiplier, 0 ) )
    cmd:SetMouseX( 0 )
    cmd:SetMouseY( 0 )
    cmd:SetViewAngles( startAngle )
end )

hook.Add( 'CalcView', 'sKeypads::SuperSecureView', function( _, _, _, fov )
    if not secureEnabled then return end
    local view = {}
    view.origin = ply:EyePos()
    view.angles = newAngle
    view.fov = fov
    view.drawviewer = false
    return view
end )

hook.Add( 'CalcViewModelView', 'sKeypads', function( _, _, _, _, pos )
    if not secureEnabled then return end
    return pos, newAngle
end )
--PATH addons/__________skeypads/lua/skeypads/utils/sh_logging.lua:
sKeypads.Utils = sKeypads.Utils or {}
function sKeypads.Utils.log( err )
    sKeypads.Utils.checkType( err, sKeypads.Types.TYPE_STRING )
    print( "sKeypads: " .. err )
end
--PATH addons/____slib/lua/slib/vgui/cl_sdropdown.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 13)
local textcolor = slib.getTheme("textcolor")
local hovercolor, margin, maincolor_5, maincolor_10 = slib.getTheme("hovercolor"), slib.getTheme("margin"), slib.getTheme("maincolor", 5), slib.getTheme("maincolor", 10)
local icon = Material("slib/down-arrow.png", "smooth")

function PANEL:Init()
    self:SetTall(slib.getScaledSize(25, "y"))
    self:setTitle("Select Option", TEXT_ALIGN_LEFT)
    self.iteration = 0
    self.options = {}
    self.maxHeightChilds = 0

    self.close = vgui.Create("DButton")
    self.close:Dock(FILL)
    self.close:SetText("")
    self.close:SetVisible(false)

    self.close.Paint = function() end

    self.close.DoClick = function()
        self.close:SetVisible(false)
        if IsValid(self.droppedMenu) then
            self.droppedMenu:SetVisible(false)
        end

        if isfunction(self.onClose) then self.onClose(self) end
    end

    self.droppedMenu = vgui.Create("SScrollPanel")
    self.droppedMenu:SetWide(self:GetWide())
    self.droppedMenu:SetVisible(false)
    self.droppedMenu.scrollbg = Color(42, 42, 42)
end

function PANEL:SetPlaceholder(str)
    self:setTitle(str, TEXT_ALIGN_LEFT)
end

function PANEL:OnRemove()
    if IsValid(self.droppedMenu) then self.droppedMenu:Remove() end
end

function PANEL:popupAlone()
    self:DoClick()

    local x, y = input.GetCursorPos()
    if !IsValid(self.droppedMenu) then return end
    self.droppedMenu:SetWide(self:GetWide())
    self.droppedMenu:SetPos(x, y)
    self.droppedMenu:MakePopup()
    self:SetVisible(false)
    self.poppedOut = true

    self.onClose = function() self:Remove() end

    return self
end

function PANEL:SizeToChilds()
    local canvas = self.droppedMenu:GetCanvas()
    local childsHeight = 0

    for k,v in ipairs(canvas:GetChildren()) do
        if self.maxHeightChilds > 0 and k > self.maxHeightChilds then
            break
        end
        
        childsHeight = childsHeight + v:GetTall()
    end

    canvas:InvalidateLayout(true)
    canvas:SetTall(childsHeight)

    self.droppedMenu:SetHeight(canvas:GetTall())
end

function PANEL:addOption(val)
    local iteration = self.iteration
    self.options[iteration] = vgui.Create("SButton", self.droppedMenu)
    :Dock(TOP)
    :SetLinePos(0)
    :SetTall(slib.getScaledSize(25, "y"))

    if self.buttonfont then
        self.options[iteration].font = self.buttonfont
    end

    local is_func = isfunction(val)

    self.options[iteration]:setTitle(is_func and val() or val, TEXT_ALIGN_LEFT)

    local wide = self.options[iteration]:GetWide()

    self.options[iteration].accentheight = 1

    self:SizeToChilds()

    self.options[iteration].DoClick = function(called)
        self.close.DoClick()
        self:setTitle(is_func and val() or val, TEXT_ALIGN_LEFT, true)
        self.sel_int = iteration + 1
        
        if isfunction(self.onValueChange) then
            self.onValueChange(is_func and val() or val)
        end
    end
    local isFirst = !self.firstchild
    self.options[iteration].Paint = function(s,w,h)
        if is_func then self.options[iteration]:setTitle(val(), TEXT_ALIGN_LEFT) end

        surface.SetDrawColor(s:IsHovered() and maincolor_5 or maincolor_10)
        surface.DrawRect(0, 0, w, h)

        draw.SimpleText(is_func and val() or val, self.buttonfont or self.options[iteration].font, margin, h * .5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end
    
    if iteration == 0 then
        self.options[iteration].DoClick()
    end
    
    if wide > self:GetWide() then
        self:SetWide(wide)
    end
    
    self.iteration = self.iteration + 1

    self.firstchild = self.firstchild or self.options[iteration]
    self.lastchild = self.options[iteration]

    return self
end

function PANEL:SelectOption(int)
    self.options[int].DoClick(true)

    return self
end

function PANEL:Reposition()
    local x, y = self:LocalToScreen(0,self:GetTall())
    if !IsValid(self.droppedMenu) then return end
    self.droppedMenu:SetWide(self:GetWide())
    self.droppedMenu:SetPos(x, y)
    self.droppedMenu:MakePopup()
end

function PANEL:DoClick()
    self.close:SetVisible(!self.droppedMenu:IsVisible())
    self.close:MakePopup()

    self.droppedMenu:SetVisible(!self.droppedMenu:IsVisible())

    self:Reposition()
end

function PANEL:OnSizeChanged()
    self:Reposition()
end

function PANEL:PaintOver(w,h)
    local size = math.min(h * .7, slib.getScaledSize(12, "y"))
    local thickness = slib.getScaledSize(2, "x")

    draw.NoTexture()

    local wantedCol = self:IsHovered() and color_white or hovercolor

    surface.SetDrawColor(wantedCol)
    surface.SetMaterial(icon)
    surface.DrawTexturedRect(w - size - margin * 2, h * .5 - size * .5, size, size)
end

vgui.Register("SDropDown", PANEL, "SButton")
--PATH addons/____sprinter/lua/s_printer/cl_sprinter.lua:
sPrinter = sPrinter or {}

local margin, main_col, accent_col, successcolor, failcolor, shade_10, shade_min10, text_col, white, orange, invisible = 8, slib.getTheme("maincolor"), slib.getTheme("accentcolor"), slib.getTheme("successcolor"), slib.getTheme("failcolor"), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", -10), slib.getTheme("textcolor"), Color(255,255,255), Color(189, 75, 0), Color(0,0,0,0)
local cursor, power_ico, charge_ico, plus_ico, upgrades_ico, lock_ico = Material("sprinter/cursor.png", "smooth"), Material("sprinter/power.png", "smooth"), Material("sprinter/energy.png", "smooth"), Material("sprinter/plus.png", "smooth"), Material("sprinter/upgrade.png", "smooth"), Material("sprinter/lock.png", "smooth")
local stats = {}

function sPrinter.addTopbar(parent, ent)
    local drawBattery = isfunction(ent.GetBattery)
    local topbar = vgui.Create("EditablePanel", parent)
    topbar:SetSize(parent:GetWide(), 45)
    topbar.Paint = function(s,w,h)
        if ent:drawingOverlay("topbar") then return end
        surface.SetDrawColor(shade_min10)
        surface.DrawRect(0,0,w,h)

        draw.SimpleText(ent.name or topbar.title, slib.createFont("NasalizationRg-Regular", 35, nil, true), margin, h * .5, text_col, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        if drawBattery then
            local batteryw, batteryh = 75, 26
            local batteryx, batteryy = (w - batteryw - margin) - 70, (h * .5 - (batteryh * .5))
            local percent = ent:GetBattery()
            local percentcolor = successcolor

            if percent < .5 then
                percentcolor = orange
                if percent < .15 then
                    percentcolor = failcolor
                end
            end

            surface.SetDrawColor(percentcolor)
            surface.DrawRect(batteryx + (batteryw * (1 - percent)), batteryy, batteryw * percent, batteryh)

            surface.SetDrawColor(white)
            surface.DrawOutlinedRect(batteryx, batteryy, batteryw, batteryh)

            surface.DrawRect(batteryx - 2, h * .5 - (12 * .5), 2, 12)

            draw.SimpleText(math.Round(percent * 100).."%", slib.createFont("NasalizationRg-Regular", 28, nil, true), batteryx + (batteryw * .5), batteryy + (batteryh * .5), white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    if drawBattery then
        local power = vgui.Create("SButton", topbar)
        :Dock(RIGHT)
        :SetWide(25)
        :DockMargin(0, 7, 20, 7)

        power.DoClick = function()
            if !sPrinter.ShouldDraw(ent) then return end
            net.Start("sP:Networking")
            net.WriteEntity(ent)
            net.WriteUInt(1,3)
            net.WriteUInt(3,2)
            net.SendToServer()
        end

        power.Paint = function(s,w,h)
            if ent:drawingOverlay() then return end
            surface.SetDrawColor(slib.lerpColor(s, ent:GetPower() and successcolor or failcolor))
            surface.SetMaterial(power_ico)
            local iconsize = h
            surface.DrawTexturedRect(margin, h * .5 - iconsize * .5, iconsize, iconsize)
        end

        local charge = vgui.Create("SButton", topbar)
        :Dock(RIGHT)
        :SetWide(25)
        :DockMargin(0, 7, 10, 7)

        charge.DoClick = function()
            if !sPrinter.ShouldDraw(ent) then return end
            surface.PlaySound("buttons/button15.wav")
            
            sPrinter.MakePopup(ent, parent, slib.getLang("sprinter", sPrinter.config["language"], "this-will-cost", sPrinter.config["currency"]..string.Comma(ent:GetRechargePrice())), function()
                net.Start("sP:Networking")
                net.WriteEntity(ent)
                net.WriteUInt(2,3)
                net.WriteUInt(1,2)
                net.SendToServer()
            end)
        end

        charge.Paint = function(s,w,h)
            if ent:drawingOverlay() then return end
            if s.Hovered and !sPrinter.ShouldDraw(ent) then s.Hovered = false end
            surface.SetDrawColor(slib.lerpColor(s, s.Hovered and accent_col or white))
            surface.SetMaterial(charge_ico)
            local iconsize = h
            surface.DrawTexturedRect(margin, h * .5 - iconsize * .5, iconsize, iconsize)
        end
    end

    return topbar
end

local ico_size = 64
sPrinter.DrawLocked = function(w, h)
    surface.SetDrawColor(main_col)
    surface.DrawRect(0,0,w,h)

    surface.SetDrawColor(successcolor)
    surface.SetMaterial(lock_ico)
    surface.DrawTexturedRect(w * .5 - ico_size * .5, h * .5 - ico_size * .5 - 25, ico_size, ico_size)

    draw.SimpleText(slib.getLang("sprinter", sPrinter.config["language"], "locked"), slib.createFont("NasalizationRg-Regular", 56, nil, true), w * .5, h * .5 + 25, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
end

local ShouldDraw = {}
local lastDistUpdate = {}

function sPrinter.ShouldDraw(ent)
    if !IsValid(ent) then return end
    if !lastDistUpdate[ent] or (CurTime() - lastDistUpdate[ent]) > .5 then 
        local plypos = LocalPlayer():GetPos()
        local entpos = ent:GetPos()
        entpos.z = plypos.z

        ShouldDraw[ent] = plypos:DistToSqr(entpos) <= sPrinter.config["maxdistance"]
        lastDistUpdate[ent] = CurTime()
    end

    return ShouldDraw[ent]
end

local isDrawingCursor = CurTime()

function sPrinter.DrawCursor(w, h, ent, limit)
    if !sPrinter.ShouldDraw(ent) then return end
    local x, y = gui.MouseX(), gui.MouseY()
    if (x > w + 10 or x < -30) or (y > h + 10 or y < -30) or (x <= 0 and y <= 0) then return end
    surface.SetDrawColor(white)
    surface.SetMaterial(cursor)
    surface.DrawTexturedRect(math.Clamp(x, 0, w - limit), math.Clamp(y, 0, h - limit), 20, 20)
    isDrawingCursor = CurTime()
end

function sPrinter.MakePopup(ent, parent, question, func)
    local madeTime = SysTime()

    ent.stopHover = true

    local cover = vgui.Create("SButton", parent)
    cover:SetSize(parent:GetWide(), parent:GetTall())
    cover.OnRemove = function()
        ent.stopHover = nil
    end

    cover.Paint = function(s, w, h)
        surface.SetDrawColor(shade_min10.r, shade_min10.g, shade_min10.b, 250)
        surface.DrawRect(0, 0, w, h)
    end

    cover.DoClick = function() cover:Remove() end
    
    local popup = vgui.Create("SFrame", cover)
    :SetSize(parent:GetWide() * .6, 130)
    :setTitle(slib.getLang("sprinter", sPrinter.config["language"], "are-you-sure"))
    :addCloseButton()
    :Center()

    popup:SetDraggable(false)

    popup.OnRemove = function()
        if !IsValid(cover) then return end
        cover:Remove()
    end

    popup.PaintOver = function(s,w,h)
        draw.SimpleText(question, slib.createFont("NasalizationRg-Regular", 26, nil, true), w * .5, h * .5, text_col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    local agree = vgui.Create("SButton", popup)
    agree.bg = shade_10
    agree:setTitle(slib.getLang("sprinter", sPrinter.config["language"], "agree"))
    agree:SetSize(popup:GetWide() * .5 - 7, 25)
    agree:SetPos(popup:GetWide() - agree:GetWide() - 5, popup:GetTall() - 30)

    agree.DoClick = function()
        surface.PlaySound("buttons/button15.wav")
        cover.dontClick = true
        func()
    end

    local deny = vgui.Create("SButton", popup)
    deny.bg = shade_10
    deny:setTitle(slib.getLang("sprinter", sPrinter.config["language"], "deny"))
    deny:SetSize(popup:GetWide() * .5 - 7, 25)
    deny:SetPos(5, popup:GetTall() - 30)

    deny.DoClick = function()
        surface.PlaySound("buttons/button14.wav")
    end

    return popup
end

function sPrinter.addButton(parent, ent, title, func, icon, dock, gap, check, onlyicon)
    surface.SetFont(slib.createFont("NasalizationRg-Regular", 24, nil, true))
    local originalfunc = title
    if isfunction(title) then title = title() end
    local w = select(1, surface.GetTextSize(title))

    local button = vgui.Create("SButton", parent)
    :SetWide(w + margin * 2)

    if dock then
        button:Dock(dock)
    end

    button.resetText = function()
        title = originalfunc()
    end

    if gap then
        button:DockMargin(0,0,gap,0)
    end

    button.DoClick = function()
        if !sPrinter.ShouldDraw(ent) or ent:drawingOverlay() then return end
        if isfunction(check) and !check() then return end
        surface.PlaySound("buttons/button15.wav")
        func()
    end

    button.randid = tostring(function() end)

    button.Paint = function(s,w,h)
        if !IsValid(ent) or ent:drawingOverlay() then return end
        if s.disabled ~= nil then s.Hovered = s.disabled end
        if isfunction(check) and !check() then return end
        if ent.stopHover or !sPrinter.ShouldDraw(ent) and s.Hovered then s.Hovered = false end
        local wantedColor = onlyicon and invisible or s.Hovered and invisible or text_col
        local wantedIconColor = s.Hovered and accent_col or onlyicon and white or invisible
        surface.SetDrawColor(s.forcebg and s.forcebg or shade_10)
        surface.DrawRect(0, 0, w, h)

        local iconcol = slib.lerpColor(s.randid, s.inverted and wantedColor or wantedIconColor)
        local textcol = slib.lerpColor(s, s.inverted and wantedIconColor or wantedColor)

        surface.SetDrawColor(iconcol.a > 60 and iconcol or invisible)
        surface.SetMaterial(icon)
        local iconsize = (s.usewidth and w or h) * .7
        iconsize = s.iconsize or iconsize
        surface.DrawTexturedRect(w * .5 - iconsize * .5, h * .5 - iconsize * .5, iconsize, iconsize)

        draw.SimpleText(title, slib.createFont("NasalizationRg-Regular", s.fontsize and s.fontsize or 24, nil, true), w * .5, h * .5, textcol.a > 60 and textcol or invisible, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    return button
end

local function fullUpgradePrice(ent, upg_int)
    local cur_stage = ent.data.upgrades[upg_int].stage
    local sum = 0

    for i = cur_stage + 1, ent.data.upgrades[upg_int].max do
        sum = sum + ent:GetUpgradePrice(upg_int, i)
    end

    return sum
end 

function sPrinter.addUpgrades(ent, parent)
    for k,v in ipairs(ent.data.upgrades) do
        ent.data.upgrades[k].stage = ent.data.upgrades[k].stage or 0
        local name = slib.getLang("sprinter", sPrinter.config["language"], v.upgrade)

        local upg_bttn, upg_all_bttn

        local upgrade = vgui.Create("EditablePanel", parent)
        upgrade:Dock(TOP)
        upgrade:DockMargin(0,0,0,margin)
        upgrade:SetTall(60)

        upgrade.Paint = function(s,w,h)
            if !ent or !ent.data then return end
            if !ent.data.upgrades then upgrade:Remove() return end
            surface.SetDrawColor(shade_10)
            surface.DrawRect(0, 0, w, h)

            local iconsize = h * .7
            surface.SetDrawColor(white)
            surface.SetMaterial(v.icon)
            surface.DrawTexturedRect(h * .5 - iconsize * .5, h * .5 - iconsize * .5, iconsize, iconsize)

            local stage = ent.data.upgrades[k].stage
            local upgradewidth = math.Round((w - h - 110 - 30) / ent.data.upgrades[k].max)
            if ent.data.upgrades and ent.data.upgrades[k] and ent.data.upgrades[k].max then
                for i=1,ent.data.upgrades[k].max do
                    surface.SetDrawColor(i <= stage and accent_col or main_col)
                    surface.DrawRect(h + ((upgradewidth + 1) * (i - 1)), 7, (upgradewidth - 1) - ent.data.upgrades[k].max, 7)
                end
            end

            draw.SimpleText(name.."["..stage.."/"..ent.data.upgrades[k].max.."]", slib.createFont("NasalizationRg-Regular", 29, nil, true), h, h - 10, text_colmin40, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
            local price = (stage >= ent.data.upgrades[k].max) and "Max" or upg_bttn.Hovered and ent:GetUpgradePrice(k, stage + 1) or upg_all_bttn.Hovered and fullUpgradePrice(ent, k) or "N/A"
            local isnum = isnumber(price)
            price = isnum and sPrinter.config["currency"]..string.Comma(price) or price
            draw.SimpleText(price, slib.createFont("NasalizationRg-Regular", 24, nil, true), w - 56, h * .5, !isnum and text_col or successcolor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        local w = parent:GetWide()

        local buttonDock = vgui.Create("EditablePanel", upgrade)
        buttonDock:Dock(RIGHT)
        buttonDock:DockMargin(0,0,108,0)
        buttonDock:DockPadding(0,1,0,1)
        buttonDock:SetWide(28)

        upg_bttn = sPrinter.addButton(buttonDock, ent, "", function()
            net.Start("sP:Networking")
            net.WriteEntity(ent)
            net.WriteUInt(3, 3)
            net.WriteUInt(k, 3)
            net.WriteBool(false)
            net.SendToServer()
        end, plus_ico, TOP, nil, nil, true)
        upg_bttn:SetTall(28)
        upg_bttn:DockMargin(0,0,0,1)
        upg_bttn.forcebg = main_col

        upg_all_bttn = sPrinter.addButton(buttonDock, ent, "", function()
            net.Start("sP:Networking")
            net.WriteEntity(ent)
            net.WriteUInt(3, 3)
            net.WriteUInt(k, 3)
            net.WriteBool(true)
            net.SendToServer()
        end, upgrades_ico, TOP, nil, nil, true)
        upg_all_bttn:SetTall(28)
        upg_all_bttn:DockMargin(0,1,0,0)
        upg_all_bttn.forcebg = main_col
    end
end

local settingUpdate = {}

local UpdatedSetting = function(ent, setting)
    for panel, v in pairs(settingUpdate) do
        if !IsValid(panel) then continue end
        if setting == v.action and v.ent == ent then
            panel.enabled = ent.settings[setting]
        end
    end
end

local settings = {
    ["notify-low-hp"] = {action = 1, icon = Material("sprinter/low-hp-notify.png", "smooth")},
    ["notify-withdraw"] = {action = 2, icon = Material("sprinter/steal.png", "smooth")},
    ["notify-low-battery"] = {action = 3, icon = Material("sprinter/low-battery.png", "smooth")},
    ["notify-on-damage"] = {action = 4, icon = Material("sprinter/on-damage-notify.png", "smooth")}
}

function sPrinter.addSettings(ent, parent)
    ent.settings = ent.settings or {}
    for name, v in pairs(settings) do
        local setting = vgui.Create("SStatement", parent)
        setting:SetTall(55)
        setting:DockMargin(0,0,0,margin)
        setting.font = slib.createFont("NasalizationRg-Regular", 32, nil, true)
        local name = slib.getLang("sprinter", sPrinter.config["language"], name)
        setting.Paint = function(s,w,h)
            surface.SetDrawColor(shade_10)
            surface.DrawRect(0, 0, w, h)

            local iconsize = h * .7
            surface.SetDrawColor(white)
            surface.SetMaterial(v.icon)
            surface.DrawTexturedRect(h * .5 - iconsize * .5, h * .5 - iconsize * .5, iconsize, iconsize)

            draw.SimpleText(name, s.font, h, h * .5, text_colmin40, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        local _, element = setting:addStatement(name, ent.settings[v.action])
        element:DockMargin(5,5,5,5)
        element:SetWide(45)
        settingUpdate[element] = {action = v.action, ent = ent}

        element.onValueChange = function(newval)
            net.Start("sP:Networking")
            net.WriteEntity(ent)
            net.WriteUInt(2,3)
            net.WriteUInt(3,2)
            net.WriteUInt(v.action, 3)
            net.WriteBool(newval)
            net.SendToServer()
        end
    end
end

local actionNames = {
    [1] = "withdrawn-money",
    [2] = "received-damage",
    [3] = "upgraded-printer",
    [4] = "turned-on",
    [5] = "turned-off"
}

local function addLogEntry(parent, ent, setting)
    if !IsValid(parent) then return end
    local data = ent.logs[setting]
    local entry = vgui.Create("EditablePanel", parent)
    entry:Dock(TOP)
    entry:DockMargin(0,0,0,margin)
    entry:SetZPos(-setting)
    entry:SetTall(40)

    entry.Paint = function(s,w,h)
        surface.SetDrawColor(shade_10)
        surface.DrawRect(0, 0, w, h)

        local iconsize = h * .7
        
        surface.SetDrawColor(white)
        surface.SetMaterial(plus_ico)
        surface.DrawTexturedRect(h * .5 - iconsize * .5, h * .5 - iconsize * .5, iconsize, iconsize)

        draw.SimpleText("["..os.date( "%H:%M" , data.time ).."] "..slib.getLang("sprinter", sPrinter.config["language"], actionNames[data.action]), slib.createFont("NasalizationRg-Regular", 29, nil, true), h, h * .5, text_colmin40, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end
end

local logsEntryCanvas = {}

function sPrinter.addLogEntries(ent, parent)
    if ent.logs then
        for k,v in pairs(ent.logs) do
            addLogEntry(parent, ent, k)
        end
    end

    logsEntryCanvas[parent] = ent
end

sPrinter.requestData = function(ent)
    if ent.Requested then return end
    net.Start("sP:Networking")
    net.WriteEntity(ent)
    net.SendToServer()
    ent.Requested = true
end

sPrinter.fadeByDistance = function(ent)
    if !IsValid(ent) then return end
    local distance = ent:GetPos():DistToSqr(LocalPlayer():GetPos())
    local wantedopacity = distance > sPrinter.config["maxdrawdistance"] and 0 or 255

    return slib.lerpNum(ent, wantedopacity, 2, RealFrameTime())
end

sPrinter.drawLogo = function(ent, id)
    local logo = slib.ImgurGetMaterial(id)
    if !logo then return end

    local class = ent:GetClass()
    local data = sPrinter.config["logo"][class] or sPrinter.config["logo"][ent.Base]
    local pos = ent:LocalToWorld(data.pos)
	local ang = ent:LocalToWorldAngles(data.ang)
    local size = data.size

	vgui.Start3D2DS( pos, ang, .03 )
        surface.SetDrawColor(white)
        surface.SetMaterial(logo)
        surface.DrawTexturedRect(-(size.w * .5),-(size.h * .5),size.w,size.h)
	vgui.End3D2DS()
end

net.Receive("sP:Networking", function(len)
    local ent = net.ReadEntity()
    local action = net.ReadUInt(2)
    if !IsValid(ent) then return end

    if action == 0 then
        local upgrade = net.ReadUInt(3)
        local stage = net.ReadUInt(4)

        ent.data.upgrades[upgrade].stage = stage
    elseif action == 1 then
        local setting = net.ReadUInt(3)
        local status = net.ReadBool()
        ent.settings[setting] = status

        hook.Run("sP:SettingsNetworked", ent, setting)
    elseif action == 2 then
        local chunk = net.ReadUInt(32)
        local data = net.ReadData(chunk)

        data = util.Decompress(data)
        data = util.JSONToTable(data)

        if istable(ent.logs) then
            local setting = #ent.logs + 1
            ent.logs[setting] = data

            hook.Run("sP:LogsNetworked", ent, setting)
        end
    elseif action == 3 then
        local bool = net.ReadBool()
        local sid64 = LocalPlayer():SteamID64()
        ent.authorized[sid64] = bool or nil
    end
end)

local lastMouseStatus, nextThink = nil, 0

hook.Add("Think", "sP:ToggleScreenMode", function(enabled)
    if nextThink > CurTime() then return end
    
    local prev = lastMouseStatus

    lastMouseStatus = gui.MouseX() != 0 or gui.MouseY() != 0

    if prev != lastMouseStatus then
        hook.Run("sP:MouseEnabled", lastMouseStatus)
    end

    nextThink = CurTime() + .5
end)

hook.Add("HUDShouldDraw", "noCrosshairOnScreen", function(n)
    if n == "CHudCrosshair" and (CurTime() - (isDrawingCursor or 0) < .1) then return false end
end)

hook.Add("sP:SettingsNetworked", "sP:UpdateSettings", UpdatedSetting)

hook.Add("sP:LogsNetworked", "sP:AddLogsCanvas", function(ent, setting)
    for canvas,v in pairs(logsEntryCanvas) do
        if v ~= ent then continue end
        addLogEntry(canvas, ent, setting)
    end
end) --- Add log entries!    ​​           
--PATH addons/____sprinter/lua/s_printer/languages/sh_french.lua:
if CLIENT then
    slib.setLang("sprinter", "fr", "main", "Principale")
    slib.setLang("sprinter", "fr", "logs", "Historique")
    slib.setLang("sprinter", "fr", "upgrades", "Améliorer")
    slib.setLang("sprinter", "fr", "settings", "Paramètres")
    slib.setLang("sprinter", "fr", "overclocking", "Overclocking")
    slib.setLang("sprinter", "fr", "noisereduction", "Réduction du bruit")
    slib.setLang("sprinter", "fr", "dmgresistance", "Résistance aux dégâts")
    slib.setLang("sprinter", "fr", "notifications", "Notifications")

    slib.setLang("sprinter", "fr", "notify-withdraw", "Notifier lors du retrait")
    slib.setLang("sprinter", "fr", "notify-on-damage", "Notifier les dommages")
    slib.setLang("sprinter", "fr", "notify-low-hp", "Notifier en cas de faible HP")
    slib.setLang("sprinter", "fr", "notify-low-battery", "Notifier en cas de batterie faible")

    slib.setLang("sprinter", "fr", "withdrawn-money", "Argent retiré")
    slib.setLang("sprinter", "fr", "received-damage", "Dommages reçus")
    slib.setLang("sprinter", "fr", "upgraded-printer", "Imprimante améliorée")
    slib.setLang("sprinter", "fr", "turned-on", "Allumé")
    slib.setLang("sprinter", "fr", "turned-off", "Éteindre")

    slib.setLang("sprinter", "fr", "are-you-sure", "Êtes-vous sûr?")
    slib.setLang("sprinter", "fr", "this-will-cost", "Cela coûtera %s")

    slib.setLang("sprinter", "fr", "nothing-to-show", "Rien à montrer ici")

    slib.setLang("sprinter", "fr", "condition", "État") 
    slib.setLang("sprinter", "fr", "temperature", "Température")
    slib.setLang("sprinter", "fr", "clockspeed", "Vitesse de l'horloge")
    slib.setLang("sprinter", "fr", "income", "Revenu (min)")
    slib.setLang("sprinter", "fr", "eject", "Éjecter")
    slib.setLang("sprinter", "fr", "withdraw", "Retiré")
    slib.setLang("sprinter", "fr", "repair", "Réparation")
    slib.setLang("sprinter", "fr", "recharge", "Recharger")

    slib.setLang("sprinter", "fr", "empty", "Vide") 
else
    slib.setLang("sprinter", "fr", "upgraded", "Vous avez amélioré une imprimante pour %s")
    slib.setLang("sprinter", "fr", "recharged", "Vous avez rechargé une imprimante pendant %s")
    slib.setLang("sprinter", "fr", "repaired", "Vous avez réparé une imprimante pour %s")
    slib.setLang("sprinter", "fr", "repaired-rack", "Vous avez réparé un rack pour %s")
    slib.setLang("sprinter", "fr", "withdrawn", "Vous avez retiré %s")
    slib.setLang("sprinter", "fr", "recharged-all", "Vous avez rechargé toutes les imprimantes du rack pendant %s")
    slib.setLang("sprinter", "fr", "recharged-this-many", "Vous avez rechargé les imprimantes %s dans le rack pendant %s")
    slib.setLang("sprinter", "fr", "repaired-all", "Vous avez réparé toutes les imprimantes du rack pendant %s")
    slib.setLang("sprinter", "fr", "repaired-this-many", "Vous avez réparé les imprimantes %s dans le rack pendant %s")
    slib.setLang("sprinter", "fr", "no-eject-space", "Il n'y a pas d'espace pour éjecter l'imprimantes")
    slib.setLang("sprinter", "fr", "printer-was-damaged", "Votre imprimante %s a été endommagée!")
    slib.setLang("sprinter", "fr", "printer-low-hp", "Votre imprimante %s a une puissance faible!")
    slib.setLang("sprinter", "fr", "someone-has-withdrawn", "Quelqu'un a retiré de l'argent de votre imprimante %s!")
    slib.setLang("sprinter", "fr", "battery-low", "Votre imprimante %s a une batterie faible, vous devriez la recharger!")
    slib.setLang("sprinter", "fr", "rewarded-on-destroy", "Vous avez reçu %s en récompense pour avoir détruit une imprimante!")
end

slib.setLang("sprinter", "fr", "rack", "Rack d'imprimante")
slib.setLang("sprinter", "fr", "insufficient-permissions", "Vous avez des autorisations insifficentes pour faire cela!")
--PATH addons/____plogs/lua/ui/util.lua:

-----------------------------------------------------
surface.CreateFont('ui.40', {font = 'roboto', size = 40, weight = 500})
surface.CreateFont('ui.39', {font = 'roboto', size = 39, weight = 500})
surface.CreateFont('ui.38', {font = 'roboto', size = 38, weight = 500})
surface.CreateFont('ui.37', {font = 'roboto', size = 37, weight = 500})
surface.CreateFont('ui.36', {font = 'roboto', size = 36, weight = 500})
surface.CreateFont('ui.35', {font = 'roboto', size = 35, weight = 500})
surface.CreateFont('ui.34', {font = 'roboto', size = 34, weight = 500})
surface.CreateFont('ui.33', {font = 'roboto', size = 33, weight = 500})
surface.CreateFont('ui.32', {font = 'roboto', size = 32, weight = 500})
surface.CreateFont('ui.31', {font = 'roboto', size = 31, weight = 500})
surface.CreateFont('ui.30', {font = 'roboto', size = 30, weight = 500})
surface.CreateFont('ui.29', {font = 'roboto', size = 29, weight = 500})
surface.CreateFont('ui.28', {font = 'roboto', size = 28, weight = 500})
surface.CreateFont('ui.27', {font = 'roboto', size = 27, weight = 400})
surface.CreateFont('ui.26', {font = 'roboto', size = 26, weight = 400})
surface.CreateFont('ui.25', {font = 'roboto', size = 25, weight = 400})
surface.CreateFont('ui.24', {font = 'roboto', size = 24, weight = 400})
surface.CreateFont('ui.23', {font = 'roboto', size = 23, weight = 400})
surface.CreateFont('ui.22', {font = 'roboto', size = 22, weight = 400})
surface.CreateFont('ui.20', {font = 'roboto', size = 20, weight = 400})
surface.CreateFont('ui.19', {font = 'roboto', size = 19, weight = 400})
surface.CreateFont('ui.18', {font = 'roboto', size = 18, weight = 400})
surface.CreateFont('ui.17', {font = 'roboto', size = 15, weight = 550})
surface.CreateFont('ui.15', {font = 'roboto', size = 15, weight = 550})

local surface_SetDrawColor 	= surface.SetDrawColor
local surface_SetMaterial 	= surface.SetMaterial
local surface_DrawRect 		= surface.DrawRect
local surface_DrawTexturedRect = surface.DrawTexturedRect
local render_UpdateScreenEffectTexture = render.UpdateScreenEffectTexture
local ScrW = ScrW
local ScrH = ScrH

local function DrawRect(x, y, w, h, t)
	if not t then t = 1 end
	surface_DrawRect(x, y, w, t)
	surface_DrawRect(x, y + (h - t), w, t)
	surface_DrawRect(x, y, t, h)
	surface_DrawRect(x + (w - t), y, t, h)
end

function draw.Box(x, y, w, h, col)
	surface_SetDrawColor(col)
	surface_DrawRect(x, y, w, h)
end

function draw.Outline(x, y, w, h, col, thickness)
	surface_SetDrawColor(col)
	DrawRect(x, y, w, h, thickness)
end

function draw.OutlinedBox(x, y, w, h, col, bordercol, thickness)
	surface_SetDrawColor(col)
	surface_DrawRect(x + 1, y + 1, w - 1, h - 1)

	surface_SetDrawColor(bordercol)
	DrawRect(x, y, w, h, thickness)
end
--[[
local blur = Material('pp/blurscreen')
function draw.Blur(panel, amount) -- Thanks nutscript
	local x, y = panel:LocalToScreen(0, 0)
	local scrW, scrH = ScrW(), ScrH()
	surface_SetDrawColor(255, 255, 255)
	surface_SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat('$blur', (i / 3) * (amount or 6))
		blur:Recompute()
		render_UpdateScreenEffectTexture()
		surface_DrawTexturedRect(x * -1, y * -1, scrW, scrH)
	end
end
--]]
local vguiFucs = {
	['DTextEntry'] = function(self, p)
		self:SetFont('ui.20')
	end,	
	['DLabel'] = function(self, p)
		self:SetFont('ui.22')
		self:SetColor(ui.col.White)
	end,
	['DButton'] = function(self, p)
		self:SetFont('ui.20')
	end,
	['DComboBox'] = function(self, p)
		self:SetFont('ui.22')
	end,
}

timer.Simple(0, function()
	vgui.GetControlTable('DButton').SetBackgroundColor = function(self, color)
		self.BackgroundColor = color
	end
end)

function ui.Create(t, f, p)
	local parent
	if (not isfunction(f)) and (f ~= nil) then
		parent = f
	elseif not isfunction(p) and (p ~= nil) then
		parent = p
	end

	local v = vgui.Create(t, parent)
	v:SetSkin('SUP')

	if vguiFucs[t] then vguiFucs[t](v, parent) end

	if isfunction(f) then f(v, parent) elseif isfunction(p) then p(v, f) end

	return v
end

function ui.Label(txt, font, x, y, parent)
	return ui.Create('DLabel', function(self, p)
		self:SetText(txt)
		self:SetFont(font)
		self:SetTextColor(ui.col.White)
		self:SetPos(x, y)
		self:SizeToContents()
		self:SetWrap(true)
		self:SetAutoStretchVertical(true)
	end, parent)
end

function ui.DermaMenu(p)
	local m = DermaMenu(p)
	m:SetSkin('SUP')
	return m
end

function ui.OpenURL(url, title)
	local w, h = ScrW() * .9, ScrH() * .9

	local fr = ui.Create('ui_frame', function(self)
		self:SetSize(w, h)
		self:SetTitle(url)
		self:Center()
		self:MakePopup()
	end)

	ui.Create('HTML', function(self)
		self:SetPos(5, 32)
		self:SetSize(w - 10, h - 37)
		self:OpenURL(url)
	end, fr)

	return fr
end
--PATH addons/__main/lua/wos/anim_extension/holdtypes/melee_combo.lua:
local DATA = {}

DATA.Name = "Melee Combination"
DATA.HoldType = "melee-combo"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

--DATA.Translations[ ACT_MP_STAND_IDLE ]					= 2680
--DATA.Translations[ ACT_MP_WALK ]						= 2683
--DATA.Translations[ ACT_MP_RUN ]							= 2685
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= ACT_HL2MP_IDLE_CROUCH_KNIFE 
DATA.Translations[ ACT_MP_CROUCHWALK ]					= ACT_HL2MP_WALK_CROUCH_KNIFE
--DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= 2688
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_JUMP ]						= 3160
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
--DATA.Translations[ ACT_LAND ]							= ACT_LAND

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/_dance/lua/autorun/wos_fortnite_loader.lua:

--[[-------------------------------------------------------------------
	Fortnite Dancing Addon:
		Why the hell did we make this?
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2019 ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
]]--


wOS = wOS or {}
wOS.Fortnite = wOS.Fortnite or {}

if SERVER then
	AddCSLuaFile( "wos/fortnite/loader/loader.lua" )
end

include( "wos/fortnite/loader/loader.lua" )
--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/time.lua:
function XeninUI:GetUTCTime()

	return os.time()
end

function XeninUI:SecondsToTimeString(s, _format, as_tbl)
	local d = (s / 86400)
	local h = math.floor(math.fmod(s, 86400) / 3600)
	local m = math.floor(math.fmod(s, 3600) / 60)
	local s = math.floor(math.fmod(s, 60))

	if as_tbl then
		return {
			d = d,
			h = h,
			m = m,
			s = s
		}
	end

	return string.format(_format or "%d:%02d:%02d:%02d", d, h, m, s)
end

function XeninUI:SecondsToSmallTime(s, _format, as_tbl)
	local m = math.floor(math.fmod(s, 3600) / 60)
	local s = math.floor(math.fmod(s, 60))

	if as_tbl then
		return {
			d = d,
			h = h,
			m = m,
			s = s
		}
	end

	return string.format(_format or "%02d:%02d", m, s)
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/classes/controller.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
XeninUI.Configurator.Controllers = XeninUI.Configurator.Controllers || {}

function XeninUI.Configurator:GetControllers()
  return self.Controllers
end

function XeninUI.Configurator:FindControllerByScriptName(script)
  return self:GetControllers()[script]
end

do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Configurator.Controller",
    setTitle = function(self, title)
      self.title = title
      return self
    end,
    getSettings = function(self)
      return self.settings
    end,
    getTabs = function(self)
      return self.tabs
    end,
    getScript = function(self)
      return self.script
    end,
    getTitle = function(self)
      return self.title
    end,
    IsValid = function(self)
      return XeninUI.Configurator:FindControllerByScriptName(self.script) == self
    end,
    addSettingTab = function(self, name)
      table.insert(self.settingTab, {
        name = name,
        subtabs = {}
      })
    end,
    getSettingTabs = function(self)
      return self.settingTab
    end,
    addSetting = function(self, id, category, subCategory, name, desc, value, type, data, sortOrder)
      if data == nil then data = {}
      end
      self.settings[id] = {
        id = id,
        category = category,
        subCategory = subCategory,
        name = name,
        desc = desc,
        value = value,
        defaultValue = value,
        type = type,
        data = data,
        sortOrder = sortOrder or table.Count(self.settings) + 1
      }

      self.cache:set(id, value)
    end,
    addTab = function(self, name, icon, color, panel, settings)
      if settings == nil then settings = {}
      end
      table.insert(self.tabs, __laux_concat_0({
        name = name,
        icon = icon,
        color = color or color_white,
        panel = panel or "DPanel"
      }, settings))
    end,
    addSettingsTab = function(self, name, icon, color, settings)
      if settings == nil then settings = {}
      end
      local panel = "Xenin.Configurator.Admin.Panel"
      settings.settingsTab = true

      self:addTab(name, icon, color, panel, settings)
    end,
    addEntityTab = function(self, name, icon, color, entity, settings)
      if settings == nil then settings = {}
      end
      local panel = settings.panelOverride or "Xenin.Configurator.Admin.Entity"
      if (settings.isGrid and !settings.panelOverride) then
        panel = "Xenin.Configurator.Admin.EntityGrid"
      end
      if (settings.isList and !settings.panelOverride) then
        panel = "Xenin.Configurator.Admin.EntityList"
      end

      table.Merge(settings, {
        __entity = entity,
        script = self:getScript(),
        name = name
      })
      self:addTab(name, icon, color, panel, settings)
    end,
    getSettingsKV = function(self)
      local tbl = {}
      for i, v in pairs(self:getSettings()) do
        tbl[v.id] = self.cache:get(v.id)
      end

      return tbl
    end,
    getSortedSettings = function(self)
      local tbl = {}
      for i, v in pairs(self:getSettings()) do
        table.insert(tbl, v)
      end
      table.sort(tbl, function(a, b)
        return a.sortOrder < b.sortOrder end)

      return tbl
    end,
    getSettingsByCategory = function(self)
      local tbl = {}
      for i, v in pairs(self:getSettings()) do
        tbl[v.category] = tbl[v.category] || {}

        table.insert(tbl[v.category], v)
      end
      for i, v in pairs(tbl) do
        table.sort(v, function(a, b)
          return a.sortOrder < b.sortOrder end)
      end

      return tbl
    end,
    get = function(self, key, default)
      local val = self.cache:get(key)
      if (val != nil) then
        return val
      end

      return default
    end,
    onSettingChanged = function(self, key, value) end,
    set = function(self, key, value)
      self.cache:set(key, value)
      self.settings[key].value = value

      self:onSettingChanged(key, value)
    end,
    saveSetting = function(self, id, val)
      if CLIENT then
        XeninUI.Configurator.Network:sendSaveSetting(self:getScript(), id, val)
      else
        return XeninUI.Configurator.ORM:saveSetting(self:getScript(), id, val)
      end
    end,
    load = function(self)
      local p = XeninUI.Promises.new()

      if self.hasLoadedSettings then
        return p:resolve()
      end

      XeninUI.Configurator.ORM:getScriptSettings(self:getScript()):next(function(results)
        if results == nil then results = {}
        end
        for i, v in ipairs(results) do
          assert(v ~= nil, "cannot destructure nil value")
          local id, value, json = v.id, v.value, v.json
          if (json and json != "NULL") then
            value = util.JSONToTable(value)
          end

          self.cache:set(id, value)
        end

        self.hasLoadedSettings = true
        p:resolve()
      end, function(err)
        p:reject(err)
      end)

      return p
    end,
    networkSettings = function(self, target)
      if (CLIENT) then return end

      local isAdmin = XeninUI.Permissions:canAccessFramework(target)
      local tbl = {}
      for i, v in pairs(self:getSettings()) do
        local setting = self.settings[v.id]
        if (setting.data.secret and !isAdmin) then continue end

        tbl[v.id] = self.cache:get(v.id)
      end

      XeninUI.Configurator.Network:sendSettings(target, self:getScript(), tbl)
    end,
    loadEntities = function(self, ent)
      local p = XeninUI.Promises.new()
      local id = ent:getDatabaseEntity()
      if self.loadedEntities[id] then
        return p:resolve()
      end

      XeninUI.Configurator.ORM:findEntities(ent):next(function(results)
        results = results || {}

        local tbl = {}

        for _, entData in ipairs(results) do
          local inst = XeninUI.Configurator.Entities:create(id)
          for i, v in pairs(entData) do
            local val = v
            local col = inst:getColumn(i)
            if col.onLoad then
              val = col:onLoad(v)
            end

            inst["set" .. tostring(i)](inst, val)
          end
          inst:save()
          inst:onLoad()
        end

        self.loadedEntities[id] = true
        p:resolve()
      end)

      return p
    end,
    networkEntities = function(self, target)
      if (CLIENT) then return end

      local ents = XeninUI.Configurator.Entities:getEntities()
      local type = self:__type()
      local id = (string.Explode(".", type) and string.Explode(".", type)[1])
      local length = #id
      for entId, ent in pairs(ents) do
        local str = entId:sub(1, length)
        if (str != id) then continue end

        if (!ent.getAllEntities) then
          Error(tostring(entId) .. " has no way of getting all instances of said entity. Please implement a static getAllEntities function\n")
        end

        self:loadEntities(ent()):next(function(result)
          local allEnts = ent.getAllEntities()

          XeninUI.Configurator.Network:sendEntities(target, allEnts)
        end)
      end
    end,
    addSearch = function(self, id, tabFunc, matchFunc, clickFunc)
      if clickFunc == nil then clickFunc = function() end
      end
      table.insert(self.search, {
        id = id,
        matchFunc = matchFunc,
        tabFunc = tabFunc,
        clickFunc = clickFunc
      })
    end,
    getSearch = function(self, text)
      text = text:lower()

      local function findTab(func)
        for i, v in pairs(self.tabs) do
          if (!func(v, i)) then continue end

          return v, i
        end
      end

      local tbl = {}
      for i, v in ipairs(self.search) do

        local tab = findTab(v.tabFunc)
        if (!tab) then continue end

        local results = v:matchFunc(text, tab)
        tbl = __laux_concat_0(tbl, results)

        if (#tbl >= 4) then break end
      end

      return {
        tbl[1],
        tbl[2],
        tbl[3],
        tbl[4]
      }
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, script)
      self.search = {}
      self.loadedEntities = {}
      self.tabs = {}
      self.settingTab = {}
      self.settings = {}
      self.hasLoadedSettings = false
      self.cache = XeninUI.Configurator.Cache()
      self.script = script:lower()

      XeninUI.Configurator.Controllers[self.script] = self

      hook.Add("PlayerInitialSpawn", "XeninUI.Configurator.Scripts." .. tostring(script), function(ply)
        timer.Simple(3, function()
          self:load():next(function()
            if (!IsValid(ply)) then return end

            self:networkSettings(ply)
            self:networkEntities(ply)
          end)
        end)
      end)
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Configurator.Controller = _class_0
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/network/client.lua:
local Network
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "Network",
    __base = XeninUI.Network.__base,
    receiveSettings = function(self, ply)
      local script = net.ReadString()
      local size = net.ReadUInt(12)
      XeninUI.Configurator:PrintMessage("Received settings for the addon '" .. tostring(script) .. "', size: " .. tostring(size))
      local controller = XeninUI.Configurator:FindControllerByScriptName(script)
      for i = 1, size do
        local id = net.ReadString()
        local val = self:read()

        controller:set(id, val)
      end
    end,
    sendSaveSettings = function(self, script, tbl)
      local __laux_type = (istable(script) and script.__type and script:__type()) or type(script)
      assert(__laux_type == "string", "Expected parameter `script` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(tbl) and tbl.__type and tbl:__type()) or type(tbl)
      assert(__laux_type == "table", "Expected parameter `tbl` to be type `table` instead of `" .. __laux_type .. "`")
      self:send("SaveSettings", function(self)
        local size = table.Count(tbl)
        net.WriteString(script)
        net.WriteUInt(size, 12)
        for i, v in pairs(tbl) do
          net.WriteString(i)
          self:write(v)
        end
      end)
    end,
    sendSaveSetting = function(self, script, id, val)
      local __laux_type = (istable(script) and script.__type and script:__type()) or type(script)
      assert(__laux_type == "string", "Expected parameter `script` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(id) and id.__type and id:__type()) or type(id)
      assert(__laux_type == "string", "Expected parameter `id` to be type `string` instead of `" .. __laux_type .. "`")
      self:send("SaveSetting", function(self)
        net.WriteString(script)
        net.WriteString(id)
        self:write(val)
      end)
    end,
    sendGetEntities = function(self, entity, limit, offset, search)
      if limit == nil then limit = 10
      end
      if offset == nil then offset = 0
      end
      if search == nil then search = ""
      end
      local __laux_type = (istable(entity) and entity.__type and entity:__type()) or type(entity)
      assert(__laux_type == "XeninUI.Configurator.Entity", "Expected parameter `entity` to be type `XeninUI.Configurator.Entity` instead of `" .. __laux_type .. "`")
      local ent = entity:getDatabaseEntity()

      self:send("GetEntities", function(self)
        net.WriteString(ent)
        net.WriteUInt(limit, 16)
        net.WriteUInt(offset, 16)
        net.WriteString(search)
      end)
    end,
    sendSaveEntity = function(self, entity)
      self:send("SaveEntity", function(self)
        net.WriteString(entity:getDatabaseEntity())
        entity:onNetworkSend()
      end)
    end,
    sendCreateEntity = function(self, entity)
      self:send("CreateEntity", function(self)
        net.WriteString(entity:getDatabaseEntity())
        entity:onNetworkSend()
      end)
    end,
    sendDeleteEntity = function(self, entity)
      self:send("DeleteEntity", function(self)
        net.WriteString(entity:getDatabaseEntity())
        entity:onNetworkSend()
      end)
    end,
    receiveCreateEntity = function(self, entity)
      local entity = net.ReadString()
      local ent = XeninUI.Configurator.Entities:create(entity)
      ent:onNetworkReceive()
      ent:save()

      hook.Run("XeninUI.Configurator.CreatedEntity", ent)
    end,
    receiveEntity = function(self, ply)
      local entity = net.ReadString()
      local ent = XeninUI.Configurator.Entities:create(entity)
      ent:onNetworkReceive()
      ent:save()
    end,
    receiveGetEntities = function(self, ply)
      local size = net.ReadUInt(16)
      local tbl = {}
      for i = 1, size do
        local entity = net.ReadString()
        local ent = XeninUI.Configurator.Entities:create(entity)
        ent:onNetworkReceive()

        table.insert(tbl, ent)
      end

      hook.Run("XeninUI.Configurator.GetEntities", tbl)
    end,
    __type = function(self)
      return "XeninUI.Configurator.Network"end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self)
      Network.__parent.__init(self)

      self:setPrefix("XeninUI.Configuator.")

      self:receiver("Settings", self.receiveSettings)
      self:receiver("Entity", self.receiveEntity)
      self:receiver("GetEntities", self.receiveGetEntities)
      self:receiver("CreateEntity", self.receiveCreateEntity)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  Network = _class_0
end

XeninUI.Configurator.Network = Network()

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/blank.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/sliderpad.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/players/controller.lua:
local Controller
do
  local _class_0
  local _base_0 = {
    __name = "Controller",
    onPlayerInitialSpawn = function(self, ply)
      local db = XeninUI.Players.Database
      db:begin()
      self:playTimeJoin(ply)
      db:commit():next(function()
        if (!IsValid(ply)) then return end

        hook.Run("Xenin.PlayerInitialSpawn", ply)
      end)
    end,
    onPlayerDisconnect = function(self, ply)
      self:playTimeDisconnect(ply)
    end,
    playTimeJoin = function(self, ply)
      local sid64 = ply:SteamID64()
      local db = XeninUI.Players.Database
      db:insertPlayer(sid64)
      db:deleteInactivePlayerJoins(sid64)
      db:insertPlayerJoin(sid64)
      db:getPlayerPlayTime(sid64):next(function(result)
        if (!IsValid(ply)) then return end

        ply.xeninPlaytime = result
      end)
    end,
    getAmountOfUnreadNotifications = function(self, ply)
      return XeninUI.Players.Database:getAmountOfUnreadNotifications(ply:SteamID64())
    end,
    getNotifications = function(self, ply)
      return XeninUI.Players.Database:getNotifications(ply:SteamID64())
    end,
    addNotificationSid64 = function(self, sid64, notification)
      assert(notification ~= nil, "cannot destructure nil value")
      local scriptId, type, content, data = notification.scriptId, notification.type, notification.content, notification.data
      local db = XeninUI.Players.Database

      return db:insertNotification(sid64, scriptId, type, content, data):next(function(id)
        return db:getNotification(id)
      end)
    end,
    markNotificationsRead = function(self, sid64, ids)
      local db = XeninUI.Players.Database
      db:begin()
      for i, v in ipairs(ids) do
        db:markNotificationRead(sid64, v)
      end
      return db:commit()
    end,
    addNotification = function(self, ply, notification)
      return self:addNotificationSid64(ply:SteamID64(), notification):next(function(result)
        return result
      end)
    end,
    playTimeDisconnect = function(self, ply)
      XeninUI.Players.Database:insertPlayerLeave(ply:SteamID64())
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self) end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Controller = _class_0
end

XeninUI.Players.Controller = Controller()

if SERVER then
  hook.Add("PlayerInitialSpawn", "XeninUI.Players", function(ply)
    XeninUI.Players.Controller:onPlayerInitialSpawn(ply)
  end)

  hook.Add("PlayerDisconnected", "XeninUI.Players", function(ply)
    XeninUI.Players.Controller:onPlayerDisconnect(ply)
  end)
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/notifications.lua:
XeninUI.Notifications = XeninUI.Notifications or {}

XeninUI:CreateFont("XeninUI.Notification", 18)

local standardIcons = {
  [NOTIFY_GENERIC] = Material("vgui/notices/generic"),
  [NOTIFY_ERROR] = Material("vgui/notices/error"),
  [NOTIFY_UNDO] = Material("vgui/notices/undo"),
  [NOTIFY_HINT] = Material("vgui/notices/hint"),
  [NOTIFY_CLEANUP] = Material("vgui/notices/cleanup")
}

local PANEL = {}

AccessorFunc(PANEL, "m_progressColor", "Color")
AccessorFunc(PANEL, "m_animTime", "AnimTime")
AccessorFunc(PANEL, "m_iconColor", "IconColor")

function PANEL:Init()
  self.textColor = Color(225, 225, 225)
  self:SetAnimTime(0.2)
  self:SetColor(XeninUI.Theme.Accent)
  self:SetIconColor(color_white)

  self.icon = vgui.Create("Panel", self)
  self.icon.Paint = function(pnl, w, h)
    if (!self.img or type(self.img) != "IMaterial") then return end

    surface.SetDrawColor(self:GetIconColor())
    surface.SetMaterial(self.img)
    surface.DrawTexturedRect(0, 0, w, h)
  end

  self.label = vgui.Create("DLabel", self)
  self.label:SetText("")
  self.label:SetFont("XeninUI.Notification")
  self.label:SetTextColor(self.textColor)
end

function PANEL:SetIcon(icon)
  self.img = icon
end

function PANEL:SetAvatar(ply)
  self.icon = vgui.Create("XeninUI.Avatar", self)
  self.icon:DockMargin(8, 8, 8, 8)
  self.icon:SetVertices(90)
  self.icon:SetPlayer(ply, 32)

  self.icon:SetWide(self.icon:GetTall())

  self:InvalidateLayout()
end

function PANEL:SetTextColor(col)
  self.label:SetTextColor(col)
end

function PANEL:SetText(text)
  if istable(text) then
    self.markup = text
    self.label:SetVisible(false)
  else
    self.label:SetText(text)
    self.label:SizeToContents()
  end
end

function PANEL:Paint(w, h)
  draw.RoundedBox(h * 0.5, 0, 0, w, h, XeninUI.Theme.Primary)

  local start = self.startTime
  local current = SysTime()
  local timeLeft = current - start

  local width = timeLeft * (w / self.duration)

  local x, y = self:LocalToScreen()
  render.SetScissorRect(x, y, x + w - width, y + h, true)
  draw.RoundedBox(h * 0.5, 0, 0, w, h, self:GetColor())
  render.SetScissorRect(0, 0, 0, 0, false)

  if self.markup then
    self.markup:Draw(8 + (h - 4 - 8) + 4, h * 0.5, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
end

function PANEL:Close()
  local id = self.id
  table.remove(XeninUI.Notifications, id)
  hook.Run("XeninUI.NotificationRemoved")

  self:LerpMove(ScrW() + self:GetWide(), self.y, self:GetAnimTime(), function()
    if (!IsValid(self)) then return end

    self:Remove()
  end)
end

function PANEL:SetDuration(time)
  self.duration = time
  self.startTime = SysTime()

  timer.Simple(time, function()
    if (!IsValid(self)) then return end

    self:Close()
  end)
end

function PANEL:PerformLayout(w, h)
  self.icon:SetPos(8, 6)
  self.icon:SetWide(h - 4 - 8)
  self.icon:SetTall(self.icon:GetWide())

  self.label:SetWide(w - self.icon:GetWide() - 8)
  self.label:SetPos(self.icon.x + self.icon:GetWide() + 6, 8)
end

function PANEL:StartNotification()
  local text = self.label:GetText()
  surface.SetFont("XeninUI.Notification")
  local tw, th = surface.GetTextSize(text)
  local width = 8 + 24 + 8 + tw + 8
  if self.markup then
    width = width + self.markup:GetWidth()
  end
  local x = ScrW() + width
  local y = ScrH() - 200
  local offset = (self.id - 1) * 45
  y = y - offset

  self:SetSize(width, 36)
  self:SetPos(x, y)
  self:LerpMove(ScrW() - width - 20, y, self:GetAnimTime())
end

vgui.Register("XeninUI.Notification", PANEL, "Panel")

function XeninUI:Notify(text, icon, duration, progressColor, textColor)

  if XeninUI.DisableNotification then
    icon = isnumber(icon) and icon or NOTIFY_HINT

    notification.AddLegacy(text or "No Notification Text", icon, duration or 4)

    return
  end

  text = text or "No Notification Text"
  icon = icon or Material("xenin/logo.png", "noclamp smooth")
  duration = duration or 4
  progressColor = progressColor or XeninUI.Theme.Accent
  textColor = textColor or Color(215, 215, 215)
  iconColor = iconColor or color_white

  local panel = vgui.Create("XeninUI.Notification")
  panel.Start = SysTime()
  panel:SetSize(width, 36)
  panel:SetPos(x, y)
  panel:SetText(text)
  panel:SetColor(progressColor)
  if isnumber(icon) then
    panel:SetIcon(standardIcons[icon])
  elseif isstring(icon) then
    panel:SetIcon(Material(icon, "smooth"))
  elseif (IsValid(icon) and icon:IsPlayer()) then
    panel:SetAvatar(icon)
  else
    panel:SetIcon(icon)
  end
  panel:SetTextColor(textColor)
  panel:SetIconColor(iconColor)
  panel:SetDuration(duration)
  local id = table.insert(self.Notifications, panel)
  panel.id = id
  self.Notifications[id].id = id
  panel:StartNotification()
  surface.PlaySound("buttons/lightswitch2.wav")
end

hook.Add("XeninUI.NotificationRemoved", "Core", function()
  for i, v in ipairs(XeninUI.Notifications) do
    if (v == NULL) then
      XeninUI.Notifications[i] = nil
    end
    if (!IsValid(v)) then continue end
    if v.removing then continue end

    v.id = i

    local y = ScrH() - 200
    local offset = (v.id - 1) * 45
    y = y - offset

    v:LerpMoveY(y, v:GetAnimTime())
  end
end)

net.Receive("XeninUI.Notification", function(len)
  local ply = LocalPlayer()
  local tbl = net.ReadTable()
  if tbl.markup then
    tbl.str = markup.Parse(tbl.str)
  end

  XeninUI:Notify(tbl.str, tbl.icon, tbl.dur, tbl.progressCol, tbl.textCol)
end)

--PATH addons/battlepass/lua/battlepass/challenges/zarobi_100000_za_profesiy_bitmainer.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Зароби 100000 за професію бітмайнера")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("zarobi_100000_za_profesiy_bitmainer")

CHALLENGE:AddHook("playerSellBitcoins_BattlePass", function(self, ply, _ply, bitcoinsell)
  if IsValid( _ply ) and ply == _ply and _ply:Team() == TEAM_BITMINER then
    self:AddProgress(bitcoinsell)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/languages/english.lua:
BATTLEPASS:AddLanguage("English", {
  ["Pass.Info.Tiers"] = ":tiers: tiers",
  ["Pass.Info.Rewards"] = ":rewards: rewards",
  ["Pass.Info.Challenges"] = ":challenges: challenge stages",

  ["Pass.CurrentTier.Max"] = "MAX TIER",

  ["Tabs.BattlePass"] = "BATTLE PASS",
  ["Tabs.Challenges"] = "CHALLENGES",
  ["Tabs.Help"] = "HELP",

  ["Pass.Page"] = "PAGE :currentPage:/:totalPages:",

  ["Pass.Purchase.Pass"] = "Purchase Battle Pass",
  ["Pass.Purchase.Tiers"] = "Purchase Tiers",
  ["Pass.Purchase.Website.Title"] = "Purchasing Battle Pass",
  ["Pass.Purchase.Website.Body"] = "To purchase please go to the store on our website",
  ["Pass.Purchase.Website.Yes"] = "Go to website",
  ["Pass.Purchase.Website.No"] = "Nevermind",
  ["Pass.Purchase.Website.Title.Tiers"] = "Purchasing Tiers",

  ["Pass.Items.Unlock"] = "Unlock",

  ["Challenges.Challenges"] = ":challenges: challenges",
  ["Challenges.Stages"] = "| :stages: stages",
  ["Challenges.Star"] = "Stars granted by completing this challenge",
  ["Challenges.Stage.Tooltip"] = "You are at stage :currentStage: out of :goal: stages",

  ["Notifications.Reward"] = "Ви виповнили завдання [:name:] за винагороду у :stars: зірки",
  ["Notifications.Reward.Stage"] = "You completed a stage for the challenge [:name:] for a reward of :stars: stars",
  ["Notifications.LevelUp"] = "Ви підняли рівень вашого БП до :level:",
  ["Notifications.ClaimReward"] = "Будьласка заберіть свої винагороди у батлпасі",
})

--PATH addons/battlepass/lua/battlepass/ui/tooltip.lua:
XeninUI:CreateFont("BATTLEPASS_Tooltip", 18)

local PanelMeta = FindMetaTable("Panel")

function PanelMeta:AddBPTooltip(str, delay, offsetX, offsetY, dontDrawPoly)
  self.DontDrawPoly = dontDrawPoly
  self.CursorEntered = 0
  self.ActivateTooltip = true
  self.TooltipStr = str
  self.TooltipDelay = delay or 0.2

  local oldCursorEntered = self.OnCursorEntered
  self.OnCursorEntered = function(pnl)
    if (oldCursorEntered) then oldCursorEntered(pnl) end

    pnl.CursorEntered = CurTime() + pnl.TooltipDelay
  end
  
  local oldCursorExited = self.OnCursorExited
  self.OnCursorExited = function(pnl)
    if (oldCursorExited) then oldCursorExited(pnl) end

    pnl.CursorEntered = 0

    if (IsValid(pnl.Tooltip)) then
      pnl.Tooltip:Remove()
      pnl.Tooltip = nil
    end
  end

  local oldThink = self.Think
  self.Think = function(pnl)
    if (oldThink) then oldThink(pnl) end

    if (pnl.CursorEntered < CurTime() and !IsValid(pnl.Tooltip) and pnl:IsHovered()) then
      local x, y = pnl:LocalToScreen(offsetX or 0, offsetY or 0)
      local w = pnl:GetWide()

      surface.SetFont("BATTLEPASS_Tooltip")
      local width, height = surface.GetTextSize(self.TooltipStr)

      pnl.Tooltip = vgui.Create("BATTLEPASS_Tooltip")
      pnl.Tooltip:SetAlpha(0)
      pnl.Tooltip:SetDrawOnTop(true)
      pnl.Tooltip:SetSize(width + 32, height + 24)
      pnl.Tooltip:SetPos(x + self:GetWide() * 0.5 - pnl.Tooltip:GetWide() * 0.5, y - pnl.Tooltip:GetTall() - 4)
      pnl.Tooltip:AlphaTo(255, 0.15)
      pnl.Tooltip.Str = str
    end
  end

  local oldRemove = self.OnRemove
  self.OnRemove = function(pnl)
    if (oldRemove) then oldRemove(pnl) end

    if (IsValid(pnl.Tooltip)) then
      pnl.Tooltip:Remove()
    end
  end
end

function PanelMeta:SetTooltipString(str)
  self.TooltipStr = str
  if (!IsValid(self.Tooltip)) then return end
  self.Tooltip.Str = str

  local x, y = self:LocalToScreen(0, 0)
  local w = self:GetWide()

  surface.SetFont("BATTLEPASS_Tooltip")
  local width, height = surface.GetTextSize(self.TooltipStr)

  self.Tooltip:SetSize(width + 32, height + 24)
  self.Tooltip:SetPos(x + self:GetWide() * 0.5 - self.Tooltip:GetWide() * 0.5, y - self.Tooltip:GetTall() - 4)
end

local PANEL = {}

function PANEL:Paint(w, h)
  local x, y = self:LocalToScreen(0, 0)

  BSHADOWS.BeginShadow()
    XeninUI:DrawRoundedBox(6, x, y, w, h - 8, color_black)
    draw.SimpleText(self.Str, "BATTLEPASS_Tooltip", x + w * 0.5, y + (h - 8) * 0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  BSHADOWS.EndShadow(1, 1, 1, 255, 0, 0)

  if (self.DontDrawPoly) then
    local tbl = {
      { x = w * 0.5 - 8, y = h - 8 },
      { x = w * 0.5 + 8, y = h - 8 },
      { x = w * 0.5, y = h },
      { x = w * 0.5 - 8, y = h - 8 }
    }
    
    draw.NoTexture()
    surface.SetDrawColor(color_black)
    surface.DrawPoly(tbl)
  end
end

vgui.Register("BATTLEPASS_Tooltip", PANEL, "EditablePanel")
--PATH addons/____bricks_framework/lua/bricks_server/bricks_server_autorun_default.lua:
local module = BRICKS_SERVER.Func.AddModule( "default", "Brick's Server", "materials/bricks_server/essentials.png" )
module:AddSubModule( "currencies", "Currencies" )
--PATH addons/____bricks_framework/lua/bricks_server/languages/bricks_server/ukrainian.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "ukrainian", {
    ["search"] = "Знайти",
    ["invalidPlayerProfile"] = "Запрошен неверний профиль игрока!",
    ["unbound"] = "НЕ ЗВЯЗАН",
    ["themes"] = "Теми",
    ["groups"] = "Группи",
    ["general"] = "Основне",
    ["itemWhitelisting"] = "Белий список предметов",
    ["rarities"] = "Раритети",
    ["languages"] = "Мови",
    ["disabled"] = "Вiдключено",
    ["enabled"] = "Вмикнуто",
    ["purchase"] = "Купити",
    ["profile"] = "Профиль",
    ["view"] = "Переглянуты",
    ["admin"] = "AДМIН",
    ["noToolPermission"] = "Нема прав.",
    ["settings"] = "Налаштуваня",
    ["players"] = "Iгроки",
    ["modules"] = "Модулi",

    ["userGroupEditor"] = "Редактор групп iгроков",
    ["addNewGroup"] = "Добавить новую группу",
    ["newUserGroup"] = "Какой должна бить новая группа iгроков?",
    ["groupName"] = "Название",

    ["custom"] = "Свое",
    ["addNew"] = "Добавить новую",
    ["material"] = "Материал",
    ["directImage"] = "Введите URL прямого iзображения ниже.",
    ["default"] = "Стандарт",
    ["selectMaterial"] = "Ви должни вибрать материал!",

    ["errorNoText"] = "ПОМИЛКА: НЕМА ТЕКСТА",
    ["selectOption"] = "Виберите опцiю",
    ["selectValue"] = "Виберите значенiе.",
    ["selectColor"] = "Виберите цвет.",
    ["configSaved"] = "Конфиг сохраненено!",
    ["cmdNoPermission"] = "Нема прав.",
    ["entityPosUpdated"] = "Позицiя entity сохранена.",
    ["noEntitiesSpawned"] = "Нет сохраненних entities.",
    ["xEntitiesSpawned"] = "%d сохранил entities где бил заспавнен.",
    ["error"] = "ERROR",

    ["seconds"] = "%d секунд",
    ["second"] = "%d секунда",
    ["minutes"] = "%d хвилин",
    ["minute"] = "%d хвилини",
    ["hours"] = "%d години",
    ["hour"] = "%d година",

    ["noRarity"] = "Нема редкости",

    ["config"] = "Налаштуваня [Конфиг]",
    ["edit"] = "iзменить",
    ["editColor"] = "iзменить цвет",
    ["editName"] = "iзменить название",
    ["remove"] = "Видалити",
    ["name"] = "Название",
    ["description"] = "Описание",
    ["model"] = "Модель",
    ["icon"] = "Значек",
    ["type"] = "Тiп",
    ["price"] = "Стоимость",
    ["group"] = "Группа",
    ["category"] = "Категорiя",
    ["color"] = "Цвет",
    ["invalidType"] = "Неверний тип.",
    ["invalidOption"] = "Неверна опция.",
    ["invalidChoice"] = "Неверний вибор.",
    ["invalidGroup"] = "Неверная группа.",
    ["invalidPlayer"] = "Неверний игрок.",
    ["true"] = "ВКЛ",
    ["false"] = "ВиКЛ",
    ["noDescription"] = "Нет описания",
    ["other"] = "Остальное",
    ["completed"] = "Виполнено",
    ["close"] = "Закрити",
    ["main"] = "Меню",
    
    ["valueQuery"] = "Що следует %s?",
    ["dataValueQuery"] = "Какие данние должни это?",
    ["newNameQuery"] = "Що следует новому имени?",
    ["newDescriptionQuery"] = "Що следует новому описанию?",
    ["newModelQuery"] = "Що следует новой моделе?",
    ["newIconQuery"] = "Що следует новой иконке?",
    ["newColorQuery"] = "Що следует новому цвету?",
    ["npcTypeQuery"] = "Какой тип этого NPC?",
    ["newTypeQuery"] = "Що следует типу",
    ["groupRequirementQuery"] = "Що следует требованиям группи?",
    ["levelRequirementQuery"] = "Що следует уровню группи?",
    ["newPriceQuery"] = "Що следует новой стоимости?",
    ["newCategoryQuery"] = "Що следует новой категории?",

    ["npcEditor"] = "Настройка NPC [Editor]",
    ["addNPC"] = "Добавить NPC",
    ["newNPC"] = "Новий NPC",

    ["ok"] = "OK",
    ["cancel"] = "Отмена",
    ["save"] = "Сохранить",
    ["confirm"] = "Подтвердить",
    ["nil"] = "NIL",
    ["none"] = "Ничего",
    ["selected"] = "Вибрано",
    ["unselected"] = "Не вибрано",
    ["add"] = "Добавить",

    ["shootyStick"] = "Стрелка!",
    ["permanent"] = "Вечная",
    ["tierX"] = "(Уровень %d)",
    ["someDescription"] = "Некоторое описание.",
    ["invalidNPC"] = "BRICKS SERVER ERROR: Неверний NPC",

    ["disconnected"] = "Отключился",
    ["profileView"] = "Просмотр профиля",
    ["loading"] = "Загрузка",
    ["statistics"] = "Статистика",
    ["steamID64"] = "SteamID64",
    ["donationRank"] = "Рейтинг пожертвований",
    ["staffRank"] = "Рейтинг персонала",
    ["currentJob"] = "Текущее место работи",
    ["wallet"] = "Бумажник",
    ["level"] = "Уровень",
    ["levelX"] = "Уровень %d",
    ["experience"] = "ОПиТ",
    ["exp"] = "EXP",
    ["money"] = "Деньги",
    ["playerLogs"] = "Логи игрока",
    ["deleteLogs"] = "Видалити логи",
    ["xLogs"] = "%d логи",
    ["xAdminGroups"] = "%d Админ группи",
    ["noUserGroups"] = "Нет групп iгроков",
    ["userGroups"] = "Группи iгроков: %s",
    ["editUserGroups"] = "iзменить группи iгроков",
    ["newGroupColor"] = "Що следует новому цвету группу?",
    ["newGroupName"] = "Какое название новой группи?",
    ["groupAlreadyExists"] = "Эта группа уже существует!",
    ["whitelist"] = "Белий список",
    ["unWhitelist"] = "Искл. iз белого списка",
    ["addCustom"] = "Добавить свое",
    ["entClassWhitelist"] = "Какой класс сущностей ви би хотели добавить в белий список?",
    ["entClassAlreadyOnList"] = "Этот класс сущностей уже есть в списке!",
    ["changesServerRestart"] = "Некоторие iзменения не вступят в силу, пока сервер не будет перезагружен!",
    ["comingSoon"] = "Скоро!",
    ["features"] = "ФУНКЦИИ",
    ["addNewRarity"] = "Добавить новий раритет",
    ["newRarity"] = "Новий раритет",
    ["needToAddRarity"] = "Ви должни сначала добавить тип редкости!",
    ["whatRarityItem"] = "Какой редкости стоит этот предмет?",
    ["invalidRarity"] = "Неверная редкость.",
    ["rarityAlreadyExists"] = "Редкость с таким названием уже существует!",
    ["themeColorX"] = "Тема - Цвет %d",
    ["themeTextColor"] = "Тема - Цвет текста",
    ["presetAccents"] = "Предустановленние акценти",
    ["presetBackgrounds"] = "Предустановленние фони",
    ["resetToBaseThemes"] = "Сбросить тему к стандарту",
    ["resetToCurrentThemes"] = "Сброс к текущим темам",
    ["toggle"] = "Включить",
    ["menu"] = "Меню",
    ["emptyValue"] = "Пустое значение",
    ["newValueQuery"] = "Що следует пустому значению?",
    ["pressKey"] = "НАЖМИТЕ НА A",

    ["entityPlacer"] = "Спавн нового Entity",
    ["invalidEntityType"] = "Неверний тип объекта, виберите правильний iз меню инструментов.",
    ["entityPlaced"] = "Объект успешно размещен.",
    ["entityRemoved"] = "Сущность успешно удалена.",
    ["canOnlyUseToolEntity"] = "Ви можете Iспользовати этот инструмент только для удаления или создания объекта.",
    ["entityType"] = "Entity Тип",
    ["entityPlacerDescription"] = "Размещает и удаляет объекти с сервера Bricks и сохраняет их позиции. Левий щелчок - место. Правий клик - Видалити.",
    ["entityPlacerDescriptionSmall"] = "Размещает и удаляет объекти",
    ["entityPlacerInstructions"] = "Левий клик - разместить, правий клик - Видалити.",

    ["npcPlacer"] = "Установка NPC",
    ["npcPlaced"] = "NPC успешно размещен.",
    ["invalidNPCType"] = "Неверний тип NPC, виберите правильний iз меню инструментов.",
    ["npcRemoved"] = "NPC успешно удален.",
    ["errorNotNPC"] = "Ви можете Iспользовати этот инструмент только для удаления или создания NPC.",
    ["npcPlacerDescription"] = "Размещает и удаляет NPC с сервера Bricks. Щелкните левой кнопкой миши - поместите, щелкните правой кнопкой миши - удалите.",
    ["npcPlacerDescriptionSmall"] = "Размещает и удаляет NPC с сервера Brick.",

    ["inventory"] = "Iнвентар",
    ["player"] = "Iгрок",
    ["drop"] = "Вибросити",
    ["use"] = "Iспользовати",
    ["dropAll"] = "Вибросити все",
    ["delete"] = "Видалити",
} )
--PATH addons/____bricks_framework/lua/bricks_server/core/client/cl_popups.lua:
function BRICKS_SERVER.Func.Message( text, title, button, buttonFunc )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( text )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.15, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( text, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local bottomButton = vgui.Create( "DButton", backPanel )
	bottomButton:SetText( "" )
	bottomButton:Dock( BOTTOM )
	bottomButton:DockMargin( 10, 10, 10, 10 )
	bottomButton:SetTall( 40 )
	local changeAlpha = 0
	bottomButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( button, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	bottomButton.DoClick = function()
		if( buttonFunc ) then
			buttonFunc()
		end
		
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	backPanel:SetTall( bottomButton:GetTall()+(4*10)+textArea:GetTall()+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.Query( text, title, confirmText, cancelText, confirmFunc, cancelFunc )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( text )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.15, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( text, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local buttonBack = vgui.Create( "DPanel", backPanel )
	buttonBack:Dock( BOTTOM )
	buttonBack:DockMargin( 10, 10, 10, 10 )
	buttonBack:SetTall( 40 )
	buttonBack.Paint = function() end

	local confirmButton = vgui.Create( "DButton", buttonBack )
	confirmButton:SetText( "" )
	confirmButton:Dock( LEFT )
	confirmButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	local changeAlpha = 0
	confirmButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	confirmButton.DoClick = function()
		if( confirmFunc ) then
			confirmFunc()
		end
		
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	local cancelButton = vgui.Create( "DButton", buttonBack )
	cancelButton:SetText( "" )
	cancelButton:Dock( RIGHT )
	cancelButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	local changeAlpha = 0
	cancelButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	cancelButton.DoClick = function()
		if( cancelFunc ) then
			cancelFunc()
		end

		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	backPanel:SetTall( buttonBack:GetTall()+(4*10)+textArea:GetTall()+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.StringRequest( title, subtitle, default, func_confirm, func_cancel, confirmText, cancelText, numberOnly )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( subtitle )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.15, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( subtitle, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local textEntryBack = vgui.Create( "DPanel", backPanel )
	textEntryBack:Dock( TOP )
	textEntryBack:DockMargin( 10, 10, 10, 0 )
	textEntryBack:SetTall( 40 )
    local Alpha = 0
    local textEntry
    local color1 = BRICKS_SERVER.Func.GetTheme( 1 )
    textEntryBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

        if( textEntry:IsEditing() ) then
            Alpha = math.Clamp( Alpha+5, 0, 100 )
        else
            Alpha = math.Clamp( Alpha-5, 0, 100 )
        end
        
        draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
    end

	if( numberOnly ) then
		textEntry = vgui.Create( "bricks_server_numberwang", textEntryBack )
		textEntry:Dock( FILL )
		textEntry:SetMinMax( 0, 9999999999999 )
	else
		textEntry = vgui.Create( "bricks_server_textentry", textEntryBack )
		textEntry:Dock( FILL )
	end
	textEntry:SetValue( default or "" )

	local buttonPanel = vgui.Create( "DPanel", backPanel )
	buttonPanel:Dock( BOTTOM )
	buttonPanel:DockMargin( 10, 10, 10, 10 )
	buttonPanel:SetTall( 40 )
	buttonPanel.Paint = function( self2, w, h ) end

	local leftButton = vgui.Create( "DButton", buttonPanel )
	leftButton:Dock( LEFT )
	leftButton:SetText( "" )
	leftButton:DockMargin( 0, 0, 0, 0 )
	leftButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	local changeAlpha = 0
	leftButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	leftButton.DoClick = function()
		func_confirm( textEntry:GetValue() )
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	local rightButton = vgui.Create( "DButton", buttonPanel )
	rightButton:Dock( RIGHT )
	rightButton:SetText( "" )
	rightButton:DockMargin( 0, 0, 0, 0 )
	rightButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	local changeAlpha = 0
	rightButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	rightButton.DoClick = function()
		func_cancel( textEntry:GetValue() )
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	backPanel:SetTall( buttonPanel:GetTall()+(4*10)+textArea:GetTall()+textEntryBack:GetTall()+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.ComboRequest( title, subtitle, default, options, func_confirm, func_cancel, confirmText, cancelText, searchSelect )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( subtitle )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.15, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( subtitle, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local comboEntry
	if( not searchSelect ) then
		comboEntry = vgui.Create( "bricks_server_combo", backPanel )
	else
		comboEntry = vgui.Create( "bricks_server_combo_search", backPanel )
	end

	if( not IsValid( comboEntry ) ) then return end

	comboEntry:Dock( TOP )
	comboEntry:DockMargin( 10, 10, 10, 0 )
	comboEntry:SetTall( 40 )
	comboEntry:SetValue( BRICKS_SERVER.Func.L( "selectOption" ) )
	for k, v in pairs( options ) do
		if( default != k and default != v ) then
			comboEntry:AddChoice( v, k, false )
		else
			comboEntry:AddChoice( v, k, true )
		end
	end

	local buttonPanel = vgui.Create( "DPanel", backPanel )
	buttonPanel:Dock( BOTTOM )
	buttonPanel:DockMargin( 10, 10, 10, 10 )
	buttonPanel:SetTall( 40 )
	buttonPanel.Paint = function( self2, w, h ) end

	local leftButton = vgui.Create( "DButton", buttonPanel )
	leftButton:Dock( LEFT )
	leftButton:SetText( "" )
	leftButton:DockMargin( 0, 0, 0, 0 )
	leftButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	local changeAlpha = 0
	leftButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	leftButton.DoClick = function()
		local value, data = comboEntry:GetSelected()
		if( value and data ) then
			func_confirm( value, data )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		else
			notification.AddLegacy( BRICKS_SERVER.Func.L( "selectValue" ), 1, 3 )
		end
	end

	local rightButton = vgui.Create( "DButton", buttonPanel )
	rightButton:Dock( RIGHT )
	rightButton:SetText( "" )
	rightButton:DockMargin( 0, 0, 0, 0 )
	rightButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	local changeAlpha = 0
	rightButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	rightButton.DoClick = function()
		local value, data = comboEntry:GetSelected()
		if( value and data ) then
			func_cancel( value, data )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		else
			func_cancel( false, false )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		end
	end

	backPanel:SetTall( buttonPanel:GetTall()+(4*10)+textArea:GetTall()+comboEntry:GetTall()+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.ColorRequest( title, subtitle, default, func_confirm, func_cancel, confirmText, cancelText )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( subtitle )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.17, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( subtitle, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local colorEntry = vgui.Create( "DColorMixer", backPanel )
	colorEntry:Dock( TOP )
	colorEntry:DockMargin( 10, 10, 10, 0 )
	colorEntry:SetTall( 150 )
	colorEntry:SetPalette( false )
	colorEntry:SetAlphaBar( false) 
	colorEntry:SetWangs( true )
	colorEntry:SetColor( default or Color( 255, 255, 255 ) )
	local displayColor = colorEntry:GetColor()
	colorEntry.ValueChanged = function()
		displayColor = colorEntry:GetColor()
	end

	local displayColorPanel = vgui.Create( "DPanel", backPanel )
	displayColorPanel:Dock( TOP )
	displayColorPanel:DockMargin( 10, 10, 10, 10 )
	displayColorPanel:SetTall( 20 )
	displayColorPanel.Paint = function( self2, w, h ) 
		draw.RoundedBox( 5, 0, 0, w, h, displayColor )
	end

	local buttonPanel = vgui.Create( "DPanel", backPanel )
	buttonPanel:Dock( BOTTOM )
	buttonPanel:DockMargin( 10, 0, 10, 10 )
	buttonPanel:SetTall( 40 )
	buttonPanel.Paint = function( self2, w, h ) end

	local leftButton = vgui.Create( "DButton", buttonPanel )
	leftButton:Dock( LEFT )
	leftButton:SetText( "" )
	leftButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( confirmText )
	textX = textX+20
	leftButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	leftButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	leftButton.DoClick = function()
		local value = colorEntry:GetColor()
		if( value ) then
			func_confirm( value )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		else
			notification.AddLegacy( BRICKS_SERVER.Func.L( "selectColor" ), 1, 3 )
		end
	end

	local rightButton = vgui.Create( "DButton", buttonPanel )
	rightButton:Dock( RIGHT )
	rightButton:SetText( "" )
	rightButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( cancelText )
	textX = textX+20
	rightButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	rightButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	rightButton.DoClick = function()
		local value = colorEntry:GetColor()
		if( value ) then
			func_cancel( value )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		else
			func_cancel( false )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		end
	end

	backPanel:SetTall( buttonPanel:GetTall()+(4*10)+textArea:GetTall()+colorEntry:GetTall()+displayColorPanel:GetTall()+10+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.PassiveQuery( text, title, time, confirmFunc, cancelFunc )
	local backPanel = vgui.Create( "bricks_server_dframepanel" )
	backPanel:DisableClose()
	backPanel:SetHeader( title )
	backPanel:SetWide( ScrW()*0.1 )

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( text, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local buttonBack = vgui.Create( "DPanel", backPanel )
	buttonBack:Dock( BOTTOM )
	buttonBack:DockMargin( 10, 10, 10, 10 )
	buttonBack:SetTall( 40 )
	buttonBack.Paint = function() end

	local confirmButton = vgui.Create( "DButton", buttonBack )
	confirmButton:SetText( "" )
	confirmButton:Dock( LEFT )
	confirmButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	local changeAlpha = 0
	local tickMat = Material( "materials/bricks_server/tick_nofill.png" )
	confirmButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
		surface.SetMaterial( tickMat )
		local size = 24
		surface.DrawTexturedRect( (w*0.5)-(size*0.5), (h*0.5)-(size*0.5), size, size )
	end
	confirmButton.DoClick = function()
		if( confirmFunc ) then
			confirmFunc()
		end
		
		backPanel:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( backPanel ) ) then
				backPanel:Remove()
			end
		end )
	end

	local cancelButton = vgui.Create( "DButton", buttonBack )
	cancelButton:SetText( "" )
	cancelButton:Dock( RIGHT )
	cancelButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	local changeAlpha = 0
	local denyMat = Material( "materials/bricks_server/close.png" )
	cancelButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
		surface.SetMaterial( denyMat )
		local size = 24
		surface.DrawTexturedRect( (w*0.5)-(size*0.5), (h*0.5)-(size*0.5), size, size )
	end
	cancelButton.DoClick = function()
		if( cancelFunc ) then
			cancelFunc()
		end

		backPanel:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( backPanel ) ) then
				backPanel:Remove()
			end
		end )
	end

	backPanel:SetTall( buttonBack:GetTall()+(4*10)+textArea:GetTall()+backPanel.headerHeight )
	backPanel:SetPos( 20, 20 )

	timer.Simple( (time or 5), function()
		if( IsValid( backPanel ) ) then
			if( cancelFunc ) then
				cancelFunc()
			end
			
			backPanel:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( backPanel ) ) then
					backPanel:Remove()
				end
			end )
		end
	end )
end

function BRICKS_SERVER.Func.CreatePopoutQuery( text, parent, panelWide, panelTall, confirmText, cancelText, confirmFunc, cancelFunc, disableBackgroundButton )
	if( IsValid( parent.brs_popout ) ) then
		parent.brs_popout:Remove()
	end

	local popoutClose = vgui.Create( "DButton", parent )
	popoutClose:SetSize( panelWide, panelTall )
	popoutClose:SetAlpha( 0 )
	popoutClose:AlphaTo( 255, 0.2 )
	popoutClose:SetText( "" )
	popoutClose:SetCursor( "arrow" )
	popoutClose.Paint = function( self2, w, h )
		surface.SetDrawColor( 0, 0, 0, 150 )
		surface.DrawRect( 0, 0, w, h )
		BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( text )

	local popoutWide, popoutTall = math.max( ScrW()*0.15, textX+40 ), 40+(4*10)+30+20

	parent.brs_popout = vgui.Create( "DPanel", parent )
	parent.brs_popout:SetSize( 0, 0 )
	parent.brs_popout:SizeTo( popoutWide, popoutTall, 0.2 )
	parent.brs_popout.Paint = function( self2, w, h )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		draw.SimpleText( text, "BRICKS_SERVER_Font20", w*0.5, h/3, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	parent.brs_popout.OnSizeChanged = function( self2 )
		self2:SetPos( (panelWide*0.5)-(self2:GetWide()*0.5), (panelTall*0.5)-(self2:GetTall()*0.5) )
	end
	parent.brs_popout.ClosePopout = function()
		if( IsValid( parent.brs_popout ) ) then
			parent.brs_popout:SizeTo( 0, 0, 0.2, 0, -1, function()
				if( IsValid( parent.brs_popout ) ) then
					parent.brs_popout:Remove()
				end
			end )
		end

		popoutClose:AlphaTo( 0, 0.2, 0, function()
			if( IsValid( popoutClose ) ) then
				popoutClose:Remove()
			end
		end )
	end

	popoutClose.DoClick = function()
		if( disableBackgroundButton ) then return end
		
		if( cancelFunc ) then
			cancelFunc()
		end

		parent.brs_popout.ClosePopout()
	end

	local buttonBack = vgui.Create( "DPanel", parent.brs_popout )
	buttonBack:Dock( BOTTOM )
	buttonBack:DockMargin( 10, 10, 10, 10 )
	buttonBack:SetTall( 40 )
	buttonBack.Paint = function() end

	local confirmButton = vgui.Create( "DButton", buttonBack )
	confirmButton:SetText( "" )
	confirmButton:Dock( LEFT )
	confirmButton:SetWide( (popoutWide-30)*0.5 )
	local changeAlpha = 0
	confirmButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	confirmButton.DoClick = function()
		if( confirmFunc ) then
			confirmFunc()
		end
		
		parent.brs_popout.ClosePopout()
	end

	local cancelButton = vgui.Create( "DButton", buttonBack )
	cancelButton:SetText( "" )
	cancelButton:Dock( RIGHT )
	cancelButton:SetWide( (popoutWide-30)*0.5 )
	local changeAlpha = 0
	cancelButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	cancelButton.DoClick = function()
		if( cancelFunc ) then
			cancelFunc()
		end

		parent.brs_popout.ClosePopout()
	end
end

function BRICKS_SERVER.Func.CreateTopNotification( text, time, accentColor )
	if( IsValid( BRS_TOPNOTIFICATION ) ) then
		BRS_TOPNOTIFICATION:Remove()
	end

	if( timer.Exists( "brs_topnotification_remove" ) ) then
		timer.Remove( "brs_topnotification_remove" )
	end

	surface.PlaySound( "ui/buttonclick.wav" )

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( text )

	local popoutWide, popoutTall = math.max( ScrW()*0.15, textX+40 ), 40

	BRS_TOPNOTIFICATION = vgui.Create( "DPanel" )
	BRS_TOPNOTIFICATION:SetSize( 0, popoutTall )
	BRS_TOPNOTIFICATION:SizeTo( popoutWide, popoutTall, 0.2 )
	BRS_TOPNOTIFICATION.Paint = function( self2, w, h )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, 0, 0, 5, h, (accentColor or BRICKS_SERVER.Func.GetTheme( 5 )), 10, h )
		BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, w-5, 0, 5, h, (accentColor or BRICKS_SERVER.Func.GetTheme( 5 )), 10, h, w-10 )

		draw.SimpleText( text, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	BRS_TOPNOTIFICATION.OnSizeChanged = function( self2 )
		self2:SetPos( (ScrW()*0.5)-(self2:GetWide()*0.5), 100 )
	end
	BRS_TOPNOTIFICATION.ClosePopout = function()
		if( IsValid( BRS_TOPNOTIFICATION ) ) then
			BRS_TOPNOTIFICATION:SizeTo( 0, popoutTall, 0.2, 0, -1, function()
				if( IsValid( BRS_TOPNOTIFICATION ) ) then
					BRS_TOPNOTIFICATION:Remove()
				end
			end )
		end
	end

	timer.Create( "brs_topnotification_remove", (time or 3), 1, function()
		if( IsValid( BRS_TOPNOTIFICATION ) ) then
			BRS_TOPNOTIFICATION.ClosePopout()
		end
	end )
end

function BRICKS_SERVER.Func.CreatePopoutPanel( parent, panelWide, panelTall, popoutWide, popoutTall )
	if( IsValid( parent.brs_popout ) ) then
		parent.brs_popout:Remove()
	end

	local popoutClose = vgui.Create( "DButton", parent )
	popoutClose:SetSize( panelWide, panelTall )
	popoutClose:SetAlpha( 0 )
	popoutClose:AlphaTo( 255, 0.2 )
	popoutClose:SetText( "" )
	popoutClose:SetCursor( "arrow" )
	popoutClose.Paint = function( self2, w, h )
		surface.SetDrawColor( 0, 0, 0, 150 )
		surface.DrawRect( 0, 0, w, h )
		BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
	end

	parent.brs_popout = vgui.Create( "DPanel", parent )
	parent.brs_popout:SetSize( 0, 0 )
	parent.brs_popout:SizeTo( popoutWide, popoutTall, 0.2 )
	parent.brs_popout.SetColor = function( self2, color )
		self2.backColor = color
	end
	parent.brs_popout.Paint = function( self2, w, h )
		draw.RoundedBox( 5, 0, 0, w, h, (self2.backColor or BRICKS_SERVER.Func.GetTheme( 2 )) )
	end
	parent.brs_popout.OnSizeChanged = function( self2 )
		self2:SetPos( (panelWide*0.5)-(self2:GetWide()*0.5), (panelTall*0.5)-(self2:GetTall()*0.5) )
	end
	parent.brs_popout.ClosePopout = function()
		if( IsValid( parent.brs_popout ) ) then
			parent.brs_popout:SizeTo( 0, 0, 0.2, 0, -1, function()
				if( IsValid( parent.brs_popout ) ) then
					parent.brs_popout:Remove()
				end
			end )
		end

		popoutClose:AlphaTo( 0, 0.2, 0, function()
			if( IsValid( popoutClose ) ) then
				popoutClose:Remove()
			end
		end )
	end

	popoutClose.DoClick = function()
		parent.brs_popout.ClosePopout()
	end

	return parent.brs_popout
end

function BRICKS_SERVER.Func.CreatePopoutConfigPanel( parent, panelWide, panelTall, popoutWide, popoutTall, confirmFunc, cancelFunc )
	local popoutPanel = BRICKS_SERVER.Func.CreatePopoutPanel( parent, panelWide, panelTall, popoutWide, popoutTall )

	local buttonBack = vgui.Create( "DPanel", popoutPanel )
	buttonBack:Dock( BOTTOM )
	buttonBack:DockMargin( 10, 10, 10, 10 )
	buttonBack:SetTall( 40 )
	buttonBack.Paint = function() end

	local saveButton = vgui.Create( "DButton", buttonBack )
	saveButton:SetText( "" )
	saveButton:Dock( LEFT )
	saveButton:SetWide( (popoutWide-30)*0.5 )
	local changeAlpha = 0
	saveButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( "Save", "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	saveButton.DoClick = function()
		if( confirmFunc ) then
			confirmFunc()
		end
		
		popoutPanel.ClosePopout()
	end

	local cancelButton = vgui.Create( "DButton", buttonBack )
	cancelButton:SetText( "" )
	cancelButton:Dock( RIGHT )
	cancelButton:SetWide( (popoutWide-30)*0.5 )
	local changeAlpha = 0
	cancelButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( "Cancel", "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	cancelButton.DoClick = function()
		if( cancelFunc ) then
			cancelFunc()
		end

		popoutPanel.ClosePopout()
	end

	return popoutPanel
end
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_config_languages.lua:
local PANEL = {}

function PANEL:Init()
    self.margin = 0

    local panelWide = ScrW()*0.6-BRICKS_SERVER.DEVCONFIG.MainNavWidth
    local panelTall = (ScrH()*0.65)-40

    local function CreateEditPopout( languageKey )
        if( IsValid( self.popout ) ) then
            self.popout:Remove()
        end

        local popoutClose = vgui.Create( "DPanel", self )
        popoutClose:SetSize( panelWide, panelTall )
        popoutClose:SetAlpha( 0 )
        popoutClose:AlphaTo( 255, 0.2 )
        popoutClose.Paint = function( self2, w, h )
            surface.SetDrawColor( 0, 0, 0, 150 )
            surface.DrawRect( 0, 0, w, h )
            BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
        end

        local popoutWide, popoutTall = panelWide-panelWide*0.1, panelTall-panelWide*0.1

        self.popout = vgui.Create( "DPanel", self )
        self.popout:SetSize( 0, 0 )
        self.popout:SizeTo( popoutWide, popoutTall, 0.2 )
        self.popout.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        end
        self.popout.OnSizeChanged = function( self2 )
            self2:SetPos( (panelWide*0.5)-(self2:GetWide()*0.5), (panelTall*0.5)-(self2:GetTall()*0.5) )
        end
        self.popout.ClosePopout = function()
            if( IsValid( self.popout ) ) then
                self.popout:SizeTo( 0, 0, 0.2, 0, -1, function()
                    if( IsValid( self.popout ) ) then
                        self.popout:Remove()
                    end
                end )
            end

            popoutClose:AlphaTo( 0, 0.2, 0, function()
                if( IsValid( popoutClose ) ) then
                    popoutClose:Remove()
                end
            end )
        end

        local popoutCloseButton = vgui.Create( "DButton", self.popout )
        popoutCloseButton:Dock( BOTTOM )
        popoutCloseButton:SetTall( 40 )
        popoutCloseButton:SetText( "" )
        popoutCloseButton:DockMargin( 25, 0, 25, 25 )
        local changeAlpha = 0
        popoutCloseButton.Paint = function( self2, w, h )
            if( not self2:IsDown() and self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            
            draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        popoutCloseButton.DoClick = self.popout.ClosePopout

        local originalLanguageTable = table.Copy( BRICKS_SERVER.Languages[languageKey] or {} )

        local topBar = vgui.Create( "DPanel", self.popout )
        topBar:Dock( TOP )
        topBar:SetTall( 40 )
        topBar:DockMargin( 25, 25, 25, 0 )
        topBar.Paint = function( self2, w, h ) end

        local buttons = {
            {
                Title = "Auto Fill",
                Color = Color( 46, 204, 113 ),
                DoClick = function()
                    local options = { 
                        ["af"] = "Afrikaans",
                        ["ga"] = "Irish",
                        ["sq"] = "Albanian",
                        ["it"] = "Italian",
                        ["ja"] = "Japanese",
                        ["az"] = "Azerbaijani",
                        ["kn"] = "Kannada",
                        ["eu"] = "Basque",
                        ["ko"] = "Korean",
                        ["bn"] = "Bengali",
                        ["la"] = "Latin",
                        ["be"] = "Belarusian",
                        ["lv"] = "Latvian",
                        ["bg"] = "Bulgarian",
                        ["ca"] = "Catalan",
                        ["mk"] = "Macedonian",
                        ["zh-CN"] = "Chinese Simplified",
                        ["ms"] = "Malay",
                        ["zh-TW"] = "Chinese Traditional",
                        ["mt"] = "Maltese",
                        ["hr"] = "Croatian",
                        ["no"] = "Norwegian",
                        ["cs"] = "Czech",
                        ["fa"] = "Persian",
                        ["da"] = "Danish",
                        ["pl"] = "Polish",
                        ["nl"] = "Dutch",
                        ["ro"] = "Romanian",
                        ["eo"] = "Esperanto",
                        ["ru"] = "Russian",
                        ["et"] = "Estonian",
                        ["sr"] = "Serbian",
                        ["tl"] = "Filipino",
                        ["sk"] = "Slovak",
                        ["fi"] = "Finnish",
                        ["sl"] = "Slovenian",
                        ["fr"] = "French",
                        ["es"] = "Spanish",
                        ["gl"] = "Galician",
                        ["sw"] = "Swahili",
                        ["ka"] = "Georgian",
                        ["de"] = "German",
                        ["ta"] = "Tamil",
                        ["el"] = "Greek",
                        ["te"] = "Telugu",
                        ["gu"] = "Gujarati",
                        ["th"] = "Thai",
                        ["ht"] = "Haitian Creole",
                        ["tr"] = "Turkish",
                        ["iw"] = "Hebrew",
                        ["uk"] = "Ukrainian",
                        ["hi"] = "Hindi",
                        ["ur"] = "Urdu",
                        ["hu"] = "Hungarian",
                        ["vi"] = "Vietnamese",
                        ["is"] = "Icelandic",
                        ["cy"] = "Welsh",
                        ["id"] = "Indonesian",
                        ["yi"] = "Yiddish"
                    }
                    for k, v in pairs( {} ) do
                        options[k] = k
                    end
                    
                    BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), "What language would you like to auto fill?", "None", options, function( value, data ) 
                        if( options[data] ) then
                            local stringsToTranslate = {}
                            for k, v in pairs( BRICKS_SERVER.Languages["english"] ) do
                                local textEntry = self.popout.textEntries[k]
        
                                if( not IsValid( textEntry ) ) then continue end
        
                                table.insert( stringsToTranslate, { k, v, textEntry } )
                            end
        
                            local function translateNext()
                                if( not IsValid( self ) or not self:IsVisible() ) then return end
        
                                if( #stringsToTranslate <= 0 ) then return end
        
                                local nextStringTable = stringsToTranslate[1]
        
                                if( not nextStringTable ) then return end
        
                                if( not IsValid( nextStringTable[3] ) ) then
                                    table.remove( stringsToTranslate, 1 )
                                    translateNext()
                                    return
                                end
        
                                nextStringTable[3]:GetParent().translating = true
        
                                BRICKS_SERVER.Func.GetTranslatedString( data, nextStringTable[2], function( translatedString, errorMsg )
                                    if( not translatedString or errorMsg or not IsValid( nextStringTable[3] ) ) then
                                        print( "TRANSLATING ERROR: " .. (errorMsg or "UNKNOWN") )
        
                                        BRICKS_SERVER.Func.Message( "Your IP has been temporarily blocked by Google, please try again later.", BRICKS_SERVER.Func.L( "admin" ), "Confirm" )
        
                                        nextStringTable[3]:GetParent().translating = nil
                                        return
                                    else
                                        nextStringTable[3]:SetValue( translatedString )
                                    end
        
                                    table.remove( stringsToTranslate, 1 )
        
                                    timer.Simple( 0.5, function() 
                                        if( IsValid( nextStringTable[3] ) ) then
                                            nextStringTable[3]:GetParent().translating = nil
                                        end
        
                                        translateNext() 
                                    end )
                                end )
                            end
                            translateNext()
                        else
                            notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidType" ), 1, 3 )
                        end
                    end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
                end
            },
            {
                Title = "Reset Changes",
                Color = Color( 231, 76, 60 ),
                DoClick = function()
                    if( not BS_ConfigCopyTable.LANGUAGE.Languages or not BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] ) then return end
        
                    BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][2] = {}
        
                    BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
                    self.popout.RefreshLanguageStrings()
                end
            },
        }

        if( isnumber( languageKey ) ) then
            table.insert( buttons, {
                Title = "Delete",
                Color = Color( 231, 76, 60 ),
                DoClick = function()
                    if( not BS_ConfigCopyTable.LANGUAGE.Languages or not BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] ) then return end
        
                    if( isnumber( languageKey ) ) then
                        BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] = nil
                    end
        
                    BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
                    self.popout.ClosePopout()

                    self.RefreshPanel()
                end
            } )

            table.insert( buttons, {
                Title = "Edit Name",
                Color = Color( 127, 140, 141 ),
                DoClick = function()
                    if( not BS_ConfigCopyTable.LANGUAGE.Languages or not BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] ) then return end
        
                    if( isnumber( languageKey ) ) then
                        BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newNameQuery" ), (BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][1] or ""), function( text ) 
                            BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][1] = text
                            self.RefreshPanel()
                            BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
                        end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
                    end
                end
            } )
        end

        for k, v in ipairs( buttons ) do
            surface.SetFont( "BRICKS_SERVER_Font20" )
            local textX, textY = surface.GetTextSize( v.Title )
    
            local button = vgui.Create( "DButton", topBar )
            button:Dock( RIGHT )
            button:DockMargin( 5, 0, 0, 0 )
            button:SetText( "" )
            button:SetWide( textX+20 )
            local changeAlpha = 0
            button.Paint = function( self2, w, h )
                if( self2:IsDown() or self2.m_bSelected ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 5, 50 )
                elseif( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 5, 25 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 5, 50 )
                end
        
                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, v.Color or BRICKS_SERVER.Func.GetTheme( 4 ) )
                surface.SetAlphaMultiplier( 1 )
        
                draw.SimpleText( v.Title, "BRICKS_SERVER_Font20", 10, h*0.5, (v.Color or BRICKS_SERVER.Func.GetTheme( 5 )), 0, TEXT_ALIGN_CENTER )
            end
            button.DoClick = v.DoClick
        end

        local searchBarBack = vgui.Create( "DPanel", topBar )
        searchBarBack:Dock( FILL )
        local search = Material( "materials/bricks_server/search.png" )
        local Alpha = 0
        local Alpha2 = 20
        local color1 = BRICKS_SERVER.Func.GetTheme( 2 )
        local searchBar
        searchBarBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
    
            if( searchBar:IsEditing() ) then
                Alpha = math.Clamp( Alpha+5, 0, 100 )
                Alpha2 = math.Clamp( Alpha2+20, 20, 255 )
            else
                Alpha = math.Clamp( Alpha-5, 0, 100 )
                Alpha2 = math.Clamp( Alpha2-20, 20, 255 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
        
            surface.SetDrawColor( 255, 255, 255, Alpha2 )
            surface.SetMaterial(search)
            local size = 24
            surface.DrawTexturedRect( w-size-(h-size)*0.5, (h-size)*0.5, size, size )
        end
    
        searchBar = vgui.Create( "bricks_server_search", searchBarBack )
        searchBar:Dock( FILL )
        searchBar:SetFont( "BRICKS_SERVER_Font20" )

        local scrollPanel = vgui.Create( "bricks_server_scrollpanel_bar", self.popout )
        scrollPanel:Dock( FILL )
        scrollPanel:DockMargin( 25, 10, 25, 10 )

        function self.popout.RefreshLanguageStrings()
            scrollPanel:Clear()

            self.popout.textEntries = {}

            local languageTable = {}
            if( (BS_ConfigCopyTable.LANGUAGE.Languages or {})[languageKey] ) then
                table.Merge( languageTable, (BS_ConfigCopyTable.LANGUAGE.Languages or {})[languageKey][2] or {} )
            end

            local count = 0
            local languageStringCount = table.Count( BRICKS_SERVER.Languages["english"] )
            for k, v in pairs( BRICKS_SERVER.Languages["english"] ) do
                if( (searchBar:GetValue() or "") != "" and not string.find( string.lower( v ), string.lower( searchBar:GetValue() or "" ) ) and not string.find( string.lower( languageTable[k] or v ), string.lower( searchBar:GetValue() or "" ) ) ) then
                    continue
                end

                count = count+1

                local currentCount = count

                local languageBack = vgui.Create( "DPanel", scrollPanel )
                languageBack:Dock( TOP )
                languageBack:DockMargin( 0, 0, 10, 0 )
                languageBack:SetTall( 40 )
                languageBack.Paint = function( self2, w, h )
                    if( currentCount == 1 ) then
                        draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ), true, true, false, false )
                    elseif( currentCount >= languageStringCount ) then
                        draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ), false, false, true, true )
                    else
                        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
                        surface.DrawRect( 0, 0, w, h )
                    end

                    if( self2.translating ) then
                        if( currentCount == 1 ) then
                            draw.RoundedBoxEx( 5, w*0.5+1, 0, w*0.5-1, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, true, false, false )
                        elseif( currentCount >= languageStringCount ) then
                            draw.RoundedBoxEx( 5, w*0.5+1, 0, w*0.5-1, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, false, false, true )
                        else
                            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                            surface.DrawRect( w*0.5+1, 0, w*0.5-1, h )
                        end
                    end

                    if( currentCount < languageStringCount ) then
                        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
                        surface.DrawRect( 0, h-1, w, 1 )
                    end

                    surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
                    surface.DrawRect( w*0.5, 0, 1, h )
        
                    draw.SimpleText( v, "BRICKS_SERVER_Font20", 10, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
                end

                local languageTextEntry = vgui.Create( "bricks_server_textentry", languageBack )
                languageTextEntry:Dock( RIGHT )
                languageTextEntry:DockMargin( 0, 0, 10, 0 )
                languageTextEntry:SetWide( (popoutWide-50-20-30)*0.5 )
                languageTextEntry:SetValue( languageTable[k] or v )
                languageTextEntry:SetFont( "BRICKS_SERVER_Font20" )
                languageTextEntry:SetUpdateOnType( true )
                languageTextEntry.OnValueChange = function( self2, value )
                    if( not BS_ConfigCopyTable.LANGUAGE.Languages ) then
                        BS_ConfigCopyTable.LANGUAGE.Languages = {}
                    end

                    if( not BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] ) then
                        BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] = { false, {} }
                    end

                    if( languageTextEntry:GetValue() != originalLanguageTable[k] ) then
                        BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][2][k] = languageTextEntry:GetValue()
                    else
                        BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][2][k] = nil
                    end
        
                    BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
                end

                self.popout.textEntries[k] = languageTextEntry
            end
        end
        self.popout.RefreshLanguageStrings()

        searchBar.OnChange = function()
            self.popout.RefreshLanguageStrings()
        end
    end

    local scrollPanel = vgui.Create( "bricks_server_scrollpanel", self )
    scrollPanel:Dock( FILL )
    scrollPanel:DockMargin( 10, 10, 10, 10 )

    local languageSpacing = 10
    local gridWide = (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth-20
    local slotSize = 320
    local slotsWide = math.floor( gridWide/slotSize )
    local actualSlotSize = (gridWide-((slotsWide-1)*languageSpacing))/slotsWide

    local slotTall = 125
    local languageGrid = vgui.Create( "DIconLayout", scrollPanel )
    languageGrid:Dock( TOP )
    languageGrid:SetSpaceY( languageSpacing )
    languageGrid:SetSpaceX( languageSpacing )
    languageGrid:SetTall( slotTall )

    function self.RefreshPanel()
        languageGrid:Clear()

        local languages = {}
        for k, v in pairs( BRICKS_SERVER.Languages ) do
            local key = table.insert( languages, { k, table.Copy( v ) } )

            if( (BS_ConfigCopyTable.LANGUAGE.Languages or {})[k] ) then
                table.Merge( languages[key][2], (BS_ConfigCopyTable.LANGUAGE.Languages or {})[k][2] )
            end
        end

        for k, v in pairs( BS_ConfigCopyTable.LANGUAGE.Languages or {} ) do
            if( not v[1] ) then continue end

            table.insert( languages, { k, v[2], v[1] } )
        end

        for k, v in pairs( languages ) do
            languageGrid.slots = (languageGrid.slots or 0)+1
            local slots = languageGrid.slots
            local slotsTall = math.ceil( slots/slotsWide )
            languageGrid:SetTall( (slotsTall*slotTall)+((slotsTall-1)*languageSpacing) )

            local missingLanguageStrings = math.max( 0, table.Count( BRICKS_SERVER.Languages["english"] or {} ) - table.Count( v[2] ) )

            local languageBack = vgui.Create( "DPanel", languageGrid )
            languageBack:SetSize( actualSlotSize, slotTall )
            languageBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                draw.SimpleText( string.upper( v[3] or v[1] ), "BRICKS_SERVER_Font25", w*0.5, h/3, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

                if( missingLanguageStrings > 0 ) then
                    draw.SimpleText( missingLanguageStrings .. " missing language strings", "BRICKS_SERVER_Font20", w*0.5, h/3, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, TEXT_ALIGN_CENTER, 0 )
                else
                    draw.SimpleText( missingLanguageStrings .. " missing language strings", "BRICKS_SERVER_Font20", w*0.5, h/3, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green, TEXT_ALIGN_CENTER, 0 )
                end
            end

            local languageEditButton = vgui.Create( "DButton", languageBack )
            languageEditButton:SetSize( 36, 36 )
            languageEditButton:SetPos( actualSlotSize-10-languageEditButton:GetWide(), 10 )
            languageEditButton:SetText( "" )
            local alpha = 0
            local editMat = Material( "materials/bricks_server/edit.png" )
            languageEditButton.Paint = function( self2, w, h )
                if( not self2:IsDown() and self2:IsHovered() ) then
                    alpha = math.Clamp( alpha+10, 0, 95 )
                else
                    alpha = math.Clamp( alpha-10, 0, 95 )
                end

                surface.SetAlphaMultiplier( alpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
                surface.SetAlphaMultiplier( 1 )

                BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

                surface.SetMaterial( editMat )
                local size = 24
                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
                surface.DrawTexturedRect( (h-size)*0.5, (h-size)*0.5, size, size )
            end
            languageEditButton.DoClick = function()
                CreateEditPopout( v[1] )
            end

            local languageButton = vgui.Create( "DButton", languageBack )
            languageButton:Dock( BOTTOM )
            languageButton:DockMargin( 10, 10, 10, 10 )
            languageButton:SetTall( 40 )
            languageButton:SetText( "" )
            local alpha = 0
            languageButton.Paint = function( self2, w, h )
                local buttonText, buttonColor, buttonDownColor = BRICKS_SERVER.Func.L( "unselected" ), BRICKS_SERVER.Func.GetTheme( 2 ), BRICKS_SERVER.Func.GetTheme( 1 )

                if( (BS_ConfigCopyTable.LANGUAGE.Language or "english") == v[1] ) then
                    buttonText, buttonColor, buttonDownColor = BRICKS_SERVER.Func.L( "selected" ), BRICKS_SERVER.Func.GetTheme( 5 ), BRICKS_SERVER.Func.GetTheme( 4 )
                end

                if( not self2:IsDown() and self2:IsHovered() ) then
                    alpha = math.Clamp( alpha+5, 0, 200 )
                else
                    alpha = math.Clamp( alpha-5, 0, 255 )
                end

                draw.RoundedBox( 5, 0, 0, w, h, buttonColor )

                surface.SetAlphaMultiplier( alpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, buttonDownColor )
                surface.SetAlphaMultiplier( 1 )

                BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, buttonDownColor )

                draw.SimpleText( buttonText, "BRICKS_SERVER_Font20", w*0.5, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
            languageButton.DoClick = function()
                if( (BS_ConfigCopyTable.LANGUAGE.Language or "") == v[1] ) then return end

                BS_ConfigCopyTable.LANGUAGE.Language = v[1]
                BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
            end
        end

        -- Create new
        languageGrid.slots = (languageGrid.slots or 0)+1
        local slots = languageGrid.slots
        local slotsTall = math.ceil( slots/slotsWide )
        languageGrid:SetTall( (slotsTall*slotTall)+((slotsTall-1)*languageSpacing) )

        local createNewBack = vgui.Create( "DPanel", languageGrid )
        createNewBack:SetSize( actualSlotSize, slotTall )
        createNewBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

            draw.SimpleText( BRICKS_SERVER.Func.L( "createNew" ), "BRICKS_SERVER_Font25", w*0.5, h/3, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

            draw.SimpleText( BRICKS_SERVER.Func.L( "createNewLanguage" ), "BRICKS_SERVER_Font20", w*0.5, h/3, BRICKS_SERVER.Func.GetTheme( 5 ), TEXT_ALIGN_CENTER, 0 )
        end

        local createNewButton = vgui.Create( "DButton", createNewBack )
        createNewButton:Dock( BOTTOM )
        createNewButton:DockMargin( 10, 10, 10, 10 )
        createNewButton:SetTall( 40 )
        createNewButton:SetText( "" )
        local alpha = 0
        createNewButton.Paint = function( self2, w, h )
            if( not self2:IsDown() and self2:IsHovered() ) then
                alpha = math.Clamp( alpha+5, 0, 200 )
            else
                alpha = math.Clamp( alpha-5, 0, 255 )
            end

            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )

            surface.SetAlphaMultiplier( alpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )

            draw.SimpleText( BRICKS_SERVER.Func.L( "create" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        createNewButton.DoClick = function()
            if( not BS_ConfigCopyTable.LANGUAGE.Languages ) then
                BS_ConfigCopyTable.LANGUAGE.Languages = {}
            end

            table.insert( BS_ConfigCopyTable.LANGUAGE.Languages, { "New Language", {} } )
            self.RefreshPanel()

            BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_config_languages", PANEL, "DPanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dcategorylist.lua:

local PANEL = {}

function PANEL:Init()

	self.pnlCanvas:DockPadding( 0, 0, 0, 0 )

end

function PANEL:AddItem( item )

	item:Dock( TOP )
	DScrollPanel.AddItem( self, item )
	self:InvalidateLayout()

end

function PANEL:Add( name, backColor, fillBackColor )

	local Category = vgui.Create( "bricks_server_dcollapsiblecategory", self )
	Category:SetLabel( "" )
	Category:SetList( self )
	Category.backColor = backColor
	Category.headerText = name
	Category.fillBackColor = fillBackColor

	self:AddItem( Category )

	return Category

end

function PANEL:Paint( w, h )

end

function PANEL:UnselectAll()

	for k, v in pairs( self:GetChildren() ) do

		if ( v.UnselectAll ) then
			v:UnselectAll()
		end

	end

end

derma.DefineControl( "bricks_server_dcategorylist", "", PANEL, "bricks_server_scrollpanel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dnumslider.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_fDefaultValue", "DefaultValue" )

function PANEL:Init()
	self.TextArea = self:Add( "DTextEntry" )
	self.TextArea:Dock( RIGHT )
	self.TextArea:DockMargin( 20, 0, 0, 0 )
	self.TextArea:SetPaintBackground( false )
	self.TextArea:SetWide( 45 )
	self.TextArea:SetNumeric( true )
	self.TextArea:SetTextColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
	self.TextArea:SetFont( "BRICKS_SERVER_Font17" )
	self.TextArea.OnChange = function( textarea, val ) self:SetValue( self.TextArea:GetText() ) end

	self.Slider = self:Add( "bricks_server_dslider", self )
	self.Slider:SetLockY( 0.5 )
	self.Slider.TranslateValues = function( slider, x, y ) return self:TranslateSliderValues( x, y ) end
	self.Slider:Dock( FILL )
	self.Slider:SetHeight( 16 )
	self.Slider.Knob.OnMousePressed = function( panel, mcode )
		if ( mcode == MOUSE_MIDDLE ) then
			self:ResetToDefaultValue()
			return
		end
		self.Slider:OnMousePressed( mcode )
	end

	self:SetTall( 32 )

	self:SetMin( 0 )
	self:SetMax( 1 )
	self:SetValue( 1 )
	self.Slider:SetSlideX( 0 )
end

function PANEL:SetMinMax( min, max )
	self:UpdateNotches()
end

function PANEL:GetMin()
	return self.min or 0
end

function PANEL:GetMax()
	return self.max or 1
end

function PANEL:GetRange()
	return self:GetMax() - self:GetMin()
end

function PANEL:ResetToDefaultValue()
	if ( !self:GetDefaultValue() ) then return end
	self:SetValue( self:GetDefaultValue() )
end

function PANEL:SetMin( min )

	if ( !min ) then min = 0 end

	self.min = tonumber( min )
	self:UpdateNotches()

end

function PANEL:SetMax( max )

	if ( !max ) then max = 0 end

	self.max = tonumber( max )
	self:UpdateNotches()

end

function PANEL:SetValue( val )

	val = math.Clamp( tonumber( val ) || 0, self:GetMin(), self:GetMax() )

	if ( self:GetValue() == val ) then return end

	self.value = val

	self:ValueChanged( self:GetValue() ) -- In most cases this will cause double execution of OnValueChanged

end

function PANEL:GetFloatValue()
	return self.value or 0
end

function PANEL:GetValue()
	return self.value or 0
end

--
-- Are we currently changing the value?
--
function PANEL:IsEditing()

	return self.TextArea:IsEditing() || self.Slider:IsEditing()

end

function PANEL:IsHovered()

	return self.TextArea:IsHovered() || self.Slider:IsHovered() || vgui.GetHoveredPanel() == self

end

function PANEL:PerformLayout()
	self.Slider:PerformLayout()
end

function PANEL:ValueChanged( val )

	val = math.Clamp( tonumber( val ) || 0, self:GetMin(), self:GetMax() )

	self.Slider:SetSlideX( self.value/self.max )

	self:OnValueChanged( val )
	self.TextArea:SetText( math.floor( val ) )
end

function PANEL:OnValueChanged( val )

	-- For override

end

function PANEL:TranslateSliderValues( x, y )

	self:SetValue( self:GetMin() + ( x * self:GetRange() ) )

	return (self:GetValue()-self:GetMin())/self:GetRange(), y

end

function PANEL:GetTextArea()

	return self.TextArea

end

function PANEL:UpdateNotches()

	local range = self:GetRange()
	self.Slider:SetNotches( nil )

	if ( range < self:GetWide() / 4 ) then
		return self.Slider:SetNotches( range )
	else
		self.Slider:SetNotches( self:GetWide() / 4 )
	end

end

function PANEL:SetEnabled( b )
	self.Slider:SetEnabled( b )
	FindMetaTable( "Panel" ).SetEnabled( self, b ) -- There has to be a better way!
end

derma.DefineControl( "bricks_server_dnumslider", "Menu Option Line", table.Copy( PANEL ), "Panel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_scrollpanel_bar.lua:

local PANEL = {}

AccessorFunc( PANEL, "Padding", "Padding" )
AccessorFunc( PANEL, "pnlCanvas", "Canvas" )

function PANEL:Init()

	self.pnlCanvas = vgui.Create( "Panel", self )
	self.pnlCanvas.OnMousePressed = function( self, code ) self:GetParent():OnMousePressed( code ) end
	self.pnlCanvas:SetMouseInputEnabled( true )
	self.pnlCanvas.PerformLayout = function( pnl )

		self:PerformLayout()
		self:InvalidateParent()

	end

	-- Create the scroll bar
	self.VBar = vgui.Create( "bricks_server_dvscrollbar", self )
	self.VBar:Dock( RIGHT )

	self:SetPadding( 0 )
	self:SetMouseInputEnabled( true )

	-- This turns off the engine drawing
	self:SetPaintBackgroundEnabled( false )
	self:SetPaintBorderEnabled( false )
	self:SetPaintBackground( false )

end

function PANEL:SetBarBackColor( color )
	self.VBar.backColor = color
end

function PANEL:SetBarColor( color )
	self.VBar.barColor = color
end

function PANEL:SetBarDownColor( color )
	self.VBar.barDownColor = color
end

function PANEL:AddItem( pnl )

	pnl:SetParent( self:GetCanvas() )

end

function PANEL:OnChildAdded( child )

	self:AddItem( child )

end

function PANEL:SizeToContents()

	self:SetSize( self.pnlCanvas:GetSize() )

end

function PANEL:GetVBar()

	return self.VBar

end

function PANEL:GetCanvas()

	return self.pnlCanvas

end

function PANEL:InnerWidth()

	return self:GetCanvas():GetWide()

end

function PANEL:Rebuild()

	self:GetCanvas():SizeToChildren( false, true )

	-- Although this behaviour isn't exactly implied, center vertically too
	if ( self.m_bNoSizing && self:GetCanvas():GetTall() < self:GetTall() ) then

		self:GetCanvas():SetPos( 0, ( self:GetTall() - self:GetCanvas():GetTall() ) * 0.5 )

	end

end

function PANEL:OnMouseWheeled( dlta )

	return self.VBar:OnMouseWheeled( dlta )

end

function PANEL:OnVScroll( iOffset )

	self.pnlCanvas:SetPos( 0, iOffset )

end

function PANEL:ScrollToChild( panel )

	self:PerformLayout()

	local x, y = self.pnlCanvas:GetChildPosition( panel )
	local w, h = panel:GetSize()

	y = y + h * 0.5
	y = y - self:GetTall() * 0.5

	self.VBar:AnimateTo( y, 0.5, 0, 0.5 )

end

function PANEL:PerformLayout()
	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end
end

function PANEL:Clear()

	return self.pnlCanvas:Clear()

end

derma.DefineControl( "bricks_server_scrollpanel_bar", "", PANEL, "DPanel" )

--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/client/cl_gang_entitydisplay.lua:
local circleSize = 50
hook.Add( "PostPlayerDraw", "BricksServerHooks_PostPlayerDraw_DrawGangEntityDisplay", function( ply )
    if( not LocalPlayer():HasGang() ) then return end

    if( not IsValid( ply ) or not ply:Alive() or ply == LocalPlayer() ) then return end

    local drawColor

    if( ply:HasGang() and ply:GetGangID() == LocalPlayer():GetGangID() ) then 
        drawColor = BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen
    elseif( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "associations" ) ) then
        local associationType = LocalPlayer():GetGangAssociationWith( ply )
        if( associationType ) then 
            drawColor = (BRICKS_SERVER.DEVCONFIG.GangAssociationTypes[associationType] or {}).Color
        end
    end
    
	if( not drawColor ) then return end
    
    local Distance = LocalPlayer():GetPos():DistToSqr( ply:GetPos() )
    if( Distance > BRICKS_SERVER.CONFIG.GENERAL["3D2D Display Distance"] ) then return end

    cam.Start3D2D( ply:GetPos(), ply:GetAngles(), 0.5 )
        local AlphaMulti = 1-(Distance/BRICKS_SERVER.CONFIG.GENERAL["3D2D Display Distance"])
        surface.SetAlphaMultiplier( AlphaMulti )
            BRICKS_SERVER.Func.DrawArc( 0, 0, circleSize*0.5, 3, 0, 360, drawColor )
        surface.SetAlphaMultiplier( 1 )
    cam.End3D2D()
end )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangmenu_settings.lua:
local PANEL = {}

function PANEL:Init()
    self.animMultiplier = 0
    self.leftBorderW = BRICKS_SERVER.Func.ScreenScale( 6 )

    local margin50 = BRICKS_SERVER.Func.ScreenScale( 50 )

    self.scrollPanel = vgui.Create( "bricks_server_scrollpanel", self )
    self.scrollPanel:Dock( FILL )
    self.scrollPanel:DockMargin( margin50, margin50, margin50, margin50 )
end

function PANEL:FillPanel( gangTable )
    self.gangTable = table.Copy( gangTable )
    self:Refresh()

    hook.Add( "BRS.Hooks.RefreshGang", self, function( self, valuesChanged )
        if( not valuesChanged or not (valuesChanged["Name"] or valuesChanged["Icon"]) ) then return end

        self.gangTable = table.Copy( (BRICKS_SERVER_GANGS or {})[LocalPlayer():GetGangID()] or {} )

        self:Refresh()
    end )
end

function PANEL:CreateSettingPanel( parent, h, text, subText )
    local rounding = BRICKS_SERVER.Func.ScreenScale( 10 )
    local margin10 = BRICKS_SERVER.Func.ScreenScale( 10 )
    local margin25 = BRICKS_SERVER.Func.ScreenScale( 25 )

    local errorIconMat = Material( "bricks_server/step_error.png", "noclamp smooth" )
    local completedIconMat = Material( "bricks_server/step_completed.png", "noclamp smooth" )
    local iconSize = BRICKS_SERVER.Func.ScreenScale( 24 )

    surface.SetFont( "BRICKS_SERVER_Font22B" )
    local textW, textH = surface.GetTextSize( string.upper( text ) )

    surface.SetFont( "BRICKS_SERVER_Font20B" )
    local subTextW, subTextH = surface.GetTextSize( subText )

    local settingPanel = vgui.Create( "DPanel", parent )
    settingPanel:Dock( TOP )
    settingPanel:SetTall( h )
    settingPanel:DockMargin( 0, 0, 0, margin25 )
    settingPanel.leftW = BRICKS_SERVER.Func.ScreenScale( 50 )
    settingPanel.Paint = function( self2, w, h )
        draw.RoundedBox( rounding, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
        draw.RoundedBox( rounding, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2, 200 ) )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3, 100 ) )
        surface.DrawRect( self.leftBorderW, 0, self2.leftW, h )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 10 ) )
        surface.SetMaterial( self2.completed and completedIconMat or errorIconMat )
        surface.DrawTexturedRect( self.leftBorderW+self2.leftW*0.5-iconSize*0.5, h*0.5-iconSize*0.5, iconSize, iconSize )

        BRICKS_SERVER.Func.DrawPartialRoundedBox( rounding, 0, 0, 6, h, self2.completed and BRICKS_SERVER.DEVCONFIG.BaseThemes.Green or BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, 2*self.leftBorderW, h )
    
        local leftMargin = self.leftBorderW+self2.leftW+margin25
        draw.SimpleText( string.upper( text ), "BRICKS_SERVER_Font22B", leftMargin, margin25, BRICKS_SERVER.Func.GetTheme( 5 ) )
        draw.SimpleText( subText, "BRICKS_SERVER_Font20B", leftMargin, margin25+textH, BRICKS_SERVER.Func.GetTheme( 6, 50 ) )
    end
    settingPanel.requirementEntries = {}
    settingPanel.AddRequirement = function( self2, requirementText, hasPassed, infoFunc )
        surface.SetFont( "BRS.Font.Bold20" )
        requirementText = string.upper( requirementText )

        local tickIconMat = Material( "bricks_server/accept_16.png" )
        local crossIconMat = Material( "bricks_server/decline_16.png" )
        local iconSize = BRICKS_SERVER.Func.ScreenScale( 16 )
    
        local requirementEntry = vgui.Create( "DPanel", self2.requirementsPanel )
        requirementEntry:Dock( LEFT )
        requirementEntry:SetWide( self2.requirementsPanel:GetTall()+surface.GetTextSize( requirementText )+margin10+(infoFunc and self2.requirementsPanel:GetTall() or 0) )
        requirementEntry:DockMargin( 0, 0, margin10, 0 )
        requirementEntry.hasPassed = hasPassed()
        requirementEntry.Paint = function( self2, w, h )
            local highlightColor = self2.hasPassed and BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen or BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed

            draw.RoundedBox( 5, 0, 0, w, h, Color( highlightColor.r, highlightColor.g, highlightColor.b, 25 ) )

            surface.SetDrawColor( highlightColor )
            surface.SetMaterial( self2.hasPassed and tickIconMat or crossIconMat )
            surface.DrawTexturedRect( h*0.5-iconSize*0.5, h*0.5-iconSize*0.5, iconSize, iconSize )

            draw.SimpleText( requirementText, "BRS.Font.Bold20", w-margin10-(infoFunc and h or 0), h*0.5-1, highlightColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
        end

        if( infoFunc ) then
            local infoButton = vgui.Create( "DButton", requirementEntry )
            infoButton:Dock( RIGHT )
            infoButton:SetWide( self2.requirementsPanel:GetTall() )
            infoButton:SetText( "" )
            infoButton.Paint = function( self2, w, h )
                draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 6, 5+(self2:IsHovered() and 5 or 0) ), false, true, false, true )
        
                draw.SimpleText( "!", "BRICKS_SERVER_Font30B", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6, 50 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
            infoButton.DoClick = infoFunc
        end

        local reqWide = self2.requirementsPanel:GetWide()
        self2.requirementsPanel:SetWide( reqWide+(reqWide != 0 and margin10 or 0)+requirementEntry:GetWide() )

        table.insert( self2.requirementEntries, { requirementEntry, hasPassed } )
    end
    settingPanel.UpdateCompletion = function( self2 )
        local requirementsCompleted = true
        for k, v in ipairs( self2.requirementEntries ) do
            local passed = v[2]()
            v[1].hasPassed = passed

            if( passed ) then continue end
            requirementsCompleted = false
        end

        self2.completed = self2.isCompletedFunc( requirementsCompleted )
    end

    settingPanel.requirementsPanel = vgui.Create( "Panel", settingPanel )
    settingPanel.requirementsPanel:SetTall( BRICKS_SERVER.Func.ScreenScale( 30 ) )
    settingPanel.requirementsPanel:SetPos( self.leftBorderW+settingPanel.leftW+margin25+subTextW+margin25, margin25+(textH+subTextH)*0.5-settingPanel.requirementsPanel:GetTall()*0.5 )

    table.insert( self.settingPanels, settingPanel )
    return settingPanel
end

function PANEL:Refresh()
    self.settingsTable = {
        name = self.gangTable.Name,
        icon = self.gangTable.Icon,
        colour = self.gangTable.Colour
    }

    self.settingPanels = {}
    self.settingsChanged = false

    self.scrollPanel:Clear()

    local rounding = BRICKS_SERVER.Func.ScreenScale( 10 )
    local margin5 = BRICKS_SERVER.Func.ScreenScale( 5 )
    local margin10 = BRICKS_SERVER.Func.ScreenScale( 10 )
    local margin25 = BRICKS_SERVER.Func.ScreenScale( 25 )
    local margin50 = BRICKS_SERVER.Func.ScreenScale( 50 )

    -- First Step
    local firstPanel = self:CreateSettingPanel( self.scrollPanel, BRICKS_SERVER.Func.ScreenScale( 150 ), "Gang Name", "A cool name for your new gang." )

    local gangNameEntry = vgui.Create( "bricks_server_textentry", firstPanel )
    gangNameEntry:SetSize( (self.panelWide-2*margin50)*0.3, BRICKS_SERVER.Func.ScreenScale( 40 ) )
    gangNameEntry:SetPos( self.leftBorderW+firstPanel.leftW+margin25, firstPanel:GetTall()-margin25-gangNameEntry:GetTall() )
    gangNameEntry:SetFont( "BRICKS_SERVER_Font22" )
    gangNameEntry.backColor = BRICKS_SERVER.Func.GetTheme( 0, 100 )
    gangNameEntry:SetValue( self.settingsTable.name )
    gangNameEntry.OnChange = function()
        self.settingsTable.name = string.Trim( gangNameEntry:GetValue() )
        firstPanel:UpdateCompletion()
        self:SettingChanged()
    end

    firstPanel:AddRequirement( "+" .. BRICKS_SERVER.DEVCONFIG.GangNameCharMin .. " Length", function() 
        return string.len( self.settingsTable.name ) >= BRICKS_SERVER.DEVCONFIG.GangNameCharMin
    end )

    firstPanel:AddRequirement( "< " .. BRICKS_SERVER.DEVCONFIG.GangNameCharMax .. " Length", function() 
        return string.len( self.settingsTable.name ) <= BRICKS_SERVER.DEVCONFIG.GangNameCharMax
    end )

    firstPanel:AddRequirement( "Only Letters/Numbers", function() 
        return not string.match( string.Replace( self.settingsTable.name, " ", "" ), "[%W]" )
    end )

    firstPanel.isCompletedFunc = function( requirementsPassed )
        return requirementsPassed
    end

    firstPanel:UpdateCompletion()

    -- Second Step
    local secondPanel = self:CreateSettingPanel( self.scrollPanel, BRICKS_SERVER.Func.ScreenScale( 185 ), "Gang Icon", "An icon used when displaying your gang." )

    secondPanel.bottom = vgui.Create( "Panel", secondPanel )
    secondPanel.bottom:Dock( BOTTOM )
    secondPanel.bottom:SetTall( BRICKS_SERVER.Func.ScreenScale( 75 ) )
    secondPanel.bottom:DockMargin( self.leftBorderW+secondPanel.leftW+margin25, 0, margin25, margin25 )

    local unselectedIconMat = Material( "bricks_server/icon_unselected.png" )
    local loadingNewIcon, newGangIconMat = false

    local currentIconDisplay = vgui.Create( "Panel", secondPanel.bottom )
    currentIconDisplay:Dock( LEFT )
    currentIconDisplay:SetWide( BRICKS_SERVER.Func.ScreenScale( 75 ) )
    currentIconDisplay.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0, 100 ) )

        if( loadingNewIcon ) then
            if( CurTime() >= (self2.loadingStart or 0)+1.5 ) then
                self2.loadingStart = CurTime()
            end

            local percent = math.Clamp( (CurTime()-self2.loadingStart)/1.5, 0, 1 )

            local entrySize, entryMargin = BRICKS_SERVER.Func.ScreenScale( 10 ), margin5
            local yOffset = margin5
            local totalEntryW = 3*(entrySize+entryMargin)-entryMargin
            for i = 1, 3 do
                local min = (i-1)*(1/3)
                local isActive = percent >= min and percent < i*(1/3)
                local entryPercent = math.Clamp( (percent-min)*3, 0, 1 )
                local yAdjustment = isActive and (entryPercent < 0.5 and (entryPercent/0.5)*yOffset or yOffset-((entryPercent-0.5)/0.5*yOffset)) or 0

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.DrawRect( w*0.5-totalEntryW*0.5+(i-1)*(entryMargin+entrySize), h*0.5-entrySize*0.5-yAdjustment, entrySize, entrySize )
            end

            return
        end
        
        local unselectedIconSize = newGangIconMat and h*0.75 or BRICKS_SERVER.Func.ScreenScale( 64 )

        surface.SetDrawColor( newGangIconMat and BRICKS_SERVER.DEVCONFIG.BaseThemes.White or BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.SetMaterial( newGangIconMat or unselectedIconMat )
        surface.DrawTexturedRect( w*0.5-unselectedIconSize*0.5, h*0.5-unselectedIconSize*0.5, unselectedIconSize, unselectedIconSize )
    end

    local presetsSpacer = vgui.Create( "Panel", secondPanel.bottom )
    presetsSpacer:Dock( LEFT )
    presetsSpacer:SetWide( 4 )
    presetsSpacer:DockMargin( margin50, margin10, margin50, margin10 )
    presetsSpacer.Paint = function( self2, w, h )
        draw.RoundedBox( w*0.5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0, 100 ) )
    end

    surface.SetFont( "BRICKS_SERVER_Font20B" )

    local presetsHeader = vgui.Create( "Panel", secondPanel.bottom )
    presetsHeader:Dock( LEFT )
    presetsHeader:SetWide( surface.GetTextSize( "Default icons" ) )
    presetsHeader.Paint = function( self2, w, h )
        draw.SimpleText( "PRESETS", "BRICKS_SERVER_Font22B", 0, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 4 ), 0, TEXT_ALIGN_BOTTOM )
        draw.SimpleText( "Default icons", "BRICKS_SERVER_Font20B", 0, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6, 50 ), 0, 0 )
    end

    local presetsPanel = vgui.Create( "Panel", secondPanel.bottom )
    presetsPanel:Dock( LEFT )
    presetsPanel:SetTall( secondPanel.bottom:GetTall()-2*margin5 )
    presetsPanel:DockMargin( margin25, margin5, 0, margin5 )

    local customUrlEntry

    for k, v in ipairs( BRICKS_SERVER.DEVCONFIG.PresetGangIcons ) do
        local presetIconMat = Material( v, "noclamp smooth" )

        if( self.settingsTable.icon == v ) then
            newGangIconMat = presetIconMat
        end
    
        local currentIconDisplay = vgui.Create( "DButton", presetsPanel )
        currentIconDisplay:Dock( LEFT )
        currentIconDisplay:SetWide( presetsPanel:GetTall() )
        currentIconDisplay:DockMargin( 0, 0, margin5, 0 )
        currentIconDisplay:SetText( "" )
        currentIconDisplay.Paint = function( self2, w, h )
            local isSelected = v == self.settingsTable.icon
            self2.hoverAlpha = math.Clamp( (self2.hoverAlpha or 0)+(self2:IsHovered() and 5 or -5), 0, 100 )

            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0, 100+(isSelected and 50 or self2.hoverAlpha) ) )

            local borderH = 3
            BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, 0, h-borderH, w, borderH, BRICKS_SERVER.Func.GetTheme( 5, isSelected and 255 or self2.hoverAlpha ), w, 10, 0, h-10 )

            local iconSize = h*0.75
    
            surface.SetDrawColor( 255, 255, 255 )
            surface.SetMaterial( presetIconMat )
            surface.DrawTexturedRect( w*0.5-iconSize*0.5, h*0.5-iconSize*0.5, iconSize, iconSize )
        end
        currentIconDisplay.DoClick = function()
            if( self.settingsTable.icon == v ) then
                self.settingsTable.icon = ""
                newGangIconMat = nil
            else
                self.settingsTable.icon = v
                newGangIconMat = presetIconMat
                loadingNewIcon = false
                customUrlEntry:SetValue( "" )
            end

            secondPanel:UpdateCompletion()
            self:SettingChanged()
        end
    end

    presetsPanel:SetWide( #BRICKS_SERVER.DEVCONFIG.PresetGangIcons*(presetsPanel:GetTall()+margin5)-margin5 )

    local customSpacer = vgui.Create( "Panel", secondPanel.bottom )
    customSpacer:Dock( LEFT )
    customSpacer:SetWide( 4 )
    customSpacer:DockMargin( margin50, margin10, margin50, margin10 )
    customSpacer.Paint = function( self2, w, h )
        draw.RoundedBox( w*0.5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0, 100 ) )
    end
    
    local customHeader = vgui.Create( "Panel", secondPanel.bottom )
    customHeader:Dock( LEFT )
    customHeader:SetWide( surface.GetTextSize( "A custom icons" ) )
    customHeader.Paint = function( self2, w, h )
        draw.SimpleText( "CUSTOM", "BRICKS_SERVER_Font22B", 0, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 4 ), 0, TEXT_ALIGN_BOTTOM )
        draw.SimpleText( "A custom icon", "BRICKS_SERVER_Font20B", 0, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6, 50 ), 0, 0 )
    end

    local customEntryBar = vgui.Create( "Panel", secondPanel.bottom )
    customEntryBar:Dock( LEFT )
    customEntryBar:SetWide( ScrW()*0.1 )
    local verticalMargin = (secondPanel.bottom:GetTall()-BRICKS_SERVER.Func.ScreenScale( 40 ))*0.5
    customEntryBar:DockMargin( margin25, verticalMargin, 0, verticalMargin )
    customEntryBar.Paint = function( self2, w, h )
        if( not IsValid( customUrlEntry ) or customUrlEntry:GetValue() == "" or customUrlEntry:GetValue() == self.settingsTable.icon ) then return end

        local oldClipping = DisableClipping( true )
        draw.SimpleText( "PRESS ENTER TO SAVE", "BRICKS_SERVER_Font20B", w*0.5, h, BRICKS_SERVER.Func.GetTheme( 6, 50 ), TEXT_ALIGN_CENTER, 0 )
        DisableClipping( oldClipping )
    end

    customUrlEntry = vgui.Create( "bricks_server_textentry", customEntryBar )
    customUrlEntry:Dock( BOTTOM )
    customUrlEntry:SetTall( BRICKS_SERVER.Func.ScreenScale( 40 ) )
    customUrlEntry:DockMargin( 0, 0, 0, 0 )
    customUrlEntry:SetFont( "BRICKS_SERVER_Font22" )
    customUrlEntry.backColor = BRICKS_SERVER.Func.GetTheme( 0, 100 )
    customUrlEntry.UpdateIcon = function( self2 )
        loadingNewIcon = true
        newGangIconMat = nil

        BRICKS_SERVER.Func.GetImage( self.settingsTable.icon, function( mat )
            if( self.settingsTable.icon != self.settingsTable.icon ) then return end
            newGangIconMat = mat 
            loadingNewIcon = false
        end )
    end
    customUrlEntry.OnEnter = function( self2 )
        self.settingsTable.icon = self2:GetValue()

        secondPanel:UpdateCompletion()
        self:SettingChanged()

        self2:UpdateIcon()
    end

    if( not newGangIconMat ) then
        customUrlEntry:SetValue( self.settingsTable.icon )
        customUrlEntry:UpdateIcon()
    end

    local validImageEndings = { ".png", ".jpg", ".jpeg" }
    secondPanel:AddRequirement( ".png, .jpg or .jpeg", function() 
        if( table.HasValue( BRICKS_SERVER.DEVCONFIG.PresetGangIcons, self.settingsTable.icon ) ) then return true end

        for _, v in ipairs( validImageEndings ) do
            if( string.EndsWith( self.settingsTable.icon, v ) ) then return true end
        end

        return false
    end )

    -- BRICKS_SERVER.DEVCONFIG.GangURLWhitelist
    -- Show whitelsited urls when hovering?
    secondPanel:AddRequirement( "Whitelisted URL", function() 
        if( table.HasValue( BRICKS_SERVER.DEVCONFIG.PresetGangIcons, self.settingsTable.icon ) ) then return true end

        for _, v in ipairs( BRICKS_SERVER.DEVCONFIG.GangURLWhitelist ) do
            if( string.StartWith( self.settingsTable.icon, v ) ) then return true end
        end

        return false
    end, function( self2 )
        if( IsValid( self2.hoverPopup ) ) then
            self2.hoverPopup:Remove()
        end

        local x, y = self2:LocalToScreen( 0, 0 )

        self2.hoverPopup = vgui.Create( "DFrame" )
        self2.hoverPopup:SetSize( 300, 500 )
        self2.hoverPopup:Center()
        self2.hoverPopup:MakePopup()
        self2.hoverPopup:SetTitle( "" )
        self2.hoverPopup:DockPadding( 25, 50, 0, 0 )

        for k, v in ipairs( BRICKS_SERVER.DEVCONFIG.GangURLWhitelist ) do
            local urlEntry = vgui.Create( "DLabel", self2.hoverPopup )
            urlEntry:Dock( TOP )
            urlEntry:SetText( v )
            urlEntry:SetFont( "Trebuchet24" )
            urlEntry:SizeToContentsY()
        end
    end )

    secondPanel.isCompletedFunc = function( requirementsPassed )
        return requirementsPassed
    end

    secondPanel:UpdateCompletion()

    -- Third Step
    -- local thirdPanel = self:CreateSettingPanel( self.scrollPanel, BRICKS_SERVER.Func.ScreenScale( 160 ), "Gang Colour", "The colour of your gang, displayed in various places." )

    -- thirdPanel.bottom = vgui.Create( "Panel", thirdPanel )
    -- thirdPanel.bottom:Dock( BOTTOM )
    -- thirdPanel.bottom:SetTall( BRICKS_SERVER.Func.ScreenScale( 50 ) )
    -- thirdPanel.bottom:DockMargin( self.leftBorderW+thirdPanel.leftW+margin25, 0, margin25, margin25 )

    -- local colourOptions = { 
    --     Color( 244, 67, 54 ),
    --     Color( 233, 30, 99 ),
    --     Color( 156, 39, 176 ),
    --     Color( 103, 58, 183 ),
    --     Color( 63, 81, 181 ),
    --     Color( 33, 150, 243 ),
    --     Color( 3, 169, 244 ),
    --     Color( 0, 188, 212 ),
    --     Color( 0, 150, 136 ),
    --     Color( 76, 175, 80 ),
    --     Color( 139, 195, 74 ),
    --     Color( 205, 220, 57 ),
    --     Color( 255, 235, 59 ),
    --     Color( 255, 193, 7 ),
    --     Color( 255, 152, 0 ),
    --     Color( 255, 87, 34 )
    -- }

    -- local colourEntrySize = math.floor( (thirdPanel.bottom:GetTall()-margin5)*0.5 )

    -- local colourGrid = vgui.Create( "DIconLayout", thirdPanel.bottom )
    -- colourGrid:Dock( LEFT )
    -- colourGrid:SetWide( (math.ceil( #colourOptions*0.5 )*(colourEntrySize+margin5))-margin5 )
    -- colourGrid:SetSpaceX( margin5 )
    -- colourGrid:SetSpaceY( margin5 )
    
    -- local whiteColour = BRICKS_SERVER.DEVCONFIG.BaseThemes.White
    -- local circleBorder = BRICKS_SERVER.Func.ScreenScale( 2 )
    -- for k, v in ipairs( colourOptions ) do
    --     local colourEntry = vgui.Create( "DButton", colourGrid )
    --     colourEntry:SetSize( colourEntrySize, colourEntrySize )
    --     colourEntry:SetText( "" )
    --     colourEntry.Paint = function( self2, w, h )
    --         self2.hoverAlpha = math.Clamp( (self2.hoverAlpha or 0)+(self2:IsHovered() and 5 or -5), 0, 100 )

    --         local isSelected = v == self.settingsTable.colour
    --         if( isSelected or self2.hoverAlpha != 0 ) then
    --             local oldClipping = DisableClipping( true )
    --             surface.SetAlphaMultiplier( isSelected and 1 or self2.hoverAlpha/255 )
    --             BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, w*0.5+circleBorder, whiteColour )
    --             surface.SetAlphaMultiplier( 1 )
    --             DisableClipping( oldClipping )
    --         end

    --         BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, w*0.5, v )
    --     end
    --     colourEntry.DoClick = function()
    --         if( self.settingsTable.colour == v ) then
    --             self.settingsTable.colour = nil
    --         else
    --             self.settingsTable.colour = v
    --         end

    --         thirdPanel:UpdateCompletion()
    --         self:SettingChanged()
    --     end
    -- end

    -- thirdPanel.isCompletedFunc = function( requirementsPassed )
    --     return self.settingsTable.colour != nil
    -- end

    -- thirdPanel:UpdateCompletion()
end

function PANEL:SettingChanged()
    if( self.settingsChanged ) then
        local shouldRemove = true
        if( self.settingsTable.name != self.gangTable.Name ) then
            shouldRemove = false
        elseif( self.settingsTable.icon != self.gangTable.Icon ) then
            shouldRemove = false
        end

        if( shouldRemove and IsValid( self.popup ) ) then
            self.settingsChanged = false
            self.popup:Close()
        end

        return 
    end

    self.settingsChanged = true

    if( IsValid( self.popup ) ) then return end

    local margin25 = BRICKS_SERVER.Func.ScreenScale( 25 )

    local warningIconMat = Material( "bricks_server/gang_warning.png", "noclamp smooth" )
    local warningIconSize = BRICKS_SERVER.Func.ScreenScale( 64 )

    local popup = vgui.Create( "DPanel", self )
    popup:SetSize( self.panelWide-(2*margin25), BRICKS_SERVER.Func.ScreenScale( 100 ) )
    popup:SetPos( margin25, ScrH()*0.65-40 )
    popup:MoveTo( margin25, ScrH()*0.65-40-margin25-popup:GetTall(), 0.2 )
    local yBound = (ScrH()*0.5)-(ScrH()*0.65*0.5)
    popup.Paint = function( self2, w, h )
        local x, y = self2:LocalToScreen( 0, 0 )

        BRICKS_SERVER.BSHADOWS.BeginShadow( 0, yBound, ScrW(), yBound+(ScrH()*0.65) )
        draw.RoundedBox( 8, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
        BRICKS_SERVER.BSHADOWS.EndShadow( 1, 1, 1, 255, 0, 0, false )

        draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 50 ) )
    
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 15 ) )
        surface.SetMaterial( warningIconMat )
        surface.DrawTexturedRect( self.leftBorderW+h*0.5-warningIconSize*0.5, h*0.5-warningIconSize*0.5, warningIconSize, warningIconSize )

        draw.SimpleText( "WARNING", "BRICKS_SERVER_Font30B", h, h*0.5+BRICKS_SERVER.Func.ScreenScale( 2 ), BRICKS_SERVER.Func.GetTheme( 5 ), 0, TEXT_ALIGN_BOTTOM )
        draw.SimpleText( BRICKS_SERVER.Func.L( "gangUnsavedChanges" ), "BRICKS_SERVER_Font21", h, h*0.5-BRICKS_SERVER.Func.ScreenScale( 2 ), BRICKS_SERVER.Func.GetTheme( 6, 100 ), 0, 0 )
    end
    popup.Close = function( self2 )
        self2:MoveTo( margin25, ScrH()*0.65-40, 0.2, 0, -1, function()
            self2:Remove()
        end )
    end

    self.popup = popup

    local gradient = vgui.Create( "bricks_server_gradientanim", popup )
    gradient:SetPos( 0, 0 )
    gradient:SetSize( self.leftBorderW, popup:GetTall() )
    gradient:SetDirection( 1 )
    gradient:SetCornerRadius( rounding )
    gradient:SetRoundedBoxDimensions( false, false, 20, false )
    gradient:TasteTheRainbow()
    gradient:StartAnim()

    surface.SetFont( "BRICKS_SERVER_Font22B" )
    local text2X, text2Y = surface.GetTextSize( BRICKS_SERVER.Func.L( "gangReset" ) )

    local resetChanges = vgui.Create( "DButton", popup )
    resetChanges:Dock( RIGHT )
    resetChanges:DockMargin( 0, margin25, margin25, margin25 )
    resetChanges:SetWide( text2X+BRICKS_SERVER.Func.ScreenScale( 25 ) )
    resetChanges:SetText( "" )
    local alpha = 0
    local whiteColor = BRICKS_SERVER.Func.GetTheme( 6 )
    resetChanges.Paint = function( self2, w, h )
        self2.hoverAlpha = math.Clamp( (self2.hoverAlpha or 0)+(self2:IsHovered() and 5 or -5), 0, 100 )

        draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 25+self2.hoverAlpha ) )
    
        draw.SimpleText( BRICKS_SERVER.Func.L( "gangReset" ), "BRICKS_SERVER_Font22B", w*0.5, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6, 25 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end
    resetChanges.DoClick = function()
        popup:Close()
        self:Refresh()
    end

    surface.SetFont( "BRICKS_SERVER_Font22B" )
    local textX = surface.GetTextSize( BRICKS_SERVER.Func.L( "gangSaveChanges" ) )

    local saveIconMat = Material( "bricks_server/gang_save.png", "noclamp smooth" )
    local saveIconSize = BRICKS_SERVER.Func.ScreenScale( 24 )
    
    local contentMargin = BRICKS_SERVER.Func.ScreenScale( 10 )

    local saveChanges = vgui.Create( "DButton", popup )
    saveChanges:Dock( RIGHT )
    saveChanges:DockMargin( 0, margin25, margin25, margin25 )
    saveChanges:SetWide( textX+saveIconSize+2*contentMargin+BRICKS_SERVER.Func.ScreenScale( 10 ) )
    saveChanges:SetText( "" )
    local alpha = 0
    saveChanges.Paint = function( self2, w, h )
        self2.hoverAlpha = math.Clamp( (self2.hoverAlpha or 0)+(self2:IsHovered() and 5 or -5), 0, 100 )

        self2.isPossible = true
        for k, v in ipairs( self.settingPanels ) do
            if( not v.completed ) then 
                self2.isPossible = false
                break
            end
        end

        draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 50+self2.hoverAlpha ) )

        local edgeH = 4
        BRICKS_SERVER.Func.DrawPartialRoundedBox( 8, 0, h-edgeH, w, edgeH, self2.isPossible and BRICKS_SERVER.DEVCONFIG.BaseThemes.Green or BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, w, 2*edgeH, 0, h-2*edgeH )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 50 ) )
        surface.SetMaterial( saveIconMat )
        surface.DrawTexturedRect( contentMargin, h*0.5-saveIconSize*0.5, saveIconSize, saveIconSize )
    
        draw.SimpleText( BRICKS_SERVER.Func.L( "gangSaveChanges" ), "BRICKS_SERVER_Font22B", w-contentMargin, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6, 50 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
    end
    saveChanges.DoClick = function( self2 )
        if( not self2.isPossible ) then return end

        popup:Close()

        net.Start( "BRS.Net.SaveGangSettings" )
            net.WriteString( self.settingsTable.name )
            net.WriteString( self.settingsTable.icon )
            -- net.WriteColor( self.settingsTable.colour )
        net.SendToServer()
    end
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_settings", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/storage/shared/sh_gang_storage.lua:
function BRICKS_SERVER.Func.GangIsStorageFull( gangID, amount, canStack )
    local gangStorage = ((BRICKS_SERVER_GANGS or {})[gangID] or {}).Storage or {}

    local storageCount = table.Count( gangStorage )
	if( not canStack ) then
		if( storageCount+amount > BRICKS_SERVER.Func.GangGetUpgradeInfo( gangID, "StorageSlots" )[1] ) then 
			return true
		end
	else
		local newStacks = amount/(BRICKS_SERVER.CONFIG.GANGS["Max Storage Item Stack"] or 10)
		if( storageCount+newStacks > BRICKS_SERVER.Func.GangGetUpgradeInfo( gangID, "StorageSlots" )[1] ) then 
			return true
		end
	end

	return false
end

function BRICKS_SERVER.Func.GangGetStorageCount( gangID )
    if( not BRICKS_SERVER_GANGS or not gangID ) then return 0 end

    local gangTable = BRICKS_SERVER_GANGS[gangID]

    if( not gangTable or not gangTable.Storage ) then return 0 end

    local itemCount = 0
    for k, v in pairs( gangTable.Storage ) do
        itemCount = itemCount+(v[1] or 0)
    end

    return itemCount
end
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/territories/vgui/bricks_server_config_gang_territories.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( configPanel )
    function self.RefreshPanel()
        self:Clear()

        for k, v in pairs( BS_ConfigCopyTable.GANGS.Territories or {} ) do
            local itemActions = {
                [1] = { BRICKS_SERVER.Func.L( "edit" ), function()
                    BRICKS_SERVER.Func.CreateTerritoryEditor( v, function( territoryTable ) 
                        BS_ConfigCopyTable.GANGS.Territories[k] = territoryTable
                        BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                        self.RefreshPanel()
                    end, function() end )
                end },
                [2] = { BRICKS_SERVER.Func.L( "remove" ), function()
                    BS_ConfigCopyTable.GANGS.Territories[k] = nil
                    BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                    self.RefreshPanel()
                end, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed }
            }

            local itemBack = vgui.Create( "DPanel", self )
            itemBack:Dock( TOP )
            itemBack:DockMargin( 0, 0, 0, 5 )
            itemBack:SetTall( 100 )
            itemBack:DockPadding( 0, 0, 25, 0 )
            itemBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                draw.RoundedBoxEx( 5, 0, 0, 25, h, (v.Color or BRICKS_SERVER.Func.GetTheme( 5 )), true, false, true, false )

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.DrawRect( 5, 0, 20, h )

                draw.SimpleText( v.Name, "BRICKS_SERVER_Font33", 20, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
            end

            for key2, val2 in ipairs( itemActions ) do
                local itemAction = vgui.Create( "DButton", itemBack )
                itemAction:Dock( RIGHT )
                itemAction:SetText( "" )
                itemAction:DockMargin( 5, 25, 0, 25 )
                surface.SetFont( "BRICKS_SERVER_Font25" )
                local textX, textY = surface.GetTextSize( val2[1] )
                textX = textX+20
                itemAction:SetWide( math.max( (ScrW()/2560)*150, textX ) )
                local changeAlpha = 0
                itemAction.Paint = function( self2, w, h )
                    if( self2:IsHovered() and not self2:IsDown() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
                    else
                        changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
                    end
                    
                    draw.RoundedBox( 5, 0, 0, w, h, val2[3] or BRICKS_SERVER.Func.GetTheme( 2 ) )
            
                    surface.SetAlphaMultiplier( changeAlpha/255 )
                        draw.RoundedBox( 5, 0, 0, w, h, val2[4] or BRICKS_SERVER.Func.GetTheme( 3 ) )
                    surface.SetAlphaMultiplier( 1 )

                    BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, val2[4] or BRICKS_SERVER.Func.GetTheme( 3 ) )
            
                    draw.SimpleText( val2[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end
                itemAction.DoClick = function()
                    val2[2]()
                end
            end

            surface.SetFont( "BRICKS_SERVER_Font33" )
            local nameX, nameY = surface.GetTextSize( v.Name )

            local noticeBack = vgui.Create( "DPanel", itemBack )
            noticeBack:SetSize( 0, 35 )
            noticeBack:SetPos( 20, 5+nameY+10 )
            noticeBack.Paint = function( self2, w, h ) end

            local itemNotices = {}

            for key, val in pairs( v.Rewards or {} ) do
                local devConfig = BRICKS_SERVER.DEVCONFIG.GangRewards[key]

                if( not devConfig ) then continue end

                table.insert( itemNotices, { devConfig.FormatDescription( val ), devConfig.Color } )
            end

            for k, v in pairs( itemNotices ) do
                surface.SetFont( "BRICKS_SERVER_Font23" )
                local textX, textY = surface.GetTextSize( v[1] )
                local boxW, boxH = textX+10, textY

                local itemInfoNotice = vgui.Create( "DPanel", noticeBack )
                itemInfoNotice:Dock( LEFT )
                itemInfoNotice:DockMargin( 0, 0, 5, 0 )
                itemInfoNotice:SetWide( boxW )
                itemInfoNotice.Paint = function( self2, w, h ) 
                    draw.RoundedBox( 5, 0, 0, w, h, (v[2] or BRICKS_SERVER.Func.GetTheme( 5 )) )
                    draw.SimpleText( v[1], "BRICKS_SERVER_Font23", w*0.5, (h*0.5)-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end

                if( noticeBack:GetWide() <= 5 ) then
                    noticeBack:SetSize( noticeBack:GetWide()+boxW, boxH )
                else
                    noticeBack:SetSize( noticeBack:GetWide()+5+boxW, boxH )
                end
            end
        end

        local addNewButton = vgui.Create( "DButton", self )
        addNewButton:Dock( TOP )
        addNewButton:SetText( "" )
        addNewButton:DockMargin( 0, 0, 0, 5 )
        addNewButton:SetTall( 40 )
        local changeAlpha = 0
        addNewButton.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( BRICKS_SERVER.Func.L( "gangAddTerritory" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        addNewButton.DoClick = function()
            if( not BS_ConfigCopyTable.GANGS.Territories ) then
                BS_ConfigCopyTable.GANGS.Territories = {}
            end

            table.insert( BS_ConfigCopyTable.GANGS.Territories, {
                Name = BRICKS_SERVER.Func.L( "gangNewTerritory" ), 
                Color = BRICKS_SERVER.Func.GetTheme( 5 ),
                RewardTime = 60,
                Rewards = {}
            } )

            BRICKS_SERVER.Func.ConfigChange( "GANGS" )
            self.RefreshPanel()
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_gang_territories", PANEL, "bricks_server_scrollpanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/territories/vgui/bricks_server_gangmenu_territories.lua:
local PANEL = {}

function PANEL:Init()
    self:DockMargin( 10, 10, 10, 10 )
end

function PANEL:FillPanel( gangTable )
    function self.RefreshPanel()
        self:Clear()

        for k, v in pairs( BRICKS_SERVER.CONFIG.GANGS.Territories or {} ) do
            local territoryTable = (BRS_GANG_TERRITORIES or {})[k] or {}
            local claimed = territoryTable.Claimed

            local itemBack = vgui.Create( "DPanel", self )
            itemBack:Dock( TOP )
            itemBack:DockMargin( 0, 0, 0, 5 )
            itemBack:SetTall( 140 )
            itemBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            end

            local topBar = vgui.Create( "DPanel", itemBack )
            topBar:Dock( TOP )
            topBar:SetTall( 40 )
            surface.SetFont( "BRICKS_SERVER_Font20" )
            local nameX, nameY = surface.GetTextSize( v.Name )
            topBar.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, 0, 0, 3, h, (v.Color or BRICKS_SERVER.Func.GetTheme( 5 )), 10, h )
            
                draw.SimpleText( v.Name, "BRICKS_SERVER_Font20", 15, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )

                local text = (claimed and BRICKS_SERVER.Func.L( "gangClaimed" )) or BRICKS_SERVER.Func.L( "gangUnclaimed" )

                surface.SetFont( "BRICKS_SERVER_Font20" )
                local textX, textY = surface.GetTextSize( text )
                local boxW, boxH = textX+10, textY+3

                draw.RoundedBox( 5, 15+nameX+10, (h*0.5)-(boxH*0.5), boxW, boxH, (claimed and BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen) or BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
                draw.SimpleText( text, "BRICKS_SERVER_Font20", 15+nameX+10+(boxW*0.5), h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

                if( claimed ) then
                    local timeSince = math.max( 0, math.floor( os.time()-(territoryTable.ClaimedAt or 0) ) )

                    draw.SimpleText( BRICKS_SERVER.Func.L( "gangClaimedAgo", BRICKS_SERVER.Func.FormatWordTime( timeSince ) ), "BRICKS_SERVER_Font20", w-10, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
                end
            end

            local rewardsBackTall = itemBack:GetTall()-topBar:GetTall()

            local rewardsBack = vgui.Create( "DPanel", itemBack )
            rewardsBack:Dock( RIGHT )
            rewardsBack:DockMargin( 0, 0, 15, 0 )
            rewardsBack:SetWide( 150 )
            local noticeBack
            rewardsBack.Paint = function( self2, w, h ) 
                if( v.Rewards and table.Count( v.Rewards ) > 0 ) then
                    if( not IsValid( noticeBack ) ) then return end

                    local noticeX, noticeY = noticeBack:GetPos()
                    local noticeW, noticeH = noticeBack:GetSize()

                    draw.SimpleText( BRICKS_SERVER.Func.L( "gangRewards" ), "BRICKS_SERVER_Font23", w*0.5, noticeY-5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

                    draw.SimpleText( BRICKS_SERVER.Func.L( "gangRewardsEvery", BRICKS_SERVER.Func.FormatWordTime( v.RewardTime ) ), "BRICKS_SERVER_Font17", w*0.5, noticeY+noticeH+5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
                else
                    draw.SimpleText( BRICKS_SERVER.Func.L( "gangRewards" ), "BRICKS_SERVER_Font23", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
                    draw.SimpleText( BRICKS_SERVER.Func.L( "none" ), "BRICKS_SERVER_Font17", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
                end
            end

            noticeBack = vgui.Create( "DPanel", rewardsBack )
            noticeBack:SetSize( 0, 35 )
            noticeBack:SetPos( (rewardsBack:GetWide()*0.5)-(noticeBack:GetWide()*0.5), (rewardsBackTall*0.5)-(noticeBack:GetTall()*0.5) )
            noticeBack.Paint = function( self2, w, h ) end

            local itemNotices = {}

            for key, val in pairs( v.Rewards or {} ) do
                local devConfig = BRICKS_SERVER.DEVCONFIG.GangRewards[key]

                if( not devConfig ) then continue end

                table.insert( itemNotices, { devConfig.FormatDescription( val ), devConfig.Color } )
            end

            for k, v in pairs( itemNotices ) do
                surface.SetFont( "BRICKS_SERVER_Font23" )
                local textX, textY = surface.GetTextSize( v[1] )
                local boxW, boxH = textX+10, textY

                local itemInfoNotice = vgui.Create( "DPanel", noticeBack )
                itemInfoNotice:Dock( LEFT )
                itemInfoNotice:DockMargin( 0, 0, 5, 0 )
                itemInfoNotice:SetWide( boxW )
                itemInfoNotice.Paint = function( self2, w, h ) 
                    draw.RoundedBox( 5, 0, 0, w, h, (v[2] or BRICKS_SERVER.Func.GetTheme( 5 )) )
                    draw.SimpleText( v[1], "BRICKS_SERVER_Font23", w*0.5, (h*0.5)-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end

                if( noticeBack:GetWide() <= 5 ) then
                    noticeBack:SetSize( noticeBack:GetWide()+boxW, boxH )
                else
                    noticeBack:SetSize( noticeBack:GetWide()+5+boxW, boxH )
                end

                if( noticeBack:GetWide() > rewardsBack:GetWide() ) then
                    rewardsBack:SetWide( noticeBack:GetWide() )
                end

                noticeBack:SetPos( (rewardsBack:GetWide()*0.5)-(noticeBack:GetWide()*0.5), (rewardsBackTall*0.5)-(noticeBack:GetTall()*0.5) )
            end

            local claimedGangTable = {}
            if( claimed ) then
                if( BRICKS_SERVER_GANGS[territoryTable.GangID or 0] ) then
                    claimedGangTable = BRICKS_SERVER_GANGS[territoryTable.GangID or 0]
                else
                    BRICKS_SERVER.Func.RequestTerritoryGangs()
                end
            end

            local avatarBack = vgui.Create( "DPanel", itemBack )
            avatarBack:Dock( FILL )
            avatarBack:DockMargin( 15, 15, 15, 15 )
            local avatarBackSize = 70
            local avatarSize = (claimedGangTable.Icon and avatarBackSize*0.6) or 32
            avatarBack.Paint = function( self2, w, h )
                local textStartPos = avatarBackSize+15

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                draw.NoTexture()
                BRICKS_SERVER.Func.DrawCircle( (h-avatarBackSize)*0.5+(avatarBackSize*0.5), h*0.5, avatarBackSize*0.5, 45 )
        
                draw.SimpleText( (claimedGangTable.Name or BRICKS_SERVER.Func.L( "gangNone" )), "BRICKS_SERVER_Font23", textStartPos, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )
        
                draw.SimpleText( BRICKS_SERVER.Func.L( "gangID", (claimedGangTable.GangID or 0) ), "BRICKS_SERVER_Font17", textStartPos, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
            end

            local gangIcon = vgui.Create( "bricks_server_gangicon", avatarBack )
            gangIcon:SetSize( avatarSize, avatarSize )
            gangIcon:SetPos( (avatarBackSize-avatarSize)*0.5, (avatarBackSize-avatarSize)*0.5 )
            gangIcon:SetIconURL( claimedGangTable.Icon or "bricks_server/question.png" )
        end
    end
    self.RefreshPanel()

    hook.Add( "BRS.Hooks.RefreshGangTerritories", self, function()
        if( IsValid( self ) ) then
            self.RefreshPanel()
        else
            hook.Remove( "BRS.Hooks.RefreshGangTerritories", self )
        end
    end )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_territories", PANEL, "bricks_server_scrollpanel" )
--PATH addons/_bitminers2/lua/autorun/client/cl_bitminers2.lua:
--This file is mainly used for UI based stuff and controlling the miners.
include( "bitminers2_config.lua" )
local CloseMaterial = onyx.wimg.Simple( "https://i.imgur.com/76OnBOE.png", "smooth mips" )
local TerminalBackground = onyx.wimg.Simple( "https://i.imgur.com/hsJMDro.png", "noclamp smooth" )
surface.CreateFont( "BM2ConsoleFont", {
	font = "Ubuntu Mono",
	size = 19,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
} )

--My bad attempt and drop shadows :/
local function DrawDropShadow( x, y, sizex, sizey, strength, distance )
	for i = 1, math.ceil( distance ) * 2, 2 do
		draw.RoundedBox( 50, x - i, y - i, sizex + i * 2, sizey + i * 2, Color( 10, 10, 10, Lerp( ( i * 0.5 ) / distance, strength, 0 ) ) )
	end
end

local terminalIsOpen = false
--So we can access it later
local consoleDisplay = nil
--Active entity that we are in the terminal for
local activeBitminerEntity = nil
--This will contain a list of all the intructions for the terminal for this entity
local entityInstructions = {}
local backgroundColor = Color( 48, 10, 36 )
local lastCommand = ""
--Thanks Lua wiki
function comma_value( amount )
	local formatted = amount
	while true do
		formatted, k = string.gsub( formatted, "^(-?%d+)(%d%d%d)", "%1,%2" )
		if k == 0 then break end
	end
	return formatted
end

function BM2OpenTerminal( entity )
	activeBitminerEntity = entity
	if terminalIsOpen == true then return end
	terminalIsOpen = true
	local frame = vgui.Create( "DFrame", nil )
	frame:SetTitle( "" )
	frame:NoClipping( true )
	frame:ShowCloseButton( false )
	frame:SetSize( 800, 500 )
	frame:Center()
	frame.Close = function( s )
		activeBitminerEntity.terminalHistory = consoleDisplay.history
		terminalIsOpen = false
		s:Remove()
	end

	--Draw terminal frame
	local col1 = Color( 255, 255, 255, 30 )
	frame.Paint = function( _, w, h )
		--Draw shadow
		DrawDropShadow( 0, 0, w, h, 20, 40 )
		draw.RoundedBoxEx( 8, 0, 0, w, h, Color( 70, 68, 69, 255 ), true, true, false, false )
		--Draw background
		draw.RoundedBox( 0, 3, 30, w - 6, h - 33, backgroundColor )
		TerminalBackground( 3, 3, w - 6, h - 33, col1 )
	end

	local closeButton = vgui.Create( "DButton", frame )
	closeButton:SetPos( 800 - 20 - 5, 5 )
	closeButton:SetSize( 20, 20 )
	closeButton:SetText( "" )
	closeButton.Paint = function( _, w, h ) CloseMaterial( 0, 0, w, h ) end
	closeButton.DoClick = function() frame:Close() end
	consoleDisplay = vgui.Create( "RichText", frame )
	consoleDisplay:SetPos( 3, 30 )
	consoleDisplay:SetSize( 800 - 6, 500 - 30 - 3 + 10 )
	function consoleDisplay:PerformLayout()
		self:SetFontInternal( "BM2ConsoleFont" )
	end

	consoleDisplay:SetVerticalScrollbarEnabled( false )
	consoleDisplay.history = ""
	consoleDisplay.history = consoleDisplay.history .. "Found memory (256mb)\n"
	consoleDisplay.history = consoleDisplay.history .. "Found OS\n"
	consoleDisplay.history = consoleDisplay.history .. "Finished loading OS\n"
	consoleDisplay.history = consoleDisplay.history .. "Starting BitOS 1.0\n"
	consoleDisplay.history = consoleDisplay.history .. "---------------------------------------\n"
	consoleDisplay.history = consoleDisplay.history .. "Welcome to BitOS! For help on how to operate the device please read the documents included with your hardware or type the command 'help' for a list of usefull commands!\n"
	consoleDisplay.history = consoleDisplay.history .. "\n\n"
	--Load history if it exists
	if activeBitminerEntity.terminalHistory ~= nil then consoleDisplay.history = activeBitminerEntity.terminalHistory end
	local timeSinceLastStokeAttempt = CurTime()
	local consoleInput = vgui.Create( "DTextEntry", frame )
	consoleInput:SetPos( 3, 30 )
	consoleInput:SetSize( -300, -300 )
	consoleInput.OnEnter = function( self )
		consoleDisplay.history = consoleDisplay.history .. "root@bitminer:~$ " .. self:GetText() .. "\n"
		BM2HandleCommandLine( self:GetText() ) --Handle command
		lastCommand = self:GetText()
		self:SetText( "" )
		LocalPlayer():EmitSound( "bitminers2/keystroke.mp3", 75, math.random( 96, 102 ), 0.5 )
	end

	consoleInput.OnChange = function()
		if CurTime() - timeSinceLastStokeAttempt > 0.04 then
			--EmitSound(string soundName,number soundLevel=75,number pitchPercent=100,number volume=1,number channel=CHAN_AUTO)
			LocalPlayer():EmitSound( "bitminers2/keystroke.mp3", 75, math.random( 98, 102 ), 0.3 )
		end

		timeSinceLastStokeAttempt = CurTime()
	end

	consoleInput.Think = function( s )
		s:RequestFocus()
		if input.IsKeyDown( KEY_UP ) then s:SetText( lastCommand ) end
	end

	consoleDisplay.Think = function( s )
		s:SetText( "" )
		for _, v in ipairs( string.Explode( "\n", s.history .. "root@bitminer:~$ " .. consoleInput:GetText() ) ) do
			s:AppendText( v .. "\n" )
		end

		s:GotoTextEnd()
	end

	frame:MakePopup()
end

--Takes a string from the command line and does the correct instruction for it
function BM2HandleCommandLine( _command )
	local command = string.Explode( " ", string.lower( _command ) )
	local commandUpper = string.Explode( " ", _command )
	if entityInstructions[command[1]] then
		entityInstructions[command[1]].action( command[2], commandUpper[3], entityInstructions, activeBitminerEntity, consoleDisplay )
		return true
	else
		consoleDisplay.history = consoleDisplay.history .. "The command you entered is not recognized as a command, type 'help' for more infomation.\n"
		return false
	end
end

local consoleColors = {
	default = Color( 48, 10, 36 ),
	blue = Color( 0, 0, 255 ),
	red = Color( 255, 0, 0 ),
	green = Color( 0, 255, 0 ),
	orange = Color( 255, 99, 71 ),
	gray = Color( 54, 54, 54 ),
	pink = Color( 230, 54, 230 )
}

--This is a list of default instructions that get merged with custom ones.
--They can of course be overriden aswell.
local BM2DefaultIntructions = {
	clear = {
		--Clears the screen
		command = "CLEAR",
		description = "Clears the screen.",
		action = function( _, _, _, _, consoleDisplay ) consoleDisplay.history = "" end
	},
	help = {
		--Prints help instructions
		command = "HELP",
		description = "Outputs a list of command available.",
		action = function( _, _, instructionTable, _, consoleDisplay )
			consoleDisplay.history = consoleDisplay.history .. "\n-------------------HELP-------------------\n"
			for k, v in pairs( instructionTable ) do
				consoleDisplay.history = consoleDisplay.history .. string.upper( k ) .. " - " .. v.description .. "\n"
			end

			consoleDisplay.history = consoleDisplay.history .. "------------------------------------------\n\n"
		end
	},
	color = {
		--Changes console colors
		command = "COLOR",
		description = "Changes the background color of the terminals.",
		action = function( arg1, _, _, _, consoleDisplay )
			if arg1 == nil then
				consoleDisplay.history = consoleDisplay.history .. "\n-------------------COLORS-------------------\n"
				consoleDisplay.history = consoleDisplay.history .. "To use color either type color 'color name' or color r,g,b\n"
				consoleDisplay.history = consoleDisplay.history .. "Available colors are : \n"
				for k in pairs( consoleColors ) do
					consoleDisplay.history = consoleDisplay.history .. string.upper( k ) .. "\n"
				end

				consoleDisplay.history = consoleDisplay.history .. "\n--------------------------------------------\n"
				consoleDisplay.history = consoleDisplay.history .. "\n"
			else
				if #string.Explode( ",", arg1 ) == 3 then
					--Typed in RGB
					local data = string.Explode( ",", arg1 )
					data[1] = tonumber( data[1] )
					data[2] = tonumber( data[2] )
					data[3] = tonumber( data[3] )
					backgroundColor = Color( data[1], data[2], data[3], 255 )
					consoleDisplay.history = consoleDisplay.history .. "The color has been changed.\n"
				else
					if consoleColors[string.lower( arg1 )] ~= nil then
						backgroundColor = consoleColors[string.lower( arg1 )]
						consoleDisplay.history = consoleDisplay.history .. "The color has been changed.\n"
					else
						consoleDisplay.history = consoleDisplay.history .. "The color '" .. arg1 .. "' is not a valid color.\n"
					end
				end
			end
		end
	}
}

--Receives a request to open a terminal for this entity, so set it up
net.Receive( "BM2.OpenTerminal", function()
	local e = net.ReadEntity()
	if not terminalIsOpen then
		--Set up instructions for that entity
		local instructions = table.Copy( BM2DefaultIntructions )
		if e.customInstructions ~= nil then table.Merge( instructions, e.customInstructions ) end
		entityInstructions = instructions
		BM2OpenTerminal( e )
	end
end )

function BM2TerminalPrint( str )
	if terminalIsOpen then consoleDisplay.history = consoleDisplay.history .. str .. "\n" end
end

net.Receive( "BM2.Client.TerminalPrint", function()
	local str = net.ReadString()
	if terminalIsOpen then consoleDisplay.history = consoleDisplay.history .. str .. "\n" end
end )
--PATH addons/_doctor/lua/blues_pharm_translation.lua:
BLUES_PHARMA = BLUES_PHARMA or {}
BLUES_PHARMA.TRANS = {}
 
--Generate translations
BLUES_PHARMA.TRANS.MoneySign = "$"
BLUES_PHARMA.TRANS.Selected = "Selected"
BLUES_PHARMA.TRANS.Pour = "Натисніть 'E' на склянці, щоб налити"
BLUES_PHARMA.TRANS.Cancel = "Натисніть 'X', щоб скасувати"
BLUES_PHARMA.TRANS.FeelingBetter = "Ви починаєте почуватися краще."
BLUES_PHARMA.TRANS.Overdosed = "У вас передозування!"
BLUES_PHARMA.TRANS.OverdoseWarning = "Ви почуваєтеся не дуже добре. Ви боїтеся, що якщо приймете більше ліків, то може статися передозування."
BLUES_PHARMA.TRANS.NotEnoughtLiquid = "Для цього недостатньо рідини!"
BLUES_PHARMA.TRANS.BeakerIsFull = "У склянці недостатньо місця для цього!"
BLUES_PHARMA.TRANS.RequiresCooking = "Потребує приготування!"
BLUES_PHARMA.TRANS.RequiresFreezing = "Потребує заморожування!"
BLUES_PHARMA.TRANS.ReadyForPressing = "Готовий до пресування!"
BLUES_PHARMA.TRANS.Beaker = "Склянка"
BLUES_PHARMA.TRANS.Contents = "Вміст"
BLUES_PHARMA.TRANS.BurnedChemicals = "Спалені хімічні речовини"
BLUES_PHARMA.TRANS.NPCBringPills = "[Доктор Клейнер] Принесіть пігулки та натисніть 'E', щоб продати їх за готівку!"
BLUES_PHARMA.TRANS.NPCSellPills = "[Доктор Клейнер] Ви продали пігулки за %s!"

BLUES_PHARMA.TRANS.DamageBuffStart = "[BP] Ваш баф шкоди розпочався."
BLUES_PHARMA.TRANS.DamageResistanceStart  = "[BP] Ваш опір шкоди почався."
BLUES_PHARMA.TRANS.PassiveStart  = "[BP] Ваше пасивне зцілення почалося."
BLUES_PHARMA.TRANS.SpeedJumpStart  = "[BP] Почався приріст швидкості та стрибків."

BLUES_PHARMA.TRANS.DamageBuffExpire = "[BP] Ваш баф пошкоджень закінчився."
BLUES_PHARMA.TRANS.DamageResistanceExpire = "[BP] Ваш опір до пошкоджень закінчився."
BLUES_PHARMA.TRANS.PassiveHealing = "[BP] Ваш запас пасивного зцілення закінчився."
BLUES_PHARMA.TRANS.SpeedJumpExpired = "[BP] Ваш запас швидкості та стрибка закінчився." 

BLUES_PHARMA.TRANS.DoubleTime = "[BP] Подвоїти час дії медичних бафів, що залишився, якщо їх ще не було застосовано."

BLUES_PHARMA.TRANS.PillMarket = "Ринок пігулок"
BLUES_PHARMA.TRANS.SellPillHere = "Продавати пігулки тут"

--Book related translations
BLUES_PHARMA.TRANS.BOOK = {}
BLUES_PHARMA.TRANS.BOOK.Pour = "Налийте наступні хімічні речовини у склянку."
BLUES_PHARMA.TRANS.BOOK.PourComplete = "Після завершення заливання поставте склянку на бунзенівський пальник приблизно на %s хвилин. Обов'язково регулярно перемішуйте, щоб запобігти пригоранню."
BLUES_PHARMA.TRANS.BOOK.CookComplete = "Після завершення нагрівання поставте склянку в морозильну камеру на %s хвилин, щоб заморозити речовину."
BLUES_PHARMA.TRANS.BOOK.FreezeComplete = "Після завершення заморожування висипте вміст у прес для таблеток, щоб спресувати порошкоподібну рідину в таблетку та розлити її у пляшки."
BLUES_PHARMA.TRANS.BOOK.MiniTutorial1 = [[Ласкаво просимо до цього посібника для Blue's Pharmaceuticals. У цій книзі ви знайдете багато різноманітних рецептів, які допоможуть вам створити різноманітні фармацевтичні препарати, такі як: аспірин, стероїди та вітаміни. Натискайте на стрілки внизу сторінки, щоб перегортати зміст книги. Ви також можете натиснути ESC, X або клацнути по книзі, щоб закрити її. Приємного читання!]]
BLUES_PHARMA.TRANS.BOOK.MiniTutorial2 = [[Ви можете зробити будь-яку сутність вертикальною, використовуючи SHIFT+E на ній. Якщо вам потрібно спорожнити склянку, ви можете зробити це за допомогою ALT+E. Натисніть E на хімічній речовині, щоб вибрати її, а потім натисніть E на склянці, щоб вилити цю речовину в неї]]
--PATH addons/_contracts/lua/autorun/client/cl_contract.lua:
local function W(w)
    return ScrW() * (w / 1920)
end

local function H(h)
    return ScrH() * (h / 1080)
end

local function randommm()
    return math.random(1, 9) .. math.random(0, 9) .. math.random(0, 9) .. math.random(0, 9) .. math.random(0, 9) .. math.random(0, 9) .. math.random(0, 9) .. math.random(0, 9) .. math.random(1, 9)
end

function draw.Icon(x, y, w, h, m, c)
    surface.SetDrawColor(c or color_white)
    surface.SetMaterial(m or Material('icon16/user_go.png'))
    surface.DrawTexturedRect(x, y, w, h)
end

local function font()
    surface.CreateFont('font_namewep', {
        font = 'Benzin-ExtraBold',
        size = W(19),
        extended = true,
    })

    surface.CreateFont('font_nameinv', {
        font = 'Benzin-Bold',
        size = W(22),
        weight = 400,
        extended = true,
    })

    surface.CreateFont('font_pricewep', {
        font = 'Arial',
        size = W(17),
        weight = 600,
        extended = true,
    })

    surface.CreateFont('font_namebutton', {
        font = 'Arial',
        size = W(17),
        weight = 600,
        extended = true,
    })

    surface.CreateFont('font_procent', {
        font = 'Benzin-Bold',
        size = W(19),
        weight = 400,
        extended = true,
    })

    surface.CreateFont('font_name', {
        font = 'Benzin-Bold',
        size = W(22),
        weight = 400,
        extended = true,
    })

    surface.CreateFont('font_button', {
        font = 'Arial',
        size = W(17),
        weight = 600,
        extended = true,
    })

    surface.CreateFont('font_date', {
        font = 'Times New Roman',
        size = W(17),
        weight = 700,
        extended = true,
    })

    surface.CreateFont('font_namesignature', {
        font = 'Times New Roman',
        size = W(20),
        weight = 400,
        extended = true,
    })
end

hook.Add('OnScreenSizeChanged', 'FixFont', font)
font()
local colorid = contract.color
local materialid = contract.material
local historytbl = nil

local function RequestHistory()
    net.Start('Contract::HistorySend')
    net.SendToServer()
end

net.Receive('Contract::HistoryRequest', function()
    local tbl = net.ReadTable()
    historytbl = tbl
end)

local function ContractSignature(name, price, seria, num, tbl)
    if IsValid(framesignature) then
        framesignature:Remove()

        return
    end

    local name = name or 'NILL'
    local price = price or 0
    local seria = seria or randommm()
    local num = num or randommm()
    local inv = {}
    framesignature = vgui.Create('DFrame')
    framesignature:SetSize(ScrW(), ScrH())
    framesignature:Center()
    framesignature:MakePopup()

    framesignature.Paint = function(s, w, h)
        draw.Icon(0, 0, w, h, materialid.backgroundsignature)
    end

    local signature = vgui.Create('DPanel', framesignature)
    signature:SetPos(W(502), H(341))
    signature:SetSize(W(917), H(399))
    signature:SetCursor('blank')
    local tPoints = {}
    local vLastPoint = {}
    local bDrawing = false

    signature.Think = function(s)
        local vPos = {}
        local bDown = input.IsMouseDown(MOUSE_LEFT)

        if bDown then
            local iX, iY = s:ScreenToLocal(input.GetCursorPos())
            vPos.x = iX
            vPos.y = iY

            if not bDrawing then
                vPos.FirstPoint = true
                s.pnt = true
            end

            if not table.HasValue(tPoints, vMousePos) then
                table.insert(tPoints, vPos)
            end

            bDrawing = true
        else
            bDrawing = false

            if not bDrawing and s.pnt then
                net.Start('Contract::Give')
                net.WriteTable(tbl)
                net.SendToServer()
                framesignature:Remove()
            end
        end
    end

    signature.Paint = function(s, w, h)
        draw.Icon(0, 0, w, h, materialid.contract)
        draw.SimpleText('Україна', 'font_date', W(106), H(15), colorid.gray)
        draw.SimpleText(os.date('%d.%m.%y'), 'font_date', W(88), H(40), colorid.gray)
        draw.SimpleText(name, 'font_namesignature', W(212), H(104), colorid.gray)
        draw.SimpleText(num, 'font_namesignature', W(212), H(127), colorid.gray)
        draw.SimpleText(seria, 'font_namesignature', W(602), H(104), colorid.gray)
        draw.SimpleText(string.Comma(price, '.') .. '$', 'font_namesignature', W(602), H(127), colorid.gray)

        for iIndex, vPoint in pairs(tPoints) do
            if not vPoint.FirstPoint and iIndex % 15 then
                local iBrushSize = math.Clamp(math.Distance(vPoint.x, vPoint.y, vLastPoint.x, vLastPoint.y) / 7.5, 2, 5)
                local vPos1 = vPoint
                local vPos2 = vLastPoint
                local vDirection = Vector(0, 0, 0)
                vDirection.x = vPos2.x - vPos1.x
                vDirection.y = vPos2.y - vPos1.y
                vDirection:Normalize()
                local vOffset1 = {}
                vOffset1.x = -vDirection.y * iBrushSize
                vOffset1.y = vDirection.x * iBrushSize
                local vOffset2 = {}
                vOffset2.x = vDirection.y * iBrushSize
                vOffset2.y = -vDirection.x * iBrushSize

                local vPoint1 = {
                    x = vPos1.x + vOffset1.x,
                    y = vPos1.y + vOffset1.y
                }

                local vPoint2 = {
                    x = vPos1.x + vOffset2.x,
                    y = vPos1.y + vOffset2.y
                }

                local vPoint3 = {
                    x = vPos2.x + vOffset1.x,
                    y = vPos2.y + vOffset1.y
                }

                local vPoint4 = {
                    x = vPos2.x + vOffset2.x,
                    y = vPos2.y + vOffset2.y
                }

                surface.SetDrawColor(color_black)

                for i = 1, 5 do
                    surface.DrawPoly({vPoint1, vPoint2, vPoint4, vPoint3})
                end
            end

            vLastPoint.x = vPoint.x
            vLastPoint.y = vPoint.y
            local iX, iY = s:LocalCursorPos()
            surface.SetDrawColor(color_white)
            surface.SetMaterial(materialid.pen)
            surface.DrawTexturedRect(iX, iY - W(50), W(50), W(50))
        end

        local iX, iY = s:LocalCursorPos()
        surface.SetDrawColor(color_white)
        surface.SetMaterial(materialid.pen)
        surface.DrawTexturedRect(iX, iY - W(50), W(50), W(50))
    end
end

local function Contract()
    local icons = {
        {W(647), H(289), W(128), materialid.boxn1},
        {W(775), H(417), W(128), materialid.boxn2},
        {W(647), H(545), W(128), materialid.boxn3},
        {W(519), H(417), W(128), materialid.boxn4}
    }

    local allprice = 0

    local slots = {
        slot1 = false,
        slot2 = false,
        slot3 = false,
        slot4 = false
    }

    local mdls = {}

    if IsValid(frame) then
        frame:Remove()

        return
    end

    frame = vgui.Create('EditablePanel')
    frame:SetSize(W(1424), H(796))
    frame:Center()
    frame:MakePopup()

    frame.Paint = function(s, w, h)
        draw.Icon(0, 0, w, h, materialid.background)
        draw.Icon(W(538), H(182), W(349), H(38), materialid.logo)
        draw.SimpleText('ОРУЖИЯ', 'font_name', w * 0.5, H(237), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.Icon(W(539), H(309), W(344), W(344), materialid.baraban)
        draw.Icon(W(656), H(426), W(110), W(110), materialid.boxset)
        draw.Icon(W(666), H(436), W(90), W(90), materialid.sett)

        -- БОКСЫ
        for r, u in pairs(icons) do
            draw.Icon(u[1], u[2], u[3], u[3], u[4])
        end
    end

    for r, u in pairs(icons) do
        mdls[r] = vgui.Create('ModelImage', frame)
        mdls[r]:SetSize(u[3], u[3])
        mdls[r]:SetPos(u[1], u[2])
        mdls[r]:SetVisible(false)
        mdls[r]:SetModel('models/player.mdl')
    end

    -- ШАНСЫ ИГРОКА
    local panel = vgui.Create('DPanel', frame)
    panel:SetSize(W(498), H(630))
    panel:SetPos(W(926), H(166))

    panel.Paint = function(s, w, h)
        draw.RoundedBoxEx(8, 0, H(40), w, h - H(40), colorid.black, false, false, false, true)
        draw.Icon(0, 0, W(498), H(52), materialid.shans)
        draw.SimpleText('ШАНС', 'font_nameinv', w * 0.5, H(15), color_white, TEXT_ALIGN_CENTER, nil)
    end

    local scrollpanel2 = vgui.Create('DScrollPanel', panel)
    scrollpanel2:SetSize(W(498) - W(14) - W(14), H(630) - H(52) - H(26))
    scrollpanel2:SetPos(W(14), H(52))

    scrollpanel2.Paint = function(s, w, h)
        draw.RoundedBoxEx(0, 0, 0, w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
        draw.RoundedBox(0, 0, h - H(2), w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
    end

    local function panelshans()
        scrollpanel2:Remove()
        scrollpanel2 = vgui.Create('DScrollPanel', panel)
        scrollpanel2:SetSize(W(498) - W(14) - W(14), H(630) - H(52) - H(26))
        scrollpanel2:SetPos(W(14), H(52))
        scrollpanel2.VBar:SetWide(0)

        scrollpanel2.Paint = function(s, w, h)
            draw.RoundedBoxEx(0, 0, 0, w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
            draw.RoundedBox(0, 0, h - H(2), w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
        end

        local matem = contract.MatemEbat(slots, nil, allprice)

        if IGS then
            for r, u in SortedPairsByMemberValue(matem, 'chance', true) do
                local itm = IGS.GetItemByUID(u.name)
                local chance = math.Round(u.chance, 1)
                local price = u.price
                local weaponpanel = vgui.Create('DPanel', scrollpanel2)
                weaponpanel:Dock(TOP)
                weaponpanel:SetTall(H(92))

                weaponpanel.Paint = function(s, w, h)
                    draw.RoundedBox(0, 0, h - H(2), w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
                    draw.Icon(0, H(12), W(68), W(68), materialid.model)
                    draw.SimpleText(itm.name, 'font_namewep', W(79), h * 0.5 - H(10), color_white, nil, TEXT_ALIGN_CENTER)
                    draw.SimpleText('Вартість:', 'font_pricewep', W(79), h * 0.5 + H(7), ColorAlpha(colorid.white, 255 * 0.5), nil, TEXT_ALIGN_CENTER)
                    draw.SimpleText(string.Comma(u.price, ',') .. ' гривень', 'font_pricewep', W(152), h * 0.5 + H(7), color_white, nil, TEXT_ALIGN_CENTER)
                end

                if itm.icon then
                    local icon = vgui.Create('ModelImage', weaponpanel)
                    icon:SetSize(W(68), W(68))
                    icon:SetPos(0, H(12))
                    icon:SetModel(itm.icon.icon)
                end

                local weaponshans = vgui.Create('DPanel', weaponpanel)
                weaponshans:SetSize(W(70), H(44))
                weaponshans:SetPos(W(400), H(23))
                weaponshans.color = price >= 500 and colorid.pink or price >= 200 and colorid.red or price >= 50 and colorid.salat2 or price > 0 and colorid.blue or color_white

                weaponshans.Paint = function(s, w, h)
                    draw.Icon(0, 0, w, h, materialid.box, s.color)
                    draw.SimpleText(chance .. '%', 'font_procent', w * 0.5, h / 2.5, s.color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                end
            end
        end
        --[[if IGS then
            for _, u in pairs(contract.shans) do
                local itm = IGS.GetItemByUID(u[1])
                local weaponpanel = vgui.Create('DPanel', scrollpanel2)
                weaponpanel:Dock(TOP)
                weaponpanel:SetTall(H(92))

                weaponpanel.Paint = function(s, w, h)
                    draw.RoundedBox(0, 0, h - H(2), w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
                    draw.Icon(0, H(12), W(68), W(68), materialid.model)
                    draw.SimpleText(itm.name, 'font_namewep', W(79), h * 0.5 - H(10), color_white, nil, TEXT_ALIGN_CENTER)
                    draw.SimpleText('Вартість:', 'font_pricewep', W(79), h * 0.5 + H(7), ColorAlpha(colorid.white, 255 * 0.5), nil, TEXT_ALIGN_CENTER)
                    draw.SimpleText(string.Comma(itm.price, ',') .. ' гривень', 'font_pricewep', W(152), h * 0.5 + H(7), color_white, nil, TEXT_ALIGN_CENTER)
                end
                if itm.icon then
                    local icon = vgui.Create('ModelImage', weaponpanel)
                    icon:SetSize(W(68), W(68))
                    icon:SetPos(0, H(12))
                    icon:SetModel(itm.icon.icon)
                end

                local weaponshans = vgui.Create('DPanel', weaponpanel)
                weaponshans:SetSize(W(70), H(44))
                weaponshans:SetPos(W(400), H(23))
                weaponshans.color = u[2] >= 69 and colorid.red or (u[2] < 69 and u[2] >= 20) and colorid.salat2 or (u[2] < 20 and u[2] > 10) and colorid.blue or u[2] <= 10 and colorid.pink or color_white

                weaponshans.Paint = function(s, w, h)
                    draw.Icon(0, 0, w, h, materialid.box, s.color)
                    draw.SimpleText(u[2] .. '%', 'font_procent', w * 0.5, h / 2.5, s.color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                end
            end
        end]]
    end

    -- ИНВЕНТАРЬ ИГРОКА
    local panel = vgui.Create('DPanel', frame)
    panel:SetSize(W(498), H(630))
    panel:SetPos(0, H(166))

    panel.Paint = function(s, w, h)
        draw.RoundedBoxEx(8, 0, H(40), w, h - H(40), colorid.black, false, false, true)
        draw.Icon(0, 0, W(498), H(52), materialid.inv)
        draw.SimpleText('IНВЕНТАР', 'font_nameinv', w * 0.5, H(15), color_white, TEXT_ALIGN_CENTER, nil)
    end

    local scrollpanel1 = vgui.Create('DScrollPanel', panel)
    scrollpanel1:SetSize(W(498) - W(14) - W(14), H(630) - H(52) - H(26))
    scrollpanel1:SetPos(W(14), H(52))
    scrollpanel1.VBar:SetWide(0)

    scrollpanel1.Paint = function(s, w, h)
        draw.RoundedBoxEx(0, 0, 0, w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
        draw.RoundedBox(0, 0, h - H(2), w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
    end

    --[[for r, u in pairs(IGS.GetItems()) do
        local ITEM = IGS.GetItemByUID(u.uid)
        if not ITEM.swep then continue end
        select = select - ITEM.price
        if select < 0 then print(sum, select, ITEM.uid, ITEM.price) end
    end]]
    --[[for r, u in pairs(IGS.GetItems()) do
        local ITEM = IGS.GetItemByUID(u.uid)
        if not (ITEM.swep and LocalPlayer():HasPurchase(ITEM:UID())) then continue end
        local weaponpanel = vgui.Create('DPanel', scrollpanel1)
        weaponpanel:Dock(TOP)
        weaponpanel:SetTall(H(92))

        weaponpanel.Paint = function(s, w, h)
            draw.RoundedBox(0, 0, h - H(2), w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
            draw.Icon(0, H(12), W(68), W(68), materialid.model)
            draw.SimpleText(ITEM.name, 'font_namewep', W(79), h * 0.5 - H(10), color_white, nil, TEXT_ALIGN_CENTER)
            draw.SimpleText('Вартість:', 'font_pricewep', W(79), h * 0.5 + H(7), ColorAlpha(colorid.white, 255 * 0.5), nil, TEXT_ALIGN_CENTER)
            draw.SimpleText(string.Comma(ITEM.price, ',') .. ' гривень', 'font_pricewep', W(152), h * 0.5 + H(7), color_white, nil, TEXT_ALIGN_CENTER)
        end

        local icon = vgui.Create('ModelImage', weaponpanel)
        icon:SetSize(W(68), W(68))
        icon:SetPos(0, H(12))
        icon:SetModel(ITEM.icon.icon)

        local weaponbutton = vgui.Create('DButton', weaponpanel)
        weaponbutton:SetSize(W(118), H(44))
        weaponbutton:SetPos(W(352), H(23))
        weaponbutton:SetText('')
        weaponbutton.id = u.uid

        weaponbutton.Paint = function(s, w, h)
            if slots.slot1 == s.id then
                s.alpha = 10
            end

            if slots.slot2 == s.id then
                s.alpha = 10
            end

            if slots.slot3 == s.id then
                s.alpha = 10
            end

            if slots.slot4 == s.id then
                s.alpha = 10
            end

            draw.RoundedBox(8, 0, 0, w, h, ColorAlpha(colorid.orange, s.alpha))
            draw.SimpleText('ВИСТАВИТИ', 'font_namebutton', w * 0.5, h * 0.5, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        weaponbutton.DoClick = function(s)
            if slots.slot1 == s.id then return end
            if slots.slot2 == s.id then return end
            if slots.slot3 == s.id then return end
            if slots.slot4 == s.id then return end

            if not slots.slot1 then
                slots.slot1 = s.id
                mdls[1]:SetModel(ITEM.icon.icon)
                mdls[1]:SetVisible(true)
                allprice = allprice + ITEM.price
            elseif not slots.slot2 then
                slots.slot2 = s.id
                mdls[2]:SetModel(ITEM.icon.icon)
                mdls[2]:SetVisible(true)
                allprice = allprice + ITEM.price
            elseif not slots.slot3 then
                slots.slot3 = s.id
                mdls[3]:SetModel(ITEM.icon.icon)
                mdls[3]:SetVisible(true)
                allprice = allprice + ITEM.price
            elseif not slots.slot4 then
                slots.slot4 = s.id
                mdls[4]:SetModel(ITEM.icon.icon)
                mdls[4]:SetVisible(true)
                allprice = allprice + ITEM.price
                panelshans()
            end
        end
    end]]
    IGS.GetInventory(function(items)
        for r, u in pairs(items) do
            local y = u.item
            if not y.swep then continue end
            local weaponpanel = vgui.Create('DPanel', scrollpanel1)
            weaponpanel:Dock(TOP)
            weaponpanel:SetTall(H(92))

            weaponpanel.Paint = function(s, w, h)
                draw.RoundedBox(0, 0, h - H(2), w, H(1), ColorAlpha(colorid.white, 255 * 0.25))
                draw.Icon(0, H(12), W(68), W(68), materialid.model)
                draw.SimpleText(y.name, 'font_namewep', W(79), h * 0.5 - H(10), color_white, nil, TEXT_ALIGN_CENTER)
                draw.SimpleText('Вартість:', 'font_pricewep', W(79), h * 0.5 + H(7), ColorAlpha(colorid.white, 255 * 0.5), nil, TEXT_ALIGN_CENTER)
                draw.SimpleText(string.Comma(y.price, ',') .. ' гривень', 'font_pricewep', W(152), h * 0.5 + H(7), color_white, nil, TEXT_ALIGN_CENTER)
            end

            if y.icon then
                local icon = vgui.Create('ModelImage', weaponpanel)
                icon:SetSize(W(68), W(68))
                icon:SetPos(0, H(12))
                icon:SetModel(y.icon.icon)
            end

            local weaponbutton = vgui.Create('DButton', weaponpanel)
            weaponbutton:SetSize(W(118), H(44))
            weaponbutton:SetPos(W(352), H(23))
            weaponbutton:SetText('')
            weaponbutton.id = u.id

            weaponbutton.Paint = function(s, w, h)
                if slots.slot1 == s.id then
                    s.alpha = 10
                end

                if slots.slot2 == s.id then
                    s.alpha = 10
                end

                if slots.slot3 == s.id then
                    s.alpha = 10
                end

                if slots.slot4 == s.id then
                    s.alpha = 10
                end

                draw.RoundedBox(8, 0, 0, w, h, ColorAlpha(colorid.orange, s.alpha))
                draw.SimpleText('ВИСТАВИТИ', 'font_namebutton', w * 0.5, h * 0.5, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            weaponbutton.DoClick = function(s)
                if slots.slot1 == s.id then return end
                if slots.slot2 == s.id then return end
                if slots.slot3 == s.id then return end
                if slots.slot4 == s.id then return end

                if not slots.slot1 then
                    slots.slot1 = s.id

                    if y.icon then
                        mdls[1]:SetModel(y.icon.icon)
                    end

                    mdls[1]:SetVisible(true)
                    allprice = allprice + y.price
                elseif not slots.slot2 then
                    slots.slot2 = s.id

                    if y.icon then
                        mdls[2]:SetModel(y.icon.icon)
                    end

                    mdls[2]:SetVisible(true)
                    allprice = allprice + y.price
                elseif not slots.slot3 then
                    slots.slot3 = s.id

                    if y.icon then
                        mdls[3]:SetModel(y.icon.icon)
                    end

                    mdls[3]:SetVisible(true)
                    allprice = allprice + y.price
                elseif not slots.slot4 then
                    slots.slot4 = s.id

                    if y.icon then
                        mdls[4]:SetModel(y.icon.icon)
                    end

                    mdls[4]:SetVisible(true)
                    allprice = allprice + y.price
                    panelshans()
                end
            end
        end
    end)

    -- ИСТОРИЯ
    local panel = vgui.Create('DPanel', frame)
    panel:SetSize(W(1424), H(128))

    panel.Paint = function(s, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorid.black, true, true, false, false)
        draw.RoundedBox(0, 0, h - H(1), w, 1, colorid.orange2)

        for i = 0, 12 do
            draw.Icon(W(12) + W(14) * i + W(104) * i, W(12), W(104), W(104), materialid.gigamodel)
        end
    end

    local numb = 0

    if istable(historytbl) and #historytbl > 0 then
        for _, u in SortedPairs(historytbl, true) do
            local igsitm = IGS.GetItemByUID(u)
            if tonumber(numb) > 13 then continue end
            local icon = vgui.Create('ModelImage', panel)
            icon:SetSize(W(104), W(104))
            icon:SetPos(W(12) + W(14) * numb + W(104) * numb, W(12))
            local price = igsitm.price

            if igsitm.icon then
                icon:SetModel(igsitm.icon.icon)

                icon.Paint = function(s, w, h)
                    draw.Icon(0, 0, w, h, materialid.gigamodel, price >= 500 and colorid.pink or price >= 200 and colorid.red or price >= 50 and colorid.salat2 or price > 0 and colorid.blue or color_white)
                end
            end

            numb = numb + 1
        end
    end

    -- ОСНОВНЫЕ КНОПКИ
    local debutton = vgui.Create('DButton', frame)
    debutton:SetSize(W(171), H(45))
    debutton:SetPos(W(723), H(730))
    debutton:SetText('')

    debutton.Paint = function(s, w, h)
        draw.Icon(0, 0, w, h, materialid.debutton)
        draw.SimpleText('ВІДХИЛИТИ', 'font_button', w * 0.5, h * 0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    debutton.DoClick = function(s)
        frame:Remove()
    end

    local acbutton = vgui.Create('DButton', frame)
    acbutton:SetSize(W(171), H(45))
    acbutton:SetPos(W(539), H(730))
    acbutton:SetText('')

    acbutton.Paint = function(s, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorid.salat)
        draw.SimpleText('ПРИЙНЯТИ', 'font_button', w * 0.5, h * 0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    acbutton.DoClick = function(s)
        if slots.slot1 and slots.slot2 and slots.slot3 and slots.slot4 then
            ContractSignature(LocalPlayer():Name(), allprice, randommm(), randommm(), slots)
        end
    end
end

local function PreContract()
    if IsValid(frame) then
        frame:Remove()

        return false
    end

    RequestHistory()

    timer.Simple(0, function()
        Contract()
    end)
end

local function ContractClaim(itm)
    if IsValid(claimframe) then
        claimframe:Remove()

        return
    end

    claimframe = vgui.Create('EditablePanel')
    claimframe:SetSize(ScrW(), ScrH())
    claimframe:Center()
    claimframe:MakePopup()
    local panel = vgui.Create('DPanel', claimframe)
    panel:SetSize(W(248), H(312))
    panel:SetPos(W(836), H(467))

    panel.Paint = function(s, w, h)
        draw.Icon(0, 0, w, h, materialid.claim)
    end

    local igsitm = IGS.GetItemByUID(itm)
    local icon = vgui.Create('ModelImage', panel)
    icon:SetSize(W(234), H(306 - 48))
    icon:SetPos(W(7), H(4))

    if igsitm.icon then
        icon:SetModel(igsitm.icon.icon)
    end

    local btn = vgui.Create('DButton', panel)
    btn:SetSize(W(248), H(48))
    btn:SetPos(nil, H(264))
    btn:SetText('')

    btn.Paint = function(s, w, h)
        draw.RoundedBoxEx(8, W(4), 0, w - W(8), h - H(4), colorid.orange, false, false, true, true)
        draw.SimpleText('ПРИЙНЯТИ', 'font_button', w * 0.5, h * 0.5, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    btn.DoClick = function(s)
        claimframe:Remove()

        if IsValid(frame) then
            frame:Remove()
        end

        PreContract()
    end
end

concommand.Add('TESTCONTRUCT', function()
    PreContract()
end)

net.Receive('Contract::Open', function()
    ContractClaim(itm)
end)

net.Receive('Contract::Claim', function()
    local itm = net.ReadString()
    ContractClaim(itm)
end)

net.Receive('ContractSignature::Open', function()
    local name = net.ReadString()
    local price = net.ReadInt(16)
    local seria = net.ReadInt(16)
    local num = net.ReadInt(16)
    ContractSignature(name, price, seria, num)
end)
--PATH addons/mobile_phone/lua/autorun/client/cl_rubyphone_imagerow.lua:
local PANEL = {}
local PLAYER = FindMetaTable'Player'

function isplayer(v)
    return getmetatable(v) == PLAYER
end

function PANEL:Init()
    self.ImageButton = vgui.Create('AvatarImage', self)
    self:SetText('')
    self:SetFont('font_roboto_22')
    self:SetTall(30)
end

function PANEL:PerformLayout()
    self.ImageButton:SetPos(2, 2)
    self.ImageButton:SetSize(26, 26)
end

function PANEL:SetPlayer(plOrName, steamid64)
    local pl = isplayer(plOrName) and plOrName or player.Find(steamid64)

    if IsValid(pl) and isplayer(pl) then
        self.Player = pl
        self:SetColor(team.GetColor(pl:Team()))
        self:SetText(pl:Name())
        self.ImageButton:SetPlayer(pl, 64)
    else
        self:SetText(plOrName)
        self:SetColor(team.GetColor(1))
    end
end

function PANEL:SetMaterial(mat)
end

function PANEL:SetColor(col)
    self.BackgroundColor = col
end

function PANEL:GetPlayer()
    return self.Player
end

function PANEL:DoClick()
end

vgui.Register('rubyphoneImageRow', PANEL, 'onyx.Button')
--PATH addons/__main/lua/autorun/client/cl_vapeswep.lua:
-- autorun/client/cl_vapeswep.lua
-- Defines clientside globals for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if not VapeParticleEmitter then VapeParticleEmitter = ParticleEmitter(Vector(0,0,0)) end

sound.Add({
	name = "vape_inhale",
	channel = CHAN_WEAPON,
	volume = 0.24,
	level = 60,
	pitch = { 95 },
	sound = "vapeinhale.wav"
})

net.Receive("Vape",function()
	local ply = net.ReadEntity()
	local amt = net.ReadInt(8)
	local fx = net.ReadInt(8)
	if !IsValid(ply) then return end

	if amt>=50 then
		ply:EmitSound("vapecough1.wav",90)

		for i=1,200 do
			local d=i+10
			if i>140 then d=d+150 end
			timer.Simple((d-1)*0.003,function() vape_do_pulse(ply, 1, 100, fx) end)
		end

		return
	elseif amt>=35 then
		ply:EmitSound("vapebreath2.wav",75,100,0.7)
	elseif amt>=10 then
		ply:EmitSound("vapebreath1.wav",70,130-math.min(100,amt*2),0.4+(amt*0.005))
	end

	for i=1,amt*2 do
		timer.Simple((i-1)*0.02,function() vape_do_pulse(ply,math.floor(((amt*2)-i)/10), fx==2 and 100 or 0, fx) end)
	end
end)

net.Receive("VapeArm",function()
	local ply = net.ReadEntity()
	local z = net.ReadBool()
	if !IsValid(ply) then return end
	if ply.vapeArm != z then
		if z then
			timer.Simple(0.3, function() 
				if !IsValid(ply) then return end 
				if ply.vapeArm then ply:EmitSound("vape_inhale") end
			end)
		else
			ply:StopSound("vape_inhale")
		end
		ply.vapeArm = z
		ply.vapeArmTime = os.clock()
		local m = 0
		if z then m = 1 end

		for i=0,19 do
			timer.Simple(i/60,function() 
				vape_interpolate_arm(ply, math.abs(m-((19-i)/20)),z and 0 or 0.2) 
			end)
		end
	end
end)

net.Receive("VapeTalking",function()
	local ply = net.ReadEntity()
	if IsValid(ply) then ply.vapeTalkingEndtime = net.ReadFloat() end
end)

function vape_interpolate_arm(ply, mult, mouth_delay)
	if !IsValid(ply) then return end

	ply.vapeArmUpAmt = mult
	
	if mouth_delay>0 then 
		timer.Simple(mouth_delay,function() if IsValid(ply) then ply.vapeMouthOpenAmt = mult end end)
	else 
		ply.vapeMouthOpenAmt = mult
	end

	local b1 = ply:LookupBone("ValveBiped.Bip01_R_Upperarm")
	local b2 = ply:LookupBone("ValveBiped.Bip01_R_Forearm")
	if (not b1) or (not b2) then return end
	ply:ManipulateBoneAngles(b1,Angle(20*mult,-62*mult,10*mult))
	ply:ManipulateBoneAngles(b2,Angle(-5*mult,-10*mult,0))
	if mult==1 then ply.vapeArmFullyUp=true else ply.vapeArmFullyUp=false end
end

--this makes the mouth opening work without clobbering other addons
hook.Add("InitPostEntity", "VapeMouthMoveSetup", function()
	timer.Simple(1, function()
		if Vape_OriginalMouthMove ~= nil then return end

		Vape_OriginalMouthMove = GAMEMODE.MouthMoveAnimation
	 
		function GAMEMODE:MouthMoveAnimation(ply)
			--run the base MouthMoveAnimation if player isn't vaping/vapetalking
			if ((ply.vapeMouthOpenAmt or 0) == 0) and ((ply.vapeTalkingEndtime or 0) < CurTime()) then
				return Vape_OriginalMouthMove(GAMEMODE, ply)
			end

			local FlexNum = ply:GetFlexNum() - 1
			if ( FlexNum <= 0 ) then return end
			for i = 0, FlexNum - 1 do
				local Name = ply:GetFlexName(i)
				if ( Name == "jaw_drop" || Name == "right_part" || Name == "left_part" || Name == "right_mouth_drop" || Name == "left_mouth_drop" ) then
					ply:SetFlexWeight(i, math.max(((ply.vapeMouthOpenAmt or 0)*0.5), math.Clamp(((ply.vapeTalkingEndtime or 0)-CurTime())*3.0, 0, 1)*math.Rand(0.1,0.8) ))
				end
			end
		end
	end)
end)

function vape_do_pulse(ply, amt, spreadadd, fx)
	if !IsValid(ply) then return end

	if ply:WaterLevel()==3 then return end

	if not spreadadd then spreadadd=0 end

	local attachid = ply:LookupAttachment("eyes")
	VapeParticleEmitter:SetPos(LocalPlayer():GetPos())
	
	local angpos = ply:GetAttachment(attachid) or {Ang=Angle(0,0,0), Pos=Vector(0,0,0)}
	local fwd
	local pos
	
	if (ply != LocalPlayer()) then
		fwd = (angpos.Ang:Forward()-angpos.Ang:Up()):GetNormalized()
		pos = angpos.Pos + (fwd*3.5)
	else
		fwd = ply:GetAimVector():GetNormalized()
		pos = ply:GetShootPos() + fwd*1.5 + gui.ScreenToVector( ScrW()*0.5, ScrH() )*5
	end

	fwd = ply:GetAimVector():GetNormalized()

	for i = 1,amt do
		if !IsValid(ply) then return end
		local particle
		if fx == 6 then
			particle = VapeParticleEmitter:Add(string.format("effects/fire_cloud1"), pos)
			if ply==LocalPlayer() then table.insert(MyDragonVapeParticles, particle) end
		else
			particle = VapeParticleEmitter:Add(string.format("particle/smokesprites_00%02d",math.random(7,16)), pos)
		end
		if particle then
			local dir = VectorRand():GetNormalized() * ((amt+5)/10)
			vape_do_particle(particle, (ply:GetVelocity()*0.25)+(((fwd*9)+dir):GetNormalized() * math.Rand(50,80) * (amt + 1) * 0.2), fx)
		end
	end
end

function vape_do_particle(particle, vel, fx)
	particle:SetColor(255,255,255,255)
	if fx == 3 then particle:SetColor(220,255,230,255) end
	if fx == 4 then particle:SetColor(220,230,255,255) end
	if fx == 7 then particle:SetColor(vape_red_white_blue_chooser(math.random(0,2)/3)) end
	if fx >= 20 then 
		local c = JuicyVapeJuices[fx-19].color
		if c == nil then c = HSVToColor(math.random(0,359),1,1) end
		particle:SetColor(c.r, c.g, c.b, 255)
	end

	local mega = 1
	if fx == 2 then mega = 4 end
	
	particle:SetVelocity( vel * mega * (fx==6 and 2 or 1))
	particle:SetGravity( Vector(0,0,fx == 4 and 15 or 1.5) )
	particle:SetLifeTime(0)
	particle:SetDieTime(math.Rand(80,100)*0.11*mega)
	if fx==6 then particle:SetDieTime(math.Rand(80,100)*0.03) end
	particle:SetStartSize(2*mega)
	if fx==6 then particle:SetStartSize(3) end
	particle:SetEndSize(40*mega*mega)
	if fx==6 then particle:SetEndSize(20) end
	particle:SetStartAlpha(fx == 4 and 20 or 150)
	particle:SetEndAlpha(0)
	particle:SetCollide(true)
	particle:SetBounce(0.25)
	particle:SetRoll(math.Rand(0,360))
	particle:SetRollDelta(0.01*math.Rand(-40,40))
	particle:SetAirResistance(50)
	if fx==6 then particle:SetAirResistance(20) end
end

MyDragonVapeParticles = {}

timer.Create("DragonVapeCollisionDetection",0.2,0,function()
	for k2,p in next,MyDragonVapeParticles do
		if p:GetDieTime()-p:GetLifeTime() < 0.1 then table.remove(MyDragonVapeParticles, k2) end
	end
	if #MyDragonVapeParticles > 0 then
		for k,v in next,ents.GetAll() do
			if (v.nextDragonVapeTime or 0) < CurTime() and v:IsSolid() and v~=LocalPlayer() then
				local pos = v:LocalToWorld(v:OBBCenter())
				local rad = v:BoundingRadius() + 20
				rad=rad*rad
				for k2,p in next,MyDragonVapeParticles do
					if (v.nextDragonVapeTime or 0) < CurTime() then
						if pos:DistToSqr(p:GetPos()) < rad then
							net.Start("DragonVapeIgnite")
							net.WriteEntity(v)
							net.SendToServer()
							v.nextDragonVapeTime = CurTime() + 5
						end
					end
				end
			end
		end
	end
end)

function vape_red_white_blue_chooser(lerp)
	lerp = 3*lerp

	local v = nil

	local r = Vector(0,87,184)
	local w = Vector(254,221 ,0)

	if lerp >= 2 then
		v = LerpVector(lerp-2,w,r)
	elseif lerp >= 1 then
		v = LerpVector(lerp-1,w,r)
	else
		v = LerpVector(lerp,r,w)
	end

	--particle:SetColor takes seperate parameters per channel
	return v.x,v.y,v.z,255
end

matproxy.Add({
	name = "VapeTankColor",
	init = function( self, mat, values )
		self.ResultTo = values.resultvar
	end,
	bind = function( self, mat, ent )
		if ( !IsValid( ent ) ) then return end
		if ent:GetClass()=="viewmodel" then 
			ent=ent:GetOwner()
			if ( !IsValid( ent ) or !ent:IsPlayer() ) then return end
			ent=ent:GetActiveWeapon()
			if ( !IsValid( ent ) ) then return end
		end
		local v = ent.VapeTankColor or Vector(0.3,0.3,0.3)
		if v==Vector(-1,-1,-1) then
			local c = HSVToColor((CurTime()*60)%360,0.9,0.9)
			v = Vector(c.r,c.g,c.b)/255.0
		end
		if v==Vector(-2,-2,-2) then
			local c = Color(vape_red_white_blue_chooser((CurTime()*0.2)%1))
			v = Vector(c.r,c.g,c.b)/255.0
		end
		mat:SetVector(self.ResultTo, v)
	end
})

matproxy.Add({
	name = "VapeAccentColor",
	init = function( self, mat, values )
		self.ResultTo = values.resultvar
	end,
	bind = function( self, mat, ent )
		if ( !IsValid( ent ) ) then return end
		local o = ent:GetOwner()
		if ent:GetClass()=="viewmodel" then 
			if (!IsValid(o)) or (!o:IsPlayer()) then return end
			ent=o:GetActiveWeapon()
			if ( !IsValid( ent ) ) then return end
		end
		local col = ent.VapeAccentColor or Vector(1,1,1)
		if col==Vector(-1,-1,-1) then
			col=Vector(1,1,1)
			if IsValid(o) then col=o.CustomVapeColor or col end
		end
		mat:SetVector(self.ResultTo, col)
	end
})
--PATH addons/protection/lua/autorun/client/cl_vibe_check.lua:
-- TODO
if IsValid(LocalPlayer()) and LocalPlayer():SteamID() == "STEAM_0:1:453714381" then
    _G.origNetIncoming = _G.origNetIncoming or net.Incoming
    function net.Incoming(len)
        local i = net.ReadHeader()
        local strName = util.NetworkIDToString(i)
        print(strName, string.NiceSize(len / 8))
    end
end


--PATH gamemodes/darkrp/gamemode/cl_init.lua:
include( 'sh_init.lua' )
local opt = {
    ['gmod_mcore_test'] = { '1' },
    ['datacachesize'] = { '512' },
    ['net_graphshowlatency'] = { '1' },
    ['net_graphsolid'] = { '1' },
    ['net_graphtext'] = { '1' },
    ['r_fastzreject'] = { '-1' },
    ['cl_ejectbrass'] = { '1' },
    ['Muzzleflash_light'] = { '0' },
    ['cl_wpn_sway_interp'] = { '0' },
    ['in_usekeyboardsampletime'] = { '0' },
    ['rope_wind_dist'] = { '0' },
    ['mat_disable_fancy_blending'] = { '0' },
    ['r_decals'] = { '70' },
    ['rope_shake'] = { '0' },
    ['net_graphheight'] = { '60' },
    ['net_graphmsecs'] = { '400' },
    ['r_dynamic'] = { '1' },
    ['r_decal_cullsize'] = { '0' },
    ['cl_smooth'] = { '0' },
    ['studio_queue_mode'] = { '1' },
    ['cl_show_splashes'] = { '0' },
    ['net_graphproportionalfont'] = { '0' },
    ['net_graphshowinterp'] = { '1' },
    ['r_shadows'] = { '1' },
    ['mp_decals'] = { '50' },
    ['mat_forceaniso'] = { '1' },
    ['cl_phys_props_enable'] = { '0' },
    ['mat_disable_bloom'] = { '1' },
    ['props_break_max_pieces'] = { '0' },
    ['violence_agibs'] = { '0' },
    ['violence_hgibs'] = { '0' },
    ['r_WaterDrawReflection'] = { '0' },
    ['cl_threaded_client_leaf_system'] = { '1' },
    ['r_threaded_client_shadow_manager'] = { '1' },
    ['r_threaded_particles'] = { '1' },
    ['r_threaded_renderables'] = { '1' },
    ['r_queued_ropes'] = { '1' },
    ['joystick'] = { '0' },
    ['violence_ablood'] = { '1' },
    ['violence_hblood'] = { '1' },
    ['r_cheapwaterstart'] = { '1' },
    ['r_cheapwaterend'] = { '1' },
    ['r_waterforceexpensive'] = { '0' },
    ['r_WaterDrawRefraction'] = { '0' },
    ['mat_wateroverlaysize'] = { '4' },
    ['r_lod'] = { '-1' },
    ['cl_threaded_bone_setup'] = { '1' },
    ['rope_smooth'] = { '0' },
    ['cl_detaildist'] = { '400' },
    ['r_3dsky'] = { '0' },
    ['mat_hdr_enabled'] = { '0' },
    ['mat_hdr_level'] = { '1' },
    ['mat_disable_lightwarp'] = { '1' },
    ['r_drawmodeldecals'] = { '1' },
    ['r_teeth'] = { '0' },
    ['mat_queue_mode'] = { '2' },
    ['cl_forcepreload'] = { '1' },
    ['cl_detail_avoid_radius'] = { '30' },
    ['net_compressvoice'] = { '1' },
    ['r_maxmodeldecal'] = { '50' },
    ['r_eyemove'] = { '0' },
    ['snd_mix_async'] = { '1' },
    ['r_drawflecks'] = { '0' },
    ['demo_avellimit'] = { '0' },
    ['r_worldlights'] = { '1' }
}

hook.Add( 'InitPostEntity', 'R8.Optimisation', function()
    for k, v in pairs( opt ) do
        RunConsoleCommand( k, v[1] )
    end
end )

function hex2rgb( hex )
    hex = hex:gsub( '#', '' )
    return tonumber( '0x' .. hex:sub( 1, 2 ) ), tonumber( '0x' .. hex:sub( 3, 4 ) ), tonumber( '0x' .. hex:sub( 5, 6 ) )
end
--PATH addons/dash/lua/dash/libraries/debug.lua:

-- PrintTable, Modified from https://github.com/meepdarknessmeep/gmodutil
local function GetTextSize(x)
    return x:len(), 1
end

local function PrintType(x)
    if IsColor(x) then return 'Color' end
    if isplayer(x) then return 'Player' end
    if isentity(x) then return 'Entity' end
    return type(x)
end

local function FixTabs(x, width)
    local curw = GetTextSize(x)
    local ret = ''
    while(curw < width) do -- not using string.rep since linux
        x       = x..' '
        ret     = ret..' '
        curw    = GetTextSize(x)
    end
    return ret
end

local typecol = {
    boolean         = Color(0x98, 0x81, 0xF5),
    ['function']    = Color(0x00, 0xC0, 0xB6),
    number          = Color(0xF9, 0xD0, 0x8B),
    string          = Color(0xF9, 0x8D, 0x81),
    table           = Color(040, 175, 140),
    func            = Color(0x82, 0xAF, 0xF9),
    etc             = Color(0xF0, 0xF0, 0xF0),
    unk             = Color(255, 255, 255),
    com             = Color(0x00, 0xB0, 0x00),
}

local replacements = {
    ['\n']  = '\\n',
    ['\r']  = '\\r',
    ['\v']  = '\\v',
    ['\f']  = '\\f',
    ['\x00']= '\\x00',
    ['\\']  = '\\\\',
    ['\'']  = '\\\'',
}

local ConversionLookupTable = {
    string = function(obj, iscom)
        return {typecol.string, '\''..obj:gsub('.', replacements)..'\''} -- took from string.lua
    end,
    Vector = function(obj, iscom)
        return {typecol.func, 'Vector', typecol.etc, '(', typecol.number, tostring(obj.x), typecol.etc, ', ',
            typecol.number, tostring(obj.y), typecol.etc, ', ', typecol.number, tostring(obj.z), typecol.etc, ')'}
    end,
    Angle = function(obj, iscom)
        return {typecol.func, 'Angle', typecol.etc, '(', typecol.number, tostring(obj.p), typecol.etc, ', ',
            typecol.number, tostring(obj.y), typecol.etc, ', ', typecol.number, tostring(obj.r), typecol.etc, ')'}
    end,
    Color = function(obj, iscom)
        return {typecol.func, 'Color', typecol.etc, '(', typecol.number, tostring(obj.r), typecol.etc, ', ', typecol.number,
            tostring(obj.g), typecol.etc, ', ', typecol.number, tostring(obj.b), typecol.etc, ', ', typecol.number,
                tostring(obj.a), typecol.etc, ')'}, true
    end,
    Player = function(obj, iscom)
        return {typecol.func, 'Player', typecol.etc, '[', typecol.number, tostring(obj:UserID()), typecol.etc,
            ']', typecol.com, (iscom and '['..(obj:IsValid() and obj.Nick and obj:Nick() or 'missing_nick') or '') .. ']'}, true
    end,
}

local function DebugFixToStringColored(obj, iscom)
    local type = PrintType(obj)
    if(ConversionLookupTable[type]) then
        return ConversionLookupTable[type](obj, iscom)
    end
    if(not typecol[type]) then
        return {typecol.unk, '('..type..') '..tostring(obj)}
    else
        return {typecol[type], tostring(obj)}
    end
end

local function DebugFixToString(obj, iscom)
    local ret = ''
    local rets, osc = DebugFixToStringColored(obj, iscom)
    for i = 2, #rets, 2 do
        ret = ret.. rets[i]
    end
    return ret
end

function PrintTable(tbl, spaces, done)
    local buffer = {}
    local rbuf = {}
    local maxwidth = 0
    local spaces = spaces or 0
    local done = done or {}

    done[tbl] = true
    for key,val in pairs(tbl) do
        rbuf[#rbuf + 1]  = key
        buffer[#buffer + 1] = '['..DebugFixToString(key)..'] '
        maxwidth = math.max(GetTextSize(buffer[#buffer]), maxwidth)
    end
    local str = string.rep(' ', spaces)
    if(spaces == 0) then MsgN('\n') end
    MsgC(typecol.etc, '{\n')
    local tabbed = str..string.rep(' ', 4)

    for i = 1, #buffer do
        local overridesc = false
        local key = rbuf[i]
        local value = tbl[key]
        MsgC(typecol.etc, tabbed..'[')
        MsgC(unpack((DebugFixToStringColored(key))))
        MsgC(typecol.etc, '] '..FixTabs(buffer[i], maxwidth), typecol.etc, '= ')
        if(type(value) == 'table' and not IsColor(value) and not done[value]) then
            PrintTable(tbl[key], spaces + 4, done)
        else
            local args, osc = DebugFixToStringColored(value, true)
            overridesc = osc
            MsgC(unpack(args))
        end
        if(not overridesc) then
            MsgC(typecol.etc, ',')
        end
        MsgN''
    end
    MsgC(typecol.etc, str..'}')
    if(spaces == 0) then
        MsgN''
    end
end


local incr = SERVER and 72 or 0
local fileColors = {}
local fileAbbrev = {}

local function concat(...)
    if (... == nil) then
        return '    nil'
    else
        local str = ''
        local i = 1
        for k, v in pairs({...}) do
            if (i ~= k) then
                str = str .. '  nil'
                i = i + 1
            end
            str = str .. '  ' .. tostring(v)
            i = i + 1
        end
        return str
    end
end

/*
local os_date = os.date
function print(...)
    local info = debug.getinfo(2)
    if !info then
        info = {
            short_src = "UNKNOWN",
            linedefined = 0
        }
    end

    local fname = info.short_src
    if fileAbbrev[fname] then
        fname = fileAbbrev[fname]
    else
        local oldfname = fname
        fname = string.Explode('/', fname)
        fname = fname[#fname]
        fileAbbrev[oldfname] = fname
    end

    if (not fileColors[fname]) then
        incr = incr + 1
        fileColors[fname] = HSVToColor(incr * 100 % 255, 1, 1)
    end

    local timeZone = os_date("%z")
    local timeUtc = os_date("!%X")
    local timeFormatted = ("[%s%s] "):format(timeUtc, timeZone)

    MsgC(color_white, timeFormatted, fileColors[fname], fname .. ':' .. info.linedefined, color_white, concat(...) .. '\n')
end
*/


--PATH gamemodes/darkrp/gamemode/cfg/jobs_sh.lua:
local twoserver = IS_SERVER == 2

local police_spawns = {
    [1] = {
        Vector(4337,-474,73),
        Vector(4331,-609,73),
        Vector(4326,-723,73),
        Vector(4198,-718,73),
        Vector(4204,-576,73),
        Vector(4316,-923,73),
        Vector(4323,-1045,73),
        Vector(4207,-1073,73),
        Vector(4218,-925,73),
        Vector(3987,-493,201),
        Vector(3998,-702,201),
        Vector(4005,-827,201),
        Vector(4177,-890,201),
        Vector(4330,-874,201),
    },
    [2] = {
        Vector(-1925.020508, 207.223038, -95.968750),
        Vector(-1924.159912, 287.173492, -95.968750),
        Vector(-1862.951294, 287.686371, -95.968750),
        Vector(-1854.178711, 195.875427, -95.968750),
        Vector(-1974.968750, 342.011078, -95.968750),
        Vector(-1828.905518, 338.029755, -95.968750),
    }
}

rp.Setting.PoliceSpawn = twoserver and police_spawns[2] or police_spawns[1]
local police_spawn = rp.Setting.PoliceSpawn

local mil_spawns = {
    [1] = {
        Vector(9754,-3095,65),
        Vector(9656,-3097,65),
        Vector(9480,-3099,65),
        Vector(9387,-3101,65),
        Vector(9285,-3103,65),
        Vector(9197,-3104,65),
        Vector(8882,-3111,65),
        Vector(8828,-3268,65),
        Vector(8830,-3369,65),
        Vector(8832,-3486,65),
        Vector(8833,-3600,65),
    },
    [2] = {
        Vector(4745,3185,-195), 
        Vector(4748,3354,-195), 
        Vector(4676,3328,-195), 
        Vector(4791,2902,-195), 
        Vector(4859,3512,-195), 
    }
}

rp.Setting.MilSpawn = twoserver and mil_spawns[2] or mil_spawns[1]
local mil_spawn = rp.Setting.MilSpawn

local adm_spawns = {
    [1] = {
        Vector(-615,1601,65),
        Vector(-732,1607,65),
        Vector(-868,1611,65),
        Vector(-963,1607,65),
        Vector(-1073,1632,65),
        Vector(-1165,1624,65),
        Vector(-1188,1535,65),
        Vector(-1209,1421,65),
        Vector(-1209,1311,65),
        Vector(-1209,1191,65),
        Vector(-1208,1083,65),
    },
    [2] = {
        Vector(151.665405, -1541.707764, 12256.031250),
        Vector(420.226440, -1714.602173, 12256.031250),
        Vector(799.508789, -1670.010254, 12256.031250),
        Vector(1129.313599, -1635.345825, 12256.031250),
        Vector(1353.610962, -1445.089600, 12256.031250),
        Vector(1426.496094, -1137.319824, 12256.031250),
        Vector(1391.172119, -872.260010, 12256.031250),
        Vector(1145.092651, -848.270447, 12256.031250),
        Vector(1076.208496, -1090.329102, 12257.031250),
        Vector(1236.268188, -1224.748169, 12257.031250),
        Vector(-107.913452, -526.219971, 12256.031250),
    }
}

local adm_spawn = twoserver and adm_spawns[2] or adm_spawns[1]

local mayor_spawns = {
    [1] = {
        Vector(652,2431,145),
    },
    [2] = {
        Vector(-1700.925171, 1013.734741, 76.031250),
    }
}

local mayor_spawn = twoserver and mayor_spawns[2] or mayor_spawns[1]

local banned_spawns = {
    [1] = {
        Vector(5489,487,-1340),
        Vector(5273, 456, -1340),
        Vector(5195, 660, -1340),
    },
    [2] = {
        Vector(-681.205994, -26.772860, 12288.031250),
        Vector(-622.271118, 177.641617, 12288.031250),
        Vector(-755.600952, 300.857300, 12288.031250),
    }
}

local banned_spawn = twoserver and banned_spawns[2] or banned_spawns[1]

TEAM_CITIZEN = rp.AddTeam("Громадянин", {
    Color = Color(20, 150, 20, 255),
    Model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl",
        "models/player/Group02/male_02.mdl",
        "models/player/Group02/male_04.mdl",
        "models/player/Group02/male_06.mdl",
        "models/player/Group02/male_08.mdl"
    },
    Description = [[Громадянин - базовий суспільний прошарок, яким ви можете безперешкодно стати.
   У вас немає наперед визначеної ролі в житті міста.
    Ви можете придумати собі свою власну професію і займатися вашою справою.]],
    Weapons = {'keys'},
    Command = "citizen",
    Max = 0,
    category = "Громадяни",
    Umbrella = true,
    Salary = 75,
    canDemote = false
})

TEAM_BITMINER = rp.AddTeam("Бітмайнер", {
   Color = Color(255, 215, 0, 255),
   Model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl",
        "models/player/Group02/male_02.mdl",
        "models/player/Group02/male_04.mdl",
        "models/player/Group02/male_06.mdl",
        "models/player/Group02/male_08.mdl"
    },
   Description = [[Бітмайнер - купуй обладнання, майни біткойни і ставай мільйонером.]],
   Weapons = {'keys'},
   Command = "bitminer",
   Max = 5,
   Salary = 75,
   admin = 0,
   vote = false,
   category = "Громадяни",
   hasLicense = false,
   candemote = true,
})

TEAM_PARKYR = rp.AddTeam("Паркурист", {
    Color = Color(180, 180, 20, 255),
    Model = {
        "models/player/soldier_stripped.mdl"
    },
    Description = [[Паркурист - ви повинні досліджувати місто і не попастися поліції.]],
    Weapons = {"climb_swep2"},
    Command = "parkyr",
    Max = 0,
    category = "Кримінал",
    Salary = 150,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false
})

TEAM_COOK = rp.AddTeam("Кухар", {
    Color = Color(226, 114, 123, 255),
    Model = {"models/player/mossman.mdl"},
    Description = [[Людина, професія якої є приготування їжі.]],
    Weapons = { },
    Command = "kitchener",
    Max = 5,
    Salary = 145,
    category = "Бізнес",
})

TEAM_VENI1 = rp.AddTeam("Військовий [Рядовий]", {
   Color = Color(100, 183, 183, 255),
   Model = {
    "models/player/afu_security_heavy.mdl",
   },
   Description = [[Ви є військовим. До ваших обов'язків входить служба у військових частинах та установах
        Збройних сил, виконання військового обов'язку.
        Ця служба не просто професія, а ваше покликання.
        Суспільство та держава повністю сподіваються на вашу допомогу.
        Ви зобов'язані виконувати будь-які накази (які не порушують правила сервера)
        Вам заборонено залишати військову базу без наказу Генерала.
        Вам дозволяється вирушати в патруль по 2 людини.
        Ви можете допомагати поліції.
        Ви підкоряєтеся тільки Генералу. (Старшому за званням призначеному генералом)]],
   Weapons = {"m9k_colt1911", "stunstick", "door_ram", "weaponchecker", "unarrest_stick", "m9k_ak47"},
   Command = "voenniy",
   Max = 0,
   Salary = 950,
   License = true,
   category = "Військові",
   admin = 0,
   Spawn = mil_spawn,
   vote = false,
   hasLicense = false,
   candemote = true,
})

TEAM_VENI2 = rp.AddTeam("Військовий [Снайпер]", {
    Color = Color(100, 183, 183, 255),
    Model = {
     "models/player/afu_security_heavy.mdl",
    },
    Description = [[Ви є військовим. До ваших обов'язків входить служба у військових частинах та установах
         Збройних сил, виконання військового обов'язку.
         Ця служба не просто професія, а ваше покликання.
         Суспільство та держава повністю сподіваються на вашу допомогу.
         Ви зобов'язані виконувати будь-які накази (які не порушують правила сервера)
         Вам заборонено залишати військову базу без наказу Генерала.
         Вам дозволяється вирушати в патруль по 2 людини.
         Ви можете допомагати поліції.
         Ви підкоряєтеся тільки Генералу. (Старшому за званням призначеному генералом)]],
    Weapons = {"m9k_colt1911", "stunstick", "door_ram", "weaponchecker", "unarrest_stick", "m9k_svt40"},
    Command = "voenniysniper",
    Max = 0,
    Salary = 950,
    License = true,
    category = "Військові",
    admin = 0,
    Spawn = mil_spawn,
    vote = false,
    hasLicense = false,
    candemote = true,
})

TEAM_VENI = rp.AddTeam("Військовий [Генерал]", {
   Color = Color(100, 183, 183, 255),
   Model = {
    "models/player/afu_security_light.mdl",
   },
   Description = [[Ви є безпосереднім командувачем усієї армії.
        Вашим основним завданням є захист і утримання території,
        а також людських і матеріальних ресурсів.
        Ваше завдання командувати цілою армією.
        Ви зобов'язані командувати іншими "Військовими".
        Ви можете підвищити будь-якого військового у званні (Не вище "Полковника").
        Ви можете допомагати поліції в пошуку військових злочинців. )]],
   Weapons = {"m9k_model500", "m9k_1897winchester", "stunstick", "door_ram", "weaponchecker", "unarrest_stick"},
   Command = "voenniy1",
   Max = 1,
   Salary = 1120,
   Spawn = mil_spawn,
   admin = 0,
   vote = false,
   category = "Військові",
   License = true,
   hasLicense = false,
   candemote = true,
})

TEAM_DRUG = rp.AddTeam("Метоварник", {
   Color = Color(183, 183, 255, 255),
   Model = {"models/player/soldier_stripped.mdl"},
   Description = [[Ви наркобарон і варите наркоту]],
   Weapons = {},
   Command = "narko",
   Max = 0,
   Salary = 90,
   admin = 0,
   vote = false,
   category = "Кримінал",
   hasLicense = false,
   candemote = true,
})

TEAM_DRUGDiller = rp.AddTeam("Наркоділер", {
   Color = Color(100, 255, 100, 255),
   Model = {"models/player/soldier_stripped.mdl"},
   Description = [[Продавай стаф і рубай бабло]],
   Weapons = {},
   Command = "TEAM_DRUG",
   Max = 0,
   Salary = 90,
   admin = 0,
   vote = false,
   category = "Кримінал",
   hasLicense = false,
   candemote = true,
})

TEAM_GROVER = rp.AddTeam("Гровер", {
    Color = Color(4, 117, 0),
    Model = {
        "models/gang_chem/gang_groove_chem.mdl"
    },
    Description = [[Гровер - вирощуй коноплю, для себе і друзів, 
        або для продажу, але пам'ятай, 
        поки не буде легалайзу від мера - будуть проблеми.]],
    Weapons = {},
    Command = "grover",
    Max = 4,
    Salary = 90,
    IsDisguse = false,
    category = "Кримінал",
    admin = 0,
    vote = false,
    hasLicense = false,
    customCheck = function(ply) return ply:IsVIP() end,
})

----
TEAM_RADIO = rp.AddTeam("Радіоведучий", {
   Color = Color(183, 50, 183, 255),
   Model = {"models/player/p2_chell.mdl"},
   Description = [[Ви радіоведучий і ваш обов'язок сповіщати місто забезпечуватиме ....]],
   Weapons = {},
   Command = "radio2",
   Max = 3,
   Salary = 310,
   admin = 0,
   vote = false,
   category = "Бізнес",
   hasLicense = false,
   candemote = true,
   unlimitAdvert = true
})


TEAM_POLICE = rp.AddTeam("Поліцейський", {
    Color = Color(25, 25, 170, 255),
    Model = {
    "models/kerry/detective/male_08.mdl",
    "models/kerry/detective/male_07.mdl",
    "models/kerry/detective/male_06.mdl"
    },
    Description = [[Поліцейський є захисником кожного громадянина, який живе в місті.
        У вас є влада, ви можете заарештувати злочинців і захистити невинних людей.
        Бийте їх StunStick'ом, якщо злочинці не послухалися вас.
        Battering Ram (Таран) може виламати двері будь-якого гравця, але тільки з ордером на обшук.
        Таран також може вибивати заморожені пропи гравця.]],
    Weapons = {"m9k_sig_p229r"},
    Command = "cp",
    Max = 10,
    category = "Правопорядок",
    ammo = {
        ["pistol"] = 100,
    },
    Salary = 100 * 11.45,
    admin = 0,
    vote = false,
    License = true,
    Police = true,
    Armor = 50,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function(ply) ply:SetArmor(50) ply:SetMaxArmor(50) end,
    Spawn = police_spawn,
})

TEAM_POLICE_N = rp.AddTeam("Начальник поліції", {
    Color = Color(25, 25, 170, 255),
    Model = {
    "models/kerry/detective/male_04.mdl",

    },
    Description = [[Ви начальник поліції. Під вашим керівництвом патруль.]],
    Weapons = {"m9k_sig_p229r",'m9k_1897winchester'},
    Command = "cp_n",
    Max = 1,
    category = "Правопорядок",
    ammo = {
        ["pistol"] = 100,
    },
    Salary = 100 * 13,
    admin = 0,
    vote = false,
    License = true,
    Armor = 50,
    Police = true,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function(ply) ply:SetArmor(50) ply:SetMaxArmor(50) end,
    Spawn = police_spawn,
})

TEAM_FBI = rp.AddTeam("СБУ", {
    Color = Color(0, 25, 63, 255),
    Model = {
        "models/player/ssu_security_light.mdl"
    },
    Description = [[Ви Федеральна служба безпеки!
        Ви маєте повноваження розслідувати порушення
        федерального законодавства міста та забезпечувати
        безпеку держави, країни, нації та мера.]],
    Weapons = {"m9k_deagle",'m9k_auga3'},
    Command = "fbi",
    Max = 6,
    Salary = 550,
    IsDisguse = true,
    category = "Правопорядок",
    ammo = {
        ["pistol"] = 100,
    },
    admin = 0,
    vote = false,
    License = true,
    Police = true,
    Armor = 100,
    hasLicense = true,
    nocuff = true,
    vip = true,
    Spawn = police_spawn,
})

TEAM_MAYOR = rp.AddTeam("Мер", {
    Color = Color(150, 20, 20, 255),
    Model = {
    "models/player/breen.mdl",
    "models/player/mossman_arctic.mdl"
    },
    Description = [[Мер міста створює закони, щоб покращити життя людей у місті.
        Під час Комендантської години всі люди повинні бути в своїх будинках,
        а поліцейські мають патрулювати місто.]],
    Weapons = {},
    Command = "mayor",
    Max = 1,
    category = "Правопорядок",
    Salary = 100 * 21.89,
    admin = 0,
    vote = true,
    License = true,
    hasLicense = true,
    mayor = true,
    Spawn = mayor_spawn,
    notVIP = true,
    nocuff = true,
    customCheck = function(ply)
        net.Start('VOTING_Confirm')
        net.Send(ply)
        return false
    end,
})

TEAM_GANG = rp.AddTeam("Мафія", {
    Color = Color(75, 75, 75, 255),
    Model = {
        "models/player/group03/female_01.mdl",
        "models/player/group03/female_02.mdl",
        "models/player/group03/female_03.mdl",
        "models/player/group03/female_04.mdl",
        "models/player/group03/female_06.mdl",
        "models/player/group03/male_01.mdl",
        "models/player/group03/male_02.mdl",
        "models/player/group03/male_03.mdl",
        "models/player/group03/male_04.mdl",
        "models/player/group03/male_05.mdl",
        "models/player/group03/male_06.mdl",
        "models/player/group03/male_07.mdl",
        "models/player/group03/male_08.mdl",
        "models/player/group03/male_09.mdl"
    },
    Description = [[Найнижча каста в кримінальному світі.
        Мафія зазвичай працює на главу мафії, який заправляє всіма справами.
        Крадіть, вбивайте на замовлення і дотримуйтесь агенди від боса, або ви, можливо, будете покарані.]],
    Weapons = {},
    Command = "gangster",
    category = "Кримінал",
    Max = 16,
    Salary = 45,
    admin = 0,
    vote = false,
})

TEAM_GANGVIP = rp.AddTeam("VIP Мафія", {
    Color = Color(75, 75, 75, 255),
    Model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl"
    },
    Description = [[Найнижча каста в Кримінальному світі.
        Бандит зазвичай працює на голову банди, який заправляє всіма справами.
        Крадіть, вбивайте на замовлення і дотримуйтесь агенди від боса, або ви, можливо, будете покарані.]],
    Weapons = {"m9k_ump45", "weapon_eginventory_checker", "moneychecker"},
    Command = "gangstervip",
    category = "Віп роботи",
    Max = 6,
    Salary = 45,
    admin = 0,
    vote = false,
    customCheck = function(ply) return ply:IsVIP() end,
})

TEAM_MANIAK = rp.AddTeam("Маніяк", {
    Color = Color(200, 75, 75, 255),
    Model = {
        "models/player/hostage/hostage_04.mdl"
    },
    Description = [[Ви маніяк! Вбивайте людей у безлюдних місцях! Ви можете використовувати тільки ніж!]],
    Weapons = {"swb_knife", "weapon_cuff_rope"},
    Command = "maniak",
    category = "Віп роботи",
    Max = 3,
    IsDisguse = true,
    Salary = 0,
    admin = 0,
    vote = false,
    customCheck = function(ply) return ply:IsVIP() end,
})

TEAM_GLCRIME = rp.AddTeam("Глава мафії", {
    Color = Color(0, 100, 255, 255),
    Model = {"models/player/gman_high.mdl"},
    Description = [[Ви провідний учасник усього
    приступного світу! Удачі! ]],
    Weapons = {"unarrest_stick", "lockpick"},
    Command = "glavamafiii",
    category = "Кримінал",
    Max = 1,
    Salary = 180,
    admin = 0,
    vote = false
})


TEAM_THIEFF = rp.AddTeam("Злодій", {
    Color = Color(135, 0, 200, 255),
    Model = {
        "models/player/Group01/female_02.mdl",
        "models/player/Group01/female_04.mdl",
        "models/player/Group01/female_01.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/male_05.mdl",
        "models/player/Group01/male_07.mdl",
        "models/player/Group02/male_04.mdl",
        "models/player/Group02/male_06.mdl",
        "models/player/Group02/male_02.mdl",
        "models/player/Group02/male_08.mdl"
    },
    Description = [[
    Ви дуже вправний ведмежатник з дитинства відчували потяг до цього ремесла,
    тепер ця робота - спосіб прогодувати себе, ви можете вступити в будь-яку банду і нажити на всьому цьому великі гроші,
    хапай в руку монтування і відмички і в дорогу.]],
    Weapons = {"lockpick"},
    Command = "thieff",
    category = "Кримінал",
    Max = 4,
    Salary = 50,
})


TEAM_THIEFF_VIP = rp.AddTeam("Кишеньковий злодій", {
    Color = Color(135, 0, 200, 255),
    Model = {

            "models/player/guerilla.mdl"
    },
    Description = [[Ваше завдання стати мільйонером. У вас є можливість грабувати людей! Дій!]],
    Weapons = {"lockpick", "base_keypadcracker",'swb_p228','grabej'},
    Command = "thieffvip",
    category = "Кримінал",
    Max = 4,
    Salary = 0,
    customCheck = function(ply)
        return ply:IsVIP()
    end
})

TEAM_KILL = rp.AddTeam("Найманий вбивця", {
    Color = Color(25, 25, 25, 255),
    Model = {"models/player/phoenix.mdl"},
    Description = [[Вас можуть найняти в банду або
    робити замовлення на вбивство.]],
    Weapons = {"m9k_m24"},
    Command = "hitmankill",
    IsDisguse = true,
    category = "Віп роботи",
    Max = 4,
    Salary = 0,
    hitman = true,
    customCheck = function(ply) return ply:IsVIP() end,
})

TEAM_GUN = rp.AddTeam("Продавець зброї", {
    Color = Color(255, 140, 0, 255),
    Model = {
            "models/player/monk.mdl",
            "models/player/alyx.mdl"
    },
    Description = [[
        Продавець зброї є єдиною людиною, яка може легально продавати зброю іншим людям.
       Переконайтеся в тому, що ви не продаєте
        нелегальні види озброєння у відкриту,
        інакше вас можуть заарештувати!]],
    Weapons = {},
    Command = "gundealer",
    category = "Бізнес",
    Max = 4,
    Salary = 589,
    admin = 0,
    vote = false,
})

TEAM_BANK = rp.AddTeam("Банкір", {
    Color = Color(79, 121, 66, 255),
    Model = {
        "models/player/hostage/hostage_01.mdl",
        "models/player/hostage/hostage_02.mdl",
        "models/player/hostage/hostage_03.mdl",
        "models/player/magnusson.mdl"
    },
    Description = [[
        Банкір може побудувати свій банк і приймати вклади інших людей.
        Врахуйте, що вам доведеться постійно зміцнювати захист свого Бізнесу, інакше вас можуть
        пограбувати і ваш банк втратить довіру гравців.]],
    Weapons = {},
    Command = "banker",
    category = "Бізнес",
    Max = 2,
    Salary = 879,
    admin = 0,
    vote = false
})

TEAM_DARKGUN = rp.AddTeam("Контрабандист", {
    Color = Color(25, 25, 25, 255),
    Model = {"models/player/monk.mdl"},
    Description = [[
    Продає нелегальну зброю.
    Може вступати в банди.
    ]],
    Weapons = {},
    Command = "darkgundealer",
    category = "Віп роботи",
    Max = 4,
    Salary = 120,
    customCheck = function(ply) return ply:IsVIP() end,
})

TEAM_SECURITY = rp.AddTeam("Охоронник", {
    Color = Color(0, 140, 255, 255),
    Model = {"models/player/odessa.mdl"},
    Description = [[Наймайтеся в охорону магазину, банку або охоронцем.
        Ви маєте захищати заклад від хуліганів і дрібних злодіїв.
        У разі складної ситуації викликайте поліцію.
        За замовчуванням вам дається Stunstick,
        тож не ризикуйте особливо, дійте обережно.]],
    Weapons = {"stun_baton"},
    Command = "security",
    category = "Інші",
    Max = 6,
    Salary = 389,
    admin = 0,
    vote = false,
})

TEAM_MEDIC = rp.AddTeam("Лікар", {
    Color = Color(47, 79, 79, 255),
    Model = {
    -- Мужчины
        "models/player/Group03m/male_01.mdl",
        "models/player/Group03m/male_02.mdl",
        "models/player/Group03m/male_03.mdl",
        "models/player/Group03m/male_04.mdl",
        "models/player/Group03m/male_05.mdl",
        "models/player/Group03m/male_06.mdl",
        "models/player/Group03m/male_07.mdl",
        "models/player/Group03m/male_08.mdl",
        "models/player/Group03m/male_09.mdl",
    -- Женщины
        "models/player/Group03m/female_01.mdl",
        "models/player/Group03m/female_02.mdl",
        "models/player/Group03m/female_03.mdl",
        "models/player/Group03m/female_04.mdl",
        "models/player/Group03m/female_05.mdl",
        "models/player/Group03m/female_06.mdl"
    },
    Description = [[Лікар здатний зцілювати гравців за допомогою своїх медичних знань.
        Використовуйте аптечку щоб лікувати себе або інших,
        або продавайте аптечки покупцям.]],
    Weapons = {"weapon_medkit"},
    Command = "medic",
    category = "Місцеві служби",
    Max = 4,
    Salary = 240,
    admin = 0,
    vote = false,
    medic = true,
})

TEAM_HOBO = rp.AddTeam("Безхатченко", {
    Color = Color(80, 45, 0, 255),
    Model = {"models/player/corpse1.mdl"},
    Description = [[Бездомний перебуває в самому низу суспільного ладу. Над ним усі сміються.
        У вас немає дому.
        Ви змушені просити їжу і гроші.
        Порпайтеся в сміттєвих баках для того щоб знайти корисні вам речі.
        Побудуйте будинок із дощечок і сміття, щоб сховатися від холоду.
        Ви можете поставити відро і написати на ньому прохання, щоб вам подавали грошей.
        Проявіть фантазію, влаштуйте циркову виставу, заспівайте. Таким чином ви можете отримати більше грошей.]],
    Weapons = {"weapon_bugbait","weapon_hl2brokenbottle"},
    Command = "hobo",
    category = "Інші",
    Max = 0,
    Salary = 0,
    admin = 0,
    vote = false,
    candemote = false,
    hobo = true,
    noAdvert = true
})
 TEAM_BA_OWNER = rp.AddTeam("Тваринник", {
   Color =  Color(235,157,10, 255),
   Model = {"models/player/odessa.mdl"},
   Description = [[
    Працівник тваринницької ферми.
    Вирощуйте будь-що - від маленького краба до великого лунатика!
    Годуйте їх і дбайте про них, навіть захищайте їх, якщо знадобиться!
   ]],
   Weapons = {},
   Command = "farmowner",
   Max = 3,
   Salary = 60,
   admin = 0,
   category = "Бізнес",
   vote = false,
   Armor = 100,
   hasLicense = false,
   candemote = true,
})


TEAM_BISNES = rp.AddTeam("Бізнесмен", {
    Color = Color(0, 100, 255, 255),
    Model = {"models/player/magnusson.mdl"},
    Description = [[Найкреативніша професія в його силах
    зробити з нічого щось, що приносить йому гроші, наприклад
    ( ви можете скупити всі двері в будинку і продавати квартирки )
    все залежить лише від вас і від ваших уявлень.]],
    Weapons = {},
    Command = "bisnes",
    category = "Бізнес",
    Max = 3,
    Salary = 620,
    admin = 0,
    vote = false
})

TEAM_NAIM = rp.AddTeam("Найманець", {
    Color = Color(228, 64, 64, 255),
    Model = {"models/player/phoenix.mdl"},
    Description = [[Ви працюєте тільки за гроші не важливо на кого ви зробите все що завгодно
    для вашого замовника ви можете викрасти міра,
    зламати за гроші чийсь будинок, вкрасти речі для замовника.
    удачі в нелегкій праці.]],
    Weapons = {},
    Command = "naim",
    category = "Кримінал",
    Max = 4,
    Salary = 0,
    admin = 0,
    hitman = true,
    vote = false,
})

TEAM_ADMIN = rp.AddTeam("Адміністратор", {
   Color = Color(219, 0, 0, 255),
   Model = {"models/vedatys/orangutan.mdl"},
   Description = [[NON RP]],
   Weapons = {"skeypad_checker",'gas_log_scanner'},
   Command = "admin",
   Spawn = adm_spawn,
   Max = 0,
   Salary = 450,
   IsDisguse = true,
   admin = 0,
   category = "Адміністрація",
   vote = false,
   Hunger = false,
   hasLicense = false,
   nocuff = true,
   PlayerLoadout = function(ply) ply:SetHealth(500) ply:ConCommand('adminmode') end,
   canDemote = false,
   customCheck = function(ply) return ply:IsModerator() end,
})

TEAM_BANNED = rp.AddTeam("Заблокований", {
   Color = Color(219, 0, 0, 255),
   Model = {'models/player/charple.mdl',},
   Description = [[NON RP]],
   Weapons = {},
   Command = "banned124",
   Spawn = banned_spawn,
   Max = 0,
   Salary = 0,
   IsDisguse = true,
   category = "Заблокований",
   vote = false,
   hasLicense = false,
   canDemote = false,
   customCheck = function(pl) return pl:IsBanned() end,
})

rp.CreateDoorGroup('Військові',TEAM_VENI,TEAM_VENI1, TEAM_VENI2)
rp.CreateDoorGroup('Держава', TEAM_MAYOR, TEAM_FBI, TEAM_POLICE, TEAM_POLICE_N)
rp.CreateDoorGroup('Банк', TEAM_BANK)

hook.Run('LoadingJobs')
--PATH gamemodes/darkrp/gamemode/core/player/player/player_sh.lua:
function PLAYER:GetTeamTable()
	return rp.Team[self:Team()] or {}
end

function PLAYER:CanAfford( amount )
	if not amount then return false end
	return math.floor( amount ) >= 0 and self:GetMoney() - math.floor( amount ) >= 0
end

PLAYER.canAfford = PLAYER.CanAfford
PLAYER.SteamName = PLAYER.SteamName or PLAYER.Name
function PLAYER:Name()
	return IsValid( self ) and ( self:onyx_GetNetVar( 'Name' ) or self:SteamName() ) or 'NONE'
end

PLAYER.GetRPName = PLAYER.Name
PLAYER.Nick = PLAYER.Name
PLAYER.GetName = PLAYER.Name
function PLAYER:GetMoney()
	return IsValid( self ) and self:onyx_GetNetVar( 'Money' ) or 0
end

function PLAYER:GetSalary()
	if not IsValid( self ) or not rp.Team[self:Team()] then return 0 end
	local sal = rp.Team[self:Team()].Salary or 0
	return sal
end

function PLAYER:IsWanted()
	return IsValid( self ) and self:onyx_GetNetVar( 'Wanted' ) or false
end

function PLAYER:WantedReson()
	return IsValid( self ) and self:onyx_GetNetVar( 'WantedReson' ) or ''
end

function JobCategoryС( team )
	for _, v in pairs( rp.Team ) do
		if v.team == team then return v end
	end
end

function PLAYER:JobCat()
	return JobCategoryС( self:Team() ).category
end

rp.category_jobs = {}
function rp.JobCategory()
	for _, v in pairs( rp.Team ) do
		if not table.HasValue( rp.category_jobs, v.category ) then table.insert( rp.category_jobs, v.category ) end
	end
	return rp.category_jobs
end

---------------------------------------------
function PLAYER:GetJob()
	return IsValid( self ) and ( self:onyx_GetNetVar( 'Job' ) or rp.Team[self:Team()] and rp.Team[self:Team()].name or 'Nope' ) or 'Nope'
end

function PLAYER:IsPolice()
	return IsValid( self ) and rp.Team[self:Team()].Police or false
end

function PLAYER:GetJobColor()
	return IsValid( self ) and rp.Team[self:Team()] and rp.Team[self:Team()].Color or color_white
end

function PLAYER:GetJobModel()
	return IsValid( self ) and ( rp.Team[self:Team()] and rp.Team[self:Team()].Model or rp.Team[self:Team()].Model[1] ) or 'models/player/alyx.mdl'
end

function PLAYER:CanBuy( amount )
	if tonumber( self:GetMoney() ) >= tonumber( amount ) and tonumber( amount ) > 1 then
		return true
	else
		return false
	end
end

function PLAYER:IsAdminMode()
	return IsValid( self ) and self:onyx_GetNetVar( 'adminmode' ) or false
end

function GetPlayer( args )
	return player.Find( args ) or false
end
--PATH gamemodes/darkrp/gamemode/core/prop/cppi_sh.lua:
function ENTITY:IsProp()
	if IsValid( self ) then return self:GetClass() == 'prop_physics' or self:GetClass() == 'skeypad' or self:GetClass() == 'gmod_cameraprop' or self:GetClass() == 'gmod_button' or self:GetClass() == 'ent_textscreen' end
end

onyx.netvar:Register( 'PropOwnedd', {
	type = TYPE_STRING,
	public = true
} )

function ENTITY:CPPISetOwner( pl )
	if not IsValid( pl ) then return end
	self.pp_owner = pl
	self:onyx_SetNetVar( 'PropOwnedd', pl:SteamID() )
end

if CLIENT then
	function ENTITY:CPPIGetOwner()
		return player.GetBySteamID( self:onyx_GetNetVar( 'PropOwnedd' ) or 'none' )
	end

	function ENTITY:CPPIGetName()
		return self:CPPIGetOwner() and self:CPPIGetOwner():Name() or false
	end

	function ENTITY:CPPIGetSteamID()
		return self:onyx_GetNetVar( 'PropOwnedd' ) or false
	end
else
	function ENTITY:CPPIGetOwner()
		return self.pp_owner
	end

	function ENTITY:CPPIGetName()
		return self.pp_owner:Name()
	end

	function ENTITY:CPPIGetSteamID()
		return self.pp_owner:SteamID()
	end
end



function CPPIGetLimit( pl )
	if pl:GetUserGroup() == 'superadmin' then return true end
	local limit = sam.ranks.get_limit( pl:GetUserGroup(), 'props' )
	limit = limit + tonumber( util.GetPData( pl:SteamID(), 'propov', 0 ) )
	-- if pl:HasPurchase( '75propov' ) then limit = limit + 75 end
	-- if pl:HasPurchase( '50propov' ) then limit = limit + 50 end
	-- if pl:HasPurchase( '25propov' ) then limit = limit + 25 end
	-- if pl:HasPurchase( '10propov' ) then limit = limit + 10 end
	-- if pl:HasPurchase( '5propov' ) then limit = limit + 5 end
	if pl:GetCount( 'props' ) >= limit then
		rp.Notify( pl, 1, 'Вы привысили лимит пропов.', '' )
		return false
	else
		return true
	end
end

function CPPIGetProps( pl )
	return pl:GetCount( 'props' )
end

hook.Add( 'PlayerSpawnedProp', 'rp.PlayerSpawnedProp', function( pl, _, ent )
	ent:CPPISetOwner( pl )
	local phys = ent:GetPhysicsObject()
	phys:EnableMotion( false )
	phys:SetMaterial( 'Plastic_Box' )
	phys:SetMass( 1 )
	pl:AddCount( 'props', ent )
	return CPPIGetLimit( pl )
end )

hook.Add( 'PlayerSpawnedSENT', 'rp.PlayerSpawnedSENT', function( pl, ent ) ent:CPPISetOwner( pl ) end )
function ENTITY:InBox( p1, p2 )
	return self:GetPos():WithinAABox( p1, p2 )
end

-- Sight checks
if SERVER then return end
-- I try too hard
local LocalPlayer = LocalPlayer
local GetPos = ENTITY.GetPos
local EyePos = ENTITY.EyePos
local DistToSqr = VECTOR.DistToSqr
local IsLineOfSightClear = ENTITY.IsLineOfSightClear
local util_TraceLine = util.TraceLine
local GetAimVector = PLAYER.GetAimVector
local DotProduct = VECTOR.DotProduct
local FrameNumber = FrameNumber
local lp
local trace = {
	mask = -1,
	filter = {},
}

-- Check if the ent is in your line of sight, fastish
function ENTITY:InSight()
	return false
end

PLAYER.InSight = ENTITY.InSight
-- Check if the ent is in your line of sight, very slow
function ENTITY:InTrace()
	return false
end

PLAYER.InTrace = ENTITY.InTrace
-- Check if the ent is on your screen, very fast
function ENTITY:InView()
	return false
end

function ENTITY:InDistance()
	return false, math.huge
end

hook.Add( 'Think', 'VisChecks', function()
	if IsValid( LocalPlayer() ) then
		lp = LocalPlayer()
		trace.filter = LocalPlayer()
		hook.Remove( 'Think', 'VisChecks' )
		-- Check if the ent is in your line of sight, fastish
		function ENTITY:InSight()
			local frameNumber = FrameNumber()
			if self.LastInSight == frameNumber then return self.InSightResult end
			self.LastInSight = frameNumber
			if not self:IsDormant() and DistToSqr( GetPos( self ), GetPos( lp ) ) < 250000 then
				self.InSightResult = IsLineOfSightClear( lp, self )
				return self.InSightResult
			end

			self.InSightResult = false
			return self.InSightResult
		end

		PLAYER.InSight = ENTITY.InSight
		-- Check if the ent is in your line of sight, very slow
		function ENTITY:InTrace()
			local frameNumber = FrameNumber()
			if self.LastInTrace == frameNumber then return self.InTraceResult end
			self.LastInTrace = frameNumber
			trace.start = EyePos( lp )
			trace.endpos = GetPos( self )
			self.InTraceResult = util_TraceLine( trace ).Entity == self
			return self.InTraceResult
		end

		function PLAYER:InTrace()
			local frameNumber = FrameNumber()
			if self.LastInTrace == frameNumber then return self.InTraceResult end
			self.LastInTrace = frameNumber
			trace.start = EyePos( lp )
			trace.endpos = GetPos( self ) + self:OBBCenter()
			self.InTraceResult = util_TraceLine( trace ).Entity == self
			return self.InTraceResult
		end

		-- Check if the ent is on your screen, very fast
		function ENTITY:InView()
			return DotProduct( GetPos( self ) - GetPos( lp ), GetAimVector( lp ) ) > 0
		end

		function ENTITY:InDistance()
			local dist = DistToSqr( GetPos( self ), GetPos( lp ) )
			return dist < ( maxDistance or 250000 ), dist
		end
	end
end )
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/contextmenu_cl.lua:

local PANEL = {}

AccessorFunc(PANEL, "m_bHangOpen", "HangOpen")


function PANEL:Init()

	--
	-- This makes it so that when you're hovering over this panel
	-- you can `click` on the world. Your viewmodel will aim etc.
	--
	self:SetWorldClicker(true)

	self.Canvas = vgui.Create("DCategoryList", self)
	self.m_bHangOpen = false

end


function PANEL:Open()

	self:SetHangOpen(false)

	-- If the spawn menu is open, try to close it..
	if (g_SpawnMenu:IsVisible()) then
		g_SpawnMenu:Close(true)
	end

	if (self:IsVisible()) then return end

	CloseDermaMenus()

	self:MakePopup()
	self:SetVisible(true)
	self:SetKeyboardInputEnabled(false)
	self:SetMouseInputEnabled(true)

	RestoreCursorPosition()

	local bShouldShow = true;

	-- TODO: Any situation in which we shouldn't show the tool menu on the context menu?

	-- Set up the active panel..
	if (bShouldShow && IsValid(spawnmenu.ActiveControlPanel())) then

		self.OldParent = spawnmenu.ActiveControlPanel():GetParent()
		self.OldPosX, self.OldPosY = spawnmenu.ActiveControlPanel():GetPos()
		spawnmenu.ActiveControlPanel():SetParent(self)
		self.Canvas:Clear()
		self.Canvas:AddItem(spawnmenu.ActiveControlPanel())
		self.Canvas:Rebuild()
		self.Canvas:SetVisible(true)

	else

		self.Canvas:SetVisible(false)

	end

	self:InvalidateLayout(true)

end


function PANEL:Close(bSkipAnim)

	if (self:GetHangOpen()) then
		self:SetHangOpen(false)
		return
	end

	RememberCursorPosition()

	CloseDermaMenus()

	self:SetKeyboardInputEnabled(false)
	self:SetMouseInputEnabled(false)

	self:SetAlpha(255)
	self:SetVisible(false)
	self:RestoreControlPanel()

end


function PANEL:PerformLayout()

	self:SetPos(0, 0)
	self:SetSize(ScrW(), ScrH())

	self.Canvas:SetWide(311)
	self.Canvas:SetPos(ScrW() - self.Canvas:GetWide() - 50, self.y)

	if (IsValid(spawnmenu.ActiveControlPanel())) then

		spawnmenu.ActiveControlPanel():InvalidateLayout(true)

		local Tall = spawnmenu.ActiveControlPanel():GetTall() + 10
		local MaxTall = ScrH() * 0.8
		if (Tall > MaxTall) then Tall = MaxTall end

		self.Canvas:SetTall(Tall)
		self.Canvas.y = ScrH() - 50 - Tall

	end

	self.Canvas:InvalidateLayout(true)

end


function PANEL:StartKeyFocus(pPanel)

	self:SetKeyboardInputEnabled(true)
	self:SetHangOpen(true)

end


function PANEL:EndKeyFocus(pPanel)

	self:SetKeyboardInputEnabled(false)

end


function PANEL:RestoreControlPanel()

	-- Restore the active panel
	if (!spawnmenu.ActiveControlPanel()) then return end
	if (!self.OldParent) then return end

	spawnmenu.ActiveControlPanel():SetParent(self.OldParent)
	spawnmenu.ActiveControlPanel():SetPos(self.OldPosX, self.OldPosY)

	self.OldParent = nil

end

--
-- Note here: EditablePanel is important! Child panels won't be able to get
-- keyboard input if it's a DPanel or a Panel. You need to either have an EditablePanel
-- or a DFrame (which is derived from EditablePanel) as your first panel attached to the system.
--
vgui.Register("ContextMenu", PANEL, "EditablePanel")


function CreateContextMenu()

	if (IsValid(g_ContextMenu)) then
		g_ContextMenu:Remove()
		g_ContextMenu = nil
	end

	g_ContextMenu = vgui.Create("ContextMenu")
	g_ContextMenu:SetVisible(false)

	--
	-- We're blocking clicks to the world - but we don't want to
	-- so feed clicks to the proper functions..
	--
	g_ContextMenu.OnMousePressed = function(p, code)
		hook.Run("GUIMousePressed", code, gui.ScreenToVector(gui.MousePos()))
	end
	g_ContextMenu.OnMouseReleased = function(p, code)
		hook.Run("GUIMouseReleased", code, gui.ScreenToVector(gui.MousePos()))
	end

	hook.Run("ContextMenuCreated", g_ContextMenu)

end


function GM:OnContextMenuOpen()

	-- Let the gamemode decide whether we should open or not..
	if (!hook.Call("ContextMenuOpen", GAMEMODE)) then return end

	if (IsValid(g_ContextMenu) && !g_ContextMenu:IsVisible()) then
		g_ContextMenu:Open()
	end

end


function GM:OnContextMenuClose()

	if (IsValid(g_ContextMenu)) then
		g_ContextMenu:Close()
	end

end
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/controls/ropematerial_cl.lua:
--
--  ___  ___   _   _   _    __   _   ___ ___ __ __
-- |_ _|| __| / \ | \_/ |  / _| / \ | o \ o \\ V /
--  | | | _| | o || \_/ | ( |_n| o ||   /   / \ /
--  |_| |___||_n_||_| |_|  \__/|_n_||_|\\_|\\ |_|  2009
--
--

list.Set("RopeMaterials", "#ropematerial.rope",			"cable/rope")
list.Set("RopeMaterials", "#ropematerial.cable",		"cable/cable2")
list.Set("RopeMaterials", "#ropematerial.xbeam",		"cable/xbeam")
list.Set("RopeMaterials", "#ropematerial.laser",		"cable/redlaser")
list.Set("RopeMaterials", "#ropematerial.electric",		"cable/blue_elec")
list.Set("RopeMaterials", "#ropematerial.physbeam",		"cable/physbeam")
list.Set("RopeMaterials", "#ropematerial.hydra",		"cable/hydra")

local PANEL = {}

--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()

	self:SetItemWidth(0.14)
	self:SetItemHeight(0.3)
	self:SetAutoHeight(true)

	local mats = list.Get("RopeMaterials")
	for k, v in pairs(mats) do

		self:AddMaterial(k, v)

	end

end

function PANEL:Paint(w, h)

	draw.RoundedBox(4, 0, 0, w, h, Color(128, 128, 128, 255))

end


vgui.Register("RopeMaterial", PANEL, "MatSelect")
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/content_cl.lua:
local PANEL = {}

AccessorFunc(PANEL, "m_pSelectedPanel", 		"SelectedPanel")

--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()

	self:SetPaintBackground(false)

	self.CategoryTable = {}

	self.ContentNavBar = vgui.Create("ContentSidebar", self)
	self.ContentNavBar:Dock(LEFT)
	self.ContentNavBar:SetSize(190, 10)
	self.ContentNavBar:DockMargin(0, 0, 4, 0)


	self.HorizontalDivider = vgui.Create("DHorizontalDivider", self)
	self.HorizontalDivider:Dock(FILL)
	self.HorizontalDivider:SetLeftWidth(175)
	self.HorizontalDivider:SetLeftMin(175)
	self.HorizontalDivider:SetRightMin(450)

	self.HorizontalDivider:SetLeft(self.ContentNavBar)

end

function PANEL:EnableModify()
	self.ContentNavBar:EnableModify()
end

function PANEL:CallPopulateHook(HookName)

	hook.Call(HookName, GAMEMODE, self, self.ContentNavBar.Tree, self.OldSpawnlists)

end

function PANEL:SwitchPanel(panel)

	if (IsValid(self.SelectedPanel)) then
		self.SelectedPanel:SetVisible(false)
		self.SelectedPanel = nil;
	end

	self.SelectedPanel = panel

	self.SelectedPanel:Dock(FILL)
	self.SelectedPanel:SetVisible(true)
	self:InvalidateParent()

	self.HorizontalDivider:SetRight(self.SelectedPanel)

end


vgui.Register("SpawnmenuContentPanel", PANEL, "DPanel")



local function CreateContentPanel()

	local ctrl = vgui.Create("SpawnmenuContentPanel")

	ctrl:EnableModify()
	hook.Call("PopulatePropMenu", GAMEMODE)
	ctrl:CallPopulateHook("PopulateContent")

	return ctrl

end

//spawnmenu.AddCreationTab("#spawnmenu.content_tab", CreateContentPanel, "icon16/application_view_tile.png", -10)
--PATH gamemodes/darkrp/gamemode/modules/notify/cl_init.lua:
local curAdID = 1
local ads = { "Сервер знаходиться на етапі розробки можуть бути баги та помилки", "Подобається сервер? Підтримай його! Натисти F6", "Ти можеш увімкнути вид від третього лиця, натиснувши F1", "Якщо тобі потрібна допомога адміністрації, напиши в чат @ текст звернення, і тобі неодмінно допоможуть", "У нас є донат-магазин з великим асортиментом плюшок! Натисни F6, щоб відкрити його!", }
timer.Create( "srp_notifications.adverts", 180, 0, function()
	notification.AddLegacy( ads[curAdID], NOTIFY_HINT, 8 )
	curAdID = curAdID + 1
	if curAdID > #ads then curAdID = 1 end
end )

timer.Start( "srp_notifications.adverts" )
hook.Add( "PlayerIsLoaded", "srp_notifications.startNotify", function()
	timer.Simple( 15, function() notification.AddLegacy( "Тут з'являться повідомлення та корисні підказки під час гри", NOTIFY_HINT, 14.5 ) end )
	timer.Simple( 30, function() notification.AddLegacy( "Всі основні функції знаходяться в TAB-меню", NOTIFY_HINT, 14.5 ) end )
end )
--PATH addons/__main/lua/weapons/3dgear/shared.lua:
SWEP.PrintName			= "3D-Maneuver-Gear"
SWEP.Author			= "Darkfortune, OldDeath"
SWEP.Contact		= "olddeath1@gmx.net"
SWEP.Purpose		= "Swinging around and killing Titans."
SWEP.Instructions	= "Leftclick for Grappling Hook and Rightclick for dealing damage."
SWEP.Category       = "Weapons"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Base = "weapon_base"
SWEP.ViewModelFlip	= false
SWEP.Spawnable		= true
SWEP.Slot				= 2
SWEP.SlotPos			= 0
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModel			= "models/aot/c_aot_model_sword.mdl"
SWEP.WorldModel			= "models/aot/w_snk_sword.mdl"
SWEP.Icon 				= "vgui/entities/3dgear"
SWEP.AutoSwitchTo 		= true
SWEP.Weight 			= 100
SWEP.UseHands 			= true

SWEP.Secondary.Damage				= 500
SWEP.Secondary.NumShots				= -1
SWEP.Secondary.Recoil				= 0
SWEP.Secondary.ClipSize				= -1
SWEP.Secondary.DefaultClip			= -1
SWEP.Secondary.TakeAmmoPerBullet	= false
SWEP.Secondary.Automatic			= true
SWEP.Secondary.Ammo					= "none"

SWEP.WElements = {
	["3dgear"] = { type = "Model", model = "models/aot/3dgear.mdl", bone = "ValveBiped.Bip01_Pelvis", rel = "", pos = Vector(0, 0, -3), angle = Angle(90, 0, -90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["left_sword"] = { type = "Model", model = "models/aot/w_snk_sword.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(0, 2.2, 0), angle = Angle(270, 90, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


local SwingSound = Sound( "weapons/iceaxe/iceaxe_swing1.wav" )
local HitSound = Sound( "physics/flesh/flesh_impact_bullet3.wav" )
local hooksound = Sound( "aot/hookshootsound.wav" )


function SWEP:Initialize()

	nextshottime = CurTime()
	self:SetWeaponHoldType( "melee" )

	if CLIENT then

		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels

		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)

				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")
				end
			end
		end

	end

end



SWEP.AttackAnims = { "hitcenter1", "hitcenter2", "hitcenter3" }

function SWEP:Think()

	if (!self.Owner || self.Owner == NULL) then return end

	if ( self.Owner:KeyPressed( IN_ATTACK ) ) then

		self:StartAttack()

	elseif ( self.Owner:KeyDown( IN_ATTACK ) && inRange ) then

		self:UpdateAttack()

	elseif ( self.Owner:KeyReleased( IN_ATTACK ) && inRange ) then

		self:EndAttack( true )

	end

	if ( self.Owner:KeyPressed( IN_ATTACK2 ) ) then

		self:Attack2()

	end

	--[[
	if !self.Owner:OnGround() then
		if  SERVER then
			if( self.Owner:KeyDown( IN_SPEED ) ) then
				self.Owner:SetVelocity(Angle(-25,self.Owner:EyeAngles().y,0):Forward()*15)
			end
		end
	end
	if !self.Owner:OnGround() then
		if  SERVER then
			if( self.Owner:KeyDown( IN_SPEED ) ) then
				self.Owner:EmitSound(Sound( "ambient/levels/canals/dam_water_loop2.wav" ))
				else
				self.Owner:StopSound(Sound( "ambient/levels/canals/dam_water_loop2.wav" ))
			end
		end
	end]]
end



function SWEP:DoTrace( endpos )
	local trace = {}
		trace.start = self.Owner:GetShootPos()
		trace.endpos = trace.start + (self.Owner:GetAimVector() * 14096)
		if(endpos) then trace.endpos = (endpos - self.Tr.HitNormal * 7) end
		trace.filter = { self.Owner, self.Weapon }

	self.Tr = nil
	self.Tr = util.TraceLine( trace )
end

function SWEP:StartAttack()
	local gunPos = self.Owner:GetShootPos()
	local disTrace = self.Owner:GetEyeTrace()
	local hitPos = disTrace.HitPos

	if disTrace.HitSky then return end

	local x = (gunPos.x - hitPos.x)^2;
	local y = (gunPos.y - hitPos.y)^2;
	local z = (gunPos.z - hitPos.z)^2;
	local distance = math.sqrt(x + y + z);

	local distanceCvar = GetConVarNumber("aot_rope_distance")
	inRange = false
	if distance <= distanceCvar then
		inRange = true
	end

	if inRange then
		if (SERVER) then

			if (!self.Beam) then
				self.Beam = ents.Create( "aot_rope" )
					self.Beam:SetPos( self.Owner:GetShootPos() )
				self.Beam:Spawn()
			end


			self.Beam:SetParent( self.Owner )
			self.Beam:SetOwner( self.Owner )
			self.Owner:EmitSound( hooksound )
		end

		self:DoTrace()
		self.speed = 10000
		self.startTime = CurTime()
		self.endTime = CurTime() + self.speed
		self.dt = -1

		if (SERVER && self.Beam) then
			self.Beam:GetTable():SetEndPos( self.Tr.HitPos )
		end

		self:UpdateAttack()
	end

end

function SWEP:UpdateAttack()

	self.Owner:LagCompensation( true )

	if (!endpos) and self.Tr then endpos = self.Tr.HitPos end

	if not endpos and not self.Tr then return end
	if (SERVER && self.Beam) then
		self.Beam:GetTable():SetEndPos( endpos )
	end

	lastpos = endpos


			if ( self.Tr.Entity:IsValid() ) then

					endpos = self.Tr.Entity:GetPos()
					if ( SERVER ) and IsValid(self.Beam) then
					self.Beam:GetTable():SetEndPos( endpos )
					end

			end

			local vVel = (endpos - self.Owner:GetPos())
			local Distance = endpos:Distance(self.Owner:GetPos())

			local et = (self.startTime + (Distance/self.speed))
			if(self.dt != 0) then
				self.dt = (et - CurTime()) / (et - self.startTime)
			end
			if(self.dt < 0) then
				self.dt = 0
			end

			if(self.dt == 0) then
			zVel = self.Owner:GetVelocity().z
			vVel = vVel:GetNormalized()*(math.Clamp(Distance,0,7))
				if( SERVER ) then
				local gravity = GetConVarNumber("sv_Gravity")
				vVel:Add(Vector(0,0,(gravity/100)*1.5))
				if(zVel < 0) then
					vVel:Sub(Vector(0,0,zVel/100))
				end
				self.Owner:SetVelocity(vVel * 3)
				end
			end

	endpos = nil

	self.Owner:LagCompensation( false )

end

function SWEP:EndAttack( shutdownsound )

	if ( CLIENT ) then return end
	if ( !self.Beam ) then return end

	self.Beam:Remove()
	self.Beam = nil

end

function SWEP:Attack2()

end



function SWEP:Holster()

	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	self:EndAttack( false )

	return true
end

function SWEP:OnRemove()
self:Holster()
	self:EndAttack( false )
	return true
end


if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()

		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end

		if (!self.VElements) then return end

		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then

			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end

		end

		for k, name in ipairs( self.vRenderOrder ) do

			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end

			local model = v.modelEnt
			local sprite = v.spriteMaterial

			if (!v.bone) then continue end

			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )

			if (!pos) then continue end

			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end

				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end

			elseif (v.type == "Sprite" and sprite) then

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)

			elseif (v.type == "Quad" and v.draw_func) then

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end

		end

	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()

		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end

		if (!self.WElements) then return end

		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end

		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end

		for k, name in pairs( self.wRenderOrder ) do

			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end

			local pos, ang

			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end

			if (!pos) then continue end

			local model = v.modelEnt
			local sprite = v.spriteMaterial

			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end

				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end

			elseif (v.type == "Sprite" and sprite) then

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)

			elseif (v.type == "Quad" and v.draw_func) then

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end

		end

	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )

		local bone, pos, ang
		if (tab.rel and tab.rel != "") then

			local v = basetab[tab.rel]

			if (!v) then return end

			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )

			if (!pos) then return end

			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)

		else

			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end

			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end

			if (IsValid(self.Owner) and self.Owner:IsPlayer() and
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end

		end

		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then

				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end

			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite)
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then

				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)

			end
		end

	end

	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)

		if self.ViewModelBoneMods then

			if (!vm:GetBoneCount()) then return end

			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end

				loopthrough = allbones
			end
			// !! ----------- !! //

			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end

				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end

				s = s * ms
				// !! ----------- !! //

				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end

	end

	function SWEP:ResetBonePositions(vm)

		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end

	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end

		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end

		return res

	end

end



function SWEP:PrimaryAttack()

end

function SWEP:SecondaryAttack()
	self:SetNextSecondaryFire( CurTime() + 0.7 )

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	if ( !SERVER ) then return end

	local vm = self.Owner:GetViewModel()
	vm:ResetSequence( vm:LookupSequence( "idle01" ) )

	local anim = self.AttackAnims[ math.random( 1, #self.AttackAnims ) ]

	timer.Simple( 0, function()
		if ( !IsValid( self ) || !IsValid( self.Owner ) || !self.Owner:GetActiveWeapon() || self.Owner:GetActiveWeapon() != self ) then return end

		local vm = self.Owner:GetViewModel()
		vm:ResetSequence( vm:LookupSequence( anim ) )

		self:Idle()
	end )

	timer.Simple( 0.05, function()
		if ( !IsValid( self ) || !IsValid( self.Owner ) || !self.Owner:GetActiveWeapon() || self.Owner:GetActiveWeapon() != self ) then return end
		if ( anim == "hitcenter1" ) then
			self.Owner:ViewPunch( Angle( 5, 20, 0 ) )
		elseif ( anim == "hitcenter2" ) then
			self.Owner:ViewPunch( Angle( 5, -20, 0 ) )
		elseif ( anim == "hitcenter3" ) then
			self.Owner:ViewPunch( Angle( 20, 0, 0 ) )
		end
	end )

	timer.Simple( 0.2, function()
		if ( !IsValid( self ) || !IsValid( self.Owner ) || !self.Owner:GetActiveWeapon() || self.Owner:GetActiveWeapon() != self ) then return end
		if ( anim == "hitcenter1" ) then
			self.Owner:ViewPunch( Angle( 2, 10, 0 ) )
		elseif ( anim == "hitcenter2" ) then
			self.Owner:ViewPunch( Angle( 2, -10, 0 ) )
		elseif ( anim == "hitcenter3" ) then
			self.Owner:ViewPunch( Angle( 10, 0, 0 ) )
		end

	end )

		local gunPos = self.Owner:GetShootPos()
		local disTrace = self.Owner:GetEyeTrace()
		local hitPos = disTrace.HitPos

		local x = (gunPos.x - hitPos.x)^2;
		local y = (gunPos.y - hitPos.y)^2;
		local z = (gunPos.z - hitPos.z)^2;
		local distance = math.sqrt(x + y + z);

	local distanceCvar = GetConVarNumber("aot_hit_distance")
	local inRange = false
		if distance <= distanceCvar then
		inRange = true
	end

	if inRange==false then
	self.Owner:EmitSound( SwingSound )
	end

	if inRange==false then return
	end



	self.Owner:EmitSound( HitSound )
	local bullet = {}	-- Set up the shot
		bullet.Num = self.Primary.NumShots
		bullet.Src = self.Owner:GetShootPos()
		bullet.Dir = self.Owner:GetAimVector()
		bullet.Tracer = self.Primary.Tracer
		bullet.Force = self.Primary.Force
		bullet.Damage = self.Secondary.Damage
		bullet.AmmoType = self.Primary.Ammo
		self.Owner:FireBullets( bullet )
		self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		self:TakePrimaryAmmo(0)
end

function SWEP:Idle()

	local vm = self.Owner:GetViewModel()
	timer.Create( "idle" .. self:EntIndex(), vm:SequenceDuration(), 1, function()
		if not IsValid(vm) then return end
		vm:ResetSequence( vm:LookupSequence( "idle0" .. math.random( 1, 2 ) ) )
	end )

end

--PATH addons/__main/lua/weapons/abilities_vampire_cut.lua:
if SERVER then 
	AddCSLuaFile()
	--resource.AddFile( "materials/effects/vampiresplattercut.vtf" )
	--resource.AddFile( "materials/effects/vampiresplattercut.vmt" )
end

-- Todo: Add a convar to this and TTT to enable/disable sucking health while at the cap

SWEP.PrintName 			= "Vampire Abilities Cut"
SWEP.Author				= "Exho, EpicCreeper, Timebender"
SWEP.Contact			= ""
SWEP.Purpose			= ""
SWEP.Instructions		= "Left click to steal health\n Right click to give"
SWEP.Category			= "Weapons" 

SWEP.Slot				 = 0
SWEP.SlotPos			 = 2
SWEP.DrawAmmo 		   	 = false
SWEP.DrawCrosshair 		 = true

SWEP.Spawnable			 = true
SWEP.AdminSpawnable		 = true

SWEP.UseHands			= true
SWEP.ViewModelFlip		= false
SWEP.ViewModelFOV		= 54
SWEP.ViewModel = "models/timebender/weapons/hands.mdl"
SWEP.WorldModel = ""
SWEP.HoldType = "normal"

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("weapons/vampicon/abilities_vampire_cut.vtf")
end

SWEP.DrawCrosshair     	    = true
SWEP.Primary.Damage         = 0
SWEP.Primary.ClipSize       = -1
SWEP.Primary.DefaultClip    = -1
SWEP.Primary.Automatic      = true
SWEP.Primary.Ammo           = "none"
SWEP.Secondary.ClipSize     = -1
SWEP.Secondary.DefaultClip  = -1
SWEP.Secondary.Automatic    = true
SWEP.Secondary.Ammo         = "none"
SWEP.DeploySpeed            = 2

-- These are used for the delay times in between healing and giving
SWEP.Primary.Delay = 0.4
SWEP.Secondary.Delay = 0.4
SWEP.Draining = false -- Dont touch this

-- * Config * --
SWEP.VampRange = 90 -- How many units from the player's eyes that you can do the vampirism thingy
SWEP.MaxHealth = 500 -- Limit on health
SWEP.HealthRate = 10 -- How much health is taken per cycle

SWEP.prevtarget = nil
SWEP.id = 0
SWEP.freezetime = 4
SWEP.tracenum = 20

local trgt = nil
local weaponownercut = nil
local vampirisedcut = false


function SWEP:Initialize()
    self:SetWeaponHoldType(self.HoldType)
    self.Weapon:DrawShadow(false)
    return true
end

local function CanVamp( ent )
	if not IsValid(ent) then return false end
	if ent:IsPlayer() or ent:IsNPC() then
		return true
	else
		return false end
end

function SWEP:PrimaryAttack()
	self.id = self.Owner:UserID()
	weaponownercut = self.Owner
	self.Weapon:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.Secondary.Delay )

	-- Traces a line from the players shoot position to 100 units
	local pos = self.Owner:GetShootPos()
	local ang = self.Owner:GetAimVector()
	local tracedata = {}
	
	tracedata.start = pos
	tracedata.endpos = pos +( ang * self.VampRange)
	tracedata.filter = self.Owner
	local trace = {}
	
	local target
	
	local r, d, f = 13, 0, 0
	
	for i = 0, self.tracenum do
		trace[i] = util.TraceLine(tracedata)
		pos.x = self.Owner:GetShootPos().x + r * math.sin(d) * math.cos(f)
		pos.y = self.Owner:GetShootPos().y + r * math.sin(d) * math.sin(f)
		pos.z = self.Owner:GetShootPos().z + r * math.cos(d)
		d = 360 - 360 / i
		f = 360 - 360 / i
		tracedata.start = pos
		ang = self.Owner:GetAimVector()
		tracedata.endpos = pos +( ang * self.VampRange)
		tracedata.filter = self.Owner
		target = trace[i].Entity
		if target ~= nil and CanVamp(target) then
			break
		end
	end
	
	if target:IsNPC() or target:IsPlayer() then
		trgt = target
	end
	
	if (not trace.HitWorld and CanVamp(target)) then
		rnd = math.random(0, 5)
		if rnd == 0 then
			self.Owner:DoAnimationEvent(ACT_LAND)
		end
		self.Draining = true
		local selfH = self.Owner:Health()
		local targetH = target:Health()
		local amount = self.HealthRate
		if SERVER then
			local dmginfo = DamageInfo()
			dmginfo:SetDamage( amount )
			dmginfo:SetDamageType( DMG_SLASH ) 
			dmginfo:SetAttacker(self.Owner ) 
			dmginfo:SetInflictor(self)
			dmginfo:SetDamagePosition(self:GetPos())
			target:TakeDamageInfo(dmginfo)
			local muni = 0
			if( target:GetModel() == "models/jazzmcfly/wrs/wrs.mdl" ) then
				muni = -3
			end
			if target:IsValid() and !target:IsNPC() then
				target:Freeze(true)
			end
			if not self.id then return end
			if !timer.Exists( "freezeVplayercut" .. self.id ) then            --freezes annoying puffs who try to break rules
				timer.Create( "freezeVplayercut" .. self.id , self.freezetime + muni, 1, function()
					if target:IsValid() and !target:IsNPC() then 
						target:Freeze(false) 
						timer.Remove( "freezeVplayercut" .. self.id ) 
					end 
				end)
			else
				if self.prevtarget~= nil and self.prevtarget:IsValid() and !self.prevtarget:IsNPC() and self.prevtarget ~= target then 
					self.prevtarget:Freeze(false)
				end
				timer.Remove( "freezeVplayercut" .. self.id )
				timer.Create( "freezeVplayercut" .. self.id , self.freezetime + muni, 1, function()
					if target:IsValid() and !target:IsNPC() then 
						target:Freeze(false) 
						timer.Remove( "freezeVplayercut" .. self.id ) 
					end 
				end)
			end
			
			vampirisedcut = true
			
			if !timer.Exists("vampirisedcut" .. self.id) then
				timer.Create("vampirisedcut" .. self.id, 20, 1, function() vampirisedcut = false timer.Remove( "vampirisedcut" .. self.id ) end)
			else
				timer.Start("vampirisedcut" .. self.id)
			end
			self.prevtarget = target
		end
		
		if selfH < self.MaxHealth then
			
			
			-- In order to show up in dmg logs, this actually hurts the player

		
		-- Gives health to the player who held the Vampire up to the max limit
			self.Owner:SetHealth(math.Clamp(self.Owner:Health() + amount, 0,self.MaxHealth ) )
		else
			self.Owner:ChatPrint("You have reached the max amount of health!")
		end
	
	else
		self.Draining = false
	end
end

-- Does the same thing as the Primary attack except this time it allows you to give health
function SWEP:SecondaryAttack()
	self.id = self.Owner:UserID()
	self.Weapon:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.Secondary.Delay )

	-- Traces a line from the players shoot position to 100 units
	local pos = self.Owner:GetShootPos()
	local ang = self.Owner:GetAimVector()
	local tracedata = {}
	tracedata.start = pos
	tracedata.endpos = pos+( ang * self.VampRange)
	tracedata.filter = self.Owner
	local trace = util.TraceLine(tracedata)

	local target = trace.Entity
	if (not trace.HitWorld and CanVamp(target)) then
		self.Draining = true
		local selfH = self.Owner:Health()
		local targetH = target:Health()
		local amount = self.HealthRate

		if targetH < self.MaxHealth then
		-- Slightly modified from the Primary attack to give health 
			if SERVER then
				local dmginfo = DamageInfo()
				dmginfo:SetDamage( amount )
				dmginfo:SetDamageType( DMG_SLASH ) 
				dmginfo:SetAttacker(self.Owner ) 
				dmginfo:SetInflictor(self)
				dmginfo:SetDamagePosition(self:GetPos())
				self.Owner:TakeDamageInfo(dmginfo)
			end
			target:SetHealth(math.Clamp(target:Health() + amount, 0, self.MaxHealth ))
			--if target:IsValid() and !target:IsNPC() then
			--	target:Freeze(false)
			--end
		else
			self.Owner:ChatPrint("Your friend has reached the max amount of health!")
		end
	else
		self.Draining = false
	end
end


function SWEP:Reload()
	return
end

function SWEP:DrawHUD()
	if self.Draining == true then
		-- Yet another trace because the health needs to be accurate and up to date
		-- Its probably inefficient to trace this much, oh well --(T) it's ok
		local pos = self.Owner:GetShootPos()
		local ang = self.Owner:GetAimVector()
		local tracedata = {}
		tracedata.start = pos
		tracedata.endpos = pos+( ang * self.VampRange)
		tracedata.filter = self.Owner
		local trace = util.TraceLine(tracedata)
		local target = trace.Entity
	
		if (not trace.HitWorld and CanVamp(target)) then
			--local selfH = self.Owner:Health() why was this useless shoot here?
			
			local ratioH =  target:Health()/target:GetMaxHealth()
			if ratioH > 1 then --forbidding to get out of range
				ratioH = 1
			end

			-- Health bar
			local w = ScrW()
			local h = ScrH()
			local x_axis, y_axis, width, height = w*0.5-w/21, h/2.8, w/11, h/20
			draw.RoundedBox(2, x_axis, y_axis, width, height, Color(10,10,10,200))
			draw.RoundedBox(2, x_axis, y_axis, width * (ratioH), height, Color(192,57,43,200))
			draw.SimpleText(target:Health(), "Trebuchet24", w*0.5, h/2.8 + height*0.5, Color(255,255,255,255), 1, 1)
			
			-- Blood splatter stuff
			local splatter = surface.GetTextureID( "effects/vampiresplattercut" );
 
			local BoxSize = 128
			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.SetTexture( splatter )
			surface.DrawTexturedRect( x_axis - 60, y_axis - 50, BoxSize, BoxSize )
		else
			self.Draining = false
		end
	end
end


function SWEP:Equip()
   self.Weapon:SetNextPrimaryFire( CurTime() + (self.Primary.Delay * 1.5) )
   self.Weapon:SetNextSecondaryFire( CurTime() + (self.Secondary.Delay * 1.5) )
   weaponownercut = self.Owner
end

function SWEP:OnRemove()
   if CLIENT and IsValid(self.Owner) and self.Owner == LocalPlayer() and self.Owner:Alive() then
      RunConsoleCommand("lastinv")
   end
end

hook.Add( "EntityTakeDamage", "vampirenodamagecut", function( possibleOwner, dmginfo )
	if weaponownercut == nil or !weaponownercut:IsValid() or trgt == nil or !trgt:IsValid() then return end
	if possibleOwner == weaponownercut and dmginfo:GetAttacker() == trgt and vampirisedcut then
		trgt:TakeDamageInfo(dmginfo)
		dmginfo:ScaleDamage( 0.2 )
	end
end)
--PATH addons/__main/lua/weapons/ak47_beast/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("ak47_beast") -- must be the name of your swep but NO CAPITALS!
SWEP.Category				= "CSO/CF Weapons" --Category where you will find your weapons
SWEP.Author				= "Zekeou"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "AK47 Beast"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 3			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false		-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight					= 30		-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg makes for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_rif_akmp.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_rif_akmp.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "zekeou_gun_base" --the Base this weapon will work on. PLEASE RENAME THE BASE! 
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("weapons/AK_Beast/ak-1.wav")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("")		-- Sound if the weapon is silenced
SWEP.Primary.RPM			= 685			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 35		-- Size of a clip
SWEP.Primary.DefaultClip		= 105		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.2		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.2		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. 
--Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true
SWEP.CanBeSilenced		= false

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.Damage		= 34	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(7.716, -5.343, 2.039)
SWEP.IronSightsAng = Vector(1.465, 3.674, 1.042)
SWEP.SightsPos = Vector(7.716, -5.343, 2.039)
SWEP.SightsAng = Vector(1.465, 3.674, 1.042)
SWEP.RunSightsPos = Vector(0,0,0)	--These are for the angles your viewmodel will be when running
SWEP.RunSightsAng = Vector(0,0,0)	--Again, use the Swep Construction Kit

--PATH gamemodes/darkrp/entities/weapons/camera.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = Model( "models/MaxOfS2D/camera.mdl" )

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"


SWEP.PrintName	= "#GMOD_Camera"

SWEP.Slot		= 5
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true

SWEP.ShootSound = Sound( "NPC_CScanner.TakePhoto" )

if ( SERVER ) then

	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false

	--
	-- A concommand to quickly switch to the camera
	--
	concommand.Add( "gmod_camera", function( player, command, arguments )

		player:SelectWeapon( "gmod_camera" )

	end )

end

--
-- Network/Data Tables
--
function SWEP:SetupDataTables()

	self:NetworkVar( "Float", 0, "Zoom" )
	self:NetworkVar( "Float", 1, "Roll" )

	if ( SERVER ) then
		self:SetZoom( 70 )
		self:SetRoll( 0 )
	end

end

--
-- Initialize Stuff
--
function SWEP:Initialize()

	self:SetHoldType( "camera" )

end

--
-- Reload resets the FOV and Roll
--
function SWEP:Reload()

	if ( !self.Owner:KeyDown( IN_ATTACK2 ) ) then self:SetZoom( self.Owner:IsBot() && 75 || self.Owner:GetInfoNum( "fov_desired", 75 ) ) end
	self:SetRoll( 0 )

end

--
-- PrimaryAttack - make a screenshot
--
function SWEP:PrimaryAttack()

	self:DoShootEffect()

	-- If we're multiplayer this can be done totally clientside
	if ( !game.SinglePlayer() && SERVER ) then return end
	if ( CLIENT && !IsFirstTimePredicted() ) then return end

	self.Owner:ConCommand( "jpeg" )

end

--
-- SecondaryAttack - Nothing. See Tick for zooming.
--
function SWEP:SecondaryAttack()
end

--
-- Mouse 2 action
--
function SWEP:Tick()

	if ( CLIENT && self.Owner != LocalPlayer() ) then return end -- If someone is spectating a player holding this weapon, bail

	local cmd = self.Owner:GetCurrentCommand()

	if ( !cmd:KeyDown( IN_ATTACK2 ) ) then return end -- Not holding Mouse 2, bail

	self:SetZoom( math.Clamp( self:GetZoom() + cmd:GetMouseY() * 0.1, 0.1, 175 ) ) -- Handles zooming
	self:SetRoll( self:GetRoll() + cmd:GetMouseX() * 0.025 ) -- Handles rotation

end

--
-- Override players Field Of View
--
function SWEP:TranslateFOV( current_fov )

	return self:GetZoom()

end

--
-- Deploy - Allow lastinv
--
function SWEP:Deploy()

	return true

end

--
-- Set FOV to players desired FOV
--
function SWEP:Equip()

	if ( self:GetZoom() == 70 && self.Owner:IsPlayer() && !self.Owner:IsBot() ) then
		self:SetZoom( self.Owner:GetInfoNum( "fov_desired", 75 ) )
	end

end

function SWEP:ShouldDropOnDie() return false end

--
-- The effect when a weapon is fired successfully
--
function SWEP:DoShootEffect()

	self:EmitSound( self.ShootSound )
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	if ( SERVER && !game.SinglePlayer() ) then

		--
		-- Note that the flash effect is only
		-- shown to other players!
		--

		local vPos = self.Owner:GetShootPos()
		local vForward = self.Owner:GetAimVector()

		local trace = {}
		trace.start = vPos
		trace.endpos = vPos + vForward * 256
		trace.filter = self.Owner

		local tr = util.TraceLine( trace )

		local effectdata = EffectData()
		effectdata:SetOrigin( tr.HitPos )
		util.Effect( "camera_flash", effectdata, true )

	end

end

if ( SERVER ) then return end -- Only clientside lua after this line

SWEP.WepSelectIcon = surface.GetTextureID( "vgui/gmod_camera" )

-- Don't draw the weapon info on the weapon selection thing
function SWEP:DrawHUD() end
function SWEP:PrintWeaponInfo( x, y, alpha ) end

function SWEP:HUDShouldDraw( name )

	-- So we can change weapons
	if ( name == "CHudWeaponSelection" ) then return true end
	if ( name == "CHudChat" ) then return true end

	return false

end

function SWEP:FreezeMovement()

	-- Don't aim if we're holding the right mouse button
	if ( self.Owner:KeyDown( IN_ATTACK2 ) || self.Owner:KeyReleased( IN_ATTACK2 ) ) then
		return true
	end

	return false

end

function SWEP:CalcView( ply, origin, angles, fov )

	if ( self:GetRoll() != 0 ) then
		angles.Roll = self:GetRoll()
	end

	return origin, angles, fov

end

function SWEP:AdjustMouseSensitivity()

	if ( self.Owner:KeyDown( IN_ATTACK2 ) ) then return 1 end

	return self:GetZoom() / 80

end

--PATH addons/__main/lua/weapons/climb_swep2/shared.lua:
SWEP.Author              = "Fix by Pavetr"
SWEP.Contact             = ""
SWEP.Purpose             = "Паркур без бхопа"
SWEP.Instructions        = "Экзек пидр"

SWEP.Spawnable                  = true
SWEP.AdminSpawnable             = false

SWEP.ViewModel                  = "models/weapons/v_pistol.mdl"
SWEP.HoldType                   = "normal"

SWEP.Primary.ClipSize           = -1
SWEP.Primary.DefaultClip        = -1
SWEP.Primary.Automatic          = false
SWEP.Primary.Ammo               = "none"

SWEP.Secondary.ClipSize         = -1
SWEP.Secondary.DefaultClip      = -1
SWEP.Secondary.Automatic        = true
SWEP.Secondary.Ammo             = "none"


local HitPlayer = { Sound("npc/vort/foot_hit.wav"), Sound("npc/zombie/zombie_hit.wav") }
local MatList = { }
MatList[67] = "concrete"
MatList[68] = "dirt"
MatList[71] = "chainlink"
MatList[76] = "tile"
MatList[77] = "metal"
MatList[78] = "dirt"
MatList[84] = "tile"
MatList[86] = "duct"
MatList[87] = "wood"

function SWEP:DrawWorldModel() return false; end

function SWEP:Initialize()
    self:SetWeaponHoldType(self.HoldType)
    self.Weapon:DrawShadow(false)
	self.nextThink = 0
	self.Jumps = 0
    self.JumpSequence = 0
	self.EasterEgg = false
	self.Released = false
	self.MFC = "male"
	self.WallJumpTrace = nil
	self.CanWallRun = true
	self.WallRunAnim = 0
    return true
end
function SWEP:Deploy()
    self.Owner:DrawViewModel(false)
    if string.find(self.Owner:GetModel(), "female") or string.find(self.Owner:GetModel(), "alyx") or string.find(self.Owner:GetModel(), "mossman") then self.MFC = "female"
    elseif string.find(self.Owner:GetModel(), "combine") or string.find(self.Owner:GetModel(), "metro") then self.MFC = "combine"
    else self.MFC = "male" end

    self.Owner:SetNWBool("ClimbWallJump", false)
    self.Owner:SetNWBool("ClimbFalling", false)
    self.Owner:SetNWBool("ClimbWallRun", false)
    self.Released = false
    self.CanWallRun = true;		
    self.Parent = NULL;
end
function SWEP:Forget()

    if self.Grab then
        if self.Owner:GetMoveType() == MOVETYPE_NONE then self.Owner:SetMoveType(MOVETYPE_WALK) end
        self.Grab = false
        self.Parent = NULL;
    end
    return true

end
function SWEP:Think()

    if CLIENT or !IsValid(self.Owner) or !self.Owner:Alive() then return false end

    if self.Jumps != self.Owner:GetNWInt("ClimbJumps") then self.Owner:SetNWInt("ClimbJumps", self.Jumps) end
    if !self.Released and !self.Owner:KeyDown(IN_ATTACK2) then
        self.Released = true
    elseif self.Owner:OnGround() and (self.Jumps > 0 or !self.CanWallRun) or self.Owner:GetNWBool("ClimbFalling") then

        self.Jumps, self.JumpSequence = 0, 0
        self.EasterEgg = false
		self.CanWallRun = true
		self.Owner:SetNWBool("ClimbWallJump", false)
        self.Owner:SetNWBool("ClimbFalling", false)

	elseif self.Owner:GetNWBool("ClimbWallRun") and !self.Grab then
	
		local traceData = {};
		traceData.start = self.Owner:GetPos() + Vector(0, 0, 20);
		traceData.endpos = traceData.start + self.Owner:GetForward() * 70;
		traceData.filter = self.Owner;
		local trace = util.TraceLine(traceData);
		
		local vel = self.Owner:GetVelocity();
		if !self.Owner:OnGround() and trace.Hit and self.Owner:KeyDown(IN_FORWARD) and math.abs(vel:Length()) > 100 then
		
			local vel = self.Owner:GetVelocity() + self.Owner:GetForward();
			vel.z = 0;			
			if CurTime() > self.WallRunAnim then
			
				self.WallRunAnim = CurTime() + (0.2 - vel:Length() / 10000);
				self.Owner:ViewPunch(Angle(10, 0, 0));
				if trace.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
				elseif trace.MatType and MatList[trace.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end
				vel.z = -(100 + vel:Length());
				
			end
			self.Owner:SetLocalVelocity(vel);
			
		else 
			
			self.Owner:SetNWBool("ClimbWallRun", false); 
			self.CanWallRun = false;
			
		end
    elseif self.Owner:KeyDown(IN_FORWARD) then
		if self.Owner:KeyDown(IN_USE) and !self.Owner:OnGround() and self.CanWallRun and self.Jumps < GetConVarNumber("climbswep2_maxjumps") and !self.Grab then
	
			local traceData = {};
			traceData.start = self.Owner:GetPos();
			traceData.endpos = traceData.start - Vector(0, 0, GetConVarNumber("climbswep2_wallrun_minheight"));
			if !util.TraceLine(traceData).Hit then
			
				self.Owner:SetNWBool("ClimbWallRun", true);
				self.Jumps = self.Jumps + 1
				local vel = self.Owner:GetVelocity() + self.Owner:GetForward() * 100;
				vel.z = 0;
				self.Owner:SetLocalVelocity(vel);
			
			end
		end
	end

    if CurTime() < self.nextThink then return false end

    // For the lulz.
    if self.Owner:GetVelocity().z <= -900 and self.Owner:GetMoveType() == MOVETYPE_WALK then

        if !self.Owner:GetNWBool("ClimbFalling") then self.Owner:SetNWBool("ClimbFalling", true); self.Owner:SetNWBool("ClimbWallJump", false)
        elseif self.Owner:KeyDown(IN_JUMP) then

            self.nextThink = CurTime() + 2.5
            if self.MFC == "combine" then

                self.Owner:EmitSound("npc/metropolice/vo/help.wav", 125, math.random(90, 110))
                return true

            end
            self.Owner:EmitSound("vo/npc/"..self.MFC.."01/help01.wav", 125, math.random(90, 110))
            return true

        elseif !self.EasterEgg and math.random(1, 128) == 1 then

            self.EasterEgg = true
            if self.MFC == "combine" then self.Owner:EmitSound("npc/metropolice/vo/shit.wav", 100)
            else self.Owner:EmitSound("vo/npc/"..self.MFC.."01/gordead_ans19.wav", 100) end
            return true

        end

        return true

    elseif self.Owner:GetNWBool("ClimbFalling") then self.Owner:SetNWBool("ClimbFalling", false)
    end

    // Are we grabbing a ledge?
    if self.Grab then

        // Is it a prop?
		local physObj = NULL;
        if IsValid(self.Parent) then
			
			physObj = self.Parent:GetPhysicsObject();
            if physObj:IsMoveable() then 
				if math.abs(self.OldVelocity - self.Parent:GetVelocity():Length()) >= 500 then 
					return false;
				end
			end

        end
        if !self.Owner:KeyDown(IN_FORWARD) and !self.Owner:KeyDown(IN_MOVELEFT) and !self.Owner:KeyDown(IN_MOVERIGHT) then return false
        elseif self.Owner:KeyDown(IN_FORWARD) then

            if self.Owner:KeyDown(IN_JUMP) then

                self:Forget()
                self.Owner:EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
                self.Owner:ViewPunch(Angle(-7.5, 0, 0))
                self.Owner:SetLocalVelocity(self.Owner:GetAimVector() * 400)
                return true

            end
            return true

        end

        local Predict
        local Shift = 0
        if self.Owner:KeyDown(IN_SPEED) then Shift = 0.15 end
        self.nextThink = CurTime() + (0.35 - Shift)

        if self.Owner:KeyDown(IN_MOVELEFT) then Predict = -self.Owner:GetRight() * 10
        elseif self.Owner:KeyDown(IN_MOVERIGHT) then Predict = self.Owner:GetRight() * 10 end

        local tracedata = {}
        tracedata.start = self.Owner:GetShootPos() + Predict
        tracedata.endpos = tracedata.start + self.Owner:GetForward() * 40
        tracedata.filter = self.Owner
        local trLo =  util.TraceLine(tracedata)

        local tracedata = {}
        tracedata.start = self.Owner:GetShootPos() + Vector(0, 0, 15) + Predict
        tracedata.endpos = tracedata.start + self.Owner:GetForward() * self.Owner:GetShootPos():Distance(trLo.HitPos)
        tracedata.filter = self.Owner
        local trHi =  util.TraceLine(tracedata)

        if !trHi.Hit and trLo.Hit then

            self.Owner:SetPos(self.Owner:GetPos() + Predict)
			if physObj != NULL then
				self.LocalPos = self.Parent:WorldToLocal(self.Owner:GetPos());
			end
            if trLo.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
			elseif trLo.MatType and MatList[trLo.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trLo.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end

            if self.Owner:KeyDown(IN_MOVELEFT) then self.Owner:ViewPunch(Angle(0, 0, -2.5))
            else self.Owner:ViewPunch(Angle(0, 0, 2.5)) end
            return true

        end

    end

    // Wall Jumping. (In Think due to HUD Implementation)
    if self.Jumps > 0 then

        // Are we actually against a wall?
        local tracedata = { }
        local ShootPos = self.Owner:GetShootPos()
        local AimVector = self.Owner:GetAimVector()
        tracedata.start = ShootPos
        tracedata.endpos = ShootPos - AimVector*45
        tracedata.filter = self.Owner

        local trace = util.TraceLine(tracedata)

        if trace.Hit and !trace.HitSky and !self.Owner:GetNWBool("ClimbWallJump") then

            self.Owner:SetNWBool("ClimbWallJump", true)

        end

    elseif self.Owner:GetNWBool("ClimbWallJump") then self.Owner:SetNWBool("ClimbWallJump", false)
    end

    return true

end
function SWEP:ShakeEffect()
    if self.JumpSequence == 0 then
        self.Owner:ViewPunch(Angle(0, 5, 0))
    elseif self.JumpSequence == 1 then
        self.Owner:ViewPunch(Angle(0, -5, 0))
    elseif self.JumpSequence == 2 then
        self.Owner:ViewPunch(Angle(-5, 0, 0))
    end
    self.JumpSequence = self.JumpSequence < 3 and self.JumpSequence + 1 or 0
end
function SWEP:PrimaryAttack()

    if CLIENT or self.Owner:GetNWBool("ClimbWallRun") then return true end

    // We'll use this trace for determining whether we're looking at a Wall!
    local tracedata = { }
    local ShootPos = self.Owner:GetShootPos()
    local AimVector = self.Owner:GetAimVector()
    tracedata.start = ShootPos
    tracedata.endpos = ShootPos + AimVector*45
    tracedata.filter = self.Owner
    local trace = util.TraceLine(tracedata)

    // We'll have to be off the ground to start climbing!
    if self.Owner:OnGround() then

        // General Melee Functionality

        self:SetNextPrimaryFire(CurTime() + 0.4)

        if !trace.Hit or trace.HitWorld or trace.HitSky then

            self.Owner:EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75)
            return false

        end

        if IsValid(trace.Entity) then

            if !trace.Entity:IsWorld() then

                if GetConVarNumber("climbswep2_necksnaps") == 1 and (trace.Entity:IsPlayer() or trace.Entity:IsNPC()) and trace.Entity:GetAimVector():DotProduct(self.Owner:GetAimVector()) > 0.6 then

                    if trace.Entity:IsPlayer() then

                        if GetConVarNumber("sbox_playershurtplayers") <= 0 then return false end
                        trace.Entity:Kill()
                        self.Owner:AddFrags(1)
                        self.Owner:EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
                        return true

                    else

                        trace.Entity:TakeDamage(trace.Entity:Health(), self.Owner, self)
                        self.Owner:AddFrags(1)
                        self.Owner:EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
                        return true

                    end

                    return true

                elseif trace.Entity:IsPlayer() then

                    trace.Entity:ViewPunch(Angle(-25, 20, 0))
					if trace.Entity:GetActiveWeapon().Grab then trace.Entity:GetActiveWeapon().Grab = false end
					
                elseif trace.Entity:IsNPC() then
                    trace.Entity:TakeDamage(10, self.Owner, self)
                end
                if (IsValid(trace.Entity:GetPhysicsObject())) then
                    trace.Entity:GetPhysicsObject():ApplyForceOffset((trace.HitPos-self.Owner:EyePos())*128, trace.HitPos)
                end
                self.Owner:EmitSound(table.Random(HitPlayer), 80, math.random(95, 105))
                return true

            end

        end

        return false

    end

    // Are we grabbing?
    if self.Grab then

        // If so, we'll want to reset our variables!
        self:Forget()

        // Now, run up that wall!
        self.Owner:ViewPunch(Angle(-15, self.Owner:EyeAngles().yaw/32, 0))
        self.Owner:EmitSound(Sound("player/suit_sprint.wav"), 80, math.random(95, 105))
        self.Owner:SetVelocity(-self.Owner:GetVelocity() + Vector(0, 0, 250))
        self:SetNextPrimaryFire(CurTime() + 0.15)
        return true

    end

    // Wall Jumping. (Code in Think due to HUD Implementation)
    if self.Owner:GetNWBool("ClimbWallJump") then

        // We can Wall Jump!
        self.CanWallRun = true;
		self.Jumps = 0
        self.Owner:SetLocalVelocity(self.Owner:GetAimVector() * 300)
        self.Owner:EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
        self.Owner:ViewPunch(Angle(-7.5, 0, 0))
        return true

    end

    // Are we close enough to start climbing?
    if ( (self.Jumps == 0 and trace.HitPos:Distance(ShootPos) > 40) or self.Jumps > (GetConVarNumber("climbswep2_maxjumps") - 1) or trace.HitSky) then return false end

    // If we've mysteriously lost the wall we'll want to stop climbing!
    if !trace.Hit then return false end

    if self.Owner:GetVelocity().z <= -750 then

        self:SetNextPrimaryFire(CurTime() + 1)
        self.Owner:EmitSound("ambient/levels/canals/toxic_slime_sizzle4.wav", 50, 200)

        if self.MFC == "combine" then self.Owner:EmitSound("npc/metropolice/knockout2.wav", 125)
        else self.Owner:EmitSound("vo/npc/"..self.MFC.."01/ow0"..math.random(1, 2)..".wav", 125) end

        return true

    end

    // Add some effects.
    if trace.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
	elseif trace.MatType and MatList[trace.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105))
    else self.Owner:EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75, math.random(95, 105)) end

    // Climb the wall and modify our jump count.

    local Vel = self.Owner:GetVelocity()
    self.Owner:SetVelocity(Vector(0, 0, 240 - 15 * 1 + self.JumpSequence - Vel.z))
    self:SetNextPrimaryFire(CurTime() + 0.15)
    self.Jumps = self.Jumps + 1
    self:ShakeEffect()
    return true

end
function SWEP:CanGrab() -- This too, but modified it somewhat.

    // We'll detect whether we can grab onto the ledge.
    local trace = {}
    trace.start = self.Owner:GetShootPos() + Vector( 0, 0, 15 )
    trace.endpos = trace.start + self.Owner:GetAimVector() * 30
    trace.filter = self.Owner

    local trHi = util.TraceLine(trace)

    local trace = {}
    trace.start = self.Owner:GetShootPos()
    trace.endpos = trace.start + self.Owner:GetAimVector() * 30
    trace.filter = self.Owner

    local trLo = util.TraceLine(trace)

    // Is the ledge actually grabbable?
    if trLo and trHi and trLo.Hit and !trHi.Hit then
        return {true, trLo}
    else
        return {false, trLo}
    end

end
function SWEP:SecondaryAttack()

    if CLIENT then return true end

    if !self.Released then return end

    if self.Owner:OnGround() then return false end // We don't want to grab onto a ledge if we're on the ground!

    // If we're already grabbing something, we want to let go!
    if self.Grab then
        self:Forget()
        self.Released = false
        return false
    end

    // Returns whether we can grab(boolean) and a traceres.
    local Grab = self:CanGrab()

    // If we can't grab we're done here.
    if !Grab[1] then 
        return false 
    end

    // Otherwise reset our jumps and enter ledge holding mode!
    self.Jumps = 0
    self.Grab  = true
    self.Released = false
    local VelZ = self.Owner:GetVelocity().z;
	self.Owner:ViewPunch(Angle(math.max(15, math.min(30, VelZ)) * (VelZ > 0 and 1 or -1), 0, 0));
    self.Owner:SetLocalVelocity(Vector(0, 0, 0))
    self.Owner:SetMoveType(MOVETYPE_NONE)
    self.Owner:EmitSound(Sound("physics/flesh/flesh_impact_hard"..math.random(1, 3)..".wav"), 75)
	
    // Are we looking at a valid entity?
    if IsValid(Grab[2].Entity) then

        // Does the prop/entity use valid prop-like behaviour?
        if Grab[2].Entity:GetMoveType() == MOVETYPE_VPHYSICS then

            // Then we can grab onto it!
            self.OldVelocity      = Grab[2].Entity:GetVelocity():Length()
            self.Parent           = Grab[2].Entity
            self.LocalPos      	= Grab[2].Entity:WorldToLocal(self.Owner:GetPos())
        end

    end

    local ClimbSwep = self
	local Ply = self.Owner;
    local Forget = function()
        --self:Forget();
		hook.Remove("Think", "ClimbGrab"..Ply:UniqueID())
    end
    local IsOneHanded = function()

        if !IsValid(Ply:GetActiveWeapon()) then return false end

        local Weps = {climb_swep2 = true, weapon_pistol = true, weapon_357 = true, weapon_crowbar = true, weapon_frag = true}
        local HoldTypes = {pistol = true, grenade = true, knife = true}
        local Wep = Ply:GetActiveWeapon()
        if Weps[Wep:GetClass()] then return true
        elseif HoldTypes[Wep.HoldType] then return true end
        return false

    end


    local ThinkFunction = function()
       

    end
    --hook.Add("Think", "ClimbGrab"..Ply:UniqueID(), ThinkFunction)
    return true

end
function SWEP:DrawHUD()

    if SERVER or GetConVarNumber("climbswep2_showhud") == 0 then return false end

    /*
        We can't make use of the variables the SERVER has indexed.
        Instead we'll make use of Networked Variables, available to both
        the CLIENT and the SERVER.
    */

    local Jumps, MaxJumps = LocalPlayer():GetNWInt("ClimbJumps"), GetConVarNumber("climbswep2_maxjumps")
    local Width, Height = 256, 18


    // Draw Jump-Monitor
    draw.RoundedBox(4, ScrW() * 0.5 - Width * 0.5, ScrH() - Height * 2, Width, Height, Color(51, 181, 229, 122))
    if (MaxJumps - Jumps) > 0 then draw.RoundedBox(4, ScrW() * 0.5 - Width * 0.5, ScrH() - Height * 2, Width * (MaxJumps - Jumps) / MaxJumps, Height, Color(51, 181, 229, 255)) end
    draw.DrawText("Jumps: "..(MaxJumps - Jumps).." of "..GetConVarNumber("climbswep2_maxjumps"), "Default", ScrW() * 0.5, ScrH() - 33, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)

    // Draw Custom HUD Icons
    if LocalPlayer():GetNWBool("ClimbWallJump") then

        surface.SetDrawColor(Color(51, 181, 229, 255))
        surface.DrawRect(ScrW() * 0.5 - 8, ScrH() - Height * 2 - 36, 8, 32)
        surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
        surface.DrawTexturedRectRotated(ScrW() * 0.5 + 9, ScrH() - Height * 2 - 22, 30, 30, -60)
        surface.SetDrawColor(Color(255, 255, 255, 255))

    elseif LocalPlayer():GetNWBool("ClimbFalling") then

        surface.SetDrawColor(Color(51, 181, 229, 255))
        surface.DrawRect(ScrW() * 0.5 - 16, ScrH() - Height * 2 - 12, 32, 8)
        surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
        surface.DrawTexturedRectRotated(ScrW() * 0.5, ScrH() - Height * 2 - 28, 30, 30, 180)
        surface.SetDrawColor(Color(255, 255, 255, 255))

    end

end
--PATH addons/__main_only_1st/lua/weapons/death_note/shared.lua:
--[[*******************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
*******************************************************]]
AddCSLuaFile( "cl_init.lua" )
AddCSLuaFile( "init.lua" )
function SWEP:Initialize()
	-- other initialize code goes here
	self:SetWeaponHoldType( self.HoldType )
	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:CreateModels( self.VElements ) -- create viewmodels
		self:CreateModels( self.WElements ) -- create worldmodels
		-- init view model bone build function
		if IsValid( self:GetOwner() ) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid( vm ) then
				self:ResetBonePositions( vm )
				-- Init viewmodel visibility
				if self.ShowViewModel == nil or self.ShowViewModel then
					vm:SetColor( Color( 255, 255, 255, 255 ) )
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor( Color( 255, 255, 255, 1 ) )
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial( "Debug/hsv" )
				end
			end
		end
	end
end

function SWEP:Holster()
	if CLIENT and IsValid( self:GetOwner() ) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid( vm ) then self:ResetBonePositions( vm ) end
	end
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid( vm ) then return end
		if not self.VElements then return end
		self:UpdateBonePositions( vm )
		if not self.vRenderOrder then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if v.type == "Model" then
					table.insert( self.vRenderOrder, 1, k )
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert( self.vRenderOrder, k )
				end
			end
		end

		for _, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if not v then
				self.vRenderOrder = nil
				break
			end

			if v.hide then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if not v.bone then continue end
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			if not pos then continue end
			if v.type == "Model" and IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.material == "" then
					model:SetMaterial( "" )
				elseif model:GetMaterial() ~= v.material then
					model:SetMaterial( v.material )
				end

				if v.skin and v.skin ~= model:GetSkin() then model:SetSkin( v.skin ) end
				if v.bodygroup then
					for k, v in pairs( v.bodygroup ) do
						if model:GetBodygroup( k ) ~= v then model:SetBodygroup( k, v ) end
					end
				end

				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			elseif v.type == "Sprite" and sprite then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial( sprite )
				render.DrawSprite( drawpos, v.size.x, v.size.y, v.color )
			elseif v.type == "Quad" and v.draw_func then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				cam.Start3D2D( drawpos, ang, v.size )
				v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if self.ShowWorldModel == nil or self.ShowWorldModel then self:DrawModel() end
		if not self.WElements then return end
		if not self.wRenderOrder then
			self.wRenderOrder = {}
			for k, v in pairs( self.WElements ) do
				if v.type == "Model" then
					table.insert( self.wRenderOrder, 1, k )
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert( self.wRenderOrder, k )
				end
			end
		end

		if IsValid( self:GetOwner() ) then
			bone_ent = self:GetOwner()
		else
			-- when the weapon is dropped
			bone_ent = self
		end

		for _, name in pairs( self.wRenderOrder ) do
			local v = self.WElements[name]
			if not v then
				self.wRenderOrder = nil
				break
			end

			if v.hide then continue end
			local pos, ang
			if v.bone then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end

			if not pos then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if v.type == "Model" and IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.material == "" then
					model:SetMaterial( "" )
				elseif model:GetMaterial() ~= v.material then
					model:SetMaterial( v.material )
				end

				if v.skin and v.skin ~= model:GetSkin() then model:SetSkin( v.skin ) end
				if v.bodygroup then
					for k, v in pairs( v.bodygroup ) do
						if model:GetBodygroup( k ) ~= v then model:SetBodygroup( k, v ) end
					end
				end

				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			elseif v.type == "Sprite" and sprite then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial( sprite )
				render.DrawSprite( drawpos, v.size.x, v.size.y, v.color )
			elseif v.type == "Quad" and v.draw_func then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				cam.Start3D2D( drawpos, ang, v.size )
				v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		local bone, pos, ang
		if tab.rel and tab.rel ~= "" then
			local v = basetab[tab.rel]
			if not v then return end
			-- Technically, if there exists an element with the same name as a bone
			-- you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			if not pos then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis( ang:Up(), v.angle.y )
			ang:RotateAroundAxis( ang:Right(), v.angle.p )
			ang:RotateAroundAxis( ang:Forward(), v.angle.r )
		else
			bone = ent:LookupBone( bone_override or tab.bone )
			if not bone then return end
			pos, ang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
			local m = ent:GetBoneMatrix( bone )
			if m then pos, ang = m:GetTranslation(), m:GetAngles() end
			if IsValid( self:GetOwner() ) and self:GetOwner():IsPlayer() and ent == self:GetOwner():GetViewModel() and self.ViewModelFlip then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if not tab then return end
		-- Create the clientside models here because Garry says we can't do it in the render hook
		for _, v in pairs( tab ) do
			if v.type == "Model" and v.model and v.model ~= "" and ( not IsValid( v.modelEnt ) or v.createdModel ~= v.model ) and string.find( v.model, ".mdl" ) and file.Exists( v.model, "GAME" ) then
				v.modelEnt = ClientsideModel( v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE )
				if IsValid( v.modelEnt ) then
					v.modelEnt:SetPos( self:GetPos() )
					v.modelEnt:SetAngles( self:GetAngles() )
					v.modelEnt:SetParent( self )
					v.modelEnt:SetNoDraw( true )
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif v.type == "Sprite" and v.sprite and v.sprite ~= "" and ( not v.spriteMaterial or v.createdSprite ~= v.sprite ) and file.Exists( "materials/" .. v.sprite .. ".vmt", "GAME" ) then
				local name = v.sprite .. "-"
				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for _, j in pairs( tocheck ) do
					if v[j] then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial( name, "UnlitGeneric", params )
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false
	function SWEP:UpdateBonePositions( vm )
		if self.ViewModelBoneMods then
			if not vm:GetBoneCount() then return end
			-- !! WORKAROUND !! //
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if not hasGarryFixedBoneScalingYet then
				allbones = {}
				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName( i )
					if self.ViewModelBoneMods[bonename] then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector( 1, 1, 1 ),
							pos = Vector( 0, 0, 0 ),
							angle = Angle( 0, 0, 0 )
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! //
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone( k )
				if not bone then continue end
				-- !! WORKAROUND !! //
				local s = Vector( v.scale.x, v.scale.y, v.scale.z )
				local p = Vector( v.pos.x, v.pos.y, v.pos.z )
				local ms = Vector( 1, 1, 1 )
				if not hasGarryFixedBoneScalingYet then
					local cur = vm:GetBoneParent( bone )
					while cur >= 0 do
						local pscale = loopthrough[vm:GetBoneName( cur )].scale
						ms = ms * pscale
						cur = vm:GetBoneParent( cur )
					end
				end

				s = s * ms
				-- !! ----------- !! //
				if vm:GetManipulateBoneScale( bone ) ~= s then vm:ManipulateBoneScale( bone, s ) end
				if vm:GetManipulateBoneAngles( bone ) ~= v.angle then vm:ManipulateBoneAngles( bone, v.angle ) end
				if vm:GetManipulateBonePosition( bone ) ~= p then vm:ManipulateBonePosition( bone, p ) end
			end
		else
			self:ResetBonePositions( vm )
		end
	end

	function SWEP:ResetBonePositions( vm )
		if not vm:GetBoneCount() then return end
		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector( 1, 1, 1 ) )
			vm:ManipulateBoneAngles( i, Angle( 0, 0, 0 ) )
			vm:ManipulateBonePosition( i, Vector( 0, 0, 0 ) )
		end
	end

	--[[*************************
		Global utility code
	*************************]]
	-- Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- Does not copy entities of course, only copies their reference.
	-- WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )
		if not tab then return nil end
		local res = {}
		for k, v in pairs( tab ) do
			if type( v ) == "table" then
				res[k] = table.FullCopy( v ) -- recursion ho!
			elseif type( v ) == "Vector" then
				res[k] = Vector( v.x, v.y, v.z )
			elseif type( v ) == "Angle" then
				res[k] = Angle( v.p, v.y, v.r )
			else
				res[k] = v
			end
		end
		return res
	end
end

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/C_slam.mdl"
SWEP.WorldModel = "models/weapons/w_slam.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.UseHands = true
SWEP.ViewModelBoneMods = {
	["Slam_base"] = {
		scale = Vector( 0.009, 0.009, 0.009 ),
		pos = Vector( 0, 0, 0 ),
		angle = Angle( 0, 0, 0 )
	},
	["Detonator"] = {
		scale = Vector( 0.009, 0.009, 0.009 ),
		pos = Vector( 0, 0, 0 ),
		angle = Angle( 0, 0, 0 )
	}
}

SWEP.VElements = {
	["Deathnote Pen"] = {
		type = "Model",
		model = "models/death_note/dn_pen.mdl",
		bone = "Detonator",
		rel = "",
		pos = Vector( 9, -64, 22.6 ),
		angle = Angle( -92.338, 43.247, 0 ),
		size = Vector( 1, 1, 1 ),
		color = Color( 255, 255, 255, 255 ),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
	["Deathnote Book"] = {
		type = "Model",
		model = "models/death_note/deathnote_open1.mdl",
		bone = "Slam_base",
		rel = "",
		pos = Vector( -5.716, -67.014, 22.336 ),
		angle = Angle( -31.56, 45.583, -8.183 ),
		size = Vector( 0.5, 0.5, 0.5 ),
		color = Color( 255, 255, 255, 255 ),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["Deathnote Pen"] = {
		type = "Model",
		model = "models/death_note/dn_pen.mdl",
		bone = "ValveBiped.Bip01_L_Hand",
		rel = "",
		pos = Vector( 4, 1, 4 ),
		angle = Angle( 180, 0, 0 ),
		size = Vector( 1, 1, 1 ),
		color = Color( 255, 255, 255, 255 ),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
	["Deathnote Book"] = {
		type = "Model",
		model = "models/death_note/deathnote.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector( 3.634, 3.634, -0.519 ),
		angle = Angle( 0, 0, 180 ),
		size = Vector( 0.5, 0.5, 0.5 ),
		color = Color( 255, 255, 255, 255 ),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

-------------------------------------------
SWEP.PrintName = "Death-Note - WIP Module version"
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.Author = "Blue-Pentagram And TheRowan"
SWEP.Instructions = "Left click to kill who your looking at - Right click to open a GUI"
SWEP.Contact = "http://steamcommunity.com/workshop/filedetails/discussion/278185787/617330406650185272/"
SWEP.Purpose = "To kill or respawn anyone"
SWEP.Category = "Death Note"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
function SWEP:Reload()
end

function SWEP:Think()
end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/object.lua:
--[[---------------------------------------------------------
   Sets which stage a tool is at
-----------------------------------------------------------]]
function ToolObj:UpdateData()

	self:SetStage(self:NumObjects())

end

--[[---------------------------------------------------------
   Sets which stage a tool is at
-----------------------------------------------------------]]
function ToolObj:SetStage(i)

	if (SERVER) then
		self:GetWeapon():SetNWInt( "Stage", i )
	end

end

--[[---------------------------------------------------------
   Gets which stage a tool is at
-----------------------------------------------------------]]
function ToolObj:GetStage()
	return self:GetWeapon():GetNWInt( "Stage", 0 )
end

--[[---------------------------------------------------------
-----------------------------------------------------------]]
function ToolObj:GetOperation()
	return self:GetWeapon():GetNWInt( "Op", 0 )
end

--[[---------------------------------------------------------
-----------------------------------------------------------]]
function ToolObj:SetOperation(i)

	if (SERVER) then
		self:GetWeapon():SetNWInt( "Op", i )
	end

end

--[[---------------------------------------------------------
   ClearObjects - clear the selected objects
-----------------------------------------------------------]]
function ToolObj:ClearObjects()

	self:ReleaseGhostEntity()
	self.Objects = {}
	self:SetStage(0)
	self:SetOperation(0)

end


--[[---------------------------------------------------------
	Since we're going to be expanding this a lot I've tried
	to add accessors for all of this crap to make it harder
	for us to mess everything up.
-----------------------------------------------------------]]
function ToolObj:GetEnt(i)

	if (!self.Objects[i]) then return NULL end

	return self.Objects[i].Ent
end


--[[---------------------------------------------------------
	Returns the world position of the numbered object hit
	We store it as a local vector then convert it to world
	That way even if the object moves it's still valid
-----------------------------------------------------------]]
function ToolObj:GetPos(i)

	if (self.Objects[i].Ent:EntIndex() == 0) then
		return self.Objects[i].Pos
	else
		if (self.Objects[i].Phys ~= nil && self.Objects[i].Phys:IsValid()) then
			return self.Objects[i].Phys:LocalToWorld(self.Objects[i].Pos)
		else
			return self.Objects[i].Ent:LocalToWorld(self.Objects[i].Pos)
		end
	end

end

--[[---------------------------------------------------------
	Returns the local position of the numbered hit
-----------------------------------------------------------]]
function ToolObj:GetLocalPos(i)
	return self.Objects[i].Pos
end


--[[---------------------------------------------------------
	Returns the physics bone number of the hit (ragdolls)
-----------------------------------------------------------]]
function ToolObj:GetBone(i)
	return self.Objects[i].Bone
end

function ToolObj:GetNormal(i)
	if (self.Objects[i].Ent:EntIndex() == 0) then
		return self.Objects[i].Normal
	else
		local norm
		if (self.Objects[i].Phys ~= nil && self.Objects[i].Phys:IsValid()) then
			norm = self.Objects[i].Phys:LocalToWorld(self.Objects[i].Normal)
		else
			norm = self.Objects[i].Ent:LocalToWorld(self.Objects[i].Normal)
		end

		return norm - self:GetPos(i)
	end
end


--[[---------------------------------------------------------
	Returns the physics object for the numbered hit
-----------------------------------------------------------]]
function ToolObj:GetPhys(i)

	if (self.Objects[i].Phys == nil) then
		return self:GetEnt(i):GetPhysicsObject()
	end

	return self.Objects[i].Phys
end


--[[---------------------------------------------------------
	Sets a selected object
-----------------------------------------------------------]]
function ToolObj:SetObject(i, ent, pos, phys, bone, norm)

	self.Objects[i] = {}
	self.Objects[i].Ent = ent
	self.Objects[i].Phys = phys
	self.Objects[i].Bone = bone
	self.Objects[i].Normal = norm

	-- Worldspawn is a special case
	if (ent:EntIndex() == 0) then

		self.Objects[i].Phys = nil
		self.Objects[i].Pos = pos

	else

		norm = norm + pos

		-- Convert the position to a local position - so it's still valid when the object moves
		if (IsValid(phys)) then
			self.Objects[i].Normal = self.Objects[i].Phys:WorldToLocal(norm)
			self.Objects[i].Pos = self.Objects[i].Phys:WorldToLocal(pos)
		else
			self.Objects[i].Normal = self.Objects[i].Ent:WorldToLocal(norm)
			self.Objects[i].Pos = self.Objects[i].Ent:WorldToLocal(pos)
		end

	end

	if (SERVER) then
		-- Todo: Make sure the client got the same info
	end

end


--[[---------------------------------------------------------
	Returns the number of objects in the list
-----------------------------------------------------------]]
function ToolObj:NumObjects()

	if (CLIENT) then

		return self:GetStage()

	end

	return #self.Objects

end


--[[---------------------------------------------------------
	Returns the number of objects in the list
-----------------------------------------------------------]]
function ToolObj:GetHelpText()

	return "#tool." .. GetConVarString("gmod_toolmode") .. "." .. self:GetStage()

end
--PATH addons/____bricks_framework/lua/weapons/gmod_tool/stools/bricks_server_entityplacer.lua:
TOOL.Category = "Bricks Server"
TOOL.Name = "Entity Placer"
TOOL.Command = nil
TOOL.ConfigName = "" --Setting this means that you do not have to create external configuration files to define the layout of the tool config-hud 

function TOOL:LeftClick( trace )
	if( !trace.HitPos || IsValid( trace.Entity ) && trace.Entity:IsPlayer() ) then return false end
	if( CLIENT ) then return true end

	local ply = self:GetOwner()
	
	if( not BRICKS_SERVER.Func.HasAdminAccess( ply ) ) then
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "noToolPermission" ) )
		return
	end
	
	local entClassTable = BRICKS_SERVER.DEVCONFIG.EntityTypes[ply:GetNW2String( "bricks_server_stoolcmd_entityclass" )]
	if( entClassTable ) then
		local entity = ents.Create( ply:GetNW2String( "bricks_server_stoolcmd_entityclass" ) )
		if( !IsValid( entity ) ) then
			BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "invalidEntityType" ) )
			return
		end
		entity:SetPos( trace.HitPos )
		if( entClassTable.AngleToSurface == true ) then
			entity:SetAngles( trace.HitNormal:Angle() )
		elseif( entClassTable.AngleToPlayer == true ) then
			entity:SetAngles( Angle( entity:GetAngles().p, ply:GetAngles().y+180, entity:GetAngles().r ) )
		end
		entity:Spawn()
		
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "entityPlaced" ) )
		ply:ConCommand( "bricks_server_saveentpositions" )
	else
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "invalidEntityType" ) )
	end
end

function TOOL:RightClick( trace )
	if( !trace.HitPos ) then return false end
	if( !IsValid( trace.Entity ) or trace.Entity:IsPlayer() ) then return false end
	if( CLIENT ) then return true end

	local ply = self:GetOwner()
	
	if( not BRICKS_SERVER.Func.HasAdminAccess( ply ) ) then
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "noToolPermission" ) )
		return
	end
	
	if( BRICKS_SERVER.DEVCONFIG.EntityTypes[trace.Entity:GetClass()] ) then
		trace.Entity:Remove()
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "entityRemoved" ) )
		ply:ConCommand( "bricks_server_saveentpositions" )
	else
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "canOnlyUseToolEntity" ) )
		return false
	end
end

function TOOL:DrawToolScreen( width, height )
	if( not BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then return end

	surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
	surface.DrawRect( 0, 0, width, height )

	surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
	surface.DrawRect( 0, 0, width, 60 )
	
	draw.SimpleText( language.GetPhrase( "tool.bricks_server_entityplacer.name" ), "BRICKS_SERVER_Font33", width*0.5, 30, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	local entitySelected = BRICKS_SERVER.DEVCONFIG.EntityTypes[LocalPlayer():GetNW2String( "bricks_server_stoolcmd_entityclass", "" )]
	draw.SimpleText( BRICKS_SERVER.Func.L( "selected" ), "BRICKS_SERVER_Font33", width*0.5, 60+((height-60)*0.5)-15, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	draw.SimpleText( ((entitySelected and (entitySelected.PrintName or BRICKS_SERVER.Func.L( "error" ))) or BRICKS_SERVER.Func.L( "none" )), "BRICKS_SERVER_Font25", width*0.5, 60+((height-60)*0.5)-15, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
end

function TOOL.BuildCPanel( panel )
	panel:AddControl("Header", { Text = BRICKS_SERVER.Func.L( "entityType" ), Description = BRICKS_SERVER.Func.L( "entityPlacerDescription" ) })
 
	local combo = panel:AddControl( "ComboBox", { Label = BRICKS_SERVER.Func.L( "entityType" ) } )
	for k, v in pairs( BRICKS_SERVER.DEVCONFIG.EntityTypes ) do
		if( not istable( v ) or not v.Placeable ) then continue end

		combo:AddOption( (v.PrintName or k), { k } )
	end
	function combo:OnSelect( index, text, data )
		net.Start( "BRS.Net.ToolEntityPlacer" )
			net.WriteString( data[1] )
		net.SendToServer()
	end
end

if( CLIENT ) then
	language.Add( "tool.bricks_server_entityplacer.name", BRICKS_SERVER.Func.L( "entityPlacer" ) )
	language.Add( "tool.bricks_server_entityplacer.desc", BRICKS_SERVER.Func.L( "entityPlacerDescriptionSmall" ) )
	language.Add( "tool.bricks_server_entityplacer.0", BRICKS_SERVER.Func.L( "entityPlacerInstructions" ) )
elseif( SERVER ) then
	util.AddNetworkString( "BRS.Net.ToolEntityPlacer" )
	net.Receive( "BRS.Net.ToolEntityPlacer", function( len, ply )
		if( not BRICKS_SERVER.Func.HasAdminAccess( ply ) ) then return end

		ply:SetNW2String( "bricks_server_stoolcmd_entityclass", net.ReadString() )
	end )
end
--PATH addons/__main/lua/weapons/gmod_tool/stools/permaprops.lua:
/*
	PermaProps
	Created by Entoros, June 2010
	Facepunch: http://www.facepunch.com/member.php?u=180808
	Modified By Malboro 28 / 12 / 2012
	
	Ideas:
		Make permaprops cleanup-able
		
	Errors:
		Errors on die

	Remake:
		By Malboro the 28/12/2012
*/

TOOL.Category		=	"Staff"
TOOL.Name			=	"PermaProps"
TOOL.Command		=	nil
TOOL.ConfigName		=	""

if CLIENT then
	language.Add("Tool.permaprops.name", "PermaProps")
	language.Add("Tool.permaprops.desc", "Save a props permanently")
	language.Add("Tool.permaprops.0", "LeftClick: Add RightClick: Remove Reload: Update")

	surface.CreateFont("PermaPropsToolScreenFont", { font = "Arial", size = 40, weight = 1000, antialias = true, additive = false })
	surface.CreateFont("PermaPropsToolScreenSubFont", { font = "Arial", size = 30, weight = 1000, antialias = true, additive = false })
end

function TOOL:LeftClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end
	
	if !PermaProps.HasPermission( ply, "Save") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if ent.PermaProps then ply:ChatPrint( "That entity is already permanent !" ) return end

	local content = PermaProps.PPGetEntTable(ent)
	if not content then return end

	local max = tonumber(sql.QueryValue("SELECT MAX(id) FROM permaprops;"))
	if not max then max = 1 else max = max + 1 end

	local new_ent = PermaProps.PPEntityFromTable(content, max)
	if !new_ent or !new_ent:IsValid() then return end

	PermaProps.SparksEffect( ent )

	PermaProps.SQL.Query("INSERT INTO permaprops (id, map, content) VALUES(NULL, ".. sql.SQLStr(game.GetMap()) ..", ".. sql.SQLStr(util.TableToJSON(content)) ..");")
	ply:ChatPrint("You saved " .. ent:GetClass() .. " with model ".. ent:GetModel() .. " to the database.")

	ent:Remove()

	return true

end

function TOOL:RightClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end

	if !PermaProps.HasPermission( ply, "Delete") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if not ent.PermaProps then ply:ChatPrint( "That is not a PermaProp !" ) return end
	if not ent.PermaProps_ID then ply:ChatPrint( "ERROR: ID not found" ) return end

	PermaProps.SQL.Query("DELETE FROM permaprops WHERE id = ".. ent.PermaProps_ID ..";")

	ply:ChatPrint("You erased " .. ent:GetClass() .. " with a model of " .. ent:GetModel() .. " from the database.")

	ent:Remove()

	return true

end

function TOOL:Reload(trace)

	if CLIENT then return true end

	if not PermaProps then self:GetOwner():ChatPrint( "ERROR: Lib not found" ) return end

	if (not trace.Entity:IsValid() and PermaProps.HasPermission( self:GetOwner(), "Update")) then self:GetOwner():ChatPrint( "You have reload all PermaProps !" ) PermaProps.ReloadPermaProps() return false end

	if trace.Entity.PermaProps then

		local ent = trace.Entity
		local ply = self:GetOwner()

		if !PermaProps.HasPermission( ply, "Update") then return end

		if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
		
		local content = PermaProps.PPGetEntTable(ent)
		if not content then return end

		PermaProps.SQL.Query("UPDATE permaprops set content = ".. sql.SQLStr(util.TableToJSON(content)) .." WHERE id = ".. ent.PermaProps_ID .." AND map = ".. sql.SQLStr(game.GetMap()) .. ";")

		local new_ent = PermaProps.PPEntityFromTable(content, ent.PermaProps_ID)
		if !new_ent or !new_ent:IsValid() then return end

		PermaProps.SparksEffect( ent )

		ply:ChatPrint("You updated the " .. ent:GetClass() .. " in the database.")

		ent:Remove()


	else

		return false

	end

	return true

end

function TOOL.BuildCPanel(panel)

	panel:AddControl("Header",{Text = "PermaProps", Description = "PermaProps\n\nSaves entities across map changes\n"})
	panel:AddControl("Button",{Label = "Open Configuration Menu", Command = "pp_cfg_open"})

end

function TOOL:DrawToolScreen(width, height)

	if SERVER then return end

	surface.SetDrawColor(17, 148, 240, 255)
	surface.DrawRect(0, 0, 256, 256)

	surface.SetFont("PermaPropsToolScreenFont")
	local w, h = surface.GetTextSize(" ")
	surface.SetFont("PermaPropsToolScreenSubFont")
	local w2, h2 = surface.GetTextSize(" ")

	draw.SimpleText("Нах взяв це", "PermaPropsToolScreenFont", 128, 100, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
	draw.SimpleText("Чмонька", "PermaPropsToolScreenSubFont", 128, 128 + (h + h2) * 0.5 - 4, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)

end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/remover.lua:
TOOL.Category = "Construction"
TOOL.Name = "#tool.remover.name"

local function DoRemoveEntity(ent)

	if (!IsValid(ent) || ent:IsPlayer()) then return false end

	-- Nothing for the client to do here
	if (CLIENT) then return true end

	-- Remove all constraints (this stops ropes from hanging around)
	constraint.RemoveAll(ent)

	-- Remove it properly in 1 second
	timer.Simple(1, function() if (IsValid(ent)) then ent:Remove() end end)

	-- Make it non solid
	ent:SetNotSolid(true)
	ent:SetMoveType(MOVETYPE_NONE)
	ent:SetNoDraw(true)

	-- Send Effect
	local ed = EffectData()
	ed:SetEntity(ent)
	util.Effect("entity_remove", ed, true, true)

	return true

end

--
-- Remove a single entity
--
function TOOL:LeftClick(trace)

	if (DoRemoveEntity(trace.Entity)) then
		return true
	end

	return false

end

--
-- Remove this entity and everything constrained
--
function TOOL:RightClick(trace)

	local Entity = trace.Entity

	if (!IsValid(Entity) || Entity:IsPlayer()) then return false end

	-- Client can bail out now.
	if (CLIENT) then return true end

	local ConstrainedEntities = constraint.GetAllConstrainedEntities(trace.Entity)
	local Count = 0

	-- Loop through all the entities in the system
	for _, Entity in pairs(ConstrainedEntities) do

		if (DoRemoveEntity(Entity)) then
			Count = Count + 1
		end

	end

	return true

end

--
-- Reload removes all constraints on the targetted entity
--
function TOOL:Reload(trace)

	if (!IsValid(trace.Entity) || trace.Entity:IsPlayer()) then return false end
	if (CLIENT) then return true end

	return constraint.RemoveAll(trace.Entity)

end

function TOOL.BuildCPanel(CPanel)

	CPanel:AddControl("Header", { Description = "#tool.remover.desc" })

end

function TOOL:DrawToolScreen(width, height)

	if SERVER then return end

	surface.SetDrawColor(17, 148, 240, 255)
	surface.DrawRect(0, 0, 256, 256)

	surface.SetFont("Roboto_40")
	local w, h = surface.GetTextSize(" ")
	surface.SetFont("Roboto_40")
	local w2, h2 = surface.GetTextSize(" ")

	rp.ShadowText("Видаляй пропи", "Roboto_40", 128, 100, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
	rp.ShadowText("Красавчик)", "Roboto_40", 128, 128 + (h + h2) * 0.5 - 4, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)

end
--PATH addons/__________skeypads/lua/weapons/gmod_tool/stools/skeypads.lua:
TOOL.Name = '#tool.skeypads.name'
TOOL.Category = 'Roleplay'
TOOL.Desc = '#tool.skeypads.desc'
TOOL.Author = 'Tom.bat & NoSharp'
TOOL.ConfigName = ''
TOOL.ClientConVar['password'] = '1234'
TOOL.ClientConVar['securemode'] = 1
TOOL.ClientConVar['output_type'] = 'fadingdoor'
TOOL.ClientConVar['output_time'] = 5
TOOL.ClientConVar['fade_material'] = 'models/shadertest/shader3'
TOOL.ClientConVar['key_success'] = 0
TOOL.ClientConVar['key_fail'] = 0
cleanup.Register( 'skeypads' )
if CLIENT then
    TOOL.Information = {
        {
            name = 'left', --Select a fading door
            stage = 0
        },
        {
            name = 'left_1', --Click on a place to put the keypad
            stage = 1
        },
        {
            name = 'left_2', --Add fading door
            stage = 2
        },
        {
            name = 'right', --Delete keypad
            stage = 0
        },
        {
            name = 'right_1', --Cancel placement
            stage = 1
        },
        {
            name = 'right_2', --Remove fading door
            stage = 2
        },
        {
            name = 'reload', --Update settings of keypad
            stage = 0
        },
        {
            name = 'reload_2', --Exit fading door editor
            stage = 2
        }
    }

    language.Add( 'tool.skeypads.name', 'Кейпад' )
    language.Add( 'tool.skeypads.desc', 'Створіть та налаштуйте власний кейпад' )
    language.Add( 'tool.skeypads.left', 'Оберіть проп, щоб перетворити його на Fading Door' )
    language.Add( 'tool.skeypads.left_1', 'Розмістіти кейпад по напрямку погляду' )
    language.Add( 'tool.skeypads.left_2', 'Додати Fading Door' )
    language.Add( 'tool.skeypads.right', 'Видалити кейпад' )
    language.Add( 'tool.skeypads.right_1', 'Скасувати розміщення' )
    language.Add( 'tool.skeypads.right_2', 'Прибрати Fading Door' )
    language.Add( 'tool.skeypads.reload', 'Оновити налаштування кейпад' )
    language.Add( 'tool.skeypads.reload_2', 'Вийти з редактора дверей Fading Door' )
    language.Add( 'Undone_sKeypad', 'Кейпад видалено' )
    language.Add( 'Cleanup_skeypads', 'Кейпади' )
    language.Add( 'Cleaned_skeypads', 'Очистити усі кейпади' )
    language.Add( 'SBoxLimit_skeypads', 'Ви досягли ліміту кейпадів!' )
    local backgroundCol = Color( 50, 50, 50 )
    local gradientMat = Material( 'gui/gradient_down' )
    local hsvCol = HSVToColor
    local font1 = onyx.FontNoScale( 'Comfortaa Bold', 33 )
    TOOL.RainbowProg = 0
    function TOOL:DrawToolScreen( w, h )
        self.RainbowProg = self.RainbowProg + FrameTime() * 100
        surface.SetDrawColor( backgroundCol )
        surface.DrawRect( 0, 0, w, h )
        surface.SetDrawColor( hsvCol( self.RainbowProg / 4 % 360, 1, 1 ) )
        surface.SetMaterial( gradientMat )
        surface.DrawTexturedRect( 0, 0, w, h )
        local _, h1 = surface.GetTextSize( ' ' )
        surface.SetFont( font1 )
        local h2 = draw.GetFontHeight( font1 )
        draw.SimpleText( 'Паролі ставиш?)', font1, 128, 100, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        draw.SimpleText( 'Красавчик)', font1, 128, 128 + ( h1 + h2 ) * 0.5 - 4, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end

    TOOL.BuildCPanel = sKeypads.BuildToolMenu
    function TOOL:UpdateGhost( ent )
        if not IsValid( ent ) then return end
        local pos, ang = self:GetKeypadPos( ent )
        if not ( pos and ang ) then
            ent:SetNoDraw( true )
            return
        end

        ent:SetAngles( ang )
        ent:SetPos( pos )
        ent:SetNoDraw( false )
    end

    function TOOL:Think()
        local ent = self.GhostEntity
        if self:GetStage() ~= 1 then
            if IsValid( ent ) then self:ReleaseGhostEntity() end
            return
        end

        if not IsValid( ent ) then self:MakeGhostEntity( 'models/ogl/ogl_skeypad.mdl', vector_origin, Angle() ) end
        self:UpdateGhost( self.GhostEntity, self:GetOwner() )
        if IsValid( self.GhostEntity ) then self.GhostEntity:SetBodygroup( 2, 1 ) end
    end

    function TOOL:LeftClick()
        return true
    end

    function TOOL:RightClick()
        return true
    end

    function TOOL:Reload()
        return self:GetStage() == 0 or self:GetStage() == 2
    end
end

function TOOL:GetKeypadPos()
    local tr = self:GetOwner():GetEyeTrace()
    if not tr.Hit or IsValid( tr.Entity ) and tr.Entity:IsPlayer() then return false end
    local ang = tr.HitNormal:Angle()
    ang:RotateAroundAxis( ang:Up(), 180 )
    return tr.HitPos - tr.HitNormal * -0.38, ang
end

if CLIENT then return end
CreateConVar( 'sbox_maxskeypads', 100 )
function TOOL:Think()
    local outputType = self:GetClientInfo( 'output_type' )
    if outputType == 'keybind' then self:SetStage( 1 ) end
end

function TOOL:RestartPlacement()
    self.KeypadTable = nil
    self:SetStage( 0 )
end

function TOOL:IsOwner( ent, ply )
    local entOwner = ent:CPPIGetOwner()
    if entOwner == CPPI_DEFER or entOwner == nil then
        for _ = 1, 10 do
            sKeypads.Utils.log( 'CPPI NOT PROPERLY USED IN YOUR PROP PROTECTION ON THE SERVER sKeypads WILL BE BROKEN!' )
        end
        return false
    end

    if entOwner ~= ply then return false end
end

function TOOL:LeftClick( tr )
    local ent = tr.Entity
    if IsValid( ent ) and string.lower( ent:GetClass() ) == 'player' then --No player clicky clicky grrr
        return false
    end

    local ply = self:GetOwner()
    if not ply:CheckLimit( 'skeypads' ) then
        self:RestartPlacement()
        return false
    end

    if ply:sKeypadsGetCount() >= 40 then
        self:RestartPlacement()
        ply:sKeypadsNotify( 'Ви досягли свого особистого ліміту кейпадів!', 1 )
        return false
    end

    if tr.HitPos:DistToSqr( ply:GetPos() ) >= sKeypads.Config.max_distance_from_placement ^ 2 then return false end
    local outputType = self:GetClientInfo( 'output_type' )
    if self:GetStage() == 0 then
        if ent:GetClass() ~= 'prop_physics' then
            if ent:GetClass() == 'skeypad' then
                if outputType ~= 'fadingdoor' then return false end
                if self:IsOwner( ent, ply ) then return false end
                self.KeypadTable = ent:GetMeta()
                self:SetStage( 2 )
                sKeypads.DoorHalos.sendDoors( ply, ent )
                return
            end
            return
        end

        if outputType ~= 'fadingdoor' then return false end
        if self:IsOwner( ent, ply ) then return false end
        self.SelectedDoor = ent
        self:SetStage( 1 )
        return true
    elseif self:GetStage() == 2 then
        if ent:GetClass() ~= 'prop_physics' then return false end
        if self:IsOwner( ent, ply ) then return false end
        local keypad = self.KeypadTable:getAttachedEntity()
        if not IsValid( keypad ) then
            self:RestartPlacement()
            return false
        end

        if table.Count( self.KeypadTable:getFadingDoors() ) >= 20 then
            ply:sKeypadsNotify( 'Ви досягли максимальної кількості Fading Door-ів для цього кейпада.', 1 )
            return false
        end

        self.KeypadTable:conectToFadingDoor( ent )
        sKeypads.DoorHalos.sendDoors( ply, keypad )
        return true
    end

    local keypad = ents.Create( 'skeypad' )
    local pos, ang = self:GetKeypadPos( keypad )
    if not ( pos and ang ) then
        SafeRemoveEntityDelayed( keypad, 0 )
        return
    end

    keypad:SetAngles( ang )
    keypad:SetPos( pos )
    keypad:Spawn()
    keypad:CPPISetOwner( ply )
    keypad.ooooowner = ply
    local keypadMeta = sKeypads.Utilities.createNewButtonPad( keypad )
    if outputType == 'keybind' then
        keypadMeta:setKeyBinds( self:GetClientNumber( 'key_success' ), self:GetClientNumber( 'key_fail' ) )
    elseif outputType == 'fadingdoor' then
        if not ( IsValid( self.SelectedDoor ) and self.SelectedDoor:GetClass() == 'prop_physics' ) then
            SafeRemoveEntityDelayed( keypad, 0 )
            self:RestartPlacement()
            return false
        end

        keypadMeta:conectToFadingDoor( self.SelectedDoor )
        keypadMeta:setMaterial( 'sprites/heatwave' )
    else
        SafeRemoveEntityDelayed( keypad, 0 )
        self:RestartPlacement()
        return false
    end

    if not keypadMeta:setOutputMethod( outputType ) then --Returns false when user does a naughty
        SafeRemoveEntityDelayed( keypad, 0 )
        self:RestartPlacement()
        return false
    end

    local fadeTime = self:GetClientNumber( 'output_time', 10 )
    keypadMeta:setCode( self:GetClientInfo( 'password' ) )
    keypadMeta:setProtected( self:GetClientNumber( 'securemode', 1 ) )
    keypadMeta:setTime( math.Clamp( fadeTime, sKeypads.Config.min_keypad_open_time, sKeypads.Config.max_keypad_open_time ) )
    keypadMeta:attachToEntity( keypad )
    keypad:SetMeta( keypadMeta )
    duplicator.StoreEntityModifier( keypad, 'skeypad_data', {
        code = self:GetClientInfo( 'password' ),
        time = math.Clamp( fadeTime, sKeypads.Config.min_keypad_open_time, sKeypads.Config.max_keypad_open_time ),
        material = 'sprites/heatwave',
        protected = self:GetClientNumber( 'securemode', 1 ),
        keybindSuccess = self:GetClientNumber( 'key_success' ),
        keybindFail = self:GetClientNumber( 'key_fail' ),
        attachedEntity = keypadMeta:getAttachedEntity()
    } )

    local physObj = keypad:GetPhysicsObject()
    if IsValid( physObj ) then physObj:EnableMotion( false ) end
    constraint.Weld( keypad, ent, 0, tr.PhysicsBone or 0, 0, false, true )
    undo.Create( 'sKeypad' )
    undo.AddEntity( keypad )
    undo.SetPlayer( ply )
    undo.Finish()
    ply:AddCount( 'skeypads', keypad )
    ply:AddCleanup( 'skeypads', keypad )
    ply:sKeypadsAddKeypad( keypad:EntIndex() )
    self:RestartPlacement()
end

function TOOL:RightClick( tr )
    if self:GetStage() == 1 then
        self:RestartPlacement()
        return
    elseif self:GetStage() == 2 then
        local ent = tr.Entity
        local ply = self:GetOwner()
        if ent:GetClass() ~= 'prop_physics' then return false end
        if self:IsOwner( ent, ply ) then return false end
        local keypad = self.KeypadTable:getAttachedEntity()
        if not IsValid( keypad ) then
            self:RestartPlacement()
            return false
        end

        self.KeypadTable:disconnectFromFadingDoor( ent )
        sKeypads.DoorHalos.sendDoors( ply, keypad )
        return true
    end

    local ent = tr.Entity
    if not IsValid( ent ) or ent:GetClass() ~= 'skeypad' then return false end
    local ply = self:GetOwner()
    if tr.HitPos:DistToSqr( ply:GetPos() ) >= sKeypads.Config.max_distance_from_placement ^ 2 then return false end
    if self:IsOwner( ent, ply ) then return false end
    SafeRemoveEntityDelayed( ent, 0 )
end

function TOOL:Reload( tr )
    if self:GetStage() == 2 then
        self:SetStage( 0 )
        sKeypads.DoorHalos.resetDoors( self:GetOwner() )
        return
    end

    if self:GetStage() ~= 0 then return end
    local ent = tr.Entity
    if not IsValid( ent ) or ent:GetClass() ~= 'skeypad' then return false end
    local ply = self:GetOwner()
    if tr.HitPos:DistToSqr( ply:GetPos() ) >= sKeypads.Config.max_distance_from_placement ^ 2 then return false end
    if self:IsOwner( ent, ply ) then return false end
    local keypadMeta = ent:GetMeta()
    if not keypadMeta then
        ent:Remove()
        return false
    end

    local fadeTime = self:GetClientNumber( 'output_time', 10 )
    keypadMeta:setCode( self:GetClientInfo( 'password' ) )
    keypadMeta:setTime( math.Clamp( fadeTime, sKeypads.Config.min_keypad_open_time, sKeypads.Config.max_keypad_open_time ) )
    keypadMeta:setMaterial( 'sprites/heatwave' )
    keypadMeta:setProtected( self:GetClientNumber( 'securemode', 1 ) )
    keypadMeta:setKeyBinds( self:GetClientNumber( 'key_success' ), self:GetClientNumber( 'key_fail' ) )
    ent:SetMeta( keypadMeta )
    duplicator.StoreEntityModifier( ent, 'skeypad_data', {
        code = self:GetClientInfo( 'password' ),
        time = math.Clamp( fadeTime, sKeypads.Config.min_keypad_open_time, sKeypads.Config.max_keypad_open_time ),
        material = 'sprites/heatwave',
        protected = self:GetClientNumber( 'securemode', 1 ),
        keybindSuccess = self:GetClientNumber( 'key_success' ),
        keybindFail = self:GetClientNumber( 'key_fail' ),
        attachedEntity = keypadMeta:getAttachedEntity()
    } )
end

function TOOL:Holster()
    self:SetStage( 0 )
    sKeypads.DoorHalos.resetDoors( self:GetOwner() )
end
--PATH gamemodes/darkrp/entities/weapons/grabej.lua:
﻿
SWEP.Base = 'weapon_rp_base'
SWEP.PrintName  = "Пограбувати" // Это название нашего оружия. 
SWEP.Instructions   = "Натисни ЛКМ і ти ограбуєш людину!" // Это инструкция по аддону.
SWEP.Category = "DarkRP (Utility)"

SWEP.Spawnable = false;
SWEP.AdminSpawnable = true;

SWEP.Primary.ClipSize   = -1 // Это функция отвечает за количество патрон в магазине,если значение = -1 как в нашем случае,то патронов в магазине бесконечно.
SWEP.Primary.DefaultClip    = -1 // Количество патрон при получения оружия.
SWEP.Primary.Automatic  = false // Тип оружия автомат или винтовка.В нашем случае = true это автомат,при случае = false это винтовка.
SWEP.Primary.Ammo   = "none" // Тип патрон.

SWEP.Secondary.ClipSize = -1 // Вот тут всё то же самое как и в верхних
// функциях.
SWEP.Secondary.DefaultClip  = -1
SWEP.Secondary.Automatic    = false
SWEP.Secondary.Ammo = "none"
 
SWEP.Weight = 1 // Вес оружия.
SWEP.AutoSwitchTo   = false // Авто переключение оружия.
SWEP.AutoSwitchFrom = false
 
SWEP.Slot   = 1 // Слот оружия,если = 1,то наше оружие будет в первом слоте рядом с монтировкой.
SWEP.SlotPos    = 3 // Позиция оружия в слоте.
SWEP.DrawAmmo   = false // Скрытие количества патрон в hud'е,если = false,то патроны скрываются,если = true то патроны остаются.
SWEP.DrawCrosshair  = true // Скрытие прицела.
SWEP.HoldType   = "slam"
 
 
SWEP.ViewModel = Model("models/weapons/v_hands.mdl") // ВАЖНО:Тут прописываем путь к оружию.Это модель которую будет держать игрок.
--SWEP.WorldModel = "models/weapons/w_hands.mdl" // ВАЖНО:Тут прописываем путь к оружию.Это модель которая будет лежать в не подобранном состоянии
 
function SWEP:Reload()
end
 
function SWEP:Think()
return false
end
 
if SERVER then
    util.AddNetworkString("Grabej")
    util.AddNetworkString("EndGrab")
    net.Receive("EndGrab",function (len, ply)
        if ply:IsValid() and ply:GetNWBool("Grabyat") == true and ply:GetNWEntity("GrabitKogo") == net.ReadEntity() then
            local target = ply:GetNWEntity("GrabitKogo")
            if target.NextGrabTime == nil or target.NextGrabTime < CurTime() then
                if BATTLEPASS:GetPermanentVariable(target, 'anticarm') then return end
                if RSP:InsideSafeZone( target:GetPos() ) or RSP:InsideSafeZone( ply:GetPos() ) then return end
                local procent = target:GetMoney() * 3 / 100
                procent = math.floor(math.Clamp(procent, 5000, 450000))
                ply:SetNWInt('SumSpizdil', ply:GetNWInt('SumSpizdil', 0) + procent)
                target:AddMoney(-procent)
                rp.notify(target,"Вас пограбували на " .. tonumber(procent) .. "$",'')
                rp.notify(ply,"Ви пограбували гравця " .. target:Nick() .. " на " .. tonumber(procent) .. "$ щоб отримати гроші розміняйте їх у валютчика на станції метро.",'')
                hook.Run('PlayerGrabejPlayer', ply, target, procent)
                target.NextGrabTime = CurTime() + 120
            end
        end
    end)
 
    function SWEP:PrimaryAttack() // ВАЖНО:Эта функция отвечает за свойства выстрела из левой кнопки мыши.
        local target = self.Owner:GetEyeTrace().Entity

        if not IsValid(target) then return false end

        if target:IsPlayer() and target:GetPos():WithinAABox(Vector(-123.909271, -3085.475098, 57.791084), Vector(391.716766, -2380.657959, 245.692307)) then
            return false
        end

        if target:IsPlayer() and self.Owner:GetPos():Distance(target:GetPos()) < 150 then
            if target.NextGrabTime == nil or target.NextGrabTime < CurTime() then
                local procent = target:GetMoney()*5/100 -- Не забыть поменять на getDarkRPVar
                if target:CanBuy(procent) then
                    self.Owner:SetNWBool("Grabyat",true)
                    self.Owner:SetNWEntity("GrabitKogo",target)
                    net.Start("Grabej")
                    net.Send(self.Owner)
                    print ("Send!")
 
                end
            else
                rp.notify(self.Owner,"Його вже грабували. Залиш бідолагу в спокої!",'')
            end
        end
    end
end
 
 
if CLIENT then
    tGrab = 1
    net.Receive("Grabej",function ()
        if LocalPlayer():GetNWBool("Grabyat") then
            LocalPlayer().HUDDraw = true
        end
    end)
 
    hook.Add("HUDPaint","GrabejHUD",function ()
        if LocalPlayer().HUDDraw == true then
            tGrab = tGrab + 1
            -- print (LocalPlayer():GetNWEntity("GrabitKogo"))
            if tGrab >= 350 then tGrab = 1 LocalPlayer().HUDDraw = false net.Start("EndGrab") net.WriteEntity(LocalPlayer():GetNWEntity("GrabitKogo")) net.SendToServer() return end
            if LocalPlayer():GetPos():Distance(LocalPlayer():GetEyeTrace().Entity:GetPos()) > 250 then LocalPlayer().HUDDraw = false tGrab = 1 LocalPlayer():SetNWBool("Grabyat", false) return end
            draw.RoundedBoxEx(0,ScrW()*0.5 - 170,ScrH()*0.5,350,40,Color(96,96,96,150),false,false,false,false)
            draw.RoundedBoxEx(0,ScrW()*0.5 - 170,ScrH()*0.5,tGrab,40,Color(9,100,255,255),false,false,false,false)
        end
    end)
 
end
--PATH addons/__main/lua/weapons/m4a1_beast/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m4a1_beast") -- must be the name of your swep but NO CAPITALS!
SWEP.Category				= "CSO/CF Weapons" --Category where you will find your weapons
SWEP.Author				= "Zekeou"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "M4A1 Transformers"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 3			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false		-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight					= 30		-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg makes for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_rif_m2.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_rif_m4a2.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "zekeou_gun_base" --the Base this weapon will work on. PLEASE RENAME THE BASE! 
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("weapons/M4_Beast/m4_unsil-1.wav")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("")		-- Sound if the weapon is silenced
SWEP.Primary.RPM			= 900			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 38		-- Size of a clip
SWEP.Primary.DefaultClip		= 114		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.2		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.2		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. 
--Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true
SWEP.CanBeSilenced		= false

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.Damage		= 28	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(9.239, -5.119, 2.359)
SWEP.IronSightsAng = Vector(-0.145, 6.276, 0)
SWEP.SightsPos = Vector(9.239, -5.119, 2.359)
SWEP.SightsAng = Vector(-0.145, 6.276, 0)
SWEP.RunSightsPos = Vector(0,0,0)	--These are for the angles your viewmodel will be when running
SWEP.RunSightsAng = Vector(0,0,0)	--Again, use the Swep Construction Kit

--PATH addons/__main/lua/weapons/m9k_barret_m82/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_barret_m82") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Barret M82"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 51			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_50calm82.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_barret_m82.mdl"	-- Weapon world model
--oops
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("BarretM82.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 200		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "SniperPenetratedRound"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 9	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= true	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 110	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .00001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector (2.894, 0, 1.7624)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (2.894, 0, 1.7624)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_bizonp19/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_bizonp19") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Bizon PP19"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 42			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_bizon19.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_pp19_bizon.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_P19.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 675			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 64		-- Size of a clip
SWEP.Primary.DefaultClip		= 128		-- Bullets you start with
SWEP.Primary.KickUp				= 0.6		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 19	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.359, 0, 0.839)
SWEP.IronSightsAng = Vector(0.744, -0.588, 0)
SWEP.SightsPos = Vector(3.359, 0, 0.839)
SWEP.SightsAng = Vector(0.744, -0.588, 0)
SWEP.GSightsPos = Vector (0, 0, 0)
SWEP.GSightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_coltpython/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_coltpython") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Colt Python"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 57			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "revolver"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_pist_python.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_colt_python.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_ColtPython.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 115			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 6		-- Size of a clip
SWEP.Primary.DefaultClip		= 30		-- Bullets you start with
SWEP.Primary.KickUp				= 1		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.5		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "357"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		--how many bullets to shoot, use with shotguns
SWEP.Primary.Damage		= 29	--base damage, scaled by game
SWEP.Primary.Spread		= .02	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- has to be the same as primary.spread

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.743, -1.676, 1.796)
SWEP.IronSightsAng = Vector(0.611, 0.185, 0)
SWEP.SightsPos = Vector(-2.743, -1.676, 1.796)
SWEP.SightsAng = Vector(0.611, 0.185, 0)
SWEP.RunSightsPos = Vector(2.124, -9.365, -3.987)
SWEP.RunSightsAng = Vector(48.262, -8.214, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_dragunov/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_dragunov") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "SVD Dragunov"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 4				-- Slot in the weapon selection menu
SWEP.SlotPos				= 41			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_dragunov02.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_svd_dragunov.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_svd01.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 400		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .6			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= .5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "SniperPenetratedRound"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 9	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= true	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 90	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .00012 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(-1.241, -1.476, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(-1.241, -1.476, 0)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(3.934, -5.41, 0)
SWEP.RunSightsAng = Vector(-11.476, 35, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/mp_weapon_smart_pistol.lua:
if CLIENT then
    SWEP.WepSelectIcon = surface.GetTextureID( "ui/menu/items/weapon_smartpistol" )
    SWEP.DrawWeaponInfoBox = false
    SWEP.BounceWeaponIcon = false
end

SWEP.PrintName = "Smart Pistol MK5"
SWEP.Category = "Weapons"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.AdminOnly = true
SWEP.ViewModelFOV = 55
SWEP.ViewModel = "models/weapons/p2011sp/ptpov_p2011sp.mdl"
SWEP.WorldModel = "models/weapons/p2011sp/w_p2011sp.mdl"
SWEP.ViewModelFlip = false
SWEP.SwayScale = 0.5
SWEP.BobScale = 0.5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Weight = 15
SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.UseHands = false
SWEP.HoldType = "pistol"
SWEP.FiresUnderwater = true
SWEP.DrawCrosshair = false
SWEP.DrawAmmo = true
SWEP.CSMuzzleFlashes = true
SWEP.Base = "weapon_base"
SWEP.Aim = 0
SWEP.IronInTime = 0.25
SWEP.IronOutTime = 0.2
SWEP.DeployTime = 0.4
SWEP.Sprint = 0
SWEP.Lock = 0
SWEP.BobTimer = CurTime()
SWEP.Bob = 0
SWEP.Primary.Sound = Sound( "Weapon_SmartPistol.Single" )
SWEP.Primary.ClipSize = 12
SWEP.Primary.DefaultClip = 120
SWEP.Primary.MaxAmmo = 108
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "pistol"
SWEP.Primary.Damage = 32
SWEP.Primary.TakeAmmo = 1
SWEP.Primary.Recoil = 1
SWEP.Primary.RecoilView = 0.75
SWEP.Primary.Spread = 0.8
SWEP.Primary.NumberofShots = 1
SWEP.Primary.Delay = 0.125
SWEP.Primary.Force = 10
SWEP.Secondary.ClipSize = 0
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
function SWEP:Initialize()
    self:SetWeaponHoldType( self.HoldType )
end

function SWEP:DrawHUD()
    local owner = self:GetOwner()
    local x, y
    if owner == LocalPlayer() and owner:ShouldDrawLocalPlayer() then
        local tr = util.GetPlayerTrace( owner )
        local trace = util.TraceLine( tr )
        local coords = trace.HitPos:ToScreen()
        x, y = coords.x, coords.y
    else
        x, y = ScrW() * 0.5, ScrH() * 0.5
    end

    surface.SetTexture( surface.GetTextureID( "vgui/hud/weapons/smart_pistol_reticle" ) )
    surface.SetDrawColor( 255, 255, 255, 255 )
    surface.DrawTexturedRect( x - 128, y - 128, 256, 256 )
end

function SWEP:Deploy()
    local owner = self:GetOwner()
    self:SendWeaponAnim( ACT_VM_DRAW )
    self:SetNextPrimaryFire( CurTime() + self.DeployTime )
    self:SetNextSecondaryFire( CurTime() + self.DeployTime )
    self.Primary.Spread = 0.8
    owner:SetFOV( 0, 0 )
    self.Aim = 0
    self.Sprint = 0
    self.Lock = 0
    self.BobTimer = CurTime()
    self.Bob = 0
    owner:SetWalkSpeed( 200 )
end

function SWEP:Holster()
    local owner = self:GetOwner()
    self.Primary.Spread = 0.8
    owner:SetFOV( 0, 0 )
    self.Aim = 0
    self.Sprint = 0
    self.Lock = 0
    self.BobTimer = CurTime()
    self.Bob = 0
    owner:SetWalkSpeed( 200 )
    return true
end

function SWEP:Deploy()
    self:SetHoldType( self.HoldType )
    return true
end

function SWEP:PrimaryAttack()
    if self.Sprint == 1 then return end
    local owner = self:GetOwner()
    if self:Clip1() <= 0 and self:Ammo1() <= 0 and owner:WaterLevel() ~= 3 then
        self:EmitSound( "Default.ClipEmpty_Rifle" )
        self:SetNextPrimaryFire( CurTime() + self.Primary.Delay * 2 )
    end

    if self.FiresUnderwater == false and owner:WaterLevel() == 3 then
        self:EmitSound( "Default.ClipEmpty_Rifle" )
        self:SetNextPrimaryFire( CurTime() + self.Primary.Delay * 2 )
    end

    if self:Clip1() <= 0 and self:Ammo1() > 0 then self:Reload() end
    if self:Clip1() <= 0 then return end
    if self.FiresUnderwater == false and owner:WaterLevel() == 3 then return end
    owner:LagCompensation( true )
    local tr = util.TraceLine( {
        start = owner:GetShootPos(),
        endpos = owner:GetShootPos() + owner:GetAimVector() * 1000,
        filter = owner,
        mask = MASK_SHOT_HULL,
    } )

    if not IsValid( tr.Entity ) then
        tr = util.TraceHull( {
            start = owner:GetShootPos(),
            endpos = owner:GetShootPos() + owner:GetAimVector() * 1000,
            filter = owner,
            mins = Vector( -32, -32, 0 ),
            maxs = Vector( 32, 32, 0 ),
            mask = MASK_SHOT_HULL,
        } )
    end

    if SERVER and IsValid( tr.Entity ) and ( tr.Entity:IsNPC() or tr.Entity:IsPlayer() or tr.Entity:Health() > 0 ) then
        local dmginfo = DamageInfo()
        local attacker = owner
        if not IsValid( attacker ) then attacker = self end
        owner:EmitSound( "Weapon_SmartPistol.Lock" )
        dmginfo:SetAttacker( attacker )
        dmginfo:SetInflictor( self )
        dmginfo:SetDamage( self.Primary.Damage )
        dmginfo:SetDamageForce( owner:GetForward() * 10000 )
        dmginfo:SetDamage( self.Primary.Damage )
        tr.Entity:TakeDamageInfo( dmginfo )
    else
        local bullet = {}
        bullet.Num = self.Primary.NumberofShots
        bullet.Src = owner:GetShootPos()
        bullet.Dir = owner:GetAimVector()
        bullet.Spread = Vector( self.Primary.Spread * 0.1, self.Primary.Spread * 0.1, 0 )
        bullet.Tracer = 1
        bullet.Force = self.Primary.Force
        bullet.Damage = self.Primary.Damage
        bullet.AmmoType = self.Primary.Ammo
        owner:FireBullets( bullet )
    end

    if SERVER and IsValid( tr.Entity ) and ( tr.Entity:IsNPC() or tr.Entity:IsPlayer() or tr.Entity:Health() > 0 ) then
        local phys = tr.Entity:GetPhysicsObject()
        if IsValid( phys ) then phys:ApplyForceOffset( owner:GetAimVector() * 80 * phys:GetMass(), tr.HitPos ) end
    end

    owner:LagCompensation( false )
    self:EmitSound( self.Primary.Sound )
    owner:SetAnimation( PLAYER_ATTACK1 )
    owner:MuzzleFlash()
    owner:ViewPunchReset()
    owner:ViewPunch( Angle( -1, 0, 0 ) * self.Primary.Recoil )
    owner:SetEyeAngles( owner:EyeAngles() + Angle( -1, math.random( -0.25, 0.25 ), 0 ) * self.Primary.RecoilView )
    self:TakePrimaryAmmo( self.Primary.TakeAmmo )
    self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
    self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
    if self.Aim == 0 then self:SendWeaponAnim( ACT_VM_PRIMARYATTACK ) end
    if self.Aim == 1 then self:SendWeaponAnim( ACT_VM_PRIMARYATTACK_DEPLOYED ) end
end

function SWEP:SecondaryAttack()
    if self.Sprint == 1 then return end
    local owner = self:GetOwner()
    if self.Aim == 0 then
        self:SendWeaponAnim( ACT_VM_DEPLOY )
        self:SetNextPrimaryFire( CurTime() + self.IronInTime )
        self:SetNextSecondaryFire( CurTime() + self.IronInTime )
        self.Primary.Spread = 0.05
        owner:SetFOV( 75, 0.1 )
        self.Aim = 1
        owner:SetWalkSpeed( 100 )
    else
        if self.Aim == 1 then
            self:SendWeaponAnim( ACT_VM_UNDEPLOY )
            self:SetNextPrimaryFire( CurTime() + self.IronOutTime )
            self:SetNextSecondaryFire( CurTime() + self.IronOutTime )
            self.Primary.Spread = 0.8
            owner:SetFOV( 0, 0.1 )
            self.Aim = 0
            owner:SetWalkSpeed( 200 )
        end
    end
end

function SWEP:Reload()
    if self.Sprint == 1 then return end
    local owner = self:GetOwner()
    if self:Clip1() < self.Primary.ClipSize and self:Ammo1() > 0 then
        if self:Clip1() > 0 then self:DefaultReload( ACT_VM_RELOAD ) end
        if self:Clip1() <= 0 then self:DefaultReload( ACT_VM_RELOAD_EMPTY ) end
        self.Primary.Spread = 0.8
        owner:SetFOV( 0, 0.1 )
        self.Aim = 0
        owner:SetWalkSpeed( 200 )
    end
end

function SWEP:Think()
    local owner = self:GetOwner()
    local tr = util.TraceLine( {
        start = owner:GetShootPos(),
        endpos = owner:GetShootPos() + owner:GetAimVector() * 1000,
        filter = owner,
        mask = MASK_SHOT_HULL,
    } )

    if not IsValid( tr.Entity ) then
        tr = util.TraceHull( {
            start = owner:GetShootPos(),
            endpos = owner:GetShootPos() + owner:GetAimVector() * 1000,
            filter = owner,
            mins = Vector( -32, -32, 0 ),
            maxs = Vector( 32, 32, 0 ),
            mask = MASK_SHOT_HULL,
        } )
    end

    if self.Lock == 0 and IsValid( tr.Entity ) and ( tr.Entity:IsNPC() or tr.Entity:IsPlayer() or tr.Entity:Health() > 0 ) then
        owner:EmitSound( "Weapon_SmartPistol.TargetLock" )
        self.Lock = 1
    end

    if self.Lock == 1 and not IsValid( tr.Entity ) then self.Lock = 0 end
    if self:Ammo1() > self.Primary.MaxAmmo then owner:SetAmmo( self.Primary.MaxAmmo, self.Primary.Ammo ) end
    if self.Sprint == 0 and owner:KeyDown( IN_SPEED ) and ( owner:KeyDown( IN_FORWARD ) or owner:KeyDown( IN_BACK ) or owner:KeyDown( IN_MOVELEFT ) or owner:KeyDown( IN_MOVERIGHT ) ) then
        if SERVER then self:SendWeaponAnim( ACT_VM_SPRINT_IDLE ) end
        self.Primary.Spread = 0.8
        owner:SetFOV( 0, 0.1 )
        self.Sprint = 1
        self.Aim = 0
        self.BobTimer = CurTime()
        self.Bob = 1
        owner:SetWalkSpeed( 200 )
    end

    if self.Sprint == 1 and self.BobTimer <= CurTime() and self.Bob == 1 then
        owner:ViewPunch( Angle( 0, 0, -0.5 ) )
        self.BobTimer = CurTime() + 0.3
        self.Bob = 2
    end

    if self.Sprint == 1 and self.BobTimer <= CurTime() and self.Bob == 2 then
        owner:ViewPunch( Angle( 0, 0, 0.5 ) )
        self.BobTimer = CurTime() + 0.3
        self.Bob = 1
    end

    if self.Sprint == 1 and not owner:KeyDown( IN_SPEED ) then
        if SERVER then self:SendWeaponAnim( ACT_VM_IDLE ) end
        self:SetNextPrimaryFire( CurTime() + 0.2 )
        self:SetNextSecondaryFire( CurTime() + 0.2 )
        self.Sprint = 0
        self.BobTimer = CurTime()
        self.Bob = 0
    end

    if self.Sprint == 1 and not ( owner:KeyDown( IN_FORWARD ) or owner:KeyDown( IN_BACK ) or owner:KeyDown( IN_MOVELEFT ) or owner:KeyDown( IN_MOVERIGHT ) ) then
        if SERVER then self:SendWeaponAnim( ACT_VM_IDLE ) end
        self:SetNextPrimaryFire( CurTime() + 0.2 )
        self:SetNextSecondaryFire( CurTime() + 0.2 )
        self.Sprint = 0
        self.BobTimer = CurTime()
        self.Bob = 0
    end
end
--PATH addons/swb_css/lua/weapons/swb_ak47/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "AK-47"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-6.615, -10.563, 2.417)
	SWEP.AimAng = Vector(2.625, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = "swb_rifle_med"
end

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 7.62
SWEP.CaseLength = 39

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_rif_ak47.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_ak47.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_AK47.Single")
SWEP.Recoil = 1.2

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.005
SWEP.VelocitySensitivity = 1.6
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.13
SWEP.Shots = 1
SWEP.Damage = 30
SWEP.DeployTime = 1
--PATH addons/swb_base/lua/weapons/swb_base/sh_bullets.lua:
local Dir, Dir2, dot, sp, ent, trace, seed, hm
local trace_normal = bit.bor(CONTENTS_SOLID, CONTENTS_OPAQUE, CONTENTS_MOVEABLE, CONTENTS_DEBRIS, CONTENTS_MONSTER, CONTENTS_HITBOX, 402653442, CONTENTS_WATER)
local trace_walls = bit.bor(CONTENTS_TESTFOGVOLUME, CONTENTS_EMPTY, CONTENTS_MONSTER, CONTENTS_HITBOX)
local NoPenetration = {[MAT_SLOSH] = true}
local NoRicochet = {[MAT_FLESH] = true, [MAT_ANTLION] = true, [MAT_BLOODYFLESH] = true, [MAT_DIRT] = true, [MAT_SAND] = true, [MAT_GLASS] = true, [MAT_ALIENFLESH] = true}
local PenMod = {[MAT_SAND] = 0.5, [MAT_DIRT] = 0.8, [MAT_METAL] = 1.1, [MAT_TILE] = 0.9, [MAT_WOOD] = 1.2}
local bul, tr = {}, {}
local SP = game.SinglePlayer()

local reg = debug.getregistry()
local GetShootPos = reg.Player.GetShootPos
local GetCurrentCommand = reg.Player.GetCurrentCommand
local CommandNumber = reg.CUserCmd.CommandNumber

function SWEP:FireBullet(damage, cone, bullets)
	sp = GetShootPos(self.Owner)
	math.randomseed(CommandNumber(GetCurrentCommand(self.Owner)))
	
	if self.Owner:Crouching() then
		cone = cone * 0.85
	end
	
	Dir = (self.Owner:EyeAngles() + self.Owner:GetPunchAngle() + Angle(math.Rand(-cone, cone), math.Rand(-cone, cone), 0) * 25):Forward()

	for i = 1, bullets do
		Dir2 = Dir
		
		if self.ClumpSpread and self.ClumpSpread > 0 then
			Dir2 = Dir + Vector(math.Rand(-1, 1), math.Rand(-1, 1), math.Rand(-1, 1)) * self.ClumpSpread
		end
		
		bul.Num = 1
		bul.Src = sp
		bul.Dir = Dir2
		bul.Spread 	= Vector(0, 0, 0)
		bul.Tracer	= 4
		bul.Force	= damage * 0.3
		bul.Damage = math.Round(damage)
		
		self.Owner:FireBullets(bul)
		
		tr.start = sp
		tr.endpos = tr.start + Dir2 * self.PenetrativeRange
		tr.filter = self.Owner
		tr.mask = trace_normal
		
		trace = util.TraceLine(tr)
			
		if trace.Hit and not trace.HitSky then
			if not NoPenetration[trace.MatType] then
				dot = -Dir2:DotProduct(trace.HitNormal)
				ent = trace.Entity
			
				if dot > 0.26 and self.CanPenetrate and not ent:IsNPC() and not ent:IsPlayer() then
					tr.start = trace.HitPos
					tr.endpos = tr.start + Dir2 * self.PenStr * (PenMod[trace.MatType] and PenMod[trace.MatType] or 1) * self.PenMod
					tr.filter = self.Owner
					tr.mask = trace_walls
					
					trace = util.TraceLine(tr)
					
					tr.start = trace.HitPos
					tr.endpos = tr.start + Dir2 * 0.1
					tr.filter = self.Owner
					tr.mask = trace_normal
					
					trace = util.TraceLine(tr) -- run ANOTHER trace to check whether we've penetrated a surface or not
					
					if not trace.Hit then
						bul.Num = 1
						bul.Src = trace.HitPos
						bul.Dir = Dir2
						bul.Spread 	= Vec0
						bul.Tracer	= 4
						bul.Force	= damage * 0.15
						bul.Damage = bul.Damage * 0.5
						
						self.Owner:FireBullets(bul)
						
						bul.Num = 1
						bul.Src = trace.HitPos
						bul.Dir = -Dir2
						bul.Spread 	= Vec0
						bul.Tracer	= 4
						bul.Force	= damage * 0.15
						bul.Damage = bul.Damage * 0.5
						
						self.Owner:FireBullets(bul)
					end
				else
					if self.CanRicochet then
						if not NoRicochet[trace.MatType] and self.PenetrativeRange * trace.Fraction < self.PenetrativeRange then
							Dir2 = Dir2 + (trace.HitNormal * dot) * 3
							Dir2 = Dir2 + VectorRand() * 0.06
							bul.Num = 1
							bul.Src = trace.HitPos
							bul.Dir = Dir2
							bul.Spread 	= Vec0
							bul.Tracer	= 0
							bul.Force	= damage * 0.225
							bul.Damage = bul.Damage * 0.75
							
							self.Owner:FireBullets(bul)
						end
					end
				end
			end
		end
	end
		
	tr.mask = trace_normal
end
--PATH addons/swb_base/lua/weapons/swb_base/sh_ammotypes.lua:
function SWB_AddAmmoType(name)
	game.AddAmmoType({name = name,
	dmgtype = DMG_BULLET})
	
	if CLIENT then
		language.Add(name .. "_ammo", name .. " Ammo")
	end
end

SWB_AddAmmoType("Rifle")
SWB_AddAmmoType("Sniper Rifle")
--PATH addons/swb_base/lua/weapons/swb_base/sh_move.lua:
local reg = debug.getregistry()
local GetActiveWeapon = reg.Player.GetActiveWeapon
local GetDTFloat = reg.Entity.GetDTFloat
local GetRunSpeed = reg.Player.GetRunSpeed
local GetWalkSpeed = reg.Player.GetWalkSpeed
local GetCrouchedWalkSpeed = reg.Player.GetCrouchedWalkSpeed
local Crouching = reg.Player.Crouching

local wep

function SWB_Move(ply, m)
	if Crouching(ply) then
		m:SetMaxSpeed(GetWalkSpeed(ply) * GetCrouchedWalkSpeed(ply))
	else
		wep = GetActiveWeapon(ply)
		
		if IsValid(wep) and wep.SWBWeapon then
			if wep.dt and wep.dt.State == SWB_AIMING then
				m:SetMaxSpeed(GetWalkSpeed(ply) * 0.75)
			else
				m:SetMaxSpeed((GetRunSpeed(ply) - wep.SpeedDec))
			end
		else
			m:SetMaxSpeed(GetRunSpeed(ply))
		end
	end
end

//hook.Add("Move", "SWB_Move", SWB_Move)
--PATH addons/swb_base/lua/weapons/swb_base/cl_playerbindpress.lua:
local wep, CT

function SWEP.PlayerBindPress(ply, b, p)
	if p then
		wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.SWBWeapon then
			if wep.dt and wep.dt.State == SWB_AIMING then
				if wep.AdjustableZoom then
					CT = CurTime()
					
					if b == "invprev" then
						CT = CurTime()
						
						if CT > wep.ZoomWait then
							if wep.ZoomAmount > wep.MinZoom then
								wep.ZoomAmount = math.Clamp(wep.ZoomAmount - 15, wep.MinZoom, wep.MaxZoom)
								surface.PlaySound("weapons/zoom.wav")
								wep.ZoomWait = CT + 0.15

							end
						end
						
						return true
					elseif b == "invnext" then
						CT = CurTime()
						
						if CT > wep.ZoomWait then
							if wep.ZoomAmount < wep.MaxZoom then
								wep.ZoomAmount = math.Clamp(wep.ZoomAmount + 15, wep.MinZoom, wep.MaxZoom)
								surface.PlaySound("weapons/zoom.wav")
								wep.ZoomWait = CT + 0.15
							end
						end
						
						return true
					end
				end
			end
		end
	end
end

hook.Add("PlayerBindPress", "SWEP.PlayerBindPress (SWB)", SWEP.PlayerBindPress)
--PATH addons/__main/lua/weapons/weapon_base/sh_anim.lua:
local ActIndex = {
	[ "pistol" ] 		= ACT_HL2MP_IDLE_PISTOL,
	[ "smg" ] 			= ACT_HL2MP_IDLE_SMG1,
	[ "grenade" ] 		= ACT_HL2MP_IDLE_GRENADE,
	[ "ar2" ] 			= ACT_HL2MP_IDLE_AR2,
	[ "shotgun" ] 		= ACT_HL2MP_IDLE_SHOTGUN,
	[ "rpg" ]	 		= ACT_HL2MP_IDLE_RPG,
	[ "physgun" ] 		= ACT_HL2MP_IDLE_PHYSGUN,
	[ "crossbow" ] 		= ACT_HL2MP_IDLE_CROSSBOW,
	[ "melee" ] 		= ACT_HL2MP_IDLE_MELEE,
	[ "slam" ] 			= ACT_HL2MP_IDLE_SLAM,
	[ "normal" ]		= ACT_HL2MP_IDLE,
	[ "fist" ]			= ACT_HL2MP_IDLE_FIST,
	[ "melee2" ]		= ACT_HL2MP_IDLE_MELEE2,
	[ "passive" ]		= ACT_HL2MP_IDLE_PASSIVE,
	[ "knife" ]			= ACT_HL2MP_IDLE_KNIFE,
	[ "duel" ]			= ACT_HL2MP_IDLE_DUEL,
	[ "camera" ]		= ACT_HL2MP_IDLE_CAMERA,
	[ "magic" ]			= ACT_HL2MP_IDLE_MAGIC,
	[ "revolver" ]		= ACT_HL2MP_IDLE_REVOLVER
}

--[[---------------------------------------------------------
   Name: SetWeaponHoldType
   Desc: Sets up the translation table, to translate from normal 
			standing idle pose, to holding weapon pose.
-----------------------------------------------------------]]
function SWEP:SetWeaponHoldType( t )

	t = string.lower( t )
	local index = ActIndex[ t ]
	
	if ( index == nil ) and !wOS.AnimExtension.TranslateHoldType[ t ] then
		Msg( "SWEP:SetWeaponHoldType - ActIndex[ \""..t.."\" ] isn't set! (defaulting to normal)\n" )
		t = "normal"
		index = ActIndex[ t ]		
	end
	
	if wOS.AnimExtension.TranslateHoldType[ t ] then 
		self.ActivityTranslate = table.Copy( wOS.AnimExtension.TranslateHoldType[ t ]:GetActivityList() )
	else
		self.ActivityTranslate = {}
		self.ActivityTranslate [ ACT_MP_STAND_IDLE ] 				= index
		self.ActivityTranslate [ ACT_MP_WALK ] 						= index+1
		self.ActivityTranslate [ ACT_MP_RUN ] 						= index+2
		self.ActivityTranslate [ ACT_MP_CROUCH_IDLE ] 				= index+3
		self.ActivityTranslate [ ACT_MP_CROUCHWALK ] 				= index+4
		self.ActivityTranslate [ ACT_MP_ATTACK_STAND_PRIMARYFIRE ] 	= index+5
		self.ActivityTranslate [ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ] = index+5
		self.ActivityTranslate [ ACT_MP_RELOAD_STAND ]		 		= index+6
		self.ActivityTranslate [ ACT_MP_RELOAD_CROUCH ]		 		= index+6
		self.ActivityTranslate [ ACT_MP_JUMP ] 						= index+7
		self.ActivityTranslate [ ACT_RANGE_ATTACK1 ] 				= index+8
		self.ActivityTranslate [ ACT_MP_SWIM ] 						= index+9	
	end
	
	-- "normal" jump animation doesn't exist
	if t == "normal" then
		self.ActivityTranslate [ ACT_MP_JUMP ] = ACT_HL2MP_JUMP_SLAM
	end

	self:SetupWeaponHoldTypeForAI( t )

end

-- Default hold pos is the pistol
SWEP:SetWeaponHoldType( "pistol" )

--[[---------------------------------------------------------
   Name: weapon:TranslateActivity( )
   Desc: Translate a player's Activity into a weapon's activity
		 So for example, ACT_HL2MP_RUN becomes ACT_HL2MP_RUN_PISTOL
		 Depending on how you want the player to be holding the weapon
-----------------------------------------------------------]]
function SWEP:TranslateActivity( act )

	if ( self.Owner:IsNPC() ) then
		if ( self.ActivityTranslateAI[ act ] ) then
			return self.ActivityTranslateAI[ act ]
		end
		return -1
	end

	if ( self.ActivityTranslate[ act ] != nil ) then
		return self.ActivityTranslate[ act ]
	end

	return -1

end
--PATH gamemodes/darkrp/entities/weapons/weapon_c4/shared.lua:
if (SERVER) then
	AddCSLuaFile('shared.lua')
end

SWEP.PrintName = 'C4'
SWEP.Slot = 1
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.Instructions = 'Click to blow shit up'
SWEP.Author = 'aStonedPenguin'
SWEP.Contact = ''
SWEP.Purpose = ''
SWEP.ViewModel = "models/weapons/cstrike/c_c4.mdl"
SWEP.WorldModel = "models/weapons/w_c4.mdl"
SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = 'rpg'
SWEP.Spawnable = true
SWEP.Category = 'RP'
SWEP.Sound = ''
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ''
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ''

function SWEP:Initialize()
	self.nextReload = 0
	self:SetHoldType('normal')
end

function SWEP:Deploy()
	if (SERVER) then
		self.Owner:DrawWorldModel(false)
	end
end

function SWEP:PrimaryAttack()
	if (SERVER) then
		local tr = util.TraceLine({
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + 100 * self.Owner:GetAimVector(),
			filter = {self.Owner}
		})

		local c4 = ents.Create('ent_c4')
		c4:SetPos(tr.HitPos)
		c4:SetAngles(tr.HitNormal:Angle() - Angle(90, 180, 0))
		c4:Spawn()
		c4.ItemOwner = self.Owner

		if tr.Entity and IsValid(tr.Entity) then
			if tr.Entity:GetPhysicsObject():IsValid() then
				c4:SetParent(tr.Entity)
			elseif not tr.Entity:IsNPC() and not tr.Entity:IsPlayer() and tr.Entity:GetPhysicsObject():IsValid() then
				constraint.Weld(c4, tr.Entity)
			end
		else
			c4:SetMoveType(MOVETYPE_NONE)
		end

		hook.Call('PlayerPlaceC4', nil, self.Owner, tr.Entity)

		if not tr.Hit then
			c4:SetMoveType(MOVETYPE_VPHYSICS)
		end

		self.Owner:EmitSound("c4.PlantSound")
		self.Owner:StripWeapon('weapon_c4')
	end
end

function SWEP:SecondaryAttack()
	self:PrimaryAttack()
end
--PATH addons/__main/lua/weapons/weapon_claws/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Claws"
SWEP.Category				= "Weapons"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/v_models/V_demhands.mdl" )
SWEP.ViewModel				= Model( "models/weapons/v_models/V_demhands.mdl" )
SWEP.DrawWorldModel			= false
SWEP.ViewModelFOV			= 60
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= 0
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"
SWEP.Anim 					= 0

SWEP.Secondary.ClipSize		= 1
SWEP.Secondary.DefaultClip	= 1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"
SWEP.Damage 			= 25
SWEP.DamageType			= DMG_SLASH
SWEP.HitDistance		= 75
SWEP.HitRate			= 0.2

SWEP.HitSound			= Sound("CLAW_HIT")
SWEP.SwingSound			= Sound("CLAW_SWING")

if CLIENT then
SWEP.DrawWeaponInfoBox	= false
end

function SWEP:Initialize()
	self:SetHoldType( "fist") 
end

function SWEP:PrimaryAttack()
			local vm = self.Owner:GetViewModel()
			if self.Anim == 1 then
			vm:SendViewModelMatchingSequence( vm:LookupSequence( "attack1" )) 
			self.Anim = 0
			else
			vm:SendViewModelMatchingSequence( vm:LookupSequence( "attack2" ))
			self.Anim = 1
			end
			self.Owner:SetAnimation( PLAYER_ATTACK1 )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )
	self.Owner:EmitSound(self.SwingSound, 75, 100)

	timer.Create("hitdelay", 0.1, 1, function() self.HitWait(self) end)

	timer.Start( "hitdelay" )
 
end

function SWEP:SecondaryAttack()
self:PrimaryAttack()
end

function SWEP:OnDrop()
	
end

function SWEP.HitWait(self)
	local tr = util.TraceHull( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.HitDistance,
			filter = self.Owner,
			mins = Vector( -5, -5, -5 ),
			maxs = Vector( 5, 5, 5 ),
			mask = MASK_SHOT_HULL  
		} )
 
	if ( tr.Hit ) then

		if ( SERVER and string.find(tr.Entity:GetClass(),"player")) then
			tr.Entity:EmitSound(self.HitSound, 150, 100)
			if tr.Entity:Health() > self.Damage then
			local dmginfo = DamageInfo()
			dmginfo:SetAttacker(self.Owner) 
			dmginfo:SetInflictor(self) 
			dmginfo:SetDamage(self.Damage) 
			dmginfo:SetDamageType(self.DamageType) 
			tr.Entity:TakeDamageInfo(dmginfo)
			else
			local nade = ents.Create("prop_ragdoll")
			nade:SetModel( tr.Entity:GetModel())		
			nade:SetPos(tr.Entity:GetPos())
			nade:SetAngles(tr.Entity:EyeAngles())
			tr.Entity:KillSilent() 
			nade:Spawn()
			end
		else 
			if ( SERVER and string.find(tr.Entity:GetClass(),"npc")) then
			tr.Entity:EmitSound(self.HitSound, 75, 100)
			local dmginfo = DamageInfo()
			dmginfo:SetAttacker(self.Owner)
			dmginfo:SetInflictor(self) 
			dmginfo:SetDamage(self.Damage) 
			dmginfo:SetDamageForce(self.Owner:GetAimVector() * self.Damage )
			dmginfo:SetDamageType(self.DamageType) 
			tr.Entity:TakeDamageInfo(dmginfo)	
			
			else 
			
			if ( SERVER and string.find(tr.Entity:GetClass(),"prop_ragdoll")) then
			
				if tr.Entity:GetMaterialType() == MAT_FLESH then
				tr.Entity:EmitSound(self.HitSound, 100, 100)
				if tr.Entity:GetMaterial() ~=  "models/zombie_fast/fast_zombie_sheet" then
				tr.Entity:SetMaterial("models/zombie_fast/fast_zombie_sheet",true)
				else
				self.Owner:SetHealth( self.Owner:Health() + tr.Entity:GetPhysicsObject():GetMass() )
				self:SetClip1(self:Clip1() + 1)
				tr.Entity:Remove()
				end
				end
				
				if tr.Entity:GetMaterialType() == MAT_ALIENFLESH or tr.Entity:GetMaterialType() == MAT_ANTLION then
					tr.Entity:EmitSound(self.HitSound, 75, 100)
					if tr.Entity:GetMaterial() ~=  "models/antlion/antlion_innards" then
					tr.Entity:SetMaterial("models/antlion/antlion_innards",true) 
					else
					self.Owner:SetHealth( self.Owner:Health() + tr.Entity:GetPhysicsObject():GetMass() )
					self:SetClip1(self:Clip1() + 1)
					tr.Entity:Remove()
					end	
				end
			end
		end
end
end
end

function SWEP:Deploy()
	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "idle" ) ) 
end

function SWEP:Reload()
end

function SWEP:Holster()
	return true
end

function SWEP:CustomAmmoDisplay()
	self.AmmoDisplay = self.AmmoDisplay or {} 
 
	self.AmmoDisplay.Draw = true //draw the display?
 
		self.AmmoDisplay.PrimaryClip = self:Clip1() //amount in clip
 
	return self.AmmoDisplay //return the table
end

function SWEP:OnRemove()
	timer.Remove("hitdelay")
	return true
end
--PATH addons/__main/lua/weapons/weapon_hl2axe/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Axe"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack : Push"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_axe.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_axe.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 35
SWEP.HitInclination		= 0.4
SWEP.HitPushback		= 700
SWEP.HitRate			= 1.00
SWEP.MinDamage			= 34
SWEP.MaxDamage			= 40

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound("npc/ministrider/flechette_flesh_impact1.wav")
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 1.5 * 40,
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

	if ( tr.Hit ) then
	self:EmitSound( PushSoundBody )
	if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
	tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * 500 )
	end
	end

end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 34, 40 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay")
	return true
end
--PATH addons/__main/lua/weapons/weapon_hl2hook/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Hook"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack : Push (Pulls instead of pushing back on primary attack)"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_hook.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_hook.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 40
SWEP.HitInclination		= 0.4
SWEP.HitPushback		= -1000
SWEP.HitRate			= 1.25
SWEP.MinDamage			= 34
SWEP.MaxDamage			= 55

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.Break" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 1.5 * 40,
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

	if ( tr.Hit ) then
	self:EmitSound( PushSoundBody )
	if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
	tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * 500 )
	end
	end

end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 5
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 34, 50 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay")
	return true
end
--PATH addons/__main/lua/weapons/weapon_vape_american.lua:
-- weapon_vape_american.lua
-- Defines a vape which emits red, white, and blue clouds and plays Donald Trump sounds

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
	net.Receive('vapeukr',function()
		local pos=net.ReadVector()
		sound.PlayURL ( "https://ukrainerp.one/slava.mp3", "3d", function( station )
                    if ( IsValid( station ) ) then
                        station:SetPos( pos )
                        station:Play()
                    end
                end )
	end)
else
	include('weapon_vape/shared.lua')
	util.AddNetworkString('vapeukr')
end

SWEP.PrintName = "Ukraine Vape"

SWEP.Instructions = ""

SWEP.VapeID = 7
SWEP.VapeAccentColor = Vector(0.5,0.5,0.5)

--tells the matproxy to substitute red/white/blue fader (todo: change how this works)
SWEP.VapeTankColor = Vector(-2,-2,-2)

function SWEP:SecondaryAttack()
	--this makes it so the "bing bong" sounds the same to everyone instead of the owner hearing a different noise due to randomness
	--print('asd2')
	if CLIENT then return else SuppressHostEvents(NULL) end

	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	--self:EmitSound("vapebing"..tostring(math.random(1,2))..".wav", 80, pitch + math.Rand(-25,25))
	for k,v in player.Iterator() do
		if v:GetPos():Distance(self.Owner:GetPos()) < 1000 then
			net.Start('vapeukr')
			net.WriteVector(self.Owner:GetPos())
			net.Send(v)
			print(v)
		end
	end
end
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/weapon_vape_hallucinogenic.lua:
-- weapon_vape_hallucinogenic.lua
-- Defines a vape which makes hallucinogenic effects on the user's screen

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Hallucinogenic Vape"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nThis juice contains hallucinogens (don't worry, they're healthy and all-natural)"

SWEP.VapeAccentColor = Vector(0.5,1,0)
SWEP.VapeTankColor = Vector(-1,-1,-1)

SWEP.VapeID = 5

if CLIENT then
	hook.Add("RenderScreenspaceEffects","HallucinogenicVape",function()
		if (vapeHallucinogen or 0) > 0 then
			if vapeHallucinogen>100 then vapeHallucinogen=100 end
			local alpha = vapeHallucinogen/100
			DrawMotionBlur( 0.04, alpha, 0 )

			local tab = {}
			tab[ "$pp_colour_colour" ] =   1 + (alpha*0.25)
			tab[ "$pp_colour_contrast" ] = 1 + alpha
			tab[ "$pp_colour_brightness" ] = -0.1*alpha
			DrawColorModify(tab)

		end
	end)

	timer.Create("HallucinogenicVapeCounter",0.1,0,function()
		if (vapeHallucinogen or 0) > 0 then vapeHallucinogen = vapeHallucinogen-1 end
	end)
end
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__snow_event/lua/weapons/zck_snowballswep/shared.lua:
SWEP.PrintName = 'Сніжок'
SWEP.Author = 'Zerochain'
SWEP.Instructions = 'LeftClick Throw Snoball, RightClick Pickup snow'
SWEP.Contact = ''
SWEP.Purpose = ''
SWEP.AdminSpawnable = false
SWEP.Spawnable = true
SWEP.ViewModelFOV = 45
SWEP.ViewModel = 'models/zerochain/props_christmas/snowballswep/zck_c_snowballswep.mdl'
SWEP.WorldModel = 'models/zerochain/props_christmas/snowballswep/zck_w_snowballswep.mdl'
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = true
SWEP.Slot = 1
SWEP.SlotPos = 1
SWEP.HoldType = 'grenade'
SWEP.FiresUnderwater = false
SWEP.Weight = 5
SWEP.DrawCrosshair = true
SWEP.Category = 'Main'
SWEP.DrawAmmo = false
SWEP.base = 'weapon_base'
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = 'none'
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 1
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = 'none'
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 0.4
SWEP.UseHands = true
SWEP.DisableDuplicator = true
function SWEP:SetupDataTables()
	self:NetworkVar( 'Int', 0, 'SnowballCount' )
	if SERVER then self:SetSnowballCount( 5 ) end
end
--PATH addons/__main/lua/weapons/zekeou_gun_base/cl_init.lua:
include('shared.lua')

SWEP.PrintName				= ""				// 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot				= 4				// Slot in the weapon selection menu
SWEP.SlotPos				= 1				// Position in the slot
SWEP.DrawAmmo				= true				// Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox			= false				// Should draw the weapon info box
SWEP.BounceWeaponIcon   			= false				// Should the weapon icon bounce?
SWEP.CSMuzzleFlashes			= true


--PATH addons/__main/lua/entities/anim_gmantele_ex.lua:
AddCSLuaFile()

DEFINE_BASECLASS("base_anim")

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.Author = "Axel"
ENT.DoNotDuplicate = true
ENT.PhysgunDisabled = true
ENT.AutomaticFrameAdvance = true
ENT.WorldModel = "models/weapons/w_suitcase_passenger.mdl"
ENT.RenderGroup = RENDERGROUP_BOTH

ENT.OpenSound = "doors/metal_move1.wav"
ENT.CloseSound = "doors/door_metal_rusty_move1.wav"
ENT.FullyOpen = "doors/door_metal_thin_open1.wav"


function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "EndDoorTime")
	self:NetworkVar("Bool", 1, "Close")
	self:NetworkVar("Vector", 0, "PlayerColor")
end

if SERVER then
	function ENT:Initialize()
		BaseClass.Initialize(self)
		self:ResetSequence("idle_all_01")
		self:SetEndDoorTime(CurTime() + 2)
	end

	function ENT:Think()
		BaseClass.Think(self)
		if not self.StartWalking and self:GetEndDoorTime() < CurTime() then
			self:ResetSequence("walk_suitcase")
			self.StartWalking = CurTime() + 1.7
			self:SetVelocity(self:GetForward() * 30)
			self:SetMoveType(MOVETYPE_NOCLIP)
			self:SetPoseParameter("move_x", 0.5)
		elseif self.StartWalking and self.StartWalking < CurTime() and not self.ClosingDoor then
			self:SetEndDoorTime(CurTime() + 1)
			self.ClosingDoor = CurTime() + 0.3
		elseif self.ClosingDoor and self.ClosingDoor < CurTime() and not self.Finished then
			self.Finshed = true
			self:ResetSequence("idle_all_01")
			self:SetVelocity(vector_origin)
			self:SetMoveType(MOVETYPE_NONE)
			SafeRemoveEntityDelayed(self, 3)
		end

		self:NextThink(CurTime())
		return true
	end

	function ENT:UpdateTransmitState()
		return TRANSMIT_ALWAYS
	end
end

if CLIENT then
	local function DrawWall(pos, angle, width, height, color)
		if width < 0 or height < 0 then return end
		render.SetColorMaterial()
		render.DrawQuad(
			LocalToWorld(Vector( 0, -height, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( 0, 0, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( width, 0, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( width, -height, 0 ), angle_zero, pos, angle),
			color or COLOR_WHITE
		)
	end

	function ENT:Initialize()
		self:SetIK(false)
		self:DrawShadow(false)
		if not IsValid(self.ClientModel) then
			self.ClientModel = ClientsideModel(self.WorldModel)
			if IsValid(self.ClientModel) then
				self.ClientModel:SetNoDraw(true)
			end
		end
	end

	function ENT:Think()
		BaseClass.Think(self)

		self:SetNextClientThink(CurTime())
		self:SetRenderBounds(Vector(-16, -16, 0), Vector(16, 16, 64), Vector(75, 75, 75))
		return true
	end

	function ENT:OnRemove()
		if IsValid(self.ClientModel) then
			self.ClientModel:Remove()
		end
	end

	function ENT:DrawTranslucent()
		self:DrawShadow(false)
		if self:GetEndDoorTime() == 0 and not self.DPos or not self.StartTime then
			self.DPos = self:GetPos() + self:GetForward() * 32
			self.StartTime = CurTime()
			self:EmitSound(self.OpenSound)
			return
		end

		local pos, ang = self.DPos, self:GetForward():Angle()
		local dang = self:GetForward():Angle()
		dang:RotateAroundAxis(dang:Right(), - 90)
		dang:RotateAroundAxis(dang:Up(), 90)

		if self:GetEndDoorTime() < CurTime() and not self.CloseLatch then
			self.CloseLatch = true
			self:EmitSound(self.FullyOpen)
		elseif self.CloseLatch and self:GetEndDoorTime() > CurTime() and not self.Close then
			self.Close = true
			self.StartTime = CurTime()
			self:EmitSound(self.CloseSound)
		end

		local dur, elapsed = self:GetEndDoorTime() - self.StartTime, CurTime() - self.StartTime
		local per = math.Clamp(elapsed / dur, 0, 1)


		render.SetStencilEnable(true)
		render.ClearStencil()
		render.SetStencilTestMask(255)
		render.SetStencilWriteMask(255)

		render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
		render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
		render.SetStencilReferenceValue(1)

		per = (not self.Close and per or (1 - per))
		DrawWall(pos + ang:Right() * 25 + ang:Up() * 100 * per - Vector(0, 0, 1), dang, 50, 100 * per)

		local oldclip = render.EnableClipping(true)
		render.PushCustomClipPlane(self:GetForward(), self:GetForward():Dot(self.DPos))

		render.SetStencilReferenceValue(0)
		self:DrawModel()
		self:DrawBriefcase()

		render.PopCustomClipPlane()

		render.SetStencilReferenceValue(1)
		render.SetStencilPassOperation(STENCILOPERATION_KEEP)
		render.SetStencilFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)

		render.SuppressEngineLighting(true)
		render.ResetModelLighting(0, 0, 0)
		render.SetLocalModelLights(
			{
				{
					type = MATERIAL_LIGHT_SPOT,
					color = Vector(0.6, 0.6, 0.6),
					pos = self:GetPos() + self:GetForward() * 120 + self:GetUp() * 64,
					dir = -self:GetForward(),
					outerAngle = 90,
					linearFalloff = true,
				}
			}
		)

		render.PushCustomClipPlane(-self:GetForward(), -self:GetForward():Dot(self.DPos))
		render.DepthRange( 0, 0.1 )
		self:DrawModel()
		self:DrawBriefcase()
		render.DepthRange( 0, 1 )

		render.PopCustomClipPlane()
		render.SuppressEngineLighting(false)
		render.EnableClipping(oldclip)
		render.SetStencilEnable(false)

		dang:RotateAroundAxis(self:GetUp(), 180)
		DrawWall(pos - ang:Right() * 25 + ang:Up() * 100 * per - Vector(0, 0, 1), dang, 50, 100 * per)

	end

	function ENT:Draw()
		self:DrawTranslucent()
	end

	local offsetVec = Vector(5, -1, 0)
	local offsetAng = Angle(-90, 0, 0)
	function ENT:DrawBriefcase()
		local boneid = self:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
		if not boneid or not IsValid(self.ClientModel) then return end

		local matrix = self:GetBoneMatrix(boneid)
		if not matrix then return end

		local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

		self.ClientModel.IsBrief = true
		self.ClientModel:SetPos(newPos)
		self.ClientModel:SetAngles(newAng)
		self.ClientModel:DrawModel()
	end
end
--PATH addons/__________scripts__loader/lua/entities/arierules/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'ariebaseboard'
ENT.PrintName = 'Board Rules'
ENT.Author = 'Snaggle/arie'
ENT.Spawnable = true
ENT.AdminSpawnable = true
--PATH addons/_bitminers2ex/lua/entities/bm2_base/cl_init.lua:
include( "shared.lua" )
--PATH addons/_bitminers2/lua/entities/bm2_bitminer_2/cl_init.lua:
include( "shared.lua" )
local function __round( num, numDecimalPlaces )
	local mult = 10 ^ ( numDecimalPlaces or 0 )
	return math.floor( num * mult + 0.5 ) / mult
end

--Animate fan(s)
function ENT:Think()
	if LocalPlayer():GetPos():Distance( self:GetPos() ) < 500 then
		if self:GetIsMining() then
			self.fanAng = self.fanAng + FrameTime() * 400
			for i = 0, self:GetBoneCount() - 1 do
				if string.match( self:GetBoneName( i ), "fan" ) ~= nil then self:ManipulateBoneAngles( i, Angle( self.fanAng, 0, 0 ) ) end
			end
		end

		if self.prev ~= self:GetIsMining() then
			self:DestroyShadow()
			self:CreateShadow()
		end

		self.prev = self:GetIsMining()
	end
end

--Yuck I know but its to much effort to re-write the entire system
function ENT:Initialize()
	self.fanAng = 0
	self.prev = false
	--So each bitminer can have its own set of unique instructions. This is how we will do that
	self.customInstructions = {
		status = {
			--Outputs usefull runtime infomation
			command = "STATUS",
			description = "Outputs usefull infomation about the current device.",
			action = function( _, _, _, ent, consoleDisplay )
				consoleDisplay.history = consoleDisplay.history .. "\n------------------STATUS------------------\n"
				local firstPart = "IS MINING                                 "
				local secondPart = string.upper( tostring( ent:GetIsMining() ) )
				consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
				firstPart = "HAS POWER                                 "
				secondPart = string.upper( tostring( ent:GetHasPower() ) )
				consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
				consoleDisplay.history = consoleDisplay.history .. "------------------------------------------\n\n"
			end
		},
		info = {
			command = "INFO",
			description = "Outputs sepcifications for the device such as power usage.",
			action = function( _, _, _, ent, consoleDisplay )
				consoleDisplay.history = consoleDisplay.history .. "\n-------------------INFO------------------\n"
				local firstPart = "CLOCK SPEED                              "
				local secondPart = tostring( __round( ent:GetClockSpeed(), 3 ) ) .. "Ghz"
				consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
				local firstPart = "CORES                                    "
				local secondPart = ent:GetCoreCount()
				consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
				consoleDisplay.history = consoleDisplay.history .. "POWER REQUIREMENT                    250W\n"
				consoleDisplay.history = consoleDisplay.history .. "MODEL NAME                    Bitminer S2\n"
				local playerName = self:Getowning_ent()
				if playerName ~= NULL then
					playerName = playerName:Name()
				else
					playerName = "Unknown"
				end

				consoleDisplay.history = consoleDisplay.history .. string.sub( "OWNER                                    ", 1, string.len( "OWNER                                    " ) - string.len( playerName ) ) .. playerName .. "\n"
				consoleDisplay.history = consoleDisplay.history .. "-----------------------------------------\n\n"
			end
		},
		mining = {
			command = "MINING",
			description = "Starts or stop the miner from mining.",
			action = function( arg1, _, _, ent, consoleDisplay )
				if arg1 == nil then
					consoleDisplay.history = consoleDisplay.history .. "To use this command please supply one of the following arguments, 'mining start' or 'mining stop'\n"
				elseif arg1 == "start" then
					net.Start( "BM2.Command.Mining" )
					net.WriteEntity( ent )
					net.WriteBool( true )
					net.SendToServer()
				elseif arg1 == "stop" then
					net.Start( "BM2.Command.Mining" )
					net.WriteEntity( ent )
					net.WriteBool( false )
					net.SendToServer()
				else
					consoleDisplay.history = consoleDisplay.history .. "The option '" .. arg1 .. "' is not a valid option, the options are 'mining start' or 'mining stop'\n"
				end
			end
		},
		bitcoin = {
			--Used for selling or getting info about bitcoins
			command = "BITCOIN",
			description = "Allows you to sell or see infomation about the stored bitcoins.",
			action = function( arg1, _, _, ent, consoleDisplay )
				if arg1 == "info" then
					consoleDisplay.history = consoleDisplay.history .. "\n-------------------BITCOIN------------------\n"
					local firstPart = "Bitcoin Amount                              "
					local secondPart = comma_value( __round( ent:GetBitcoinAmount(), 2 ) ) .. "btc"
					consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
					firstPart = "Bitcoin Value ($)                           "
					secondPart = tostring( comma_value( __round( ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2 ) ) )
					consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
					consoleDisplay.history = consoleDisplay.history .. "--------------------------------------------\n\n"
				elseif arg1 == "sell" then
					net.Start( "BM2.Command.SellBitcoins" )
					net.WriteEntity( ent )
					net.SendToServer()
					local firstPart = "From                                        "
					local secondPart = tostring( comma_value( __round( ent:GetBitcoinAmount(), 2 ) ) ) .. "btc"
					consoleDisplay.history = consoleDisplay.history .. "\n-------------------RECEIPT------------------\n"
					consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
					firstPart = "Convereted to                               "
					secondPart = "$" .. tostring( comma_value( __round( ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2 ) ) )
					consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
					consoleDisplay.history = consoleDisplay.history .. "The money has been transfered to your wallet\n"
					consoleDisplay.history = consoleDisplay.history .. "--------------------------------------------\n\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history .. "To use this command please supply one of the following arguments, 'bitcoin info' or 'bticoin sell'\n"
					else
						consoleDisplay.history = consoleDisplay.history .. "The option '" .. arg1 .. "' is not a valid option, the options are 'bitcoin info' or 'bticoin sell'\n"
					end
				end
			end
		},
		upgrade = {
			--Used for selling or getting info about bitcoins
			command = "UPGRADE",
			description = "Shows available upgrades and allows you to purchase them.",
			action = function( arg1, _, _, ent, consoleDisplay )
				if arg1 == "1" then --CPU
					net.Start( "BM2.Command.Upgrade" )
					net.WriteEntity( ent )
					net.WriteBool( false )
					net.SendToServer()
				elseif arg1 == "2" then
					--Cores
					net.Start( "BM2.Command.Upgrade" )
					net.WriteEntity( ent )
					net.WriteBool( true )
					net.SendToServer()
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history .. "\n-------------------UPGRADES------------------\n"
						local i = 0
						if self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1] ~= nil then
							i = i + 1
							firstPart = "[1] " .. self.upgrades.CPU.name .. "                                                              "
							secondPart = "                                             "
							thirdtPart = "$" .. comma_value( self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1] )
							local str = string.sub( firstPart, 0, string.len( secondPart ) )
							consoleDisplay.history = consoleDisplay.history .. string.sub( str, 1, string.len( str ) - string.len( thirdtPart ) ) .. thirdtPart .. "\n"
						end

						if self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1] ~= nil then
							i = i + 1
							firstPart = "[2] " .. self.upgrades.CORES.name .. "                                                              "
							secondPart = "                                             "
							thirdtPart = "$" .. comma_value( self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1] )
							local str = string.sub( firstPart, 0, string.len( secondPart ) )
							consoleDisplay.history = consoleDisplay.history .. string.sub( str, 1, string.len( str ) - string.len( thirdtPart ) ) .. thirdtPart .. "\n"
						end

						if i == 0 then consoleDisplay.history = consoleDisplay.history .. "There are no more upgrade left for this device.\n" end
						consoleDisplay.history = consoleDisplay.history .. "---------------------------------------------\nType 'upgrade 1' or 'upgrade 2' to select one.\n"
					else
						consoleDisplay.history = consoleDisplay.history .. "The option '" .. arg1 .. "' is not a valid option, the options are 'upgrade 1' or 'upgrade 2'\n"
					end
				end
			end
		},
	}

	--Only add if DLC is loaded
	if BITMINERS_2_EXTRAS_DLC then
		self.customInstructions.remote = {
			command = "REMOTE",
			description = "Allows you to install and uninstall and change the name of a remote access module that will allow you to access the bitminer remotely using " .. BM2EXTRACONFIG.RemoteAccessCommand .. ". Installing it costs $" .. string.Comma( BM2EXTRACONFIG.RemoteAccessPrice ) .. ".",
			action = function( arg1, arg2, _, ent, consoleDisplay )
				if arg1 == "install" then
					net.Start( "BM2.Command.RemoteInstall" )
					net.WriteEntity( ent )
					net.WriteBool( true )
					net.SendToServer()
					ent.remoteName = math.random( 10, 99 ) .. "." .. math.random( 100, 800 ) .. "." .. math.random( 10, 99 ) .. "." .. math.random( 100, 800 )
				elseif arg1 == "remove" then
					net.Start( "BM2.Command.RemoteInstall" )
					net.WriteEntity( ent )
					net.WriteBool( false )
					net.SendToServer()
				elseif arg1 == "setname" then
					local _string = arg2 or math.random( 10, 99 ) .. "." .. math.random( 100, 800 ) .. "." .. math.random( 10, 99 ) .. "." .. math.random( 100, 800 )
					ent.remoteName = _string
					consoleDisplay.history = consoleDisplay.history .. "Remote name changed to '" .. _string .. "'\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history .. "---------------------------------------------\nType 'REMOTE INSTALL' to install the remote module. Installing costs $" .. string.Comma( BM2EXTRACONFIG.RemoteAccessPrice ) .. " and allows to bitminer to be remotely access using " .. BM2EXTRACONFIG.RemoteAccessCommand .. "\nType 'REMOTE REMOVE' to uninstall the remote module.\nType 'REMOTE SETNAME ExampleName' to change the remote name of the bitminer. The name cannot contain spaces!\n"
					else
						consoleDisplay.history = consoleDisplay.history .. "The option '" .. arg1 .. "' is not a valid option, the options are 'install', 'setname' or 'remove'\n"
					end
				end
			end
		}
	end
end

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_bitminers2ex/lua/entities/bm2_large_fuel/cl_init.lua:
include( "shared.lua" )
function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_doctor/lua/entities/bp_bunsen_burner/cl_init.lua:
include("shared.lua")

local flame = Material("blues_pharm/flame")
local timeLeft = Material("blues_pharm/ui/time.png", "smooth")
local mix = Material("blues_pharm/ui/mix.png", "smooth")

function ENT:Initialize()
	self.lerpedMixAmount = 0

	self:EmitSound("bp_burner")
end

function ENT:DrawFlame()
	local ang = self:GetAngles()
	local pos2 = self:GetPos() + (ang:Up() * 16.3)
	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos2):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	--Flame
	cam.Start3D2D(pos2, ang2, 0.03)
		surface.SetMaterial(flame)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-32, -128, 64, 256)
	cam.End3D2D()
end

function ENT:Draw()
	self:DrawModel()

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 27.7) + (ang:Forward() * 9.5)
	ang:RotateAroundAxis(ang:Right(), 90)
	ang:RotateAroundAxis(ang:Up(), -90)

	--Get the dot of the player, don't render if there behind
	local playerPos = LocalPlayer():GetPos() - self:GetPos()
	local ourPos = self:GetAngles():Forward()
	local dot = playerPos:Dot(ourPos:GetNormalized())

	if dot < 9.4 and not (self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist ) then

		local beaker = self:GetConnectedBeaker()

		if IsValid(beaker) then

			local recipe = BLUES_PHARMA.Medicines[beaker:GetRecipe()]

			--Backdrop
			cam.Start3D2D(pos, ang, 0.03)
				draw.RoundedBoxEx(32, -180, -280, 370, 260, Color(43, 43, 43, 255), true, true, false, false)

				local percent = math.Clamp((CurTime() - self:GetBurnStartTime()) / self:GetBurnCookTime(), 0, 1)
				local color = BLUES_PHARMA:LerpColor(Color(255,50,30, 80), Color(50,205,50, 80), percent)

				self.lerpedMixAmount = Lerp(2 * FrameTime(), self.lerpedMixAmount, 1 - self:GetMixAmount())

				local color2 = BLUES_PHARMA:LerpColor(Color(50,205,50), Color(255,99,71), 1 - self.lerpedMixAmount)

				--Time bar
				draw.RoundedBox(0, -180, -130, 150, 880 + 128, Color(43, 43, 43, 255))
				draw.RoundedBox(0, -180 + 8, 8, 150 - 16, 880 - 16, Color(64,64,64, 255))
				draw.RoundedBox(0, -180 + 12, 12, 150 - 24, 880 - 24, Color(32,32,32, 255))

				--Draw icon
				surface.SetMaterial(timeLeft)
				surface.SetDrawColor(Color(255,255,255,90))
				surface.DrawTexturedRect(-155, -110, 100, 100)

				draw.RoundedBox(0, -180 + 12, 12 + ((880 - 24) -  (880 - 24) * percent), 150 - 24, (880 - 24) * percent, color)

				--Time bar
				draw.RoundedBox(0, 40, -130, 150, 880 + 128, Color(43, 43, 43, 255))
				draw.RoundedBox(0, 40 + 8, 8, 150 - 16, 880 - 16, Color(64,64,64, 255))
				draw.RoundedBox(0, 40 + 12, 12, 150 - 24, 880 - 24, Color(32,32,32, 255))

				--Draw icon
				surface.SetMaterial(mix)
				surface.SetDrawColor(Color(255,255,255,90))
				surface.DrawTexturedRect(70, -110, 100, 100)

				draw.RoundedBox(0, 40 + 12, 12 + ((880 - 24) -  (880 - 24) * self.lerpedMixAmount), 150 - 24, (880 - 24) * self.lerpedMixAmount, color2)

				--Draw recipe name

				draw.SimpleText(recipe.name, "BP_Chemical_UI_Name3", 0, -235, Color(255,255,255,90), 1, 1)
				draw.SimpleText("Press 'E' to mix", "BP_Chemical_UI_Name", 0, -175, Color(255,255,255,90), 1, 1)
				draw.SimpleText("Don't let it burn!", "BP_Chemical_UI_Name2", 0, -140, Color(255,255,255,90), 1, 1)
			cam.End3D2D()
		end
	end


	--Always draw flame
	self:DrawFlame()
end

function ENT:OnRemove()
	self:StopSound("bp_burner")
end
--PATH addons/_doctor/lua/entities/bp_chemical_prog/cl_init.lua:
include("shared.lua")

local levelIcon = Material("blues_pharm/ui/level.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 15)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-160, -270, 280, 65)

		draw.RoundedBox(0, -160, -270, 20, 570, Color(43, 43, 43))

		draw.SimpleText(BLUES_PHARMA.Chemicals[self.ChemicalID].name, "BP_Chemical_Title",  -135, -270, Color(255, 255, 255), 0, 0)

		surface.SetMaterial(levelIcon)
		surface.SetDrawColor(Color(255, 255, 255, 60))
		surface.DrawTexturedRect(-135, -240, 32, 32)

		draw.SimpleText(self:GetLiquidAmount().."ml", "BP_Chemical_Amount",  - 100, -240, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end
--PATH addons/_doctor/lua/entities/bp_chemical_sele/cl_init.lua:
include("shared.lua")

local levelIcon = Material("blues_pharm/ui/level.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 25)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-180, -270, 300, 65)

		draw.RoundedBox(0, -180, -270, 20, 770, Color(43, 43, 43))

		draw.SimpleText(BLUES_PHARMA.Chemicals[self.ChemicalID].name, "BP_Chemical_Title",  -155, -270, Color(255, 255, 255), 0, 0)

		surface.SetMaterial(levelIcon)
		surface.SetDrawColor(Color(255, 255, 255, 60))
		surface.DrawTexturedRect(-155, -240, 32, 32)

		draw.SimpleText(self:GetLiquidAmount().."ml", "BP_Chemical_Amount",  - 120, -240, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end
--PATH addons/____bricks_framework/lua/entities/bricks_server_npc/cl_init.lua:
include('shared.lua')

local Padding = 10
function ENT:Draw()
	self:DrawModel()

	local ShopName = ((BRICKS_SERVER.CONFIG.NPCS or {})[(self:GetNPCKeyVar() or 0)] or {}).Name or self.PrintName

    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    Ang:RotateAroundAxis(Ang:Up(), 90)
	Ang:RotateAroundAxis(Ang:Forward(), 90)

	local YPos = -(self:OBBMaxs().z*20)-5

	local Distance = LocalPlayer():GetPos():DistToSqr( self:GetPos() )

	if( Distance < BRICKS_SERVER.CONFIG.GENERAL["3D2D Display Distance"] ) then
		cam.Start3D2D(Pos + Ang:Up() * 0.5, Ang, 0.05)
		
			surface.SetFont("BRICKS_SERVER_Font45")
		
			local width, height = surface.GetTextSize( ShopName )
			width, height = width+20, height+15

			draw.RoundedBox( 5, -(width*0.5)-Padding, YPos-(height+(2*Padding)), width+(2*Padding), height+(2*Padding), BRICKS_SERVER.Func.GetTheme( 1 ) )		
			draw.RoundedBox( 5, -(width*0.5)-Padding, YPos-(height+(2*Padding)), 20, height+(2*Padding), BRICKS_SERVER.Func.GetTheme( 5 ) )	

			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
			surface.DrawRect( -(width*0.5)-Padding+5, YPos-(height+(2*Padding)), 15, height+(2*Padding) )

			draw.SimpleText( ShopName, "BRICKS_SERVER_Font45", 0, YPos-((height+(2*Padding))*0.5), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 1 )
			
		cam.End3D2D()
	end
end
--PATH addons/____bricks_gangs/lua/entities/bricks_server_territory/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
	self.flagMaterial = CreateMaterial( "brs_flag_material_entid" .. self:EntIndex(), "UnlitGeneric", {} )
	self.flagRenderTarget = GetRenderTarget( "brs_flag_rendertarget_entid" .. self:EntIndex(), 1004, 704, false )

	self.flagMaterial:SetTexture( "$basetexture", self.flagRenderTarget )
end

local iconMat
local iconRequested = false
function ENT:Draw()
	self:DrawModel()

    local position = self:GetPos()
    local angles = self:GetAngles()

	angles:RotateAroundAxis( angles:Forward(), 90)

	angles.y = LocalPlayer():EyeAngles().y - 90

	local Distance = LocalPlayer():GetPos():DistToSqr( self:GetPos() )

	local w, h = 200, 50
	local x, y = 25, 0

	local territoryKey = self:GetTerritoryKey()
	local territoryTable = BRICKS_SERVER.Func.GangTerritoryExists( territoryKey )

	if( not territoryTable ) then return end
	
	local territoryConfig = BRICKS_SERVER.CONFIG.GANGS.Territories[territoryKey] or {}
	local territoryGangTable = (BRICKS_SERVER_GANGS or {})[(territoryTable or {}).GangID or 0] or {}

	if( Distance < BRICKS_SERVER.CONFIG.GENERAL["3D2D Display Distance"] ) then
		surface.SetAlphaMultiplier( math.Clamp( 1-(Distance/BRICKS_SERVER.CONFIG.GENERAL["3D2D Display Distance"]), 0, 1 ) )
		cam.Start3D2D( self:GetPos()+self:GetUp()*55, angles, 0.1 )
			draw.RoundedBox( 5, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

			local capturePercent = (territoryTable.Claimed and 1) or 0

			if( IsValid( self:GetCaptor() ) ) then
				if( (self:GetCaptureEndTime() or 0) > 0 ) then
					capturePercent = math.Clamp( (BRICKS_SERVER.CONFIG.GANGS["Territory Capture Time"]-(self:GetCaptureEndTime()-CurTime()))/BRICKS_SERVER.CONFIG.GANGS["Territory Capture Time"], 0, 1 )
				else
					capturePercent = math.Clamp( 1-((BRICKS_SERVER.CONFIG.GANGS["Territory Capture Time"]-(self:GetUnCaptureEndTime()-CurTime()))/BRICKS_SERVER.CONFIG.GANGS["Territory Capture Time"]), 0, 1 )
				end
			end

			local border = 5
			draw.RoundedBox( 5, x+border, y+border, (w-2*border)*capturePercent, h-(2*border), territoryConfig.Color or BRICKS_SERVER.Func.GetTheme( 5 ) )
		cam.End3D2D()

		local bottomW, bottomH, iconSize = 240, 310, 64
		local bottomX, bottomY = -(bottomW*0.5), 0

		local function drawBottomInfo()
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
			surface.DrawRect( bottomX, bottomY, bottomW, bottomH )
			draw.SimpleText( territoryConfig.Name, "BRICKS_SERVER_Font40", bottomX+bottomW*0.5, 65, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( BRICKS_SERVER.Func.L( "gangTerritoryUpper" ), "BRICKS_SERVER_Font25", bottomX+bottomW*0.5, 65, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, 0 )

			if( territoryTable.Claimed ) then
				draw.SimpleText( BRICKS_SERVER.Func.L( "gangCaptured" ), "BRICKS_SERVER_Font20", bottomX+bottomW*0.5, bottomY+(bottomH*0.5)-(iconSize*0.5)+25-5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

				if( territoryTable.IconMat ) then
					surface.SetDrawColor( 255, 255, 255, 255 )
					surface.SetMaterial( territoryTable.IconMat )
					surface.DrawTexturedRect( bottomX+(bottomW*0.5)-(iconSize*0.5), bottomY+(bottomH*0.5)-(iconSize*0.5)+25, iconSize, iconSize )
				else
					BRICKS_SERVER.Func.RequestTerritoryIconMat( territoryKey )
				end

				draw.SimpleText( (territoryGangTable.Name or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font25", bottomX+bottomW*0.5, bottomY+(bottomH*0.5)+(iconSize*0.5)+25+5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, 0 )
			end
		end

		local angles = self:GetAngles()
		angles:RotateAroundAxis( angles:Forward(), 90)

		cam.Start3D2D( self:GetPos()+self:GetUp()*17.4+self:GetRight()*12.8, angles, 0.05 )
			drawBottomInfo()
		cam.End3D2D()

		angles:RotateAroundAxis( angles:Right(), 90)

		cam.Start3D2D( self:GetPos()+self:GetUp()*17.4-self:GetForward()*12.8, angles, 0.05 )
			drawBottomInfo()
		cam.End3D2D()
		
		angles:RotateAroundAxis( angles:Right(), 90)

		cam.Start3D2D( self:GetPos()+self:GetUp()*17.4-self:GetRight()*12.8, angles, 0.05 )
			drawBottomInfo()
		cam.End3D2D()

		angles:RotateAroundAxis( angles:Right(), 90)

		cam.Start3D2D( self:GetPos()+self:GetUp()*17.4+self:GetForward()*12.8, angles, 0.05 )
			drawBottomInfo()
		cam.End3D2D()
		surface.SetAlphaMultiplier( 1 )

		-- Draw flag color and logo
		local w, h, iconSize = 1004, 704, 400
		render.PushRenderTarget( self.flagRenderTarget )
			render.Clear( 0, 0, 0, 0, true, true ) 
			cam.Start2D()
				surface.SetDrawColor( territoryConfig.Color or BRICKS_SERVER.Func.GetTheme( 5 ) )
				surface.DrawRect( 0, 0, w, h )

				if( territoryTable.Claimed ) then
					if( territoryTable.IconMat ) then
						surface.SetDrawColor( 255, 255, 255, 255 )
						surface.SetMaterial( territoryTable.IconMat )
						surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
					else
						BRICKS_SERVER.Func.RequestTerritoryIconMat( territoryKey )
					end
				end
			cam.End2D()
		render.PopRenderTarget()
		
		self:SetSubMaterial( 2, "!brs_flag_material_entid" .. self:EntIndex() )
	end
end
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}
bshields.shields = {
	{
		[1] = {
			["angles"] = Angle( 4, 6, -14 ),
			["position"] = Vector( 0, 8, -1 )
		},
		[2] = {
			["angles"] = Angle( 6, 6, -12 ),
			["position"] = Vector( 8, 10, -4 )
		},
		[3] = {
			["angles"] = Angle( -3, 7, -16 ),
			["position"] = Vector( -1, 4, -3 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -4, -8 )
		},
		[2] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 16, -3, -12 )
		},
		[3] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -3, -12 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -7, -13 )
		},
		[2] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -6, -22 )
		},
		[3] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -8, -12 )
		}
	}
}
--PATH addons/__main_only_1st/lua/entities/death_note_ent.lua:
if SERVER then
	AddCSLuaFile()
	function ENT:Initialize()
		self:SetModel( "models/death_note/DeathNote.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then phys:Wake() end
	end

	function ENT:AcceptInput( _, caller )
		if caller:IsPlayer() and not caller.CantUse then
			caller.CantUse = true
			caller.MenuOpen = true
			caller.CanUse = true
			timer.Simple( 3, function() caller.CantUse = false end )
			if caller:IsValid() then
				net.Start( "deathnote_gui" )
				net.WriteTable( deathtypes )
				net.WriteString( "ent" )
				net.Send( caller )
			end
		end
	end

	function ENT:Use()
		return
	end

	function ENT:Think()
	end
elseif CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end
end

ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Death-Note"
ENT.Author = "Blue-Pentagram And TheRowan"
ENT.Spawnable = true
ENT.AdminOnly = true
ENT.Category = "Death Note"
--PATH addons/_drones/lua/entities/dronesrewrite_defender/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
//ENT.PrintName = "DF 'Defender'"
ENT.PrintName = "Defender"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "DF"
ENT.Weight = 350

ENT.Model = "models/dronesrewrite/defender/defender.mdl"

ENT.FirstPersonCam_pos = Vector(34, 0, 3)
ENT.RenderCam = false

ENT.ExplosionForce = 16
ENT.ExplosionAngForce = 1.7
ENT.DoExplosionEffect = "stinger_explode_drr"

ENT.HackValue = 3

ENT.Alignment = 0 --1.6
ENT.AlignmentRoll = 0.7
ENT.AlignmentPitch = 1.6

ENT.NoiseCoefficient = 0.4
ENT.AngOffset = 3

ENT.Speed = 7800
ENT.UpSpeed = 40000
ENT.RotateSpeed = 6

ENT.PitchOffset = 0.4

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.PitchMin = -30
ENT.PitchMax = 50

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.Fuel = 120
ENT.MaxFuel = 120

ENT.HealthAmount = 110
ENT.DefaultHealth = 110

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/manhack/mh_engine_loop1.wav",
		Pitch = 120,
		Level = 71,
		Volume = 0.65
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_7.wav",
		Level = 85
	}
}


ENT.Propellers = {
	Damage = 1,
	Health = 50,
	HitRange = 18,
	Scale = 0.9,
	Model = "models/dronesrewrite/propellers/propeller2_4.mdl",

	Info = {
		Vector(-0.2, 48, 10),
		Vector(-0.2, -48, 10),
		Vector(-24.5, 0, 10)
	}
}

ENT.Attachments = {
	["Blaster"] = {
		Pos = Vector(6, 13, -5)
	},

	["Shield"] = {
		Pos = Vector(6, -13, -5)
	}
}

ENT.Weapons = {
	["Electric Blaster"] = {
		Name = "Electric Blaster",
		Attachment = "Blaster"
	},

	["Shield"] = {
		Name = "Shield",
		Attachment = "Shield"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()

--PATH addons/_drones/lua/entities/dronesrewrite_doll/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Doll Drone"
ENT.Spawnable = false
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.RenderInCam = false
ENT.UNIT = "DOLL"
ENT.HUD_hudName = "No HUD"
ENT.OverlayName = "No Overlay"

ENT.Weight = 30

ENT.Model = "models/props_c17/doll01.mdl"

ENT.FirstPersonCam_pos = Vector(0, 0, 6)
ENT.RenderCam = false

ENT.DoExplosionEffect = false
ENT.ExplosionForce = 0
ENT.ExplosionAngForce = 0

ENT.Alignment = 5

ENT.NoiseCoefficient = 0
ENT.AngOffset = 6

ENT.Speed = 150
ENT.UpSpeed = 600
ENT.RotateSpeed = 7

ENT.PitchOffset = 0

ENT.AllowPitchRestrictions = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.ShouldConsumeFuel = false
ENT.Fuel = 1
ENT.MaxFuel = 1

ENT.HealthAmount = 60
ENT.DefaultHealth = 60

ENT.UseFlashlight = false
ENT.UseNightVision = false

ENT.Sounds = {}

ENT.NoPropellers = true
ENT.Propellers = {
	Model = "models/props_junk/PopCan01a.mdl",
	Info = { Vector(0, 0, 0) }
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_dxl/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)
	
	if self:IsDroneWorkable() then
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:LocalToWorld(Vector(16, 0, 6))
			dlight.r = 0
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 80
			dlight.DieTime = CurTime() + 0.1
		end

		render.SetMaterial(Material("particle/particle_glow_04_additive"))
		render.DrawSprite(self:LocalToWorld(Vector(12, 0, 5)), 16, 16, Color(0, 255, 255, 100))
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_laser/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Laser Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "LSR"

ENT.Weight = 200

ENT.Model = "models/dronesrewrite/laserdr/laserdr.mdl"

ENT.FirstPersonCam_pos = Vector(20, 0, 0)
ENT.ThirdPersonCam_distance = 86
ENT.ThirdPersonCam_pos = Vector(-16, 0, 1)
ENT.RenderCam = false

ENT.NoiseCoefficient = 0.2
ENT.AngOffset = 5
ENT.Alignment = 1.2

ENT.Speed = 2300
ENT.UpSpeed = 10000
ENT.RotateSpeed = 6

ENT.HackValue = 2

ENT.Fuel = 80
ENT.MaxFuel = 80
ENT.FuelReduction = 0.3

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.PitchMin = -30
ENT.PitchMax = 70

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/manhack/mh_engine_loop2.wav",
		Pitch = 150,
		Level = 70,
		Volume = 0.6
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 80
	}
}


ENT.Propellers = {
	Scale = 0.8,
	Damage = 1,
	Health = 17,
	HitRange = 10,
	Model = "models/dronesrewrite/propellers/propeller2_2.mdl",

	Info = {
		Vector(13.8, 13.8, 0.8),
		Vector(-13.8, -13.8, 0.8),
		Vector(-13.8, 13.8, 0.8),
		Vector(13.8, -13.8, 0.8)
	}
}

ENT.Attachments = {
	["Laser"] = {
		Pos = Vector(0, 0, -2)
	}
}

ENT.Weapons = {
	["Laser"] = {
		Name = "Laser",
		Attachment = "Laser"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_microwave/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Microwave"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "MWV"

ENT.Model = "models/dronesrewrite/microwave/microwave.mdl"

ENT.FirstPersonCam_pos = Vector(20, 17.5, 2.5)
ENT.ThirdPersonCam_distance = 70
ENT.RenderCam = false
ENT.AllowLowHealthExplosion = false

ENT.Speed = 1000
ENT.UpSpeed = 5000
ENT.SprintCoefficient = 1.2
ENT.RotateSpeed = 5

ENT.AngOffset = 2

ENT.HackValue = 2

ENT.Fuel = 50
ENT.MaxFuel = 50
ENT.FuelReduction = 0.1

ENT.HUD_hudName = "Drones 2"

ENT.UseNightVision = false
ENT.UseFlashlight = false

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowPitchRestrictions = false

ENT.AI_CustomEnemyChecker = function(drone, v)
	return drone:GetPos():Distance(v:GetPos()) < 250 and DRONES_REWRITE.AI.ShouldAttack(drone, v)
end

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/manhack/mh_engine_loop1.wav",
		Pitch = 200,
		Level = 60,
		Volume = 0.4
	}
}

ENT.Propellers = {
	Damage = 1,
	Health = 25,
	HitRange = 10,
	Model = "models/dronesrewrite/propellers/propeller2_2.mdl",

	Info = {
		Vector(0, 0, 16)
	}
}

ENT.Weapons = {	["Microwave"] = { Name = "Microwave" } }

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_orbs/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_orbs/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Orbital Strike Marker"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "ORBS"

ENT.HUD_hudName = "Simple"

ENT.Model = "models/dronesrewrite/orbsdr/orbsdr.mdl"

ENT.Weight = 300

ENT.Speed = 5200
ENT.UpSpeed = 25000
ENT.AngOffset = 3
ENT.RotateSpeed = 3
ENT.Alignment = 1
ENT.PitchOffset = 0.6

ENT.NoiseCoefficient = 0
ENT.NoiseCoefficientAng = 0.1
ENT.NoiseCoefficientPos = 2

ENT.ThirdPersonCam_distance = 200
ENT.FirstPersonCam_pos = Vector(20, 0, 8)
ENT.RenderCam = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowYawRestrictions = true
ENT.YawMin = -70
ENT.YawMax = 70

ENT.HackValue = 4

ENT.PitchMin = -60
ENT.PitchMax = 60

ENT.Fuel = 80
ENT.MaxFuel = 80
ENT.FuelReduction = 0.2

ENT.UseFlashlight = false

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/manhack/mh_engine_loop1.wav",
		Pitch = 60,
		Level = 72
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 80
	}
}


ENT.Propellers = {
	Damage = 2,
	Health = 30,
	HitRange = 14,
	Model = "models/dronesrewrite/propellers/propeller2_3.mdl",

	Info = {
		Vector(7, 30.5, 19),
		Vector(7, -30.5, 19)
	}
}

ENT.Weapons = {
	["Orbital Strike"] = {
		Name = "Orbital Strike"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_spyspider/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.DrrBaseType = "walker"
ENT.Type = "anim"
ENT.PrintName = "Spider Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UseSpiderPhysics = true

ENT.DoExplosionEffect = "splode_drone_sparks"

ENT.UNIT = "SPD"

ENT.Model = "models/dronesrewrite/spider/spider.mdl"

ENT.SpawnHeight = 16
ENT.Weight = 32

ENT.OverlayName = "Red"
ENT.HUD_hudName = "White Box"

ENT.FirstPersonCam_pos = Vector(7, 0, 1)
ENT.ThirdPersonCam_distance = 100
ENT.RenderCam = false

ENT.Speed = 2500
ENT.UpSpeed = 0
ENT.SprintCoefficient = 1
ENT.RotateSpeed = 50
ENT.PitchOffset = 0
ENT.Hover = 12

ENT.HackValue = 2

ENT.AngSlip = 0.1

ENT.ExplosionForce = 2
ENT.ExplosionAngForce = 0.03

ENT.AllowPitchRestrictions = true
ENT.PitchMin = -70
ENT.PitchMax = 70

ENT.AllowYawRestrictions = true
ENT.YawMin = -40
ENT.YawMax = 40

ENT.NoiseCoefficient = 0

ENT.WaitForSound = 0.1

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.HealthAmount = 50
ENT.DefaultHealth = 50

ENT.Fuel = 20
ENT.MaxFuel = 20
ENT.FuelReduction = 0.2

ENT.UseFlashlight = false

ENT.AI_DistanceEnemy = 30

ENT.AI_CustomEnemyChecker = function(drone, v)
	return drone:GetPos():Distance(v:GetPos()) < 40
end

ENT.Sounds = {
	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 82
	},

	FootSound = {
		Sounds = {
			"physics/concrete/rock_impact_hard1.wav",
			"physics/concrete/rock_impact_hard2.wav",
			"physics/concrete/rock_impact_hard3.wav",
			"physics/concrete/rock_impact_hard4.wav"
		},

		Pitch = 250,
		Volume = 52
	}
}

ENT.Corners = {
	Vector(-10, -4, 0),
	Vector(-10, 4, 0),

	Vector(8, 4, 0),
	Vector(8, -4, 0)
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
ENT.Weapons = { ["Bite"] = { Name = "Spider Bite", Pos = Vector(8, 0, 2) } }

--PATH addons/_drones/lua/entities/dronesrewrite_turret/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)

	if self:IsDroneWorkable() then
		local pos = self:GetAttachment(self:LookupAttachment("light")).Pos
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = pos
			dlight.r = 0
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 80
			dlight.DieTime = CurTime() + 0.1
		end

		render.SetMaterial(Material("particle/particle_glow_04_additive"))
		render.DrawSprite(pos, 8, 8, Color(0, 255, 0, 100))
	end
end

function ENT:Think()
	self.BaseClass.Think(self)

	local cam = self:GetCamera()

	if cam:IsValid() then
		local ang = self:WorldToLocalAngles(cam:GetAngles())

		self:SetPoseParameter("aim_yaw", ang.y)
		self:SetPoseParameter("aim_pitch", ang.p)

		self:InvalidateBoneCache()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_warriordr/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Steel Warrior"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "SW"

ENT.HUD_hudName = "White Box"

ENT.Model = "models/dronesrewrite/warriordr/warriordr.mdl"

ENT.Weight = 650
ENT.SpawnHeight = 40

ENT.Speed = 7000
ENT.UpSpeed = 35000
ENT.AngOffset = 4
ENT.RotateSpeed = 3
ENT.Alignment = 1
ENT.PitchOffset = 0.4

ENT.NoiseCoefficient = 0
ENT.NoiseCoefficientAng = 0.2
ENT.NoiseCoefficientPos = 20

ENT.HackValue = 3

ENT.ThirdPersonCam_distance = 120
ENT.FirstPersonCam_pos = Vector(28, 0, 22)
ENT.RenderCam = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.UseFlashlight = false

ENT.AllowYawRestrictions = true
ENT.YawMin = -68
ENT.YawMax = 68

ENT.PitchMin = -60
ENT.PitchMax = 70

ENT.HealthAmount = 650
ENT.DefaultHealth = 650
//ENT.DoExplosionEffect = "splode_big_drone_main"

ENT.Fuel = 200
ENT.MaxFuel = 200
ENT.FuelReduction = 0.4

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/attack_helicopter/aheli_rotor_loop1.wav",
		Pitch = 160,
		Level = 74,
		Volume = 0.45
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 80
	}
}

ENT.Propellers = {
	Scale = 0.97,
	Damage = 2,
	Health = 60,
	HitRange = 18,
	Model = "models/dronesrewrite/propellers/propeller1_4.mdl",

	Info = {
		Vector(-3.3, 23.8, 35),
		Vector(-3.3, -23.8, 35)
	},

	InfoAng = {
		Angle(0, 0, -5),
		Angle(0, 0, 5)
	}
}

ENT.Attachments = {
	["Minigun1"] = {
		Pos = Vector(0, -3, 0),
		Angle = Angle(0, 0, -90)
	},

	["Minigun2"] = {
		Pos = Vector(0, 3, 0),
		Angle = Angle(0, 0, 90)
	}
}

ENT.Weapons = {
	["Miniguns"] = {
		Name = "3-barrel Minigun",
		Sync = { 
			["1"] = { fire1 = "fire1" }
		},
		Attachment = "Minigun1"
	},

	["1"] = {
		Name = "3-barrel Minigun",
		Select = false,
		Attachment = "Minigun2"
	},
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/__main/lua/entities/durgz_lsd/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "LSD"
ENT.Nicknames = {"LSD", "acid", "a tab", "a few tabs", "an entire vial of LSD", "a glass of LSD"}
ENT.OverdosePhrase = {"saw God whilst on", "peed in their mouth after taking", "drank"}
ENT.Author = "Jenna Huxley"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Information	 = " lol high scientists" 
ENT.Category = "Drugs"
ENT.TRANSITION_TIME = 6

--function for high visuals

if(CLIENT)then

	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	local HIGH_INTENSITY = 0.77; --1 is max, 0 is nothing at all
	
	
	local function DoLSD()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		--self:SetNWFloat( "SprintSpeed"
		local pl = LocalPlayer();
		
		
		local tab = {}
		tab[ "$pp_colour_addr" ] = 0
		tab[ "$pp_colour_addg" ] = 0
		tab[ "$pp_colour_addb" ] = 0
		//tab[ "$pp_colour_brightness" ] = 0
		//tab[ "$pp_colour_contrast" ] = 1
		tab[ "$pp_colour_mulr" ] = 0
		tab[ "$pp_colour_mulg" ] = 0
		tab[ "$pp_colour_mulb" ] = 0
		
		
		if( pl:GetNWFloat("durgz_lsd_high_start") && pl:GetNWFloat("durgz_lsd_high_end") > CurTime() )then
		
			if( pl:GetNWFloat("durgz_lsd_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_lsd_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				local pf = (c-s) / (e-s);
				
				tab[ "$pp_colour_colour" ] =   1 + pf*3
				tab[ "$pp_colour_brightness" ] = -pf*0.19
				tab[ "$pp_colour_contrast" ] = 1 + pf*5.31
				DrawBloom(0.65, (pf^2)*0.1, 9, 9, 4, 7.7,255,255,255)
				DrawColorModify( tab ) 
				
			elseif( pl:GetNWFloat("durgz_lsd_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_lsd_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				local pf = 1 - (c-s) / (e-s);
				
				tab[ "$pp_colour_colour" ] =   1 + pf*3
				tab[ "$pp_colour_brightness" ] = -pf*0.19
				tab[ "$pp_colour_contrast" ] = 1 + pf*5.31
				DrawBloom(0.65, (pf^2)*0.1, 9, 9, 4, 7.7,255,255,255)
				DrawColorModify( tab ) 
				
			else
				
				
				tab[ "$pp_colour_colour" ] =   1 + 3
				tab[ "$pp_colour_brightness" ] = -0.19
				tab[ "$pp_colour_contrast" ] = 1 + 5.31
				DrawBloom(0.65, 0.1, 9, 9, 4, 7.7,255,255,255)
				DrawColorModify( tab ) 
				
			end
			
			
		end
	end
	
	
	/*local function DoMsgLSD()
		local pl = LocalPlayer();
		
		
		
		if( pl:GetNWFloat("durgz_lsd_high_start") && pl:GetNWFloat("durgz_lsd_high_end") > CurTime() )then
		
			local say = "main"
			
			if( pl:GetNWFloat("durgz_lsd_high_start") + TRANSITION_TIME > CurTime() )then
			
				say = "trans"
				
			elseif( pl:GetNWFloat("durgz_lsd_high_end") - TRANSITION_TIME < CurTime() )then
			
				say = "trans"
				
			end
			draw.DrawText(say, "ScoreboardHead", ScrW() * 0.5+1 , ScrH()*0.6+1, Color(255,255,255,255),TEXT_ALIGN_CENTER) 
			draw.DrawText(say, "ScoreboardHead", ScrW() * 0.5-1 , ScrH()*0.6-1, Color(255,255,255,255),TEXT_ALIGN_CENTER) 
			draw.DrawText(say, "ScoreboardHead", ScrW() * 0.5-1 , ScrH()*0.6+1, Color(255,255,255,255),TEXT_ALIGN_CENTER) 
			draw.DrawText(say, "ScoreboardHead", ScrW() * 0.5+1 , ScrH()*0.6-1, Color(255,255,255,255),TEXT_ALIGN_CENTER) 
			draw.DrawText(say, "ScoreboardHead", ScrW() * 0.5 , ScrH()*0.6, Color(255,9,9,255),TEXT_ALIGN_CENTER) 
		end
	end
	hook.Add("HUDPaint", "durgz_lsd_msg", DoMsgLSD)*/
	
	hook.Add("RenderScreenspaceEffects", "durgz_lsd_high", DoLSD)
end

--PATH addons/_eml/lua/entities/eml_iodine/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	local iodineColor = EML_Iodine_Color;
	
	if (self:GetNWInt("amount")>0) then
		iodineColor = EML_Iodine_Color;
	else
		iodineColor = Color(100, 100, 100, 255);
	end;
	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		cam.Start3D2D(pos+ang:Up()*3.35, ang, 0.07)
			draw.SimpleTextOutlined("Рідкий", "methFont", 0, -14, iodineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Йод", "methFont", 0, 10, iodineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined(""..self:GetNWInt("amount").."l", "methFont", 0, 34, iodineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), -90);
	ang:RotateAroundAxis(ang:Right(), 90);		
		cam.Start3D2D(pos+ang:Up()*3.35, ang, 0.1)
			surface.SetDrawColor(0, 0, 0, 200);
			surface.DrawRect(-40, -8, 64, 16);
			
			surface.SetDrawColor(EML_Iodine_Color);
			surface.DrawRect(-38, -6, math.Round((self:GetNWInt("amount")*60)/self:GetNWInt("maxAmount")), 12);				
		cam.End3D2D();
	end;
end;

-- maxAmount = 60
-- amount = x


--PATH gamemodes/darkrp/entities/entities/ent_c4/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH gamemodes/darkrp/entities/entities/ent_c4/shared.lua:
ENT.Type 		= "anim"
ENT.PrintName	= "C4"
ENT.Author		= "aStonedPenguin"
ENT.Spawnable 	= false

function ENT:Initialize()
	self:EmitSound("C4.Plant")
end
--PATH addons/igs-core/lua/entities/ent_igs/shared.lua:
ENT.Type      = "anim"
ENT.Base      = "base_anim"
ENT.PrintName = "Донат итем"
ENT.Author    = "GMDonate"
ENT.Category  = "IGS"

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar("String", 0, "UID")
end

--PATH addons/__main_only_1st/lua/entities/ent_riotshield/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Riot Shield"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
--PATH addons/_drones/lua/entities/item_drr_ammobase.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "AMMO"
ENT.Spawnable = false
ENT.Category = "Drones Rewrite Ammo"

ENT.Model = ""
ENT.Material = nil
ENT.Hp = 200
ENT.Amount = 0
ENT.RemoveTouched = false

ENT.IS_DRR_AMMO = true

function ENT:GetAmount()
	return self:GetNWInt("Amount")
end

function ENT:GetMaxAmount()
	return self:GetNWInt("MaxAmount")
end

if SERVER then
	function ENT:TakeAmount(n)
		self:SetAmount(self:GetAmount() - n)
	end

	function ENT:SetAmount(n)
		self:SetNWInt("Amount", n)
	end

	function ENT:OnTouched()
		if self.RemoveTouched then SafeRemoveEntity(self) end
	end

	function ENT:SpawnFunction(ply, tr, class)
		if not tr.Hit then return end

		local pos = tr.HitPos + tr.HitNormal * 32

		local ent = ents.Create(class)
		ent.Owner = ply
		ent:SetPos(pos)
		ent:SetAngles(Angle(0, (ply:GetPos() - tr.HitPos):Angle().y, 0))
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()
		local a = self.Amount
		self:SetAmount(a)
		self:SetNWInt("MaxAmount", a)

	    self:SetModel(self.Model)
	    if self.Material then self:SetMaterial(self.Material) end

	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    self:GetPhysicsObject():Wake()
	end

	function ENT:Explode()
		self.OnTakeDamage = function() end

		ParticleEffect("splode_big_main", self:GetPos(), Angle(0, 0, 0))		
		
		self:EmitSound("ambient/explosions/explode_3.wav", 100)

		util.BlastDamage(self, self, self:GetPos(), 300, 100)
		util.ScreenShake(self:GetPos(), 60, 20, 1, 1000) 
		
		SafeRemoveEntity(self)
	end

	function ENT:PhysicsCollide(data, physobj)
		if data.DeltaTime < 0.5 or data.Speed < 200 then return end
		self:TakeDamage(data.Speed * 0.02)
	end

	function ENT:OnTakeDamage(dmg)
		self.Hp = self.Hp - dmg:GetDamage()
		if self.Hp <= 0 then self:Explode() end
	end
else
	function ENT:Draw()
		self:DrawModel()

		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), (LocalPlayer():GetPos() - self:GetPos()):Angle().y - ang.y + 90)
		ang:RotateAroundAxis(ang:Forward(), 90)

		local height = self:OBBMaxs().z * 1.5

		cam.Start3D2D(self:GetPos() + self:GetUp() * height, ang, 0.1)
			surface.SetDrawColor(Color(0, 150, 255))
			surface.DrawOutlinedRect(-100, -30, 200, 70)
			local amount = (self:GetAmount() / self:GetMaxAmount()) * 200
			surface.DrawRect(-95, -25, amount - 10, 60)

			draw.SimpleText(self.PrintName, "DronesRewrite_font1", -86, -86, nil, TEXT_ALIGN_LEFT)
			draw.SimpleText(self:GetAmount() .. " / " .. self:GetMaxAmount(), "DronesRewrite_font1", 110, -16, nil, TEXT_ALIGN_LEFT)
		cam.End3D2D()
	end
end
--PATH addons/_drones/lua/entities/item_drr_mines.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Mines"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 5
ENT.Model = "models/dronesrewrite/ammobox/ammobox.mdl"
ENT.Material = "models/dronesrewrite/ammunition/ammo_mine"

--PATH addons/_drones/lua/entities/item_drr_plasma.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Plasma"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 50
ENT.Model = "models/dronesrewrite/ammobox/ammobox.mdl"
ENT.Material = "models/dronesrewrite/ammunition/ammo_plsm"

--PATH gamemodes/darkrp/entities/entities/lootbox_1/cl_init.lua:
include("Shared.lua")

function ENT:Draw()
	self.OverlayText = "<color=200,200,0>Сміття</color> \\\\nМожливо є щось корисне."
	self:DrawModel()
end  





--PATH addons/lvs_base-main/lua/entities/lvs_base/cl_hud.lua:

LVS:AddHudEditor( "VehicleHealth", 10, ScrH() - 85,  220, 75, 220, 75, "VEHICLE HEALTH", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintVehicleHealth then return end

		vehicle:LVSHudPaintVehicleHealth( X, Y, W, H, ScrX, ScrY, ply )
	end
)

LVS:AddHudEditor( "VehicleInfo", ScrW() - 460, ScrH() - 85,  220, 75, 220, 75, "VEHICLE INFORMATION", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintInfoText then return end

		vehicle:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	end
)

function ENT:LVSHudPaintVehicleHealth( X, Y, W, H, ScrX, ScrY, ply )
	draw.DrawText( "HEALTH ", "LVS_FONT", X + 102, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( math.Round( self:GetHP(), 0 ), "LVS_FONT_HUD_LARGE", X + 102, Y + 20, color_white, TEXT_ALIGN_LEFT )
end

ENT.VehicleIdentifierRange = 10000

function ENT:LVSHudPaintVehicleIdentifier( X, Y, In_Col )
	local HP = self:GetHP()

	surface.SetDrawColor( In_Col.r, In_Col.g, In_Col.b, In_Col.a )
	LVS:DrawDiamond( X + 1, Y + 1, 20, HP / self:GetMaxHP() )

	if self:GetMaxShield() > 0 and HP > 0 then
		surface.SetDrawColor( 200, 200, 255, In_Col.a )
		LVS:DrawDiamond( X + 1, Y + 1, 24, self:GetShield() / self:GetMaxShield() )
	end
end

function ENT:LVSHudPaint( X, Y, ply )
end

function ENT:HurtMarker( intensity )
	LocalPlayer():EmitSound( "lvs/hit_receive"..math.random(1,2)..".wav", 75, math.random(95,105), 0.25 + intensity * 0.75, CHAN_STATIC )
	util.ScreenShake( Vector(0, 0, 0), 25 * intensity, 25 * intensity, 0.5, 1 )
end

function ENT:KillMarker()
	self.LastKillMarker = CurTime() + 0.5

	LocalPlayer():EmitSound( "lvs/hit_kill.wav", 85, 100, 0.4, CHAN_VOICE )
end

local LastMarker = 0
function ENT:ArmorMarker( IsDamage )
	local T = CurTime()

	local DontHurtEars = math.Clamp( T - LastMarker, 0, 1 ) ^ 2

	LastMarker = T

	local ArmorFailed = IsDamage and "takedamage" or "pen"
	local Volume = IsDamage and (0.3 * DontHurtEars) or 1

	LocalPlayer():EmitSound( "lvs/armor_"..ArmorFailed.."_"..math.random(1,3)..".wav", 85, math.random(95,105), Volume, CHAN_ITEM2 )
end

function ENT:HitMarker()
	self.LastHitMarker = CurTime() + 0.15

	LocalPlayer():EmitSound( "lvs/hit.wav", 85, math.random(95,105), 0.4, CHAN_ITEM )
end

function ENT:CritMarker()
	self.LastCritMarker = CurTime() + 0.15

	LocalPlayer():EmitSound(  "lvs/hit_crit.wav", 85, math.random(95,105), 0.4, CHAN_ITEM2 )
end

function ENT:GetHitMarker()
	return self.LastHitMarker or 0
end

function ENT:GetCritMarker()
	return self.LastCritMarker or 0
end

function ENT:GetKillMarker()
	return self.LastKillMarker or 0
end

function ENT:LVSPaintHitMarker( scr )
	local T = CurTime()

	local aV = math.cos( math.rad( math.max(((self:GetHitMarker() - T) / 0.15) * 360,0) ) )
	if aV ~= 1 then
		local Start = 12 + (1 - aV) * 8
		local dst = 10

		surface.SetDrawColor( 255, 255, 0, 255 )

		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start, scr.y + Start - dst )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start - dst, scr.y + Start )

		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start, scr.y - Start + dst )
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start - dst, scr.y - Start )

		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start, scr.y + Start - dst )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start + dst, scr.y + Start )

		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start, scr.y - Start + dst )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start + dst, scr.y - Start )

		scr.x = scr.x + 1
		scr.y = scr.y + 1

		surface.SetDrawColor( 0, 0, 0, 80 )

		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start, scr.y + Start - dst )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start - dst, scr.y + Start )

		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start, scr.y - Start + dst )
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start - dst, scr.y - Start )

		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start, scr.y + Start - dst )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start + dst, scr.y + Start )

		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start, scr.y - Start + dst )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start + dst, scr.y - Start )
	end

	local aV = math.sin( math.rad( math.max(((self:GetCritMarker() - T) / 0.15) * 180,0) ) )
	if aV > 0.01 then
		local Start = 10 + aV * 40
		local End = 20 + aV * 45

		surface.SetDrawColor( 255, 100, 0, 255 )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + End, scr.y + End )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - End, scr.y + End ) 
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + End, scr.y - End )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - End, scr.y - End ) 

		draw.NoTexture()
		surface.DrawTexturedRectRotated( scr.x + Start, scr.y + Start, 3, 20, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y + Start, 20, 3, 45 )
		surface.DrawTexturedRectRotated(  scr.x + Start, scr.y - Start, 20, 3, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y - Start, 3, 20, 45 )
	end

	local aV = math.sin( math.rad( math.sin( math.rad( math.max(((self:GetKillMarker() - T) / 0.2) * 90,0) ) ) * 90 ) )
	if aV > 0.01 then
		surface.SetDrawColor( 255, 255, 255, 15 * (aV ^ 4) )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )

		local Start = 10 + aV * 40
		local End = 20 + aV * 45
		surface.SetDrawColor( 255, 0, 0, 255 )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + End, scr.y + End )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - End, scr.y + End ) 
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + End, scr.y - End )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - End, scr.y - End ) 

		draw.NoTexture()
		surface.DrawTexturedRectRotated( scr.x + Start, scr.y + Start, 5, 20, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y + Start, 20, 5, 45 )
		surface.DrawTexturedRectRotated(  scr.x + Start, scr.y - Start, 20, 5, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y - Start, 5, 20, 45 )
	end
end

function ENT:PaintCrosshairCenter( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local Alpha = Col.a / 255
	local Shadow = Color( 0, 0, 0, 80 * Alpha )

	surface.DrawCircle( Pos2D.x, Pos2D.y, 4, Shadow )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 5, Col )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 6, Shadow )
end

function ENT:PaintCrosshairOuter( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local Alpha = Col.a / 255
	local Shadow = Color( 0, 0, 0, 80 * Alpha )

	surface.DrawCircle( Pos2D.x,Pos2D.y, 17, Shadow )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 18, Col )

	if LVS.AntiAliasingEnabled then
		surface.DrawCircle( Pos2D.x, Pos2D.y, 19, Color( Col.r, Col.g, Col.b, 150 * Alpha ) )
		surface.DrawCircle( Pos2D.x, Pos2D.y, 20, Shadow )
	else
		surface.DrawCircle( Pos2D.x, Pos2D.y, 19, Shadow )
	end
end

local Circles = {
	[1] = {r = -1, col = Color(0,0,0,200)},
	[2] = {r = 0, col = Color(255,255,255,200)},
	[3] = {r = 1, col = Color(255,255,255,255)},
	[4] = {r = 2, col = Color(255,255,255,200)},
	[5] = {r = 3, col = Color(0,0,0,200)},
}

function ENT:LVSDrawCircle( X, Y, target_radius, value )
	local endang = 360 * value

	if endang == 0 then return end

	for i = 1, #Circles do
		local data = Circles[ i ]
		local radius = target_radius + data.r
		local segmentdist = endang / ( math.pi * radius * 0.5 )

		for a = 0, endang, segmentdist do
			surface.SetDrawColor( data.col )

			surface.DrawLine( X - math.sin( math.rad( a ) ) * radius, Y + math.cos( math.rad( a ) ) * radius, X - math.sin( math.rad( a + segmentdist ) ) * radius, Y + math.cos( math.rad( a + segmentdist ) ) * radius )
		end
	end
end

function ENT:PaintCrosshairSquare( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local X = Pos2D.x + 1
	local Y = Pos2D.y + 1

	local Size = 20

	surface.SetDrawColor( 0, 0, 0, 80 )
	surface.DrawLine( X - Size, Y + Size, X - Size * 0.5, Y + Size )
	surface.DrawLine( X + Size, Y + Size, X + Size * 0.5, Y + Size )
	surface.DrawLine( X - Size, Y + Size, X - Size, Y + Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size, Y - Size * 0.5 )
	surface.DrawLine( X + Size, Y + Size, X + Size, Y + Size * 0.5 )
	surface.DrawLine( X + Size, Y - Size, X + Size, Y - Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size * 0.5, Y - Size )
	surface.DrawLine( X + Size, Y - Size, X + Size * 0.5, Y - Size )

	if Col then
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
	else
		surface.SetDrawColor( 255, 255, 255, 255 )
	end

	X = Pos2D.x
	Y = Pos2D.y

	surface.DrawLine( X - Size, Y + Size, X - Size * 0.5, Y + Size )
	surface.DrawLine( X + Size, Y + Size, X + Size * 0.5, Y + Size )
	surface.DrawLine( X - Size, Y + Size, X - Size, Y + Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size, Y - Size * 0.5 )
	surface.DrawLine( X + Size, Y + Size, X + Size, Y + Size * 0.5 )
	surface.DrawLine( X + Size, Y - Size, X + Size, Y - Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size * 0.5, Y - Size )
	surface.DrawLine( X + Size, Y - Size, X + Size * 0.5, Y - Size )
end
--PATH addons/lvs_base-main/lua/entities/lvs_base_gunner/cl_init.lua:
include("shared.lua")

function ENT:Think()
end

function ENT:OnRemove()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetNWAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		if self._AimVectorUnlocked then
			local pod = self:GetDriverSeat()

			if IsValid( pod ) then
				return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
			end
		end

		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:LVSPaintHitMarker( scr )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:LVSPaintHitMarker( scr )
end

function ENT:LVSDrawCircle( X, Y, target_radius, value )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:LVSDrawCircle( X, Y, target_radius, value )
end

function ENT:PaintCrosshairCenter( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairCenter( Pos2D, Col )
end

function ENT:PaintCrosshairOuter( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairOuter( Pos2D, Col )
end

function ENT:PaintCrosshairSquare( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairSquare( Pos2D, Col )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_flak/cl_init.lua:
include("shared.lua")
include("cl_tankview.lua")
include("sh_turret.lua")
include("cl_attached_playermodels.lua")
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_dodwillyjeep_mg/cl_init.lua:
include("shared.lua")

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )

	if pod ~= self:GetGunnerSeat() then
		return LVS:CalcView( self, ply, pos, angles, fov, pod )
	end

	if pod:GetThirdPersonMode() then
		local view = {}
		view.fov = fov
		view.drawviewer = true

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = pos
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * pod:GetCameraHeight())

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos + pod:GetUp() * 65

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end

	local ZoomAttach = self:GetAttachment( self:LookupAttachment( "zoom" ) )
	local EyeAttach = self:GetAttachment( self:LookupAttachment( "eye" ) )

	if ZoomAttach and EyeAttach then
		local ZOOM = ply:lvsKeyDown( "ZOOM" )

		local TargetZoom = ZOOM and 1 or 0

		pod.smZoom = pod.smZoom and (pod.smZoom + (TargetZoom - pod.smZoom) * RealFrameTime() * 12) or 0

		local Zoom = pod.smZoom
		local invZoom = 1 - Zoom

		pos = ZoomAttach.Pos * Zoom + EyeAttach.Pos * invZoom
	end

	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_engine.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "Entity",1, "DoorHandler" )

	self:NetworkVar( "Float",1, "HP" )
	self:NetworkVar( "Float",2, "MaxHP" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
	end

	function ENT:CheckWater( Base )
		local EntTable = self:GetTable()

		if bit.band( util.PointContents( self:GetPos() ), CONTENTS_WATER ) ~= CONTENTS_WATER then
			if EntTable.CountWater then
				EntTable.CountWater = nil
			end

			return
		end

		if Base.WaterLevelAutoStop > 3 then return end

		EntTable.CountWater = (EntTable.CountWater or 0) + 1

		if EntTable.CountWater < 4 then return end

		Base:StopEngine()
	end

	function ENT:Think()

		local Base = self:GetBase()

		if IsValid( Base ) and Base:GetEngineActive() then
			self:CheckWater( Base )
		end

		self:NextThink( CurTime() + 1 )

		return true
	end

	function ENT:OnDestroyed()
		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
		util.Effect( "lvs_trailer_explosion", effectdata, true, true )

		self:EmitSound("physics/metal/metal_box_break"..math.random(1,2)..".wav",75,100,1)

		local base = self:GetBase()

		if not IsValid( base ) then return end

		net.Start( "lvs_car_break" )
			net.WriteEntity( base )
		net.Broadcast()

		if base:GetEngineActive() then
			self:EmitSound("npc/manhack/bat_away.wav",75,100,0.5)

			timer.Simple(1, function()
				if not IsValid( self ) then return end
				self:EmitSound("npc/manhack/gib.wav",75,90,1)
			end)
		end
	
		base:ShutDownEngine()
	end

	function ENT:TakeTransmittedDamage( dmginfo )
		if self:GetDestroyed() then return end

		local Damage = dmginfo:GetDamage()

		if Damage <= 0 then return end

		local CurHealth = self:GetHP()

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:SetHP( NewHealth )

		if NewHealth <= 0 then
			self:SetDestroyed( true )

			self:OnDestroyed()
		end
	end

	function ENT:OnTakeDamage( dmginfo )
	end


	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	function ENT:OnRemove()
		local base = self:GetBase()

		if not IsValid( base ) or base.ExplodedAlready then return end

		base:SetMaxThrottle( 1 )
	end

	return
end

ENT._oldEnActive = false
ENT._ActiveSounds = {}

function ENT:Initialize()
end

function ENT:StopSounds()
	for id, sound in pairs( self._ActiveSounds ) do
		if istable( sound ) then
			for _, snd in pairs( sound ) do
				if snd then
					snd:Stop()
				end
			end
		else
			sound:Stop()
		end
		self._ActiveSounds[ id ] = nil
	end
end

function ENT:OnEngineActiveChanged( Active )
	if not Active then self:StopSounds() return end

	for id, data in pairs( self.EngineSounds ) do
		if not isstring( data.sound ) then continue end

		self.EngineSounds[ id ].Pitch = data.Pitch or 100
		self.EngineSounds[ id ].PitchMul = data.PitchMul or 100
		self.EngineSounds[ id ].Volume = data.Volume or 1
		self.EngineSounds[ id ].SoundType = data.SoundType or LVS.SOUNDTYPE_NONE
		self.EngineSounds[ id ].UseDoppler = data.UseDoppler ~= false
		self.EngineSounds[ id ].SoundLevel = data.SoundLevel or 85

		if data.sound_int and data.sound_int ~= data.sound then
			local sound = CreateSound( self, data.sound )
			sound:SetSoundLevel( data.SoundLevel )
			sound:PlayEx(0,100)

			if data.sound_int == "" then
				self._ActiveSounds[ id ] = {
					ext = sound,
					int = false,
				}
			else
				local sound_interior = CreateSound( self, data.sound_int )
				sound_interior:SetSoundLevel( data.SoundLevel )
				sound_interior:PlayEx(0,100)

				self._ActiveSounds[ id ] = {
					ext = sound,
					int = sound_interior,
				}
			end
		else
			local sound = CreateSound( self, data.sound )
			sound:SetSoundLevel( data.SoundLevel )
			sound:PlayEx(0,100)

			self._ActiveSounds[ id ] = sound
		end
	end
end

function ENT:SetGear( newgear )
	self._CurGear = newgear
end

function ENT:GetGear()
	return (self._CurGear or 1)
end

function ENT:SetRPM( rpm )
	self._CurRPM = rpm
end

function ENT:GetRPM()
	local base = self:GetBase()

	if not IsValid( base ) or not base:GetEngineActive() then return 0 end

	return math.abs(self._CurRPM or 0)
end

function ENT:GetClutch()
	return self._ClutchActive == true
end

function ENT:SetEngineVolume( volume )
	self._engineVolume = volume

	return volume
end

function ENT:GetEngineVolume()
	return (self._engineVolume or 0)
end

function ENT:HandleEngineSounds( vehicle )
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()
	local Throttle = vehicle:GetThrottle()
	local MaxThrottle = vehicle:GetMaxThrottle()
	local Doppler = vehicle:CalcDoppler( ply )

	local EntTable = self:GetTable()

	local DrivingMe = ply:lvsGetVehicle() == vehicle

	local IsManualTransmission = vehicle:IsManualTransmission()

	local VolumeSetNow = false

	local FirstPerson = false
	if IsValid( pod ) then
		local ThirdPerson = pod:GetThirdPersonMode()

		if ThirdPerson ~= EntTable._lvsoldTP then
			EntTable._lvsoldTP = ThirdPerson
			VolumeSetNow = DrivingMe
		end

		FirstPerson = DrivingMe and not ThirdPerson
	end

	if DrivingMe ~= EntTable._lvsoldDrivingMe then
		EntTable._lvsoldDrivingMe = DrivingMe

		self:StopSounds()

		EntTable._oldEnActive = nil

		return
	end

	local FT = RealFrameTime()
	local T = CurTime()

	local Reverse = vehicle:GetReverse()
	local vehVel = vehicle:GetVelocity():Length()
	local wheelVel = vehicle:GetWheelVelocity()

	local IsHandBraking = wheelVel == 0 and vehicle:GetNWHandBrake()

	local Vel = 0
	local Wobble = 0

	if vehVel / wheelVel <= 0.8 then
		Vel = wheelVel
		Wobble = -1
	else
		Vel = vehVel
	end

	local NumGears = vehicle.TransGears
	local MaxGear = Reverse and vehicle.TransGearsReverse or NumGears

	local VolumeValue = self:SetEngineVolume( LVS.EngineVolume )
	local PitchValue = vehicle.MaxVelocity / NumGears

	local DesiredGear = 1

	local subGeared = vehVel - (EntTable._smVelGeared or 0)
	local VelocityGeared = vehVel

	if IsHandBraking then
		VelocityGeared = PitchValue * Throttle
		Vel = VelocityGeared
	end

	--[[ workaround ]]-- TODO: Fix it properly
	if vehicle:Sign( subGeared ) < 0 then
		self._smVelGeared = (EntTable._smVelGeared or 0) + subGeared * FT * 5
		VelocityGeared = EntTable._smVelGeared
	else
		EntTable._smVelGeared = VelocityGeared 
	end
	--[[ workaround ]]--


	while (VelocityGeared > PitchValue) and DesiredGear< NumGears do
		VelocityGeared = VelocityGeared - PitchValue

		DesiredGear = DesiredGear + 1
	end

	if IsManualTransmission then
		EntTable._NextShift = 0

		if IsHandBraking then
			DesiredGear = 1
		else
			DesiredGear = vehicle:GetGear()
		end
	else
		DesiredGear = math.Clamp( DesiredGear, 1, MaxGear )
	end

	local CurrentGear = math.Clamp(self:GetGear(),1,NumGears)

	local RatioThrottle = 0.5 + (Throttle ^ 2) * 0.5

	local RatioPitch = math.max(Vel - (CurrentGear - 1) * PitchValue,0)

	if (not IsManualTransmission or IsHandBraking) then --and CurrentGear ~= MaxGear then
		RatioPitch = math.min( PitchValue, RatioPitch )
	end

	local preRatio = math.Clamp(Vel / (PitchValue * (CurrentGear - 1)),0,1)
	local Ratio = (RatioPitch / PitchValue) * RatioThrottle

	if CurrentGear ~= DesiredGear then
		if (EntTable._NextShift or 0) < T then
			EntTable._NextShift = T + vehicle.TransMinGearHoldTime

			if CurrentGear < DesiredGear then
				EntTable._ShiftTime = T + vehicle.TransShiftSpeed
				EntTable._WobbleTime = T + vehicle.TransWobbleTime
			end

			vehicle:OnChangeGear( CurrentGear, DesiredGear )

			self:SetGear( DesiredGear )
		end
	end

	if Throttle > 0.5 then
		local FullThrottle = Throttle >= 0.99

		if EntTable._oldFullThrottle ~= FullThrottle then
			EntTable._oldFullThrottle = FullThrottle

			if FullThrottle then
				EntTable._WobbleTime = T + vehicle.TransWobbleTime
			end
		end

		if Wobble == 0 then
			local Mul = math.Clamp( (EntTable._WobbleTime or 0) - T, 0, 1 )

			Wobble = (math.cos( T * (20 + CurrentGear * 10) * vehicle.TransWobbleFrequencyMultiplier ) * math.max(1 - Ratio,0) * vehicle.TransWobble * math.max(1 - vehicle:AngleBetweenNormal( vehicle:GetUp(), Vector(0,0,1) ) / 5,0) ^ 2) * Mul 
		end
	end

	local FadeSpeed = 0.15
	local PlayIdleSound = CurrentGear == 1 and Throttle == 0 and Ratio < 0.5
	local rpmSet = false
	local rpmRate = PlayIdleSound and 1 or 5

	if IsManualTransmission and (self:GetRPM() < vehicle.EngineIdleRPM or EntTable.ForcedIdle) then
		if EntTable.ForcedIdle then
			self:SetRPM(  vehicle.EngineIdleRPM )
			PlayIdleSound = true
			rpmRate = 1
			EntTable._ClutchActive = true

			if Ratio > 0 or Throttle > 0 then
				EntTable.ForcedIdle = nil
			end
		else
			if Ratio == 0 and Throttle == 0 then
				EntTable.ForcedIdle = true
			end
		end
	end

	EntTable._smIdleVolume = EntTable._smIdleVolume and EntTable._smIdleVolume + ((PlayIdleSound and 1 or 0) - EntTable._smIdleVolume) * FT or 0
	EntTable._smRPMVolume = EntTable._smRPMVolume and EntTable._smRPMVolume + ((PlayIdleSound and 0 or 1) - EntTable._smRPMVolume) * FT * rpmRate or 0

	if (EntTable._ShiftTime or 0) > T or PlayIdleSound then
		PitchAdd = 0
		Ratio = 0
		Wobble = 0
		Throttle = 0
		FadeSpeed = PlayIdleSound and 0.25 or 3
		EntTable._ClutchActive = true
	else
		EntTable._ClutchActive = false
	end

	if IsManualTransmission and IsHandBraking then
		EntTable._ClutchActive = true
	end

	if not EntTable.EnginePitchStep then
		EntTable.EnginePitchStep = math.Clamp(vehicle.EngineMaxRPM / 10000, 0.6, 0.9)

		return
	end

	for id, sound in pairs( EntTable._ActiveSounds ) do
		if not sound then continue end

		local data = EntTable.EngineSounds[ id ]

		local Vol03 = data.Volume * 0.3
		local Vol02 = data.Volume * 0.2

		local Volume = (Vol02 + Vol03 * Ratio + (Vol02 * Ratio + Vol03) * Throttle) * VolumeValue

		local PitchAdd = CurrentGear * (data.PitchMul / NumGears * EntTable.EnginePitchStep) * MaxThrottle

		local Pitch = data.Pitch + PitchAdd + (data.PitchMul - PitchAdd) * Ratio + Wobble
		local PitchMul = data.UseDoppler and Doppler or 1

		if IsManualTransmission and Ratio == 0 and preRatio < 1 and not PlayIdleSound then
			Pitch = (PitchAdd / CurrentGear) * (1 - preRatio) + (data.Pitch + PitchAdd) * preRatio + Wobble
		end

		local SoundType = data.SoundType

		if SoundType ~= LVS.SOUNDTYPE_ALL then
			Volume = Volume  * EntTable._smRPMVolume

			if SoundType == LVS.SOUNDTYPE_IDLE_ONLY then
				Volume = EntTable._smIdleVolume * data.Volume * VolumeValue
				Pitch = data.Pitch + data.PitchMul * Ratio
			end

			if SoundType == LVS.SOUNDTYPE_REV_UP then
				Volume = Throttle == 0 and 0 or Volume
			end

			if SoundType == LVS.SOUNDTYPE_REV_DOWN then
				Volume =  Throttle == 0 and Volume or 0
			end
		end

		if istable( sound ) then
			sound.ext:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), FadeSpeed )
	
			if sound.int then
				sound.int:ChangePitch( math.Clamp( Pitch, 0, 255 ), FadeSpeed )
			end

			local fadespeed = VolumeSetNow and 0 or 0.15

			if FirstPerson then
				sound.ext:ChangeVolume( 0, 0 )

				if vehicle:HasActiveSoundEmitters() then
					Volume = Volume * 0.25
					fadespeed = fadespeed * 0.5
				end

				if sound.int then sound.int:ChangeVolume( Volume, fadespeed ) end
			else
				sound.ext:ChangeVolume( Volume, fadespeed )
				if sound.int then sound.int:ChangeVolume( 0, 0 ) end
			end
		else
			sound:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), FadeSpeed )
			sound:ChangeVolume( Volume, 0.15 )
		end

		if rpmSet then continue end

		if PlayIdleSound then self:SetRPM( vehicle.EngineIdleRPM ) rpmSet = true continue end

		if data.SoundType == LVS.SOUNDTYPE_IDLE_ONLY then continue end

		if istable( sound ) then
			if sound.int then
				rpmSet = true
				self:SetRPM( vehicle.EngineIdleRPM + ((sound.int:GetPitch() - data.Pitch) / data.PitchMul) * (vehicle.EngineMaxRPM - vehicle.EngineIdleRPM) )
			else
				if not sound.ext then continue end

				rpmSet = true
				self:SetRPM( vehicle.EngineIdleRPM + ((sound.ext:GetPitch() - data.Pitch) / data.PitchMul) * (vehicle.EngineMaxRPM - vehicle.EngineIdleRPM) )
			end
		else
			rpmSet = true
			self:SetRPM( vehicle.EngineIdleRPM + ((sound:GetPitch() - data.Pitch) / data.PitchMul) * (vehicle.EngineMaxRPM - vehicle.EngineIdleRPM) )
		end
	end
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	local EntTable = self:GetTable()

	self:DamageFX( vehicle )

	if not EntTable.EngineSounds then
		EntTable.EngineSounds = vehicle.EngineSounds

		return
	end

	local EngineActive = vehicle:GetEngineActive()

	if EntTable._oldEnActive ~= EngineActive then
		EntTable._oldEnActive = EngineActive

		self:OnEngineActiveChanged( EngineActive )
	end

	if EngineActive then
		self:HandleEngineSounds( vehicle )
		self:ExhaustFX( vehicle )
	end
end

function ENT:RemoveFireSound()
	if self.FireBurnSND then
		self.FireBurnSND:Stop()
		self.FireBurnSND = nil
	end

	self.ShouldStopFire = nil
end

function ENT:StopFireSound()
	if self.ShouldStopFire or not self.FireBurnSND then return end

	self.ShouldStopFire = true

	self:EmitSound("ambient/fire/mtov_flame2.wav")

	self.FireBurnSND:ChangeVolume( 0, 0.5 )

	timer.Simple( 1, function()
		if not IsValid( self ) then return end

		self:RemoveFireSound()
	end )
end

function ENT:StartFireSound()
	if self.ShouldStopFire or self.FireBurnSND then return end

	self.FireBurnSND = CreateSound( self, "ambient/fire/firebig.wav" )
	self.FireBurnSND:PlayEx(0,100)
	self.FireBurnSND:ChangeVolume( LVS.EngineVolume, 1 )

	self:EmitSound("ambient/fire/ignite.wav")
end

function ENT:OnRemove()
	self:StopSounds()
	self:RemoveFireSound()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:ExhaustFX( vehicle )
	if not istable( vehicle.ExhaustPositions ) then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.1

	vehicle:DoExhaustFX( (self:GetRPM() / vehicle.EngineMaxRPM) * 0.5 + 0.5 * vehicle:GetThrottle() )
end

function ENT:DamageFX( vehicle )
	local T = CurTime()
	local HP = self:GetHP()
	local MaxHP = self:GetMaxHP()

	local EntTable = self:GetTable()

	if HP >= MaxHP * 0.5 then self:StopFireSound() return end

	if (EntTable.nextDFX or 0) > T then return end

	EntTable.nextDFX = T + 0.05

	if self:GetDestroyed() then
		if not EntTable._FireStopTime then
			EntTable._FireStopTime = T + math.random(20,40)
		end

		if EntTable ._FireStopTime < T then
			self:StopFireSound()

			local effectdata = EffectData()
				effectdata:SetOrigin( self:GetPos() )
				effectdata:SetEntity( vehicle )
			util.Effect( "lvs_carengine_blacksmoke", effectdata )

			return
		end

		self:StartFireSound()

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( vehicle )
		util.Effect( "lvs_carengine_fire", effectdata )
	else
		EntTable._FireStopTime = nil

		self:StopFireSound()

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( vehicle )
			effectdata:SetMagnitude( math.max(HP,0) / (MaxHP * 0.5) )
		util.Effect( "lvs_carengine_smoke", effectdata )
	end
end


--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_gtr34/cl_init.lua:
include("shared.lua")

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	self:SetPoseParameter( "vehicle_steer", steer )
	self:SetPoseParameter( "tacho_gauge", engine_rpm / 10000 )
	self:SetPoseParameter( "temp_gauge", temperature )
	self:SetPoseParameter( "fuel_gauge", fuel )
	self:SetPoseParameter( "oil_gauge", oil )
	self:SetPoseParameter( "vehicle_gauge", speed_kmh / 180 )
	self:SetPoseParameter( "throttle_pedal", throttle )
	self:SetPoseParameter( "brake_pedal", brake )
	self:SetPoseParameter( "handbrake_pedal", handbrake )
	self:SetPoseParameter( "clutch_pedal", clutch )

	local GearIDtoPose = {
		[-1] = 0,
		[1] = 5,
		[2] = 7,
		[3] = 10,
		[4] = 12,
		[5] = 15,
		[6] = 17,
	}

	self:SetPoseParameter( "gear",  self:QuickLerp( "gear", (GearIDtoPose[ gear ] or 1) ) )

	local Turbo = self:GetTurbo()

	if not IsValid( Turbo ) then return end

	self:SetPoseParameter( "turbo_gauge", Turbo:GetBoost() )
end
--PATH addons/__main/lua/entities/m9k_ammo_357/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "357"
ENT.Category		= "M9K Ammunition"

ENT.Spawnable		= true
ENT.AdminOnly = false
ENT.DoNotDuplicate = true

if SERVER then

AddCSLuaFile("shared.lua")

function ENT:SpawnFunction(ply, tr)

	if (!tr.Hit) then return end
	
	local SpawnPos = tr.HitPos + tr.HitNormal * 16
	
	local ent = ents.Create("m9k_ammo_357")
	
	ent:SetPos(SpawnPos)
	ent:Spawn()
	ent:Activate()
	ent.Planted = false
	
	return ent
end


/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()

	local model = ("models/Items/357ammo.mdl")
	
	self.Entity:SetModel(model)
	
	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:DrawShadow(false)
	
	self.Entity:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	
	local phys = self.Entity:GetPhysicsObject()
	
	if (phys:IsValid()) then
		phys:Wake()
	end

	self.Entity:SetUseType(SIMPLE_USE)
end


/*---------------------------------------------------------
   Name: PhysicsCollide
---------------------------------------------------------*/
function ENT:PhysicsCollide(data, physobj)
	
	// Play sound on bounce
	if (data.Speed > 80 and data.DeltaTime > 0.2) then
		self.Entity:EmitSound("Default.ImpactSoft")
	end
end

/*---------------------------------------------------------
   Name: OnTakeDamage
---------------------------------------------------------*/
function ENT:OnTakeDamage(dmginfo)

	if dmginfo:GetAttacker():GetClass() == "m9k_ammo_explosion" then return end
	
	self.Entity:TakePhysicsDamage(dmginfo)
	if GetConVar("M9KAmmoDetonation") == nil then return end
	if not (GetConVar("M9KAmmoDetonation"):GetBool()) then return end
	blaster = dmginfo:GetAttacker()
	pos = self.Entity:GetPos()+Vector(0,0,10)
	
	dice = math.random(1,5)

	if dmginfo:GetDamage() >75 or dice == 1 then
		self.Entity:Remove()
	
		local effectdata = EffectData()
		effectdata:SetOrigin(self.Entity:GetPos())
		util.Effect("ThumperDust", effectdata)
		util.Effect("Explosion", effectdata)
	
		timer.Simple(.01, function()
			for i=1, 100 do
			
			ouchies = {}
			ouchies.start = pos
			ouchies.endpos = pos + Vector(math.Rand(-1,1), math.Rand(-1,1), math.Rand(0,1)) * 64000
			ouchies = util.TraceLine(ouchies)
			
			if ouchies.Hit and not ouchies.HitSky then 
				util.Decal("Impact.Concrete", ouchies.HitPos + ouchies.HitNormal, ouchies.HitPos - ouchies.HitNormal )//and ouchies.Entity then
				ouchies.Entity:TakeDamage(30 * math.Rand(.85,1.15), blaster, blaster)
			end
			end
		end)
	end	

end

/*---------------------------------------------------------
   Name: Use
---------------------------------------------------------*/
function ENT:Use(activator, caller)

	if (activator:IsPlayer()) and not self.Planted then
		// Give the collecting player some free health
		activator:GiveAmmo(100, "357")
		self.Entity:Remove()
	end
	
end

end

if CLIENT then

/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()
end

/*---------------------------------------------------------
   Name: DrawPre
---------------------------------------------------------*/
function ENT:Draw()
	
	self.Entity:DrawModel()
	
	local ledcolor = Color(230, 45, 45, 255)

  	local TargetPos = self.Entity:GetPos() + (self.Entity:GetUp() * 4) + (self.Entity:GetRight() * -2.5) + (self.Entity:GetForward() * -3.3)//-1.2

	local FixAngles = self.Entity:GetAngles()
	local FixRotation = Vector(48, -90, 0)
	
	FixAngles:RotateAroundAxis(FixAngles:Right(), FixRotation.x)
	FixAngles:RotateAroundAxis(FixAngles:Up(), FixRotation.y)
	FixAngles:RotateAroundAxis(FixAngles:Forward(), FixRotation.z)

	self.Text = "357"
	
	cam.Start3D2D(TargetPos, FixAngles, .07)
		draw.SimpleText(self.Text, "DermaLarge", 31, -22, ledcolor, 1, 1)
	cam.End3D2D()
end

end
--PATH addons/media_player/lua/entities/mediaplayer_base/cl_init.lua:
include "shared.lua"

--PATH addons/media_player/lua/entities/mediaplayer_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.Spawnable = false

ENT.Model = Model( "models/props_phx/rt_screen.mdl" )

ENT.MediaPlayerType = "entity"
ENT.IsMediaPlayerEntity = true

local ErrorModel = "models/error.mdl"

function ENT:Initialize()

	if SERVER then
		if self:GetModel() == ErrorModel then
			self:SetModel( self.Model )
		end

		self:SetUseType( SIMPLE_USE )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )

		local phys = self:GetPhysicsObject()
		if IsValid( phys ) then
			phys:EnableMotion( false )
		end

		-- Install media player to entity
		local mp = self:InstallMediaPlayer( self.MediaPlayerType )

		-- Network media player ID
		self:SetMediaPlayerID( mp:GetId() )
	end

	-- Apply player config based on model
	self.PlayerConfig = self:GetMediaPlayerConfig()
end

function ENT:SetupDataTables()
	self:NetworkVar( "String", 0, "MediaPlayerID" )
end

function ENT:OnRemove()
	local mp = self:GetMediaPlayer()
	if mp then
		mp:Remove()
	end
end

function ENT:GetMediaPlayerConfig()
	local model = self:GetModel()
	local MPModelConfigs = list.Get( "MediaPlayerModelConfigs" )
	local config = MPModelConfigs and MPModelConfigs[model] or self.PlayerConfig
	return config
end

--PATH addons/igs-core/lua/entities/npc_igs/shared.lua:
ENT.Base      = "base_ai"
ENT.Type      = "ai"
ENT.PrintName = "Донат NPC"
ENT.Author    = "GMDonate"
ENT.Category  = "IGS"
ENT.Spawnable = true

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

--PATH addons/_pcasino/lua/entities/pcasino_sign_plaque/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Plaque"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.noDrag = true

PerfectCasino.Core.RegisterEntity("pcasino_sign_plaque", {
	-- General data
	general = {
		text = {d = "Cool Casino", t = "string"} -- The text to show
	}
},
"models/freeman/owain_casinosign_text.mdl")
--PATH addons/_pcasino/lua/entities/pcasino_sign_wall_logo/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end
--PATH gamemodes/darkrp/entities/entities/spawned_food/cl_init.lua:
include("Shared.lua")

function ENT:Draw()
	self.OverlayText = "<color=200,200,0>Еда</color> \nЇж, Їж нікого не слухай. "

	self:DrawModel()
end  

--PATH gamemodes/darkrp/entities/entities/spawned_weapon/shared.lua:
ENT.Type 			= 'anim'
ENT.Base 			= 'base_entity'
ENT.PrintName 		= 'Spawned Weapon'
ENT.Spawnable 		= false
ENT.AdminSpawnable 	= false


function ENT:SetupDataTables()
	self:NetworkVar('Int', 0, 'Stage')
	self:NetworkVar('Entity', 1, 'owning_ent')

	self:SetNWString('GetWeapon',"1")
	self:SetNWString('GetModel',"1")
	self:SetNWString('GetName',"1")

end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_bag/cl_init.lua:
include("shared.lua")

local grn = Color(0, 0, 0, 255)
local xpos = 50
local ypos = 0

function ENT:Draw() end

function ENT:DrawTranslucent()
	self:DrawModel()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		-- Background
		draw.RoundedBox(0, xpos, ypos+0, 400, 120, Color(0, 0, 0, 225))
		-- Side bar
		draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
	
		draw.SimpleText(string.upper(UWeed.Translation.Bag.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.SimpleText(UWeed.Translation.Bag.Capacity.." "..((self:GetBudCounter()*100)/UWeed.WeedBag.Capacity).."%", "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_light_big/cl_init.lua:
include("shared.lua")

function ENT:Think()
	if self:GetOn() then
		local dlight = DynamicLight(self:EntIndex())
		if (dlight) then
			dlight.pos = self:GetPos() + (self:GetUp()*-4)
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 4
			dlight.Decay = 1000
			dlight.Size = 256
			dlight.DieTime = CurTime() + 1
		end
	end
end

local grn = Color(0, 0, 0, 255)
local xpos = 500
local ypos = -10
function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		if UWeed.Light.Batery then
			-- Background
			draw.RoundedBox(0, xpos, ypos+0, 665, 160, Color(0, 0, 0, 225))
			-- Side bar
			draw.RoundedBox(0, xpos, ypos+0, 10, 160, grn)
		else
			-- Background
			draw.RoundedBox(0, xpos, ypos+0, 265, 120, Color(0, 0, 0, 225))
			-- Side bar
			draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
		end
	
		draw.SimpleText(string.upper(UWeed.Translation.BIGLAMP.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

		local state = UWeed.Translation.BIGLAMP.Off
		if self:GetOn() then
			state = UWeed.Translation.BIGLAMP.On
		end
		draw.SimpleText(UWeed.Translation.BIGLAMP.State.." "..state, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		if UWeed.Light.Batery then
			draw.SimpleText(UWeed.Translation.BIGLAMP.Battery.." "..self:GetBattery().."%", "uweed_font_60", xpos+10, ypos+135, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

	cam.End3D2D()
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_seed/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Seed"
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
end
--PATH addons/_drones/lua/effects/dronesrewrite_muzzleflashblaster2.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.Forward = data:GetNormal()

	self.Emitter = ParticleEmitter(self.Start)

	local dlight = DynamicLight(self:EntIndex())
	if dlight then
		dlight.pos = self.Start
		dlight.r = 255
		dlight.g = 0
		dlight.b = 0
		dlight.brightness = 1
		dlight.Decay = 1
		dlight.Size = math.random(150, 300)
		dlight.DieTime = CurTime()
	end

	local p = self.Emitter:Add("sprites/heatwave", self.Start - self.Forward * 2)
	p:SetVelocity(120 * self.Forward + 20 * VectorRand() * 2)
	p:SetGravity(Vector(0, 0, 100))
	p:SetAirResistance(160)
	p:SetDieTime(math.Rand(0.1, 0.15))
	p:SetStartSize(30)
	p:SetEndSize(0)
	p:SetRoll(math.Rand(180, 480))
	p:SetRollDelta(math.Rand(-1, 1))

	for a = 1, 12 do
		for i = 1, 4 do
			local p = self.Emitter:Add("sprites/light_glow02_add", self.Start + i * 4 * self.Forward)

			p:SetAirResistance(200)
			p:SetVelocity(6 * VectorRand())
			p:SetDieTime(math.Rand(0.05, 0.15))
			p:SetStartAlpha(155)
			p:SetStartSize(0)
			p:SetEndSize(34 - i * 6)
			p:SetRoll(math.Rand(180, 480))
			p:SetRollDelta(math.Rand(-1, 1))
			p:SetColor(255, 0, 0)	
		end
	end
	
	for i = 1, 4 do
		local p = self.Emitter:Add("sprites/light_glow02_add", self.Start + i * 4 * self.Forward)

		p:SetAirResistance(200)
		p:SetVelocity(6 * VectorRand())
		p:SetDieTime(math.Rand(0.05, 0.15))
		p:SetStartAlpha(155)
		p:SetStartSize(0)
		p:SetEndSize(34 - i * 6)
		p:SetRoll(math.Rand(180, 480))
		p:SetRollDelta(math.Rand(-1, 1))
		p:SetColor(255, 255, 255)	
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end





--PATH addons/_drones/lua/effects/dronesrewrite_rocketfly.lua:
function EFFECT:Init(data)		
	self.Start = data:GetOrigin()
	
	self.Emitter = ParticleEmitter(self.Start)
	
	for i = 1, 2 do
		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Start)
		
		p:SetVelocity(VectorRand() * 30)
		p:SetAirResistance(200)
		p:SetDieTime(2)
		p:SetStartAlpha(30)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(10, 20))
		p:SetEndSize(math.random(20, 30))	
		p:SetRollDelta(math.Rand(-2, 2))
		p:SetCollide(true)
		p:SetColor(150, 150, 150)
	end
	
	for i = 1, 4 do
		local p = self.Emitter:Add("particles/flamelet" .. math.random(1, 5), self.Start)
		
		p:SetDieTime(0.1)
		p:SetStartAlpha(100)
		p:SetEndAlpha(0)
		p:SetStartSize(math.Rand(3, 6))
		p:SetEndSize(1)	
		p:SetCollide(true)
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH addons/lvs_base-main/lua/effects/lvs_explosion_nodebris.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()

	self:Explosion( Pos, 2 )

	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		timer.Simple( delay, function()
			sound.Play( "LVS.EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.EXPLOSION", Pos )
	end

	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if not IsValid( self ) then return end

			local p = Pos + VectorRand() * 10 * i
			
			self:Explosion( p, math.Rand(0.5,0.8) )
		end)
	end
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 1000 * scale )
		particle:SetDieTime( math.Rand(0.75,1.5) * scale )
		particle:SetAirResistance( math.Rand(200,600) ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( math.Rand(60,120) * scale )
		particle:SetEndSize( math.Rand(160,280) * scale )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 40,40,40 )
		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetCollide( false )
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 1000 * scale )
		particle:SetDieTime( 0.14 )
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 * scale )
		particle:SetEndSize( math.Rand(60,120) * scale )
		particle:SetEndAlpha( 100 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 200,150,150 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_base-main/lua/effects/lvs_muzzle.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Vel = Dir * 10

	if IsValid( Ent ) then
		Vel = Ent:GetVelocity()
	end

	local emitter = ParticleEmitter( Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 12 do
		local particle = emitter:Add( "effects/muzzleflash2", Pos + Dir * i * 0.7 * math.random(1,2) * 0.5 )
		local Size = 1

		if not particle then continue end

		particle:SetVelocity( Dir * 800 + Vel )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 * Size )
		particle:SetStartSize( math.max( math.random(10,24) - i * 0.5,0.1 ) * Size )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 255, 255, 255 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_base-main/lua/effects/lvs_physics_dust.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local MatDebris = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	local Dir = Ent:GetForward()

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	local VecCol = render.GetLightColor( Pos + Vector(0,0,10) ) * 0.5 + Vector(0.3,0.25,0.15)

	if emitter and emitter.Add then
		for i = 1, 3 do
			local particle = emitter:Add( MatDebris[math.random(1,#MatDebris)], Pos + VectorRand(-10,10) )
			if particle then
				particle:SetVelocity( Vector(0,0,150) - Dir * 150 )
				particle:SetDieTime( 0.2 )
				particle:SetAirResistance( 60 ) 
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 255 )
				particle:SetStartSize( 15 )
				particle:SetEndSize( 50 )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				particle:SetColor( VecCol.x * 130,VecCol.y * 100,VecCol.z * 60 )
				particle:SetGravity( Vector( 0, 0, -600 ) )
				particle:SetCollide( false )
			end
		end

		local Right = Ent:GetRight() 
		Right.z = 0
		Right:Normalize()

		for i = -1,1,2 do
			local particle = emitter:Add( Materials[math.random(1,#Materials)], Pos + Vector(0,0,10)  )
			if particle then
				particle:SetVelocity( -Dir * 400 + Right * 150 * i )
				particle:SetDieTime( math.Rand(0.5,1) )
				particle:SetAirResistance( 150 ) 
				particle:SetStartAlpha( 50 )
				particle:SetStartSize( -80 )
				particle:SetEndSize( 400 )
				particle:SetColor( VecCol.x * 255,VecCol.y * 255,VecCol.z * 255 )
				particle:SetGravity( Vector( 0, 0, 100 ) )
				particle:SetCollide( false )
			end
		end
	end
end


function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH addons/__main/lua/effects/m9k_effect_mad_penetration_trace/init.lua:
EFFECT.Mat = Material( "effects/spark" ) 

/*---------------------------------------------------------
   EFFECT:Init(data)
---------------------------------------------------------*/
function EFFECT:Init(data)

	self.StartPos 	= data:GetStart()	
	self.EndPos 	= data:GetOrigin()
	self.Dir 		= self.EndPos - self.StartPos
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	
	self.TracerTime 	= 0.4
	
	// Die when it reaches its target
	self.DieTime 	= CurTime() + self.TracerTime
	
end

/*---------------------------------------------------------
   THINK
---------------------------------------------------------*/
function EFFECT:Think()

	if (CurTime() > self.DieTime) then return false end
	
	return true
end

/*---------------------------------------------------------
   Draw the effect
---------------------------------------------------------*/
function EFFECT:Render()

	local fDelta = (self.DieTime - CurTime()) / self.TracerTime
	fDelta = math.Clamp(fDelta, 0, 1)
			
	render.SetMaterial(self.Mat)
	
	local sinWave = math.sin(fDelta * math.pi)
	
	local color = Color(255, 255, 255, 255 * fDelta)
	
 	render.DrawBeam(self.StartPos, self.EndPos, 8 * fDelta, 1, 0, color) 
end
--PATH addons/____inventory/lua/itemstore/config.lua:
-- The maximum allowable size for stacked items. Set to math.huge for infinite stacks.
-- SOME ITEMS DO NOT OBEY THIS CONFIG OPTION!! Ammo and money are exempt for obvious reasons.
itemstore.config.MaxStack = 8

-- Where to save player data. Values are none, text, mysqloo (recommended) and tmysql4 (deprecated)
itemstore.config.DataProvider = "text"

-- If true, saves the player's inventory every time it's changed.
itemstore.config.SaveOnWrite = true

-- The gamemode to enable support for. Valid values are darkrp and darkrp24.
itemstore.config.GamemodeProvider = "darkrp"

-- Prefix for chat commands
itemstore.config.ChatCommandPrefix = "/"

-- The jobs that have access to an inventory. If this is empty, all teams have access.
-- Admins will still have access to their inventory though.
-- Names must be exact.
-- example: itemstore.config.LimitToTeams = { TEAM_CITIZEN, TEAM_COP }
itemstore.config.LimitToJobs = {}

-- The interval at which the inventory saves all players automatically, in seconds.
itemstore.config.SaveInterval = 180

-- The language of the inventory.
-- There are two languages by default, en (English), fr (French), de (German)
itemstore.config.Language = "ua"

-- Enable quick inventory viewing by holding the context menu key, default C.
itemstore.config.ContextInventory = true

-- If context inventory is enabled, this defines where it appears on the player's screen.
-- Valid values are "top", "bottom", "left", "right", "topleft", "topright", "bottomleft" and "bottomright"
itemstore.config.ContextInventoryPosition = "bottom"

-- Allow the use of the /invholster command
itemstore.config.EnableInvholster = false

-- Force player to holster all of their ammo as well as their gun when they use /invholster, ala DarkRP.
itemstore.config.InvholsterTakesAmmo = false

-- Split ammo on spawned_weapons instead of giving all ammo at once when used
itemstore.config.SplitWeaponAmmo = true

-- Force player to retrieve their items from the bank before being able to use them.
itemstore.config.PickupsGotoBank = false

-- The distance that the player is able to "reach" when picking up items.
itemstore.config.PickupDistance = 100

-- The distance that items will drop at relative to the player
itemstore.config.DropDistance = 100

-- The key to use in combination with +use (E) to pick up items.
-- A list of keys for this option is here: http://wiki.garrysmod.com/page/Enums/IN
-- Set this to -1 to disable the key combo.
itemstore.config.PickupKey = IN_DUCK

-- Whether or not trading should be enabled. Set this to false to disable.
itemstore.config.TradingEnabled = true

-- How long in seconds the player needs to wait after a trade to trade again
itemstore.config.TradeCooldown = 120

-- How close in hammer units two players need to be to trade. 0 means infinite.
itemstore.config.TradeDistance = 200

-- Whether or not the player should drop their inventory on death.
itemstore.config.DeathLoot = false

-- How long in seconds the player's dropped inventory should exist for.
itemstore.config.DeathLootTimeout = 60 * 5

-- Makes boxes breakable if enough damage is inflicted
itemstore.config.BoxBreakable = false

-- Amount of health for boxes to have
itemstore.config.BoxHealth = 100

-- Should users be able to pick up other users' entities
itemstore.config.IgnoreOwner = true

-- Fixes an old duplication exploit. This shouldn't be required anymore but is here in case it is still somehow possible.
itemstore.config.AntiDupe = true

-- Migrates text data from 2.0 to the current format.
-- This is experimental and may not function correctly. Please be careful if you decide to use this.
-- !!IMPORTANT!!
-- PLEASE make backups of your data -- this process is DESTRUCTIVE and will delete old data files 
-- and overwrite any inventory data that players currently have.
itemstore.config.MigrateOldData = false

-- Set to true to use the new container UI including search bar
itemstore.config.UseNewUI = true

-- Delay loading the player's inventory by this amount of seconds.
-- Use this if your ranks load from MySQL or other asynchronous sources (ie they won't be available right as the player initializes)
itemstore.config.LoadDelay = 1

-- Inventory sizes according to rank.
-- The format for this table is:
-- [ "<rank>" ] = { <width>, <height>, <pages> }
-- If a player's rank is not contained within this table, it defaults to default.
-- DO NOT REMOVE DEFAULT! If you remove it, there will be errors!
itemstore.config.InventorySizes = {
	[ "default" ] = { 8, 4, 1 }
}

-- Same as above, for banks. Same format. DON'T REMOVE DEFAULT!
itemstore.config.BankSizes = {
	[ "default" ] = { 10, 6, 2 },
	--[ "admin" ] = { 12, 4, 1 },
}

-- Whether or not to print ItemStore's log to the server console. Set this to true to enable.
itemstore.config.PrintLog = false

-- Log when players move their items around. Will create a lot of log noise that would not be very useful. Set this to true to enable.
itemstore.config.VerboseLogging = false

-- Whether or not to enable bLogs support. Having this enabled if you don't have bLogs shouldn't create any problems, but just in case it does, set this to false.
itemstore.config.bLogs = true

-- The skin to use. Preinstalled skins are "flat" and "classic".
itemstore.config.Skin = "flat"

-- The various colours of the VGUI in R, G, B, A 0-255 format.
-- Not available when using the flat skin
itemstore.config.Colours = {
	[ "Slot" ] = Color( 0, 0, 0, 150 ),
	[ "HoveredSlot" ] = Color( 255, 255, 255, 150 ),
	[ "Title" ] = Color( 255, 255, 255 ),
	[ "TitleBackground" ] = Color( 0, 0, 0, 200 ),
	[ "Upper" ] = Color( 100, 100, 100, 100 ),
	[ "Lower" ] = Color( 30, 30, 30, 150 ),
	[ "InnerBorder" ] = Color( 0, 0, 0, 0 ),
	[ "OuterBorder" ] = Color( 0, 0, 0, 200 )
}

-- The style of the item highlight. Options are "old", "border", "corner", subtle" and "full"
-- This is deprecated and will probably be removed in a later version
itemstore.config.HighlightStyle = "subtle"

-- Highlight colours for the various types of items. 
itemstore.config.HighlightColours = {
	[ "Weapons" ] = Color( 231, 76, 60 ),
	[ "Ammo" ] = Color( 241, 196, 15 ),
	[ "Shipments" ] = Color( 230, 126, 34 ),
	[ "Factories" ] = Color( 52, 152, 219 ), -- printers, gunlabs, microwaves, etc
	[ "Consumables" ] = Color( 26, 188, 156 ), -- drugs, food
	[ "Money" ] = Color( 46, 204, 113 ),
	[ "Other" ] = Color( 236, 240, 241 ), -- never delete this!
}

-- A table of disabled items. Set any value in this table to true to disallow picking up the item.
-- You can also add items to this array with the following format:
-- [ "my_item" ] = true,
-- This array also works for weapons, if you want to disable picking up a certain weapon in ItemStore entirely
itemstore.config.DisabledItems = {
	[ "microwave" ] = false,
	[ "money_printer" ] = false,
	[ "spawned_food" ] = false,
	[ "spawned_shipment" ] = false,
	[ "spawned_weapon" ] = false,
	[ "spawned_money" ] = true,
	[ "durgz_alcohol" ] = false,
	[ "durgz_aspirin" ] = false,
	[ "durgz_cigarette" ] = false,
	[ "durgz_cocaine" ] = false,
	[ "durgz_heroine" ] = false,
	[ "durgz_lsd" ] = false,
	[ "durgz_mushroom" ] = false,
	[ "durgz_pcp" ] = false,
	[ "durgz_weed" ] = false,
	[ "prop_physics" ] = true,
}

-- A table of weapons that cannot be invholstered. Works identically to the above table but exclusively for weapons and /invholster
itemstore.config.InvholsterDisabled = {
	[ "m9k_harpoon" ] = true
}

-- Custom items. Defining these will allow server owners to make certain
-- entities pickupable... but may not work 100%. If this is the case, you will probably
-- need to code the item definition yourself.
-- Format for each entry is:
-- <entity class> = { "<name>", "<description>", <stackable (optional)> }
itemstore.config.CustomItems = {}
--PATH addons/____inventory/lua/itemstore/vgui/container.lua:
local PANEL = {}

function PANEL:Init()
	self.Pages = {}
	self.Slots = {}

	table.insert( itemstore.containers.Panels, self )
end

function PANEL:SetContainerID( id )
	self.ContainerID = id
	self:Refresh()
end

function PANEL:GetContainerID()
	return self.ContainerID
end

function PANEL:Refresh()
	local id = self:GetContainerID()
	local con = itemstore.containers.Get( id )

	if con then
		for i = 1, con:GetSize() do
			local page_id = con:GetPageFromSlot( i )
			local page = self.Pages[ page_id ]

			if not page then
				page = vgui.Create( "DIconLayout" )
				page:SetSpaceX( 1 )
				page:SetSpaceY( 1 )

				self.Pages[ page_id ] = page

				self:AddSheet( itemstore.Translate( "page", page_id ), page )
			end

			local slot = self.Slots[ i ]

			if not slot then
				slot = page:Add( "ItemStoreNewSlot" )
				slot:SetSize( 40, 40 )
				slot:SetContainerID( self:GetContainerID() )
				slot:SetSlot( i )

				self.Slots[ i ] = slot
			end

			slot:SetItem( con:GetItem( i ) )
			slot:Refresh()
		end
	end

	self:SizeToContents()
end

function PANEL:SizeToContents()
	local id = self:GetContainerID()
	local con = itemstore.containers.Get( id )

	if con then
		local w = con:GetWidth() * 41 + 15
		local h = con:GetHeight() * 41 + 35

		self:SetSize( w, h )
	end
end

vgui.Register( "ItemStoreContainer", PANEL, "DPropertySheet" )

--PATH addons/____inventory/lua/itemstore/vgui/itemtooltip.lua:
DEFINE_BASECLASS( "DListLayout" )

local PANEL = {}

AccessorFunc( PANEL, "ContainerID", "ContainerID", FORCE_NUMBER )
AccessorFunc( PANEL, "Slot", "Slot", FORCE_NUMBER )
AccessorFunc( PANEL, "Item", "Item" )

function PANEL:Init()
	self:SetWide( 200 )
	self:SetDrawOnTop( true )
	self:DockPadding( 5, 5, 5, 5 )
	self:SetSkin( "itemstore" )

	self.Name = self:Add( "onyx.Label" )
	self.Name:SetFont( onyx.Font('Comfortaa Bold@16') )
	self.Name:SetWrap( true )

	self.Model = self:Add( "DModelPanel" )
	self.Model:SetSize( 125, 125 )

	self.Description = self:Add( "onyx.Label" )
	self.Description:SetWrap( true )
end

PANEL.Blurrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr = Material( "pp/blurscreen" )
function PANEL:Paint( w, h )
	self.Blurrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr:SetFloat( "$blur", 2 )
	self.Blurrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr:Recompute()
	render.UpdateScreenEffectTexture()

	local x, y = self:LocalToScreen( 0, 0 )

	surface.SetDrawColor( 255, 255, 255 )
	surface.SetMaterial( self.Blurrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr )
	surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )

	surface.SetDrawColor( Color( 30, 30, 30, 200 ) )
	surface.DrawRect( 0, 0, w, h )
end

function PANEL:PerformLayout()
	self.Name:SizeToContents()
	self.Description:SizeToContents()

	BaseClass.PerformLayout( self )
end

function PANEL:Refresh()
	local item = self:GetItem()

	if not item then
		self.Model.Entity:Remove()
		self.Name:SetText( "" )
		self.Description:SetText( "" )

		return
	end

	local name = item:GetName()
	local desc = item:GetDescription() or ""

	if item:GetAmount() > 1 then
		name = name .. " x" .. item:GetAmount()
	end

	if self:GetSlot() then
		desc = desc .. "\n\n" .. itemstore.Translate( "dragtomove" )
		desc = desc .. "\n" .. itemstore.Translate( "mclicktodrop" )
		desc = desc .. "\n" .. itemstore.Translate( "rclickforoptions" )

		if item.Use then
			desc = desc .. "\n" .. itemstore.Translate( "dclicktouse" )
		end
	end

	self.Name:SetText( name )
	self.Name:SizeToContents()

	self.Description:SetText( desc )
	self.Description:SizeToContents()

	self.Model:SetModel( item:GetModel() )

	if not IsValid(self.Model.Entity) then return end
	self.Model.Entity:SetMaterial( item:GetMaterial() )
	self.Model:SetColor( item:GetColor() or color_white )

	min, max = self.Model.Entity:GetRenderBounds()

	self.Model:SetCamPos( Vector( 0.55, 0.55, 0.55 ) * min:Distance( max ) )
	self.Model:SetLookAt( ( min + max ) * 0.5 )

	self:InvalidateLayout( true )
end

vgui.Register( "ItemStoreTooltip", PANEL, "DListLayout" )

--PATH addons/____inventory/lua/itemstore/vgui/newcontainer.lua:
local PANEL = {}

function PANEL:Init()
    self.Page = 1

	self.Pages = {}
	self.Slots = {}
    self.PageButtons = {}

    self.Toolbar = vgui.Create( "Panel", self )
    self.Toolbar:SetHeight( 32 )
    self.Toolbar:Dock( TOP )
    self.Toolbar:DockMargin( 0, 0, 0, 5 )

    self.SearchClear = vgui.Create( "onyx.Button", self.Toolbar )
    self.SearchClear:Dock( RIGHT )
    self.SearchClear:SetText( "X" )
    self.SearchClear:SetWidth( 32 )

    self.SearchClear.DoClick = function()
        self.Search:SetValue( "" )
        self:DoSearch()
    end

    self.Search = vgui.Create( "DTextEntry", self.Toolbar )
    self.Search:SetWidth( 200 )
    self.Search:Dock( RIGHT )
    self.Search:SetPlaceholderText( "Пошук..." )
    self.Search:RequestFocus()

    self.Search.OnChange = function()
        self:DoSearch()
    end

	table.insert( itemstore.containers.Panels, self )
end

function PANEL:GetPage()
    return self.Page
end

function PANEL:SetPage( page )
    self.Page = page

    for k, v in ipairs( self.Pages ) do
        if IsValid( v ) then
            v:SetVisible( k == page )
        end
    end
end

function PANEL:SetContainerID( id )
	self.ContainerID = id
	self:Refresh()
end

function PANEL:GetContainerID()
	return self.ContainerID
end

function PANEL:FadeToPage( page )
    local direction = page > self.Page and 1 or -1

    local current_page = self.Pages[ self.Page ]
    local next_page = self.Pages[ page ]

    if not IsValid( current_page ) or not IsValid( next_page ) then return end
    if current_page == next_page then return end

    --[[
    local x, y = current_page:GetPos()

    current_page:MoveTo( current_page:GetWide() * -direction , y, 0.25, 0, -1, function()
        next_page:SetPos( x + next_page:GetWide() * direction, y )
        self:SetPage( page )
        next_page:MoveTo( x, y, 0.25, 0, -1 )
    end )
    ]]

    current_page:AlphaTo( 0, 0.15, 0, function()
        next_page:SetAlpha( 0 )
        self:SetPage( page )
        next_page:AlphaTo( 255, 0.15, 0 )
    end )
end

function PANEL:Refresh()
	local id = self:GetContainerID()
	local con = itemstore.containers.Get( id )

    if con then
        for i = 1, con:GetPages() do
            if not self.PageButtons[ i ] then
                local button = vgui.Create( "onyx.Button", self.Toolbar )
                button:SetWidth( 32 )
                button:Dock( LEFT )
                button:DockMargin( 0, 0, 5, 0 )
                button:SetText( i )

                button.DoClick = function()
                    self:FadeToPage( i )
                end

                button.DragHoverClick = function()
                    button:DoClick()
                end

                self.PageButtons[ i ] = button
            end
        end

        for i = 1, con:GetSize() do
            local page_id = con:GetPageFromSlot( i )
			local page = self.Pages[ page_id ]

            if not page then
                page = vgui.Create( "Panel", self )
                page:Dock( FILL )
                page:SetVisible( page_id == self:GetPage() )
                --page:SetAlpha( page_id == self:GetPage() and 255 or 0 )

                self.Pages[ page_id ] = page
			end

			local slot = self.Slots[ i ]

            if not slot then
				slot = vgui.Create( "ItemStoreNewSlot", page )
				slot:SetContainerID( self:GetContainerID() )
				slot:SetSlot( i )

                self.Slots[ i ] = slot
            end
            
            slot:SetItem( con:GetItem( i ) )            
			slot:Refresh()
        end
        
        self:DoSearch() 
        self:InvalidateLayout()
	end
end

function PANEL:PerformLayout()
	local id = self:GetContainerID()
    local con = itemstore.containers.Get( id )
    if not con then return end

    local p = 2

    local page = self.Pages[ self:GetPage() ]
    if not IsValid( page ) then return end

    local w, h = page:GetSize()
    local cw, ch = con:GetWidth(), con:GetHeight()

    w = w - ( cw * p ) + p
    h = h - ( ch * p ) + p

    local sw, sh = w / cw, h / ch
    local ox, oy = 0, 0

    if itemstore.config.SquareSlots then
        if sw > sh then
            ox = ( sw - sh ) * cw * 0.5
            sw = sh
        else
            oy = ( sh - sw ) * ch * 0.5
            sh = sw
        end
    end

    local slots = page:GetChildren()

    for k, v in ipairs( slots ) do
        local x = ( k - 1 ) % cw 
        local y = math.floor( ( k - 1 ) / cw )

        local calc_x = ox + ( x * sw ) + ( p * x )
        local calc_y = oy + ( y * sh ) + ( p * y )

        v:SetPos( calc_x, calc_y )
        v:SetSize( sw, sh )
    end

    local w, sw = self:GetWide(), self.Search:GetWide()

    if sw * 1.5 > w then
        self.SearchClear:Hide()
        self.Search:Hide()
        self.Search:SetText( "" )
        self:DoSearch()
    else
        self.SearchClear:Show()
        self.Search:Show()
    end
end

function PANEL:DoSearch()
    local search = string.lower( self.Search:GetValue() )

    if search ~= "" then
        for k, v in ipairs( self.Slots ) do
            local item = v:GetItem() 
            
            if item then
                local class = string.lower( item:GetClass() )
                local name = string.lower( item:GetName() )
                local desc = string.lower( item:GetDescription() )

                if string.find( class, search ) or string.find( name, search ) or string.find( desc, search ) then
                    v:SetAlpha( 255 )
                else
                    v:SetAlpha( 50 )
                end
            else
                v:SetAlpha( 50 )
            end
        end
    else
        for k, v in ipairs( self.Slots ) do
            v:SetAlpha( 255 )
        end
    end
end

vgui.Register( "ItemStoreNewContainer", PANEL )


--PATH addons/____inventory/lua/itemstore/vgui/traderequest.lua:
local PANEL = {}

function PANEL:Init()
	self:SetSkin( "itemstore" )
	self:SetTitle( itemstore.Translate( "trade_request" ) )

	self:ShowCloseButton( false )

	self.Label = vgui.Create( "DLabel", self )

	self.Accept = vgui.Create( "onyx.Button", self )
	self.Accept:SetText( itemstore.Translate( "accept" ) )

	function self.Accept.DoClick()
		itemstore.trading.Panel = vgui.Create( "ItemStoreTrade" )
		itemstore.trading.Panel:Refresh()
		itemstore.trading.Panel:Center()
		itemstore.trading.Panel:MakePopup()

		self:Remove()
	end

	self.Deny = vgui.Create( "onyx.Button", self )
	self.Deny:SetText( itemstore.Translate( "deny" ) )
	
	function self.Deny.DoClick()
		net.Start( "ItemStoreCloseTrade" ) net.SendToServer()
		self:Remove()
	end
end

function PANEL:Refresh()
	self.Label:SetText( itemstore.Translate( "wants_to_trade",
		LocalPlayer().Trade.Left.Player:Name() ) )
end

function PANEL:PerformLayout()
	self.BaseClass.PerformLayout( self )

	self.Label:SizeToContents()
	self.Label:SetPos( self:GetWide() * 0.5 - self.Label:GetWide() * 0.5, 30 )

	self.Accept:SetSize( 75, 30 )
	self.Accept:SetPos( self:GetWide() * 0.5 - self.Accept:GetWide() - 15, self:GetTall() * 0.5 + 10 )

	self.Deny:SetSize( 75, 30 )
	self.Deny:SetPos( self:GetWide() * 0.5 + 15, self:GetTall() * 0.5 + 10 )
end

vgui.Register( "ItemStoreTradeRequest", PANEL, "DFrame" )

--PATH addons/____bricks_framework/lua/bricks_server/bricks_server_devcfg_main.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame or use the f4menu
    !!WARNING!!
]]--

BRICKS_SERVER.DEVCONFIG.BaseThemes = {}
BRICKS_SERVER.DEVCONFIG.BaseThemes.Red = Color(201, 70, 70)
BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed = Color(181, 50, 50)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Green = Color(46, 204, 113)
BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen = Color(39, 174, 96)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Gold = Color(201,176,55)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Silver = Color(180,180,180)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Bronze = Color(173,138,86)
BRICKS_SERVER.DEVCONFIG.BaseThemes.White = Color( 255, 255, 255 )
BRICKS_SERVER.DEVCONFIG.BaseThemes.Black = Color( 0, 0, 2505 )

BRICKS_SERVER.DEVCONFIG.AccentThemes = {}
BRICKS_SERVER.DEVCONFIG.AccentThemes["Turquoise"] = { Color(22, 160, 133), Color(26, 188, 156) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Emerald"] = { Color(39, 174, 96), Color(46, 204, 113) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Blue"] = { Color(41, 128, 185), Color(52, 152, 219) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Amethyst"] = { Color(142, 68, 173), Color(155, 89, 182) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Yellow"] = { Color(243, 156, 18), Color(241, 196, 15) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Orange"] = { Color(211, 84, 0), Color(230, 126, 34) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Red"] = { Color(181, 50, 50), Color(201, 70, 70) }

BRICKS_SERVER.DEVCONFIG.BackgroundThemes = {}
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["Dark"] = { Color(25, 25, 25), Color(40, 40, 40), Color(49, 49, 49), Color(68, 68, 68), Color( 255, 255, 255 ) }
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["DarkBlue"] = { Color(26, 41, 56), Color(36, 51, 66), Color(44, 62, 80), Color(52, 73, 94), Color( 255, 255, 255 ) }
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["Light"] = { Color(152, 157, 161), Color(170, 177, 182), Color(189, 195, 199), Color(236, 240, 241), Color( 0, 0, 0 ) }
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["Grey"] = { Color(101, 115, 116), Color(111, 125, 126), Color(127, 140, 141), Color(149, 165, 166), Color( 255, 255, 255 ) }

BRICKS_SERVER.DEVCONFIG.EntityTypes = BRICKS_SERVER.DEVCONFIG.EntityTypes or {}
BRICKS_SERVER.DEVCONFIG.EntityTypes["bricks_server_npc"] = { 
    GetDataFunc = function( entity ) 
        return entity:GetNPCKeyVar() or 0
    end,
    SetDataFunc = function( entity, data ) 
        return entity:SetNPCKey( data or 0 )
    end
}

BRICKS_SERVER.DEVCONFIG.NPCTypes = BRICKS_SERVER.DEVCONFIG.NPCTypes or {}

BRICKS_SERVER.DEVCONFIG.WeaponModels = {
    ["weapon_ar2"] = "models/weapons/w_irifle.mdl",
    ["weapon_bugbait"] = "models/weapons/w_bugbait.mdl",
    ["weapon_crossbow"] = "models/weapons/w_crossbow.mdl",
    ["weapon_crowbar"] = "models/weapons/w_crowbar.mdl",
    ["weapon_frag"] = "models/weapons/w_grenade.mdl",
    ["weapon_physcannon"] = "models/weapons/w_Physics.mdl",
    ["weapon_pistol"] = "models/weapons/w_pistol.mdl",
    ["weapon_rpg"] = "models/weapons/w_rocket_launcher.mdl",
    ["weapon_shotgun"] = "models/weapons/w_shotgun.mdl",
    ["weapon_slam"] = "models/weapons/w_slam.mdl",
    ["weapon_smg1"] = "models/weapons/w_smg1.mdl",
    ["weapon_stunstick"] = "models/weapons/w_stunbaton.mdl",
    ["weapon_medkit"] = "models/weapons/w_medkit.mdl",
    ["weapon_physgun"] = "models/weapons/w_Physics.mdl",
    ["gmod_tool"] = "models/weapons/w_toolgun.mdl",

    ["arrest_stick"] = "models/weapons/w_stunbaton.mdl",
    ["unarrest_stick"] = "models/weapons/w_stunbaton.mdl",
    ["stunstick"] = "models/weapons/w_stunbaton.mdl",
    ["weaponchecker"] = "models/weapons/v_hands.mdl",
}

BRICKS_SERVER.DEVCONFIG.KEY_BINDS = {
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "Numpad 0",
    "Numpad 1",
    "Numpad 2",
    "Numpad 3",
    "Numpad 4",
    "Numpad 5",
    "Numpad 6",
    "Numpad 7",
    "Numpad 8",
    "Numpad 0",
    "Numpad /",
    "Numpad *",
    "Numpad -",
    "Numpad +",
    "Numpad Enter",
    "Numpad .",
    "(",
    ")",
    ";",
    "'",
    "`",
    ",",
    ".",
    "/",
    [[\]],
    "-",
    "=",
    "Enter",
    "Space",
    "Backspace",
    "Tab",
    "Capslock",
    "Numlock",
    "Escape",
    "Scrolllock",
    "Insert",
    "Delete",
    "Home",
    "End",
    "Pageup",
    "Pagedown",
    "Break",
    "Left Shift",
    "Right Shift",
    "Alt",
    "Right Alt",
    "Left Control",
    "Right Control",
    "Left Windows",
    "Right Windows",
    "App",
    "Up",
    "Left",
    "Down",
    "Right",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "F11",
    "F12",
    "Capslock Toggle",
    "Numlock Toggle",
    "Last",
    "Count"
}

-- Inventory --
BRICKS_SERVER.DEVCONFIG.INVENTORY = BRICKS_SERVER.DEVCONFIG.INVENTORY or {}
BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs = {
    GetItemData = function( ent )
        local itemData = { ent:GetClass(), ent:GetModel() }
        
        return itemData, 1
    end,
    OnSpawn = function( ply, pos, itemData )
        local ent = ents.Create( itemData[1] )
        if( not IsValid( ent ) ) then return end
        ent:SetPos( pos )
        ent:SetModel( itemData[2] )
        ent:Spawn()
        if( ent.CPPISetOwner ) then ent:CPPISetOwner( ply ) end
        if( ent.Setowning_ent ) then ent:Setowning_ent( ply ) end
    end,
    ModelDisplay = function( Panel, itemData )
        if( not Panel.Entity or not IsValid( Panel.Entity ) ) then return end

        local mn, mx = Panel.Entity:GetRenderBounds()
        local size = 0
        size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
        size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
        size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )

        Panel:SetFOV( 65 )
        Panel:SetCamPos( Vector( size, size, size ) )
        Panel:SetLookAt( (mn + mx) * 0.5 )
    end,
    GetInfo = function( itemData )
        local name = BRICKS_SERVER.Func.GetList( "entities" )[itemData[1] or ""] or (itemData[1] or "Unknown")
        return { name, "Some " .. name .. ".", (BRICKS_SERVER.CONFIG.INVENTORY.ItemRarities or {})[itemData[1] or ""] }
    end,
    GetItemKey = function( itemData )
        return itemData[1]
    end,
    CanCombine = function( itemData1, itemData2 )
        if( itemData1[1] == itemData2[1] ) then
            return true
        end

        return false
    end,
}

BRICKS_SERVER.DEVCONFIG.RarityTypes = {}
BRICKS_SERVER.DEVCONFIG.RarityTypes["SolidColor"] = {
    Title = "Solid Color"
}
BRICKS_SERVER.DEVCONFIG.RarityTypes["Gradient"] = {
    Title = "Gradient"
}
BRICKS_SERVER.DEVCONFIG.RarityTypes["Fade"] = {
    Title = "Fade"
}
BRICKS_SERVER.DEVCONFIG.RarityTypes["Rainbow"] = {
    Title = "Rainbow"
}

BRICKS_SERVER.DEVCONFIG.Currencies = BRICKS_SERVER.DEVCONFIG.Currencies or {}
local function loadCurrencies()
    if( DarkRP ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["darkrp_money"] = {
            Title = "DarkRP Money",
            getFunction = function( ply )
                return ply:getDarkRPVar( "money" )
            end,
            addFunction = function( ply, amount )
                ply:addMoney( amount )
            end,
            formatFunction = function( amount )
                return DarkRP.formatMoney( amount )
            end
        }
    end

    if( BRICKSCREDITSTORE ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["brcs_credits"] = {
            Title = "Credits",
            getFunction = function( ply )
                return ply:GetBRCS_Credits()
            end,
            addFunction = function( ply, amount )
                ply:AddBRCS_Credits( amount )
            end,
            formatFunction = function( amount )
                return BRICKSCREDITSTORE.FormatCredits( amount )
            end
        }
    end

    if( mTokens ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["mtokens"] = {
            Title = "mTokens",
            getFunction = function( ply )
                return ((SERVER and mTokens.GetPlayerTokens(ply)) or (CLIENT and mTokens.PlayerTokens)) or 0
            end,
            addFunction = function( ply, amount )
                if( amount > 0 ) then
                    mTokens.AddPlayerTokens(ply, amount)
                else
                    mTokens.TakePlayerTokens(ply, math.abs(amount))
                end
            end,
            formatFunction = function( amount )
                return string.Comma( amount ) .. " Tokens"
            end
        }
    end
    
    BRICKS_SERVER.DEVCONFIG.Currencies["ps2_points"] = {
        Title = "PS2 Points",
        getFunction = function( ply )
            return (ply.PS2_Wallet or {}).points or 0
        end,
        addFunction = function( ply, amount )
            ply:PS2_AddStandardPoints( amount )
        end,
        formatFunction = function( amount )
            return string.Comma( amount ) .. " Points"
        end
    }

    BRICKS_SERVER.DEVCONFIG.Currencies["ps2_premium_points"] = {
        Title = "PS2 Premium Points",
        getFunction = function( ply )
            return (ply.PS2_Wallet or {}).premiumPoints or 0
        end,
        addFunction = function( ply, amount )
            ply:PS2_AddPremiumPoints( amount )
        end,
        formatFunction = function( amount )
            return string.Comma( amount ) .. " Premium Points"
        end
    }

    BRICKS_SERVER.DEVCONFIG.Currencies["ps1_points"] = {
        Title = "PS1 Points",
        getFunction = function( ply )
            return ply:PS_GetPoints() or 0
        end,
        addFunction = function( ply, amount )
            ply:PS_GivePoints( amount )
        end,
        formatFunction = function( amount )
            return string.Comma( amount ) .. " Points"
        end
    }

    if( SH_POINTSHOP ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["sh_points"] = {
            Title = "SH Points",
            getFunction = function( ply )
                return ply:SH_GetStandardPoints()
            end,
            addFunction = function( ply, amount )
                ply:SH_AddStandardPoints( amount )
            end,
            formatFunction = function( amount )
                return string.Comma( amount ) .. " Points"
            end
        }

        BRICKS_SERVER.DEVCONFIG.Currencies["sh_premium_points"] = {
            Title = "SH Premium Points",
            getFunction = function( ply )
                return ply:SH_GetPremiumPoints()
            end,
            addFunction = function( ply, amount )
                ply:SH_AddPremiumPoints( amount )
            end,
            formatFunction = function( amount )
                return string.Comma( amount ) .. " Premium Points"
            end
        }
    end
end

if( gmod.GetGamemode() ) then
    loadCurrencies()
else
    hook.Add( "OnGamemodeLoaded", "BRS.OnGamemodeLoaded.DevConfig", loadCurrencies )
end
--PATH addons/____esclib/lua/elib/essentials/libs/esc_message_pack.lua:
--[[
lua-MessagePack License
--------------------------

lua-MessagePack is licensed under the terms of the MIT/X11 license reproduced below.

===============================================================================

Copyright (C) 2012-2019 Francois Perrad.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

===============================================================================

(end of COPYRIGHT)
]]--


--
-- lua-MessagePack : <https://fperrad.frama.io/lua-MessagePack/>
--
local SIZEOF_NUMBER = string.pack and #string.pack('n', 0.0) or 8
local maxinteger
local mininteger
local assert = assert
local error = error
local pairs = pairs
local pcall = pcall
local setmetatable = setmetatable
local tostring = tostring
local char = string.char
local format = string.format
local floor = math.floor
local tointeger = floor
local frexp = math.frexp
local ldexp = math.ldexp
local huge = math.huge
local tconcat = table.concat
local type = type
local isnumber = isnumber
local _ENV = nil
local m = {}

--[[ debug only
local function hexadump (s)
	return (s:gsub('.', function (c) return format('%02X ', c:byte()) end))
end
m.hexadump = hexadump
--]]
local function argerror(caller, narg, extramsg)
	error("bad argument #" .. tostring(narg) .. " to " .. caller .. " (" .. extramsg .. ")")
end

local function typeerror(caller, narg, arg, tname)
	argerror(caller, narg, tname .. " expected, got " .. type(arg))
end

local function checktype(caller, narg, arg, tname)
	if type(arg) ~= tname then
		typeerror(caller, narg, arg, tname)
	end
end

local packers = setmetatable({}, {
	__index = function(t, k)
		if k == 1 then return end -- allows ipairs
		error("pack '" .. k .. "' is unimplemented")
	end
})

m.packers = packers

packers["nil"] = function(buffer)
	buffer[#buffer + 1] = char(0xC0) -- nil
end

packers["boolean"] = function(buffer, bool)
	if bool then
		buffer[#buffer + 1] = char(0xC3) -- true
	else
		buffer[#buffer + 1] = char(0xC2) -- false
	end
end

packers["string_compat"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error"overflow in pack 'string_compat'"
	end

	buffer[#buffer + 1] = str
end

packers["_string"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFF then
		buffer[#buffer + 1] = char(0xD9, n) -- str8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error("overflow in pack 'string'")
	end

	buffer[#buffer + 1] = str
end

packers["binary"] = function(buffer, str)
	local n = #str

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC4, n) -- bin8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC5, floor(n / 0x100), n % 0x100) -- bin16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC6, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- bin32
	else
		error("overflow in pack 'binary'")
	end

	buffer[#buffer + 1] = str
end

local set_string = function(str)
	if str == "string_compat" then
		packers["string"] = packers["string_compat"]
	elseif str == "string" then
		packers["string"] = packers["_string"]
	elseif str == "binary" then
		packers["string"] = packers["binary"]
	else
		argerror("set_string", 1, "invalid option '" .. str .. "'")
	end
end

m.set_string = set_string

packers["map"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x80 + n) -- fixmap
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDE, floor(n / 0x100), n % 0x100) -- map16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDF, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- map32
	else
		error("overflow in pack 'map'")
	end

	for k, v in pairs(tbl) do
		packers[type(k)](buffer, k)
		packers[type(v)](buffer, v)
	end
end

packers["array"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x90 + n) -- fixarray
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDC, floor(n / 0x100), n % 0x100) -- array16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDD, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- array32
	else
		error("overflow in pack 'array'")
	end

	for i = 1, n do
		local v = tbl[i]
		packers[type(v)](buffer, v)
	end
end

local set_array = function(array)
	if array == "without_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			-- there are holes
			if max ~= n then
				is_map = true
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, n)
			end
		end
	elseif array == "with_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, max)
			end
		end
	elseif array == "always_as_map" then
		packers["_table"] = function(buffer, tbl)
			local n = 0

			for k in pairs(tbl) do
				n = n + 1
			end

			packers["map"](buffer, tbl, n)
		end
	else
		argerror("set_array", 1, "invalid option '" .. array .. "'")
	end
end

m.set_array = set_array

packers["table"] = function(buffer, tbl)
	packers["_table"](buffer, tbl)
end

packers["unsigned"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0xFF then
			buffer[#buffer + 1] = char(0xCC, n) -- uint8
		elseif n <= 0xFFFF then
			buffer[#buffer + 1] = char(0xCD, floor(n / 0x100), n % 0x100) -- uint16
		elseif n <= 4294967295.0 then
			buffer[#buffer + 1] = char(0xCE, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint32
		else
			buffer[#buffer + 1] = char(0xCF, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0x100 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

packers["signed"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0x7FFF then
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n <= 0x7FFFFFFF then
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0xE0 + 0x20 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

local set_integer = function(integer)
	if integer == "unsigned" then
		packers["integer"] = packers["unsigned"]
	elseif integer == "signed" then
		packers["integer"] = packers["signed"]
	else
		argerror("set_integer", 1, "invalid option '" .. integer .. "'")
	end
end

m.set_integer = set_integer

packers["float"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCA, 0xFF, 0x88, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x80 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCA, 0x7F, 0x80, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCA, 0xFF, 0x80, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
		buffer[#buffer + 1] = char(0xCA, sign, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x7E
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 24))
		buffer[#buffer + 1] = char(0xCA, sign + floor(expo / 0x2), (expo % 0x2) * 0x80 + floor(mant / 0x10000), floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

packers["double"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x400 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCB, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x3FE then
		buffer[#buffer + 1] = char(0xCB, sign, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x3FE
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 53))
		buffer[#buffer + 1] = char(0xCB, sign + floor(expo / 0x10), (expo % 0x10) * 0x10 + floor(mant / 0x1000000000000), floor(mant / 0x10000000000) % 0x100, floor(mant / 0x100000000) % 0x100, floor(mant / 0x1000000) % 0x100, floor(mant / 0x10000) % 0x100, floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

local set_number = function(number)
	if number == "float" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["float"](buffer, n)
			end
		end
	elseif number == "double" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["double"](buffer, n)
			end
		end
	else
		argerror("set_number", 1, "invalid option '" .. number .. "'")
	end
end

m.set_number = set_number

for k = 0, 4 do
	local n = tointeger(2 ^ k)
	local fixext = 0xD4 + k

	packers["fixext" .. tostring(n)] = function(buffer, tag, data)
		assert(#data == n, "bad length for fixext" .. tostring(n))
		buffer[#buffer + 1] = char(fixext, tag < 0 and tag + 0x100 or tag)
		buffer[#buffer + 1] = data
	end
end

packers["ext"] = function(buffer, tag, data)
	local n = #data

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC7, n, tag < 0 and tag + 0x100 or tag) -- ext8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC8, floor(n / 0x100), n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC9, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext&32
	else
		error("overflow in pack 'ext'")
	end

	buffer[#buffer + 1] = data
end

function m.pack(data)
	local buffer = {}
	packers[type(data)](buffer, data)

	return tconcat(buffer)
end

local unpackers -- forward declaration

local function unpack_cursor(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local val = s:byte(i)
	c.i = i + 1

	return unpackers[val](c, val)
end

m.unpack_cursor = unpack_cursor

local function unpack_str(c, n)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return s:sub(i, e)
end

local function unpack_array(c, n)
	local t = {}

	for i = 1, n do
		t[i] = unpack_cursor(c)
	end

	return t
end

local function unpack_map(c, n)
	local t = {}

	for i = 1, n do
		local k = unpack_cursor(c)
		local val = unpack_cursor(c)

		if k == nil or k ~= k then
			k = m.sentinel
		end

		if k ~= nil then
			t[k] = val
		end
	end

	return t
end

local function unpack_float(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x2 + floor(b2 / 0x80)
	local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0xFF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 0x800000, expo - 0x7F)
	end

	c.i = i + 4

	return n
end

local function unpack_double(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
	local mant = ((((((b2 % 0x10) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0x7FF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 4503599627370496.0, expo - 0x3FF)
	end

	c.i = i + 8

	return n
end

local function unpack_uint8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	return b1
end

local function unpack_uint16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	return b1 * 0x100 + b2
end

local function unpack_uint32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
end

local function unpack_uint64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
end

local function unpack_int8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	if b1 < 0x80 then
		return b1
	else
		return b1 - 0x100
	end
end

local function unpack_int16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	if b1 < 0x80 then
		return b1 * 0x100 + b2
	else
		return ((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) - 1
	end
end

local function unpack_int32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	if b1 < 0x80 then
		return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
	else
		return ((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) - 1
	end
end

local function unpack_int64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	if b1 < 0x80 then
		return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	else
		return ((((((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) * 0x100 + (b5 - 0xFF)) * 0x100 + (b6 - 0xFF)) * 0x100 + (b7 - 0xFF)) * 0x100 + (b8 - 0xFF)) - 1
	end
end

function m.build_ext(tag, data)
	return nil
end

local function unpack_ext(c, n, tag)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return m.build_ext(tag, s:sub(i, e))
end

local fn_1 = function(c, val) return val end
local fn_2 = function(c, val) return unpack_map(c, val % 0x10) end
local fn_3 = function(c, val) return unpack_array(c, val % 0x10) end
local fn_4 = function(c, val) return unpack_str(c, val % 0x20) end
local fn_5 = function(c, val) return val - 0x100 end

unpackers = setmetatable({
	[0xC0] = function() return nil end,
	[0xC2] = function() return false end,
	[0xC3] = function() return true end,
	[0xC4] = function(c) return unpack_str(c, unpack_uint8(c)) end, -- bin8
	[0xC5] = function(c) return unpack_str(c, unpack_uint16(c)) end, -- bin16
	[0xC6] = function(c) return unpack_str(c, unpack_uint32(c)) end, -- bin32
	[0xC7] = function(c) return unpack_ext(c, unpack_uint8(c), unpack_int8(c)) end,
	[0xC8] = function(c) return unpack_ext(c, unpack_uint16(c), unpack_int8(c)) end,
	[0xC9] = function(c) return unpack_ext(c, unpack_uint32(c), unpack_int8(c)) end,
	[0xCA] = unpack_float,
	[0xCB] = unpack_double,
	[0xCC] = unpack_uint8,
	[0xCD] = unpack_uint16,
	[0xCE] = unpack_uint32,
	[0xCF] = unpack_uint64,
	[0xD0] = unpack_int8,
	[0xD1] = unpack_int16,
	[0xD2] = unpack_int32,
	[0xD3] = unpack_int64,
	[0xD4] = function(c) return unpack_ext(c, 1, unpack_int8(c)) end,
	[0xD5] = function(c) return unpack_ext(c, 2, unpack_int8(c)) end,
	[0xD6] = function(c) return unpack_ext(c, 4, unpack_int8(c)) end,
	[0xD7] = function(c) return unpack_ext(c, 8, unpack_int8(c)) end,
	[0xD8] = function(c) return unpack_ext(c, 16, unpack_int8(c)) end,
	[0xD9] = function(c) return unpack_str(c, unpack_uint8(c)) end,
	[0xDA] = function(c) return unpack_str(c, unpack_uint16(c)) end,
	[0xDB] = function(c) return unpack_str(c, unpack_uint32(c)) end,
	[0xDC] = function(c) return unpack_array(c, unpack_uint16(c)) end,
	[0xDD] = function(c) return unpack_array(c, unpack_uint32(c)) end,
	[0xDE] = function(c) return unpack_map(c, unpack_uint16(c)) end,
	[0xDF] = function(c) return unpack_map(c, unpack_uint32(c)) end
}, {
	__index = function(t, k)
		if k < 0xC0 then
			if k < 0x80 then
				return fn_1
			elseif k < 0x90 then
				return fn_2
			elseif k < 0xA0 then
				return fn_3
			else
				return fn_4
			end
		elseif k > 0xDF then
			return fn_5
		else
			return function()
				error("unpack '" .. format("%#x", k) .. "' is unimplemented")
			end
		end
	end
})

local function cursor_string(str)
	return {
		s = str,
		i = 1,
		j = #str,
		underflow = function()
			error("missing bytes")
		end
	}
end

local function cursor_loader(ld)
	return {
		s = '',
		i = 1,
		j = 0,
		underflow = function(self, e)
			self.s = self.s:sub(self.i)
			e = e - self.i + 1
			self.i = 1
			self.j = 0

			while e > self.j do
				local chunk = ld()

				if not chunk then
					error("missing bytes")
				end

				self.s = self.s .. chunk
				self.j = #self.s
			end
		end
	}
end

function m.unpack(s)
	checktype("unpack", 1, s, "string")
	local cursor = cursor_string(s)
	local data = unpack_cursor(cursor)

	if cursor.i <= cursor.j then
		error("extra bytes")
	end

	return data
end

function m.unpacker(src)
	if type(src) == "string" then
		local cursor = cursor_string(src)

		return function()
			if cursor.i <= cursor.j then return cursor.i, unpack_cursor(cursor) end
		end
	elseif type(src) == "function" then
		local cursor = cursor_loader(src)

		return function()
			if cursor.i > cursor.j then
				pcall(cursor.underflow, cursor, cursor.i)
			end

			if cursor.i <= cursor.j then return true, unpack_cursor(cursor) end
		end
	else
		argerror("unpacker", 1, "string or function expected, got " .. type(src))
	end
end

set_string("string")
set_integer("unsigned")

if SIZEOF_NUMBER == 4 then
	maxinteger = 16777215
	mininteger = -maxinteger
	m.small_lua = true
	unpackers[0xCB] = nil -- double
	unpackers[0xCF] = nil -- uint64
	unpackers[0xD3] = nil -- int64
	set_number("float")
else
	maxinteger = 9007199254740991
	mininteger = -maxinteger
	set_number("double")

	if SIZEOF_NUMBER > 8 then
		m.long_double = true
	end
end







--
local mp = m
local EXT_VECTOR  = 1
local EXT_ANGLE   = 2
local EXT_ENTITY  = 3
local EXT_PLAYER  = 4
local EXT_COLOR   = 5

mp.packers["Entity"] = function(buffer, ent)
	local buf = {}
	mp.packers["number"](buf, ent:EntIndex())
	mp.packers["ext"](buffer, EXT_ENTITY, buf[1])
end
mp.packers["Vehicle"] = mp.packers["Entity"]
mp.packers["Weapon"] = mp.packers["Entity"]
mp.packers["NPC"] = mp.packers["Entity"]
mp.packers["NextBot"] = mp.packers["Entity"]
mp.packers["PhysObj"] = mp.packers["Entity"]
-- mp.packers["Player"] = mp.packers["Entity"]

mp.packers["Player"] = function(buffer, ply)
	local buf = {}
	mp.packers["number"](buf, ply:UserID())
	mp.packers["ext"](buffer, EXT_PLAYER, buf[1])
end

local VECTOR = {}
mp.packers["Vector"] = function(buffer, vec)
	VECTOR[1] = vec.x
	VECTOR[2] = vec.y
	VECTOR[3] = vec.z

	local buf = {}
	mp.packers["_table"](buf, VECTOR)
	mp.packers["ext"](buffer, EXT_VECTOR, table.concat(buf))
end

local ANGLE = {}
mp.packers["Angle"] = function(buffer, ang)
	ANGLE[1] = ang.p
	ANGLE[2] = ang.y
	ANGLE[3] = ang.r

	local buf = {}
	mp.packers["_table"](buf, ANGLE)
	mp.packers["ext"](buffer, EXT_ANGLE, table.concat(buf))
end

local COLOR = {}
mp.packers["Color"] = function(buffer, col)
	COLOR[1] = col.r
	COLOR[2] = col.g
	COLOR[3] = col.b
	COLOR[4] = col.a

	local buf = {}
	mp.packers["_table"](buf, COLOR)
	mp.packers["ext"](buffer, EXT_COLOR, table.concat(buf))
end

local Entity = Entity
local Player = Player
local Color = Color
local Vector = Vector
local Angle = Angle
local unpackers = {
	[EXT_ENTITY] = function(v)
		return Entity(v)
	end,
	[EXT_PLAYER] = function(v)
		return Player(v)
	end,
	[EXT_VECTOR] = function(v)
		return Vector(v[1], v[2], v[3])
	end,
	[EXT_ANGLE] = function(v)
		return Angle(v[1], v[2], v[3])
	end,
}

set_array("always_as_map")
mp._VERSION = "0.5.2"
mp._DESCRIPTION = "lua-MessagePack : a pure Lua implementation"
mp._COPYRIGHT = "Copyright (c) 2012-2019 Francois Perrad"

mp.build_ext = function(tag, data)
	local f = mp.unpacker(data)
	local _, v = f()
	return unpackers[tag](v)
end

esclib.mp = mp
--PATH addons/____esclib/lua/elib/essentials/esc_draw.lua:
esclib.draw = {}

local clr_white = Color(255,255,255)
local clr_shadow = Color(30,30,33,200)

local sin = math.sin
local cos = math.cos
local rad = math.rad
local min = math.min

------------
--# TEXT #--
------------
function esclib.draw:ShadowText(text,font,px,py,col,textax,textay,offset,clr)
	local textax = textax or TEXT_ALIGN_LEFT
	local textay = textay or TEXT_ALIGN_TOP
	local offset = offset or 2

	draw.SimpleText(text,font, px+offset, py+offset, clr or clr_shadow, textax, textay)
	draw.SimpleText(text,font, px, py, col, textax, textay)
end

--------------
--# CIRCLE #--
--------------
function esclib.draw:GenCircle(x,y,r,v)
	local circle = {}
	local v = v or 360 -- poly count
    local angle = -rad(0) -- start angle
    local esin, ecos = sin(angle), cos(angle)
    for i = 0, 360, 360 / v do
        local newang = rad(i)
        local newsin, newcos = sin(newang), cos(newang)

        local oldcos = newcos * r * ecos - newsin * r * esin + x
        newsin = newcos * r * esin + newsin * r * ecos + y
        newcos = oldcos

        circle[#circle + 1] = {x = newcos,y = newsin}
    end
    return circle
end

function esclib.draw:PolyCircle( x, y, r, col, v)
	local circle = self:GenCircle(x,y,r, v or 360)

	if circle and #circle > 0 then
		surface.SetDrawColor(col:Unpack())
		draw.NoTexture()
		surface.DrawPoly(circle)
	end
end

function esclib.draw:Circle(x,y,r,col)
	local clr = esclib.addon:GetColors()

	x = x - r
	y = y - r
	col = col or clr_white

	surface.SetDrawColor(col:Unpack())
	surface.SetMaterial(esclib:GetMaterial("circle.png"))
	surface.DrawTexturedRect(x, y, r*2, r*2)
end

-------------
--# OTHER #--
-------------
function esclib.draw:Mask(func, drawfunc, inverse, reference, ...)
	if not reference then reference = 1 end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(inverse and STENCILOPERATION_REPLACE or STENCILOPERATION_KEEP)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(reference)

	func(...)

	if inverse then reference = reference - 1 end
	render.SetStencilFailOperation(inverse and STENCILOPERATION_REPLACE or STENCILOPERATION_KEEP)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(reference)

	drawfunc(...)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

-----------------
--# MATERIALS #--
-----------------
function esclib.draw:Material(x,y,w,h,col,mat)
	if not mat then return end
	col = col or color_white
	surface.SetDrawColor(col.r,col.g,col.b,col.a)
    surface.SetMaterial(mat)
    surface.DrawTexturedRect(x,y,w,h)
end

function esclib.draw:MaterialRotated(x,y,w,h,r,col,mat)
	if not mat then return end
	col = col or color_white
	surface.SetDrawColor(col.r,col.g,col.b,col.a)
    surface.SetMaterial(mat)
    surface.DrawTexturedRectRotated(x,y,w,h,r)
end

function esclib.draw:MaterialCentered(x,y,r,col,mat)
	self:Material(x-r, y-r, r*2, r*2, col, mat)
end

function esclib.draw:MaterialCenteredF(x,y,w,h,col,mat)
	self:Material(x-w*0.5, y-h*0.5, w, h, col, mat)
end

function esclib.draw:MaterialCenteredRotated(x,y,r,rot,col,mat)
	self:MaterialRotated(x, y, r*2, r*2, rot, col, mat)
end

function esclib.draw:MaterialCenteredShadowed(x,y,r,col,mat,offset, shadowcolor)
	local offset = offset or 1
	local shadowcolor = shadowcolor or clr_shadow
	self:Material(x-r+offset, y-r+offset, r*2+offset, r*2+offset, shadowcolor, mat)
	self:Material(x-r, y-r, r*2, r*2, col, mat)
end

function esclib.draw:MaterialEllipseCentered(x, y, width, height, col, mat)
    self:Material(x - width*0.5, y - height*0.5, width, height, col, mat)
end

-- https://dl.dropboxusercontent.com/u/104427432/Scripts/drawarc.lua
-- https://facepunch.com/showthread.php?t=1438016&p=46536353&viewfull=1#post46536353
function esclib.draw:SurfaceArc(arc,todraw)
	local todraw = min(#arc, (todraw or math.huge) )
	draw.NoTexture()
	for i=1,todraw do
		surface.DrawPoly(arc[i])
	end
end

function esclib.draw:Arc(cx,cy,radius,thickness,startang,endang,roughness,color,bClockwise)
	surface.SetDrawColor(color.r,color.g,color.b,color.a)
	local arc = esclib.util.PrecacheArc(cx,cy,radius,thickness,startang,endang,roughness,bClockwise) or {}
	esclib.draw:SurfaceArc(arc)
end

local blur = Material("pp/blurscreen")
function esclib.draw:Blur(pnl,amount)
	local x, y, w, h = pnl:GetBounds(0, 0)
    surface.SetDrawColor(color_white:Unpack())
    surface.SetMaterial(blur)
    for i = 1, amount do
        blur:SetFloat("$blur", 3)
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x,y,w,h)
    end
end

function esclib.draw:BlurRect(x, y, w, h)
	surface.SetDrawColor(255,255,255)
	surface.SetMaterial(blur)
	for i = 1, 2 do
		blur:SetFloat("$blur", (i / 4) * (4))
		blur:Recompute()

		render.UpdateScreenEffectTexture()

		render.SetScissorRect(x, y, x+w, y+h, true)
			surface.DrawTexturedRect(0, 0, ScrW(), ScrH())
		render.SetScissorRect(0, 0, 0, 0, false)
	end
end

function esclib.draw:Border(x,y,w,h, thickness, color, draw_left, draw_top, draw_right, draw_bottom)
	surface.SetDrawColor(color.r,color.g,color.b,color.a)
	if draw_left ~= false then surface.DrawRect(x,y,thickness,h) end
	if draw_top ~= false then surface.DrawRect(x,y,w,thickness) end
	if draw_right ~= false then surface.DrawRect(w-thickness, y, thickness, h) end
	if draw_bottom ~= false then surface.DrawRect(x, h-thickness, w, thickness) end
end

--Generates structure for gradient text
function esclib.draw:GradientText(text, font, col1, col2)
	local result = {}
	result["info"] = {
		["full_text"] = text,
		["font"] = font,
	}
	result["grad"] = {}
	local text_len = #text
	for i=1, text_len do
		local lp = i/text_len
		local clr = Color(col1.r, col1.g, col1.b, col1.a)
		clr.r = Lerp(lp, clr.r, col2.r)
		clr.g = Lerp(lp, clr.g, col2.g)
		clr.b = Lerp(lp, clr.b, col2.b)
		clr.a = Lerp(lp, clr.a, col2.a)
		table.insert(result["grad"], {utf8.sub(text, i, i), clr})
	end

	surface.SetFont(font)
	local text_w, text_h = surface.GetTextSize(text)
	result["info"]["text_w"] = text_w
	result["info"]["text_h"] = text_h

	function result:Draw(x,y, align_x, align_y, draw_shadow)
		
		local font = result["info"]["font"]
		surface.SetFont( font )

		if draw_shadow then
			draw.SimpleText(text, font, x+1, y+1, color_black, align_x, align_y)
		end

		if align_x == TEXT_ALIGN_CENTER then
			x = x - text_w*0.5
		elseif align_x == TEXT_ALIGN_RIGHT then
			x = x - text_w
		end

		if align_y == TEXT_ALIGN_CENTER then
			y = y - text_h*0.5
		elseif align_y == TEXT_ALIGN_BOTTOM then
			y = y - text_h
		end
		surface.SetTextPos( x, y )
		for _,v in ipairs(result["grad"]) do
			surface.SetTextColor(v[2]:Unpack())
			surface.DrawText(v[1])
		end
	end

	return result
end
--PATH addons/____esclib/lua/elib/essentials/esc_addons_core.lua:
local esclib = esclib

--LUA REFRESH
if not table.IsEmpty(esclib.addons or {}) then 
	esclib.loader:LoadAllAddons() 
end


function esclib:SafeMerge(table1, table2, forceOverride)
    local visited = {}

    local function mergeRecursive(t1, t2, visited)
        if visited[t1] or visited[t2] then
            error("Cycle detected during merge")
        end

        visited[t1] = true
        visited[t2] = true

        for key, value in pairs(t2) do
            if type(value) == "table" then
                if not t1[key] then
                    t1[key] = {}
                end
                mergeRecursive(t1[key], value, visited)
            else
                t1[key] = value
            end
        end
    end

    return mergeRecursive(table1, table2, visited)
end

esclib.addons = esclib.addons or {}

------------------------
--# SHARED FUNCTIONS #--
------------------------
--Just for ability to change usergroup function
function esclib:GetUserGroup(ply)
	return ply:GetUserGroup()
end

function esclib:GetAddons()
	return self.addons
end

function esclib:GetAddon(uid)
	return self.addons[uid]
end

function esclib:HasAddon(uid)
	return self.addons[uid] ~= nil
end

function esclib:IsTTT()
	return engine.ActiveGamemode() == 'terrortown'
end

function esclib:NetWriteCompressedTable(to_send, bits)
	local bits = bits or 16
	local c_json = util.Compress( util.TableToJSON(to_send) )
	local jsbytes = #c_json
	net.WriteUInt( jsbytes, bits )
	net.WriteData( c_json, jsbytes )
end

function esclib:NetReadCompressedTable(bits,pretty)
	local bits = bits or 16
	local bytes = net.ReadUInt(bits)
	local c_json = net.ReadData(bytes)
	c_json = util.Decompress(c_json) or "{}"
	c_json = util.JSONToTable(c_json, pretty)
	return c_json
end

function esclib:GetServerHash()
	if SERVER then return "" end
	return GetGlobalString("esclib.serveruid", "")
end

local function checktype(val, lua_type)
	local lua_type = lua_type or ""
    if isfunction(lua_type) then
        if not lua_type(val) then 
            error("Customcheck failed. Maybe wrong lua type provided?")
        end
    elseif type(val) ~= lua_type then
        error("Wrong lua type or value is empty [type(val) = "..type(val) .." lua_type = "..lua_type)
    end
end

function esclib.accessor(tbl, key, name, default_val, lua_type)
    if lua_type and default_val ~= nil then 
        checktype(default_val, lua_type)
    end
    tbl[key] = default_val
    
    local set_name = string.format("Set%s", name)
    local get_name = string.format("Get%s", name)
    tbl[set_name] = function(self, val)
        if lua_type and val ~= nil then
            checktype(val, lua_type)
        end
        self[key] = val
        return self
    end
    tbl[get_name] = function(self, val)
        return self[key]
    end
end


-----------------
--# SKIN BASE #--
-----------------
local skin_base = {}
skin_base["default"] = {}
skin_base["default"].roundsize = 8
skin_base["default"].colors = {}
skin_base["default"].colors.default = {
	red = Color(252, 29, 59),
	green = Color(30, 215, 96),
	blue = Color(30,33,250),
	white = Color(255,255,255),
	black = Color(13,13,13),
	orange = Color(255, 117, 23),
	shadow = Color(0,0,0,255),
}

------------------
--# ADDON META #--
------------------
local ADDON_META = {}
ADDON_META.__index = ADDON_META

function ADDON_META:GetName()
    return self.info.name
end

function ADDON_META:GetDescription()
    return self.info.description
end

function ADDON_META:GetSortOrder()
    return self.info.sort_order
end

function ADDON_META:GetColor()
    return self.info.color
end

function ADDON_META:GetVar(varid)
    return self.data.shared_vars[varid] or self.data.vars[varid]
end

function ADDON_META:SetVar(varid, value)
    self.data.vars[varid] = value
    self:SyncVars(-1) -- vars -> settings
    self:SaveSettings()
    return true
end

function ADDON_META:GetBranch()
    return self.info.branch
end

function ADDON_META:GetVersion()
    return self.info.version
end

function ADDON_META:GetWrappedVar(tab, var) -- just safe function
    if not self.data.settings[tab] then return end
    return self.data.settings[tab][var]
end

function ADDON_META:SetName(newname)
    self.info.name = newname
end

function ADDON_META:SetBranch(branch)
    self.info.branch = branch
end

function ADDON_META:SetVersion(newversion)
    self.info.version = newversion
end

function ADDON_META:SetDescription(newdesc)
    self.info.description = newdesc
end

function ADDON_META:SetSortOrder(order)
    self.info.sort_order = order
end

function ADDON_META:SetColor(newclr)
    if not IsColor(newclr) then return end
    self.info.color = newclr
end
local function formatMessage(self, ...)
	local t_clr = color_white
	return {t_clr, "[", self:GetColor(), self:GetName(), t_clr, "]: ", ...}
end

function ADDON_META:Print(...)
	local msg = formatMessage(self, ...)
	MsgC(unpack(msg))
	MsgC("\n")
end

function ADDON_META:ChatPrint(recievers, ...)
    local args = {...}
    
    if CLIENT and recievers then
        table.insert(args, 1, recievers)
    end

    local msg = formatMessage(self, unpack(args))
    
    if CLIENT then
        chat.AddText(unpack(msg))
    else
        if not istable(recievers) then
            recievers = {recievers}
        end

        for _, receiver in ipairs(recievers) do
            if IsValid(receiver) and receiver:IsPlayer() then
                receiver:EsclibChatPrint(unpack(msg))
            end
        end
    end
end

-------------------
--# CLIENT META #--
-------------------
if (CLIENT) then
	ADDON_META.SetThumbnail = function(self, newmat)
		if type(newclr or "") == "IMaterial" then return end
		self.info.thumbnail = newmat
	end
	ADDON_META.GetThumbnail = function(self) return self.info.thumbnail end

	ADDON_META.RegisterSkin = function(self, skin_name, skin_data)
		if not isstring(skin_name) then error("Invalid Skin Name (Name must be a string) - "..tostring(skin_name)) end
		if not istable(skin_data) then error("Invalid Skin Data (Must be a table) - "..tostring(skin_name)) end
		local skin_name = string.lower(skin_name)
		
		local skin_data = table.Copy(skin_data or {})
		local base_skin = table.Copy(skin_base["default"])

		skin_data["roundsize"] = base_skin.roundsize or 8
		for clr_name, clr in pairs(base_skin["colors"] or {}) do
			skin_data["colors"][clr_name] = clr
		end

		--if exist
		if self.data.skins[skin_name] then
			self.data.skins[skin_name] = skin_data
			hook.Run(self.info.uid.."_skin_changed",skin_name)
			return
		end

		self.data.skins[skin_name] = skin_data
	end
	ADDON_META.SetSkin = function(self, skin_name)
		if not skin_name then return false end
		if not isstring(skin_name) then tostring(skin_name) end
		local skin_name = string.lower(skin_name)

		if self.data.skins[skin_name] then
			self.info.active_skin = skin_name

			hook.Run(self.info.uid.."_skin_changed",skin_name)

			return true
		else
			return false
		end
	end
	ADDON_META.SetDefaultSkin = function(self,skin_name)
		if not skin_name then return false end
		if not isstring(skin_name) then tostring(skin_name) end
		if self.data.skins[skin_name] then
			self.info.default_skin = skin_name
			if not self.info.active_skin then 
				self.info.active_skin = self.info.default_skin 
				self:LoadCustomSkin()
				self:LoadCurrentSkin()
			end
		end
	end
	ADDON_META.GetSkinByName = function(self,skin_name)
		if not skin_name then return false end
		if not isstring(skin_name) then tostring(skin_name) end 
		return self.data.skins[skin_name]
	end
	ADDON_META.GetCurrentSkin = function(self)
		return self.data.skins[self.info.active_skin]
	end
	ADDON_META.GetColors = function(self)
		return self:GetCurrentSkin()["colors"]
	end

	ADDON_META.SaveCurrentSkin = function(self)
		local dir_path = self.prefix..self.info.uid..self["sv_hash"]
		local file_name = dir_path.."/"..self.other_settings_filename
		esclib.file:SaveVar(file_name,{["skin"] = self.info.active_skin})
		end

	ADDON_META.LoadCurrentSkin = function(self)
		local dir_path = self.prefix..self.info.uid..self["sv_hash"]
		local file_name = dir_path.."/"..self.other_settings_filename
		local skin = esclib.file:ReadVar(file_name,"skin")
		if skin then
			self:SetSkin(skin)
		end
	end

	function ADDON_META:SaveCustomSkin()
		local dir_path = self.prefix..self.info.uid..self["sv_hash"]
		local file_name = dir_path.."/"..self.custom_skin_filename
		local custom_skin = self:GetSkinByName("skin_custom")

		if custom_skin then
			esclib.file:SaveVar(file_name,{["skin"] = self:GetSkinByName("skin_custom")})
		else
			custom_skin = table.Copy(self.data.skins[self.info.default_skin])

			esclib.file:SaveVar(file_name,{["skin"] = custom_skin})
			self.data.skins["skin_custom"] = custom_skin
		end
	end

	function ADDON_META:ReturnCustomSkinToDefault()
		local dir_path = self.prefix..self.info.uid..self["sv_hash"]
		local file_name = dir_path.."/"..self.custom_skin_filename

		file.Delete(file_name)
		local custom_skin = table.Copy(self.data.skins[self.info.default_skin])

		-- esclib.file:SaveVar(file_name,{["skin"] = custom_skin})
		self.data.skins["skin_custom"] = custom_skin
		self:SetSkin("skin_custom")
	end

	function ADDON_META:LoadCustomSkin()
		local dir_path = self.prefix..self.info.uid..self["sv_hash"]
		local file_name = dir_path.."/"..self.custom_skin_filename
		local custom_skin = esclib.file:ReadVar(file_name,"skin")
		if custom_skin then
			self.data.skins["skin_custom"] = self.data.skins["skin_custom"] or {}
			esclib:SafeMerge(self.data.skins["skin_custom"],custom_skin, true)
		else
			custom_skin = table.Copy(self.data.skins[self.info.default_skin])
			self.data.skins["skin_custom"] = custom_skin
		end
	end

	function ADDON_META:DownloadMaterial(url, on_succ, on_err, retry_count, additional_path)
		if not url then error("URL is empty") end
		local path = self.info.uid
		if additional_path then
			path = path .. "/" .. additional_path
		end
		local filename = util.SHA1(url)..".png"
		esclib:DownloadMaterial(url, path, filename, on_succ, on_err, retry_count)
	end

	function ADDON_META:ClearDownloadCache(additional_path)
		local path = self.info.uid
		if additional_path then
			path = path .. "/" .. additional_path
		end
		esclib:ClearDownloadCache(path)
	end

	local function recurse_print_skin(add,tbl)
		if not tbl then 
			tbl = add
			add = ""
		end
		local add = add or ""
		for k,v in pairs(tbl) do
			if istable(v) then
				if ((v["r"]) and (v["g"]) and (v["b"]) and (v["a"])) then --iscolor dont work with tables
					MsgC((string.len(add) < 1) and "skin." or "" )
					MsgC(add..''..k..' = ')
					MsgC(Color(v.r,v.g,v.b,v.a), string.format('Color(%d, %d, %d', v.r,v.g,v.b)..(v.a ~= 255 and (","..v.a) or '')..")" )
					MsgC((string.len(add) < 1) and "" or ",")
				else
					MsgC(add..'["'..k..'"] = {\n')
					recurse_print_skin("\t"..add,v)
					MsgC(add.."}"..((string.len(add) < 1) and "" or "," ))
				end
			else
				MsgC("skin.")
				if type(v) == "string" then
					MsgC(add..''..k..' = "'..v..'"')
				else
					MsgC(add..''..k..' = '..tostring(v).."")
				end
				MsgC((string.len(add) < 1) and "" or "," )
			end
			MsgC("\n")
		end
	end

	function ADDON_META:PrintSkin(skin_name)
		local skin_name = skin_name or ""

		local skin = self.data.skins[skin_name]
		if not skin then return end
		MsgC("local skin = {}\n")
		MsgC("skin")
		recurse_print_skin(skin)

		MsgC('\nesclib.addon:RegisterSkin("'..string.lower(skin.name)..'_new", skin) --Or any other addon\n')
	end

	function ADDON_META:GetAllCustomTabs()
		return self.data["settings_tabs"]
	end

	--Add tab to addon settings
	--func parameters: addon, combo_panel, callback
	function ADDON_META:AddSettingsTab(uid,realm,sort_order,func)
		local func = func or sort_order
		if not realm or not sort_order or not func then return end

		local allowed_realms = {
			["realm_Client"] = true,
			["realm_Server"] = true,
		}

		if not allowed_realms[realm] then
			error("Invalid realm ["..realm.."] (Must be realm_Client or realm_Server)")
		end

		self.data["settings_tabs"][uid] = {
			name = uid,
			realm = realm,
			func = func,
			sortOrder = sort_order or 0,
		}
	end

	function ADDON_META:RemoveSettingsTab(uid)
		self.data["settings_tabs"][uid] = nil
	end

	function ADDON_META:RequestSettings()
		print("["..self.info.uid.."] - ".."Requesting settings from server")
		net.Start("esclib.RequestConfig")
			net.WriteString(self.info.uid)
		net.SendToServer()
	end

	--RECIEVE CONFIG FROM SERVER
	net.Receive("esclib.SendConfig", function(len)

		local rewrite = false --respect server settings first

		local addon_name = net.ReadString()
		local all_addons = esclib:GetAddons()
		if not all_addons[addon_name] then return end
		local addon = all_addons[addon_name]

		local bytes = net.ReadUInt(16)
		local c_json = net.ReadData(bytes)

		local c_json = util.Decompress(c_json)
		if isstring(c_json) then 
			print(string.format("[ESCLIB] [%s] Recieved config from server",addon_name or ""))
			c_json = util.JSONToTable(c_json)

			local vars = c_json["vars"]
			local lang = c_json["lang"]
			local skin = c_json["skin"]
			local custom_skin = c_json["cst_skin"]
			local shared_vars = c_json["shared_vars"]

			local changed_vars = {}

			--settings
			if vars then
				for var_name,var_value in pairs(vars) do
					if addon.data.vars[var_name] ~= var_value then
						addon.data.vars[var_name] = var_value
						changed_vars[var_name] = var_value
					end
				end
				addon:SyncVars(-1) --vars -> settings
				--set as default
				esclib:SafeMerge(addon.data["default_settings"], addon.data.vars, true)

				if not rewrite then
					addon:LoadSettings() --load from file (file has more priority)
				end
			end

			--language
			if lang then 
				addon:SetLanguage(lang) 
				addon.info.default_language = addon.info.language
				if not rewrite then
					addon:LoadLanguage()
				end
			end

			--skin
			if skin then 
				if addon:SetSkin(skin) then
					addon.info.default_skin = skin
				end
				if not rewrite then
					addon:LoadCurrentSkin()
				end
			end

			--custom skin
			if custom_skin then
				addon.data.skins["skin_custom"] = addon.data.skins["skin_custom"] or {}
				esclib:SafeMerge(addon.data.skins["skin_custom"], custom_skin, true)
				if not rewrite then
					addon:LoadCustomSkin()
				end
			end

			--Shared settings (from server)
			if shared_vars then
				for var_name,var_value in pairs(shared_vars) do
					local orig_val = addon.data.shared_vars[var_name]
					if orig_val ~= var_value then 
						if orig_val ~= nil then changed_vars[var_name] = var_value end --only invoke changed if not first
						addon.data.shared_vars[var_name] = var_value
					end
				end
			end

			if rewrite then
				self:SaveSettings()
			end

			hook.Run(addon.info.uid.."_settings_changed",true, changed_vars)
		end

	end)

	function ADDON_META:CurrentSettingsToGlobal()
		local to_write = {}
	
		to_write["vars"] = self.data.vars
		to_write["lang"] = self:GetLanguage()
		to_write["skin"] = self.info.active_skin
		to_write["cst_skin"] = self.data.skins["skin_custom"]
	
		
		local c_json = util.TableToJSON(to_write)
		c_json = util.Compress(c_json)
		local bytes = #c_json
		
		local MAX_BYTES = 65535 --64k
		if bytes > MAX_BYTES then
			print("Error: Data size exceeds the maximum allowed limit.")
			return
		end
	
		net.Start("esclib.SendConfig")
			net.WriteString(self.info.uid)
			net.WriteUInt(bytes, 16) --64k
			net.WriteData(c_json, bytes)
		net.SendToServer()
	end

	function ADDON_META:ClearGlobalConfig()
		net.Start("esclib.ClearConfig")
			net.WriteString(self.info.uid)
		net.SendToServer()
	end

	function ADDON_META:RequestServerSettings(callback)
		if not esclib:HasAdminAccess(LocalPlayer()) then return end

		net.Start("esclib.RequestServerConfig")
			net.WriteString(self.info.uid)
		net.SendToServer()

		if callback and isfunction(callback) then
			local hook_name = self.info.name.."_request_callback"
			hook.Remove("esclib.ServerConfigRecieved",hook_name)
			hook.Add("esclib.ServerConfigRecieved", hook_name, function()
				hook.Remove("esclib.ServerConfigRecieved", hook_name)
				callback(self)
			end)
		end
	end

	net.Receive("esclib.SendServerConfig", function(len)
		local addon_name = net.ReadString()
		local addon = esclib:GetAddon(addon_name or "")
		if addon == nil then return end

		local bytes = net.ReadUInt(16)
		local c_json = net.ReadData(bytes)
		c_json = util.Decompress(c_json)

		if not isstring(c_json) then return end

		c_json = util.JSONToTable(c_json)
		if istable(c_json) and not table.IsEmpty(c_json) then
			table.Empty(addon.data["server_vars"])
			addon.data["server_vars"] = c_json
		end
		hook.Run("esclib.ServerConfigRecieved")
	end)

end

---------------------
--# SETTINGS META #--
---------------------
ADDON_META["settings_filename"] = "settings.json"
ADDON_META["custom_skin_filename"] = "custom_skin.json"
ADDON_META["other_settings_filename"] = "other_settings.json"
ADDON_META["prefix"] = CLIENT and "cl_" or "sv_"
ADDON_META["sv_hash"] = esclib:GetServerHash()

-- Direction:
-- >= 0  => settings -> vars
-- < 0 => var -> settings
function ADDON_META:SyncVars(direction)
	local direction = direction or 0

	for tabname,tab_content in pairs(self.data.settings) do
		local vars = tab_content["vars"]
		for varid,var in pairs(vars) do
			if direction >= 0 then
				--vars
				self.data.vars[varid] = var.value
			else
				--settings
				tab_content["vars"][varid]["value"] = self.data.vars[varid]
			end
		end
	end
end

--Save settings to disk
function ADDON_META:SaveSettings()
	local dir_path = self.prefix..self.info.uid..self["sv_hash"]
	local file_name = dir_path.."/"..self.settings_filename
	local json_str = util.TableToJSON(self.data.vars or {})
	if not file.Exists(dir_path, "DATA") then
		file.CreateDir(dir_path)
	end
	if json_str then
		file.Write(file_name, json_str)
	end
end

--Load settings (without languages / skin data)
function ADDON_META:LoadSettings()
	local dir_path = self.prefix..self.info.uid..self["sv_hash"]
	local file_name = dir_path.."/"..self.settings_filename

	local content = file.Read(file_name, "DATA")
	if content then
		local vars = util.JSONToTable(content)

		if istable(vars) and not table.IsEmpty(vars) then

			--changable check
			for name,val in pairs(vars) do
				for tab_name,content in pairs(self.data.settings) do
					local var = self:GetWrappedVar(tab_name,name)
					if not var then continue end

					local result = true
					if var.customCheck then 
						result = var.customCheck(var,self)
					end

					if not result then
						vars[name] = nil
					end
				end
			end

			esclib:SafeMerge(self.data.vars, vars, true) --merge vars from file and current with overwrite
			self:SyncVars(-1) --sync vars from vars to wrapped settings(used for settings menu and custom checks)
			hook.Run(self.info.uid.."_settings_changed",true, {})
		end

	end
end

function ADDON_META:LoadAll()
	self:LoadSettings()
	self:LoadLanguage()
	self:LoadCustomSkin()
	self:LoadCurrentSkin()
end

--Init settings and load from file
function ADDON_META:RegisterSettings(settings)
	--we have already registered settings. Why change it?
	if not table.IsEmpty(self.data["settings"]) then return end

	--On first function launch
	self.data["settings"] = table.Copy(settings)
	self:SyncVars(1) -- Settings -> vars
	self.data["default_settings"] = table.Copy(self.data.vars) --copy default vars

	--attemp to load settings from file
	self:LoadSettings()
end

--Used on client to 
function ADDON_META:RegisterServerSettings(settings)
	if SERVER then
		self:RegisterSettings(settings) --register settings on server
	end
	
	if CLIENT then
		--we have already registered settings. Why change it?
		if not table.IsEmpty(self.data["server_settings"]) then return end

		--On first function launch
		self.data["server_settings"] = table.Copy(settings)

		--Save defaults
		for tab_name,tab_value in pairs(self.data["server_settings"]) do
			for var_name, var in pairs(tab_value["vars"] or {}) do
				self.data["server_default_settings"][var_name] = var.value
			end
		end
	end
end

--Replace current settings and write to file
function ADDON_META:ReplaceSettings(settings,dont_save)
	esclib:SafeMerge(self.data["settings"], settings, true)
	self:SyncVars(1)
	if not dont_save then
		self:SaveSettings()
	end
end

--Return settings to default and delete settings from file
function ADDON_META:ReturnSettingsToDefault()

	--Settings
	local dir_path = self.prefix..self.info.uid..self["sv_hash"]
	local file_name = dir_path.."/"..self.settings_filename
	if file.Exists(file_name, "DATA") then --clear from file
		file.Delete(file_name)
	end
	self.data.vars = table.Copy(self.data["default_settings"])
	self:SyncVars(-1) --vars -> settings

	if (CLIENT) then
		--Language
		file_name = dir_path.."/"..self.other_settings_filename
		
		if file.Exists(file_name, "DATA") then --clear from file
			file.Delete(file_name)
		end

		self:LoadLanguage()
		self:SetSkin(self.info.default_skin)
	end

	hook.Run(self.info.uid.."_settings_changed",true, {})

end


----------------------
--# LANGUAGES META #--
----------------------
function ADDON_META:RegisterLanguages(langs)
	if not langs then return end
	if not istable(langs) then return end
	esclib:SafeMerge(self.data.languages, langs, true)
end

function ADDON_META:GetLanguage()
	return self.info.language
end

function ADDON_META:GetDefaultLanguage()
	return self.info.default_language
end

function ADDON_META:GetLanguages()
	return self.data.languages
end

function ADDON_META:HasLanguage(lang)
	return self.data.languages[lang] ~= nil
end

function ADDON_META:SaveLanguage()
	local dir_path = self.prefix..self.info.uid..self["sv_hash"]
	local file_name = dir_path.."/"..self.other_settings_filename
	esclib.file:SaveVar(file_name,{["language"] = self.info.language})
end

function ADDON_META:LoadLanguage()
	local dir_path = self.prefix..self.info.uid..self["sv_hash"]
	local file_name = dir_path.."/"..self.other_settings_filename
	local language = esclib.file:ReadVar(file_name, "language")

	if language and string.len(tostring(language)) > 0 then 
		self:SetLanguage(language)
	else
		local game_language = GetConVar("gmod_language"):GetString()
		if self:HasLanguage(game_language) then
			self:SetLanguage(game_language)
		else
			self:SetLanguage(self:GetDefaultLanguage())
		end
	end
end

function ADDON_META:SetLanguage(lang)
	if not lang then return end
	if not isstring(lang) then return end
	lang = string.lower(lang)
	if self:HasLanguage(lang) then
		self.info.language = lang
	else
		return false
	end
	return true
end

function ADDON_META:SetDefaultLanguage(lang, dont_load)
	if self:HasLanguage(lang) then
		self.info.default_language = lang
	end

	if not dont_load then
		self:LoadLanguage()
	end
end

function ADDON_META:Translate(var, lang)
    if not var or var == "" then return end
	
	local def_lang = self:GetDefaultLanguage()
	local cLang = lang or (self:GetLanguage() or def_lang)
	local languages = self:GetLanguages()

    if languages[cLang] then
        if not languages[cLang][var] then
            return "#" .. var
        end
        return languages[cLang][var]
    else
        if cLang == def_lang then --prevent recursion
            return "#" .. var
        end
        return self:Translate(var, def_lang)
    end
end

--translate if there is # before str
function ADDON_META:TranslateIf(var, lang)
	if string.StartsWith(var, "#") then
		local var = string.TrimLeft(var, "#")
		return self:Translate(var, lang)
	else
		return var
	end
end

function ADDON_META:CanTranslate(var,lang)
	if not var then return false end
	local lang = lang or (self.info.language or (self.info.default_language or "en"))
	local lv = self:GetLanguages()[lang]

	if lv then
		return lv[var] ~= nil
	else
		return false
	end
end

function esclib:Addon(str_addon)
	if not isstring(str_addon) then return end
	local str_addon = string.lower( str_addon )
	-- if exists
	if self.addons[str_addon] then
		if not table.IsEmpty(self.addons[str_addon]) then
			-- self.addons[str_addon] = nil
			setmetatable(self.addons[str_addon], ADDON_META)
			return self.addons[str_addon]
		end
	end

	--if not exists
	local addon = {}
	addon.info = {
		["uid"] = str_addon,
		["name"] = str_addon,
		["version"] = "1.0",
		["color"] = Color(255,255,255),
		["description"] = "No description.",
		["sort_order"] = 0,
	}
	addon.data = {
		settings = {},
		settings_tabs = {},
		vars = {}, --Similar to settings, but with more convenient access to variables
		languages = {},
	}
	if CLIENT then --only client data
		addon.data.skins = {}
		addon.data.server_settings = {} --Server interface.
		addon.data.server_default_settings = {}
		addon.data.server_vars = {} --real data. Recieved when requested by player
		addon.data.shared_vars = {}
	end

	setmetatable(addon, ADDON_META)

	self.addons[str_addon] = addon
	return addon
end































--PATH addons/____esclib/lua/elib/vgui/esc_colorpicker.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_ConVarR", "ConVarR" )
AccessorFunc( PANEL, "m_ConVarG", "ConVarG" )
AccessorFunc( PANEL, "m_ConVarB", "ConVarB" )
AccessorFunc( PANEL, "m_ConVarA", "ConVarA" )

AccessorFunc( PANEL, "m_bPalette", "Palette", FORCE_BOOL )
AccessorFunc( PANEL, "m_bAlpha", "AlphaBar", FORCE_BOOL )
AccessorFunc( PANEL, "m_bWangsPanel", "Wangs", FORCE_BOOL )

AccessorFunc( PANEL, "m_Color", "Color" )

local BarWide = 20

local function CreateWangFunction( self, colindex )
	local function OnValueChanged( ptxt, strvar )
		if ( ptxt.notuserchange ) then return end

		local targetValue = tonumber( strvar ) or 0
		self:GetColor()[ colindex ] = targetValue
		if ( colindex == "a" ) then
			self.Alpha:SetBarColor( ColorAlpha( self:GetColor(), 255 ) )
			self.Alpha:SetValue( targetValue / 255 )
		else
			self.HSV:SetColor( self:GetColor() )

			local h, s, v = ColorToHSV( self.HSV:GetBaseRGB() )
			self.RGB.LastY = ( 1 - h / 360 ) * self.RGB:GetTall()
		end

		self:UpdateColor( self:GetColor() )
	end

	return OnValueChanged
end

function PANEL:Init()

	self.skin = esclib.addon:GetCurrentSkin()
	self.clr = self.skin.colors
	local clr = self.clr

	local clwhite=Color(255,255,255)

	self.Palette = vgui.Create( "DColorPalette", self )
	self.Palette:Dock( BOTTOM )
	self.Palette:SetTall( 100 )
	self.Palette:SetButtonSize( 16 )
	self.Palette:DockMargin( 0, 8, 0, 0 )
	self.Palette:Reset()
	self.Palette.DoClick = function( ctrl, color, btn )
		self:SetColor( Color( color.r, color.g, color.b, self:GetAlphaBar() && color.a or 255 ) )
	end
	self.Palette.OnRightClickButton = function( ctrl, btn )
		local m = DermaMenu()
		m:AddOption( "Save Color", function() ctrl:SaveColor( btn, self:GetColor() ) end )
		m:AddOption( "Reset Palette", function() ctrl:ResetSavedColors() end )
		m:Open()
	end
	self:SetPalette( false )

	-- The label
	self.label = vgui.Create( "DLabel", self )
	self.label:SetText( "" )
	self.label:Dock( TOP )
	self.label:SetDark( true )
	self.label:SetVisible( false )

	--The number stuff
	self.WangsPanel = vgui.Create( "Panel", self )
	self.WangsPanel:SetWide( 60 )
	self.WangsPanel:Dock( RIGHT )
	self.WangsPanel:DockMargin( 4, 0, 0, 0 )
	self:SetWangs( true )

	self.txtR = self.WangsPanel:Add( "DNumberWang" )
	self.txtR:SetDecimals( 0 )
	self.txtR:SetMinMax( 0, 255 )
	self.txtR:SetTall( 25 )
	self.txtR:Dock( TOP )
	self.txtR:DockMargin( 0, 0, 0, 0 )
	self.txtR:SetFont(esclib:AdaptiveFont("esclib", 16, 500))
	function self.txtR:Paint(w,h)
		draw.RoundedBoxEx(4,0,0,w,h,clr.button.hover,true,true,false,false)
		draw.RoundedBox(0,0,h-1,w,1,clr.default.red)
		self:DrawTextEntryText(clr.button.text,clr.button.apply,clr.button.text_hover)
	end


	self.txtG = self.WangsPanel:Add( "DNumberWang" )
	self.txtG:SetDecimals( 0 )
	self.txtG:SetMinMax( 0, 255 )
	self.txtG:SetTall( 25 )
	self.txtG:Dock( TOP )
	self.txtG:DockMargin( 0, 4, 0, 0 )
	self.txtG:SetFont(esclib:AdaptiveFont("esclib", 16, 500))
	function self.txtG:Paint(w,h)
		draw.RoundedBoxEx(4,0,0,w,h,clr.button.hover,true,true,false,false)
		draw.RoundedBox(0,0,h-1,w,1,clr.default.green)
		self:DrawTextEntryText(clr.button.text,clr.button.apply,clr.button.text_hover)
	end

	self.txtB = self.WangsPanel:Add( "DNumberWang" )
	self.txtB:SetDecimals( 0 )
	self.txtB:SetMinMax( 0, 255 )
	self.txtB:SetTall( 25 )
	self.txtB:Dock( TOP )
	self.txtB:DockMargin( 0, 4, 0, 0 )
	self.txtB:SetFont(esclib:AdaptiveFont("esclib", 16, 500))
	function self.txtB:Paint(w,h)
		draw.RoundedBoxEx(4,0,0,w,h,clr.button.hover,true,true,false,false)
		draw.RoundedBox(0,0,h-1,w,1,clr.default.blue)
		self:DrawTextEntryText(clr.button.text,clr.button.apply,clr.button.text_hover)
	end

	self.txtA = self.WangsPanel:Add( "DNumberWang" )
	self.txtA:SetDecimals( 0 )
	self.txtA:SetMinMax( 0, 255 )
	self.txtA:SetTall( 25 )
	self.txtA:Dock( TOP )
	self.txtA:DockMargin( 0, 4, 0, 0 )
	self.txtA:SetFont(esclib:AdaptiveFont("esclib", 16, 500))
	function self.txtA:Paint(w,h)
		draw.RoundedBoxEx(4,0,0,w,h,clr.button.hover,true,true,false,false)
		draw.RoundedBox(0,0,h-1,w,1,clr.default.white)
		self:DrawTextEntryText(clr.button.text,clr.button.apply,clr.button.text_hover)
	end

	self.txtR.OnValueChanged = CreateWangFunction( self, "r" )
	self.txtG.OnValueChanged = CreateWangFunction( self, "g" )
	self.txtB.OnValueChanged = CreateWangFunction( self, "b" )
	self.txtA.OnValueChanged = CreateWangFunction( self, "a" )

	-- The colouring stuff
	self.HSV = vgui.Create( "DColorCube", self )
	self.HSV:Dock( FILL )
	self.HSV.OnUserChanged = function( ctrl, color )
		color.a = self:GetColor().a
		self:UpdateColor( color )
	end
	function self.HSV.Knob:Paint(w,h)
		draw.RoundedBox(4,w*0.5-3,h*0.5-3,6,6,clr.default.white)
		draw.RoundedBox(4,w*0.5-2,h*0.5-2,4,4,clr.default.black)
	end
	function self.HSV:PaintOver()
		surface.SetDrawColor( clr.frame.accent )
		self:DrawOutlinedRect()
	end

	self.RGB = vgui.Create( "DRGBPicker", self )
	self.RGB:Dock( RIGHT )
	self.RGB:SetWidth( BarWide )
	self.RGB:DockMargin( 4, 0, 0, 0 )
	self.RGB.OnChange = function( ctrl, color )
		self:SetBaseColor( color )
	end
	function self.RGB:Paint(w,h)
		surface.SetDrawColor( clwhite )
		surface.SetMaterial( self.Material )
		surface.DrawTexturedRect( 0, 0, w, h )

		surface.SetDrawColor( clr.frame.accent )
		self:DrawOutlinedRect()

		surface.SetDrawColor( clwhite )
		surface.DrawRect( 0, self.LastY - 1, w, 1 )
	end


	self.Alpha = vgui.Create( "DAlphaBar", self )
	self.Alpha:DockMargin( 4, 0, 0, 0 )
	self.Alpha:Dock( RIGHT )
	self.Alpha:SetWidth( BarWide )
	self.Alpha.OnChange = function( ctrl, fAlpha )
		self:GetColor().a = math.floor( fAlpha * 255 )
		self:UpdateColor( self:GetColor() )
	end

	local matGradient = Material( "vgui/gradient-u" )
	local matGrid = Material( "gui/alpha_grid.png", "nocull" )

	function self.Alpha:Paint(w,h)
		surface.SetDrawColor( clwhite )
		surface.SetMaterial( matGrid )
		local size = 128
		for i = 0, math.ceil( h / size ) do
			surface.DrawTexturedRect( w * 0.5 - size * 0.5, i * size, size, size )
		end

		surface.SetDrawColor( self.m_BarColor )
		surface.SetMaterial( matGradient )
		surface.DrawTexturedRect( 0, 0, w, h )
		surface.DrawTexturedRect( 0, 0, w, h )

		surface.SetDrawColor( clr.frame.accent )
		self:DrawOutlinedRect()

		surface.SetDrawColor( clwhite )
		surface.DrawRect( 0, ( 1 - self.m_Value ) * h - 1, w, 1 )
	end
	self:SetAlphaBar( true )


	-- Layout
	self:SetColor( Color( 255, 0, 0 ) )
	self:SetSize( 285, 175 )
	self:InvalidateLayout()

end

function PANEL:SetLabel( text )

	if ( not text or text == "" ) then
		self.label:SetVisible( false )

		return
	end

	self.label:SetText( text )
	self.label:SetVisible( true )

	self:InvalidateLayout()
end

function PANEL:SetPalette( bEnabled )
	self.m_bPalette = bEnabled

	self.Palette:SetVisible( bEnabled )

	self:InvalidateLayout()
end

function PANEL:SetAlphaBar( bEnabled )
	self.m_bAlpha = bEnabled

	self.Alpha:SetVisible( bEnabled )
	self.txtA:SetVisible( bEnabled )

	self:InvalidateLayout()
end

function PANEL:SetWangs( bEnabled )
	self.m_bWangsPanel = bEnabled

	self.WangsPanel:SetVisible( bEnabled )

	self:InvalidateLayout()
end

function PANEL:SetConVarR( cvar )
	self.m_ConVarR = cvar
end

function PANEL:SetConVarG( cvar )
	self.m_ConVarG = cvar
end

function PANEL:SetConVarB( cvar )
	self.m_ConVarB = cvar
end

function PANEL:SetConVarA( cvar )
	self.m_ConVarA = cvar
	self:SetAlphaBar( cvar ~= nil )
end

function PANEL:PerformLayout( w, h )

	local h, s, v = ColorToHSV( self.HSV:GetBaseRGB() )
	self.RGB.LastY = ( 1 - h / 360 ) * self.RGB:GetTall()

end

function PANEL:Paint()
	-- Invisible background!
end

function PANEL:TranslateValues( x, y )
end

function PANEL:SetColor( color )

	local h, s, v = ColorToHSV( color )
	self.RGB.LastY = ( 1 - h / 360 ) * self.RGB:GetTall()

	self.HSV:SetColor( color )

	self:UpdateColor( color )

end

function PANEL:SetVector( vec )

	self:SetColor( Color( vec.x * 255, vec.y * 255, vec.z * 255 ) )

end

function PANEL:SetBaseColor( color )
	self.HSV:SetBaseRGB( color )
	self.HSV:TranslateValues()
end

function PANEL:UpdateConVar( strName, strKey, color )
	if ( not strName ) then return end
	local col = color[ strKey ]

	RunConsoleCommand( strName, tostring( col ) )

	self[ "ConVarOld" .. strName ] = col
end

function PANEL:UpdateConVars( color )

	self.NextConVarCheck = SysTime() + 0.2

	self:UpdateConVar( self.m_ConVarR, 'r', color )
	self:UpdateConVar( self.m_ConVarG, 'g', color )
	self:UpdateConVar( self.m_ConVarB, 'b', color )
	self:UpdateConVar( self.m_ConVarA, 'a', color )

end

function PANEL:UpdateColor( color )

	self.Alpha:SetBarColor( ColorAlpha( color, 255 ) )
	self.Alpha:SetValue( color.a / 255 )

	if ( color.r ~= self.txtR:GetValue() ) then
		self.txtR.notuserchange = true
		self.txtR:SetValue( math.Clamp(color.r,0,255) )
		self.txtR.notuserchange = nil
	end

	if ( color.g ~= self.txtG:GetValue() ) then
		self.txtG.notuserchange = true
		self.txtG:SetValue( math.Clamp(color.g,0,255) )
		self.txtG.notuserchange = nil
	end

	if ( color.b ~= self.txtB:GetValue() ) then
		self.txtB.notuserchange = true
		self.txtB:SetValue( math.Clamp(color.b,0,255) )
		self.txtB.notuserchange = nil
	end

	if ( color.a ~= self.txtA:GetValue() ) then
		self.txtA.notuserchange = true
		self.txtA:SetValue( math.Clamp(color.a,0,255) )
		self.txtA.notuserchange = nil
	end

	self:UpdateConVars( color )
	self:ValueChanged( color )

	self.m_Color = color

end

function PANEL:ValueChanged( color )
	-- Override
end

function PANEL:GetColor()

	self.m_Color.a = 255
	if ( self.Alpha:IsVisible() ) then
		self.m_Color.a = math.floor( self.Alpha:GetValue() * 255 )
	end

	return self.m_Color

end

function PANEL:GetVector()

	local col = self:GetColor()
	return Vector( col.r / 255, col.g / 255, col.b / 255 )

end

function PANEL:Think()

	self:ConVarThink()

end

function PANEL:ConVarThink()

	-- Don't update the convars while we're changing them!
	if ( input.IsMouseDown( MOUSE_LEFT ) ) then return end
	if ( self.NextConVarCheck > SysTime() ) then return end

	local r, changed_r = self:DoConVarThink( self.m_ConVarR )
	local g, changed_g = self:DoConVarThink( self.m_ConVarG )
	local b, changed_b = self:DoConVarThink( self.m_ConVarB )
	local a, changed_a = 255, false

	if ( self.m_ConVarA ) then
		a, changed_a = self:DoConVarThink( self.m_ConVarA, "a" )
	end

	if ( changed_r or changed_g or changed_b or changed_a ) then
		self:SetColor( Color( r, g, b, a ) )
	end

end

function PANEL:DoConVarThink( convar )

	if ( not convar ) then return end

	local fValue = GetConVarNumber( convar )
	local fOldValue = self[ "ConVarOld" .. convar ]
	if ( fOldValue && fValue == fOldValue ) then return fOldValue, false end

	self[ "ConVarOld" .. convar ] = fValue

	return fValue, true

end

vgui.Register( "esclib.colorpicker", PANEL, "DPanel" )
--PATH addons/____esclib/lua/elib/config/esc_languages.lua:

--------------------
--# LOCALIZATION #--
--------------------
-- key MUST be an abbreviation like ru en de cz
-- some abbr-s: https://wiki.facepunch.com/gmod/Addon_Localization
-- __name__ - key for abbreviation translation. 

local langs = {
	["en"] = {
		__name__ = "English",
		__code__ = "US",

		tab_general = "General",
		tab_language = "Language",
		tab_settings = "Settings",
		tab_theme = "Theme",

		window_ValueEdit = "Edit value",

		phrase_ReturnDefault = "Return Default",
		phrase_Save = "Save",

		phrase_Activate = "Activate",
		phrase_CustomSkin = "Custom",
		phrase_Themes = "Themes",
		phrase_Unsaved = "Unsaved",

		hint_CustomSkin = "Make your own skin. RMB to edit. Only for admins",

		button_Edit = "Edit",
		button_Confirm = "Confirm",
		button_Discard = "Discard",
		button_PrintToConsole = "Print to console",
		button_LoadOtherSkin = "Copy existing",

		phrase_AreYouSure = "Are you sure?",
		phrase_SureToReturn = "Return the default settings?",
		phrase_EnterValue = "Enter value",
		phrase_Search = "Search",
		phrase_Friend = "Friend",
		phrase_NoResults = "No results",
		phrase_SetGlobalDefault = "Save current settings as default on this server.\nCurrent settings must be saved!\nOnly for admins.",
		phrase_BackGlobalDefault = "Remove global default settings.\nOnly for admins.",
		phrase_AdminInfoButtons = "These buttons control the settings for all players. To change settings globally, you must first change these settings in your settings, save them, and then send them to the server with the appropriate button.",
		phrase_RecievedFromServer = "Settings have been received from the server",
		phrase_EmptySettings = "Settings is empty",
		phrase_restart_needed = "Changes will be applied after restart",
		phrase_WhoCanChange = "Who can change",
		phrase_NoOne = "No one",

		realm_Client = "Client",
		realm_Server = "Server",

		--Config
        s_debug_name = "Debug Mode",
        s_drawblur_name = "Draw Blur",
        s_animationspeed_name = "Animation speed",

		--timevalues
		char_hours = "h",
		char_minutes = "m",
		char_seconds = "s",
		char_milliseconds = "ms",

	},
	["ua"] = {
		__name__ = "Українська",
		__code__ = "UA",

		tab_general = "Головні",
		tab_language = "Мова",
		tab_settings = "Налаштування",
		tab_theme = "Теми",

		window_ValueEdit = "Змінити значення",

		phrase_ReturnDefault = "За замовчуванням",
		phrase_Save = "Зберегти",

		phrase_Activate = "Активувати",
		phrase_CustomSkin = "Своя тема",
		phrase_Themes = "Теми",
		phrase_Unsaved = "Не збережено",

		hint_CustomSkin = "Создайте свою тему.\nПКМ щоб відкрити меню. Тільки для адміністраторів",

		button_Edit = "Редагувати",
		button_Confirm = "Застосувати",
		button_Discard = "Відмінити",
		button_PrintToConsole = "Відправити в консоль",
		button_LoadOtherSkin = "Копіювати існуючий",

		phrase_AreYouSure = "Ви впевнені?",
		phrase_SureToReturn = "Повернути початкові налаштування?",
		phrase_EnterValue = "Введіть значення",
		phrase_Search = "Пошук",
		phrase_Friend = "Друг",
		phrase_NoResults = "Немає результатів",
		phrase_SetGlobalDefault = "Загрузити поточні налаштування як стандартні на сервер.\nПоточні налаштування повинні бути збережені!\nДоступно тільки для адміністрації.",
		phrase_BackGlobalDefault = "Видалити поточні глобальні налаштування.\nДоступно тільки для адміністрації.",
		phrase_AdminInfoButtons = "Ці кнопки керують налаштуваннями для всіх гравців. Для зміни налаштувань глобально, потрібно спочатку змінити ці налаштування у себя і ОБОВ'ЯЗКОВО нажати кнопку зберегти, а після відправити їх на сервер відповідною кнопкою.",
		phrase_RecievedFromServer = "Отриманні налаштування с сервера",
		phrase_EmptySettings = "Налаштування пусті",
		phrase_restart_needed = "Зміни будуть застосовані після рестарту",
		phrase_WhoCanChange = "Можуть змінювати",
		phrase_NoOne = "Ніхто",

		realm_Client = "Клієнт",
		realm_Server = "Сервер",

		--Config
        s_debug_name = "Режим налагодження",
        s_drawblur_name = "Розмиття фону",
        s_animationspeed_name = "Швидкість анімації",

		--timevalues
		char_hours = "г",
		char_minutes = "х",
		char_seconds = "с",
		char_milliseconds = "мс",
	},
	--translation by https://www.gmodstore.com/users/kbrpluma
	["de"] = {
		__name__ = "Deutsch",
		__code__ = "DE",
 
		tab_general = "Allgemein",
		tab_language = "Sprache",
		tab_settings = "Einstellungen",
		tab_theme = "Theme",
 
		window_ValueEdit = "Wert bearbeiten",
 
		phrase_ReturnDefault = "Standard zurückkehren",
		phrase_Save = "Speichern",
 
		phrase_Activate = "Aktivieren",
		phrase_CustomSkin = "Benutzerdefiniert",
		phrase_Themes = "Themes",
		phrase_Unsaved = "Ungespeichert",
 
		hint_CustomSkin = "Mache deinen eigenen Skin. RMT zum bearbeiten. Only for admins.",
 
		button_Edit = "Editieren",
		button_Confirm = "Bestätigen",
		button_Discard = "Verwerfen",
		button_PrintToConsole = "In die Konsole schreiben",
		button_LoadOtherSkin = "Vorhandenes kopieren",
 
		phrase_AreYouSure = "Bist du sicher?",
		phrase_SureToReturn = "Wiederherstellung der Standardeinstellungen?",
		phrase_EnterValue = "Wert eingeben",
		phrase_Search = "Suche",
		phrase_Friend = "Freund",
		phrase_NoResults = "Keine Ergebnisse",
		phrase_SetGlobalDefault = "Aktuelle Einstellungen als Standard auf diesem Server speichern.\nAktuelle Einstellungen müssen gespeichert werden!\nNur für Admins.",
		phrase_BackGlobalDefault = "Globale Standardeinstellungen entfernen.\nNur für Admins.",
		phrase_AdminInfoButtons = "Diese Buttons kontrollieren die Einstellungen für jeden Spieler. Um die Einstellungen global zu ändern, musst du die Einstellungen erst bei dir speichern und dann mit dem Button zum Server senden.",
		phrase_RecievedFromServer = "Einstellungen vom Server erhalten",
		phrase_EmptySettings = "Einstellungen sind leer",
		phrase_restart_needed = "Änderungen werden nach dem Neustart angewendet",
		phrase_WhoCanChange = "Wer kann es ändern",
		phrase_NoOne = "Niemand",
 
		realm_Client = "Client",
		realm_Server = "Server",
 
		--Config
        s_debug_name = "Debug Mode",
        s_drawblur_name = "Unschärfe anzeigen",
        s_animationspeed_name = "Animationsgeschwindigkeit",
 
		--timevalues
		char_hours = "s",
		char_minutes = "m",
		char_seconds = "s",
		char_milliseconds = "ms",
 
	},
	--translation by https://www.gmodstore.com/users/76561198363331907
	["zh-cn"] = {
		__name__ = "简体中文",
		__code__ = "CN",

		tab_general = "一般",
		tab_language = "语言",
		tab_settings = "设置",
		tab_theme = "主题",

		window_ValueEdit = "编辑值",

		phrase_ReturnDefault = "恢复默认",
		phrase_Save = "保存",

		phrase_Activate = "激活",
		phrase_CustomSkin = "自定义",
		phrase_Themes = "主题",
		phrase_Unsaved = "未保存",

		hint_CustomSkin = "制作你自己的皮肤. 右键编辑. Only for admins.",

		button_Edit = "编辑",
		button_Confirm = "确定",
		button_Discard = "放弃",
		button_PrintToConsole = "输出至控制台",
		button_LoadOtherSkin = "复制已有",

		phrase_AreYouSure = "你确定吗?",
		phrase_SureToReturn = "恢复默认设置?",
		phrase_EnterValue = "输入值",
		phrase_Search = "搜索",
		phrase_Friend = "好友",
		phrase_NoResults = "无结果",
		phrase_SetGlobalDefault = "将当前设置保存为该服务器的默认值.\n必须保存当前设置!\n仅管理员.",
		phrase_BackGlobalDefault = "移除全局默认设置.\n仅管理员.",
		phrase_AdminInfoButtons = "这些按钮控制所有玩家的设置. 要改变全局设置, 你必须首先在你的设置中改变这些设置, 保存它们, 然后用对应的按钮将它们发送到服务器.",
		phrase_RecievedFromServer = "已收到来自服务器的设置",
		phrase_EmptySettings = "设置为空",
		phrase_restart_needed = "将在重新启动后应用更改",
		phrase_WhoCanChange = "谁能修改",
		phrase_NoOne = "无人",

		realm_Client = "客户端",
		realm_Server = "服务器",

		--Config
        s_debug_name = "调试模式",
        s_drawblur_name = "绘制 Blur",
        s_animationspeed_name = "动画速度",

		--timevalues
		char_hours = "时",
		char_minutes = "分",
		char_seconds = "秒",
		char_milliseconds = "毫秒",
	},
	--translation by https://www.gmodstore.com/users/76561198093244860
	["dk"] = {
		__name__ = "Danish",
		__code__ = "DK",

		tab_general = "General",
		tab_language = "Sprog",
		tab_settings = "Indstillinger",
		tab_theme = "Tema",

		window_ValueEdit = "Rediger værdi",

		phrase_ReturnDefault = "Returner Standard",
		phrase_Save = "Gem",

		phrase_Activate = "Aktiver",
		phrase_CustomSkin = "Custom",
		phrase_Themes = "Temaer",
		phrase_Unsaved = "Ikke gemt",

		hint_CustomSkin = "Lav dit egent skin. RMB for at redigere. Only for admins.",

		button_Edit = "Rediger",
		button_Confirm = "Bekræft",
		button_Discard = "Fortryd", 
		button_PrintToConsole = "Udskriv til konsol",
		button_LoadOtherSkin = "Kopier eksisterende",

		phrase_AreYouSure = "Er du sikker?",
		phrase_SureToReturn = "Returner standardindstillinger?",
		phrase_EnterValue = "Indsæt værdi",
		phrase_Search = "Søg",
		phrase_Friend = "Venner",
		phrase_NoResults = "Ingen resultater",
		phrase_SetGlobalDefault = "Gem aktuelle indstillinger som standard på denne server.\nAktuelle indstillinger skal gemmes!\nKun for administratorer.",
		phrase_BackGlobalDefault = "Fjern globale standardindstillinger.\nKun for administratorer.",
		phrase_AdminInfoButtons = "Disse knapper styrer indstillingerne for alle spillere. For at ændre indstillinger globalt skal du først ændre disse indstillinger i dine indstillinger, gemme dem og derefter sende dem til serveren med den relevante knap.",
		phrase_RecievedFromServer = "Indstillingerne er modtaget fra serveren",
		phrase_EmptySettings = "Indstillingerne er tomme",
		phrase_restart_needed = "Ændringer vil blive anvendt efter genstart",
		phrase_WhoCanChange = "Hvem kan ændre",
		phrase_NoOne = "Ingen",

		realm_Client = "Client",
		realm_Server = "Server",

		--Config
        s_debug_name = "Fejlretningstilstand",
        s_drawblur_name = "Tegn sløring",
        s_animationspeed_name = "Animations Hastighed",

		--timevalues
		char_hours = "t",
		char_minutes = "m",
		char_seconds = "s",
		char_milliseconds = "ms",
	},
	--translation by https://www.gmodstore.com/users/76561198198168751
	["fr"] = {
		__name__ = "French",
		__code__ = "FR",

		tab_general = "General",
		tab_language = "Langue",
		tab_settings = "Paramètres",
		tab_theme = "Theme",

		window_ValueEdit = "Modifier la valeur",

		phrase_ReturnDefault = "Retour par défaut",
		phrase_Save = "Sauvegarder",

		phrase_Activate = "Activer",
		phrase_CustomSkin = "Modifier",
		phrase_Themes = "Themes",
		phrase_Unsaved = "Non enregistré",

		hint_CustomSkin = "Faites votre propre skin. Clique droit pour éditer. Only for admins.",

		button_Edit = "Modifier",
		button_Confirm = "Confirmer",
		button_Discard = "Supprimer",
		button_PrintToConsole = "Copier dans la console",
		button_LoadOtherSkin = "Copie existant",

		phrase_AreYouSure = "Es-tu sûr?",
		phrase_SureToReturn = "Rétablir les paramètres par défaut ?",
		phrase_EnterValue = "Entrez la valeur",
		phrase_Search = "Rechercher",
		phrase_Friend = "Ami(e)(s)",
		phrase_NoResults = "Aucun résultat",
		phrase_SetGlobalDefault = "Enregistrer les paramètres actuels par défaut sur ce serveur.\nLes paramètres actuels doivent être enregistrés !\nReservé pour les administrateurs.",
		phrase_BackGlobalDefault = "Supprimer les paramètres globaux par défaut.\nReservé pour les administrateurs.",
		phrase_AdminInfoButtons = "Ces boutons contrôlent les paramètres de tous les joueurs. Pour modifier les paramètres globalement, vous devez d'abord modifier ces paramètres dans vos paramètres, les enregistrer, puis les envoyer au serveur avec le bouton approprié.",
		phrase_RecievedFromServer = "Les paramètres ont été reçus par le serveur",
		phrase_EmptySettings = "Les paramètres sont vides",
		phrase_restart_needed = "Les modifications seront appliquées après le redémarrage du serveur",
		phrase_WhoCanChange = "Qui peut changer",
		phrase_NoOne = "Personne",

		realm_Client = "Client",
		realm_Server = "Serveur",

		--Config
        s_debug_name = "Debug Mode",
        s_drawblur_name = "Dessiner le flou",
        s_animationspeed_name = "La vitesse d'animation",

		--timevalues
		char_hours = "h",
		char_minutes = "m",
		char_seconds = "s",
		char_milliseconds = "ms",

	},
	--translation by https://www.gmodstore.com/users/76561199213364106
	["pl"] = {
		__name__ = "Polish",
		__code__ = "PL",

		tab_general = "Główne",
		tab_language = "Języki",
		tab_settings = "Ustawienia",
		tab_theme = "Motyw",

		window_ValueEdit = "Edytuj Wartość",

		phrase_ReturnDefault = "Powrót do ustawień podstawowych",
		phrase_Save = "Zapisz",

		phrase_Activate = "Aktywuj",
		phrase_CustomSkin = "Niestandardowe",
		phrase_Themes = "Motywy",
		phrase_Unsaved = "Nie zapisane",

		hint_CustomSkin = "Stwórz własną skórkę. PPM do edycji. Only for admins.",

		button_Edit = "Edytuj",
		button_Confirm = "Potwierdź",
		button_Discard = "Odrzuć",
		button_PrintToConsole = "Wydrukuj do konsoli",
		button_LoadOtherSkin = "Załaduj skórkę",

		phrase_AreYouSure = "Jesteś pewien?",
		phrase_SureToReturn = "Powrócić do podstawowych ustawień?",
		phrase_EnterValue = "Wprowadż wartość",
		phrase_Search = "Szukaj",
		phrase_Friend = "Przyjaciel",
		phrase_NoResults = "Brak wyników",
		phrase_SetGlobalDefault = "Zapisz bieżące ustawienia jako domyślne na tym serwerze.\nBieżące ustawienia muszą zostać zapisane!\nTylko dla administracji.",
		phrase_BackGlobalDefault = "Usuń globalne ustawienia domyślne.\nTylko dla administracji.",
		phrase_AdminInfoButtons = "Te przyciski sterują ustawieniami dla wszystkich graczy. Aby zmienić ustawienia globalnie, należy najpierw zmienić te ustawienia w swoich ustawieniach, zapisać je, a następnie za pomocą odpowiedniego przycisku przesłać na serwer.",
		phrase_RecievedFromServer = "Ustawienia zostały odebrane z serwera.",
		phrase_EmptySettings = "Ustawienia są puste.",
		phrase_restart_needed = "Zmiany zostaną aktywowane po restarcie serwera!",
		phrase_WhoCanChange = "Kto może zmienić",
		phrase_NoOne = "Nikt inny",

		realm_Client = "Klient",
		realm_Server = "Serwer",

		--Config
        s_debug_name = "Tryb debugowania",
        s_drawblur_name = "Stwórz rozmycie",
        s_animationspeed_name = "Prędkość animacji",

		--timevalues
		char_hours = "h",
		char_minutes = "m",
		char_seconds = "s",
		char_milliseconds = "ms",
	},
	--translation by https://www.gmodstore.com/users/76561199213364106
	["cz"] = {
		__name__ = "Czech",
		__code__ = "CZ",

		tab_general = "Hlavní",
		tab_language = "Jazyky",
		tab_settings = "Nastavení",
		tab_theme = "Téma",

		window_ValueEdit = "Upravit hodnotu",

		phrase_ReturnDefault = "Zpět k základnímu nastavení",
		phrase_Save = "Zapsat",

		phrase_Activate = "Aktivovat",
		phrase_CustomSkin = "Nestandardní",
		phrase_Themes = "Témata",
		phrase_Unsaved = "Neuloženo",

		hint_CustomSkin = "Vytvořte si vlastní skin. PPM k úpravě. Only for admins.",

		button_Edit = "Upravit",
		button_Confirm = "Potvrdit",
		button_Discard = "Odmítnout",
		button_PrintToConsole = "Tisk do konzole",
		button_LoadOtherSkin = "Naložte kůži",

		phrase_AreYouSure = "Jsi si jistá?",
		phrase_SureToReturn = "Vrátit se k základnímu nastavení?",
		phrase_EnterValue = "Zadejte hodnotu",
		phrase_Search = "Vyhledávání",
		phrase_Friend = "Příteli",
		phrase_NoResults = "Žádné výsledky",
		phrase_SetGlobalDefault = "Uložte aktuální nastavení jako výchozí na tomto serveru.\nAktuální nastavení musí být uloženo!\nPouze pro administraci.",
		phrase_BackGlobalDefault = "Odebrat globální výchozí hodnoty.\nPouze pro administraci.",
		phrase_AdminInfoButtons = "Tato tlačítka ovládají nastavení pro všechny hráče. Chcete-li změnit nastavení globálně, musíte nejprve tato nastavení změnit ve svém nastavení, uložit je a poté je nahrát na server pomocí příslušného tlačítka.",
		phrase_RecievedFromServer = "Nastavení byla přijata ze serveru.",
		phrase_EmptySettings = "Nastavení jsou prázdná.",
		phrase_restart_needed = "Změny budou aktivovány po restartu serveru!",
		phrase_WhoCanChange = "Kdo může změnit",
		phrase_NoOne = "Nikdo jiný",

		realm_Client = "Klient",
		realm_Server = "Server",

		--Config
        s_debug_name = "Debugovací mód",
        s_drawblur_name = "Vytvořte rozostření",
        s_animationspeed_name = "Rychlost animace",

		--timevalues
		char_hours = "h",
		char_minutes = "m",
		char_seconds = "s",
		char_milliseconds = "ms",

	},
	--translation by https://www.gmodstore.com/users/Goran
	["es"] = {
		__name__ = "Spanish",
		__code__ = "ES",

		tab_general = "General",
		tab_language = "Idioma",
		tab_settings = "Ajustes",
		tab_theme = "Tema",

		window_ValueEdit = "Editar valor",

		phrase_ReturnDefault = "Config. por Defecto",
		phrase_Save = "Guardar",

		phrase_Activate = "Activar",
		phrase_CustomSkin = "Personalizado",
		phrase_Themes = "Temas",
		phrase_Unsaved = "No guardado",

		hint_CustomSkin = "Crea tu propio aspecto. Click derecho para editar. Only for admins.",

		button_Edit = "Editar",
		button_Confirm = "Confirmar",
		button_Discard = "Descartar",
		button_PrintToConsole = "Imprimir en consola",
		button_LoadOtherSkin = "Copiar existente",

		phrase_AreYouSure = "¿Seguro?",
		phrase_SureToReturn = "¿Regresar a valores por defecto?",
		phrase_EnterValue = "Ingresar valor",
		phrase_Search = "Buscar",
		phrase_Friend = "Amigo",
		phrase_NoResults = "Sin resultados",
		phrase_SetGlobalDefault = "Guardar los ajustes actuales como por defecto.\n¡Los ajustes actuales deben ser guardados!\nSólo para admins.",
		phrase_BackGlobalDefault = "Remover ajustes globales gugardados\nSólo para admins.",
		phrase_AdminInfoButtons = "Estos botones controlan los ajustes para todos los jugadores. Para cambiar ajustes globalmente, primero debes modificar estos ajustes en tus propios ajustes, guardarlos, y luego enviarlos al servidor con el botón correspondiente.",
		phrase_RecievedFromServer = "Ajustes recibidos del servidor",
		phrase_EmptySettings = "Los ajustes están vacíos",
		phrase_restart_needed = "Los cambios serán aplicados luego del reinicio",
		phrase_WhoCanChange = "Quién puede modificar",
		phrase_NoOne = "Nadie",

		realm_Client = "Cliente",
		realm_Server = "Servidor",

		--Config
        s_debug_name = "Modo Debug",
        s_drawblur_name = "Dibujar difuminado",
        s_animationspeed_name = "Velocidad de la animación",

		--timevalues
		char_hours = "h",
		char_minutes = "m",
		char_seconds = "s",
		char_milliseconds = "ms",
	},
	--translation by https://www.gmodstore.com/users/illusion
	["tr"] = {
		__name__ = "Türkçe",
		__code__ = "TR",

		tab_general = "Genel",
		tab_language = "Dil",
		tab_settings = "Ayarlar",
		tab_theme = "Tema",

		window_ValueEdit = "Düzenle",

		phrase_ReturnDefault = "Varsayılan",
		phrase_Save = "Kaydet",

		phrase_Activate = "Etkinleştir",
		phrase_CustomSkin = "Özel",
		phrase_Themes = "Temalar",
		phrase_Unsaved = "Kaydedilmemiş",

		hint_CustomSkin = "Kendi temanızı yapın. Düzenlemek için SAĞTIK. Only for admins.",

		button_Edit = "Düzenle",
		button_Confirm = "Onayla",
		button_Discard = "Çıkar",
		button_PrintToConsole = "Konsola yazdırma",
		button_LoadOtherSkin = "Var olanı kopyala",

		phrase_AreYouSure = "Emin misiniz?",
		phrase_SureToReturn = "Varsayılan ayarları döndürüyorsunuz?",
		phrase_EnterValue = "Değer girin",
		phrase_Search = "Ara",
		phrase_Friend = "Arkadaş",
		phrase_NoResults = "Sonuç yok",
		phrase_SetGlobalDefault = "Geçerli ayarları bu sunucuda varsayılan olarak kaydet.\nGeçerli ayarlar kaydedilmelidir!\nYalnızca yöneticiler için.",
		phrase_BackGlobalDefault = "Genel varsayılan ayarları kaldırın.\nYalnızca yöneticiler için.",
		phrase_AdminInfoButtons = "Bu düğmeler tüm oyuncuların ayarlarını kontrol eder. Ayarları genel olarak değiştirmek için, önce ayarlarınızdan bu ayarları değiştirmeniz, kaydetmeniz ve ardından uygun düğmeyle sunucuya göndermeniz gerekir.",
		phrase_RecievedFromServer = "Ayarlar sunucudan alındı",
		phrase_EmptySettings = "Ayarlar boş",
		phrase_restart_needed = "Değişiklikler yeniden başlatıldıktan sonra uygulanacaktır",
		phrase_WhoCanChange = "Kim değiştirebilir",
		phrase_NoOne = "Kimse",

		realm_Client = "Client",
		realm_Server = "Server",

		--Config
        s_debug_name = "Debug Mod",
        s_drawblur_name = "Blur oluştur",
        s_animationspeed_name = "Animasyon hızı",

		--timevalues
		char_hours = "sa",
		char_minutes = "dk",
		char_seconds = "sn",
		char_milliseconds = "ms",
	},
}

esclib.addon:RegisterLanguages(langs)

-- if GetConVar("gmod_language") not in languages table, sets this language
esclib.addon:SetDefaultLanguage("ua")
--PATH addons/____echat/lua/echat/core/parsers.lua:
local clamp = math.Clamp
local min, max = math.min, math.max
local format = string.format

---------------------------------------
--# USERGROUP CHECKER (from config) #--
---------------------------------------
local function default_checker(ply, parser)
	if not ply then return true end --if server doesnt know msg author then skip check
	local user_group = ply:GetUserGroup()

	if echat.config.rank_parsers[parser["uid"]] then
		return echat.config.rank_parsers[parser["uid"]][user_group]
	else
		return true
	end
end


local function format_time()
	local currentTime = os.date("*t")

	local hour = currentTime.hour
	local hours12 = hour
    local suffix = "AM"

    if hours12 >= 12 then
        suffix = "PM"
        if hours12 > 12 then
            hours12 = hours12 - 12
        end
    elseif hours12 == 0 then
        hours12 = 12
    end

	-- {hour}:{minute}:{second} --24 time format
	-- {hour12}:{minute}:{second} {am_pm} --12 hours format
	-- {time}, 24 hours time format
	-- {time12}, 12 hours time format
	local final_str = esclib.text:KeyFormat(echat.config.time_format, {
		["hour"] = format("%02d", hour),
		["minute"] = format("%02d", currentTime.min),
		["second"] = format("%02d", currentTime.sec),
		["hour12"] = format("%02d", hours12),
		["am_pm"] = suffix,
	})

	return final_str
end


----------------
--# RICHTEXT #--
----------------
--This function converts parsed data into richtext functions echat/vgui/echat_richtext.lua
local errorMat = Material("error")
function echat:ConvertParsedToRichtext(richtext, parsed)
	local colors = echat.addon:GetColors()
	
	local clr = Color(255,255,255)
	local stop_shaking = false
	local font_change = nil
	local bg_col_changed = nil

	for _, item in ipairs(parsed) do
		local _type = item.type
		local v = item.value
		
		if _type == "rgb" then
			clr = Color(v.r, v.g, v.b, v.a)
			richtext:InsertColorChange(clr:Unpack())
		elseif _type == "bg_col" then
			bg_col_changed = true
			if not v then
				richtext:InsertBackgroundColorChange(nil)
			else
				richtext:InsertBackgroundColorChange(v.r, v.g, v.b, v.a)
			end
		elseif _type == "text" then
			richtext:AppendText(v)
		elseif _type == "rainbow" then
			richtext:InsertRainbowEffect()
		elseif _type == "separator" then
			richtext:AppendSeparator( )
		elseif _type == "emoji" then
			richtext:AppendEmoji(v)
		elseif _type == "shake" then
			richtext:InsertShakingEffect(v and (clamp(v, 0, 1)) or 0.5)
			stop_shaking = true
		elseif _type == "font" then
			font_change = richtext:GetFont()
			richtext:InsertFontChange(v)
		elseif _type == "adafont" then
			font_change = richtext:GetFont()
			richtext:InsertFontChange(echat:AdaptiveFont("echat", echat.addon:GetVar("base_font_size") or v, 500))
		elseif _type == "adafont_mono" then
			font_change = richtext:GetFont()
			richtext:InsertFontChange(echat:AdaptiveMonoFont("echatmono", echat.addon:GetVar("base_font_size") or v, 500))
		elseif _type == "theme" then
			local clr = colors
			for _, v in ipairs(string.Explode(".", v)) do
				if clr[v] then clr = clr[v] else break end
			end

			if not IsColor(clr) then continue end
			richtext:InsertColorChange(clr.r, clr.g, clr.b, clr.a)
		elseif _type == "time" then
			richtext:AppendText(format_time())
		elseif _type == "link" then
			--copy color
			local clr_copy = table.Copy(clr)
			clr = Color(colors.main.accent.r, colors.main.accent.g, colors.main.accent.b, colors.main.accent.a)
			richtext:InsertColorChange(clr:Unpack())

			richtext:InsertClickable(function()
				gui.OpenURL(v)
			end)
			richtext:AppendText(v)
			richtext:InsertClickable() --remove clickable
			richtext:AppendText("")

			--restore color
			clr = Color(clr_copy:Unpack())
			richtext:InsertColorChange(clr:Unpack())
		elseif _type == "img" then
			local mat = errorMat

			local chatw, chath = chat.GetChatBoxSize()

			local width = min(esclib:AdaptiveSize(v["w"]), chatw-10)
			local height = min(esclib:AdaptiveSize(v["h"]), chath*0.5-10)

			echat.addon:DownloadMaterial(v["url"], 
				function(mater)
					mat = mater
				end,
				function(errMsg)
					--nothing
				end,
				nil,
				"temp"
			)

			local pnl = vgui.Create("DPanel")
			pnl:SetWide(width)
			pnl:SetHeight(height)
			function pnl:Paint(w,h)
				if mat:IsError() then
					esclib.draw:Border(0,0,w,h,3, colors.main.accent)
					return
				end
				esclib.draw:Material(0,0,w,h,color_white,mat)
			end

			richtext:AppendPanel(pnl)
		end
	end

	--return all back
	if stop_shaking then
		richtext:InsertShakingEffect(0)
	end

	if font_change then
		richtext:InsertFontChange(font_change)
	end

	if bg_col_changed then
		richtext:InsertBackgroundColorChange(nil)
	end
end


local nil_equivalents = {
	["none"] = true,
	["false"] = true,
	["nil"] = true,
	["end"] = true,
	["cancel"] = true,
	["stop"] = true
}

--------------------------
--# REGISTERED PARSERS #--
--------------------------
-- echat:AddParser(
-- 	 unique_name, 
-- 	 encode_func, --to table
-- 	 decode_func, --to string
-- 	 examples, --table or string
-- 	 description, --string
-- 	 custom_check_func, --check for availability
--   icon, --icon material
-- )
--args - command splits args with ":" example: <rgb:10,20,30> -> {1:"rgb", 2:"10,20,30"}

------------------
--# RGB PARSER #--
------------------
local function string_to_color(str)
	local components = {}
	for component in str:gmatch("%d+") do
		table.insert(components, tonumber(component))
	end
	local count = #components

	if count < 3 then return end

	local result = Color(components[1], components[2], components[3], 255)
	if count > 3 then
		result.a = components[4]
	end
	return result
end

local function encode(args) --function itself
	if #args < 2 then return end --nothing to return

	local result = string_to_color(args[2])
	if not result then return end

	return {type="rgb", value=result}
end

local function decode(encoded) --encoded will be {type="rgb", value=result} you need to return string
	return string.format("%s:%d,%d,%d,%d", encoded.type, encoded.value.r, encoded.value.g, encoded.value.b, encoded.value.a)
end

local examples = {"rgb:255,0,0", "rgb:10,10,255,140"}
local description = echat.addon:Translate("rgb_hint") --description of hint in chat
local custom_check = default_checker

echat:AddParser("rgb", encode, decode, examples, description, custom_check, echat:GetEmoji("art")) --add parser to addon



------------------
--# CLR PARSER #--
------------------
local clr_examples = {}
for k,_ in pairs(echat.config.pallete) do
	table.insert(clr_examples, "clr:"..k)
end
echat:AddParser(
	"clr", 

	function(args) 
		if #args < 2 then return end --nothing to return
		if not echat.config.pallete[args[2]] then return end --not in pallete
		return {type="rgb", value=echat.config.pallete[args[2]]} --NOTE: we using other parser type. Will be used decoder from rgb parser
	end, 

	function(encoded) return "" end, --as we use type rgb(other parser) we dont need to specify decoder

	clr_examples, 
	echat.addon:Translate("clr_hint"), 
	default_checker,
	echat:GetEmoji("sparkles")
)


--------------------------
--# THEME COLOR PARSER #--
--------------------------

local theme_examples = {}
if CLIENT then --only on client
	local theme = echat.addon:GetCurrentSkin()
	for _,theme_tab in ipairs(table.GetKeys(theme["colors"])) do
		if theme_tab == "default" then continue end --skip

		for _,theme_clr in ipairs(table.GetKeys(theme["colors"][theme_tab])) do
			local clr = theme["colors"][theme_tab][theme_clr]
			if not IsColor(clr) then continue end

			table.insert(theme_examples, string.format("theme:%s.%s", theme_tab, theme_clr))
		end
	end
end

echat:AddParser(
	"theme", 

	function(args)
		if #args < 2 then return end --nothing to return

		return {type="theme", value=string.format("%s.%s", args[2], args[3])}
	end, 

	function(encoded) 
		return string.format("%s:%s", encoded.type, encoded.value)
	end,

	theme_examples, 
	echat.addon:Translate("clr_hint"), 
	default_checker,
	echat:GetEmoji("fleur_de_lis")
)



-------------------------------
--# BACKGROUND COLOR PARSER #--
-------------------------------
local function encode(args)
	if #args < 2 then return end

	if nil_equivalents[args[2] or ""] then return {type="bg_col", value=nil} end --end background color

	local result = string_to_color(args[2])
	if not result then return end

	return {type="bg_col", value=result}
end

local function decode(encoded)
	return string.format("%s:%d,%d,%d,%d", encoded.type, encoded.value.r, encoded.value.g, encoded.value.b, encoded.value.a)
end

local examples = {"bg_col:255,0,0", "bg_col:none"}
local description = echat.addon:Translate("rgb_hint") --description of hint in chat
local custom_check = default_checker

echat:AddParser("bg_col", encode, decode, examples, description, custom_check, echat:GetEmoji("globe_with_meridians")) --add parser to addon


-------------------
--# FONT PARSER #--
-------------------
--generate examples
local all_fonts = echat:GetFonts()
local allowed_fonts = {}
local font_examples = {} 
for k,v in ipairs(all_fonts) do
	allowed_fonts[v] = true
	table.insert(font_examples, "font:"..v)
end

local function font_decoder(encoded)
	return string.format("%s:%s", encoded.type, encoded.value)
end

--add parser
echat:AddParser(
	"font", 

	function(args)
		if #args < 2 then return end
		if not allowed_fonts[args[2]] then return end 
		return {type="font", value=args[2]}
	end, 

	font_decoder,

	font_examples, 
	echat.addon:Translate("font_hint"), 
	default_checker,
	echat:GetEmoji("abc")
)

local function adaptive_encode(args)
	return {type=args[1], value=args[2]}
end

--adaptive font
echat:AddParser(
	"adafont", 
	adaptive_encode,
	font_decoder,
	{"adafont"}, 
	echat.addon:Translate("font_hint"), 
	default_checker,
	echat:GetEmoji("abc")
)

--adaptive monofont
echat:AddParser(
	"adafont_mono", 
	adaptive_encode,
	font_decoder,
	{"adafont_mono"}, 
	echat.addon:Translate("font_hint"), 
	default_checker,
	echat:GetEmoji("abc")
)






----------------------
--# LINE SEPARATOR #--
----------------------
echat:AddParser(
	"separator", 

	function(args) 
		return {type="separator", value=args[2]}
	end,

	function(encoded)
		return encoded.type --will be <separator>
	end,

	{"separator"}, 
	echat.addon:Translate("separator_hint"), 
	default_checker,
	echat:GetEmoji("construction")
)


----------------------
--# RAINBOW EFFECT #--
----------------------
echat:AddParser(
	"rainbow", 

	function(args) 
		return {type="rainbow"}
	end,

	function(encoded)
		return encoded.type
	end,

	{"rainbow"}, --examples
	echat.addon:Translate("rainbow_hint"), 
	default_checker,
	echat:GetEmoji("rainbow_flag") --icon
)


--------------------
--# SHAKE EFFECT #--
--------------------
echat:AddParser(
	"shake", 

	function(args)
		if nil_equivalents[args[2] or ""] then return {type="shake", value=0} end --end shake effect

		if not tonumber(args[2]) then return end

		return {type="shake", value=args[2]}
	end,

	function(encoded)
		return string.format("%s:%f",encoded.type,encoded.value)
	end,
	
	{"shake:0.5", "shake:none"}, 
	echat.addon:Translate("shaking_hint"), 
	default_checker,
	echat:GetEmoji("zap") --icon
)


-------------------------
--# LOCAL TIME PARSER #--
-------------------------
echat:AddParser(
	"time", 

	function(args) 
		return {type="time"}
	end,

	function(encoded)
		return encoded.type --will be <separator>
	end,

	{"time"}, 
	"", 
	default_checker,
	echat:GetEmoji("date")
)


-------------------
--# LINK PARSER #--
-------------------
echat:AddParser(
	"link", 

	function(args)
		local args_copy = table.Copy(args)
		table.remove(args_copy, 1)
		local url = table.concat(args_copy, ":")
		if string.StartsWith(url, "http://") or string.StartsWith(url, "https://")  then
			return {type="link", value=url}
		end
	end,

	function(encoded)
		return encoded.type
	end,

	{"link:https://"}, 
	"", 
	default_checker,
	echat:GetEmoji("link")
)

--------------------
--# IMAGE PARSER #--
--------------------
echat:AddParser(
	"img", 

	function(args)
		local args_copy = table.Copy(args)
		table.remove(args_copy, 1)

		local width = args_copy[1]
		local height = args_copy[2]
		table.remove(args_copy, 2)
		table.remove(args_copy, 1)
		
		local url = table.concat(args_copy, ":")
		if string.StartsWith(url, "http://") or string.StartsWith(url, "https://")  then
			return {type="img", value={w=max(width, 30), h=max(height, 30), url=url}}
		end
	end,

	function(encoded)
		return encoded.type
	end,

	{"img:100:100:https://"}, 
	"", 
	default_checker,
	echat:GetEmoji("link")
)