--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 10/10 - 06/04/2025


--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/arccw/shared/arccw_k_galactic_sounds.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_barrel_longrange.lua:
att.PrintName = "15a Long-range Barrel"
att.Description = "DC-15a long-range barrel. Designed for Sniper purposes."
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_bipod1.png")
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = {"15a_barrel"}
att.ActivateElements = {"15a_barrel_longrange"}

att.Mult_MoveSpeed = 0.9

att.Mult_Range = 1.25
att.Mult_Recoil = 0.95
att.Mult_SightTime = 1.35
att.Mult_AccuracyMOA = 0.75

att.Mult_ShootPitch = 0.9
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_top_stabilizer.lua:
att.PrintName = "15a Stabilizer"
att.Description = "Stabilizer designed for better accurancy at long-range combat."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_e11_grip1.png")
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_top"
att.ActivateElements = {"15a_top_stabilizer"}

att.Mult_Range = 1.58
att.Mult_Recoil = 0.50
att.Mult_SightTime = 1.2
att.Mult_AccuracyMOA = 1
att.Mult_ShootPitch = 0.87
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_powerpack.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_thermal.lua:
att.PrintName = "Thermal Grenade Launcher"
att.Icon = Material("interfaz/armas/sw_firebomb.png")
att.Description = "Throwable grenade with thermal capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_thermal"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_hammershot.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/ammo_low.lua:
att.PrintName = "Low Tibanna Density"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Cycle the potency of the platform to allow for its chambering in Low Density Tibanna."
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "ammo"

att.Reload = 1
att.Mult_DamageMin = 0.76
att.Mult_Recoil = 1.1
att.Mult_SightTime = 1
att.Mult_RPM = 1.35
att.NotForNPCs = true
att.Mult_Damage = 0.75
att.Mult_MuzzleVelocity = 0.5
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/dc17_cooling.lua:
att.PrintName = "Cooling Improved"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/module1.png")
att.Description = "Improves the weapon performance."

att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true
att.Slot = "dc17_cooling"
att.ActivateElements = {"dc17_cooling"}

att.Mult_Damage = 1.1
att.Mult_Recoil = 0.9
att.Mult_SightTime = 1.1
att.Mult_MoveSpeed = 0.95
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/dc17_module.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_impact.lua:
att.PrintName = "Grenade Launcher (Impact)"
att.Icon = Material("interfaz/armas/sw_highenergyclip.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Impact)"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_impact", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_heatbased.lua:
att.PrintName = "Heat-Based Mode"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/heatbased.png")
att.Description = "Set the weapon mode to heat-based."

att.Slot = "sw_mode"

att.Override_InfiniteAmmo = true
att.Override_BottomlessClip = true

att.Mult_FixTime = 1.2
att.Mult_HeatDissipation = 1.2
att.Mult_HeatDelayTime = 1.5

att.Desc_Pros = {}
att.Desc_Cons = {}

att.NotForNPCs = true
att.AutoStats = true

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_overpressure.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/muzzle_cr2_pistol_mod.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonearc.lua:
att.PrintName = "ARC Trooper Training"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/arctrooper.png")
att.Description = [[Elite Soldiers of the Clone Army. Trained to be the best of the best. Their training benefits them greatly at short distances.]]
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_MoveSpeed = 1.12
att.Mult_FixTime = 0.85
att.Mult_HeatDelayTime = 0.85

att.Mult_AccuracyMOA = 0.90
att.Mult_HipDispersion = 0.90
att.Mult_MoveDispersion = 0.90

att.Mult_SpeedMult = 1.05
att.Mult_SightedSpeedMult = 1.15
att.Mult_ReloadTime = 0.90
att.Mult_Recoil = 0.80
att.Mult_RecoilSide = 0.80

att.Mult_Damage = 0.90
att.Mult_DamageMin = 1.25

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonemedic.lua:
att.PrintName = "Clone Medic Training"

att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/medic.png")
att.Description = [[The best medics of the whole Republic Clone Army. Their training greatly benefits them at medium and long distances. In addition, they have better control over the heat of their weapon.]]
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true


att.UBGL = true
att.UBGL_PrintName = "Healing Darts"
att.UBGL_Automatic = true
att.UBGL_ClipSize = 25
att.UBGL_Ammo = "ar2"
att.UBGL_RPM = 125
att.UBGL_Recoil = 0.5
att.UBGL_Capacity = 25

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("ar2")
end

att.UBGL_Fire = function(wep, ubgl)
    wep.Owner:FireBullets({
        Src = wep.Owner:EyePos(),
        Num = 1,
        Damage = 0,
        Force = 0,
        Attacker = wep.Owner,
        Dir = wep.Owner:EyeAngles():Forward(),
        Callback = function(_, tr, dmg)
            local ent = tr.Entity
            local dist = (tr.HitPos - tr.StartPos):Length() * ArcCW.HUToM
            local dmgmax = 25
            local dmgmin = 1
            local delta = dist / 5
            delta = math.Clamp(delta, 0, 1)
            local amt = Lerp(delta, dmgmax, dmgmin)

            ent:SetHealth(math.Clamp(ent:Health() + (amt), 10, (ent:GetMaxHealth() * 1.5)))
        end
    })

    wep:EmitSound("ArcCW_Kraken.SW_HEALINGDARTS", 100)

end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "ar2")

    wep:SetClip2(load)
end
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_handyman.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_pointman.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_pointshooting.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_technician.lua:
att.PrintName = "Technician"

att.Icon = Material("interfaz/iconos/kraken/sith merc arsenal/3534684787_1254886694.png")
att.Description = "Life around this particular firearm has given you a solid understanding of its mechanism. When it malfunctions, you can clear the jam with enough speed to stay in the fight."
att.Desc_Pros = {
    "Jamming will fix faster"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.SortOrder = 1.5

att.Mult_MalfunctionFixTime = .65

att.Ignore = true

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_grip_e11r.lua:
att.PrintName = "SW-Grip E-11R"
att.AbbrevName = "E11-r Grip"
att.SortOrder = 100
att.Icon = nil
att.Description = "Better control."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11r_grip"

att.Model = "models/arccw/sw_battlefront/props/e11r_grip/e11r_grip.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(-90, 0, 0)
att.ModelOffset = Vector(0.5, -5.6, -0.1)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true
att.Mult_SightTime = 0.95
att.Mult_Sway = 0.85
att.Mult_SpeedMult = 0.95

att.Mult_DrawTime = 0.85
att.Mult_HolsterTime = 0.9

att.Mult_HipDispersion = 0.85


--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc15a_75mag.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/sw_stun.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/sw_stun.lua:
att.PrintName = "[ Starwars ] Stun Rounds"
att.AbbrevName = "Stun round (5 seconds)"
att.SortOrder = -2
att.Icon = Material("")
att.Description = "Stun round."

att.Desc_Pros = {
    "Causes stun for 5 seconds!"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}

att.Slot = {"sw_ammo"}

att.SortOrder = -9001
att.AutoStats = true

att.Override_AmmoPerShot = 5
att.Override_Num_Priority = 9001
att.Override_Tracer = "effect_sw_laser_blue_stun"

att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 5, 5, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end

att.Hook_GetShootSound = function(wep, sound)
    return false
end

att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("w/stun_sound.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/sw_stun15.lua:
return gluapack()()
--PATH lua/arccw/shared/languages/base_en.lua:
L = {}
STL = {}

-- not a translate string, but in case a language needs its own font
L["default_font"] = "Bahnschrift"

-- Attachment Slots
L["attslot.optic"] = "Optic"
L["attslot.bkoptic"] = "Backup Optic"
L["attslot.muzzle"] = "Muzzle"
L["attslot.barrel"] = "Barrel"
L["attslot.choke"] = "Choke"
L["attslot.underbarrel"] = "Underbarrel"
L["attslot.tactical"] = "Tactical"
L["attslot.grip"] = "Grip"
L["attslot.stock"] = "Stock"
L["attslot.fcg"] = "Fire Group"
L["attslot.ammo"] = "Ammo Type"
L["attslot.perk"] = "Perk"
L["attslot.charm"] = "Charm"
L["attslot.skin"] = "Skin"
L["attslot.noatt"] = "No Attachment"
L["attslot.optic.default"] = "Iron Sights"
L["attslot.muzzle.default"] = "Standard Muzzle"
L["attslot.barrel.default"] = "Standard Barrel"
L["attslot.choke.default"] = "Standard Choke"
L["attslot.grip.default"] = "Standard Grip"
L["attslot.stock.default"] = "Standard Stock"
L["attslot.stock.none"] = "No Stock"
L["attslot.fcg.default"] = "Standard FCG"

-- Trivia
L["trivia.class"] = "Class"
L["trivia.year"] = "Year"
L["trivia.mechanism"] = "Mechanism"
L["trivia.calibre"] = "Calibre"
L["trivia.ammo"] = "Ammo Type"
L["trivia.country"] = "Country"
L["trivia.manufacturer"] = "Manufacturer"
L["trivia.clipsize"] = "Magazine Capacity"
L["trivia.precision"] = "Precision"
L["trivia.noise"] = "Noise"
L["trivia.recoil"] = "Vertical Recoil"
L["trivia.penetration"] = "Penetration"
L["trivia.firerate"] = "Fire Rate"
L["trivia.firerate_burst"] = "Burst Fire Rate"
L["trivia.fusetime"] = "Fuse Time"

-- Class
L["class.pistol"] = "Pistol"
L["class.revolver"] = "Revolver"
L["class.machinepistol"] = "Machine Pistol"
L["class.smg"] = "Submachine Gun"
L["class.pdw"] = "Personal Defense Weapon"
L["class.shotgun"] = "Shotgun"
L["class.assaultcarbine"] = "Assault Carbine"
L["class.carbine"] = "Carbine"
L["class.assaultrifle"] = "Assault Rifle"
L["class.rifle"] = "Rifle"
L["class.battlerifle"] = "Battle Rifle"
L["class.dmr"] = "DMR"
L["class.sniperrifle"] = "Sniper Rifle"
L["class.antimaterielrifle"] = "Antimateriel Rifle"
L["class.rocketlauncher"] = "Rocket Launcher"
L["class.grenade"] = "Hand Grenade"
L["class.melee"] = "Melee Weapon"

-- UI
L["ui.savepreset"] = "Save Preset"
L["ui.loadpreset"] = "Load Preset"
L["ui.stats"] = "Stats"
L["ui.trivia"] = "Trivia"
L["ui.tttequip"] = "Equipment"
L["ui.tttchat"] = "Quickchat"
L["ui.position"] = "POSITION"
L["ui.positives"] = "POSITIVES:"
L["ui.negatives"] = "NEGATIVES:"
L["ui.information"] = "INFORMATION:"

-- Stats
L["stat.stat"] = "Stat" -- Used on first line of stat page
L["stat.original"] = "Original"
L["stat.current"] = "Current"
L["stat.damage"] = "Close Range Damage"
L["stat.damage.tooltip"] = "How much damage this weapon does at point blank."
L["stat.damagemin"] = "Long Range Damage"
L["stat.damagemin.tooltip"] = "How much damage this weapon does beyond its range."
L["stat.range"] = "Range"
L["stat.range.tooltip"] = "The distance between which close range damage turns to long range damage, in meters."
L["stat.firerate"] = "Fire Rate"
L["stat.firerate.tooltip"] = "The rate at which this weapon cycles at, in rounds per minute."
L["stat.firerate.manual"] = "MANUAL" -- Shown instead of RPM when it is a manual weapon
L["stat.capacity"] = "Capacity"
L["stat.capacity.tooltip"] = "How many rounds this weapon can hold."
L["stat.precision"] = "Precision"
L["stat.precision.tooltip"] = "How precise the weapon is when still and aimed, in minutes of arc."
L["stat.hipdisp"] = "Hip Dispersion"
L["stat.hipdisp.tooltip"] = "How much imprecision is added when the weapon is hipfired."
L["stat.movedisp"] = "Moving Accuracy"
L["stat.movedisp.tooltip"] = "How much imprecision is added when the weapon is used while moving."
L["stat.recoil"] = "Recoil"
L["stat.recoil.tooltip"] = "The amount of kick produced each shot."
L["stat.recoilside"] = "Side Recoil"
L["stat.recoilside.tooltip"] = "The amount of horizontal kick produced each shot."
L["stat.sighttime"] = "Handling Time"
L["stat.sighttime.tooltip"] = "How long does it take to transition from or to sprinting and sights with this weapon."
L["stat.speedmult"] = "Move Speed"
L["stat.speedmult.tooltip"] = "The speed at which you move with the gun, in percentage of original speed."
L["stat.sightspeed"] = "Speed while Sighted"
L["stat.sightspeed.tooltip"] = "The additional slowdown applied when you are moving with sights down."
L["stat.meleedamage"] = "Bash Damage"
L["stat.meleedamage.tooltip"] = "How much damage the melee bash causes."
L["stat.meleetime"] = "Bash Time"
L["stat.meleetime.tooltip"] = "The time it takes to do a melee bash."
L["stat.shootvol"] = "Firing Volume"
L["stat.shootvol.tooltip"] = "How loud the weapon is, in decibels. Louder weapons can be heard from further away."
L["stat.barrellen"] = "Weapon length"
L["stat.barrellen.tooltip"] = "The length of the weapon, in Hammer units / inches. Long barrels will be blocked by walls more easily."
L["stat.pen"] = "Penetration"
L["stat.pen.tooltip"] = "How much material this weapon can penetrate."

-- Autostats
L["autostat.bipodrecoil"] = "Recoil in bipod"
L["autostat.bipoddisp"] = "Dispersion in bipod"
L["autostat.damage"] = "Close range damage"
L["autostat.damagemin"] = "Long range damage"
L["autostat.damageboth"] = "Damage" -- When damage and damagemin are the same value
L["autostat.range"] = "Range"
L["autostat.penetration"] = "Penetration"
L["autostat.muzzlevel"] = "Muzzle velocity"
L["autostat.meleetime"] = "Melee attack time"
L["autostat.meleedamage"] = "Melee damage"
L["autostat.meleerange"] = "Melee range"
L["autostat.recoil"] = "Recoil"
L["autostat.recoilside"] = "Horizontal recoil"
L["autostat.firerate"] = "Fire rate"
L["autostat.precision"] = "Imprecision"
L["autostat.hipdisp"] = "Spread in hipfire"
L["autostat.sightdisp"] = "Spread while sighted"
L["autostat.movedisp"] = "Spread while moving"
L["autostat.jumpdisp"] = "Spread while in midair"
L["autostat.barrellength"] = "Weapon length"
L["autostat.shootvol"] = "Weapon volume"
L["autostat.speedmult"] = "Movement speed"
L["autostat.sightspeed"] = "Speed while sighted"
L["autostat.shootspeed"] = "Speed while shooting"
L["autostat.reloadtime"] = "Reload time"
L["autostat.drawtime"] = "Draw time"
L["autostat.sighttime"] = "Handling"
L["autostat.cycletime"] = "Cycle time"
L["autostat.magextender"] = "Extended magazine size"
L["autostat.magreducer"] = "Reduced magazine size"
L["autostat.bipod"] = "Can use Bipod"
L["autostat.holosight"] = "Precision sight picture"
L["autostat.zoom"] = "Increased zoom"
L["autostat.glint"] = "Visible scope glint"
L["autostat.thermal"] = "Thermal vision"
L["autostat.silencer"] = "Suppresses firing sound"
L["autostat.norandspr"] = "No random spread"
L["autostat.sway"] = "Aim sway"
L["autostat.heatcap"] = "Heat capacity"
L["autostat.heatfix"] = "Overheat fix time"
L["autostat.heatdelay"] = "Heat recovery delay"
L["autostat.heatdrain"] = "Heat recovery rate"

-- TTT
L["ttt.roundinfo"] = "ArcCW Configuration"
L["ttt.roundinfo.replace"] = "Auto-replace TTT weapons"
L["ttt.roundinfo.cmode"] = "Customize Mode:"
L["ttt.roundinfo.cmode0"] = "No Restrictions"
L["ttt.roundinfo.cmode1"] = "Restricted"
L["ttt.roundinfo.cmode2"] = "Pre-game only"
L["ttt.roundinfo.cmode3"] = "T/D only"

L["ttt.roundinfo.attmode"] = "Attachment Mode:"
L["ttt.roundinfo.free"] = "Free"
L["ttt.roundinfo.locking"] = "Locking"
L["ttt.roundinfo.inv"] = "Inventory"
L["ttt.roundinfo.persist"] = "Persistent"
L["ttt.roundinfo.drop"] = "Drop on death"
L["ttt.roundinfo.inv"] = "Inventory"
L["ttt.roundinfo.pickx"] = "Pick"

L["ttt.roundinfo.bmode"] = "Attachment Info on Body:"
L["ttt.roundinfo.bmode0"] = "Unavailable"
L["ttt.roundinfo.bmode1"] = "Detectives Only"
L["ttt.roundinfo.bmode2"] = "Available"

L["ttt.roundinfo.amode"] = "Ammo Explosion:"
L["ttt.roundinfo.amode-1"] = "Disabled"
L["ttt.roundinfo.amode0"] = "Simple"
L["ttt.roundinfo.amode1"] = "Frag"
L["ttt.roundinfo.amode2"] = "Full"
L["ttt.roundinfo.achain"] = "Chain explosions"

L["ttt.bodyatt.found"] = "You think the murder weapon"
L["ttt.bodyatt.founddet"] = "With your detective skills, you deduce the murder weapon"
L["ttt.bodyatt.att1"] = " had {att} installed."
L["ttt.bodyatt.att2"] = " had {att1} and {att2} installed."
L["ttt.bodyatt.att3"] = " had these attachments: "

L["ttt.attachments"] = " Attachment(s): " -- Used in TTT2 TargetID
L["ttt.ammo"] = "Ammo: " -- Used in TTT2 TargetID

-- Shit that used to be in CS+ why
L["info.togglesight"] = "Double press +USE to toggle sights"
L["info.toggleubgl"] = "Double press +ZOOM to toggle underbarrel" -- deprecated
L["pro.ubgl"] = "Selectable underbarrel launcher" -- deprecaated
L["pro.ubsg"] = "Selectable underbarrel shotgun" -- deprecaated
L["con.obstruction"] = "May obstruct sights"
L["autostat.underwater"] = "Shoot underwater"
L["autostat.sprintshoot"] = "Shoot while sprinting"
L["con.beam"] = "Visible laser beam"
L["con.light"] = "Visible flashlight beam"
L["con.noscope"] = "No point of aim"
L["pro.invistracers"] = "Invisible tracers"

-- Incompatibility Menu
L["incompatible.title"] = "ArcCW: INCOMPATIBLE ADDONS"
L["incompatible.line1"] = "You have some addons that are known to not work with ArcCW."
L["incompatible.line2"] = "Disable them or expect broken behavior!"
L["incompatible.confirm"] = "Acknowledge"
L["incompatible.wait"] = "Wait {time}s"
L["incompatible.never"] = "Never warn me again"
L["incompatible.never.hover"] = "Are you absolutely sure you understand the consequences?"
L["incompatible.never.confirm"] = "You have chosen to never show incompatiblity warnings again. If you encounter errors or broken behaviour, it is your own responsibility."

-- 2020-12-11
L["hud.hp"] = "HP: " -- Used in default HUD
L["fcg.safe"] = "Safety"
L["fcg.semi"] = "Semi-auto"
L["fcg.auto"] = "Automatic"
L["fcg.burst"] = "%d-round burst"
L["fcg.ubgl"] = "UBGL"

-- 2021-01-14
L["ui.toggle"] = "TOGGLE"
L["ui.whenmode"] = "When %s"
L["ui.modex"] = "Mode %s"

-- 2021-01-25
L["attslot.magazine"] = "Magazine"

-- 2021-03-13
L["trivia.damage"] = "Damage"
L["trivia.range"] = "Range"
L["trivia.attackspersecond"] = "Attacks Per Second"
L["trivia.description"] = "Description"
L["trivia.meleedamagetype"] = "Damage Type"

-- Units
L["unit.rpm"] = "RPM"
L["unit.moa"] = "MOA"
L["unit.mm"] = "mm"
L["unit.db"] = "dB"
L["unit.bce"] = "BC"
L["unit.aps"] = "APS"

-- melee damage types
L["dmg.generic"] = "Unarmed"
L["dmg.bullet"] = "Piercing"
L["dmg.slash"] = "Slashing"
L["dmg.club"] = "Blunt"
L["dmg.shock"] = "Shock"

L["ui.presets"] = "Presets"
L["ui.customize"] = "Customize"
L["ui.inventory"] = "Inventory"

-- 2021-05-05
L["ui.gamemode_buttons"] = "Gamemode-specific commands"
L["ui.gamemode_usehint"] = "You can hold USE to access original keybinds."
L["ui.darkrpdrop"] = "Drop Weapon"
L["ui.noatts"] = "You have no attachments"
L["ui.noatts_slot"] = "You have no attachments for this slot"
L["ui.lockinv"] = "These attachments are unlocked for all weapons."
L["autostat.ammotype"] = "Converts weapon ammo type to %s"

-- 2021-05-08
L["autostat.rangemin"] = "Minimum range"

-- 2021-05-13
L["autostat.malfunctionmean"] = "Reliability"
L["ui.heat"] = "HEAT"
L["ui.jammed"] = "JAMMED"

-- 2021-05-15
L["trivia.muzzlevel"] = "Muzzle Velocity"
L["unit.mps"] = "m/s"
L["unit.lbfps"] = "lb-fps"
L["trivia.recoilside"] = "Horizontal Recoil"

--2021-05-27
L["ui.pickx"] = "Attachments: %d/%d"
L["ui.ballistics"] = "Ballistics"

L["ammo.pistol"] = "Pistol Ammo"
L["ammo.357"] = "Magnum Ammo"
L["ammo.smg1"] = "Carbine Ammo"
L["ammo.ar2"] = "Rifle Ammo"
L["ammo.buckshot"] = "Shotgun Ammo"
L["ammo.sniperpenetratedround"] = "Sniper Ammo"
L["ammo.smg1_grenade"] = "Rifle Grenades"

--2021-05-31
L["ui.nodata"] = "No Data"
L["ui.createpreset"] = "Create"
L["ui.deletepreset"] = "Delete"

--2021-06-09 nice
L["autostat.clipsize"] = "%d-round magazine capacity"

--2021-06-30
L["autostat.bipod2"] = "Allows bipod (-%d%% Dispersion, -%d%% Recoil)"
L["autostat.nobipod"] = "Disables bipod"

--2021-07-01
L["fcg.safe2"] = "Lowered"
L["fcg.dact"] = "Double-action"
L["fcg.sact"] = "Single-action"
L["fcg.bolt"] = "Bolt-action"
L["fcg.pump"] = "Pump-action"
L["fcg.lever"] = "Lever-action"
L["fcg.manual"] = "Manual-action"
L["fcg.break"] = "Break-action"
L["fcg.sngl"] = "Single"
L["fcg.both"] = "Both"

--2021-08-11
L["autostat.clipsize.mod"] = "Magazine capacity" -- used for Add_ClipSize and Mult_ClipSize

--2021-08-22
L["trivia.recoilscore"] = "Recoil Score (Lower is better)"
L["fcg.safe.abbrev"] = "SAFE"
L["fcg.semi.abbrev"] = "SEMI"
L["fcg.auto.abbrev"] = "AUTO"
L["fcg.burst.abbrev"] = "%d-BST"
L["fcg.ubgl.abbrev"] = "UBGL"
L["fcg.safe2.abbrev"] = "LOW"
L["fcg.dact.abbrev"] = "DACT"
L["fcg.sact.abbrev"] = "SACT"
L["fcg.bolt.abbrev"] = "BOLT"
L["fcg.pump.abbrev"] = "PUMP"
L["fcg.lever.abbrev"] = "LEVER"
L["fcg.manual.abbrev"] = "MANUAL"
L["fcg.break.abbrev"] = "BREAK"
L["fcg.sngl.abbrev"] = "SNGL"
L["fcg.both.abbrev"] = "BOTH"

-- 2021-10-10
STL["lowered"] = "fcg.safe2"
STL["double-action"] = "fcg.dact"
STL["single-action"] = "fcg.sact"
STL["bolt-action"] = "fcg.bolt"
STL["pump-action"] = "fcg.pump"
STL["lever-action"] = "fcg.lever"
STL["manual-action"] = "fcg.manual"
STL["break-action"] = "fcg.break"
--STL["single"] = "fcg.sngl"
--STL["both"] = "fcg.both"

-- 2021-11-27
L["ui.hitgroup"] = "Hitgroup"
L["ui.shotstokill"] = "Shots to kill"
L["ui.hitgroup.head"] = "Head"
L["ui.hitgroup.torso"] = "Torso" -- chest+stomach when they're the same
L["ui.hitgroup.chest"] = "Chest"
L["ui.hitgroup.stomach"] = "Stomach"
L["ui.hitgroup.arms"] = "Arms"
L["ui.hitgroup.legs"] = "Legs"
L["ui.nonum"] = "You need bullets to kill people, silly." -- num is 0

-- 2022-05-23
L["fcg.nade"] = "Grenade"
L["fcg.nade.abbrev"] = "NADE"

-- 2022-08-03
L["attslot.magazine"] = "Magazine"
L["attslot.magazine.default"] = "Standard Magazine"

-- 2022-08-17
L["autostat.ubgl"] = "Selectable underbarrel weapon"
L["autostat.ubgl2"] = "Press your USE key and RELOAD key together to activate underbarrel weapon"
L["autostat.ammotypeubgl"] = "Underbarrel weapon uses %s"

-- 2023-09-09
L["autostat.triggerdelay"] = "Trigger delay"


--[[]
You can translate the trivia of any arbitrary weapon or attachment by adding the phrase ["desc.class_name"]
Similarly, you can translate attachment and weapon names with ["name.class_name"]
When translating weapon names, append .true for truename, like ["name.arccw_p228.true"]
Example:
 L["desc.fcg_auto"] = "blah blah blah automatic firemode"
 L["name.fcg_auto"] = "Auto But Cooler"
You can also translate custom firemodes with "fcg.FIREMODE_NAME"
]]
--PATH lua/arccw/shared/sh_vehicle.lua:
return gluapack()()
--PATH lua/arccw/client/cl_binds.lua:
return gluapack()()
--PATH lua/arccw/client/cl_blacklist.lua:
local srf      = surface



local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

local blacklistWindow = nil
local blacklistTbl    = {}
local filter          = ""
local onlyblacklisted = false
local internalName    = false
local dragMode = nil

local color_arccwbred = Color(150, 50, 50, 255)
local color_arccwlred = Color(125, 25, 25, 150)
local color_arccwdred = Color(75, 0, 0, 150)
local color_arccwdtbl = Color(0, 0, 0, 200)

local function SaveBlacklist()
    -- We send ID over instead of strings to save on network costs
    -- optimization_is_optimization.png

    local blacklistAmt = 0

    for attName, bStatus in pairs(blacklistTbl) do
        if bStatus then blacklistAmt = blacklistAmt + 1 end
    end

    net.Start("arccw_blacklist")
        net.WriteBool(false)
        net.WriteUInt(blacklistAmt, ArcCW.GetBitNecessity())
        for attName, bStatus in pairs(blacklistTbl) do
            if bStatus then
                net.WriteUInt(ArcCW.AttachmentTable[attName].ID, ArcCW.GetBitNecessity())
            end
        end
    net.SendToServer()

    blacklistTbl = {}
end

local function CreateAttButton(parent, attName, attTbl)
    local attBtn = vgui.Create("DButton", parent)
    attBtn:SetFont("ArcCW_8")
    attBtn:SetText("")
    attBtn:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(16))
    attBtn:Dock(TOP)
    attBtn:DockMargin(ScreenScaleMulti(36), ScreenScaleMulti(1), ScreenScaleMulti(36), ScreenScaleMulti(1))
    attBtn:SetContentAlignment(5)

    attBtn.Paint = function(spaa, w, h)
        local blisted = blacklistTbl[attName]
        if blisted == nil then blisted = attTbl.Blacklisted end

        local hovered = spaa:IsHovered()
        local blackhov = blisted and hovered

        local Bfg_col = blackhov and color_arccwbred or blisted and color_arccwbred or hovered and color_black or color_white
        local Bbg_col = blackhov and color_arccwlred or blisted and color_arccwdred or hovered and color_white or color_arccwdtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        local img = attTbl.Icon
        if img then
            srf.SetDrawColor(Bfg_col)
            srf.SetMaterial(img)
            srf.DrawTexturedRect(ScreenScaleMulti(2), 0, h, h)
        end

        local txt = attTbl.PrintName
        if internalName then txt = attName end
        srf.SetTextColor(Bfg_col)
        srf.SetTextPos(ScreenScaleMulti(20), ScreenScaleMulti(2))
        srf.SetFont("ArcCW_12")
        srf.DrawText(txt)

        local listed   = (blacklistTbl[attName] and !attTbl.Blacklisted)
        local unlisted = (attTbl.Blacklisted and !blacklistTbl[attName])
        local saved = (listed or unlisted) and " [not saved]" or ""
        srf.SetTextColor(Bfg_col)
        srf.SetTextPos(spaa:GetWide() - ScreenScaleMulti(36), ScreenScaleMulti(4))
        srf.SetFont("ArcCW_8")
        srf.DrawText(saved)
    end

    -- In addition to clicking on a button, you can drag over all of them!
    attBtn.OnMousePressed = function(spaa, kc)
        blacklistTbl[attName] = !blacklistTbl[attName] and !attTbl.Blacklisted or !blacklistTbl[attName]
        dragMode = blacklistTbl[attName]
        hook.Add("Think", "ArcCW_Blacklist", function()
            if !input.IsMouseDown(MOUSE_LEFT) then
                dragMode = nil
                hook.Remove("Think", "ArcCW_Blacklist")
            end
        end)
    end
    attBtn.OnCursorEntered = function(spaa, kc)
        if dragMode != nil and input.IsMouseDown(MOUSE_LEFT) then
            blacklistTbl[attName] = dragMode
        end
    end

    return attBtn
end

function ArcCW.MakeBlacklistWindow()
    if blacklistWindow then blacklistWindow:Remove() end

    blacklistTbl = {}

    blacklistWindow = vgui.Create("DFrame")
    blacklistWindow:SetSize(ScrW() * 0.5, ScrH() * 0.75)
    blacklistWindow:Center()
    blacklistWindow:SetTitle("")
    blacklistWindow:SetDraggable(false)
    blacklistWindow:SetVisible(true)
    blacklistWindow:ShowCloseButton(true)
    blacklistWindow:MakePopup()
    blacklistWindow.Paint = function(self, w, h)
        srf.SetDrawColor(color_arccwdtbl)
        srf.DrawRect(0, 0, w, h)
    end

    local title = vgui.Create("DLabel", blacklistWindow)
    title:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(26))
    title:Dock(TOP)
    title:SetFont("ArcCW_24")
    title:SetText("ArcCW Blacklist")
    title:DockMargin(ScreenScaleMulti(16), 0, ScreenScaleMulti(16), ScreenScaleMulti(8))

    local desc = vgui.Create("DLabel", blacklistWindow)
    desc:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc:Dock(TOP)
    desc:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), ScreenScaleMulti(4))
    desc:SetFont("ArcCW_12")
    desc:SetText("Attachments checked here will stop showing up at all.")
    desc:SetContentAlignment(5)

    local attList = vgui.Create("DScrollPanel", blacklistWindow)
    attList:SetText("")
    attList:Dock(FILL)
    attList:SetContentAlignment(5)
    attList.Paint = function(span, w, h) end

    local sbar = attList:GetVBar()
    sbar.Paint = function() end
    sbar.btnUp.Paint = function(span, w, h) end
    sbar.btnDown.Paint = function(span, w, h) end
    sbar.btnGrip.Paint = function(span, w, h)
        srf.SetDrawColor(color_white)
        srf.DrawRect(0, 0, w, h)
    end

    local FilterPanel = vgui.Create("DPanel", blacklistWindow)
    FilterPanel:Dock(TOP)
    FilterPanel:DockMargin(ScreenScaleMulti(16), ScreenScaleMulti(2), ScreenScaleMulti(16), ScreenScaleMulti(2))
    FilterPanel:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    FilterPanel:SetPaintBackground(false)

    local FilterLabel = vgui.Create("DLabel", FilterPanel)
    FilterLabel:Dock(LEFT)
    FilterLabel:SetWidth(ScreenScaleMulti(36))
    FilterLabel:DockMargin(ScreenScaleMulti(2), ScreenScaleMulti(2), ScreenScaleMulti(2), ScreenScaleMulti(2))
    FilterLabel:SetFont("ArcCW_12")
    FilterLabel:SetText("FILTER")

    local FilterButton = vgui.Create("DButton", FilterPanel)
    FilterButton:SetFont("ArcCW_8")
    FilterButton:SetText("")
    FilterButton:SetSize(ScreenScaleMulti(48), ScreenScaleMulti(12))
    FilterButton:Dock(RIGHT)
    FilterButton:DockMargin(ScreenScaleMulti(1), 0, 0, 0)
    FilterButton:SetContentAlignment(5)

    FilterButton.OnMousePressed = function(spaa, kc)
        onlyblacklisted = !onlyblacklisted

        attList:GenerateButtonsToList()
    end

    FilterButton.Paint = function(spaa, w, h)
        local hovered = spaa:IsHovered()

        local Bfg_col = hovered and color_black or color_white
        local Bbg_col = hovered and color_white or color_arccwdtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        spaa:SetTextColor(Bfg_col)
        spaa:SetText(onlyblacklisted and "BLACKLISTED" or "ALL")
    end

    local NameButton = vgui.Create("DButton", FilterPanel)
    NameButton:SetFont("ArcCW_8")
    NameButton:SetText("")
    NameButton:SetSize(ScreenScaleMulti(24), ScreenScaleMulti(12))
    NameButton:Dock(RIGHT)
    NameButton:DockMargin(ScreenScaleMulti(1), 0, 0, 0)
    NameButton:SetContentAlignment(5)

    NameButton.OnMousePressed = function(spaa, kc)
        internalName = !internalName
        attList:GenerateButtonsToList()
    end

    NameButton.Paint = function(spaa, w, h)
        local hovered = spaa:IsHovered()

        local Bfg_col = hovered and color_black or color_white
        local Bbg_col = hovered and color_white or color_arccwdtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        spaa:SetTextColor(Bfg_col)
        spaa:SetText(internalName and "ID" or "NAME")
    end

    local FilterEntry = vgui.Create("DTextEntry", FilterPanel)
    FilterEntry:Dock(FILL)
    FilterEntry:SetValue(filter)
    FilterEntry:SetFont("ArcCW_12")
    FilterEntry.OnChange = function( self )
        filter = self:GetValue():lower()

        attList:GenerateButtonsToList()
    end

    local accept = vgui.Create("DButton", blacklistWindow)
    accept:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    accept:SetText("")
    accept:Dock(BOTTOM)
    accept:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))
    accept:SetContentAlignment(5)

    accept.OnMousePressed = function(spaa, kc)
        SaveBlacklist()

        blacklistWindow:Close()
        blacklistWindow:Remove()
    end

    accept.Paint = function(spaa, w, h)
        local hovered = spaa:IsHovered()

        local Bfg_col = hovered and color_black or color_white
        local Bbg_col = hovered and color_white or color_arccwdtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        srf.SetTextColor(Bfg_col)
        srf.SetTextPos(ScreenScaleMulti(4), ScreenScaleMulti(4))
        srf.SetFont("ArcCW_12")
        srf.DrawText("Save")
    end

    -- Perhaps unoptimized, but it's client
    -- client_side_calculations_is_not_expensive.png
    function attList:GenerateButtonsToList()
        self:GetCanvas():Clear()

        for attName, attTbl in SortedPairsByMemberValue(ArcCW.AttachmentTable, "PrintName") do
            if attTbl.Hidden then continue end

            if attTbl.Blacklisted then blacklistTbl[attName] = true end

            if onlyblacklisted and !(attTbl.Blacklisted or blacklistTbl[attName]) then continue end

            if filter != "" and !(string.find((attTbl.PrintName):lower(), filter) or string.find((attName):lower(), filter)) then continue end

            --if attTbl.Slot == "charm" then continue end why the fuck would you do this

            CreateAttButton(self, attName, attTbl)
        end
    end

    attList:GenerateButtonsToList()
end

concommand.Add("arccw_blacklist", function()
    if LocalPlayer():IsAdmin() then ArcCW.MakeBlacklistWindow() end
end)
--PATH lua/arccw/client/cl_convars.lua:
--[[
    ClientConVars table doc:
    name = data:
    def  - default value
    desc - description of var
    min  - minimum value
    max  - maximum value
    usri - userinfo
    save - whether to save (default true)
]]

ArcCW.ClientConVars = {
    ["arccw_bullet_imaginary"]        = { def = 1 },

    ["arccw_crosshair"]               = { def = 1 },
    ["arccw_crosshair_clr_r"]         = { def = 255 },
    ["arccw_crosshair_clr_g"]         = { def = 255 },
    ["arccw_crosshair_clr_b"]         = { def = 255 },
    ["arccw_crosshair_clr_a"]         = { def = 255 },
    ["arccw_crosshair_length"]        = { def = 4 },
    ["arccw_crosshair_thickness"]     = { def = 1 },
    ["arccw_crosshair_gap"]           = { def = 1 },
    ["arccw_crosshair_static"]        = { def = 0 },
    ["arccw_crosshair_clump"]         = { def = 0 },
    ["arccw_crosshair_clump_outline"] = { def = 0 },
    ["arccw_crosshair_clump_always"]  = { def = 0 },
    ["arccw_crosshair_outline"]       = { def = 2 },
    ["arccw_crosshair_outline_r"]     = { def = 0 },
    ["arccw_crosshair_outline_g"]     = { def = 0 },
    ["arccw_crosshair_outline_b"]     = { def = 0 },
    ["arccw_crosshair_outline_a"]     = { def = 255 },
    ["arccw_crosshair_dot"]           = { def =  1 },
    ["arccw_crosshair_shotgun"]       = { def =  1 },
    ["arccw_crosshair_equip"]         = { def =  1 },
    ["arccw_crosshair_aa"]            = { def =  1 },
    ["arccw_crosshair_trueaim"]       = { def =  0 },
    ["arccw_crosshair_prong_top"]     = { def =  1 },
    ["arccw_crosshair_prong_left"]    = { def =  1 },
    ["arccw_crosshair_prong_right"]   = { def =  1 },
    ["arccw_crosshair_prong_bottom"]  = { def =  1 },
    ["arccw_crosshair_tilt"]    = { def =  0 },

    ["arccw_attinv_simpleproscons"]   = { def =  0 },
    ["arccw_attinv_onlyinspect"]      = { def =  0 },
    ["arccw_attinv_hideunowned"]      = { def =  0 },
    ["arccw_attinv_darkunowned"]      = { def =  0 },
    ["arccw_attinv_closeonhurt"]      = { def =  0, usri = true },
    ["arccw_attinv_gamemodebuttons"]  = { def =  1 },

    ["arccw_language"]                = { def =  "", usri = true },
    ["arccw_font"]                    = { def =  "", usri = true },
    ["arccw_ammonames"]               = { def =  0 },

    ["arccw_cheapscopes"]             = { def =  1 },
    ["arccw_cheapscopesv2_ratio"]     = { def =  0.05 },
    ["arccw_scopepp"]                 = { def =  1 },
    ["arccw_thermalpp"]               = { def =  1 },
    ["arccw_scopepp_refract"]         = { def =  0 },
    ["arccw_scopepp_refract_ratio"]   = { def =  0.75 },

    ["arccw_cheapscopesautoconfig"]   = { def =  0 }, -- what this for

    --["arccw_flatscopes"]              = { def = 0 },

    ["arccw_shake"]                   = { def =  1 },
    ["arccw_shakevm"]                 = { def =  1 },
    ["arccw_muzzleeffects"]           = { def =  1 },
    ["arccw_shelleffects"]            = { def =  1 },
    ["arccw_shelltime"]               = { def =  0 },
    ["arccw_att_showothers"]          = { def =  1 },
    ["arccw_att_showground"]          = { def =  1 },
    ["arccw_visibility"]              = { def =  8000 },
    ["arccw_fastmuzzles"]             = { def =  0 },
    ["arccw_fasttracers"]             = { def =  0 },

    ["arccw_2d3d"]                    = { def =  1, min = 0, max = 2},

    ["arccw_hud_3dfun"]               = { def =  0, usri = true },
    ["arccw_hud_3dfun_lite"]          = { def =  0 },
    ["arccw_hud_3dfun_ammotype"]      = { def =  0 },
    ["arccw_hud_forceshow"]           = { def =  0 },
    ["arccw_hud_fcgbars"]             = { def =  1, desc = "Draw firemode bars on ammo HUD." },
    ["arccw_hud_fcgabbrev"]           = { def =  0, desc = "Use shortened firemode names."},
    ["arccw_hud_minimal"]             = { def =  1, desc = "Backup HUD if we cannot draw the ammo HUD." },
    ["arccw_hud_embracetradition"]    = { def =  0, desc = "Use the classic customization HUD." },
    ["arccw_hud_deadzone_x"]          = { def =  0 },
    ["arccw_hud_deadzone_y"]          = { def =  0 },
    ["arccw_hud_3dfun_decaytime"]     = { def =  3 },
    ["arccw_hud_3dfun_right"]         = { def =  2 },
    ["arccw_hud_3dfun_up"]            = { def =  1 },
    ["arccw_hud_3dfun_forward"]       = { def =  0 },
    ["arccw_hud_size"]                = { def =  1 },

    ["arccw_cust_sounds"]             = { def =  1, desc = "Play sounds when opening and closing the customization menu." },

    ["arccw_scope_r"]                 = { def =  255 },
    ["arccw_scope_g"]                 = { def =  0 },
    ["arccw_scope_b"]                 = { def =  0 },

    ["arccw_blur"]                    = { def =  0 },
    ["arccw_blur_toytown"]            = { def =  1 },

    ["arccw_adjustsensthreshold"]     = { def =  0 },

    ["arccw_drawbarrel"]              = { def =  0 },

    ["arccw_glare"]                   = { def =  1 },
    ["arccw_autosave"]                = { def =  1 },

    ["arccw_vm_right"]                = { def =  0 },
    ["arccw_vm_up"]                   = { def =  0 },
    ["arccw_vm_forward"]              = { def =  0 },
    ["arccw_vm_pitch"]                = { def =  0 },
    ["arccw_vm_yaw"]                  = { def =  0 },
    ["arccw_vm_roll"]                 = { def =  0 },
    ["arccw_vm_fov"]                  = { def =  0, usri = true },
    ["arccw_vm_add_ads"]              = { def =  0},
    ["arccw_vm_coolsway"]             = { def =  1 },
    ["arccw_vm_coolview"]             = { def =  1 },
    ["arccw_vm_coolview_mult"]        = { def =  1 },
    ["arccw_vm_look_xmult"]           = { def =  1 },
    ["arccw_vm_look_ymult"]           = { def =  1 },
    ["arccw_vm_sway_xmult"]           = { def =  1 },
    ["arccw_vm_sway_ymult"]           = { def =  1 },
    ["arccw_vm_sway_zmult"]           = { def =  1 },

    ["arccw_vm_sway_speedmult"]       = { def =  1 },
    ["arccw_vm_nearwall"]             = { def =  1 },

    ["arccw_toggleads"]               = { def = 0, usri = true },
    ["arccw_altbindsonly"]            = { def = 0, usri = true },
    ["arccw_altsafety"]               = { def = 0, usri = true },
    ["arccw_automaticreload"]         = { def = 0, usri = true },

    ["arccw_nohl2flash"]              = { def = 0, usri = true },

    ["arccw_aimassist_cl"]            = { def = 0, usri = true },

    ["arccw_dev_benchgun"]            = { def = 0, save = false },
    ["arccw_dev_benchgun_custom"]     = { def = "", save = false },

    ["arccw_dev_removeonclose"]       = { def = 0, desc = "Remove the hud when closing instead of fading out, allowing easy reloading of the hud.", save = false },
    ["arccw_noinspect"]               = { def = 0, usri = true },

    ["arccw_dev_crosshair"]           = { def = 0, save = false },
}

for name, data in pairs(ArcCW.ClientConVars) do
    ArcCW.ConVars[string.sub(name, 7)] = CreateClientConVar(name, data.def, data.save == nil and true or data.save, data.usri or false, data.desc, data.min, data.max)
end

-- CreateClientConVar("arccw_quicknade", KEY_G)

--PATH lua/autorun/aussi_cgi104th_arms.lua:
list.Set( "PlayerOptionsModel", "Phase 2 104th Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_trooper.mdl" )
player_manager.AddValidModel( "Phase 2 104th Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_trooper.mdl" )
player_manager.AddValidHands( "Phase 2 104th Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th BARC Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_barc.mdl" )
player_manager.AddValidModel( "Phase 2 104th BARC Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_barc.mdl" )
player_manager.AddValidHands( "Phase 2 104th BARC Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Medic (CGI)", "models/aussiwozzi/cgi/base/104th_medic.mdl" )
player_manager.AddValidModel( "Phase 2 104th Medic (CGI)", "models/aussiwozzi/cgi/base/104th_medic.mdl" )
player_manager.AddValidHands( "Phase 2 104th Medic (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Medic Officer (CGI)", "models/aussiwozzi/cgi/base/104th_medic_officer.mdl" )
player_manager.AddValidModel( "Phase 2 104th Medic Officer (CGI)", "models/aussiwozzi/cgi/base/104th_medic_officer.mdl" )
player_manager.AddValidHands( "Phase 2 104th Medic Officer (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Officer (CGI)", "models/aussiwozzi/cgi/base/104th_officer.mdl" )
player_manager.AddValidModel( "Phase 2 104th Officer (CGI)", "models/aussiwozzi/cgi/base/104th_officer.mdl" )
player_manager.AddValidHands( "Phase 2 104th Officer (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Commander Wolffe (CGI)", "models/aussiwozzi/cgi/base/104th_Wolffe.mdl" )
player_manager.AddValidModel( "Phase 2 104th Commander Wolffe (CGI)", "models/aussiwozzi/cgi/base/104th_Wolffe.mdl" )
player_manager.AddValidHands( "Phase 2 104th Commander Wolffe (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Pilot (CGI)", "models/aussiwozzi/cgi/base/104th_pilot.mdl" )
player_manager.AddValidModel( "Phase 2 104th Pilot (CGI)", "models/aussiwozzi/cgi/base/104th_pilot.mdl" )
player_manager.AddValidHands( "Phase 2 104th Pilot (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Boost (CGI)", "models/aussiwozzi/cgi/base/104th_boost.mdl" )
player_manager.AddValidModel( "Phase 2 104th Boost (CGI)", "models/aussiwozzi/cgi/base/104th_boost.mdl" )
player_manager.AddValidHands( "Phase 2 104th Boost (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Comet (CGI)", "models/aussiwozzi/cgi/base/104th_comet.mdl" )
player_manager.AddValidModel( "Phase 2 104th Comet (CGI)", "models/aussiwozzi/cgi/base/104th_comet.mdl" )
player_manager.AddValidHands( "Phase 2 104th Comet (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_arf.mdl" )
player_manager.AddValidModel( "Phase 2 104th ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_arf.mdl" )
player_manager.AddValidHands( "Phase 2 104th ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Sinker (CGI)", "models/aussiwozzi/cgi/base/104th_sinker.mdl" )
player_manager.AddValidModel( "Phase 2 104th Sinker (CGI)", "models/aussiwozzi/cgi/base/104th_sinker.mdl" )
player_manager.AddValidHands( "Phase 2 104th Sinker (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th EVO Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_evo.mdl" )
player_manager.AddValidModel( "Phase 2 104th EVO Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_evo.mdl" )
player_manager.AddValidHands( "Phase 2 104th EVO Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_evo_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th EVO Officer (CGI)", "models/aussiwozzi/cgi/base/104th_evo_officer.mdl" )
player_manager.AddValidModel( "Phase 2 104th EVO Officer (CGI)", "models/aussiwozzi/cgi/base/104th_evo_officer.mdl" )
player_manager.AddValidHands( "Phase 2 104th EVO Officer (CGI)", "models/aussiwozzi/cgi/base/104th_evo_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th EVO Wolffe (CGI)", "models/aussiwozzi/cgi/base/104th_evo_wolffe.mdl" )
player_manager.AddValidModel( "Phase 2 104th EVO Wolffe (CGI)", "models/aussiwozzi/cgi/base/104th_evo_wolffe.mdl" )
player_manager.AddValidHands( "Phase 2 104th EVO Wolffe (CGI)", "models/aussiwozzi/cgi/base/104th_evo_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Jet Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_jet.mdl" )
player_manager.AddValidModel( "Phase 2 104th Jet Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_jet.mdl" )
player_manager.AddValidHands( "Phase 2 104th Jet Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Jet Officer (CGI)", "models/aussiwozzi/cgi/base/104th_jet_officer.mdl" )
player_manager.AddValidModel( "Phase 2 104th Jet Officer (CGI)", "models/aussiwozzi/cgi/base/104th_jet_officer.mdl" )
player_manager.AddValidHands( "Phase 2 104th Jet Officer (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th ARC Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_arc.mdl" )
player_manager.AddValidModel( "Phase 2 104th ARC Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_arc.mdl" )
player_manager.AddValidHands( "Phase 2 104th ARC Trooper (CGI)", "models/aussiwozzi/cgi/base/104th_arc_arms.mdl",0,"10000000" )

--PATH lua/autorun/aussi_droid_pms.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/autorun/awarn3.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/cl_awarn3.lua:
AddCSLuaFile()
--[[
      __          __              ____  
     /\ \        / /             |___ \ 
    /  \ \  /\  / /_ _ _ __ _ __   __) |
   / /\ \ \/  \/ / _` | '__| '_ \ |__ < 
  / ____ \  /\  / (_| | |  | | | |___) |
 /_/    \_\/  \/ \__,_|_|  |_| |_|____/ 

	AWarn3 by Mr.President
]]


MsgC( AWARN3_CLIENT, "[AWarn3] ", AWARN3_WHITE, "AWarn3 is loading...\n" )

include( "includes/awarn3_localization.lua" )
include( "includes/sh_awarn3.lua" )
include( "includes/awarn3_concommands.lua" )
include( "includes/awarn3_permissions.lua" )
include( "includes/awarn3_vgui.lua" )
include( "includes/awarn3_themes.lua" )

net.Receive( "awarn3_clientmessage", function()
	local message = net.ReadString()
	chat.AddText( AWARN3_WARNING , "[AWarn3] ", AWARN3_WHITE, message )
end )

local PLAYER = FindMetaTable( "Player" )

net.Receive( "awarn3_warningmessage", function()

	local PlayerID = net.ReadString()
	local AdminID = net.ReadString()
	local WarningReason = net.ReadString()

	local pl = AWarn:GetPlayerFromID64( PlayerID ) or nil
	local admin = AWarn:GetPlayerFromID64( AdminID ) or nil
	
	local TARGET_COLOR 	= Color( 128,255,0 )
	local ADMIN_COLOR 	= Color( 128,255,0 )
	
	local plName = PlayerID
	local adminName = AdminID
	if IsValid( pl ) then plName = pl:GetName() end
	if IsValid( admin ) then adminName = admin:GetName() end
	
	local message = ""
	if LocalPlayer() == pl then
		if WarningReason == "NONE GIVEN" then
			message = ( AWarn.Localization:GetTranslation( "warnmessage4" ) ):format( adminName )
		else
			message = ( AWarn.Localization:GetTranslation( "warnmessage1" ) ):format( adminName, WarningReason )
		end
		chat.AddText( AWARN3_WARNING, "[AWarn3] ", AWARN3_WHITE, message )
		return
	end
	
	if LocalPlayer() == admin then
		if WarningReason == "NONE GIVEN" then
			message = ( AWarn.Localization:GetTranslation( "warnmessage5" ) ):format( plName )
		else
			message = ( AWarn.Localization:GetTranslation( "warnmessage2" ) ):format( plName, WarningReason )
		end
		chat.AddText( AWARN3_WARNING, "[AWarn3] ", AWARN3_WHITE, message )
		return
	end
	
	if WarningReason == "NONE GIVEN" then
		message = ( AWarn.Localization:GetTranslation( "warnmessage6" ) ):format( plName, adminName )
	else
		message = ( AWarn.Localization:GetTranslation( "warnmessage3" ) ):format( plName, adminName, WarningReason )
	end
	chat.AddText( AWARN3_WARNING, "[AWarn3] ", AWARN3_WHITE, message )
end )



net.Receive( "awarn3_chatmessagecolor", function()
	local messageContents = net.ReadTable()
	chat.AddText( AWARN3_CHATTAG, "[AWarn3] ", AWARN3_WHITE, unpack( messageContents ) )
end )

function AWarn:CreateWarningID( target_id, admin_id, reason )
	net.Start( "awarn3_createwarningid" )
	net.WriteString( target_id )
	net.WriteString( admin_id )
	net.WriteString( reason )
	net.SendToServer()
end

function AWarn:SavePlayerNotes( target_id, notes )
	net.Start( "awarn3_updateplayernotes" )
	net.WriteString( target_id )
	net.WriteString( notes )
	net.SendToServer()
end

function AWarn:RequestNotes( target_id )
	net.Start( "awarn3_notesrequest" )
	net.WriteString( target_id )
	net.SendToServer()
end

function AWarn:AddActiveWarning( target_id, amt )
	net.Start( "awarn3_addactivewarning" )
	net.WriteString( target_id )
	net.WriteInt( amt, 8 )
	net.SendToServer()
end

function AWarn:DeleteAllPlayerWarnings( target_pl )
	net.Start( "awarn3_deleteallplayerwarnings" )
	net.WriteString( target_pl )
	net.SendToServer()
end

function AWarn:GetPlayerActiveWarnings( pl )
	return pl:GetNW2Int( 'awarn3_activewarnings', 0 )
end

function PLAYER:GetActiveWarnings()
	return AWarn:GetPlayerActiveWarnings( self )
end

local config_version = 3
function AWarn:SaveClientSettings()
	AWarn:CheckDirectory()
	local clientConfig = {}
	clientConfig.Colors = AWarn.Colors
	clientConfig.Version = config_version
	
	file.Write( "awarn3/client_configuration.txt", util.TableToJSON( clientConfig, true ) )
end

function AWarn:LoadClientSettings()
	if file.Exists( "awarn3/client_configuration.txt", "DATA" ) then
		local clientConfig = util.JSONToTable( file.Read( "awarn3/client_configuration.txt", "DATA" ) )
		if ( clientConfig.Version or 0 ) < config_version then
			self:SaveClientSettings()
			return
		end
		AWarn.Colors = clientConfig.Colors
	else
		self:SaveClientSettings()
	end
end

AWarn.Outdated = false
local function AWarn3_Version_Check_CL()
	http.Fetch( "https://www.g4p.org/awarn3/version.php",
		
		-- onSuccess function
		function( body, length, headers, code )
			if not (AWarn.Version == body) then
				AWarn.Outdated = true
			end
		end,
		
		function( message )
			MsgC( AWARN3_CLIENT, "[AWarn3] ", AWARN3_WHITE, "Failed to retrieve latest version for version check.\n" )
		end
	)
end

local function AWarn3_Stats_TimerStart()
	timer.Simple( 5, AWarn3_Version_Check_CL )
end
hook.Add( "InitPostEntity", "awarn3_version_check_cl", AWarn3_Stats_TimerStart )

AWarn:LoadClientSettings()
--PATH addons/[admin] awarn3/lua/localizations/pl.lua:
local language_code = "PL"

AWarn.Localization:RegisterLanguage( language_code, "Polish" )

//Credit: https://www.gmodstore.com/users/76561198086149246

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"Witaj w AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"Nie posiadasz uprawnienia, aby uy tej komendy." )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"Nie posiadasz uprawnienia, aby zobaczy na ostrzeenia tego gracza." )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"Ta komenda nie istnieje." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"Nieprawidowy cel lub ID." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				"Nieprawidowy cel." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"Wymagany jest powd ostrzeenia." )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"Usune 1-no aktywne ostrzeenie z" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"Usunito ID ostrzeenia" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"Usune wszelkie ostrzeenia z gracza" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"Usune wszelkie ostrzeenia z" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"Nie moesz otworzy menu z konsoli serwerowej." )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				"Nieprawidowa Opcja." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"Nieprawidowy Typ Wartoci." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				"Opcje zostay zaadowane!" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"Brak kary za tak ilo ostrzee." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			"Kary zostay zaadowane!" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"Ten gracz nie moe zosta ostrzeony." )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"Zostae ostrzeony przez gracza %s za %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"Naoye ostrzeenia na gracza %s za %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s naoy ostrzeenie na %s za %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",				"Zostae ostrzeony przez gracza %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",				"Naoye ostrzeenia na gracza %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",				"%s naoy ostrzeenie na %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"poczy si z serwerem z ostrzeeniami." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"Jego ostatnio ostrzeenie zostao naoone:" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"Witaj ponownie! Wyglda na to e ju otrzymae ostrzeenie w przeszoci." )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"Moesz podejrze ilo ostrzee za pomoc komendy" )
AWarn.Localization:AddDefinition( language_code, "closemenu",					"Zamknij Menu" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				"Szukaj Graczy" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				"Poka Ostrzeenia" )
AWarn.Localization:AddDefinition( language_code, "configuration",				"Konfiguracja" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				"Opcje Uytkownika" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				"Opcje Serwerowe" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			"Dostosuj Kolor" )
AWarn.Localization:AddDefinition( language_code, "colorselection",				"Wybierz Kolor" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		"Opcje Jzykowe" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				"Wybierz Jzyk" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"Wcz Opcj Kickowania(po osigniciu x liczby ostrzee)" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"Wcz Opcj Banowania(po osigniciu x liczby ostrzee)" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					"Wcz Opcj Upywania Aktywnych Ostrzee" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"Zresetuj aktywne ostrzeenia po otrzymaniu bana" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"Zezwl na ostrzeganie Administratorw" )
AWarn.Localization:AddDefinition( language_code, "pressenter",					"Wcinij Enter, aby zapisa zmiany." )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"Enter aby zapisa" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					"Przedrostek wywietlany na chatcie" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			"Szybko Przemijania Ostrzee (w minutach)" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				"Jzyk Serwera" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	"Konfiguracja Systemu Kar" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				"Dodaj Kar" )
AWarn.Localization:AddDefinition( language_code, "warnings",					"Ostrzeenia" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					"Typ Kary" )
AWarn.Localization:AddDefinition( language_code, "punishlength",				"Dugo Kary" )
AWarn.Localization:AddDefinition( language_code, "playermessage",				"Wiadomo" )
AWarn.Localization:AddDefinition( language_code, "playername",					"Nazwa Gracza" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				"Message do Gracza" )
AWarn.Localization:AddDefinition( language_code, "servermessage",				"Wiadomo Serwerowa" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"Wiadomo do Serwera" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				"Usu Ostrzeenie" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"Menu Dodawania Kary" )
AWarn.Localization:AddDefinition( language_code, "inminutes",					"W minutach" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = Permanentny" )
AWarn.Localization:AddDefinition( language_code, "use%",						"Uyj %s, aby wywietli nazw gracza" )
AWarn.Localization:AddDefinition( language_code, "setdefault",					"Ustaw domylne" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"Pokazywanie Wasnych Ostrzee" )
AWarn.Localization:AddDefinition( language_code, "warnedby",					"Ostrzeony przez" )
AWarn.Localization:AddDefinition( language_code, "warningserver",				"Serwer" )
AWarn.Localization:AddDefinition( language_code, "warningreason",				"Powd" )
AWarn.Localization:AddDefinition( language_code, "warningdate",					"Data" )
AWarn.Localization:AddDefinition( language_code, "nothing",						"NIC" )
AWarn.Localization:AddDefinition( language_code, "submit",						"Zatwierd" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			"Poczeni gracze" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"Wywietlanie Ostrzee dla" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				"Aktywne ostrzeenia" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"Wybrany gracz nie zosta ostrzeony." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		"Wybierz gracza aby zobaczy jego ostrzeenia." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					"Ostrze Gracza" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"Zmniejsz liczb aktywnych ostrzee o 1" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"Menu Ostrzee Gracza" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"Menu Wyszukiwania Gracza" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				"Ostrzeganie Gracza" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"Wyklucz graczy, ktrzy nie maj adnego ostrzeenia" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"Szukaj gracza za pomoc nazwy lub SteamID64" )
AWarn.Localization:AddDefinition( language_code, "name",						"Nazwa" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					"Widziany Ostatnio" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					"Ostatnio Ostrzeony" )
AWarn.Localization:AddDefinition( language_code, "never",						"Nigdy" )
AWarn.Localization:AddDefinition( language_code, "playerid",					"ID Gracza" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"Spjrz na ostrzeenia tego gracza." )
AWarn.Localization:AddDefinition( language_code, "servername",					"Nazwa Serwera" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"Wywietlaj liczb ostrzee dla gracza przy doczaniu" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"Wywietlaj wiadomo dla administratorw, gdy gracz docza z ostrzeeniami" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"Kary" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"Jeli jest wczony, AWarn3 moe wyrzuca graczy z serwera jako kar." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"Jeli jest wczony, AWarn3 moe za kar zbanowa graczy z serwera." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"Jeli ta opcja jest wczona, aktywne ostrzeenia bd z czasem zanika." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"Jeli ta opcja jest wczona, administratorzy bd musieli poda powd w swoim ostrzeeniu." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"Jeli ta opcja jest wczona, aktywne ostrzeenia uytkownikw zostan zresetowane do 0 po zbanowaniu ich przez AWarn3." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"Rejestruj zdarzenia ostrzegawcze." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"Jeli ta opcja jest wczona, dziaania w AWarn3 bd rejestrowane w pliku tekstowym." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"Jeli ta opcja jest wczona, administratorzy bd mogli ostrzega innych administratorw." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","Jeli ta opcja jest wczona, uytkownicy, ktrzy docz do serwera, zobacz wiadomo na czacie, jeli otrzymaj ostrzeenia." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"Jeli ta opcja jest wczona, administratorzy na serwerze zobacz, kiedy doczy dowolny gracz, ktry ma ostrzeenia." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"Polecenie chat uywane w poleceniach AWarn3. Domylnie: !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"Czas (w minutach), przez ktry gracz musi by poczony, aby 1 aktywne ostrzeenie zaniko." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"Nazwa tego serwera. Jest to przydatne w przypadku konfiguracji z wieloma serwerami." )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"To jest jzyk, w ktrym bd wywietlane komunikaty serwera." )
AWarn.Localization:AddDefinition( language_code, "theme",						"Motyw interfejsu" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"Wybierz motyw" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"Grupa karania" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"Grupuj do ustawienia" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"Wywietl notatki gracza" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"Notatki gracza" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"Dostosowywanie interfejsu" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"Wcz rozmycie ta" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"Wybierz ustawienie (opcjonalnie)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"Presety" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"Dodaj/edytuj ustawienie wstpne" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"Zaprogramowana nazwa" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"Wstpnie ustawiony powd" )
--PATH lua/autorun/cgi_cis_droids.lua:
local NPC = {
	Name = "B1 Battle Droid",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid", NPC )

local NPC = {
	Name = "B1 Battle Droid (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_friendly", NPC )

local NPC = {
	Name = "B1 Battle Droid (RC) (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_rc.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_rc_friendly", NPC )

local NPC = {
	Name = "B1 Battle Droid (RC) (Hostile)",
	Class = "npc_combine",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_rc.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_rc_hostile", NPC )

local NPC = {
	Name = "B1 Battle Droid (Pilot)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_pilot.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_pilot", NPC )

local NPC = {
	Name = "B1 Battle Droid (Security)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_security.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_security", NPC )

local NPC = {
	Name = "B1 Battle Droid (Heavy)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_heavy.mdl",
	Health = "175",
	Weapons = { "gg_swnpc_e5c" },
}
list.Set( "NPC", "cgi_b1_droid_heavy", NPC )

local NPC = {
	Name = "B1 Battle Droid (Marine)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_security.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_rps" },
}
list.Set( "NPC", "cgi_b1_droid_marine", NPC )

local NPC = {
	Name = "B1 Battle Droid (AAT)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_aat.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_AAT", NPC )

local NPC = {
	Name = "B1 Battle Droid (Geonosis)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_geonosis.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_geo", NPC )

local NPC = {
	Name = "B1 Battle Droid (Point Rain Geonosis)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_pointrain.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_geo_pointrain", NPC )

local NPC = {
	Name = "B1 Battle Droid (Rocket)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_rocket.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_rocket", NPC )

local NPC = {
	Name = "B1 Battle Droid (Snow)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_snow.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_snow", NPC )

local NPC = {
	Name = "B1 Battle Droid (Training)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_training.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_training", NPC )

local NPC = {
	Name = "B1 Battle Droid (OOM-10)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_oom10.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_oom10", NPC )

local NPC = {
	Name = "B1 Battle Droid (OOM-10) Friendly",
	Class = "npc_citizen",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_oom10.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_oom10friendly", NPC )

local NPC = {
	Name = "B1 Battle Droid Commander",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b1_battledroid_commander.mdl",
	Health = "125",
	Weapons = { "gg_swnpc_e5" },
}
list.Set( "NPC", "cgi_b1_droid_commander", NPC )

local NPC = {
	Name = "B2 Super Battle Droid",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b2_battledroid.mdl",
	Health = "575",
	Weapons = { "gg_swnpc_b2hand" },
}
list.Set( "NPC", "cgi_b2_droid", NPC )

local NPC = {
	Name = "B2 Super Battle Droid Friendly",
	Class = "npc_citizen",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b2_battledroid.mdl",
	Health = "575",
	Weapons = { "gg_swnpc_b2hand" },
}
list.Set( "NPC", "cgi_b2_droidfriendly", NPC )

local NPC = {
	Name = "B2 Super Battle Droid (Cannon)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b2_battledroid_cannon.mdl",
	Health = "575",
	Weapons = { "gg_swnpc_b2rocket" },
}
list.Set( "NPC", "cgi_b2_droid_cannon", NPC )

local NPC = {
	Name = "B2 Super Battle Droid (Training)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b2_battledroid_training.mdl",
	Health = "575",
	Weapons = { "gg_swnpc_b2hand" },
}
list.Set( "NPC", "cgi_b2_droid_training", NPC )

local NPC = {
	Name = "B2 Super Battle Droid (Snow)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b2_battledroid_snow.mdl",
	Health = "575",
	Weapons = { "gg_swnpc_b2hand" },
}
list.Set( "NPC", "cgi_b2_droid_snow", NPC )

local NPC = {
	Name = "B2 Super Battle Droid (Camo)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b2_battledroid_camo.mdl",
	Health = "575",
	Weapons = { "gg_swnpc_b2hand" },
}
list.Set( "NPC", "cgi_b2_droid_camo", NPC )

local NPC = {
	Name = "B2 Super Battle Droid (Snow)",
	Class = "npc_combine_s",
	Category = "CGI Battle Droid NPCs",
	Model = "models/aussiwozzi/cgi/b1droids/b2_battledroid_snow.mdl",
	Health = "575",
	Weapons = { "gg_swnpc_b2hand" },
}
list.Set( "NPC", "cgi_b2_droid_snow", NPC )
--PATH lua/autorun/civ_pm_male.lua:
player_manager.AddValidModel( "Civilian Resident Male", "models/resident/pm_civ_resident_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Resident Male", "models/resident/pm_civ_resident_human_male.mdl" );
player_manager.AddValidModel( "Civilian Dweller Male", "models/dweller/pm_civ_dweller_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Dweller Male", "models/dweller/pm_civ_dweller_human_male.mdl" );
player_manager.AddValidModel( "Civilian Formal Male", "models/formal/pm_civ_formal_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Formal Male", "models/formal/pm_civ_formal_human_male.mdl" );
player_manager.AddValidModel( "Civilian Noble Male", "models/noble/pm_civ_noble_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Noble Male", "models/noble/pm_civ_noble_human_male.mdl" );
player_manager.AddValidModel( "Civilian Smuggler Male", "models/smuggler/pm_civ_smuggler_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Smuggler Male", "models/smuggler/pm_civ_smuggler_human_male.mdl" );


player_manager.AddValidModel( "Civilian Merc Male", "models/merc/pm_civ_merc_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Merc Male", "models/merc/pm_civ_merc_human_male.mdl" );
player_manager.AddValidModel( "Civilian Guard Male", "models/guard/pm_civ_guard_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Guard Male", "models/guard/pm_civ_guard_human_male.mdl" );
player_manager.AddValidModel( "Civilian Assassin Male", "models/assassin/pm_civ_assassin_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Assassin Male", "models/assassin/pm_civ_assassin_human_male.mdl" );
player_manager.AddValidModel( "Civilian Renegade Male", "models/renegade/pm_civ_renegade_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Renegade Male", "models/renegade/pm_civ_renegade_human_male.mdl" );
player_manager.AddValidModel( "Civilian Bandit Male", "models/bandit/pm_civ_bandit_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Bandit Male", "models/bandit/pm_civ_bandit_human_male.mdl" );

player_manager.AddValidModel( "Civilian Gundark Male", "models/gundark/pm_civ_gundark_costume_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Gundark Male", "models/gundark/pm_civ_gundark_costume_male.mdl" );
player_manager.AddValidModel( "Civilian Wampa Male", "models/wampa/pm_civ_wampa_costume_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Wampa Male", "models/wampa/pm_civ_wampa_costume_male.mdl" );
player_manager.AddValidModel( "Civilian Stalker Male", "models/stalker/pm_civ_stalker_costume_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Stalker Male", "models/stalker/pm_civ_stalker_costume_male.mdl" );

player_manager.AddValidModel( "Civilian Festive Male", "models/festive/pm_civ_festive_human_male.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Festive Male", "models/festive/pm_civ_festive_human_male.mdl" ); 


--PATH lua/autorun/coolhitmarker.lua:
CoolHitmarkersInstalled = true
-- if engine.ActiveGamemode() != "sandbox" then return end
local longrangeshot = 3937 * 0.5 -- 50m

local flags = {FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_REPLICATED}

local hmoverride = CreateConVar("profiteers_override_enabled", "0", flags, "Override Profiteers UI settings.", 0, 1)
local hmsv = CreateConVar("profiteers_override_hitmarker_enable", "1", flags, "Override Profiteers Hitmarker. 0 disabled, 1 audiovisual, 2 visual only, 3 audio only.", 0, 3)
local hmpossv = CreateConVar("profiteers_override_hitmarker_dynamic", "1", flags, "Override dynamic ''real'' position for hit markers.", 0, 1)
local hmscalesv = CreateConVar("profiteers_override_hitmarker_scale", "1", flags, "Override Longshot indicators. 1 for all hits, 2 for kills only.", 0.25, 2.5)
local indicatorssv = CreateConVar("profiteers_override_dmgindicator_enable", "1", flags, "Override Profiteers Damage indicators.", 0, 1)
local indicatorscalesv = CreateConVar("profiteers_override_dmgindicator_scale", "1", flags, "Override custom scaling for Profiteers damage indicators.", 0.25, 2.5)
local distantshotsv = CreateConVar("profiteers_override_hitmarker_longshot", "1", flags, "Override Longshot indicators. 1 for all hits, 2 for kills only.", 0, 2)
local hmarmorsv = CreateConVar("profiteers_override_hitmarker_armor", "1", flags, "Override armor hit indicators.", 0, 1)
local hmheadsv = CreateConVar("profiteers_override_hitmarker_head", "1", flags, "Override headshot indicators.", 0, 1)
local hmkillsv = CreateConVar("profiteers_override_hitmarker_kill", "1", flags, "Override kill indicators.", 0, 1)
local hmfiresv = CreateConVar("profiteers_override_hitmarker_fire", "1", flags, "Override afterburn indicators.", 0, 1)
local hmpropsv = CreateConVar("profiteers_override_hitmarker_prop", "1", flags, "Override prop (and other breakable entity) hit indicators.", 0, 1)
local skullssv = CreateConVar("profiteers_override_skulls", "1", flags, "Override Show how many enemys youve killed. very cruel.", 0, 1)

local ammotable = { -- plese nothing bigger than 2 digits :) uint bitch
    ["buckshot"] = 0.3,
    ["pistol"] = 0.5,
    ["smg1"] = 0.7,
    ["sniperpenetratedround"] = 1.5,
    ["sniperround"] = 1.5,
    ["xbowbolt"] = 1.5,

    ["default"] = 1,
    -- 357 used often for sniper rifles, not only pistols, so keeping it on 1
    -- ar2 is default basically so 1 too
}

if SERVER then
    util.AddNetworkString("profiteers_hitmark")
    util.AddNetworkString("profiteers_gothit")

    local npcheadshotted = false -- fuck you garry

    local function hitmark(ent, dmginfo, took)
        local attacker, inflictor = dmginfo:GetAttacker(), dmginfo:GetInflictor()
        if attacker:IsVehicle() and IsValid(attacker:GetDriver()) then attacker = attacker:GetDriver() end
        local attply, vicply = attacker:IsPlayer(), ent:IsPlayer()
        if (!attply and !vicply) then return end
        if inflictor == ent or attacker == ent then return end
        local vichp = ent:Health()
        local ct = CurTime()
        if ent.phm_lastHealth and ent.phm_lastHealth == vichp and (!took and (vichp <= 0 or attacker.phm_lastMarker and attacker.phm_lastMarker > ct) or dmginfo:GetDamage() == 0 or took) then return end
        local vicnpc = ent:IsNextBot() or ent:IsNPC()

        if IsValid(ent) and IsValid(attacker) and attply then
            attacker.phm_lastMarker = ct + 0.5 -- stop fucking shooting shit you cant hurt
            local distance = ent:GetPos():Distance(attacker:GetPos())
            local dmgpos = (inflictor:IsWeapon() or inflictor:IsPlayer()) and dmginfo:GetDamagePosition() or ent:WorldSpaceCenter()
            local swep = attacker:GetActiveWeapon()
            local ammo = swep:IsValid() and swep:IsScripted() and string.lower(swep.Primary.Ammo or "default") or "default"
            local armor = ent.Armor and (tonumber(ent.Armor) or (isnumber(ent:Armor()) and ent:Armor()))
            local armored = armor and ent.phm_lastArmor
            local dmg = math.Clamp(math.ceil(ent.phm_lastHealth and ent.phm_lastHealth - vichp or dmginfo:GetDamage() * 0.025), 0, 3)
            local dmgtype = dmginfo:GetDamageType()
            local sentient = vicply or vicnpc
            local hitdata = 0
            local killtype = 0
            if sentient then hitdata = hitdata + 1 end
            if (sentient and vichp <= 0) or (ent:GetNWInt("PFPropHealth", 1) <= 0) then
                hitdata = hitdata + 2
                if inflictor == attacker and dmginfo:GetDamageCustom() == 67 then killtype = 1
                elseif inflictor:IsWeapon() and bit.band(dmgtype, bit.bor(DMG_CLUB, DMG_SLASH)) != 0 then killtype = 2
                elseif bit.band(dmgtype, DMG_BLAST) != 0 then killtype = 3
                elseif inflictor:IsVehicle() and bit.band(dmgtype, bit.bor(DMG_VEHICLE, DMG_CRUSH)) != 0 then killtype = 4
                elseif bit.band(dmgtype, DMG_DISSOLVE) != 0 then killtype = 5
                elseif bit.band(dmgtype, DMG_CRUSH) != 0 then killtype = 6
                elseif bit.band(dmgtype, DMG_BURN+DMG_DIRECT) != 0 then killtype = 7
                end
            end
            if (ent.LastHitGroup and ent:LastHitGroup() == HITGROUP_HEAD or npcheadshotted) then
                hitdata = hitdata + 4
                if ent.SetLastHitGroup then ent:SetLastHitGroup(HITGROUP_GENERIC) end
            end
            if bit.band(dmgtype, DMG_BURN+DMG_DIRECT) != 0 then hitdata = hitdata + 8 end

            if !ammotable[ammo] then ammo = "default" end

            if ammotable[ammo] == 0.3 then -- its shotgun, checking for slugs
                if (swep.ARC9 and swep:GetValue("Num") or swep.GripPoseParameters and swep.Bullet.NumBullets or swep.ArcCW and (swep:GetBuff_Override("Override_Num") or swep.Num) or swep.Primary.Num or 6) < 3 then
                    ammo = "smg1" -- setting range mult to 0.7
                end
            end

            -- if you making some gamemode you can add here check for distance and give more points/moneys for long kills
            net.Start("profiteers_hitmark")
            net.WriteUInt(dmg or 0, 2) -- Damage
            net.WriteUInt(hitdata, 5) -- All the necessary data
            net.WriteUInt(killtype, 3) -- Type of kill damage
            -- net.WriteBool(sentient) -- Sentient (Player or npc) or prop
            -- net.WriteBool(ent.LastHitGroup and ent:LastHitGroup() == HITGROUP_HEAD or npcheadshotted or false) -- Headshot
            -- net.WriteBool(bit.band(dmgtype, DMG_BURN+DMG_DIRECT) == DMG_BURN+DMG_DIRECT or false) -- Burned, done on client
            -- net.WriteBool((sentient and vichp <= 0) or (ent:GetNWInt("PFPropHealth", 1) <= 0) or false) -- Was killed
            -- net.WriteBool(dmginfo:GetInflictor() == attacker and dmginfo:GetDamageCustom() == 67)
            net.WriteNormal(dmgpos != vector_origin and attacker:VisibleVec(dmgpos) and (dmgpos-attacker:EyePos()):GetNormalized() or vector_origin) -- Hit position
            net.WriteUInt(armored and (armor > 0 and 1 or 0) + ((ent.phm_lastArmor or 0) > 0 and 2 or 0) or 0, 2) -- Armor and break
            net.WriteUInt(distance, 16) -- Distance to hit
            net.WriteUInt(ammotable[ammo]*10, 6) -- Ammo type in gun
            -- net.WriteUInt( ((dmgtype == DMG_CLUB or dmgtype == DMG_SLASH) and 1) or (dmgtype == DMG_BLAST and 2) or 0, 2) -- Melee or explosion or other dmg type (for skulls), done on client
            net.Send(attacker)
            npcheadshotted = false
        end

        if took and IsValid(ent) and IsValid(attacker) and vicply and !ent:IsBot() then -- hit indicators
            net.Start("profiteers_gothit")
            net.WriteEntity(inflictor)
            net.WriteUInt((vicply and (ent:Armor() > 0 and 1 or 0) + ((ent.phm_lastArmor or 0) > 0 and 2 or 0)) or 0, 2)
            net.Send(ent)
        end
    end

    -- fuck you garry
    hook.Add("ScaleNPCDamage", "profiteers_hitmarkers_npcheadshots", function(ent, hitgroup, dmginfo)
        npcheadshotted = IsValid(ent) and IsValid(dmginfo:GetAttacker()) and dmginfo:GetAttacker():IsPlayer() and hitgroup == HITGROUP_HEAD
    end)

    hook.Add("EntityTakeDamage", "profiteers_hitmarkers", function(target, dmginfo)

        -- largely copied idea from hit numbers
        if !target:IsValid() or dmginfo:GetDamage() <= 0 then return end
        if dmginfo:GetAttacker():IsPlayer() and dmginfo:IsDamageType(DMG_BURN+DMG_SLOWBURN) then target.phm_lastAttacker = dmginfo:GetAttacker() end
        if target.phm_lastAttacker and dmginfo:IsDamageType(DMG_BURN+DMG_SLOWBURN) then
            dmginfo:SetAttacker(target.phm_lastAttacker)
        end
        if target.Armor then
            local armor = tonumber(target.Armor) or (isnumber(target:Armor()) and target:Armor())
            target.phm_lastArmor = armor or 0
        end
        target.phm_lastHealth = target:Health() or 0
    end)

    hook.Add("PostEntityTakeDamage", "profiteers_hitmarkers", hitmark)
else
    local hm = CreateClientConVar("profiteers_hitmarker_enable", "1", true, true, "Enable Profiteers Hitmarker. 0 disabled, 1 audiovisual, 2 visual only, 3 audio only.", 0, 3)
    local hmpos = CreateClientConVar("profiteers_hitmarker_dynamic", "1", true, true, "Use dynamic ''real'' position for hit markers.", 0, 1)
    local hmscale = CreateClientConVar("profiteers_hitmarker_scale", "1", true, true, "Show Longshot indicators. 1 for all hits, 2 for kills only.", 0.25, 2.5)
    local indicators = CreateClientConVar("profiteers_dmgindicator_enable", "1", true, true, "Enable Profiteers Damage indicators.", 0, 1)
    local indicatorscale = CreateClientConVar("profiteers_dmgindicator_scale", "1", true, true, "Custom scaling for Profiteers damage indicators.", 0.25, 2.5)
    local distantshot = CreateClientConVar("profiteers_hitmarker_longshot", "1", true, true, "Show Longshot indicators. 1 for all hits, 2 for kills only.", 0, 2)
    local hmarmor = CreateClientConVar("profiteers_hitmarker_armor", "1", true, true, "Show armor hit indicators.", 0, 1)
    local hmhead = CreateClientConVar("profiteers_hitmarker_head", "1", true, true, "Show headshot indicators.", 0, 1)
    local hmkill = CreateClientConVar("profiteers_hitmarker_kill", "1", true, true, "Show kill indicators.", 0, 1)
    local hmfire = CreateClientConVar("profiteers_hitmarker_fire", "1", true, true, "Show afterburn indicators.", 0, 1)
    local hmprop = CreateClientConVar("profiteers_hitmarker_prop", "1", true, true, "Show prop (and other breakable entity) hit indicators.", 0, 1)
    local skulls = CreateClientConVar("profiteers_skulls", "1", true, true, "Show how many enemys youve killed. very cruel.", 0, 1)
    local hmlength = 0.22 -- 0.5 if kill
    local hmrotata = 0
    local hmauth = 0
    local lasthm = 0
    local lasthurt = false
    local lastdistantshot = 0
    local lasthmpos = Vector()
    local lasthmtbl = {x = ScrW() * 0.5, y = ScrH() * 0.5, visible = false}
    local lasthmarmor = 0
    local lasthmhead = false
    local lasthmkill = false
    local lasthmprop = false
    local lasthmfire = false
    local hmmat = Material("profiteers/hitmark.png", "noclamp smooth")
    local hmmat2 = Material("profiteers/headmark.png", "noclamp smooth")
    local hmmat3 = Material("profiteers/hitprop.png", "noclamp smooth")
    local hmmat4 = Material("profiteers/hitmarkdestroyarmor.png", "noclamp smooth")
    local matgear = Material("profiteers/hitgear.png", "noclamp smooth")
    local matfire = Material("profiteers/hitfire.png", "noclamp smooth")
    local matarmor = Material("profiteers/kevlar.png", "noclamp smooth")
    local matarmorb = Material("profiteers/kevlarbroken.png", "noclamp smooth")
    local matarmor2 = Material("profiteers/kevlar2.png", "noclamp smooth")
    local matarmorb2 = Material("profiteers/kevlar2broken.png", "noclamp smooth")

    local hitindicators = {}
    local matgothit = Material("profiteers/hiteffect.png", "noclamp smooth")
    local matarmorhit = Material("profiteers/hiteffectarmor.png", "noclamp smooth")
    local matarmorbreak = Material("profiteers/hiteffectarmorbroken.png", "noclamp smooth")
    
    hook.Add("PopulateToolMenu", "profiteers_hitmark_options", function()
        spawnmenu.AddToolMenuOption("Utilities", "Cool Combat", "profiteers_hitmarker", "Hitmarkers", "", "", function(pan)
            pan:SetName("Cool Hitmarkers")
            local cl, sv = vgui.Create("DForm"), vgui.Create("DForm")
            pan:AddItem(cl)
            pan:AddItem(sv)
            cl:SetName("Client")
            sv:SetName("Server Overrides")
            cl:ControlHelp("\nHitmarkers")
            local mode = cl:ComboBox("Hitmarker mode", "profiteers_hitmarker_enable")
            mode:SetSortItems(false)
            mode:AddChoice("Disabled", 0)
            mode:AddChoice("Full hitmarkers", 1)
            mode:AddChoice("Visuals only", 2)
            mode:AddChoice("Sound only", 3)
            cl:NumSlider("Hitmarker scale", "profiteers_hitmarker_scale", 0.25, 2.5, 3)
            cl:CheckBox("Use dynamic position for hit markers", "profiteers_hitmarker_dynamic")
            local long = cl:ComboBox("Longshot indicators", "profiteers_hitmarker_longshot")
            long:SetSortItems(false)
            long:AddChoice("Disabled", 0)
            long:AddChoice("Every hit", 1)
            long:AddChoice("Kills only", 2)
            cl:CheckBox("Show armor hit indicators", "profiteers_hitmarker_armor")
            cl:CheckBox("Show headshot indicators", "profiteers_hitmarker_head")
            cl:CheckBox("Show kill indicators", "profiteers_hitmarker_kill")
            cl:CheckBox("Show afterburn indicators", "profiteers_hitmarker_fire")
            cl:CheckBox("Show breakable entity hit indicators", "profiteers_hitmarker_prop")
            cl:ControlHelp("\nDamage indicators")
            cl:CheckBox("Show directional damage indicators", "profiteers_dmgindicator_enable")
            cl:NumSlider("Damage indicator scale", "profiteers_dmgindicator_scale", 0.25, 2.5, 3)
            cl:Help("It's those arrows pointing toward where you were shot from.")

            if !CoolKillchainsInstalled then
                pan:ControlHelp("\nBest used with:")
                local btn = pan:Button("Cool Killchains <3")
                btn.DoClick = function()
                    gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=3193486764") -- uhh please edit link to the killchains page later
                end
            end

            sv:CheckBox("Enforce server hitmarker settings for all players", "profiteers_override_enabled")
            sv:ControlHelp("\nHitmarkers")
            local mode = sv:ComboBox("Hitmarker mode", "profiteers_override_hitmarker_enable")
            mode:SetSortItems(false)
            mode:AddChoice("Disabled", 0)
            mode:AddChoice("Full hitmarkers", 1)
            mode:AddChoice("Visuals only", 2)
            mode:AddChoice("Sound only", 3)
            sv:NumSlider("Hitmarker scale", "profiteers_override_hitmarker_scale", 0.25, 2.5, 3)
            sv:CheckBox("Use dynamic position for hit markers", "profiteers_override_hitmarker_dynamic")
            local long = sv:ComboBox("Longshot indicators", "profiteers_override_hitmarker_longshot")
            long:SetSortItems(false)
            long:AddChoice("Disabled", 0)
            long:AddChoice("Every hit", 1)
            long:AddChoice("Kills only", 2)
            sv:CheckBox("Show armor hit indicators", "profiteers_override_hitmarker_armor")
            sv:CheckBox("Show headshot indicators", "profiteers_override_hitmarker_head")
            sv:CheckBox("Show kill indicators", "profiteers_override_hitmarker_kill")
            sv:CheckBox("Show afterburn indicators", "profiteers_override_hitmarker_fire")
            sv:CheckBox("Show breakable entity hit indicators", "profiteers_override_hitmarker_prop")
            sv:ControlHelp("\nDamage indicators")
            sv:CheckBox("Show directional damage indicators", "profiteers_override_dmgindicator_enable")
            sv:NumSlider("Damage indicator scale", "profiteers_override_dmgindicator_scale", 0.25, 2.5, 3)
            sv:Help("It's those arrows pointing toward where you were shot from.")
        end)
    end)

    -- hush
    local function DoSize(size, scale) -- scale is 2 bit operator, first bit dimension, second indicator or hitmarker
        scale = scale or 0
        local iscale, hscale = (hmauth and indicatorscalesv or indicatorscale), (hmauth and hmscalesv or hmscale)
        return size * (bit.band(scale, 1) == 1 and (ScrH() / 480) or (ScrW() / 640)) * (bit.band(scale, 2) == 2 and iscale:GetFloat() or hscale:GetFloat())
    end
    
    hook.Add("HUDPaint", "profiteers_hitmark_paint", function()
        local modee = (hmauth and hmsv:GetInt() or hm:GetInt())
        local novisual = modee == 0 or modee == 3

        if novisual then return end

        local lp = LocalPlayer()
        local ct = CurTime()
        local scrw, scrh = ScrW(), ScrH()
        local alpha = lasthurt and 255 or 119
        local x, y = 0 < lasthmtbl.x and lasthmtbl.x < scrw and lasthmtbl.x or scrw * 0.5, 0 < lasthmtbl.y and lasthmtbl.y < scrh and lasthmtbl.y or scrh * 0.5
        local dist, ind = (hmauth and distantshotsv or distantshot), (hmauth and indicatorssv or indicators)

        if !novisual then
            if lasthm > ct then -- any hitmarkers
                local state = (lasthm - ct) / hmlength
                -- hmrotata = math.max(0, hmrotata - FrameTime()*300)
                hmrotata = Lerp(FrameTime()*25, hmrotata, 0)
                local armor = (hmauth and hmarmorsv or hmarmor)
                local fire = (hmauth and hmfiresv or hmfire)
                local kill = (hmauth and hmkillsv or hmkill)
                local head = (hmauth and hmheadsv or hmhead)

                if lasthmprop or fire:GetBool() and lasthmfire or !lasthurt then
                    surface.SetMaterial(hmmat3)
                elseif armor:GetBool() and lasthmarmor == 2 then
                    surface.SetMaterial(hmmat4)
                else
                    surface.SetMaterial(head:GetBool() and lasthmhead and hmmat2 or hmmat)
                end
                
                if kill:GetBool() and lasthmkill then
                    surface.SetDrawColor(255, 0, 0, alpha * state)
                elseif armor:GetBool() and lasthmarmor > 0 then
                    surface.SetDrawColor(119, 119, 255, alpha * state)
                else
                    surface.SetDrawColor(255, 255, 255, alpha * state)
                end

                -- surface.DrawTexturedRect(x - DoSize(6) - DoSize(8) * state, y - DoSize(6) - DoSize(8) * state, DoSize(12) + DoSize(16) * state, DoSize(12) + DoSize(16) * state)
                surface.DrawTexturedRectRotated(x, y, DoSize(12) + DoSize(16) * state, DoSize(12) + DoSize(16) * state, hmrotata)

                if armor:GetBool() and lasthmarmor > 0 then
                    surface.SetDrawColor(119, 119, 255, alpha * state)
                    if lasthmarmor == 3 then -- armor damage
                        surface.SetMaterial(matarmor)
                    else
                        surface.SetMaterial(matarmorb)
                    end
                    surface.DrawTexturedRect(x + DoSize(16), y - DoSize(12), DoSize(8), DoSize(8))
                end
                if lasthmprop then -- prop damage
                    surface.SetDrawColor(255, 255, 255, alpha * state)
                    surface.SetMaterial(matgear)
                    surface.DrawTexturedRect(x + DoSize(16), y + DoSize(4), DoSize(8), DoSize(8))
                end
                if fire:GetBool() and lasthmfire then -- afterburn damage
                    surface.SetDrawColor(255, 255, 255, alpha * state)
                    surface.SetMaterial(matfire)
                    surface.DrawTexturedRect(x - DoSize(4), y + DoSize(16), DoSize(8), DoSize(8))
                end
            end

            if (lasthmkill and dist:GetInt() == 2 or dist:GetInt() == 1) and lastdistantshot > ct then -- long range hits
                local state = (lastdistantshot - ct) * 2
                local message = (lasthmkill and lasthmhead) and "Long range HEADSHOT!!" or lasthmkill and "Long range kill!" or "Long range hit"
                -- surface.SetFont("CGHUD_7_Shadow")
                surface.SetFont(ARC9 and "ARC9_8_Glow" or "GModNotify")
                surface.SetTextColor(0, 0, 0, 255 * state)
                surface.SetTextPos(scrw * 0.5 + DoSize(25) + 1, scrh * 0.5 + 1)
                surface.DrawText(message)
                surface.SetTextPos(scrw * 0.5 + DoSize(25) + 1, scrh * 0.5 + 20 + 1)
                surface.DrawText(lasthmdistance .. " m")
                -- surface.SetFont("CGHUD_7")
                surface.SetFont(ARC9 and "ARC9_8" or "GModNotify")
                surface.SetTextColor(255, lasthmkill and 75 or 255, lasthmkill and 75 or 255, 255 * state)
                surface.SetTextPos(scrw * 0.5 + DoSize(25), scrh * 0.5)
                surface.DrawText(message)
                surface.SetTextColor(300 - 255 * (lasthmdistance / 400), 300 - 255 * (lasthmdistance / 400), 255, 255 * state)
                surface.SetTextPos(scrw * 0.5 + DoSize(25), scrh * 0.5 + 20)
                surface.DrawText(lasthmdistance .. " m")
            end

            if ind:GetBool() then
                for k, v in ipairs(hitindicators) do -- hit indicators
                    local decay = math.max(0, (v.time - ct)) * 30

                    if decay <= 0 then
                        table.remove(hitindicators, k) -- removing old stains
                    end

                    local hitVec = v.hitvec
                    local armorBreak = v.armor
                    local ang = math.atan2(hitVec.x, hitVec.y) + math.rad(lp:EyeAngles().y) + 3.14
                    local x, y = scrw * 0.5 + math.cos(ang) * DoSize(60, 3), scrh * 0.5 + math.sin(ang) * DoSize(60, 3)

                    if armorBreak > 0 then
                        surface.SetDrawColor(119, 119, 255, decay)
                        if armorBreak == 2 then
                            surface.SetMaterial(matarmorbreak)
                        else
                            surface.SetMaterial(matarmorhit)
                        end
                    else
                        surface.SetDrawColor(255, 255, 255, decay)
                        surface.SetMaterial(matgothit)
                    end
                    surface.DrawTexturedRectRotated(x, y, DoSize(34, 3), DoSize(34, 3), math.deg(-ang) - 90)
                end
            end
        end
    end)

    
    local function hitmarker(...)
        local sv = hmoverride:GetBool()
        local mode = sv and hmsv:GetInt() or hm:GetInt()
        if mode <= 0 and !(sv and skullssv:GetBool() or skulls:GetBool()) then return end
        local dmg = net.ReadUInt(2)
        local hitdata = net.ReadUInt(5)
        local killtype = net.ReadUInt(3)
        local isliving = bit.band(hitdata, 1) != 0
        local killed = bit.band(hitdata, 2) != 0
        local head = bit.band(hitdata, 4) != 0
        local onfire = bit.band(hitdata, 8) != 0
        local pos = net.ReadNormal()
        local armored = net.ReadUInt(2)
        local distance = net.ReadUInt(16)
        local longrangemult = net.ReadUInt(6) * 0.1
        if dmg <= 0 and !isliving then return end
        local lp = LocalPlayer()
        local ct = CurTime()

        if CoolKillchainsInstalled then
            if killed and (sv and skullssv or skulls):GetBool() then -- here cuz that line below
                CoolKillchainFunction(head, killtype, sv)
            end
        end


        if lasthm > ct and lasthmkill then return end
        hmauth = sv
        lasthurt = dmg > 0
        lasthmhead = head
        lasthmfire = onfire
        lasthmkill = killed
        lasthmpos = pos

        hmrotata = math.random(-12, 12)

        lasthmtbl = {x = ScrW() * 0.5, y = ScrH() * 0.5, visible = false }

        if (sv and hmpossv or hmpos):GetBool() and lasthmpos != vector_origin then
            pos = lp:EyePos()-lp:GetAimVector()+pos*distance

            cam.Start3D()

            local toscr = pos:ToScreen()
            if toscr.visible then
                lasthmtbl = pos:ToScreen()
            end

            cam.End3D()
        end

        lasthmarmor = armored
        lasthmprop = !isliving
        hmlength = (armored == 2 or killed) and 0.5 or 0.22

        if isliving then
            if !onfire and distance > longrangeshot * longrangemult and lasthurt then
                lasthmdistance = math.Round(distance * 0.0254, 1)
                lastdistantshot = ct + 3
            end
        elseif !(sv and hmpropsv or hmprop):GetBool() then return end

        lasthm = ct + hmlength

        if mode == 0 or mode == 2 then return end

        if armored == 2 then -- seperate armor break sond without delay
            surface.PlaySound("profiteers/breakarmorr.ogg")
        end

        timer.Simple(0.06, function()
            if !lp then return end -- just to be sure
            if !lasthurt then surface.PlaySound("profiteers/hitmarkfail.ogg") return end
            -- juicer when many dmg
            for i = 1, math.Clamp(dmg, 1, 2) do
                if !onfire and head then
                    surface.PlaySound("profiteers/headmarker.ogg")
                elseif armored == 3 then
                    surface.PlaySound("player/kevlar" .. math.random(5) .. ".wav")
                else
                    surface.PlaySound("profiteers/mwhitmarker.ogg")
                end

            end
            if killed then
                timer.Simple(0.03, function()
                    if !IsValid(lp) then return end -- just to be sure
                    surface.PlaySound("profiteers/newkillmarker.ogg")
                end)
            end
        end)

    end

    net.Receive("profiteers_hitmark", hitmarker)

    local function addgothit(attacker, armor)
        local lp = LocalPlayer()
        if !attacker:IsValid() then return end
        -- local scrw, scrh = ScrW(), ScrH()

        local hitVec =  attacker:GetPos() - lp:GetPos()

        if armor == 2 then
            surface.PlaySound("profiteers/breakarmorself.ogg")
        end

        table.insert(hitindicators, {
            time = CurTime() + 3,
            hitvec = hitVec,
            armor = armor
        })
    end

    net.Receive("profiteers_gothit", function() addgothit(net.ReadEntity(), net.ReadUInt(2)) end)
end
--PATH addons/[chat] advert/lua/autorun/darkrp-full-classic-advert.lua:
local function init()
	if not DarkRP then
		MsgC(Color(255,0,0), "DarkRP Classic Advert tried to run, but DarkRP wasn't declared!\n")
		return
	end

	DarkRP.removeChatCommand("advert")
	DarkRP.declareChatCommand({
		command = "advert",
		description = "Displays an advertisement to everyone in chat.",
		delay = 1.5
	})
	
	if SERVER then
		DarkRP.defineChatCommand("advert",function(ply,args)
			if args == "" then
				DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("invalid_x", "argument", ""))
				return ""
			end
			local DoSay = function(text)
				if text == "" then
					DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("invalid_x", "argument", ""))
					return
				end
				for k,v in pairs(player.GetAll()) do
					local col = team.GetColor(ply:Team())
					DarkRP.talkToPerson(v, col, "[Comlink] " .. ply:Nick(), Color(255, 255, 0, 255), text, ply)
				end
			end
			hook.Call("playerAdverted", nil, ply, args)
			return args, DoSay
		end, 1.5)
	else
		DarkRP.addChatReceiver("/advert", "advertise", function(ply) return true end)
	end
end

if SERVER then
	if #player.GetAll() > 0 then
		init()
	else
		hook.Add("PlayerInitialSpawn", "dfca-load", init)
	end
else
	hook.Add("InitPostEntity", "dfca-load", init)
end

--PATH lua/autorun/dathomir_pm.lua:
player_manager.AddValidModel( "Nightsister", "models/player/dathomir/pm_nightsister.mdl" );
list.Set( "PlayerOptionsModel",  "Nightsister", "models/player/dathomir/pm_nightsister.mdl" );

player_manager.AddValidModel( "Mother Talzin", "models/player/dathomir/pm_nightsister_mothertalzin.mdl" );
list.Set( "PlayerOptionsModel",  "Mother Talzin", "models/player/dathomir/pm_nightsister_mothertalzin.mdl" );

player_manager.AddValidModel( "Nightsister Ventress", "models/player/dathomir/pm_nightsister_ventress.mdl" );
list.Set( "PlayerOptionsModel",  "Nightsister Ventress", "models/player/dathomir/pm_nightsister_ventress.mdl" );

player_manager.AddValidModel( "Nightsister Undead", "models/player/dathomir/pm_nightsister_undead.mdl" );
list.Set( "PlayerOptionsModel",  "Nightsister Undead", "models/player/dathomir/pm_nightsister_undead.mdl" );

player_manager.AddValidModel( "Old Daka", "models/player/dathomir/pm_nightsister_olddaka.mdl" );
list.Set( "PlayerOptionsModel",  "Old Daka", "models/player/dathomir/pm_nightsister_olddaka.mdl" );

player_manager.AddValidModel( "Nightbrother", "models/player/dathomir/pm_nightbrother.mdl" );
list.Set( "PlayerOptionsModel",  "Nightbrother", "models/player/dathomir/pm_nightbrother.mdl" );

player_manager.AddValidModel( "Nightbrother Brawler", "models/player/dathomir/pm_nightbrother_brawler.mdl" );
list.Set( "PlayerOptionsModel",  "Nightbrother Brawler", "models/player/dathomir/pm_nightbrother_brawler.mdl" );


--PATH addons/[opt] decals/lua/autorun/decals_init.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/decals_config.lua:
return gluapack()()
--PATH addons/!discordintegration/lua/discord/core/util.lua:
Discord.Util = {}

function Discord.Util:GetModuleSuffix()
    local arch = string.sub(jit.arch, 2)
    if arch == '86' then
        arch = '32'
    end

    if system.IsWindows() then
        return 'win' .. arch
    end

    return arch == '32' and 'linux' or ('linux' .. arch)
end

function Discord.Util:LoadModule(name, fail, success)
    local filename = 'gm' .. (SERVER and 'sv' or 'cl') .. '_' .. name .. '_' .. Discord.Util:GetModuleSuffix() .. '.dll'

    if file.Exists('garrysmod/lua/bin/' .. filename, 'BASE_PATH') then
        xpcall(function()
            require(name)
            if success then success() end
        end, fail)
        return
    end

    fail()
end

function Discord.Util:IsPrivateSubnet(ip)
    for _, prefix in ipairs({'0.0.0.0', '127.0.0.1', 'localhost', '192.168.', '10.', '172.16.'}) do
        if string.StartWith(ip, prefix) then return true end
    end

    return false
end

function Discord.Util:GetServerIP()
    local gmodip = game.GetIPAddress()
    if SERVER then
        local ipconvar = GetConVar('ip'):GetString()
        local hostport = GetConVarNumber('hostport')
        if not Discord.Util:IsPrivateSubnet(ipconvar) then
            return ipconvar .. ':' .. hostport
        end

        local hostip = GetConVarNumber('hostip')
        local ip = {}
        ip[1] = bit.rshift(bit.band(hostip, 0xFF000000), 24)
        ip[2] = bit.rshift(bit.band(hostip, 0x00FF0000), 16)
        ip[3] = bit.rshift(bit.band(hostip, 0x0000FF00), 8)
        ip[4] = bit.band(hostip, 0x000000FF)

        local serverip = table.concat(ip, '.')
        if serverip ~= gmodip then
            return gmodip
        end

        return serverip .. ':' .. hostport
    else
        return gmodip
    end
end

function Discord.Util:Format(str, formatters)
    local defFormatters = { -- All of these will change at some point, so declare them here instead
        server_ip = Discord.Util:GetServerIP(),
        join_url = 'steam://connect/' .. Discord.Util:GetServerIP(),
        hostname = GetHostName(),
        map = game.GetMap(),
        gamemode = gmod.GetGamemode().Name,
    }

    for _, val in pairs(formatters and table.Merge(defFormatters, formatters) or defFormatters) do
        str = string.Replace(str, '<' .. _ .. '>', val)
    end
    
    return str
end

function Discord.Util:GetLang(str, formatters)
    return Discord.Util:Format(Discord.Lang and Discord.Lang[str] or 'UNKNOWN_LANG_STRING - ' .. str, formatters)
end

function Discord.Util:Hex2RGB(hex)
    hex = hex:gsub('#', '')
    return Color(tonumber('0x' .. hex:sub(1, 2)) or 0, tonumber('0x' .. hex:sub(3, 4)) or 0, tonumber('0x' .. hex:sub(5, 6)) or 0)
end

if SERVER then
    util.AddNetworkString('Discord_Chat')

    function Discord.Util:PlyChat(ply, msg)
        net.Start('Discord_Chat')
            net.WriteString(msg)
        net.Send(ply)
    end
end

if CLIENT then
    function Discord:Chat(...)
        chat.AddText(Color(114, 137, 255), '[Discord] ', Color(255, 255, 255), ...)
    end

    net.Receive('Discord_Chat', function(len, ply)
        Discord:Chat(net.ReadString())
    end)
end
--PATH addons/!discordintegration/lua/discord/core/api_op.lua:
return gluapack()()
--PATH addons/!discordintegration/lua/discord/modules/relay/sh_module.lua:
local MODULE = {}
MODULE.DisplayName = 'Relay'
MODULE.Dependencies = {
    {'sv', 'classes/message.lua'},
}
MODULE.PostLoad = {
    {'sv', 'screenshot.lua'},
    {'sv', 'commands.lua'},

    {'sv', 'integrations/cac.lua'},
    {'sv', 'integrations/serverguard.lua'},
    {'sv', 'integrations/ulx.lua'},
    {'sv', 'integrations/simplac.lua'},
    {'sv', 'integrations/swiftac.lua'},
    {'sv', 'integrations/modernac.lua'},
    {'sv', 'integrations/bwhitelist.lua'},
    {'sv', 'integrations/sam.lua'},

    {'cl', 'cl_screenshot.lua'},
}

Discord.MODULE = MODULE
--PATH lua/autorun/ds3_tridroid_autorun.lua:
return gluapack()()
--PATH addons/[tfres] frest_levels/lua/autorun/frestloader2.lua:
return gluapack()()
--PATH lua/autorun/gingers_hd_cg_playermodels.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end

AddPlayerModel( "Coruscant Guard Captain Kagi", "models/player/gingers_captain_kagi/gingers_captain_kagi.mdl" )
AddPlayerModel( "Coruscant Guard Airborne",     "models/player/gingers_cg_airborne_2/gingers_cg_airborne_2.mdl" )
AddPlayerModel( "Coruscant Guard ARC Trooper",  "models/player/gingers_cg_arc/gingers_cg_arc.mdl" )
AddPlayerModel( "Coruscant Guard Jek",          "models/player/gingers_cg_jek/gingers_cg_jek.mdl" )
AddPlayerModel( "Coruscant Guard Rys",          "models/player/gingers_cg_rys/gingers_cg_rys.mdl" )
AddPlayerModel( "Coruscant Guard Stone",        "models/player/gingers_cg_stone_2/gingers_cg_stone_2.mdl" )
--PATH addons/[gas] gmodadminsuite-config-master/lua/gmodadminsuite_lua_functions.lua:
--[[

	    __                   ______                 __  _                 
	   / /   __  ______ _   / ____/_  ______  _____/ /_(_)___  ____  _____
	  / /   / / / / __ `/  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
	 / /___/ /_/ / /_/ /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  ) 
	/_____/\__,_/\__,_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/  
	                                                                      

	Welcome to the Lua functions config.
	GmodAdminSuite has been designed to be as customizable as possible.
	In this configuration, you can define custom Lua functions which GmodAdminSuite can use.
	You'll find ways of integrating these Lua functions with GmodAdminSuite modules.

	More information on using GmodAdminSuite Lua functions can be found in module wikis.

]]

GAS.LuaFunctions = {
	["example_function"] = function(ply)
		if (ply:SteamID() == "STEAM_0:1:40314158" or ply:SteamID64() == "76561198112561190") then
			return true -- allow!
		elseif (ply:SteamID() == "STEAM_0:1:7099") then
			return false -- disallow!
		else
			return -- ignore!
		end
	end,
}

-- Do not delete the following line; your config will break.
return true
--PATH lua/gmodadminsuite/modules/commands/lang/chinese.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/commands/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            module_name = "",

            no_permission = "",
            commands = "",
            command = "",
            action = "",
            help = "",
            new_command = "+ ",
            wiki = "",
            run_command = "",
            edit_command = "",
            form_help = "...",
            form_help_tip = "",
            select_action = "...",
            hide_in_chat = "",
            hide_in_chat_tip = "",
            finished = "",
            commands_case_insensitive = "",
            ok = "",
            cannot_create_command = "",
            cancel = "",
            delete_command = "",
            copy_command = "",
            permissions = "",
            permissions_editor = "",
            permissions_tip = "/",
            can_access_command = "",
            teams = "",
            usergroups = "",
            anyone_can_access = "",
            whitelisted_only = "",
            non_blacklisted_only = "",
            whitelisted_and_blacklisted = "",
            custom_usergroup = "+ ",
            custom_usergroup_text = "",
            custom_usergroup_placeholder = "...",
            reason_usergroup_blacklisted = "",
            reason_usergroup_not_whitelisted = "",
            reason_team_blacklisted = "",
            reason_team_not_whitelisted = "",
            saved_exclamation = "",
            set_position = "",
            position_set = "",
            set_position_instruction = "",
            set_position_instruction_2 = "",

            action_open_commands_menu = "",
            action_command = "",
            action_chat = "",
            action_website = "",
            action_lua_function_sv = "Lua",
            action_lua_function_cl = "Lua",
            action_gas_module = "GAS",
            action_teleport = "",

            form_action_command = "",
            form_action_chat = "",
            form_action_website = "",
            form_action_lua_function_sv = "Lua",
            form_action_lua_function_cl = "Lua",
            form_action_gas_module = "GAS",
            form_action_teleport = "",

            error_command_exists = "",
            error_no_command = "",
            error_no_command_execute = "",
            error_no_action = "",
            error_invalid_website = "URL",
            error_no_lua_function = "Lua",
            error_no_gas_module = "GAS",
            error_no_position_set = "",
        }
    end
}

--PATH lua/gmodadminsuite/modules/commands/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Command Manager",

		no_permission = "Sorry, you don't have permission to use this command.",
		commands = "Commands",
		command = "Command",
		action = "Action",
		help = "Help",
		new_command = "+ New command",
		wiki = "Wiki",
		run_command = "Run Command",
		edit_command = "Edit Command",
		form_help = "Help text... (optional)",
		form_help_tip = "This is the text that will be shown in the commands menu in the \"help\" column.",
		select_action = "Select action...",
		hide_in_chat = "Hide in chat?",
		hide_in_chat_tip = "If checked, the command will not show up in chat when somebody types it.",
		finished = "Finished",
		commands_case_insensitive = "All commands are case insensitive.",
		ok = "OK",
		cannot_create_command = "Cannot create command!",
		cancel = "Cancel",
		delete_command = "Delete Command",
		copy_command = "Copy Command",
		permissions = "Permissions",
		permissions_editor = "Open Permissions Editor",
		permissions_tip = "Allows you to whitelist and blacklist usergroups and teams/jobs.",
		can_access_command = "Can access command",
		teams = "Teams",
		usergroups = "Usergroups",
		anyone_can_access = "Anyone can access this command",
		whitelisted_only = "Only whitelisted can access this command",
		non_blacklisted_only = "Only non-blacklisted can access this command",
		whitelisted_and_blacklisted = "Only whitelisted (except blacklisted) can access this command",
		custom_usergroup = "+ Custom Usergroup",
		custom_usergroup_text = "Enter usergroup",
		custom_usergroup_placeholder = "Usergroup...",
		reason_usergroup_blacklisted = "Your usergroup is blacklisted from this command.",
		reason_usergroup_not_whitelisted = "Your usergroup is not whitelisted to this command.",
		reason_team_blacklisted = "Your team is blacklisted from this command.",
		reason_team_not_whitelisted = "Your team is not whitelisted to this command.",
		saved_exclamation = "Saved!",
		set_position = "Set position",
		position_set = "Position set!",
		set_position_instruction = "Go to the desired position and face in the desired direction",
		set_position_instruction_2 = "When finished, unpin the menu and the position and angle will then be saved",

		action_open_commands_menu = "Open commands menu",
		action_command = "Run console command",
		action_chat = "Say chat message",
		action_website = "Open website",
		action_lua_function_sv = "Serverside Lua Function",
		action_lua_function_cl = "Clientside Lua Function",
		action_gas_module = "Open GAS Module",
		action_teleport = "Teleport",

		form_action_command = "Console command to run",
		form_action_chat = "Chat message to say",
		form_action_website = "Website to open",
		form_action_lua_function_sv = "Lua function to run\nserverside",
		form_action_lua_function_cl = "Lua function to run\nclientside",
		form_action_gas_module = "GAS module to open",
		form_action_teleport = "Teleport",

		error_command_exists = "A command with this name already exists!",
		error_no_command = "You have not entered the command.",
		error_no_command_execute = "You have not entered the command to execute.",
		error_no_action = "You have not selected an action for this command.",
		error_invalid_website = "The website you have entered is not a valid URL.",
		error_no_lua_function = "You have not selected a Lua function to execute.",
		error_no_gas_module = "You have not selected a GAS module to open.",
		error_no_position_set = "You did not set a position and angle for this teleport.",

} end }
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/lang/polish.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/lang/spanish.lua:
return {
	Name = "Spanish",
	Flag = "flags16/es.png",
	Phrases = function() return {

		module_name = "Billy's Logs",

		--####################### UI PHRASES #######################--

		no_data                     = "Sin registros",
		add_to_evidence_box         = "Agregar a la Caja de Pruebas",
		livelogs_show_logs_for      = "Mostrar Logs Por",
		background_color            = "Color de Fondo",
		health_abbrieviated         = "%d HP",
		livelogs                    = "Logs en Vivo",
		exit_deep_storage           = "Salir del los Registros Profundos",
		log_formatting              = "Formato de log",
		strings                     = "Palabras Clave",
		when                        = "Cuando",
		copy_log                    = "Copiar log",
		evidence_box                = "Caja de Pruebas",
		livelogs_position_x         = "Posicin X (pixeles)",
		width                       = "Anchura",
		color                       = "Color",
		help                        = "Ayuda",
		apply_filter                = "Aplicar Filtro",
		live_log_antispam           = "< live log descartado por antispam >",
		settings                    = "Ajustes",
		loading_ellipsis            = "Cargando...",
		livelogs_enabled            = "Habilitar Logs en Vivo",
		armor_abbrieviated          = "%d ARM",
		deep_storage                = "Registros Profundos",
		all_logs                    = "Todos los Logs",
		logs                        = "Logs",
		padding                     = "Relleno (pixeles)",
		livelogs_position_y         = "Posicin Y (pixeles)",
		livelogs_rows_help          = "Cul es la cantidad mxima de logs que se deben mostrar?",
		livelogs_rows               = "Filas (Cantidad de log)",
		livelogs_color_help         = "Deben mostrarse los registros en color?",
		export_to_clipboard         = "Exportar al portapapeles",
		players                     = "Jugadores",
		script_page                 = "Pagina del Script",
		wiki                        = "Wiki",
		module                      = "Mdulo",
		modules                     = "Mdulos",
		localization                = "Localizacin",
		view_deep_storage           = "Ver Registros Profundos",
		copied                      = "Copiado!",
		operator                    = "Operador",
		log                         = "Log",
		reset_to_defaults           = "Restablecer los valores predeterminados",
		livelogs_show_logs_for_help = "Por cuntos segundos se deben mostrar los registros?\nEstablecer en 0 para que sea para siempre.",
		advanced_search             = "Bsqueda Avanzada",
		quick_search                = "Bsqueda Rpida",
		quick_search_ellipsis       = "Bsqueda Rpida...",
		entities                    = "Entidades",
		tutorial                    = "Tutorial",
		clear_filters               = "Borrar Filtros",
		clear_filter                = "Borrar Filtro",
		manual_steamid_ellipsis     = "SteamID Manual...",
		no_results_found            = "No se han encontrado resultados",
		add_player                  = "+ Agregar Jugador",
		add_module                  = "+ Agregar Mdulo",
		add_entity                  = "+ Agregar Entidad",
		add_string                  = "+ Agregar Palabra Clave",
		modules_search_tooltip      = "Qu mdulo(s) quieres incluir? (dejar en blanco para cualquier mdulo)",
		players_search_tooltip      = "Qu jugador(es) ests buscando? (dejar en blanco para cualquier jugador)",
		entities_search_tooltip     = "Qu entidad(es) ests buscando? (armas, entidades, vehculos, props, clases, etc...)",
		strings_search_tooltip      = "Hay algn texto especfico que ests buscando?",
		class_name_ellipsis         = "Nombre de la clase...",
		add_string_popup_title      = "Agregar Palabra Clave",
		add_string_popup_text       = "Ingresa el texto que ests tratando de encontrar.",
		text_ellipsis               = "Texto...",
		click_to_focus              = "Haz click para enfocar",
		right_click_to_focus        = "Haz click derecho para enfocar",
		highlight_color             = "Color de resaltado",
		weapon_color                = "Color de arma",
		money_color                 = "Color de dinero",
		vehicle_color               = "Color vehiculo",
		entity_color                = "Color de entidad",
		health_color                = "Color de HP",
		armor_color                 = "Color de armadura",
		usergroup_color             = "Color de rango",
		unavailable_color           = "No disponible/Color Desconocido",
		learn_more                  = "Aprender ms",
		player_combats              = "Combates de Jugadores",
		took_damage                 = "[recibi %d de dao]",
		open_pvp_event_report       = "Reporte de evento de PVP",
		remove                      = "Borrar",
		greedy                      = "Extenso",
		greedy_tip                  = "Si tu bsqueda es extensa, intentar hacer coincidir tantos registros como sea posible. Si no lo es, intentar hacer coincidir la menor cantidad posible de registros.",
		log_colouring               = "Colores de Logs",
		done_exclamation            = "Hecho!",
		module_settings             = "Ajustes de Mdulo",
		storage_settings            = "Ajustes de Almacenamiento",
		third_party_addons          = "Addons de terceros",
		pvp_settings                = "Ajustes de registro PvP",
		live_logs_settings          = "Ajustes de Logs en Vivo",
		logging_settings            = "Ajustes de logs",
		settings                    = "Ajustes",
		enabled_modules             = "Habilitar Mdulos",
		permissions                 = "Permisos",
		gamemode_modules            = "Mdulos de Gamemodes",
		saved_exclamation           = "Guardado!",
		save_settings               = "Guardar Ajustes",
		weapon_class                = "Clase de Arma",
		enter_weapon_class          = "Introduce el nombre de la clase del arma.\nNo lo se? Abre tu men de spawn, haz clic derecho en un arma y haz click \"Copiar al portapapeles\"",
		save                        = "Guardar",
		add_new                     = "+ Agregar nuevo",
		enabled                     = "Habilitado",
		website                     = "Sitio Web",
		name                        = "Nombre",
		usergroups                  = "Rangos",
		everyone                    = "Todos",
		all_modules                 = "Todos los mdulos",
		all_teams                   = "Todos los Jobs",
		add_usergroup               = "Agregar Rango",
		cl_sv_tooltip               = [[cl representa el tiempo necesario para que tu ordenador solicite registros, los reciba, los procese y los muestre
		
		sv representa el tiempo necesario para que el servidor recupere los registros de la memoria/la base de datos, los procese y luego se los enve.

		Los servidores que usan MySQL vern un valor sv ms alto debido a la latencia entre el servidor MySQL y Garr's Mod]],
		deep_storage_help           = [[Registros Profundos es una funcin de bLogs que mejora el rendimiento al almacenar registros de sesiones anteriores del servidor por separado de las sesiones actuales.

		Despus de hacer clic en "Ver Registros Profundos", solo vers los registros de las sesiones anteriores del servidor.
		Puede ver los registros de la sesin actual haciendo click nuevamente en el botn de abajo o volviendo a abrir el men.

		NOTA:Los registros de daos no se incluyen en el almacenamiento profundo y se eliminan en cada reinicio para ahorrar espacio en el disco]],

		damage = "Dao",

		class_type_other = "Otro",
		class_type_player = "Jugador",
		class_type_team = "Team",
		class_type_weapon = "Arma",
		class_type_vehicle = "Vehiculo",
		class_type_damage = "Tipo de Dao",
		class_type_usergroup = "Rango",
		class_type_prop = "Prop",
		class_type_ragdoll = "Ragdoll",
		class_type_country = "Pas",
		class_type_ammo = "Municin",
		class_type_role = "Rol",
		class_type_entity = "Entidad",
		class_selector = "Selector de Clase",
		custom_class = "Clase Personalizada",
		class_type = "Tipo de Clase",
		value = "Valor",
		search = "Bscar",
		check_all = "Marcar Todo",
		uncheck_all = "Desmaecae Todo",
		general = "General",
		class_search_title = "Bsqueda de Clase",
		class_search_text = "Ingresa el nombre o parte de un nombre de la clase que ests buscando (no se distinguen maysculas y minsculas)",
		view_logs = "Ver Logs",
		open_menu = "Open Menu",
		licensed_to = "Licenciado para %s",

		pvp_event_report = "Reporte de Evento PvP",
		victim = "Victima",
		instigator = "Instigador",
		victim_tag_tip = "Esta es la persona contra la que el instigador comenz el combate.",
		instigator_tag_tip = "Esta es la persona que comenz el combate.",
		victim_abbr = "V",
		instigator_abbr = "I",
		time = "Tiempo",
		linked_events = "Eventos Relacionados",

		deleted_team = "(TEAM BORRADO)",

		unknown = "Desconocido",
		cancel = "Cancelar",

		deep_storage_advanced_search_warning = "ADVERTENCIA: La bsqueda avanzada en realidad busca en el Registros Profundos internamente por razones de rendimiento, lo que significa que la Bsqueda avanzada no encontrar los registros creados recientemente durante un corto perodo de tiempo.",

		--####################### SETTINGS #######################--

		Player_RecordTeam = "Mostrar team del jugador en los logs",
		Player_RecordUsergroup = "Mostrar el rango del jugador en los logs",
		Player_RecordHealth = "Mostra vida del jugador en los logs",
		Player_RecordArmor = "Mostrar armadura del jugador en los logs",
		Player_RecordWeapon = "Mostrar arma del jugador en los logs",
		Player_RecordWeapon_DoNotRecord = "Filtro de arma del jugador",
		Player_RecordWeapon_DoNotRecord_help = "Si deseas mostrar las armas de los jugadores en los registros, usa esta opcin para filtrar las armas que no quieres ver (como la physgun, la toolgun, etc.)",

		OverrideMoneyFormat = "Anular formato de dinero predeterminado",
		OverrideMoneyFormat_help = "Cuando esto est desactivado, se utilizar el formato de dinero del modo de juego.\nCuando esto est activado, puedes usar la opcin a continuacin para poner tu propio formato de dinero.",
		MoneyFormat = "Formato de Dinero",
		MoneyFormat_help = "Introduce cmo quieres que aparezca el dinero e inserta \"%s\" (sin las comillas)donde quieres que aparezca la cantidad de dinero.",

		DeepStorageEnabled = "Registros Profundos Habilitados",
		DeepStorageEnabled_help = "Deshabilitar el Registros Profundos puede mejorar significativamente el rendimiento en servidores que no usan MySQL.",

		DeepStorageCommitPeriod = "Registros Profundos perodo de compromiso",
		DeepStorageCommitPeriod_help = "Con qu frecuencia (en segundos) se deben confirmar los registros profundos en la base de datos?",

		DeepStorageTooOld = "Edad mxima de los registros profundos",
		DeepStorageTooOld_help = "Cuntos das puede estar un registro profundo antes de que se elimine? (ahorra espacio en el disco)\nEstablzcalo en 0 para no eliminar nunca los registros profundos.",

		LiveLogsEnabled = "Logs en Vivo Habilitado",
		LiveLogsEnabled_help = "Los registros en vivo pueden ser un impacto de rendimiento para servidores grandes; Puedes desactivar la funcin completamente aqu.",
		LiveLogsIn10Seconds = "Max registros en vivo en 10 segundos",
		LiveLogsIn10Seconds_help = "Cuntos registros en vivo se pueden enviar antes de que se bloqueen los registros adicionales para el antispam?",
		NotifyLiveLogsAntispam = "Notificar antispam",
		NotifyLiveLogsAntispam_help = "Se debe notificar a los usuarios que se ha descartado un registro activo por el antispam?",

		TimeBetweenPvPEvents = "Tiempo entre eventos PvP",
		TimeBetweenPvPEvents_help = "Cuando los jugadores comienzan el combate, se crea un \"Evento PVP\", cuando no se ha producido ningn combate adicional en una cierta cantidad de segundos, el evento PvP se trata como finalizado y comprometido con los registros. Cuntos segundos deben esperar los bLogs antes de hacer esto?",
		NonPvPWeapons = "Filtro de armas PvP",
		NonPvPWeapons_help = "Qu armas no deben ser tratadas como armas PvP?",

		server_restart_required = "NOTA: Los cambios en estos ajustes se aplicarn despus de reiniciar el servidor.",

		gamemode_modules_tip = [[bLogs soporta una gran cantidad de modos de juego.
        Sin embargo, a veces bLogs puede tener problemas para detectar si est ejecutando un determinado modo de juego.
        En esta pantalla, puedes forzar a bLogs a detectar que ests ejecutando un determinado modo de juego.

		Desmarcado = Comportamiento por defecto
		Marcado = Forzado
		Tachado = No Forzado

		Ten en cuenta que algunos modos de juego RETIVAN del Sandbox, esto significa que usan el men de spawn del Sandbox, la toolgun, etc.
		Para los modos de juego como DarkRP que se derivan de Sandbox, se recomienda dejar Sandbox en su deteccin predeterminada.]],

		third_party_addons_tip = [[bLogs admite una gran cantidad de addons de terceros.
		Sin embargo, a veces, los bLogs pueden tener problemas para detectar si tienes un complemento de terceros instalado.
        En esta pantalla, puede forzar a bLogs a pensar que tiene ciertos addons de terceros instalados.

		Desmarcado = Comportamiento por defecto
		Marcado = Forzado
		Tachado = No Forzado]],

		edit_discord_webhooks = "Editar Discord Webhooks",
		webhook_name = "Nombre del webhook",
		webhook_name_tip = "Ingrese el nombre del webhook.\nEsto es solo un identificador para el webhook, ingresar la URL en la siguiente pantalla.",
		webhook = "Webhook",
		webhook_url = "Webhook URL",
		webhook_url_tip = "Copia la URL de tu webhook de Discord y pgala aqu.",
		copy_webhook = "Copiar Webhook",

		can_access_module = "Puede acceder al mdulo",
		can_access_all_modules = "Puede acceder a TODOS los mdulos",
		all_usergroups = "Todos los rangos",
		all_jobs_in_category = "Todos los jobs en categora",
		all_teams_in_category = "Todos los teams en categoria",
		teams = "Teams",
		permissions_tip = "Desmarcado = Hereda de \"%s\"\nMarcado = Permitido usar mdulo\nTachado = Prohibido usar mdulo",
		all_modules_tip = "Los permisos se heredan de esta seccin a menos que se invaliden.",

		wipes_and_resets = "Wipes & Reseteos", -- wipes as in data wipes
		disable_buttons = "Deshabilitar botones",
		enable_buttons = "Habilitar botones",
		wipe_deepstorage = "Borrar Registros Profundos",
		wipe_session = "Borrar Logs de la sesin",
		wipe_all_logs = "Borrar todos los Logs",
		reset_config = "Resetear Ajustes.",

		vehicle_driver = "Conductor:",
		data = "Data",
		weapons = "Armas",
		props = "Props",
		ragdolls = "Ragdolls",
		money = "Dinero",
		countries = "Pases",
		ammo = "Municin",
		roles = "Roles",
		vehicles = "Vehiculos",

		flag_ongoing = "Evento en curso",
		flag_finished = "Evento Terminado",
		flag_superadmin = "Implica Superadmin",
		flag_admin = "Implica Staff",
		flag_friendly_fire = "Fuego amigo",
		flag_law_enforcement = "Implica cumplimiento de la ley",
		flag_instigator_death = "El instigador muri",
		flag_victim_death = "La vctima muri",
		flag_vehicle = "Implica vehculo(s)",
		flag_world = "Involucra el mapa",
		flag_props = "Involucra props",
		flag_team_switched = "Ocurri cambio de team",
		flag_disconnect = "Jugador desconectado durante el combate",
		flag_linked = "Vinculado a otros eventos PvP",

		event_start = "Inicio de evento",
		event_end = "Final del evento",

		dead_tag = "[MUERTO]",

		DmgTooltip_Victim = "% del dao total del evento PVP fue la vctima responsable",
		DmgTooltip_Instigator = "% del dao total del evento PVP fue el instigador responsable",
		DmgTooltip_Other = "% del dao total del evento PVP fue por otra causa",

		--####################### LOG PHRASES #######################--
		Logs = {
			round_start     = "INICIO DE RONDA",
			round_preparing = "PREPARANDO RONDA",
			round_end       = "RONDA TERMINADA",

			connected                                      = "{1} conectado",
			connected_from_country                         = "{1} conectado desede {2}",
			finished_connecting                            = "{1} se termin de conectar",
			respawned                                      = "{1} respawneo",
			disconnected                                   = "{1} desconectado ({2})",
			picked_up_weapon                               = "{1} cogi un arma {2}",
			picked_up_item                                 = "{1} cogi un item {2}",
			prop_killed_self                               = "{1} se suicid con su prop {2}",
			prop_killed_other                              = "{1} fue asesinado por prop creado por {2} ({3})",
			prop_killed_world                              = "{1} fue asesinado por un prop del mundo {2}",
			prop_damaged_self                              = "{1} recibi un {2} de dao con su prop {3}",
			prop_damaged_other                             = "{1} fue daado por prop creado por {2} quitandole {3} de dao ({4})",
			prop_damaged_world                             = "{1} fue daado con un prop del mundo {2} recibi un {3} de dao",
			toolgun_used_their_ent                         = "{1} us la tool {2} en su {3}",
			toolgun_used_other_ent                         = "{1} us la tool {2} en {3} creado por {4}",
			toolgun_used_world_ent                         = "{1} us la tool {2} en {3}",
			spawned_effect                                 = "{1} spawne un efecto {2}",
			spawned_npc                                    = "{1} spawne un NPC {2}",
			spawned_prop                                   = "{1} spawne un prop {2}",
			spawned_ragdoll                                = "{1} spawne un ragdoll {2}",
			spawned_sent                                   = "{1} spawne una entidad {2}",
			spawned_swep                                   = "{1} spawne un arma {2}",
			spawned_vehicle                                = "{1} spawne vehiculo {2}",
			steam_name_changed                             = "{1} cambi su nombre de Steam de {2} a {3}",
			weapon_switched                                = "{1} cambi del arma {2} a {3}",
 
			murder_loot                                    = "{1} recogi loot",
 
			cinema_video_queued                            = "[{1}] {2} en cola [{3}] \"{4}\" {5}",
 
			ttt_win_traitor                                = "Ganan Traidores!",
			ttt_win_innocent                               = "Ganan Inocentes!",
			ttt_win_timelimit                              = "Ganan Inocentes - lmite de tiempo alcanzado!",
			ttt_bought                                     = "{1} compr {2}",
			ttt_karma                                      = "{1} fue KICKEADO por bajo karma",
			ttt_foundbody                                  = "{1} encontr el cuerpo de {2}",
			ttt_founddna                                   = "{1} encontr el ADN de {2} en su {3}",
			ttt_founddna_corpse                            = "{1} encontr el ADN de {2} en su cadver",
 
			darkrp_agenda_updated                          = "{1} actualiz la agenda de {2} a: {3}",
			darkrp_agenda_removed                          = "{1} borro {2}",
			darkrp_arrest                                  = "{1} arrest {2}",
			darkrp_unarrest                                = "{1} sali {2}",
			darkrp_batteringram_owned_success              = "{1} abri con el battering ram el {2} de {3}",
			darkrp_batteringram_owned_door_success         = "{1} abri con el battering ram la puerta de {2}",
			darkrp_batteringram_success                    = "{1} abri con el battering ram algo desconocido, {2}",
			darkrp_batteringram_door_success               = "{1} abri con el battering ram una puerta desconocida",
			darkrp_batteringram_owned_failed               = "{1} fall con el battering ram en {2} de {3}",
			darkrp_batteringram_owned_door_failed          = "{1} fall con el battering ram en la puerta de {2}",
			darkrp_batteringram_failed                     = "{1} fall con el battering ram algo desconocido, {2}",
			darkrp_batteringram_door_failed                = "{1} fall con el battering ram una puerta desconocida",
			darkrp_cheque_dropped                          = "{1} sollt un cheque de {2} para {3}",
			darkrp_cheque_picked_up                        = "{1} cobr un cheque de {2} de {3}",
			darkrp_cheque_tore_up                          = "{1} rompi un cheque de {2} hecho para {3}",
			darkrp_demoted                                 = "{1} demoteado {2} por {3}",
			darkrp_demoted_afk                             = "{1} fue demoteado por estar AFK",
			darkrp_door_sold                               = "{1} vendi una puerta",
			darkrp_door_bought                             = "{1} compr una puerta",
			darkrp_money_dropped                           = "{1} solt {2}",
			darkrp_money_picked_up                         = "{1} cogi {2}",
			darkrp_money_picked_up_owned                   = "{1} cogi {2} soltado por {3}",
			darkrp_hit_accepted                            = "{1} acepto un hit para {2} requerido por {3}",
			darkrp_hit_completed                           = "{1} complet un hit hacia {2} que fue requerido por {3}",
			darkrp_hit_failed                              = "{1} fall el hit para {2} porque {3}",
			darkrp_hit_requested                           = "{1} requiri un hit para {2} mediante {3} por {4}",
			darkrp_job_changed                             = "{1} se cambi de {2} a {3}",
			darkrp_law_added                               = "{1} ley aadida: {2}",
			darkrp_law_removed                             = "{1} ley borrada: {2}",
			darkrp_purchase                                = "{1} compr {2} por {3}",
			darkrp_purchase_ammo                           = "{1} compr municin de {2} por {3}",
			darkrp_purchase_shipment                       = "{1} compr un cargamento de x{2} {3} por {4}",
			darkrp_purchase_food                           = "{1} compr comida: {2} por {3}",
			darkrp_weapons_checked                         = "{1} cheque las armas de {2}",
			darkrp_weapons_confiscated                     = "{1} confisc las armas de {2}",
			darkrp_weapons_returned                        = "{1} devolvi las armas confiscadas de {2}",
			darkrp_filed_warant                            = "{1} present un warrant para {2} por: {3}",
			darkrp_warrant_cancelled                       = "{1} cancel el warrant de {2}",
			darkrp_set_wanted                              = "{1} pus a {2} un wanted por {3}",
			darkrp_cancelled_wanted                        = "{1} cancel el wanted de {2}",
			darkrp_auto_cancelled_wanted                   = "{1} perdi el wanted que tenia",
			darkrp_starved                                 = "{1} muri de hambre",
			darkrp_pocket_added                            = "{1} guard {2} en su pocket",
			darkrp_pocket_dropped                          = "{1} solt {2} de su pocket",
			darkrp_rpname_change                           = "{1} se cambi el Nombre de RP de {2} a {3}",
			darkrp_started_lockpick_owned_entity           = "{1} empez a usar la lockpick en {2} de {3}",
			darkrp_started_lockpick_unowned_entity         = "{1} empez a usar la lockpick en un {2} desconocido",
			darkrp_started_lockpick_owned_door             = "{1} empez a usar la lockpick en una puerta de {2}",
			darkrp_started_lockpick_unowned_door           = "{1} empez a usar la lockpick en una puerta desconocida",
			darkrp_started_lockpick_own_entity             = "{1} empez a usar la lockpick en su {2}",
			darkrp_started_lockpick_own_door               = "{1} empez a usar la lockpick en una de sus puertas",
			darkrp_successfully_lockpicked_owned_entity    = "{1} lockpickeo con xito un {2} de {3}",
			darkrp_successfully_lockpicked_unowned_entity  = "{1} lockpickeo con xito un {2} desconocido",
			darkrp_successfully_lockpicked_owned_door      = "{1} lockpickeo con xito una puerta de {2}",
			darkrp_successfully_lockpicked_unowned_door    = "{1} lockpickeo con xito una puerta desconocida",
			darkrp_successfully_lockpicked_own_entity      = "{1} lockpickeo con xito su {2}",
			darkrp_successfully_lockpicked_own_door        = "{1} lockpickeo con xito una de sus puertas",
			darkrp_failed_lockpick_owned_entity            = "{1} no consigui lockpickear el {2} de {3}",
			darkrp_failed_lockpick_unowned_entity          = "{1} no consigui lockpickear el {2} desconocido",
			darkrp_failed_lockpick_owned_door              = "{1} no consigui lockpickear la puerta de {2}",
			darkrp_failed_lockpick_unowned_door            = "{1} no consigui lockpickear una puerta desconocida",
			darkrp_failed_lockpick_own_entity              = "{1} no consigui lockpickear su {2}",
			darkrp_failed_lockpick_own_door                = "{1} no consigui lockpickear una de sus pertas",
			darkrp_changed_job                             = "{1} se cambio de job de {2} a {3}",
			darkrp_added_law                               = "{1} aadi la ley: {2}",
			darkrp_removed_law                             = "{1} borr la ley: {2}",
			darkrp_hit_accepted                            = "{1} acept un hit para {2} requerido por {3}",
			darkrp_hit_completed                           = "{1} completo un hit para {2} requerido por {3}",
			darkrp_hit_failed                              = "{1} fall en un hit para {2} requerido por {3}",
			darkrp_hit_requested                           = "{1} solicit un hit para {2} mediante {3} por {4}",
			darkrp_sold_door                               = "{1} vendi una puerta",
			darkrp_bought_door                             = "{1} compr una puerta",
			darkrp_dropped_money                           = "{1} solt {2}",
			darkrp_picked_up_money                         = "{1} cogi {2}",
			darkrp_picked_up_money_dropped_by              = "{1} cogi {2} que solt {3}",
			darkrp_demoted                                 = "{1} fue demoteado de {2} por {3}",
			darkrp_afk_demoted                             = "{1} fue demoteado por estar AFK",
			darkrp_lottery_started                         = "{1} inici una loteria con el precio de: {2}",
			darkrp_lottery_ended                           = "{1} gan {2} de la loteria!",
 
			pvp_instigator_killed_noweapon                 = "{1} {2} termin el combate y ASESIN A {3} {4} despus de {5}", -- after X seconds/minutes/hours
			pvp_instigator_killed_weapon                   = "{1} {2} termin el combate usando {3} y ASESIN A {4} {5} despus de {6}",
			pvp_instigator_killed_weapons                  = "{1} {2} termin el combate usando multiples armas y ASESIN A {3} {4} despus de {5}",
			pvp_victim_killed_noweapon                     = "{1} {2} termin el combate y FUE ASESINAD POR {3} {4} despus de {5}",
			pvp_victim_killed_weapon                       = "{1} {2} termin el combate usando {3} y FUE ASESINADO POR {4} {5} despus de {6}",
			pvp_victim_killed_weapons                      = "{1} {2} termin el combate usando multiples armas y FUE ASESINADO POR {3} {4} despus de {5}",
			pvp_combat_noweapon                            = "{1} {2} termin el combate con {3} {4} despus de {5}",
			pvp_combat_weapon                              = "{1} {2} termin el combate usando {3} con {4} {5} despus {6}",
			pvp_combat_weapons                             = "{1} {2} termin el combate usando multiples armas con {3} {4} despus {5}",
			pvp_log_noweapon                               = "{1} da a {2} quitandole {3} de dao",
			pvp_log_weapon                                 = "{1} da a {2} quitandole {3} de dao usando {4}",
			pvp_killed                                     = "{1} mat a {2}",
			pvp_vehicle_owned_killed                       = "{1} fue daado & y asesinado por {2} sin conductor, propiedad de {3}",
			pvp_vehicle_owned_damaged                      = "{1} fue daado quitandole {2} de dao por {3} sin conductor, propiedad de {4}",
			pvp_vehicle_killed                             = "{1} fue daado & y asesinado por {2} sin conductor, propiedad de nadie",
			pvp_vehicle_damaged                            = "{1} fue daado quitandole {2} de dao por {3} sin conductor, propiedad de nadie",
			pvp_killed_self                                = "{1} se suicid",
			pvp_damaged_self                               = "{1} se da a si mismo quitandose {2} de dao",
 
			changed_team                                   = "{1} se cambi de team de {2} a {3}",
			command_used                                   = "{1}: {2}",
			warned_reason                                  = "{1} fue warneado por {2} por {3}",
			warned_noreason                                = "{1} fue warnedo por {2}",
			warned_kicked                                  = "{1} fue KICKEADO por alcanzar el lmite de warns activos",
			warned_banned                                  = "{1} fue BANEADO por alcanzar el lmite de warns activos",
			handcuffed                                     = "{1} espos {2}",
			handcuffs_broken_by                            = "{1} rompi las esposas que le puso {2}",
			handcuffs_broken                               = "{1} rompi sus propias esposas",
			npc_health_bought                              = "{1} compro vida en un NPC por {2}",
			npc_armor_bought                               = "{1} compro armadura en un NPC por {2}",
			pac_outfit                                     = "{1} cambiado su traje de PAC {2}",
			party_chat                                     = "{1} ({2}): {3}",
			party_created                                  = "{1} cre una party {2}",
			party_join                                     = "{1} se uni a la parti {2}",
			party_join_request                             = "{1} requiri unirse a la party {2}",
			party_invite                                   = "{1} invit a {2} a la party {3}",
			party_leave                                    = "{1} se sali de la party {2}",
			party_kick                                     = "{1} kickeo a {2} de la party {3}",
			party_disbanded                                = "{1} party borrada {2}",
			party_abandoned                                = "{1} se fue del server y se fue de la party {2}",
			spraymesh                                      = "{1} us su spray {2}",
			starwarsvehicle_damage_owned_weapon            = "{1} da un vehiculo de Star Wars {2} de {3} quitandole {4} de dao con {5}",
			starwarsvehicle_damage_owned                   = "{1} da un vehiculo de Star Wars {2} de {3} quitandole {4} de dao",
			starwarsvehicle_damage_weapon                  = "{1} da un vehiculo de Star Wars {2} quitandole {3} de dao con {4}",
			starwarsvehicle_damage                         = "{1} da un vehiculo de Star Wars {2} quitandole {3} de dao",
			wac_damage_owned_weapon                        = "{1} da un vehiculo de WAC aircraft {2} de {3} quitandole {4} de dao con {5}",
			wac_damage_owned                               = "{1} da un vehiculo de WAC aircraft {2} de {3} quitandole {4} de dao",
			wac_damage_weapon                              = "{1} da un vehiculo de WAC aircraft {2} quitandole {3} de dao con {4}",
			wac_damage                                     = "{1} da un vehiculo de WAC aircraft {2} quitandole {3} de dao",
			wyozi_cinema_queued                            = "{1} requiri un video {2}  {3} en el cine {4}",
			wyozi_dj_queued                                = "{1} en cola {2}  {3} en el canal {4}",
			wyozi_dj_channel_rename                        = "{1} renombr el canal a {2}",
 
			bwhitelist_whitelist_enabled_by                = "{1} habilit la whitelist para {2}",
			bwhitelist_whitelist_enabled                   = "La whitelist para {1} fue habilitada",
			bwhitelist_whitelist_disabled_by               = "{1} deshabilit la whitelist de {2}",
			bwhitelist_whitelist_disabled                  = "La whitelist de {1} fue deshabilitada",
 
			bwhitelist_blacklist_enabled_by                = "{1} habilit la blacklist para {2}",
			bwhitelist_blacklist_enabled                   = "La bakclist para {1} fue habilitada",
			bwhitelist_blacklist_disabled_by               = "{1} deshabilit la blacklist para {2}",
			bwhitelist_blacklist_disabled                  = "La blacklist para {1} fue deshabilitada",
 
			bwhitelist_added_to_whitelist_by               = "{1} fue aadido a la whitelist de {2} por {3}",
			bwhitelist_added_to_whitelist                  = "{1} fue aadido a la whitelist de {2}",
			bwhitelist_removed_from_whitelist_by           = "{1} fue borrado de la whitelist de {2} por {3}",
			bwhitelist_removed_from_whitelist              = "{1} fue borrado de la whitelist de {2}",
			bwhitelist_added_to_blacklist_by               = "{1} fue aadido a la blacklist de {2} por {3}",
			bwhitelist_added_to_blacklist                  = "{1} fue aadido a la blacklist de {2}",
			bwhitelist_removed_from_blacklist_by           = "{1} fue borrado de la blacklist de {2} por {3}",
			bwhitelist_removed_from_blacklist              = "{1} fue borrado de la blacklist de {2}",
 
			bwhitelist_added_to_whitelist_by_usergroup     = "El rango {1} fue aadido a la whitelist de {2} por {3}",
			bwhitelist_added_to_whitelist_usergroup        = "El rango {1} fue aadido a la whitelist de {2}",
			bwhitelist_removed_from_whitelist_by_usergroup = "El rango {1} fue borrado a la whitelist de {2} por {3}",
			bwhitelist_removed_from_whitelist_usergroup    = "El rango {1} fue borrado a la whitelist de {2}",
			bwhitelist_added_to_blacklist_by_usergroup     = "El rango {1} fue aadido a la blacklist de {2} por {3}",
			bwhitelist_added_to_blacklist_usergroup        = "El rango {1} fue aadido a la blacklist de {2}",
			bwhitelist_removed_from_blacklist_by_usergroup = "El rango {1} fue borrado a la blacklist de {2} por {3}",
			bwhitelist_removed_from_blacklist_usergroup    = "El rango {1} fue borrado a la blacklist de {2}",
 
			bwhitelist_added_to_whitelist_by_luafunc       = "La funcin de lua {1} fue aadida a la whitelist de {2} por {3}",
			bwhitelist_added_to_whitelist_luafunc          = "La funcin de lua {1} fue aadida a la whitelist de {2}",
			bwhitelist_removed_from_whitelist_by_luafunc   = "La funcin de lua {1} fue borrada a la whitelist de {2} por {3}",
			bwhitelist_removed_from_whitelist_luafunc      = "La funcin de lua {1} fue borrada a la whitelist de {2}",
			bwhitelist_added_to_blacklist_by_luafunc       = "La funcin de lua {1} fue aadida a la blacklist de {2} por {3}",
			bwhitelist_added_to_blacklist_luafunc          = "La funcin de lua {1} fue aadida a la blacklist de {2}",
			bwhitelist_removed_from_blacklist_by_luafunc   = "La funcin de lua {1} fue borrada a la blacklist de {2} por {3}",
			bwhitelist_removed_from_blacklist_luafunc      = "La funcin de lua {1} fue borrada a la blacklist de {2}",

			pvp_combat_begin = "{1} combate instigado contra {2}",
			pvp_combat_end   = "El combate instigado por {1} en contra de {2} termin",

			pvp_player_damage_weapon = "{1} da a {2} con {3}",
			pvp_player_damage = "{1} da a {2}",
			pvp_misc_dmg = "{1} fue daado por {2}",
			pvp_fall_damage = "{1} recibi dao por caida",
			pvp_world_crush_damage = "{1} fue aplastado contra el mundo",
			pvp_world_damage = "{1} fue daado por el mundo",
			pvp_prop_self_damage = "{1} se da a si mismo con el prop {2}",
			pvp_prop_damage = "{1} fue daado con el prop {2} creado por {3}",
			pvp_world_prop_damage = "{1} fue daado con el un prop del mundo, {2}",
			pvp_dmg_self = "{1} se dao a si mismo",
			pvp_vehicle_damage = "{1} fue daado por el vehculo {2} conducido por {3}",
			pvp_driverless_vehicle_damage = "{1} fue daado por el vehculo {2} sin conductor",

			pvp_player_silent_death = "{1} fue asesinado en silencio",
			pvp_death_propkill_self = "{1} se hizo propkill a si mismo con {2}",
			pvp_death_propkill_world = "{1} el mundo le hizo propkill con {2}",
			pvp_death_propkill = "{1} fue asesinado con un prop de {2} usando {3}",
			pvp_death_player = "{1} fue asesinado por {2}",
			pvp_death_player_weapon = "{1} fue asesinado por {2} con {3}",
			pvp_death_world = "{1} fue asesinado por el mundo",
			pvp_death = "{1} fue asesinado",
			
			pvp_misc_dmg_prop = "{1} recibi {2} por el prop de un mundo {3}",
			pvp_misc_dmg_attacker = "{1} recibi {2} de {3}",
			pvp_misc_dmg_other = "{1} recibi {2}",
		},

		pvp_dmgtype_generic = "%u de dao",
		pvp_dmgtype_burn = "%u de dao por fuego",
		pvp_dmgtype_crush = "%u de dao por aplastamiento",
		pvp_dmgtype_fall = "%u de dao por caida",
		pvp_dmgtype_bullet = "%u de dao por bala",
		pvp_dmgtype_slash = "%u de dao por corte",
		pvp_dmgtype_vehicle = "%u de dao por vehiculo",
		pvp_dmgtype_blast = "%u de dao por explosin",
		pvp_dmgtype_club = "%u de dao por club",
		pvp_dmgtype_shock = "%u de dao por electrocutamiento",
		pvp_dmgtype_sonic = "%u de dao por sonic",
		pvp_dmgtype_energybeam = "%u de dao por laser",
		pvp_dmgtype_drown = "%u de dao por ahogamiento",
		pvp_dmgtype_nervegas = "%u de dao por neurotoxina",
		pvp_dmgtype_poison = "%u de dao por  veneno",
		pvp_dmgtype_radiation = "%u de dao por radiacin",
		pvp_dmgtype_acid = "%u de dao por qumico",
		pvp_dmgtype_gravgun = "%u de dao por gravity gun",
		pvp_dmgtype_plasma = "%u de dao por plasma",
		pvp_dmgtype_airboat = "%u de dao por arma de airboat",
		pvp_dmgtype_buckshot = "%u de dao por bala de escopeta",
		pvp_dmgtype_sniper = "%u de dao por bala de Sniper",

} end }
--PATH lua/gmodadminsuite/sh_registry_tbl.lua:
-- Optimization library
-- Helps with optimizing pairs() into ipairs() for some stuff
-- Basically just a table that makes sure there are no duplicates

AddCSLuaFile()

local setmetatable = setmetatable
local rawget = rawget
local rawset = rawset
local isnumber = isnumber

local function __index_func(self, i)
	if (isnumber(i)) then
		return rawget(self, "seq")[i]
	else
		return rawget(self, "kv")[i]
	end
end

local function __call_func(self, i, method)
	local kv = rawget(self, "kv")

	if (method == nil and kv[i] ~= nil) then -- remove

		local seq = rawget(self, "seq")
		local seq_i = rawget(self, "seq_i")
		local seq_r = rawget(self, "seq_r")
		
		kv[i] = nil
		seq[seq_r[i]] = nil
		for shift=seq_r[i]+1,seq_i do
			if (seq[shift] ~= nil) then
				seq_r[seq[shift]] = shift - 1
			end
			seq[shift-1] = seq[shift]
		end
		
		seq_r[i] = nil

		rawset(self, "seq_i", seq_i - 1)

	elseif (method ~= nil) then -- add

		if (kv[i] ~= nil) then
			self(i, nil)
		end

		local seq = rawget(self, "seq")
		local seq_i = rawget(self, "seq_i")
		local seq_r = rawget(self, "seq_r")

		kv[i] = method
		seq[seq_i] = i
		seq_r[i] = seq_i

		rawset(self, "seq_i", seq_i + 1)

	end
end

local function ipairs_func(self)
	return ipairs(rawget(self, "seq"))
end

local function pairs_func(self)
	return pairs(rawget(self, "kv"))
end

local function ipairs_pop_func(self)
	local n, prev_n
	return function()
		n = self:len()
		if (n > 0) then
			assert(prev_n == nil or n < prev_n, "ipairs_pop requires element to always be popped")
			prev_n = n
			return n, rawget(self, "seq")[n]
		end
	end
end

local ipairs_poppy_func
do
	local active_ipairs_pop
	local function pop_func()
		active_ipairs_pop(rawget(active_ipairs_pop, "seq")[rawget(active_ipairs_pop, "poppy_i")], nil)
	end
	ipairs_poppy_func = function(self)
		self(NULL, nil)
		active_ipairs_pop = self
		rawset(self, "poppy_i", self:len() + 1)
		return function()
			rawset(self, "poppy_i", rawget(self, "poppy_i") - 1)
			if (rawget(self, "poppy_i") > 0) then
				return rawget(self, "poppy_i"), rawget(self, "seq")[rawget(self, "poppy_i")], pop_func
			end
		end
	end
end

local function len_func(self)
	self(NULL, nil)
	return rawget(self, "seq_i") - 1
end

local function sequential_func(self)
	self(NULL, nil)
	return rawget(self, "seq")
end

local function dictionary_func(self)
	self(NULL, nil)
	return rawget(self, "kv")
end

function GAS:Registry()
	local Registry = {
		seq = {},
		seq_i = 1,
		seq_r = {},
		kv = {},
		ipairs = ipairs_func,
		ipairs_pop = ipairs_pop_func,
		ipairs_poppy = ipairs_poppy_func,
		pairs = pairs_func,
		len = len_func,
		sequential = sequential_func,
		dictionary = dictionary_func
	}

	setmetatable(Registry, {
		__index = __index_func,
		__call = __call_func
	})
	
	return Registry
end
--PATH lua/gmodadminsuite/sh_modules.lua:
return gluapack()()
--PATH lua/gmodadminsuite/sh_modules.lua:
GAS.Modules = {}
GAS.Modules.Info = {}

GAS.MODULE_CATEGORY_ADMINISTRATION    = 0
GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT = 1
GAS.MODULE_CATEGORY_UTILITIES         = 2
GAS.MODULE_CATEGORY_FUN               = 3

GAS.Modules.Organised = {}

function GAS.Modules:GetFriendlyName(module_name)
	return GAS:Phrase("module_name", module_name) or GAS.Modules.Info[module_name].Name or module_name
end

if (SERVER) then

	GAS.Modules.Config = GAS:GetConfig("modules", {
		Enabled = {}
	})

	GAS:netInit("SetModuleEnabled")
	GAS:netReceive("SetModuleEnabled", function(ply)
		if (not OpenPermissions:IsOperator(ply)) then return end

		local module_name, enabled = net.ReadString(), net.ReadBool()

		GAS.Modules.Config.Enabled[module_name] = enabled or nil
		GAS:SaveConfig("modules", GAS.Modules.Config)

		GAS:netStart("SetModuleEnabled")
			net.WriteString(module_name)
			net.WriteBool(enabled)
		net.SendOmit(ply)
	end)

else

	GAS:netReceive("SetModuleEnabled", function()
		local module_name, enabled = net.ReadString(), net.ReadBool()
		GAS.Modules.Config.Enabled[module_name] = enabled or nil
	end)

end

GAS.Modules.LoadedModules = {}
function GAS.Modules:IsModuleLoaded(module_name)
	return GAS.Modules.LoadedModules[module_name] == true
end

GAS.Modules.MODULE_ENABLED  = 0
GAS.Modules.MODULE_DISABLED = 1
GAS.Modules.MODULE_UNKNOWN  = 2
function GAS.Modules:IsModuleEnabled(module_name)
	if (GAS.Modules.Info[module_name]) then
		if (GAS.Modules.Config.Enabled[module_name]) then
			return GAS.Modules.MODULE_ENABLED
		else
			return GAS.Modules.MODULE_DISABLED
		end
	else
		return GAS.Modules.MODULE_UNKNOWN
	end
end

function GAS.Modules:LoadModule(module_name, suppress_print)
	GAS.Modules.LoadedModules[module_name] = true
	hook.Run("gmodadminsuite:LoadModule:" .. module_name, GAS.Modules.Info[module_name])
end

GAS:StartHeader("Modules")

local save_config = false
local _,d = file.Find("gmodadminsuite/modules/*", "LUA")
for _,module_name in ipairs(d) do
	if (not file.Exists("gmodadminsuite/modules/" .. module_name .. "/_gas_info.lua", "LUA")) then continue end

	if (SERVER) then
		AddCSLuaFile("gmodadminsuite/modules/" .. module_name .. "/_gas_info.lua")
	end
	GAS.Modules.Info[module_name] = include("gmodadminsuite/modules/" .. module_name .. "/_gas_info.lua")

	local category = GAS.Modules.Info[module_name].Category
	GAS.Modules.Organised[category] = GAS.Modules.Organised[category] or {}
	GAS.Modules.Organised[category][module_name] = GAS.Modules.Info[module_name]

	local init = false
	if (file.Exists("gmodadminsuite/modules/" .. module_name .. "/sh_init.lua", "LUA")) then
		if (SERVER) then AddCSLuaFile("gmodadminsuite/modules/" .. module_name .. "/sh_init.lua") end
		include("gmodadminsuite/modules/" .. module_name .. "/sh_init.lua")
		init = true
	end
	if (file.Exists("gmodadminsuite/modules/" .. module_name .. "/cl_init.lua", "LUA")) then
		if (SERVER) then AddCSLuaFile("gmodadminsuite/modules/" .. module_name .. "/cl_init.lua") end
		if (CLIENT) then include("gmodadminsuite/modules/" .. module_name .. "/cl_init.lua") end
		init = true
	end
	if (SERVER and file.Exists("gmodadminsuite/modules/" .. module_name .. "/sv_init.lua", "LUA")) then
		include("gmodadminsuite/modules/" .. module_name .. "/sv_init.lua")
		init = true
	end

	local friendly_name
	if (SERVER) then
		friendly_name = GAS.Modules.Info[module_name].Name
	else
		friendly_name = GAS:Phrase("module_name", module_name)
	end
	if (SERVER) then
		if (GAS.Modules.Config.Enabled[module_name] == nil and GAS.Modules.Info[module_name].DefaultEnabled == true) then
			GAS.Modules.Config.Enabled[module_name] = true
			save_config = true
		end
		if (GAS.Modules.Config.Enabled[module_name]) then
			GAS:HeaderPrint("= " .. friendly_name, GAS_PRINT_COLOR_GOOD)
		else
			GAS:HeaderPrint("X " .. friendly_name, GAS_PRINT_COLOR_BAD)
		end
	elseif (init) then
		GAS:HeaderPrint(" " .. friendly_name, GAS_PRINT_COLOR_GOOD)
	end
end

GAS:EndHeader()

if (save_config) then
	GAS:SaveConfig("modules", GAS.Modules.Config)
end

if (CLIENT) then
	GAS:InitPostEntity(function()
		GAS:GetConfig("modules", function(config)
			GAS.Modules.Config = config
			for module_name, enabled in pairs(GAS.Modules.Config.Enabled) do
				if (not enabled) then continue end
				GAS.Modules:LoadModule(module_name, true)
			end
		end)
	end)
else
	for module_name, enabled in pairs(GAS.Modules.Config.Enabled) do
		if (not enabled) then continue end
		GAS.Modules:LoadModule(module_name, true)
	end
end
--PATH lua/gmodadminsuite/sh_permissions.lua:
if (SERVER) then AddCSLuaFile() end

if (SERVER) then
	local function OpenPermissions_Init()
		GAS:unhook("OpenPermissions:Ready", "GAS:OpenPermissions")

		GAS.OpenPermissions = OpenPermissions:RegisterAddon("gmodadminsuite", {
			Name = "GmodAdminSuite",
			Color = Color(30,34,42),
			Icon = "icon16/shield.png",
			Logo = {
				Path = "gmodadminsuite/gmodadminsuite.vtf",
				Width = 256,
				Height = 256
			}
		})

		GAS.OpenPermissions:AddToTree({
			Label = "See IP Addresses",
			Icon = "icon16/server_connect.png",
			Value = "see_ip_addresses",
			Default = OpenPermissions.CHECKBOX.CROSSED
		})

		local modules_tree = GAS.OpenPermissions:AddToTree({
			Label = "Modules",
			Icon = "icon16/server.png"
		})

		for module_name, module_data in pairs(GAS.Modules.Info) do
			if (not module_data.OperatorOnly and not module_data.NoMenu and not module_data.Hidden and not module_data.Public) then
				modules_tree:AddToTree({
					Label = module_data.Name,
					Value = module_name,
					Tip = "Can access the menu of " .. module_data.Name .. "?",
					Icon = module_data.Icon
				})
			end
		end
	end
	if (OpenPermissions_Ready == true) then
		OpenPermissions_Init()
	else
		GAS:hook("OpenPermissions:Ready", "GAS:OpenPermissions", OpenPermissions_Init)
	end
end

function GAS:CanAccessMenu(ply)
	if (OpenPermissions:IsOperator(ply)) then return true end
	for module_name in pairs(GAS.Modules.Config.Enabled) do
		if (OpenPermissions:HasPermission(ply, "gmodadminsuite/" .. module_name)) then
			return true
		end
	end
	return false
end
--PATH lua/autorun/imagetool_init.lua:
return gluapack()()
--PATH lua/imagetool/cl_image.lua:
return gluapack()()
--PATH lua/autorun/install_tfa_base.lua:
return gluapack()()
--PATH lua/autorun/jawa.lua:
return gluapack()()
--PATH lua/autorun/krennic.lua:
player_manager.AddValidModel( "navy krennic", 		"models/navy/gnavykrennic.mdl" );
list.Set( "PlayerOptionsModel", "navy krennic", 	"models/navy/gnavykrennic.mdl" );
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_lscs_convar.lua:
-- dynamic light
local cvarDynamicLight = CreateClientConVar( "lscs_dynamiclight", 1, true, false)

LSCS.DynamicLight = cvarDynamicLight and cvarDynamicLight:GetBool() or false

cvars.AddChangeCallback( "lscs_dynamiclight", function( convar, oldValue, newValue ) 
	LSCS.DynamicLight = tonumber( newValue ) ~=0
end)


-- impact effects
local cvarImpactEffects = CreateClientConVar( "lscs_impacteffects", 1, true, false)

LSCS.ImpactEffects = cvarImpactEffects and cvarImpactEffects:GetBool() or false

cvars.AddChangeCallback( "lscs_impacteffects", function( convar, oldValue, newValue ) 
	LSCS.ImpactEffects = tonumber( newValue ) ~=0
end)


-- trail detail
local cvarSaberTrailDetail = CreateClientConVar( "lscs_traildetail", 100, true, false)

LSCS.SaberTrailDetail  = cvarSaberTrailDetail and (cvarSaberTrailDetail:GetInt() / 100) or 1

cvars.AddChangeCallback( "lscs_traildetail", function( convar, oldValue, newValue ) 
	LSCS.SaberTrailDetail = math.Clamp( tonumber( newValue ), 0, 100 ) / 100
end)


-- host timescale
local cVarTimeScale = GetConVar( "host_timescale" )

LSCS.TimeScale = cVarTimeScale and cVarTimeScale:GetFloat() or 1

cvars.AddChangeCallback( "host_timescale", function( convar, oldValue, newValue ) 
	LSCS.TimeScale = tonumber( newValue )
end)


-- hud should draw
local cvarDrawHud = CreateClientConVar( "lscs_drawhud", 1, true, false)

LSCS.DrawHud = cvarDrawHud and cvarDrawHud:GetBool() or false

cvars.AddChangeCallback( "lscs_drawhud", function( convar, oldValue, newValue ) 
	LSCS.DrawHud = tonumber( newValue ) ~=0
end)
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_lscs_thirdperson.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_crafting.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_forcepowers.lua:

if SERVER then
	util.AddNetworkString( "lscs_force_anims" )
	util.AddNetworkString( "lscs_force_use" )
	util.AddNetworkString( "lscs_start_jump" )

	function LSCS:PlayVCDSequence( ply, anim, start )
		start = start or 0

		if not IsValid( ply ) then return end

		net.Start( "lscs_force_anims" ) 
			net.WriteEntity( ply )
			net.WriteString( anim )
			net.WriteFloat( start )
		net.Broadcast()

		ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_GRENADE, ply:LookupSequence( anim ), start, true )
	end

	function LSCS:ForceApply( Ent, Vel, att )
		if Ent.Alive and not Ent:Alive() then return end
		if Ent.GetObserverMode and Ent:GetObserverMode() ~= OBS_MODE_NONE then return end

		if hook.Run( "LSCS:PlayerCanManipulate", att, Ent ) then return end

		local StartPos = att:GetShootPos()
		local EndPos = Ent:LocalToWorld( Ent:OBBCenter() )

		local tr = util.TraceLine( {
			start = StartPos,
			endpos = EndPos,
			mask = MASK_SHOT,
			filter = att,
		} )

		if tr.Entity ~= Ent then return end

		if Ent.loco then
			Ent:SetPos( Ent:GetPos() + Vector(0,0,50) )
			Ent.loco:SetVelocity( Vel )
			local effectdata = EffectData()
				effectdata:SetOrigin( Ent:GetPos() )
				effectdata:SetEntity( Ent )
			util.Effect( "force_effects", effectdata, true, true )
		else
			local Phys = Ent:GetPhysicsObject()

			if IsValid( Phys ) and not Ent:IsPlayer() then
				Ent:SetPhysicsAttacker( att, 5 )

				if Phys:IsMotionEnabled() and Ent:GetMoveType() ~= MOVETYPE_NONE then
					Phys:Wake()

					if Ent:GetClass() == "prop_ragdoll" then
						for i = 1, Ent:GetPhysicsObjectCount() do
							local bone = Ent:GetPhysicsObjectNum( i )

							if bone and bone.IsValid and bone:IsValid() then
								bone:AddVelocity(  Vel )
							end
						end
					else
						if Ent:IsNPC() and Ent:GetMoveType() == MOVETYPE_STEP then
							local d = DamageInfo()
							d:SetDamage( 50 )
							d:SetDamageForce( Vel * 100 )
							d:SetAttacker( att )
							d:SetDamageType( DMG_CRUSH ) 
							d:SetDamagePosition( EndPos )

							Ent:TakeDamageInfo( d )
						else
							Phys:SetVelocity( Vel )
						end
					end

					local effectdata = EffectData()
						effectdata:SetOrigin( Ent:GetPos() )
						effectdata:SetEntity( Ent )
					util.Effect( "force_effects", effectdata, true, true )
				end
			else
				if Ent.IsPlayer and Ent:IsPlayer() then
					local effectdata = EffectData()
						effectdata:SetOrigin( Ent:GetPos() )
						effectdata:SetEntity( Ent )
					util.Effect( "force_effects", effectdata, true, true )

					if Ent:OnGround() then
						Ent:SetPos( Ent:GetPos() + Vector(0,0,10) )
					end

					Ent:SetVelocity( Vel )
				end
			end
		end
	end

	hook.Add( "StartCommand", "!!!!!!lscs_forcejumpforcer", function( ply, cmd )
		if (ply._lscsForceJumpTime or 0) > CurTime() then
			cmd:SetButtons( bit.bor( cmd:GetButtons(), IN_JUMP ) )
		end
	end )

	local TICK_MIN = 1/14
	local NEXT_THINK = 0

	hook.Add( "Think", "!!!!lscs_unforgiveable_playerGetAll_loop_in_think_hook", function()
		local TIME = CurTime()

		if FrameTime() <= TICK_MIN then -- below this tickrate we run risk skipping the correct timing...
			if NEXT_THINK > TIME then return end

			NEXT_THINK = TIME + 0.1 -- slow it down to be nice to the server. The HUD is specifically designed to mask this slow updating.
		end

		for _, ply in ipairs( player.GetAll() ) do
			if not ply:lscsGetForceAllowed() then continue end

			hook.Run( "LSCS:PlayerForcePowerThink", ply, TIME )

			if (ply._lscsNextForceRegen or 0) > TIME then continue end

			if not ply:InVehicle() then
				if not ply:OnGround() and ply:GetMoveType() ~= MOVETYPE_NOCLIP then continue end
			end

			local OldValue = ply:lscsGetForce()
			local NewValue = math.min(OldValue + ply:lscsGetForceRegenAmount(),ply:lscsGetMaxForce())

			if NewValue == OldValue then continue end

			ply:lscsSetForce( NewValue )
		end
	end )

	net.Receive( "lscs_force_use", function( len, ply )
		if not IsValid( ply ) then return end
		if not ply:Alive() then return end

		if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

		local ID = net.ReadInt( 8 )
		local Activate = net.ReadBool()
		local ForcePowers = ply:lscsGetForceAbilities()

		local selectedF = ForcePowers[ ID ]

		if not selectedF then return end

		local item = selectedF.item

		if not item then return end

		if not ply._lscsUsedPowers then
			ply._lscsUsedPowers = {}
		end

		if Activate then
			if not ply:lscsGetForceAllowed() then return end

			if hook.Run( "LSCS:OnPlayerForceUse", ply, item.id, item ) == false then return end

			ply._lscsUsedPowers[ ID ] = true

			ProtectedCall( function() LSCS.Force[ item.id ].StartUse( ply ) end )
		else
			if ply._lscsUsedPowers[ ID ] then
				ply._lscsUsedPowers[ ID ] = nil

				ProtectedCall( function() LSCS.Force[ item.id ].StopUse( ply ) end )
			end
		end
	end )

	hook.Add( "LSCS:OnPlayerEquippedItem", "!!!!lscs_forcepower_equip_handler", function( ply, item )
		if not IsValid( ply ) or not item then return end

		if item.type == "force" then
			ProtectedCall( function() LSCS.Force[ item.id ].Equip( ply ) end )
		end
	end)

	hook.Add( "LSCS:OnPlayerUnEquippedItem", "!!!!lscs_forcepower_unequip_handler", function( ply, item )
		if not IsValid( ply ) or not item then return end

		if item.type == "force" then
			ProtectedCall( function() LSCS.Force[ item.id ].UnEquip( ply ) end )
		end
	end)

	hook.Add( "PlayerDeath", "!!!!lscs_forcepower_playerdeath", function( ply )
		if not ply._lscsUsedPowers then return end

		local ForcePowers = ply:lscsGetForceAbilities()

		for ID, _ in pairs( ply._lscsUsedPowers ) do
			ProtectedCall( function() LSCS.Force[ ForcePowers[ ID ].item.id ].StopUse( ply ) end )
			ply._lscsUsedPowers[ ID ]= nil
		end

		net.Start("lscs_force_use")
		net.Send( ply )
	end )
else
	local X = ScrW() - 110
	local Y = ScrH() - 100

	local circles = include("includes/circles/circles.lua") -- i love this thing

	-- removed for performance optimization
	--local FP_BG = circles.New(CIRCLE_OUTLINED, 86, 0, 0, 22)
	--FP_BG:SetX( X )
	--FP_BG:SetY( Y )

	local FP = circles.New(CIRCLE_OUTLINED, 85, 0, 0, 20)
	FP:SetX( X )
	FP:SetY( Y )

	local smAlpha = 0

	local ForceIcon = Material( "lscs/ui/force_hud.png" )
	local ForceBG = Material( "lscs/ui/hud_fp.png" ) -- added for performance optimization

	hook.Add( "InitPostEntity", "!!!lscs_bullshit", function()
		local ply = LocalPlayer()
		ply._lscsOldIsMax = CurTime() - 1
	end )

	hook.Add( "HUDPaint", "!!!!lscs_ShowForceMana", function()
		if LSCS:HUDShouldHide( LSCS_HUD_POINTS_FORCE ) then return end

		local ply = LocalPlayer()

		if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

		local Time = CurTime()

		local F = ply:lscsGetForce()
		local Fmax = ply:lscsGetMaxForce()
		local wep = ply:GetActiveWeapon()

		local IsMax = F == Fmax

		if IsMax then
			if not ply._lscsOldIsMax then
				ply._lscsOldIsMax = Time + 5 -- fade out in 5 seconds
			end
		else
			ply._lscsOldIsMax = nil
		end

		local smRate = RealFrameTime()
		local tAlpha = (IsMax and ply._lscsOldIsMax < Time) and 0 or 1

		smAlpha = smAlpha + math.Clamp(tAlpha - smAlpha,-smRate * 3,smRate * 6)

		if IsValid( wep ) and wep.LSCS then
			if ply:InVehicle() then
				if ply:GetAllowWeaponsInVehicle() then
					smAlpha = 1
				end
			else
				smAlpha = 1
			end
		end

		if smAlpha == 0 then return end

		local segmentLength = 5
		local segmentSpace = 15
		local segmentDist = segmentLength + segmentSpace
		local segmentActiveValue = (260 / Fmax) * F

		surface.SetMaterial( ForceIcon )
		surface.SetDrawColor( Color( 0, 0, 0, 200 * smAlpha ) )
		surface.DrawTexturedRectRotated( X + 5, Y + 15, 124,124, 0 )
		surface.DrawTexturedRectRotated( X + 5, Y + 15, 132,132, 0 )
		surface.SetDrawColor( Color( 255, 255, 255, 255 * smAlpha ) )
		surface.DrawTexturedRectRotated( X + 5, Y + 15, 128,128, 0 )

		-- added for performance optimization
		surface.SetMaterial( ForceBG )
		surface.SetDrawColor( Color( 0, 0, 0, 200 * smAlpha ) )
		surface.DrawTexturedRect( X - 146, Y - 156, 256,256, 0 )

		draw.NoTexture()

		--FP_BG:SetColor( Color(0, 0, 0, 200 * smAlpha) ) -- removed for performance optimization
		FP:SetColor( Color(0, 127, 255, 255 * smAlpha) )

		-- the way im using circles is probably not ideal...  but fuck it, it looks so awesome.  This is probably the thing that will pop up in your profiler
		local Offset = 150
		for A = 0, 260 - segmentDist, segmentDist do
			local Start = Offset + A
			-- removed for performance optimization
			--FP_BG:SetStartAngle( Start - 1 )
			--FP_BG:SetEndAngle( Start  + segmentLength + 1 )
			--FP_BG()

			if A < segmentActiveValue then
				FP:SetStartAngle( Start  )
				FP:SetEndAngle( Start  + segmentLength )
				FP()
			end
		end
	end )

	net.Receive( "lscs_start_jump", function( len )
		local ply = LocalPlayer()

		ply.m_bJumping = true

		ply.m_bFirstJumpFrame = true
		ply.m_flJumpStartTime = CurTime()

		ply:AnimRestartMainSequence()
	end )

	net.Receive( "lscs_force_anims", function( len )
		local ply = net.ReadEntity()
		
		if not IsValid( ply ) then return end

		local seq = net.ReadString()
		local start = net.ReadFloat()

		ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_GRENADE, ply:LookupSequence( seq ), start, true )
	end )
end
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_player.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/butterfly.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/crescentdual.lua:
COMBO.id = "crescentdual"
COMBO.PrintName = "Crescent {Dual Wield}"
COMBO.Author = "Kong"
COMBO.Description = "A long forgotten form of saber combat, focusing on the percise cuts and flow of movement. Rather then relying on powerful strikes, quick cuts are made."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.DamageMultiplier = 1.5
COMBO.BPDrainPerHit = 50

COMBO.HoldType = "wos-meleeelegant-type"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "combo32",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "pure_h_s1_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["___D"] = {
		AttackAnim = "a_combo2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["W__D"] = {
		AttackAnim = "combo2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	},
	["WA__"] = {
		AttackAnim = "combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["__SD"] = {
		AttackAnim = "a_combo2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["_AS_"] = {
		AttackAnim = "combo1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["W___"] = {
		AttackAnim = "phalanx_b_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
}


--PATH addons/[miecze] moce i hilty/lua/lscs/combos/determination.lua:
COMBO.id = "shiicho"
COMBO.PrintName = "Determination"
COMBO.Author = ""
COMBO.Description = ""

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos-melee-type"

COMBO.DamageMultiplier = 1
COMBO.BPDrainPerHit = 25
COMBO.BlockDistanceNormal = 45 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 15 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.


COMBO.Attacks = {
	["FRONT_DASH"] = {
		AttackAnim = "b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 200 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["ROLL_RIGHT"] = {
		AttackAnim = "",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "h_c3_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "phalanx_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "judge_b_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "judge_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "judge_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "judge_h_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "phalanx_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "phalanx_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "judge_r_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
LSCS:Reload()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/determinationdual.lua:
COMBO.id = "shiichotwo"
COMBO.PrintName = "Determination{Experienced}"
COMBO.Author = "RareLogan"
COMBO.Description = ""

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "wos-melee-type"

COMBO.DamageMultiplier = 1.5
COMBO.BPDrainPerHit = 50
COMBO.BlockDistanceNormal = 45 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 15 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.

COMBO.Attacks = {
	["FRONT_DASH"] = {
		AttackAnim = "b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "h_c3_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "phalanx_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "judge_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "judge_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "h_c1_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "h_c2_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "phalanx_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "phalanx_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "b_c3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/jarkai.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/juggernaut.lua:
COMBO.id = "juggernaut"
COMBO.PrintName = "Juggernaut"
COMBO.Author = "Luna"
COMBO.Description = "Hit's hard but easy to counter due to it's slow nature"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "melee2"

COMBO.DamageMultiplier = 1.15
COMBO.BPDrainPerHit = 50

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "h_c3_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["W__D"] = {
		AttackAnim = "vanguard_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.5,
	},
	["WA__"] = {
		AttackAnim = "vanguard_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.5,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "judge_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/juyo-vaapad.lua:
COMBO.id = "vaapad"
COMBO.PrintName = "Juyo-Vaapad(VII)"
COMBO.Author = "RareLogan"
COMBO.Description = ""

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos-meleestamina-type"

COMBO.DamageMultiplier = 1.75
COMBO.BPDrainPerHit = 75

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_a_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "pure_a_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "judge_h_s2_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "ryoku_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "wos_judge_h_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "pure_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "judge_h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "judge_h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "ryoku_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "ryoku_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "wos_phalanx_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/juyo-vaapaddual.lua:
return gluapack()()
--PATH lua/lscs/combos/master_form5.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/ninja.lua:
COMBO.id = "freak"
COMBO.PrintName = "Freak"
COMBO.Author = "UCCROW"
COMBO.Description = "freak ???"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos-ninja-corvinus"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)
			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 2 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 1 )
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.9,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "ryoku_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "ryoku_b_s2_t2",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["____"] = {
		AttackAnim = "pure_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(4500,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "pure_h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(400,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.3, Vector(225,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.7, 0.6, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(nil, 1)
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.0,
	},
	["__S_"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,-150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.2, Vector(0,-80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.6, 0.4, Vector(0,0,0) )

			weapon:DoAttackSound(1, 1)
			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)
			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["___D"] = {
		AttackAnim = "pure_b_s2_t3",
		AttackAnimStart = 0.3,
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.2, Vector(0,80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.6, 0.4, Vector(0,0,0) )

			weapon:DoAttackSound( math.random(1,2), 1 )

			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(nil, 1)
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["W__D"] = {
		AttackAnim = "pure_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(150,150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.3, Vector(80,80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 1, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.9, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.0,
	},
	["WA__"] = {
		AttackAnim = "pure_b_right_t3",
		AttackAnimStart = 0.1,
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(150,-150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.3, Vector(80,-80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 1, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.9, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.0,
	},
	["__SD"] = {
		AttackAnim = "pure_b_s3_t2",
		AttackAnimStart = 0.2,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(2, 1)
			timer.Simple(0.35, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(math.random(1,2), 1)
			end)

			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(150,80,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.5, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["_AS_"] = {
		AttackAnim = "pure_b_s2_t2",
		AttackAnimStart = 0.05,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			timer.Simple(0.35, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(math.random(1,2), 1)
			end)
			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(150,-80,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.5, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["W___"] = {
		AttackAnim = "phalanx_b_s4_t1",
		AttackAnimStart = 0,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(nil,1)
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/visigothdual.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/warrior.lua:
COMBO.id = "warrior"
COMBO.PrintName = "Warrior"
COMBO.Author = "RareLogan"
COMBO.Description = "A more experienced blade wielder would use this stance."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos-test-type"

COMBO.DamageMultiplier = 1.15
COMBO.BPDrainPerHit = 50

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "h_c3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "phalanx_b_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "h_c3_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "phalanx_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "phalanx_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "judge_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "judge_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "judge_h_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "judge_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "phalanx_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "judge_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_midnight.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_breach.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_choke_expert.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_enlargeself.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_grab.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_grab.lua:
local force = {}
force.PrintName = "Grab"
force.Author = "htvgamer1000"
force.Description = "Use the force to grab your target"
force.id = "grab"
force.OnClk =  function( ply, TIME )
    if not IsValid( ply.WindTarget ) then return end
    if ply.WindTarget:IsPlayer() and not ply.WindTarget:Alive() then ply.WindTarget = nil return end
    local vec = ( ( ply:EyePos() + ply:GetAimVector()*ply.WindDistance  ) - ply.WindTarget:GetPos() )
    local vec2 = ( ( ply:EyePos() + ply:GetAimVector()*2*ply.WindDistance  ) - ply.WindTarget:GetPos() )

    if ply.WindTarget:IsPlayer() or ply.WindTarget:IsNPC() then
        ply.WindTarget:SetLocalVelocity( vec*10 )
    else
        local phys = ply.WindTarget:GetPhysicsObject()
        phys:SetVelocity( vec*10 )
    end

    ply:lscsTakeForce( 1 )

    if ply:lscsGetForce() < 1 then
        local ed = EffectData()
        ed:SetOrigin( ply.WindTarget:GetPos() + Vector( 0, 0, 36 ) )
        ed:SetRadius( 128 )
        util.Effect( "rb655_force_repulse_out", ed, true, true )
        if ply.WindTarget:IsPlayer() then
            if timer.Exists("force_whirlwind_p1_" .. ply.WindTarget:SteamID64()) then
                timer.Remove("force_whirlwind_p1_" .. ply.WindTarget:SteamID64())
            end
            ply.WindTarget:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
        end
        ply.WindTarget = nil
    end

    if not ply:KeyReleased( IN_ATTACK2 ) then return end

    local ed = EffectData()
    ed:SetOrigin( ply.WindTarget:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )
    if ply.WindTarget:IsPlayer() or ply.WindTarget:IsNPC() then
        ply.WindTarget:SetLocalVelocity( vec2*10 )
    else
        local phys = ply.WindTarget:GetPhysicsObject()
        phys:SetVelocity( vec2*10 )
    end
    if ply.WindTarget:IsPlayer() then
        if timer.Exists("force_whirlwind_p1_" .. ply.WindTarget:SteamID64()) then
            timer.Remove("force_whirlwind_p1_" .. ply.WindTarget:SteamID64())
        end
        ply.WindTarget:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
    end
    ply.WindTarget = nil
end
force.StartUse = function( ply )
    if ply:lscsGetForce() < 1 then return end
    if IsValid( ply.WindTarget ) then return end
    local tr = util.TraceLine( util.GetPlayerTrace( ply ) )
    local dist = tr.HitPos:Distance( ply:GetPos() )
    if not tr.Entity then return end
    if tr.LFS then return end
    if string.match(tr.Entity:GetClass(), "_pod") then return end
    if dist >= 400 then return end
    ply.WindTarget = tr.Entity
    ply.WindDistance = dist

    return true
end
force.StopUse = function( ply )
    if not IsValid( ply.WindTarget ) then return end
    local ed = EffectData()
    ed:SetOrigin( ply.WindTarget:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )

    ply.WindTarget = nil
end
LSCS:RegisterForce( force )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_ignite.lua:
local force = {}
force.PrintName = "Ignite"
force.Author = "UCCROW"
force.Description = "Ignites a target using the Force."
force.id = "ignite" -- lowercase only
--force.Spawnable = false  -- uncomment to unlist in q-menu

--[[ 
-- adds a hook to Think with 0.1 second interval. Only uncomment if needed
force.OnClk = function(ply, TIME)
    print(TIME)
end
]]

force.Equip = function(ply)
    print("Ignite Force Power equipped!")
end

force.UnEquip = function(ply)
    print("Ignite Force Power unequipped!")
end

force.StartUse = function(ply)
    if ply:lscsGetForce() < 50 then return end -- Check if the player has enough Force points

    local target = FindTargetInView(ply, 200) -- We set a view range of 200 units

    if not IsValid(target) or (not target:IsPlayer() and not target:IsNPC()) then return end -- Exit if no valid target is found or the target is neither a player nor an NPC

    ply:lscsTakeForce(50) -- Deduct Force points required to use the power

    ply:EmitSound("npc/combine_gunship/ping_search.wav") -- Play sound effect

    LSCS:PlayVCDSequence(ply, "wos_jedi_forceblast", 0.7) -- Play an animation

    BurnTarget(target) -- Call the function that performs the burning of the target

    -- Example of using particle system for visual effect
    local effectData = EffectData()
    effectData:SetStart(ply:GetPos()) -- Set the effect's starting point to the main player's location
    effectData:SetOrigin(target:GetPos()) -- Make the effect go to the target's location
    effectData:SetScale(1)
    effectData:SetEntity(ply) -- Set the entity that the effect is linked to as the main player
    util.Effect("corvinus_ignite_effect", effectData)
end

-- Function to find a target (player or NPC) in view within a specific distance
function FindTargetInView(ply, distance)
    local trace = util.TraceLine({
        start = ply:EyePos(),
        endpos = ply:EyePos() + ply:GetAimVector() * distance,
        filter = function(ent) return (ent:IsPlayer() or ent:IsNPC()) and ent ~= ply end
    })

    return trace.Entity
end

-- Function to ignite the target (player or NPC)
function BurnTarget(target)
    if IsValid(target) then
        local igniteDuration = 5 -- Duration the target will burn
        local damagePerSecond = 2 -- Amount of damage dealt per second

        if not target:IsOnFire() then
            target:Ignite(igniteDuration, 0) -- Ignite the target for the specified duration

            timer.Create("fireDamageTimer_" .. target:EntIndex(), 1, igniteDuration, function()
                if IsValid(target) and target:IsOnFire() then
                    target:TakeDamage(damagePerSecond, game.GetWorld(), game.GetWorld())
                else
                    timer.Remove("fireDamageTimer_" .. target:EntIndex())
                end
            end)
        end
    end
end

force.StopUse = function(ply)
    -- Called when the force power key is released
end

LSCS:RegisterForce(force)

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_wizforce_shield.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_inq.lua:
return gluapack()()
--PATH lua/lscs/content/lscs_blades.lua:
return gluapack()()
--PATH lua/autorun/lvs_init.lua:
return gluapack()()
--PATH lua/autorun/lvs_init.lua:

LVS = istable( LVS ) and LVS or {}

LVS.VERSION = 325
LVS.VERSION_GITHUB = 0
LVS.VERSION_TYPE = ".WS"
LVS.VERSION_ADDONS_OUTDATED = false

LVS.KEYS_CATEGORIES = {}
LVS.KEYS_REGISTERED = {}
LVS.pSwitchKeys = {[KEY_1] = 1,[KEY_2] = 2,[KEY_3] = 3,[KEY_4] = 4,[KEY_5] = 5,[KEY_6] = 6,[KEY_7] = 7,[KEY_8] = 8,[KEY_9] = 9,[KEY_0] = 10}
LVS.pSwitchKeysInv = {[1] = KEY_1,[2] = KEY_2,[3] = KEY_3,[4] = KEY_4,[5] = KEY_5,[6] = KEY_6,[7] = KEY_7,[8] = KEY_8,[9] = KEY_9,[10] = KEY_0}

LVS.ThemeColor = Color(127,0,0,255)

LVS.WHEEL_BRAKE = 1
LVS.WHEEL_STEER_NONE = 2
LVS.WHEEL_STEER_FRONT = 3
LVS.WHEEL_STEER_REAR = 4

LVS.WEAPONS = {
	["DEFAULT"] = {
		Icon = Material("lvs/weapons/bullet.png"),
		Ammo = 9999,
		Delay = 0,
		HeatRateUp = 0.2,
		HeatRateDown = 0.25,
		Attack = function( ent ) end,
		StartAttack = function( ent ) end,
		FinishAttack = function( ent ) end,
		OnSelect = function( ent, old ) end,
		OnDeselect = function( ent, new ) end,
		OnThink = function( ent, active ) end,
		OnOverheat = function( ent ) end,
		OnRemove = function( ent ) end,
		OnReload = function( ent ) end,
	},
}

function LVS:GetVersion()
	return LVS.VERSION
end

function LVS:AddKey(name, category, printname, cmd, default)
	local data = {
		printname = printname,
		id = name,
		category = category,
		cmd = cmd,
	}

	if not LVS.KEYS_CATEGORIES[ category ] then
		LVS.KEYS_CATEGORIES[ category ] = {}
	end

	if SERVER then
		table.insert( LVS.KEYS_REGISTERED, data )
	else
		if default then
			if isstring( default ) then
				local Key = input.LookupBinding( default )

				if Key then
					default = input.GetKeyCode( Key )
				else
					default = 0
				end
			end
		else
			default = 0
		end

		data.default = default

		table.insert( LVS.KEYS_REGISTERED, data )

		CreateClientConVar( cmd, default, true, true )
	end
end

function LVS:CheckUpdates()
	http.Fetch("https://raw.githubusercontent.com/SpaxscE/lvs_base/main/lua/autorun/lvs_init.lua", function(contents,size) 
		local Entry = string.match( contents, "LVS.VERSION%s=%s%d+" )

		if Entry then
			LVS.VERSION_GITHUB = tonumber( string.match( Entry , "%d+" ) ) or 0
		else
			LVS.VERSION_GITHUB = 0
		end

		if LVS.VERSION_GITHUB == 0 then
			print("[LVS] - Framework: latest version could not be detected, You have Version: "..LVS:GetVersion())
		else
			if LVS:GetVersion() >= LVS.VERSION_GITHUB then
				print("[LVS] - Framework is up to date, Version: "..LVS:GetVersion())
			else
				print("[LVS] - Framework: a newer version is available! Version: "..LVS.VERSION_GITHUB..", You have Version: "..LVS:GetVersion())

				if LVS.VERSION_TYPE == ".GIT" then
					print("[LVS] - Framework: get the latest version at https://github.com/SpaxscE/lvs_base")
				else
					print("[LVS] - Framework: restart your game/server to get the latest version!")
				end

				if CLIENT then 
					timer.Simple(18, function() 
						chat.AddText( Color( 255, 0, 0 ), "[LVS] - Framework: a newer version is available!" )
					end)
				end
			end
		end

		local Delay = 0
		local addons = file.Find( "data_static/lvs/*", "GAME" )

		for _, addonFile in pairs( addons ) do
			local addonInfo = file.Read( "data_static/lvs/"..addonFile, "GAME" )

			if not addonInfo then continue end

			local data = string.Explode( "\n", addonInfo )

			local wsid = string.Replace( addonFile, ".txt", "" )
			local addon_name = wsid
			local addon_url
			local addon_version

			for _, entry in pairs( data ) do
				if string.StartsWith( entry, "url=" ) then
					addon_url = string.Replace( entry, "url=", "" )
				end

				if string.StartsWith( entry, "version=" ) then
					addon_version = string.Replace( entry, "version=", "" )
				end

				if string.StartsWith( entry, "name=" ) then
					addon_name = string.Replace( entry, "name=", "" )
				end
			end

			if not addon_url or not addon_version then continue end

			addon_version = tonumber( addon_version )

			Delay = Delay + 1.5

			timer.Simple( Delay, function()
				http.Fetch(addon_url, function(con,_) 
					local addon_entry = string.match( con, "version=%d+" )

					local addon_version_git = 0

					if addon_entry then
						addon_version_git = tonumber( string.match( addon_entry, "%d+" ) ) or 0
					end

					local wsurl = "https://steamcommunity.com/sharedfiles/filedetails/?id="..wsid

					if addon_version_git == 0 then
						print("[LVS] latest version of "..addon_name.." ( "..wsurl.." ) could not be detected, You have Version: "..addon_version)
					else
						if addon_version_git > addon_version then
							print("[LVS] - "..addon_name.." ( "..wsurl.." ) is out of date!")

							if CLIENT then 
								timer.Simple(18, function() 
									chat.AddText( Color( 255, 0, 0 ),"[LVS] - "..addon_name.." is out of date!" )
								end)
							end

							LVS.VERSION_ADDONS_OUTDATED = true

						else
							print("[LVS] - "..addon_name.." is up to date, Version: "..addon_version)
						end
					end
				end)
			end )
		end
	end)
end

function LVS:GetWeaponPreset( name )
	if not LVS.WEAPONS[ name ] then return table.Copy( LVS.WEAPONS["DEFAULT"] ) end

	return table.Copy( LVS.WEAPONS[ name ] )
end

function LVS:AddWeaponPreset( name, data )
	if not isstring( name ) or not istable( data ) then return end

	LVS.WEAPONS[ name ] = data
end

function LVS:GetVehicleTypes()
	local VehicleTypes = {}

	for s, v in pairs( scripted_ents.GetList() ) do
		if not v.t or not isfunction( v.t.GetVehicleType ) then continue end

		local vehicletype = v.t:GetVehicleType()

		if not isstring( vehicletype ) or string.StartsWith( vehicletype, "LBase" ) or table.HasValue( VehicleTypes, vehicletype ) then continue end

		table.insert( VehicleTypes, vehicletype )
	end

	return VehicleTypes
end

AddCSLuaFile("lvs_framework/init.lua")
include("lvs_framework/init.lua")
--PATH lua/lvs_framework/autorun/lvs_damagenotify.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_hookers.lua:

hook.Add( "InitPostEntity", "!!!lvsBullshitFixer", function()
	timer.Simple(1, function()
		LVS.MapDoneLoading = true
	end)

	if SERVER then return end

	-- this needs to be here to make sure all sents are registered
	for _, vehicletype in ipairs( LVS:GetVehicleTypes() ) do
		CreateClientConVar( "lvs_mouseaim_type_"..vehicletype, 0, true, false)
	end
end )

local function SetDistance( vehicle, ply )
	local iWheel = ply:GetCurrentCommand():GetMouseWheel()

	if iWheel == 0 or not vehicle.SetCameraDistance then return end

	local newdist = math.Clamp( vehicle:GetCameraDistance() - iWheel * 0.03 * ( 1.1 + vehicle:GetCameraDistance() ), -1, 10 )

	vehicle:SetCameraDistance( newdist )
end

local function SetHeight( vehicle, ply )
	local iWheel = ply:GetCurrentCommand():GetMouseWheel()

	if iWheel == 0 or not vehicle.SetCameraHeight then return end

	local newdist = math.Clamp( vehicle:GetCameraHeight() - iWheel * 0.03 * ( 1.1 + vehicle:GetCameraHeight() ), -1, 10 )

	vehicle:SetCameraHeight( newdist )
end

hook.Add( "VehicleMove", "!!!!lvs_vehiclemove", function( ply, vehicle, mv )
	if not ply.lvsGetVehicle then return end

	local veh = ply:lvsGetVehicle()

	if not IsValid( veh ) then return end

	if SERVER and ply:lvsKeyDown( "VIEWDIST" ) then
		if ply:lvsKeyDown( "VIEWHEIGHT" ) then
			SetHeight( vehicle, ply )
		else
			SetDistance( vehicle, ply )
		end
	end

	if CLIENT and not IsFirstTimePredicted() then return end
	
	local KeyThirdPerson = ply:lvsKeyDown("THIRDPERSON")

	if ply._lvsOldThirdPerson ~= KeyThirdPerson then
		ply._lvsOldThirdPerson = KeyThirdPerson

		if KeyThirdPerson and vehicle.SetThirdPersonMode then
			vehicle:SetThirdPersonMode( not vehicle:GetThirdPersonMode() )
		end
	end

	return true
end )

hook.Add("CalcMainActivity", "!!!lvs_playeranimations", function(ply)
	if not ply.lvsGetVehicle then return end

	local Ent = ply:lvsGetVehicle()

	if IsValid( Ent ) then
		local A,B = Ent:CalcMainActivity( ply )

		if A and B then
			return A, B
		end
	end
end)

hook.Add("UpdateAnimation", "!!!lvs_playeranimations", function( ply, velocity, maxseqgroundspeed )
	if not ply.lvsGetVehicle then return end

	local Ent = ply:lvsGetVehicle()

	if not IsValid( Ent ) then return end

	return Ent:UpdateAnimation( ply, velocity, maxseqgroundspeed )
end)

hook.Add( "StartCommand", "!!!!LVS_grab_command", function( ply, cmd )
	if not ply.lvsGetVehicle then return end

	local veh = ply:lvsGetVehicle()

	if not IsValid( veh ) then return end

	veh:StartCommand( ply, cmd )
end )

hook.Add( "CanProperty", "!!!!lvsEditPropertiesDisabler", function( ply, property, ent )
	if ent.LVS and not ply:IsAdmin() and property == "editentity" then return false end
end )

LVS.ToolsDisable = {
	["rb655_easy_animation"] = true,
	["rb655_easy_bonemerge"] = true,
	["rb655_easy_inspector"] = true,
}
hook.Add( "CanTool", "!!!!lvsCanToolDisabler", function( ply, tr, toolname, tool, button )
	if LVS.ToolsDisable[ toolname ] and IsValid( tr.Entity ) and tr.Entity.LVS then return false end
end )

if CLIENT then
	local hide = {
		["CHudHealth"] = true,
		["CHudBattery"] = true,
		["CHudAmmo"] = true,
	}
	local function HUDShouldDrawLVS( name )
		if hide[ name ] then return false end
	end

	hook.Add( "LVS.PlayerEnteredVehicle", "!!!!lvs_player_enter", function( ply, veh )
		hook.Add( "HUDShouldDraw", "!!!!lvs_hidehud", HUDShouldDrawLVS )

		if not IsValid( veh ) then return end

		local cvar = GetConVar( "lvs_mouseaim_type" )

		if not cvar or cvar:GetInt() ~= 1 or not veh.GetVehicleType then return end

		local vehicletype = veh:GetVehicleType()

		local cvar_type = GetConVar( "lvs_mouseaim_type_"..vehicletype )
		local cvar_mouseaim = GetConVar( "lvs_mouseaim" )

		if not cvar_type or not cvar_mouseaim then return end

		cvar_mouseaim:SetInt( cvar_type:GetInt() )
	end )

	hook.Add( "LVS.PlayerLeaveVehicle", "!!!!lvs_player_exit", function( ply, veh )
		hook.Remove( "HUDShouldDraw", "!!!!lvs_hidehud" )
	end )

	hook.Add( "InitPostEntity", "!!!lvs_infmap_velocity_fixer", function()
		if not InfMap then

			hook.Remove( "InitPostEntity", "!!!lvs_infmap_velocity_fixer" )

			return
		end

		local meta = FindMetaTable( "Entity" )

		if not InfMapOriginalGetVelocity then
			InfMapOriginalGetVelocity = meta.GetVelocity
		end

		function meta:GetVelocity()
			local Velocity = InfMapOriginalGetVelocity( self )

			local EntTable = self:GetTable()

			if not EntTable.LVS and not EntTable._lvsRepairToolLabel then return Velocity end

			local Speed = Velocity:LengthSqr()

			local T = CurTime()

			if Speed > 10 then
				EntTable._infmapEntityVelocity = Velocity
				EntTable._infmapEntityVelocityTime = T + 0.6
			else
				if (EntTable._infmapEntityVelocityTime or 0) > T then
					return EntTable._infmapEntityVelocity or vector_origin
				end
			end

			return Velocity
		end
	end )

	return
end

local DamageFix = {
	["npc_hunter"] = true,
	["npc_stalker"] = true,
	["npc_strider"] = true,
	["npc_combinegunship"] = true,
	["npc_helicopter"] = true,
}

hook.Add( "EntityTakeDamage", "!!!_lvs_fix_vehicle_explosion_damage", function( target, dmginfo )
	if not target:IsPlayer() then
		if target.LVS then
			local attacker = dmginfo:GetAttacker()

			if IsValid( attacker ) and DamageFix[ attacker:GetClass() ] then
				dmginfo:SetDamageType( DMG_AIRBOAT )
				dmginfo:SetDamageForce( dmginfo:GetDamageForce():GetNormalized() * 15000 )
			end
		end

		return
	end

	local veh = target:lvsGetVehicle()

	if not IsValid( veh ) or dmginfo:IsDamageType( DMG_DIRECT ) then return end

	if target:GetCollisionGroup() == COLLISION_GROUP_PLAYER then return end

	dmginfo:SetDamage( 0 )
end )

hook.Add( "PlayerEnteredVehicle", "!!!!lvs_player_enter", function( ply, Pod )
	local veh = ply:lvsGetVehicle()

	if IsValid( veh ) then
		net.Start( "lvs_player_enterexit" )
			net.WriteBool( true )
			net.WriteEntity( veh )
		net.Send( ply )

		ply._lvsIsInVehicle = true

		if istable( veh.PlayerBoneManipulate ) then
			local ID = Pod:lvsGetPodIndex()
			local BoneManipulate = veh.PlayerBoneManipulate[ ID ]

			if BoneManipulate then
				ply._lvsStopBoneManipOnExit = true
				ply:lvsStartBoneManip()
			end
		end

		if LVS.FreezeTeams then
			local nTeam = ply:lvsGetAITeam()

			if veh:GetAITEAM() ~= nTeam then
				veh:SetAITEAM( nTeam )

				ply:PrintMessage( HUD_PRINTTALK, "[LVS] This Vehicle's AI-Team has been updated to: "..(LVS.TEAMS[ nTeam ] or "") )
			end
		end
	end

	if not Pod.HidePlayer then return end

	ply:SetNoDraw( true )

	if pac then pac.TogglePartDrawing( ply, 0 ) end
end )

hook.Add( "PlayerLeaveVehicle", "!!!!lvs_player_exit", function( ply, Pod )
	if ply._lvsIsInVehicle then
		net.Start( "lvs_player_enterexit" )
			net.WriteBool( false )
			net.WriteEntity( ply:lvsGetVehicle() )
		net.Send( ply )

		ply._lvsIsInVehicle = nil

		if ply._lvsStopBoneManipOnExit then
			ply._lvsStopBoneManipOnExit = nil

			ply:lvsStopBoneManip()
		end
	end

	if not Pod.HidePlayer then return end

	ply:SetNoDraw( false )

	if pac then pac.TogglePartDrawing( ply, 1 ) end
end )

hook.Add( "PlayerDisconnected", "!!!!lvs_player_reset_bonemanip_client", function(ply)
	if not ply._lvsStopBoneManipOnExit then return end

	ply._lvsStopBoneManipOnExit = nil

	ply:lvsStopBoneManip()
end )
--PATH lua/lvs_framework/autorun/lvs_soundscripts.lua:
return gluapack()()
--PATH lua/autorun/includes/extensions/sh_url.lua:
return gluapack()()
--PATH lua/mediaplayer/shared.lua:
MediaPlayer = MediaPlayer or {}
MP = MediaPlayer

include "utils.lua"
include "sh_cvars.lua"

--[[---------------------------------------------------------
	Config

	Store service API keys, etc.
-----------------------------------------------------------]]

MediaPlayer.config = {}

---
-- Apply configuration values to the mediaplayer config.
--
-- @param config	Table with configuration values.
--
function MediaPlayer.SetConfig( config )
	table.Merge( MediaPlayer.config, config )
end

---
-- Method for easily grabbing config value without checking that each fragment
-- exists.
--
-- @param key	e.g. "json.key.fragments"
--
function MediaPlayer.GetConfigValue( key )
	local value = MediaPlayerUtils.TableLookup( MediaPlayer.config, key )

	if type(value) == 'nil' then
		ErrorNoHalt("WARNING: MediaPlayer config value not found for key `" .. tostring(key) .. "`\n")
	end

	return value
end

if SERVER then
	AddCSLuaFile "config/client.lua"
	include "config/server.lua"
else
	include "config/client.lua"
end


--[[---------------------------------------------------------
	Shared includes
-----------------------------------------------------------]]

include "sh_events.lua"
include "sh_mediaplayer.lua"
include "sh_services.lua"
include "sh_history.lua"
include "sh_metadata.lua"

hook.Add("Initialize", "InitMediaPlayer", function()
	hook.Run("InitMediaPlayer", MediaPlayer)
end)

-- No fun allowed
hook.Add( "CanDrive", "DisableMediaPlayerDriving", function(ply, ent)
	if IsValid(ent) and ent.IsMediaPlayerEntity then
		return IsValid(ply) and ply:IsAdmin()
	end
end)

--PATH lua/mediaplayer/players/base/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/players/entity/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/sh_services.lua:
MediaPlayer.Services = {}

function MediaPlayer.RegisterService( service )

	local base

	if service.Base then
		base = MediaPlayer.Services[service.Base]
	elseif MediaPlayer.Services.base then
		base = MediaPlayer.Services.base
	end

	-- Inherit base service
	setmetatable( service, { __index = base } )

	-- Create base class for service
	baseclass.Set( "mp_service_" .. service.Id, service )

	-- Store service
	MediaPlayer.Services[ service.Id ] = service

	if MediaPlayer.DEBUG then
		print( "MediaPlayer.RegisterService", service.Name )
	end

end

function MediaPlayer.GetValidServiceNames( whitelist )
	local tbl = {}

	for _, service in pairs(MediaPlayer.Services) do
		if not rawget(service, "Abstract") then
			if whitelist then
				if table.HasValue( whitelist, service.Id ) then
					table.insert( tbl, service.Name )
				end
			else
				table.insert( tbl, service.Name )
			end
		end
	end

	return tbl
end

function MediaPlayer.GetSupportedServiceIDs()
	local tbl = {}

	for _, service in pairs(MediaPlayer.Services) do
		if not rawget(service, "Abstract") then
			table.insert( tbl, service.Id )
		end
	end

	return tbl
end

function MediaPlayer.ValidUrl( url )

	for id, service in pairs(MediaPlayer.Services) do
		if service:Match( url ) then
			return true
		end
	end

	return false

end

function MediaPlayer.GetMediaForUrl( url, webpageFallback )

	local service

	for id, s in pairs(MediaPlayer.Services) do
		if s:Match( url ) then
			service = s
			break
		end
	end

	if not service then
		if webpageFallback then
			service = MediaPlayer.Services.www
		else
			service = MediaPlayer.Services.base
		end
	end

	return service:New( url )

end

-- Load services
do
	local path = "services/"

	local fullpath = "mediaplayer/" .. path

	local services = {
		"base", -- MUST LOAD FIRST!

		-- Browser
		"browser", -- base
		"youtube",
		"googledrive",
		"twitch",
		"twitchstream",
		"vimeo",

		-- HTML Resources
		"resource", -- base
		"image",
		"html5_video",
		"webpage",

		-- IGModAudioChannel
		"audiofile",
		"shoutcast",
		"soundcloud"
	}

	for _, name in ipairs(services) do
		local clfile = path .. name .. "/cl_init.lua"
		local svfile = path .. name .. "/init.lua"
		local shfile = fullpath .. name .. ".lua"

		if file.Exists(shfile, "LUA") then
			clfile = shfile
			svfile = shfile
		end

		SERVICE = {}

		if SERVER then
			AddCSLuaFile(clfile)
			include(svfile)
		else
			include(clfile)
		end

		MediaPlayer.RegisterService( SERVICE )
		SERVICE = nil
	end
end

--PATH lua/mediaplayer/services/twitch/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/services/image.lua:
SERVICE.Name 	= "Image"
SERVICE.Id 		= "img"
SERVICE.Base 	= "res"

SERVICE.FileExtensions = { 'png', 'jpg', 'jpeg', 'gif' }

if CLIENT then

	local EmbedHTML = [[
<div style="background-image: url(%s);
			background-repeat: no-repeat;
			background-size: contain;
			background-position: center center;
			width: 100%%;
			height: 100%%;">
</div>
]]

	function SERVICE:GetHTML()
		return EmbedHTML:format( self.url )
	end

end
--PATH lua/mediaplayer/services/soundcloud/cl_init.lua:
include "shared.lua"

--PATH lua/mediaplayer/cl_idlescreen.lua:
return gluapack()()
--PATH lua/mp_menu/common.lua:
return gluapack()()
--PATH lua/mp_menu/volume_control.lua:
return gluapack()()
--PATH lua/autorun/medic.lua:
player_manager.AddValidModel( "navy medic", 		"models/navy/gnavymedic.mdl" );
list.Set( "PlayerOptionsModel", "navy medic", 	"models/navy/gnavymedic.mdl" );
--PATH addons/[miecze] moce i hilty/lua/autorun/mpowers_loader.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/memetispowers/client/cl_holo.lua:
if SERVER then return end

hook.Add("PreDrawHalos", "lscs_halos", function()
    if not IsValid(LocalPlayer()) then return end
    local rebuke = {}
    for k, v in ipairs(player.GetAll()) do
        if not IsValid(v) then continue end
        if v:GetNWFloat("lscs_rebuke", 0) < CurTime() then continue end
        table.insert(rebuke, v)
    end
    halo.Add(rebuke, Color(160,200,0))
end)
--PATH addons/[ui] msd_ui/lua/autorun/msd_autorun.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/language/nl.lua:
MSD.Language["nl"] = {

	lang_name = "Netherlands",

	ok = "OKE",
	map = "Kaart",
	off = "Uit",
	on = "Op",
	time_add = "Tijd om toe te voegen",
	type = "Type",
	delay = "Vertraging",
	cancel = "Annuleren",
	enable = "Inschakelen",
	model = "Model",
	name = "Naam",
	settings = "Instellingen",
	editor = "Editor",
	red = "Rood",
	green = "Groente",
	blue = "Blauw",
	admin_menu = "Administratie menu",
	ui_settings = "UI instellingen",
	active = "Actief",
	inactive = "Inactief",
	disabled = "Gehandicapt",
	warning = "Waarschuwing!",
	remove = "Verwijderen",
	theme = "Thema",
	dark_theme = "Donker thema",
	payment = "Betaling",
	load_autosave = "Laad laatste autosave?",
	load_save = "Laad gegevens",
	create_new = "Maak nieuw",
	enable_option = "Optie inschakelen",
	main_opt = "Belangrijkste opties",
	copy_data = "Gegevens kopiren",
	save_chng = "Wijzigingen opslaan",
	enter_name = "Voer de naam in",
	enter_id = "Voer de ID in",
	confirm_action = "Bevestig uw acties a.u.b.",
	check_fpr_errors = "Controleer op fouten",
	enter_description = "Voer beschrijving in",
	cooldown_ok = "Cooldown bij succes",
	cooldown_fail = "Afkoelen bij mislukt",
	s_team_whitelist = "Witte lijst voor team instellen",
	whitelist_blacklist = "De witte lijst is een zwarte lijst",
	custom_val = "Aangepaste waarde instellen",
	set_hp_full = "Zet volledige HP",
	dist_to_close = "Afstand tot dichtstbijzijnde",

	e_text = "Tekst invoeren",
	e_number = "Voer nummer in",
	e_class = "Ga naar de klas",
	e_value = "Voer waarde in",
	e_blank_dis = "Laat leeg om uit te schakelen",
	e_blank_default = "Laat leeg om standaard te gebruiken",
	e_url = "Binnenkomen URL",
	e_model = "Voer modelpad in", -- voorbeeld: model/alyx.mdl
	e_material = "Voer materiaalpad in",
	e_wep_class = "Voer wapenklasse in",
	e_ent_class = "Entiteitsklasse invoeren",
	e_veh_class = "Voer voertuigklasse in",
	e_npc_class = "Voer NPC-klasse in",

	select_ammo = "geselecteerde munitie",
	amount_ammo = "Munitie hoeveelheid",
	disable_phys = "Schakel natuurkunde uit",
	none = "Geen",
	custom_icon = "Aangepast pictogram instellen",
	weapon_name = "wapen naam",
	moveup = "Omhoog gaan",
	movedown = "Naar beneden verplaatsen",
	movepoint = "Punt verplaatsen",
	swap = "Ruil",
	swapmod = "Swap-mod ingeschakeld. Klik om uit te schakelen",
	copy_from_ent = "Kopiren van kijkende entiteit",
	set_pos_self = "Instellen op uw positie",
	set_pos_aim = "Ingesteld op kijkpunt",
	spawn_point = "spawn punt",
	spawn_ang = "Spawn hoek",
	mark_area = "Markeer gebied",
	time_wait = "Tijd om te wachten",
	map_marker = "Selecteer kaartmarkering",
	in_sec = "in seconden",
	def_units = "Standaard %s eenheden", -- "Standaard 350 units" het verlof %s zoals het is
	def_seconds = "Standaard %s seconden", -- "Standaard 10 seconds" het verlof %s zoals het is
	ent_show_pointer = "Toon aanwijzer boven de entiteit",
	ent_arcade_style = "Uiterlijk van entiteit in arcadestijl",
	ent_stnd_style = "Standaard uiterlijk van entiteit",
	custom_color = "Aangepaste kleur inschakelen",
	mat_default = "Leeg laten voor standaard materiaal",

	set_ui = "UI instellingen",
	set_hud = "HUD instellingen",
	set_hud_pos = "Quest HUD positie",
	set_hud_themes = "HUD Thema's",
	set_server = "Server instellingen",
	set_ui_blur = "Blur achtergrond",
	set_ui_mono = "Monochrome achtergrond",
	set_ui_vignette = "Vigneteffect voor achtergrond",
	set_ui_brightness = "Achtergrondhelderheid",
	set_ui_color = "Selecteer de hoofdkleur",
	set_ui_align_left = "Horizontale uitlijning naar links",
	set_ui_align_right = "Horizontale uitlijning naar rechts",
	set_ui_align_top = "Verticale uitlijning naar boven",
	set_ui_align_bottom = "Verticale uitlijning naar beneden",
	set_ui_offset_h = "Horizontale verschuiving",
	set_ui_offset_v = "Verticale verschuiving",

	upl_changes = "Wijzigingen uploaden naar server",
	res_changes = "Wijzigingen herstellen",

	-- Player 

	dead = "Je bent dood",
	time_ex = "Tijd verlopen",
	vehicle_bum = "Uw voertuig is vernietigd",
	left_area = "Je hebt het gebied verlaten",
	m_blew = "You blew up the mission",
	m_failed = "Missie gefaald",
	m_success = "Missie geslaagd",
	m_loop = "Missie update",

	-- Errors

	inv_quest = "Ongeldige zoektocht",
	team_bl = "Uw team staat op de zwarte lijst",
	no_players = "Server heeft meer spelers nodig om online te zijn voordat je dit kunt doen",
	no_players_team = "Server heeft meer spelers nodig voor specifieke team(s) om online te zijn voordat je dit kunt doen",
	need_admin = "Alleen beheerders kunnen deze actie uitvoeren",

	-- Quests

	active_quest = "Je hebt een actieve zoektocht",
	inactive_quest = "Je kunt deze zoektocht niet spelen",
	quest_editor = "Speurtocht Editor",
	quest_list = "Speurtocht List",
	quests = "Speurtochts",
	leave_pnt = "Het verlof point",

	q_editobj = "Doelstellingen bewerken",
	q_incvobj = "Ongeldige doelstelling",
	q_setobj = "Ongeldige instellingen",
	q_newobj = "Nieuwe doelstelling toevoegen",
	q_editrwd = "Bewerk beloningen",
	q_rwdeditor = "Belonings editor",
	q_rwdlist = "Reward list",
	q_rwdsets = "Belonings lijst",
	q_findmap = "Zoek een zoektocht van andere kaarten",
	q_obj_des = "Objectieve beschrijving",
	q_dist_point = "Afstand tot punt",
	q_dist_from_point = "Afstand vanaf punt",
	q_ignore_veh = "Negeer zoektocht voertuig",
	q_timer_show = "Toon de timer aan speler",
	q_area_stay = "Speler moet in het gebied blijven",
	q_start = "Zoektocht starten",
	q_new = "Nieuwe zoektocht",
	q_submit = "Zoekopdracht indienen",
	q_addnew = "Nieuwe zoektocht toevoegen",
	q_remove = "Zoektocht verwijderen",
	q_id_unique = "ID moet uniek zijn voor elke zoektocht",
	q_complete_msg = "Quest voltooid bericht",
	q_dotime = "Quest doe tijd",
	q_dotime_ok = "Slaag de zoektocht op tijd einde",
	q_dotime_fail = "Mislukte zoektocht op tijd einde",
	q_death_fail = "Mislukte zoektocht bij dood van speler",
	q_loop = "Loop-queeste genomen",
	q_loop_reward = "Beloon speler bij elke lus",
	q_enable = "Zoektocht inschakelen",
	q_events = "Evenementen",
	q_eventadd = "Toevoegen Evenementen",
	q_eventedit = "Evenementen edit",
	q_eventremove = "Evenement verwijderen",
	q_in_progress = "Quest in uitvoering",
	q_time_left = "Tijd over",
	q_ply_limit = "Spelerslimiet voor de zoektocht",
	q_ply_team_limit = "Teamlimieten instellen",
	q_ply_team_need = "benodigde teamspelers",
	q_ply_need = "Spelersbedrag nodig om te starten",
	q_play_limit = "Er is een limiet aan hoeveel spelers deze zoektocht kunnen spelen",
	q_must_stay_area = "Je moet binnen dit gebied blijven, anders mislukt de zoektocht",
	q_time_wait = "Je moet wachten voordat je deze quest opnieuw kunt spelen",
	q_dotime_reset = "Reset quest do time",
	q_dotime_add = "Quest do time toevoegen",
	q_noreplay = "Je kunt deze zoektocht niet opnieuw spelen",
	q_dis_replay = "Disable quest replay",
	q_needquest = "You need to finish another quest first",
	q_needquest_menu = "Voltooide zoektocht vereisen",
	q_enterror = "Quest-entiteiten zijn niet voortgekomen, controleer de setup van de missie",
	q_get = "Je kunt een quest krijgen van deze NPC's",
	q_noquests = "Er is nog geen manier om speurtochten te spelen :(",
	q_ent_draw = "Trekafstand van de queeste-entiteit",
	q_loop_stop_key = "Stop-toets voor doorlopende zoektocht",
	q_hold_key_stop = "Om quest hold te stoppen [%s]", -- To stop quest hold [P]
	q_enter_veh = "Voer uw voertuig in",
	q_npc_link = "Zoektocht koppelen aan een NPC",
	q_icon68 = "Voer url in naar .PNG pictogram 68x68 px",
	q_ent_pos_show = "Locatie van entiteiten aan speler tonen",
	q_area_size = "Oppervlakte",
	q_area_pos = "Gebiedspositie",
	q_s_area_size = "Grootte van het zoekgebied",
	q_s_area_pos = "Zoekgebied positie",
	q_npc_answer_ok = "Positief antwoord van de speler",
	q_npc_answer_no = "Negatief antwoord van de speler",
	q_npc_answer_noq = "Het antwoord van de speler als er geen speurtochten zijn",
	q_npc_quest_no = "NPC spraak als er geen speurtochten zijn",
	q_money_give = "Geld om te geven",

	-- Simple NPCs

	npc_editor = "NPC-editor",
	npc_new = "Nieuwe NPC",
	npc_select = "Selecteer een NPC",
	npc_e_speech = "Voer NPC-spraak in",
	npc_submit = "Aanmaak van NPC bevestigen",
	npc_update = "NPC bijwerken",
	npc_remove = "NPC verwijderen",
	npc_q_enable = "Zoek-NPC's inschakelen",
	npc_did_open = "Dialoogvenster-ID om te openen",
	npc_q_target = "NPC is een objectief doelwit",
	npc_hostile = "Vijandige NPC",


	-- Update 1.1.0

	cam_start = "Startparameters camera",
	cam_end = "Camera einde parameters",
	cam_pos = "Camera positie",
	cam_ang = "Camera hoek",
	cam_fov = "Camerabeeldhoek",
	cam_effect = "Camerasluitereffect",
	q_open_target = "Sta andere spelers toe om NPC's te doden",
	q_npc_mind = "Min. afstand tot NPC's",
	not_spawned = "niet voortgebracht",
	dis_text = "Weergegeven tekst",
	cam_speed = "Bewegingssnelheid camera (langzamer getal - langzamere beweging)",
	fov_speed = "FOV-veranderingssnelheid (lager getal - langzamere beweging)",
	category_des = "Missiecategorie, gebruikt om missies te sorteren",
	sortquests_cat = "Sorteer missies op categorie",
	search_q = "Zoekopdrachten",
	quest_tools = "Quest-tools",
	set_anim = "Animatieset",
	s_quest_blacklist = "Zwarte lijst voor missies instellen",
	s_quest_blacklist_desc = "Selecteer missies die deze missie blokkeren als je ze hebt gespeeld",
	hold_use = "Houden [%s] key",
	duplicate = "Duplicaat",
	unsorted = "ongesorteerd",
	search = "Zoekopdracht",
	duration = "Looptijd",
	category = "Categorie",
	blacklist = "Zwarte lijst",


	--  Update 1.2.0

	restore_wep = "Wapens herstellen aan het einde van de zoektocht",
	e_cmd = "Voer consoleopdracht in",
	e_args = "Voer opdrachtargumenten in",
	hint_cmd = "Sneltoetsen aanvullen: \n$uid - UserID, \n$sid - SteamID,  \n$s64 - SteamID 64, \n$n - Plaag naam",
	youaretracked = "Your position is now compromised to other players!",
	border_rounded = "Rounded border design",
	border_square = "Vierkant randontwerp",
	access_settings = "Toegang tot menu",
	compact_obj = "Compacte doelstellingenlijst voor speurtochten",
	e_usergroup = "Gebruikersgroep invoeren",
	ug_isanadmin = "Deze gebruikersgroep heeft al volledige toegang",
	find_player_id32 = "Vind spelergegevens op SteamID 32",
	user_data = "Editor voor gebruikersgegevens",
	access_editors = "Toegang voor quest-editors instellen",
	access_admins = "Volledige toegang instellen",
	add_usergroup = "Gebruikersgroep toevoegen",
	edit_objmod = "Objectvolgorde bewerken",
	editmod = "Mode bewerken",
	move = "Beweging",
	q_errorloop = "Quest ingevoerd in een eindeloze lus",
	q_cooldow_perply = "Openbare afkoeltimer",
	q_cooldow_publick = "Afkoeltimer per speler",
	q_stop_anytime = "Toestaan om de zoektocht handmatig te verlaten",
	quest_abandon = "Je hebt de zoektocht opgegeven",
	q_dotime_set = "Tijd voor quest instellen",


	-- Ranks

	enter_path_or_url = "Voer pad of url in",
	rank_edit = "Rangen instellen",
	rank_list = "Ranglijst",
	group_list = "Groepslijst",
	group_addnew = "Nieuwe groep toevoegen",
	blank = "Blanco",
	mrs_show_all = "Toon rangen aan alle spelers",
	mrs_show_team = "Toon rangen alleen aan de groep",
	mrs_use_sn = "Korte rangnamen weergeven",
	use_url = "Gebruik URL",
	enter_srt_name = "Voer korte naam in",
	srt_name = "Korte naam",
	mrs_prom_demote = "De volgende 2 opties zijn alleen van invloed op lagere rangen. Spelers met deze rang kunnen andere spelers niet promoveren naar hogere rangen of dezelfde rang.",
	mrs_whilelist = "Als je een rangvereiste voor een baan selecteert, kan de speler deze baan alleen spelen als zijn rang overeenkomt met de gekozen of hoger.",
	can_promote = "Kan de spelersrang bevorderen",
	can_demote = "Kan spelerrang degraderen",
	edit_player_model = "Aangepast spelersmodel bewerken",
	enable_player_model = "Aangepast spelermodel inschakelen",
	disable_player_model = "Aangepast spelermodel uitschakelen",
	edit_custom_stats = "Aangepaste spelerstatistieken bewerken",
	autoprom = "Automatisch promoveren naar de volgende rang",
	in_min = "in minuten",
	mrs_promoted = "Je bent gepromoveerd",
	mrs_demoted = "Je bent gedegradeerd",
	mrs_job_smallrank = "Je moet %s of hoger zijn om als %s. te spelen", -- You must be Sergeant II or higher to play as Watch Commander
	show_group = "Naam ranggroep weergeven",
	hide_rank = "Toon alleen rang icoon",
	mrs_hud_follow = "Draai de gebruikersinterface rond de speler, afhankelijk van de kijkhoek",
	set_overhead = "Spelers info UI",
	offline_users = "Offline gebruikers",
	mrs_noranks = "Je huidige baan heeft geen rangen",
	mrs_nopower = "Je huidige rang heeft geen extra rechten",
	promotion = "Promotie",
	on_duty = "In functie",
	other_players = "andere spelers",
	mrs_change_jobname = "Wijzig de taaknaam in de rangnaam",
	mrs_set_prefix = "Voeg de rangnaam toe als voorvoegsel aan de taaknaam",
	copy_all_data = "Kopieer alle gegevens",
	copy_only_stats = "Kopieer alleen statistieken en spelersmodel",
}

-- Other phrases
local lng = "nl"

MSD.Language[lng]["Move to point"] = "Verplaatsen naar punt"
MSD.Language[lng]["Leave area"] = "Verlaat gebied"
MSD.Language[lng]["Kill NPC"] = "Dood NPC"
MSD.Language[lng]["Collect quest ents"] = "Verzamel zoektochten"
MSD.Language[lng]["Talk to NPC"] = "Praat met NPC"
MSD.Language[lng]["There is no quests available"] = "Er zijn geen speurtochten beschikbaar"
MSD.Language[lng]["Give weapon"] = "Geef wapen"
MSD.Language[lng]["Give ammo"] = "Geef munitie"
MSD.Language[lng]["Strip Weapon"] = "Stripwapen"
MSD.Language[lng]["Spawn quest entity"] = "Spawn Quest-entiteit"
MSD.Language[lng]["Spawn entity"] = "Spawn entiteit"
MSD.Language[lng]["Spawn npc"] = "spawn npc"
MSD.Language[lng]["Manage do time"] = "Beheer doe tijd"
MSD.Language[lng]["Spawn vehicle"] = "Spawn voertuig"
MSD.Language[lng]["Remove vehicle"] = "Voertuig verwijderen"
MSD.Language[lng]["Remove all entites"] = "Alle entiteiten verwijderen"
MSD.Language[lng]["Set HP"] = "Stel HP"
MSD.Language[lng]["Set Armor"] = "Pantser instellen"
MSD.Language[lng]["DarkRP Money"] = "DarkRP Geld"
MSD.Language[lng]["Quest NPCs are disabled"] = "Quest-NPC's zijn uitgeschakeld"
MSD.Language[lng]["You can enable them in settings"] = "Je kunt ze inschakelen in instellingen"

--PATH addons/[ui] msd_ui/lua/msd/language/ru.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/language/ru.lua:
MSD.Language["ru"] = {

	-- UI

	lang_name = "",

	ok = "",
	map = "",
	off = "",
	on = "",
	time_add = " ",
	type = "",
	delay = "",
	cancel = "",
	enable = "",
	model = "",
	name = "",
	settings = "",
	editor = "",
	red = "",
	green = "",
	blue = "",
	admin_menu = " ",
	ui_settings = " ",
	active = "",
	inactive = "",
	disabled = "",
	warning = "!",
	remove = "",
	theme = "",
	dark_theme = " ",
	payment = "",
	load_autosave = "  ?",
	load_save = " ",
	create_new = " ",
	enable_option = " ",
	main_opt = " ",
	copy_data = " ",
	save_chng = " ",
	enter_name = " ",
	enter_id = " ID",
	confirm_action = "  ",
	check_fpr_errors = "  ",
	enter_description = " ",
	cooldown_ok = "  ",
	cooldown_fail = "  ",
	s_team_whitelist = "  ",
	whitelist_blacklist = "=",
	custom_val = "  ",
	set_hp_full = "  ",
	dist_to_close = "  ",

	e_text = " ",
	e_number = " ",
	e_class = " ",
	e_value = " ",
	e_blank_dis = "   ",
	e_blank_default = "    -",
	e_url = " URL",
	e_model = "  ",
	e_material = "  ",
	e_wep_class = "  ",
	e_ent_class = "  ",
	e_veh_class = "  ",
	e_npc_class = "  ",

	select_ammo = " ",
	amount_ammo = " ",
	disable_phys = " ",
	none = "",
	custom_icon = "  ",
	weapon_name = " ",
	moveup = " ",
	movedown = " ",
	movepoint = " ",
	swap = "",
	swapmod = "  .   ",
	copy_from_ent = ".  ",
	set_pos_self = "  .",
	set_pos_aim = "  ",
	spawn_point = " ",
	spawn_ang = " ",
	mark_area = " ",
	time_wait = " ",
	map_marker = "  ",
	in_sec = " ",
	def_units = " -", -- "- 350 "  %s  
	def_seconds = " -", -- "- 10 "  %s  
	ent_show_pointer = "   ",
	ent_arcade_style = "   ",
	ent_stnd_style = "  ",
	custom_color = "  ",
	mat_default = "    -",

	set_ui = "UI ",
	set_hud = "HUD ",
	set_hud_pos = "  ",
	set_hud_themes = " ",
	set_server = " ",
	set_ui_blur = "  ",
	set_ui_mono = "  ",
	set_ui_vignette = "   ",
	set_ui_brightness = "  ",
	set_ui_color = "  ",
	set_ui_align_left = "  ",
	set_ui_align_right = "  ",
	set_ui_align_top = "  ",
	set_ui_align_bottom = "  ",
	set_ui_offset_h = " ",
	set_ui_offset_v = " ",

	upl_changes = "   ",
	res_changes = " ",

	-- Player

	dead = " ",
	time_ex = " ",
	vehicle_bum = "  ",
	left_area = "  ",
	m_blew = "  ",
	m_failed = " ",
	m_success = " ",
	m_loop = " ",

	-- Errors

	inv_quest = " ",
	team_bl = "   ",
	no_players = "      ",
	no_players_team = "         ",
	need_admin = "    ",

	-- Quests

	active_quest = "    ",
	inactive_quest = "     ",
	quest_editor = " ",
	quest_list = " ",
	quests = "",
	leave_pnt = " ",

	q_editobj = " ",
	q_incvobj = " ",
	q_setobj = " ",
	q_newobj = " ",
	q_editrwd = " ",
	q_rwdeditor = " ",
	q_rwdlist = " ",
	q_rwdsets = " ",
	q_findmap = "    ",
	q_obj_des = " ",
	q_dist_point = "  ",
	q_dist_from_point = "  ",
	q_ignore_veh = "  ",
	q_timer_show = "  ",
	q_area_stay = "    ",
	q_start = " ",
	q_new = " ",
	q_submit = " ",
	q_addnew = "  ",
	q_remove = " ",
	q_id_unique = "ID      ",
	q_complete_msg = "   ",
	q_dotime = " ",
	q_dotime_ok = "     ",
	q_dotime_fail = "     ",
	q_death_fail = "     ",
	q_loop = "  ",
	q_loop_reward = "    ",
	q_enable = " ",
	q_events = "",
	q_eventadd = " ",
	q_eventedit = " ",
	q_eventremove = " ",
	q_in_progress = "  ",
	q_time_left = " ",
	q_ply_limit = "   ",
	q_ply_team_limit = "  ",
	q_ply_team_need = "    ",
	q_ply_need = "  -   ",
	q_play_limit = "   -   ",
	q_must_stay_area = "         ",
	q_time_wait = "       ",
	q_dotime_reset = "   ",
	q_dotime_add = "   ",
	q_noreplay = "     ",
	q_dis_replay = "  ",
	q_needquest = "     ",
	q_needquest_menu = "  ",
	q_enterror = "   ,   ",
	q_get = "      ",
	q_noquests = "      :(",
	q_ent_draw = "   ",
	q_loop_stop_key = "   ",
	q_hold_key_stop = "    [%s]", --     [P]
	q_enter_veh = "    ",
	q_npc_link = "   ",
	q_icon68 = " url  .PNG  68x68 .",
	q_ent_pos_show = "   ",
	q_area_size = " ",
	q_area_pos = " ",
	q_s_area_size = "  ",
	q_s_area_pos = "  ",
	q_npc_answer_ok = "  ",
	q_npc_answer_no = "  ",
	q_npc_answer_noq = "    ",
	q_npc_quest_no = "    ",
	q_money_give = "  ",

	-- Simple NPCs

	npc_editor = " ",
	npc_new = " ",
	npc_select = " ",
	npc_e_speech = "  ",
	npc_submit = "  ",
	npc_update = " ",
	npc_remove = " ",
	npc_q_enable = "  ",
	npc_did_open = "ID   ",
	npc_q_target = "  - ",
	npc_hostile = " ",

	-- Update 1.1.0

	duration = "",
	dis_text = " ",
	cam_speed = "   (  -  )",
	fov_speed = "    (  -  )",
	cam_start = "  ",
	cam_end = "  ",
	cam_pos = " ",
	cam_ang = " ",
	cam_fov = "  ",
	cam_effect = "  ",
	not_spawned = " ",
	q_open_target = "    NPC",
	q_npc_mind = ".   NPC",
	duplicate = "",
	hold_use = "  [%s]",
	category = "",
	category_des = " ,    ",
	sortquests_cat = "   ",
	unsorted = " ",
	search = "",
	search_q = " ",
	quest_tools = "",
	set_anim = " ",
	s_quest_blacklist = "   ",
	blacklist = " ",
	s_quest_blacklist_desc = " ,    ,    ",

	--  Update 1.2.0

	restore_wep = "    ",
	e_cmd = "  ",
	e_args = "  ",
	hint_cmd = "  : \n$uid - UserID, \n$sid - SteamID,  \n$s64 - SteamID 64, \n$n -  ",
	youaretracked = "     !",
	border_rounded = "   ",
	border_square = "   ",
	access_settings = "  ",
	compact_obj = "    ",
	e_usergroup = "  ",
	ug_isanadmin = "      ",
	find_player_id32 = "    SteamID 32",
	user_data = "  ",
	access_editors = "    ",
	access_admins = "  ",
	add_usergroup = "  ",
	edit_objmod = "  ",
	editmod = " ",
	move = "",
	q_errorloop = "    ",
	q_cooldow_perply = " ",
	q_cooldow_publick = " ",
	q_stop_anytime = "    ",
	quest_abandon = "   ",
	q_dotime_set = "   ",


	-- Ranks

	enter_path_or_url = "    ",
	rank_edit = " ",
	rank_list = " ",
	group_list = " ",
	group_addnew = "  ",
	blank = "",
	mrs_show_all = "   ",
	mrs_show_team = "   ",
	mrs_use_sn = "   ",
	use_url = "  ",
	enter_srt_name = "  ",
	srt_name = " ",
	mrs_prom_demote = " 2       .                 .",
	mrs_whilelist = "      ,      ,        .",
	can_promote = "   ",
	can_demote = "   ",
	edit_player_model = "  ",
	enable_player_model = "   ",
	disable_player_model = "   ",
	edit_custom_stats = "  ",
	autoprom = "    ",
	in_min = " ",
	mrs_promoted = "  ",
	mrs_demoted = "  ",
	mrs_job_smallrank = "   %s       %s",
	show_group = "   ",
	hide_rank = "   ",
	mrs_hud_follow = "    ",
	set_overhead = "   ",
	offline_users = "-",
	mrs_noranks = "     ",
	mrs_nopower = "      ",
	promotion = "",
	on_duty = " ",
	other_players = " ",
	mrs_change_jobname = "     ",
	mrs_set_prefix = "       ",
	mrs_change_plyname = "     ",
	mrs_set_prefix_ply = "       ",

	promote_limit = " ",
	demote_limit = " ",
	salary_value = " ",
	salary_set = "     ",
	salary_add = "    ",
	salary_multiply = "    ",
	force_team = " c  ",
	mrs_hud_3d2d = " 3D2D ",
	mrs_chat_command = "-    ",
	mrs_promote_command = "-   ",
	mrs_demote_command = "-   ",
}

-- Other phrases
local lng = "ru"

MSD.Language[lng]["Move to point"] = "  "
MSD.Language[lng]["Leave area"] = " "
MSD.Language[lng]["Kill NPC"] = " "
MSD.Language[lng]["Collect quest ents"] = "  "
MSD.Language[lng]["Talk to NPC"] = "  "
MSD.Language[lng]["Wait time"] = " "

MSD.Language[lng]["There is no quests avalible"] = "    "

MSD.Language[lng]["Give weapon"] = " "
MSD.Language[lng]["Give ammo"] = " "
MSD.Language[lng]["Strip Weapon"] = " "
MSD.Language[lng]["Spawn quest entity"] = "  "
MSD.Language[lng]["Spawn entity"] = " "
MSD.Language[lng]["Spawn npc"] = " "
MSD.Language[lng]["Manage do time"] = "   "
MSD.Language[lng]["Spawn vehicle"] = " "
MSD.Language[lng]["Remove vehicle"] = " "
MSD.Language[lng]["Remove all entites"] = "  "
MSD.Language[lng]["Set HP"] = " "
MSD.Language[lng]["Set Armor"] = " "

MSD.Language[lng]["DarkRP money"] = "DarkRP "

MSD.Language[lng]["Quest NPCs are disabled"] = "  "
MSD.Language[lng]["You can enable them in settings"] = "     "
--PATH addons/[ui] msd_ui/lua/msd/ui/assets.lua:
MSD.Icons48 = {
	cross = Material("msd/icons/cross.png", "smooth"),
	cog = Material("msd/icons/cog.png", "smooth"),
	eye = Material("msd/icons/eye.png", "smooth"),
	box = Material("mqs/map_markers/b5.png", "smooth"),
	box_open = Material("mqs/icons/box_open.png", "smooth"),
	layers = Material("msd/icons/layers.png", "smooth"),
	layers_plus = Material("msd/icons/layers-plus.png", "smooth"),
	layers_remove = Material("msd/icons/layers-remove.png", "smooth"),
	briefcase = Material("msd/icons/briefcase.png", "smooth"),
	account = Material("msd/icons/account.png", "smooth"),
	account_plus = Material("msd/icons/account-plus.png", "smooth"),
	account_edit = Material("msd/icons/account-edit.png", "smooth"),
	account_multiple = Material("msd/icons/account-multiple.png", "smooth"),
	account_convert = Material("msd/icons/account-convert.png", "smooth"),
	arrow_up = Material("msd/icons/arrow_up.png", "smooth"),
	arrow_down = Material("msd/icons/arrow_down.png", "smooth"),
	folder_open = Material("msd/icons/folder-open.png", "smooth"),
	file_document = Material("msd/icons/file-document.png", "smooth"),
	menu = Material("msd/icons/menu.png", "smooth"),
	dot = Material("msd/icons/dot.png", "smooth"),
	pencil = Material("msd/icons/pencil.png", "smooth"),
	play = Material("msd/icons/play.png", "smooth"),
	plus = Material("msd/icons/plus.png", "smooth"),
	back = Material("msd/icons/back.png", "smooth"),
	calendar_check = Material("msd/icons/calendar-check.png", "smooth"),
	playlist_edit = Material("msd/icons/playlist-edit.png", "smooth"),
	seal = Material("msd/icons/seal.png", "smooth"),
	save = Material("msd/icons/content-save.png", "smooth"),
	copy = Material("msd/icons/content-copy.png", "smooth"),
	submit = Material("msd/icons/check-decagram.png", "smooth"),
	alert = Material("msd/icons/alert-circle.png", "smooth"),
	arrow_down_color = Material("msd/icons/arrow_down_color.png", "smooth"),
	face_agent = Material("msd/icons/face-agent.png", "smooth"),
	swap = Material("msd/icons/swap.png", "smooth"),
	search = Material("mqs/map_markers/c4.png", "smooth"),
	tools = Material("mqs/map_markers/t1.png", "smooth"),
	human_female = Material("msd/icons/human-female.png", "smooth"),
	human_male = Material("msd/icons/human-male.png", "smooth"),
	human_female_dance = Material("msd/icons/human-female-dance.png", "smooth"),
	hand_peace_variant = Material("msd/icons/hand-peace-variant.png", "smooth"),
	key = Material("msd/icons/key-variant.png", "smooth"),
	key_arrow_right = Material("msd/icons/key-arrow-right.png", "smooth"),
	key_link = Material("msd/icons/key-link.png", "smooth"),
	key_plus = Material("msd/icons/key-plus.png", "smooth"),
	key_remove = Material("msd/icons/key-remove.png", "smooth"),
	key_star = Material("msd/icons/key-star.png", "smooth"),
	door = Material("msd/icons/door.png", "smooth"),
	car = Material("mqs/map_markers/v1.png", "smooth"),
	cancel = Material("msd/icons/cancel.png", "smooth"),
	reload = Material("msd/icons/reload.png", "smooth"),
	reload_alert = Material("msd/icons/reload-alert.png", "smooth"),
	heart = Material("msd/icons/cards-heart.png", "smooth"),
	heart_outline = Material("msd/icons/cards-heart-outline.png", "smooth"),
	heart_broken = Material("msd/icons/heart-broken.png", "smooth"),
	heart_flash = Material("msd/icons/heart-flash.png", "smooth"),
	skip_to = Material("msd/icons/debug-step-over.png", "smooth"),
	cash = Material("msd/icons/cash.png", "smooth"),
	magazine = Material("msd/icons/magazine-pistol.png", "smooth"),
	ammo = Material("mqs/icons/ammo.png", "smooth"),
	armor = Material("mqs/map_markers/a1.png", "smooth"),
	armor_outline = Material("mqs/map_markers/a2.png", "smooth"),
	armor_broken = Material("mqs/map_markers/a4.png", "smooth"),
	armor_flash = Material("mqs/map_markers/a5.png", "smooth")
}

MSD.Materials = {
	vignette = Material("msd/vignette.png", "smooth"),
	gradient = Material("gui/gradient", "smooth"),
	gradient_right = Material("msd/gradient_right.png", "smooth"),
}

MSD.PinPoints = {
	[0] = Material("mqs/icons/pin.png", "smooth"),
}

local files = file.Find("materials/mqs/map_markers/*", "GAME")

for k, v in pairs(files) do
	MSD.PinPoints[k] = Material("mqs/map_markers/" .. v, "smooth")
end

MSD.ColorPresets = {Color(255, 20, 20), Color(255, 115, 0), Color(210, 255, 0), Color(0, 170, 25), Color(0, 155, 255), Color(0, 100, 200), Color(135, 0, 255), Color(255, 0, 100),}

MSD.Theme = {
	["d_na"] = Color(25, 25, 26),
	["d"] = Color(0, 5, 10, 165),
	["m"] = Color(0, 5, 10, 120),
	["l"] = Color(0, 5, 10, 85),
}

MSD.Text = {
	["a"] = Color(150, 150, 150, 200),
	["n"] = Color(150, 150, 150),
	["d"] = Color(220, 220, 220),
	["s"] = Color(235, 235, 235),
	["m"] = Color(245, 245, 245),
	["l"] = Color(255, 255, 255),
}

local NewFont = surface.CreateFont

for i = 0, 40 do
	NewFont("MSDFont." .. 12 + i, {
		font = "AdihausDIN",
		extended = true,
		size = 12 + i,
		weight = 500
	})
end

for i = 0, 20 do
	NewFont("MSDFontB." .. 16 + i, {
		font = "AdihausDIN",
		extended = true,
		size = 16 + i,
		weight = 800
	})
end

NewFont("MSDFont.Big", {
	font = "AdihausDIN",
	extended = true,
	size = 45,
	weight = 500
})

NewFont("MSDFont.Biger", {
	font = "AdihausDIN",
	extended = true,
	size = 55,
	weight = 500
})

function MSD.DrawBG(panel, w, h)
	if MSD.Config.Blur then
		MSD.Blur(panel, 1, 3, 255, 250 - MSD.Config.BgrColor.r, w, h)
	else
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Config.BgrColor)
	end
end

function MSD.DrawTexturedOutlined(x, y, w, h, mat, color, outlinewidth, ocolor)
	if isstring(mat) then
		mat = Material(mat)
	end

	surface.SetMaterial(mat)
	surface.SetDrawColor(ocolor)
	local steps = ( outlinewidth * 2 ) / 3
	if ( steps < 1 ) then steps = 1 end

	for _x = -outlinewidth, outlinewidth, steps do
		for _y = -outlinewidth, outlinewidth, steps do
			surface.DrawTexturedRect(x + _x, y + _y, w, h)
		end
	end

	surface.SetDrawColor(color)
	surface.DrawTexturedRect(x, y, w, h)
end

local cached_mat = {}

function MSD.DrawTexturedRect(x, y, w, h, mat, color)
	if isstring(mat) then
		local crc = util.CRC(mat)
		if not cached_mat[crc] then
			cached_mat[crc] = Material(mat, "smooth")
		end
		mat = cached_mat[crc]
	end

	surface.SetDrawColor(color)
	surface.SetMaterial(mat)
	surface.DrawTexturedRect(x, y, w, h)
end

function MSD.DrawTexturedRectRotated(rot, x, y, w, h, mat, color)
	if isstring(mat) then
		local crc = util.CRC(mat)
		if not cached_mat[crc] then
			cached_mat[crc] = Material(mat, "smooth")
		end
		mat = cached_mat[crc]
	end

	surface.SetDrawColor(color)
	surface.SetMaterial(mat)
	surface.DrawTexturedRectRotated(x, y, w, h, rot)
end

function MSD.ColorAlpha(cl, al)
	local new_cl = table.Copy(cl)
	new_cl.a = al
	return new_cl
end

local blur = Material("pp/blurscreen")

function MSD.Blur(panel, inn, density, alpha, back_alpha, w, h)
	local x, y = panel:LocalToScreen(0, 0)
	surface.SetDrawColor(255, 255, 255, alpha)
	surface.SetMaterial(blur)

	for i = 1, 3 do
		blur:SetFloat("$blur", (i / inn) * density)
		blur:Recompute()
		render.UpdateScreenEffectTexture()

		if w and h then
			render.SetScissorRect(-x, -y, x + w, y + h, true)
			surface.DrawTexturedRect(-x, -y, ScrW(), ScrH())
			render.SetScissorRect(0, 0, 0, 0, false)
		else
			surface.DrawTexturedRect(-x, -y, ScrW(), ScrH())
		end
	end

	if back_alpha and back_alpha > 0 then
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.ColorAlpha(color_black, back_alpha))
	end
end

-- subUTF8 functions
local function SubStringGetByteCount(str, index)
	local curByte = string.byte(str, index)
	local byteCount = 1

	if curByte == nil then
		byteCount = 0
	elseif curByte > 0 and curByte <= 127 then
		byteCount = 1
	elseif curByte >= 192 and curByte <= 223 then
		byteCount = 2
	elseif curByte >= 224 and curByte <= 239 then
		byteCount = 3
	elseif curByte >= 240 and curByte <= 247 then
		byteCount = 4
	end

	return byteCount
end

local function SubStringGetTotalIndex(str)
	local curIndex = 0
	local i = 1
	local lastCount = 1
	repeat
		lastCount = SubStringGetByteCount(str, i)
		i = i + lastCount
		curIndex = curIndex + 1
	until (lastCount == 0)

	return curIndex - 1
end

local function SubStringGetTrueIndex(str, index)
	local curIndex = 0
	local i = 1
	local lastCount = 1
	repeat
		lastCount = SubStringGetByteCount(str, i)
		i = i + lastCount
		curIndex = curIndex + 1
	until (curIndex >= index)

	return i - lastCount
end

function string.subUTF8(str, startIndex, endIndex)
	if startIndex < 0 then
		startIndex = SubStringGetTotalIndex(str) + startIndex + 1
	end

	if endIndex ~= nil and endIndex < 0 then
		endIndex = SubStringGetTotalIndex(str) + endIndex + 1
	end

	if endIndex == nil then
		return string.sub(str, SubStringGetTrueIndex(str, startIndex))
	else
		return string.sub(str, SubStringGetTrueIndex(str, startIndex), SubStringGetTrueIndex(str, endIndex + 1) - 1)
	end
end

-- Same used in DarkRP, used it here so we can use it with any gamemodes
local function CharWrap(t, w)
	local a = 0

	t = t:gsub(".", function(c)
		a = a + surface.GetTextSize(c)

		if a >= w then
			a = 0

			return "\n" .. c
		end

		return c
	end)

	return t, a
end

function MSD.TextWrap(text, font, w)
	local total = 0
	surface.SetFont(font)
	local spaceSize = surface.GetTextSize(' ')

	text = text:gsub("(%s?[%S]+)", function(word)
		local char = string.subUTF8(word, 1, 1)

		if char == "\n" or char == "\t" then
			total = 0
		end

		local wordlen = surface.GetTextSize(word)
		total = total + wordlen

		if wordlen >= w then
			local splitWord, splitPoint = CharWrap(word, w - (total - wordlen))
			total = splitPoint

			return splitWord
		elseif total < w then
			return word
		end

		if char == ' ' then
			total = wordlen - spaceSize

			return '\n' .. string.subUTF8(word, 2)
		end

		total = wordlen

		return '\n' .. word
	end)

	local w_end, h_end =  surface.GetTextSize(text)

	return text, w_end, h_end
end

-- Image Lib
MSD.ImgLib = {}
MSD.ImgLib.Images = {}
MSD.ImgLib.PreCacheStarted = {}
MSD.ImgLib.NoMaterial = Material("msd/icons/file-hidden.png", "smooth noclamp")

function MSD.ImgLib.GetMaterial(url)
	local crc = util.CRC(url) .. ".png"
	if MSD.ImgLib.Images[crc] then return MSD.ImgLib.Images[crc] end

	if (file.Exists("msd_imgs/" .. crc, "DATA")) then
		MSD.ImgLib.Images[crc] = Material("data/msd_imgs/" .. crc, "smooth noclamp")

		return MSD.ImgLib.Images[crc]
	else
		return MSD.ImgLib.PreCacheMaterial(url, crc)
	end
end

function MSD.ImgLib.PreCacheMaterial(url, crc)
	if not crc then
		crc = util.CRC(url) .. ".png"
	end

	if not file.Exists("msd_imgs", "DATA") then
		file.CreateDir("msd_imgs")
	end

	if not MSD.ImgLib.PreCacheStarted[crc] then
		MSD.ImgLib.PreCacheStarted[crc] = true

		http.Fetch(url, function(body, size, headers, code)
			if (body:find("^.PNG")) then
				file.Write("msd_imgs/" .. crc, body)
				MSD.ImgLib.Images[crc] = Material("data/msd_imgs/" .. crc, "smooth noclamp")

				return MSD.ImgLib.Images[crc]
			else
				print("Image is not a PNG, url - " .. url)
			end
		end, function()
			print("Failed to get image, url - " .. url)
		end)
	end

	return MSD.ImgLib.NoMaterial
end
--PATH addons/[ui] msd_ui/lua/msd/ui/msdpanellist.lua:
return gluapack()()
--PATH lua/mvp/core/sh_data.lua:
return gluapack()()
--PATH lua/mvp/core/sh_quick.lua:
mvp = mvp or {}
mvp.q = mvp.q or {}

local weightToName = {
    [100] = "Proxima Nova Th",
    [200] = "Proxima Nova Lt",
    [300] = "Proxima Nova Lt",
    [400] = "Proxima Nova Rg",
    [500] = "Proxima Nova Rg",
    [600] = "Proxima Nova Semibold",
    [700] = "Proxima Nova Bold",
    [800] = "Proxima Nova Extrabold",
    [900] = "Proxima Nova Bl"
}

function mvp.q.Font(size, weight)
    return mvp.fonts.Get(size, weightToName[weight] or "Proxima Nova Rg", weight)
end

function mvp.q.Lang(key, ...)
    return mvp.language.GetPhrase(key, ...)
end
function mvp.q.LangFallback(key, fallback, ...)
    local phrase = mvp.language.GetPhrase(key, ...)

    if (string.StartsWith(phrase, "notfound#")) then
        return string.format(fallback, ...)
    end

    return phrase
end

function mvp.q.Notify(type, title, text, duration, target)
    if (SERVER) then
        if (target ~= nil) then
            mvp.notification.Send(target, type, title, text, duration)
        else
            mvp.notification.SendAll(type, title, text, duration)
        end
    else
        mvp.notification.Add(type, title, text, duration)
    end
end
function mvp.q.NotifyInfo(title, text, duration, target)
    mvp.q.Notify(mvp.NOTIFICATION.INFO, title, text, duration, target)
end
function mvp.q.NotifyWarn(title, text, duration, target)
    mvp.q.Notify(mvp.NOTIFICATION.WARN, title, text, duration, target)
end
function mvp.q.NotifyError(title, text, duration, target)
    mvp.q.Notify(mvp.NOTIFICATION.ERROR, title, text, duration, target)
end
function mvp.q.NotifySuccess(title, text, duration, target)
    mvp.q.Notify(mvp.NOTIFICATION.SUCCESS, title, text, duration, target)
end
function mvp.q.NotifyFail(title, text, duration, target)
    mvp.q.Notify(mvp.NOTIFICATION.FAIL, title, text, duration, target)
end

function mvp.q.LogInfo(...)
    mvp.logger.Log(mvp.LOG.INFO, ...)
end
function mvp.q.LogWarn(...)
    mvp.logger.Log(mvp.LOG.WARN, ...)
end
function mvp.q.LogError(...)
    mvp.logger.Log(mvp.LOG.ERROR, ...)
end
function mvp.q.LogDebug(...)
    mvp.logger.Log(mvp.LOG.DEBUG, ...)
end
function mvp.q.LogFatal(...)
    mvp.logger.Log(mvp.LOG.FATAL, ...)
end


--PATH lua/mvp/thirdparty/cl_spoly.lua:
return gluapack()()
--PATH lua/mvp/thirdparty/cl_threegrid.lua:
local PANEL = {}

AccessorFunc(PANEL, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(PANEL, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(PANEL, "columns", "Columns", FORCE_NUMBER)

function PANEL:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)

	self.Rows = {}
	self.Cells = {}
end

function PANEL:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells/cols)+1
	self.Rows[idx] = self.Rows[idx] || self:CreateRow()

	local margin = self:GetHorizontalMargin()
	
	pnl:SetParent(self.Rows[idx])
	pnl:Dock(LEFT)
	pnl:DockMargin(0, 0, #self.Rows[idx].Items+1 < cols && self:GetHorizontalMargin() || 0, 0)
	pnl:SetWide((self:GetWide()-margin*(cols-1))/cols)

	table.insert(self.Rows[idx].Items, pnl)
	table.insert(self.Cells, pnl)
	self:CalculateRowHeight(self.Rows[idx])
end

function PANEL:PerformLayout(w)
	local width = w

	-- Calculate the width of each cell
	local cols = self:GetColumns()
	local margin = self:GetHorizontalMargin()
	local cellWidth = (width - margin * (cols-  1)) / cols

	if ( self.VBar.Enabled ) then cellWidth = cellWidth - (self.VBar:GetWide() / cols) end

	-- Set the width of each cell
	for k, v in pairs(self.Cells) do
		v:SetWide(cellWidth)
	end

	local margin = self:GetVerticalMargin()
	local height = 0

	for k, v in pairs(self.Rows) do
		v:SetPos(0, height)
		height = height + v:GetTall() + margin
	end
end

function PANEL:CreateRow()
	local row = self:Add("DPanel")
	row:Dock(TOP)
	row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Paint = nil
	row.Items = {}
	return row
end

function PANEL:GetRowsHeight()
	local height = 0

	for k, v in pairs(self.Rows) do
		height = height + v:GetTall() + self:GetVerticalMargin()
	end

	return height - self:GetVerticalMargin()
end

function PANEL:CalculateRowHeight(row)
	local height = 0

	for k, v in pairs(row.Items) do
		height = math.max(height, v:GetTall())
	end

	row:SetTall(height)
end

function PANEL:Skip()
	local cell = vgui.Create("DPanel")
	cell.Paint = nil
	self:AddCell(cell)
end

function PANEL:Clear()
	for _, row in pairs(self.Rows) do
		for _, cell in pairs(row.Items) do
			cell:Remove()
		end
		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
end

PANEL.OnRemove = PANEL.Clear

vgui.Register("ThreeGrid", PANEL, "mvp.ScrollPanel")
--PATH lua/mvp/core/ui/cl_animations.lua:
mvp = mvp or {}
mvp.ui = mvp.ui or {}

function mvp.ui.Ease(t, b, c, d)
    t = t / d
    local ts = t * t
    local tc = ts * t

    return b + c * (-2 * tc + 3 * ts)
end

local PNL = FindMetaTable("Panel")

function PNL:Lerp(var, to, duration, callback)
    if (not duration) then duration = 0.5 end

    local start = self[var]

    local animation = self:NewAnimation(duration)
    animation.goalValue = to

    animation.Think = function(anim, panel, fraction)
        local newFraction = mvp.ui.Ease(fraction, 0, 1, 1)

        if (not anim.startValue) then
            anim.startValue = start
        end

        local value = Lerp(newFraction, anim.startValue, anim.goalValue)
        self[var] = value
    end

    if (callback) then
        animation.OnEnd = function(anim, panel)
            callback()
        end
    end
end

function PNL:LerpColor(var, to, duration, callback)
    if (not duration) then duration = 0.5 end

    local start = self[var]

    local animation = self:NewAnimation(duration)
    animation.goalValue = to

    animation.Think = function(anim, panel, fraction)
        local newFraction = mvp.ui.Ease(fraction, 0, 1, 1)

        if (not anim.startValue) then
            anim.startValue = start
        end

        local value = mvp.utils.LerpColor(newFraction, anim.startValue, anim.goalValue)
        self[var] = value
    end

    if (callback) then
        animation.OnEnd = function(anim, panel)
            callback()
        end
    end
end

function PNL:LerpPositionX(to, duration, callback)
    if (not duration) then duration = 0.5 end

    local start = self:GetX()
    local animation = self:NewAnimation(duration)
    animation.goalValue = to

    animation.Think = function(anim, panel, fraction)
        local newFraction = mvp.ui.Ease(fraction, 0, 1, 1)

        if (not anim.startValue) then
            anim.startValue = start
        end

        local value = Lerp(newFraction, anim.startValue, anim.goalValue)
        self:SetX(value)
    end

    if (callback) then
        animation.OnEnd = function(anim, panel)
            callback()
        end
    end
end
--PATH lua/mvp/languages/ru.lua:
return gluapack()()
--PATH lua/mvp/configs/terminal.lua:
return gluapack()()
--PATH lua/mvp/core/command/sh_command.lua:
return gluapack()()
--PATH lua/mvp/packages/radialmenu/ui/cl_wheel.lua:
return gluapack()()
--PATH lua/mvp/packages/radialmenu/cl_radialmenu.meta.lua:
local P = mvp.package.Get()

mvp = mvp or {}
mvp.meta = mvp.meta or {}
mvp.meta.radialMenu = {}

mvp.meta.radialMenu.__proto = mvp.meta.radialMenu
mvp.meta.radialMenu.__proto.isRadialMenu = true
mvp.meta.radialMenu.__proto.options = {}

function mvp.meta.radialMenu:New()
    local o = table.Copy(self.__proto)

    setmetatable(o, self)
    o.__index = self

    return o
end

function mvp.meta.radialMenu:AddOption(title, description, icon, color, click)
    local option = mvp.meta.radialMenuOption:New()

    local overlayIcon = nil
    local isModel = false
    if (istable(icon)) then
        overlayIcon = icon[2]
        isModel = icon[3] or false
        entityLayoutFunc = icon[4] or nil

        icon = icon[1]
    end

    option:SetName(title)
    option:SetDescription(description)
    option:SetIcon(icon)
    option:SetOverlayIcon(overlayIcon)
    option:SetIsModel(isModel)
    option:SetEntLayoutFunc(entityLayoutFunc)
    option:SetColor(color)

    if (click) then
        option.Click = click
    end

    table.insert(self.options, option)

    return option
end

function mvp.meta.radialMenu:Open()
    if (#self.options <= 0) then
        mvp.q.LogError(nil, "Radial menu has no options")
        return
    end

    P.ShowRadialMenu(self.options)
end

mvp.meta.radialMenuOption = {}

mvp.meta.radialMenuOption.__proto = mvp.meta.radialMenuOption
mvp.meta.radialMenuOption.__proto.isRadialMenuOption = true

mvp.meta.radialMenuOption.__proto._name = "Option"
AccessorFunc(mvp.meta.radialMenuOption, "_name", "Name", FORCE_STRING)

mvp.meta.radialMenuOption.__proto._description = "Description"
AccessorFunc(mvp.meta.radialMenuOption, "_description", "Description", FORCE_STRING)

mvp.meta.radialMenuOption.__proto._icon = nil
AccessorFunc(mvp.meta.radialMenuOption, "_icon", "Icon")

mvp.meta.radialMenuOption.__proto._isModel = false
AccessorFunc(mvp.meta.radialMenuOption, "_isModel", "IsModel")

mvp.meta.radialMenuOption.__proto._entLayoutFunc = nil
AccessorFunc(mvp.meta.radialMenuOption, "_entLayoutFunc", "EntLayoutFunc")

mvp.meta.radialMenuOption.__proto._color = mvp.colors.Text
AccessorFunc(mvp.meta.radialMenuOption, "_color", "Color")

mvp.meta.radialMenuOption.__proto._overlayIcon = nil
AccessorFunc(mvp.meta.radialMenuOption, "_overlayIcon", "OverlayIcon")

function mvp.meta.radialMenuOption:New()
    local o = table.Copy(self.__proto)

    setmetatable(o, self)
    o.__index = self

    return o
end

function mvp.meta.radialMenuOption:Click()
    -- for override

    mvp.q.LogError(nil, "Radial menu option click not implemented")
end

function mvp.meta.radialMenuOption:AddSubOption(title, description, icon, color, click)
    if (self.subMenu) then
        return self.subMenu:AddOption(title, description, icon, color, click)
    end

    self.subMenu = mvp.meta.radialMenu:New()
    local option = self.subMenu:AddOption(title, description, icon, color, click)

    self.Click = function(opt)
        opt.subMenu:Open()
    end

    return option
end
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/sh_animations_list.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/languages/ru.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/cl_credits.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/configs/simpledefcons.lua:
local DEFCONS_SECTION = mvp.config.RegisterSection("simpledefcons")

local GENERAL_GROUP = mvp.config.RegisterCategory("general", DEFCONS_SECTION, 1)

mvp.config.Add("simpledefcons.timeOnScreen", 5, {
    description = "Time in seconds that the defcon message will be on screen",
    category = GENERAL_GROUP,

    ui = {}
}, 1)

mvp.config.Add("simpledefcons.allowChatCommand", true, {
    description = "Allow players to change the defcon status using a chat command",
    category = GENERAL_GROUP,

    ui = {}
}, 2)

mvp.config.Add("simpledefcons.persistDefcons", true, {
    description = "Persist the defcon status between server restarts",
    category = GENERAL_GROUP,

    ui = {}
}, 3)

local defaultDefconsList = {
    [1] = {
        name = "DEFCON 5",
        color = mvp.colors.Green,
        description = "DEFCON 5 is now in effect. Base operations are proceeding as normal. Continue with your assigned tasks. Maintain readiness protocols and report any anomalies to your commanding officer.",
        sound = "mvp/simpledefcons/male/defcon5.wav"
    },
    [2] = {
        name = "DEFCON 4",
        color = mvp.colors.Blue,
        description = "DEFCON 4 is now in effect. Increase monitoring of all sensor arrays and communication channels. There are indications of potential threats in nearby sectors. Remain alert and ready for rapid deployment if necessary. All units are advised to review and be prepared to enact contingency plans. Report any suspicious activity immediately to your commanding officer.",
        sound = "mvp/simpledefcons/male/defcon4.wav"
    },
    [3] = {
        name = "DEFCON 3",
        color = mvp.colors.Yellow,
        description = "DEFCON 3 is now in effect. This is not a drill. Heighten all security measures across the base. Prepare all defense systems for immediate activation. Enemy forces have been detected within close proximity to our location. All units are to stand by for further orders. Prepare for the possibility of imminent engagement. Be ready to execute defensive maneuvers upon command.",
        sound = "mvp/simpledefcons/male/defcon3.wav"
    },
    [4] = {
        name = "DEFCON 2",
        color = mvp.colors.Orange,
        description = "DEFCON 2 is now in effect. This is a critical situation. All units are to assume battle stations immediately. Prepare for imminent hostilities. Secure all vital systems and personnel. Weapons systems are to be armed and standing by for engagement. Be prepared to execute combat protocols upon command.",
        sound = "mvp/simpledefcons/male/defcon2.wav"
    },
    [5] = {
        name = "DEFCON 1",
        color = mvp.colors.Red,
        description = "DEFCON 1 is now in effect. This is an emergency situation. All units are to enact maximum security measures. Prepare for immediate engagement with hostile forces. This is a code red alert. All non-essential personnel are to seek shelter immediately. Combat units are to engage the enemy with full force.",
        sound = "mvp/simpledefcons/male/defcon1.wav"
    }
}
local deleteMaterial = Material("mvp/simpledefcons/delete.png", "smooth")

mvp.config.Add("simpledefcons.defcons", defaultDefconsList, {
    description = "List of defcon levels",
    category = GENERAL_GROUP,

    ui = {
        type = "custom",
        open = function(config, val, setValue)
            val = table.Copy(val)

            local spacing = mvp.ui.Scale(10)
            local frame = vgui.Create("mvp.Frame")
            frame:SetSize(700, 500)
            frame:Center()
            frame:MakePopup()
            frame:SetTitle(mvp.q.Lang("simpledefcons.configure_defcons"))

            local defconsList = vgui.Create("mvp.ScrollPanel", frame)
            defconsList:Dock(FILL)
            defconsList:DockMargin(spacing, 0, spacing, spacing)

            local function populateMenu()
                for k, v in pairs(val) do
                    local pnl = vgui.Create("EditablePanel", defconsList)
                    pnl:Dock(TOP)
                    pnl:SetTall(mvp.ui.Scale(200))
                    pnl:DockMargin(0, 0, 0, spacing)
    
                    function pnl:Paint(w, h)
                        draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))
                    end
    
                    local positionControls = vgui.Create("EditablePanel", pnl)
                    positionControls:Dock(LEFT)
                    positionControls:DockMargin(spacing, spacing, 0, spacing)
                    positionControls:SetWide(mvp.ui.Scale(50))
    
                    local moveUp = vgui.Create("mvp.Button", positionControls)
                    moveUp:Dock(TOP)
                    moveUp:InvalidateParent(true)
                    moveUp:SetRoundness(mvp.ui.ScaleWithFactor(8))
                    moveUp:SetText("")
                    moveUp:SetFont(mvp.q.Font(24, 800))
                    moveUp:SetTall(moveUp:GetWide())
    
                    moveUp.DoClick = function()
                        if k == 1 then return end

                        
                        local temp = val[k]
                        val[k] = val[k - 1]
                        val[k - 1] = temp
                        
                        setValue(val)
                        defconsList:Clear()
                        populateMenu()
                    end

                    local divider = vgui.Create("DPanel", positionControls)
                    divider:Dock(TOP)
                    divider:DockMargin(0, spacing, 0, spacing)
                    divider:SetTall(2)

                    function divider:Paint(w, h)
                        draw.RoundedBox(0, 0, 0, w, h, mvp.colors.BackgroundHover)
                    end

                    local moveDown = vgui.Create("mvp.Button", positionControls)
                    moveDown:Dock(TOP)
                    moveDown:InvalidateParent(true)
                    moveDown:SetRoundness(mvp.ui.ScaleWithFactor(8))
                    moveDown:SetText("")
                    moveDown:SetFont(mvp.q.Font(24, 800))
                    moveDown:SetTall(moveDown:GetWide())

                    moveDown.DoClick = function()
                        if k == #val then return end

                        local temp = val[k]
                        val[k] = val[k + 1]
                        val[k + 1] = temp
                        
                        setValue(val)
                        defconsList:Clear()
                        populateMenu()
                    end

                    local removeButton = vgui.Create("mvp.ImageButton", positionControls)
                    removeButton:Dock(BOTTOM)
                    removeButton:InvalidateParent(true)
                    removeButton:SetRoundness(mvp.ui.ScaleWithFactor(8))
                    removeButton:SetTall(removeButton:GetWide())
                    removeButton:SetStyle("danger")
                    removeButton:SetImage(deleteMaterial)

                    removeButton.DoClick = function()
                        table.remove(val, k)
                        setValue(val)
                        defconsList:Clear()
                        populateMenu()
                    end
    
                    local topRow = vgui.Create("EditablePanel", pnl)
                    topRow:Dock(TOP)
                    topRow:DockMargin(spacing, spacing, spacing, 0)
                    topRow:SetTall(mvp.ui.Scale(40))
    
                    local defconName = vgui.Create("mvp.TextEntry", topRow)
                    defconName:SetRoundness(mvp.ui.ScaleWithFactor(8))
                    defconName:SetText(tostring(v.name))
                    defconName:SetUpdateOnType(true)
                    defconName:Dock(FILL)
                    defconName:SetTall(mvp.ui.Scale(40))
                    defconName:SetPlaceholderText(mvp.q.Lang("simpledefcons.defcon_name"))
    
                    defconName.OnValueChange = function(self, nameVal)
                        local name = tostring(nameVal)
                        if not name then return end
                        val[k].name = name
    
                        setValue(val)
                    end
    
                    local defconColor = vgui.Create("mvp.Button", topRow)
                    defconColor:SetRoundness(mvp.ui.ScaleWithFactor(8))
                    defconColor:Dock(RIGHT)
                    defconColor:DockMargin(spacing, 0, 0, 0)
                    defconColor:InvalidateParent(true)
                    defconColor:SetWide(defconColor:GetTall())
                    defconColor:SetText("")
    
                    function defconColor:Paint(w, h)
                        draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, v.color)
                    end
    
                    function defconColor:DoClick()
                        local mousePosX, mousePosY = gui.MouseX(), gui.MouseY()
                        local colorPickerFrame = vgui.Create("mvp.Frame")
                        colorPickerFrame:SetSize(300, 300)
                        colorPickerFrame:SetPos(mousePosX - 150, mousePosY - 150)
                        colorPickerFrame:MakePopup()
                        colorPickerFrame:SetTitle(mvp.q.Lang("simpledefcons.defcon_color"))
                        -- colorPickerFrame:DockPadding(spacing, 0, spacing, spacing)
    
                        local colorPicker = vgui.Create("DColorMixer", colorPickerFrame)
                        colorPicker:Dock(FILL)
                        colorPicker:DockMargin(spacing, 0, spacing, spacing)
                        colorPicker:SetColor(v.color)
    
                        local applyButton = vgui.Create("mvp.Button", colorPickerFrame)
                        applyButton:Dock(BOTTOM)
                        applyButton:DockMargin(spacing, spacing, spacing, spacing)
                        applyButton:SetText(mvp.q.Lang("simpledefcons.apply"))
    
                        function applyButton:DoClick()
                            val[k].color = colorPicker:GetColor()
                            setValue(val)
    
                            colorPickerFrame:Remove()
                        end
                    end
    
                    local defconDescription = vgui.Create("mvp.TextEntry", pnl)
                    defconDescription:SetRoundness(mvp.ui.ScaleWithFactor(8))
                    defconDescription:SetText(tostring(v.description))
                    defconDescription:SetUpdateOnType(true)
                    defconDescription:Dock(FILL)
                    defconDescription:DockMargin(spacing, spacing, spacing, spacing)
                    defconDescription:SetMultiline(true)
                    defconDescription:SetPlaceholderText(mvp.q.Lang("simpledefcons.defcon_description"))
    
                    defconDescription.OnValueChange = function(self, descriptionVal)
                        local description = tostring(descriptionVal)
                        if not description then return end
                        val[k].description = description
    
                        setValue(val)
                    end
    
                    local defconSound = vgui.Create("mvp.TextEntry", pnl)
                    defconSound:SetRoundness(mvp.ui.ScaleWithFactor(8))
                    defconSound:SetText(v.sound and tostring(v.sound) or "")
                    defconSound:SetPlaceholderText(mvp.q.Lang("simpledefcons.defcon_sound"))
                    defconSound:SetUpdateOnType(true)
                    defconSound:Dock(BOTTOM)
                    defconSound:DockMargin(spacing, 0, spacing, spacing)
                    defconSound:SetTall(mvp.ui.Scale(40))
    
                    defconSound.OnValueChange = function(self, soundVal)
                        local sound = tostring(soundVal)
                        if not sound then return end
                        val[k].sound = sound
    
                        setValue(val)
                    end
                end
            end

            populateMenu()

            local addButton = vgui.Create("mvp.Button", frame)
            addButton:Dock(BOTTOM)
            addButton:DockMargin(spacing, 0, spacing, spacing)
            addButton:SetText(mvp.q.Lang("simpledefcons.add_defcon"))
            addButton:SetRoundness(mvp.ui.ScaleWithFactor(8))
            addButton:SetTall(mvp.ui.Scale(40))

            function addButton:DoClick()
                table.insert(val, {
                    name = "DEFCON " .. #val + 1,
                    color = mvp.colors.Text,
                    description = "Insert description here",
                    sound = ""
                })

                setValue(val)
                defconsList:Clear()
                populateMenu()
            end
        end
    }

}, 4)

mvp.config.Add("simpledefcons.allowedJobs", {}, {
    description = "Jobs that are allowed to change the defcon status",
    category = GENERAL_GROUP,

    ui = {
        type = "custom",
        open = function(config, val, setValue)
            val = table.Copy(val)

            local spacing = mvp.ui.Scale(10)
            local frame = vgui.Create("mvp.Frame")
            frame:SetSize(700, 500)
            frame:Center()
            frame:MakePopup()
            frame:SetTitle(mvp.q.Lang("simpledefcons.configure_allowed_jobs"))

            local jobsSearch = vgui.Create("mvp.TextEntry", frame)
            jobsSearch:Dock(TOP)
            jobsSearch:DockMargin(spacing, 0, spacing, spacing)
            jobsSearch:SetTall(mvp.ui.Scale(40))
            jobsSearch:SetPlaceholderText(mvp.q.Lang("simpledefcons.search_jobs"))
            jobsSearch:SetUpdateOnType(true)

    
            local allJobs = team.GetAllTeams()
            local jobsList = vgui.Create("mvp.ScrollPanel", frame)
            jobsList:Dock(FILL)
            jobsList:DockMargin(spacing, 0, spacing, spacing)

            local function populateMenu()
                jobsList:Clear()

                for k, v in pairs(allJobs) do
                    if k == 0 then continue end

                    if (jobsSearch:GetText() ~= "" and not string.find(string.lower(v.Name), string.lower(jobsSearch:GetText()))) then continue end

                    local pnl = vgui.Create("EditablePanel", jobsList)
                    pnl:Dock(TOP)
                    pnl:SetTall(mvp.ui.Scale(50))
                    pnl:DockMargin(0, 0, 0, spacing)

                    function pnl:Paint(w, h)
                        draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))
                        draw.SimpleText(v.Name, mvp.q.Font(24, 600), spacing, h * .5, mvp.colors.Text, nil, TEXT_ALIGN_CENTER)
                    end

                    local allowed = vgui.Create("mvp.CheckBox", pnl)
                    allowed:Dock(RIGHT)
                    allowed:DockMargin(spacing, spacing, spacing, spacing)
                    allowed:InvalidateParent(true)
                    allowed:SetWide(allowed:GetTall())
                    allowed:SetChecked(val[v.Name] or false)

                    allowed.OnChanged = function(self, isChecked)
                        val[v.Name] = isChecked
                        setValue(val)
                    end
                end
            end

            populateMenu()

            jobsSearch.OnValueChange = function(self, searchVal)
                populateMenu()
            end
        end
    }
}, 5)

local APPEARANCE_GROUP = mvp.config.RegisterCategory("appearance", DEFCONS_SECTION, 2)

mvp.config.Add("simpledefcons.showHUD", true, {
    description = "Show the defcon status on the HUD",
    category = APPEARANCE_GROUP,

    ui = {}
}, 1)

mvp.config.Add("simpledefcons.hudPosition", "tc", {
    description = "Position of the defcon status on the screen",
    category = APPEARANCE_GROUP,

    ui = {
        type = "dropdown",
        choices = function()
            local positionsKeys = {"tl", "tc", "tr", "cl", "cr", "bl", "bc", "br"}
            local positions = {}

            for _, pos in ipairs(positionsKeys) do
                positions[pos] = mvp.q.Lang("general.screen_position." .. pos)
            end

            return positions
        end
    }
}, 2)

mvp.config.Add("simpledefcons.entityManagerModel", "models/reizer_props/alysseum_project/medicine_obj/med_table_01/med_table_01.mdl", {
    description = "Model for entity that will be used to change the defcon status",
    category = APPEARANCE_GROUP,

    ui = {}
}, 3)

mvp.config.Add("simpledefcons.entityDisplayModel", "models/reizer_props/alysseum_project/misc_stuff/wall_lamp_01/wall_lamp_01.mdl", {
    description = "Model for entity that will be used to display the defcon status",
    category = APPEARANCE_GROUP,

    ui = {}
}, 4)

--PATH lua/mvp/vgui/cl_category_list.lua:
local PANEL = {}

DEFINE_BASECLASS( "DScrollPanel" )
local arrowMaterial = Material("mvp/terminal/vgui/arrow.png", "smooth")

function PANEL:Init()
    self.pnlCanvas:DockPadding( 2, 2, 2, 2 )
end

function PANEL:AddItem( item )

    item:Dock( TOP )

    BaseClass.AddItem( self, item )
    self:InvalidateLayout(true)
end

function PANEL:Add( name )

    local Category = vgui.Create( "DCollapsibleCategory", self )
    Category:SetLabel( name )
    Category:SetList( self )

    Category:SetHeaderHeight(mvp.ui.Scale(48))

    Category.angle = Category:GetExpanded() and 180 or 0

    Category.Paint = function(pnl, w, h)
        local headerHeight = pnl:GetHeaderHeight()

        draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, headerHeight, mvp.colors.SecondaryBackground)

        surface.SetDrawColor(ColorAlpha(mvp.colors.Text, pnl:GetExpanded() and 255 or 150))
        surface.SetMaterial(arrowMaterial)
        surface.DrawTexturedRectRotated(w - headerHeight * .5, headerHeight * .5, headerHeight * .5, headerHeight * .5, pnl.angle)

        if (pnl:GetExpanded()) then
            pnl.angle = Lerp(FrameTime() * 10, pnl.angle, 180)
        else
            pnl.angle = Lerp(FrameTime() * 10, pnl.angle, 0)
        end
    end

    local catHeader = Category.Header
    catHeader:SetFont(mvp.Font(18, 600))
    catHeader:DockMargin(mvp.ui.Scale(10) - 5, 0, 0, mvp.ui.Scale(10) * .5)

    self:AddItem( Category )

    return Category
end

function PANEL:Paint(w, h)
    -- do nothing
end

vgui.Register("mvp.CategoryList", PANEL, "mvp.ScrollPanel")
--PATH lua/mvp/vgui/cl_text_enty.lua:
local PANEL = {}

AccessorFunc(PANEL, "roundness", "Roundness")

function PANEL:Init()
    self.textEntry = vgui.Create("DTextEntry", self)
    self.textEntry:Dock(FILL)
    self.textEntry:DockMargin(8, 0, 8, 0)
    self.textEntry:SetFont(mvp.Font(18, 600))
    self.textEntry:SetTextColor(mvp.colors.Text)
    self.textEntry:SetHighlightColor(mvp.colors.SecondaryBackground)
    self.textEntry:SetCursorColor(mvp.colors.Text)
    self.textEntry:SetPaintBackground(false)
    -- self.textEntry:SetText("das")

    self.textEntry.OnGetFocus = function()
        self:OnGetFocus()
    end
    self.textEntry.OnLoseFocus = function()
        self:OnLoseFocus()
    end

    self.textEntry.OnValueChange = function(_, val)
        self:OnValueChange(val)
    end

    -- self:DockPadding(8, 8, 8, 8)

    self:SetRoundness(mvp.ui.ScaleWithFactor(16))

    self.colors = {}
    self.colors.Background = mvp.colors.SecondaryBackground
    self.colors.BackgroundFocused = mvp.colors.SecondaryAccent

    self.backgroundColor = self.colors.Background

    local textEntryBase = baseclass.Get("DTextEntry")
    for k, v in pairs(textEntryBase) do
        if not self[k] then
            self[k] = function(_, ...)
                return v(self.textEntry, ...)
            end
        end
    end
end

function PANEL:SetText(text)
    self.textEntry:SetText(text)
end

function PANEL:GetText()
    return self.textEntry:GetText()
end

function PANEL:SetMultiline(val)
    self.textEntry:SetMultiline(val)    

    if (val) then
        self.textEntry:DockMargin(8, 8, 8, 8)
    else
        self.textEntry:DockMargin(8, 0, 8, 0)
    end
end

function PANEL:OnValueChange(val)
    -- override
end

function PANEL:Paint(w, h)
    draw.RoundedBox(self.roundness, 0, 0, w, h, self.backgroundColor)
end

function PANEL:OnGetFocus()
    self:LerpColor("backgroundColor", self.colors.BackgroundFocused, .2)
end

function PANEL:OnLoseFocus()
    self:LerpColor("backgroundColor", self.colors.Background, .2)
end

vgui.Register("mvp.TextEntry", PANEL, "EditablePanel")
--PATH lua/mvp/vgui/sidebar/cl_sidebar_hint.lua:
local PANEL = {}

local roundness = mvp.ui.ScaleWithFactor(16)
local spaceBetween = mvp.ui.Scale(10)

local sidebarHintFont = mvp.Font(16, 500)

AccessorFunc(PANEL, "hintFor", "HintFor")
AccessorFunc(PANEL, "text", "Text")

function PANEL:Init()
    self.text = "Sidebar"
    self.alpha = 0

    self:SetZPos(100)
end

function PANEL:Paint(w, h)
    surface.SetAlphaMultiplier(self.alpha / 255)

    draw.RoundedBox(h * .5 - 5, 0, 0, w, h, mvp.colors.Background)
    draw.SimpleText(self.text, sidebarHintFont, spaceBetween, h / 2, mvp.colors.Text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    surface.SetAlphaMultiplier(1)
    return true
end

function PANEL:PerformLayout(w, h)
    surface.SetFont(sidebarHintFont)
    
    local textWidth, textHeight = surface.GetTextSize(self.text)
    
    self:SetWide(textWidth + spaceBetween * 2)
end

function PANEL:Think()
    local x, y  = self:GetHintFor():LocalToScreen(0, 0)
    local w, h = self:GetHintFor():GetSize()
    local sW, sH = self:GetSize()
    
    self:SetPos(x - sW - 10, y + h * .5 - sH * .5)
end

vgui.Register("mvp.SidebarHint", PANEL, "EditablePanel")
--PATH lua/ncs_shared/cl_imgur.lua:
return gluapack()()
--PATH lua/ncs_shared/currencies/currencies/sh_blank.lua:
return gluapack()()
--PATH lua/ncs_shared/currencies/currencies/sh_nutscript.lua:
NCS_SHARED.RegisterCurrency("nutscript", {
    addMoney = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        if AMOUNT > 0 then
            P:getChar():giveMoney(AMOUNT)
        else
            P:getChar():takeMoney(AMOUNT)
        end
    end,
    canAfford = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        if not P:getChar():hasMoney(AMOUNT) then
            return false
        else
            return true
        end
    end,
    getMoney = function(P)
        return P:getChar():getMoney()
    end,
    formatMoney = function(AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        return nut.currency.get(AMOUNT)
    end,
})
--PATH lua/autorun/npc_buzz_droid.lua:
local Category = "Star Wars"
local NPC = { 	Name = "Buzz Droid", 
		Class = "npc_manhack",
		Weapons = { "" },
		Model = "models/loic_buzzdroid/buzzdroid.mdl",
		Health = "25",
		Numgrenades = "0",
		Category = Category}
list.Set( "NPC", "npc_buzz_droid", NPC )
--PATH lua/autorun/officer.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/autorun/onyx_autorun.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};
_G.pon = pon;

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY

			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end

--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_netchunk.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_netchunk.lua:
--[[
MIT License

Copyright (c) 2023 Aleksandrs Filipovskis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

if (netchunk) then return end

netchunk = netchunk or {}
netchunk.chunks = netchunk.chunks or {}
netchunk.registered = netchunk.registered or {}
-- netchunk.maxBytes = 32768
netchunk.maxBytes = 16384

local split do
    local len = string.len
    local sub = string.sub
    local maxBytes = netchunk.maxBytes

    function split(data)
        local length = len(data)
        local index = 1
        local last = 1
        local chunks = {}

        for i = 1, length do
            if (i - last + 1) > maxBytes then
                chunks[index] = sub(data, last, i)
                index = index + 1
                last = i + 1
            end
        end

        chunks[index] = sub(data, last, length)

        return chunks
    end
end

local function merge(chunks)
    local result = ''

    for i = 1, #chunks do
        result = result .. chunks[i]
    end

    return result
end

function netchunk.Register(name)
    if (SERVER) then
        util.AddNetworkString('netchunk[' .. name .. ']:Send')
    end

    netchunk.registered[name] = true
    netchunk.chunks[name] = {}
end

if (SERVER) then
    local function send(ply)
        if ply then
            net.Send(ply)
        else
            net.Broadcast()
        end
    end

    function netchunk.Send(ply, name, data)
        assert(netchunk.registered[name], 'Trying to send data during unregistered channel (`' .. name .. '`)')

        local encoded = pon.encode(data)
        local chunks = split(encoded)
        local count = #chunks

        for i = 1, count do
            local chunk = chunks[i]
            local length = #chunk

            net.Start('netchunk[' .. name .. ']:Send')
                net.WriteString(name)
                net.WriteUInt(length, 16)
                net.WriteData(chunks[i], length)
                net.WriteBool(i == count)
            send(ply)
        end
    end
else
    netchunk.callbacks = netchunk.callbacks or {}

    local ReadString = net.ReadString
    local ReadUInt = net.ReadUInt
    local ReadData = net.ReadData
    local ReadBool = net.ReadBool

    function netchunk.Callback(name, callback)
        assert(name)
        assert(callback)

        net.Receive('netchunk[' .. name .. ']:Send', function()
            local name = ReadString()
            local length = ReadUInt(16)
            local chunk = ReadData(length)
            local finished = ReadBool()

            local chunks = netchunk.chunks[name]

            chunks[#chunks + 1] = chunk

            if finished then
                local raw = merge(chunks)
                local amt = #chunks

                netchunk.chunks[name] = {}

                local data = pon.decode(raw)

                callback(data, #raw, amt)
            end
        end)
    end
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_anim.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_wimg.lua:
--[[

Copyright (c) 2022 Aleksandrs Filipovskis

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

--]]

onyx.wimg = onyx.wimg or {}
onyx.wimg.cache = onyx.wimg.cache or {}
-- onyx.wimg.proxy = 'https://proxy.duckduckgo.com/iu/?u=' -- it seems imgur has banned duckduckgo's proxy at 29/04/2023, you can try to enable it
onyx.wimg.proxy = ''

local wimg = onyx.wimg

local function printWarning(text)
    MsgC(color_white, '(', Color(153, 0, 255), 'wimg', color_white, ') ', text, '\n')
end

-- ANCHOR Queue

local addInQueue
do
    local http_Fetch = http.Fetch
    local table_remove = table.remove
    local file_Exists = file.Exists
    local file_Write = file.Write
    local insert = table.insert

    local basePath = 'wimg'
    local queue = {}
    local rate = 1 / 5

    if not file_Exists(basePath, 'DATA') then
        file.CreateDir(basePath)
    end

    local function findMaterial(name, format, parameters)
        local path = basePath .. '/' .. name .. format

        if file_Exists(path, 'DATA') then
            return Material('data/' .. path, parameters)
        end
    end

    local function saveMaterial(name, format, body)
        local path = basePath .. '/' .. name .. format

        file_Write(path, body)
    end

    function addInQueue(wimgObject)
        local name = wimgObject:GetName()
        local url = wimgObject:GetURL()
        local format = wimgObject:GetFormat()
        local parameters = wimgObject:GetParameters()
        local mat = findMaterial(name, format, parameters)

        if mat then
            wimgObject:SetMaterial(mat)
        else
            insert(queue, {
                name = name,
                url = url,
                format = format,
                parameters = parameters,
                wimgObject = wimgObject
            })
        end
    end

    timer.Create('onyx.wimg.ProcessQueue', rate, 0, function()
        local data = queue[1]
        if (data) then
            table_remove(queue, 1)

            local name = data.name
            local url = data.url
            local format = data.format
            local parameters = data.parameters
            local wimgObject = data.wimgObject

            local success, errorString = pcall(function()
                local mat = findMaterial(name, format, parameters)
                if mat then
                    wimgObject:SetMaterial(mat)
                else
                    http_Fetch(wimg.proxy .. url, function(body, size, headers, code)
                        if (code > 200) then
                            printWarning('Failed to fetch material (code: ' .. tostring(code) .. '), url: ' .. url)
                            return
                        end

                        saveMaterial(name, format, body)

                        local mat = findMaterial(name, format, parameters)
                        if (mat) then
                            if (wimgObject) then
                                wimgObject:SetMaterial(mat)
                            end
                        else
                            printWarning('Failed to fetch material after download! (url: ' .. url .. ')')
                        end
                    end, function(err)
                        printWarning(Format('Failed to download the image with name: \"%s\", url: %s, error: %s', name, url, err))
                    end)
                end
            end)

            if (not success) then
                printWarning('Error occured during image catchup: ' .. errorString)
            end
        end
    end)
end

-- ANCHOR Class

local WIMAGE = {}
WIMAGE.__index = WIMAGE

function WIMAGE.__eq(a, b)
    return a:GetName() == b:GetName()
end

AccessorFunc(WIMAGE, 'm_Name', 'Name')
AccessorFunc(WIMAGE, 'm_URL', 'URL')
AccessorFunc(WIMAGE, 'm_Format', 'Format')
AccessorFunc(WIMAGE, 'm_Material', 'Material')
AccessorFunc(WIMAGE, 'm_Parameters', 'Parameters')

do
    local SetDrawColor = surface.SetDrawColor
    local DrawTexturedRect = surface.DrawTexturedRect
    local SetMaterial = surface.SetMaterial
    local DrawTexturedRectRotated = surface.DrawTexturedRectRotated

    function WIMAGE:Draw(x, y, w, h, color)
        color = color or color_white

        local mat = self.m_Material

        if mat then
            SetDrawColor(color)
            SetMaterial(mat)
            DrawTexturedRect(x, y, w, h)
        end
    end

    function WIMAGE:DrawRotated(x, y, w, h, r, color)
        color = color or color_white

        local mat = self.m_Material

        if mat then
            SetDrawColor(color)
            SetMaterial(mat)
            DrawTexturedRectRotated(x, y, w, h, r)
        end
    end
end

function WIMAGE:Download()
    addInQueue(self)
end

function WIMAGE:GetWidth()
    return self.m_Material and self.m_Material:Width() or 0
end

function WIMAGE:GetTall()
    return self.m_Material and self.m_Material:Height() or 0
end

WIMAGE.__call = WIMAGE.Draw

-- ANCHOR Library

function wimg.Register(name, url)
    assert(name, 'No name provided')
    assert(url, 'No URL provided')
    wimg.cache[name] = url
end

function wimg.Create(name, parameters)
    assert(name, 'No name provided')

    local url = wimg.cache[name]
    local invalid = false

    if (not url) then
        ErrorNoHalt('There\'s no web image registered with name: ' .. name)
        invalid = true
    end

    local format = invalid and '_INVALID_' or string.match(url, '.%w+$')
    assert(format, 'wrong format for this url: ' .. url .. ' (' .. name ..  ')')

    local obj = setmetatable({
        m_Name = name,
        m_URL = url,
        m_Format = format,
        m_Parameters = parameters
    }, WIMAGE)

    if (not invalid) then
        obj:Download()
    end

    return obj
end

do
    local urlCache = {}

    local function encodeURL(url)
        return util.CRC(url)
    end

    function wimg.Simple(url, parameters)
        assert(url, 'No URL provided')
        assert(isstring(url), 'URL should be string!')

        if not urlCache[url] then
            urlCache[url] = encodeURL(url)
        end

        local uid = urlCache[url]

        wimg.Register(uid, url)

        return wimg.Create(uid, parameters)
    end
end

-- ANCHOR Test Section
--[[
    do
        wimg.Register('user', 'https://i.imgur.com/Q3OHblv.png')

        local userSmooth = wimg.Create('user', 'smooth mips')
        local userSharp = wimg.Create('user')
        local userQuick = wimg.Simple('https://i.imgur.com/Q3OHblv.png')

        print(userSharp == userSmooth)

        hook.Add('HUDPaint', 'wimg.Test', function()
            local size = math.abs(math.sin(CurTime() * .5)) * 256

            userSmooth:Draw(0, 0, size, size)
            userSharp:Draw(size, 0, size, size)
            userQuick:Draw(size * 2, 0, size, size)
            userQuick(size * 3, 0, size, size)
        end)
    end
]]

--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/cfg/cl_config.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

onyx.cfg.fontFamily = 'Comfortaa' -- probably does nothing, but I keep it just in case I missed something

local function hexcolor(hex)
	local r, g, b = string.match(hex, '#(..)(..)(..)')
	local a = string.len(hex) > 7 and string.Right(hex, 2) or "FF"

	return Color(tonumber(r, 16), tonumber(g, 16), tonumber(b, 16), tonumber(a, 16))
end

onyx.cfg.colors = {}
onyx.cfg.colors.primary = hexcolor('#26272E')
onyx.cfg.colors.secondary = hexcolor('#2A2C33')
onyx.cfg.colors.tertiary = hexcolor('#30323B')
onyx.cfg.colors.quaternary = hexcolor('#26272E')
onyx.cfg.colors.accent = Color(74, 172, 252)
onyx.cfg.colors.lightgray = Color(235, 235, 235)
onyx.cfg.colors.gray = Color(144, 144, 144)
onyx.cfg.colors.positive = Color(39, 174, 96)
onyx.cfg.colors.negative = Color(235, 77, 75)

onyx.wimg.Register('user', 'https://i.imgur.com/J1fNKdK.png')
onyx.wimg.Register('dashboard', 'https://i.imgur.com/9jAEe6f.png')
onyx.wimg.Register('home', 'https://i.imgur.com/Tv1U4pn.png')
onyx.wimg.Register('close', 'https://i.imgur.com/0jZwhKu.png')
onyx.wimg.Register('close-circle', 'https://i.imgur.com/Ee3TAhI.png')
onyx.wimg.Register('gear', 'https://i.imgur.com/njRQmA5.png')

hook.Call('onyx.ui.LoadedConfig')
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/core/cl_query.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/01/2024

--]]

function onyx.SimpleQuery(title, desc, showTextEntry, acceptCallback, acceptText, cancelCallback, cancelText)
    local margin = onyx.ScaleTall(25)
    local space = onyx.ScaleTall(10)

    local frame = vgui.Create('onyx.Frame')
    frame:SetTitle(title)
    frame:SetSize(ScrW() * .33, ScrH() * (showTextEntry and .225 or .175))
    frame:Center()
    frame:MakePopup()
    frame:ShowCloseButton(false)
    frame:Focus(true)

    local content = frame:Add('Panel')
    content:Dock(FILL)
    content:DockMargin(margin, margin, margin, margin)

    local lblDesc = content:Add('onyx.Label')
    lblDesc:SetContentAlignment(5)
    lblDesc:Dock(TOP)
    lblDesc:Font('Comfortaa@20')
    lblDesc:SetText(desc)
    lblDesc:SetAutoStretchVertical(true)
    lblDesc:DockMargin(0, 0, 0, space)
    frame.lblDesc = lblDesc

    local textEntry = content:Add('onyx.TextEntry')
    textEntry:Dock(TOP)
    textEntry:SetPlaceholderText('')
    textEntry:SetTall(onyx.ScaleTall(30))
    textEntry:DockMargin(0, 0, 0, space)
    textEntry:SetVisible(showTextEntry)
    frame.textEntry = textEntry

    local btnConfirm, btnDeny

    local footer = content:Add('Panel')
    footer:Dock(BOTTOM)
    footer:SetTall(onyx.ScaleTall(30))
    footer.PerformLayout = function(panel, w, h)
        btnConfirm:SetWide(w * .5)
        btnConfirm:Dock(LEFT)
        btnConfirm:DockMargin(0, 0, onyx.ScaleTall(5), 0)

        btnDeny:Dock(FILL)
        btnDeny:DockMargin(onyx.ScaleTall(5), 0, 0, 0)
    end

    -- localized above
    btnConfirm = footer:Add('onyx.Button')
    btnConfirm:SetText(acceptText or 'CONFIRM')
    btnConfirm:SetMasking(true)
    btnConfirm:SetGradientColor(Color(131, 255, 133))
    btnConfirm:SetColorIdle(Color(59, 161, 61))
    btnConfirm:Font('Comfortaa Bold@16')
    btnConfirm.DoClick = function(panel)
        if (acceptCallback(textEntry:GetValue()) ~= false) then
            frame:Remove()
        end
    end

    btnDeny = footer:Add('onyx.Button')
    btnDeny:SetText(cancelText or 'CANCEL')
    btnDeny:SetMasking(true)
    btnDeny:SetGradientColor(Color(255, 131, 131))
    btnDeny:SetColorIdle(Color(161, 59, 59))
    btnDeny:Font('Comfortaa Bold@16')
    btnDeny.DoClick = function(panel)
        frame:Remove()
        if (cancelCallback) then
            cancelCallback()
        end
    end

    return frame
end

function onyx.ChoosePlayer(title, desc, func, bIncludeClient, filter)
    local margin = onyx.ScaleTall(25)
    local space = onyx.ScaleTall(10)
    local client = LocalPlayer()
    local players = {}

    local colorTertiary = onyx:Config('colors.tertiary')

    local padding = onyx.ScaleTall(5)

    for _, ply in ipairs(player.GetAll()) do
        if (not bIncludeClient and ply == client) then continue end
        if (filter and not filter(ply)) then continue end

        table.insert(players, ply)
    end

    local frame = vgui.Create('onyx.Frame')
    frame:SetTitle(title)
    frame:SetSize(ScrW() * .25, ScrH() * .5)
    frame:Center()
    frame:MakePopup()
    frame:Focus(true)
    frame.buttons = {}

    local content = frame:Add('onyx.ScrollPanel')
    content:Dock(FILL)
    content:DockMargin(margin, margin, margin, margin)

    local lblDesc = content:Add('onyx.Label')
    lblDesc:SetContentAlignment(5)
    lblDesc:Dock(TOP)
    lblDesc:Font('Comfortaa@20')
    lblDesc:SetText(desc)
    lblDesc:SetAutoStretchVertical(true)
    lblDesc:DockMargin(0, 0, 0, space)
    frame.lblDesc = lblDesc

    for _, ply in ipairs(players) do
        local panel = content:Add('onyx.Button')
        panel:SetText('')
        panel:SetTall(onyx.ScaleTall(40))
        panel:SetColorIdle(onyx:Config('colors.primary'))
        panel:SetColorHover(onyx:Config('colors.secondary'))
        panel:DockPadding(padding, padding, padding, padding)
        panel.colorTertiary = colorTertiary
        panel.Paint = function(panel, w, h)
            draw.RoundedBox(8, 0, 0, w, h, panel.colorTertiary)
            draw.RoundedBox(8, 1, 1, w - 2, h - 2, panel.backgroundColor)
        end
        panel.DoClick = function()
            frame:Remove()
            if (func and IsValid(ply)) then
                func(ply)
            end
        end

        table.insert(frame.buttons, panel)

        local avatar = panel:Add('onyx.RoundedAvatar')
        avatar:Dock(LEFT)
        avatar:SetWide(panel:GetTall() - padding * 2)
        avatar:SetPlayer(ply, 64)
        avatar:DockMargin(0, 0, onyx.ScaleTall(7.5), 0)

        local lblTitle = panel:Add('onyx.Label')
        lblTitle:SetText(ply:Name())
        lblTitle:Font('Comfortaa Bold@16')
        lblTitle:Dock(TOP)
        lblTitle:SetTall(avatar:GetWide() / 2)
        panel.lblTitle = lblTitle

        local plyTeam = ply:Team()
        local lblSubTitle = panel:Add('onyx.Label')
        lblSubTitle:SetText(team.GetName(plyTeam))
        lblSubTitle:SetTextColor(team.GetColor(plyTeam))
        lblSubTitle:Font('Comfortaa@16')
        lblSubTitle:Dock(TOP)
        panel.lblSubTitle = lblSubTitle
    end

    return frame
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/traits/cl_click.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_category.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_combo.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

22/04/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorGray = Color(125, 125, 125)
local wimgArrow = onyx.wimg.Simple('https://i.imgur.com/KGC51Ws.png', 'smooth mips')

AccessorFunc(PANEL, 'm_CurrentOptionText', 'CurrentOptionText')
AccessorFunc(PANEL, 'm_Font', 'Font')
AccessorFunc(PANEL, 'm_colOutlineActiveColor', 'OutlineActiveColor')
AccessorFunc(PANEL, 'm_colOutlineIdleColor', 'OutlineIdleColor')
AccessorFunc(PANEL, 'm_bHideOptionIcon', 'HideOptionIcon')

function PANEL:Init()
    self:Import('click')
    self:Import('hovercolor')
    self:SetTall(onyx.ScaleTall(30))

    self:SetColorKey('backgroundColor')
    self:SetColorIdle(colorPrimary)
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5))

    self:SetFont(onyx.Font('Comfortaa@16'))

    self:SetOutlineIdleColor(colorSecondary)
    self:SetOutlineActiveColor(colorAccent)
    self:Reset()

    self.options = {}
end

function PANEL:SetOutlineIdleColor(color)
    self.m_colOutlineIdleColor = color
    self.currentOutlineColor = onyx.CopyColor(color)
end

function PANEL:Paint(w, h)
    local thickness = 1
    local currentOutlineColor = self.currentOutlineColor

    if (self.highlight) then
        currentOutlineColor = ColorAlpha(self.highlightColor, math.abs(math.sin(CurTime() * 6)) * 200 + 55)
        if (self.highlightEndTime and self.highlightEndTime <= CurTime()) then
            self:ResetHighlight()
        end
    end

    draw.RoundedBox(8, 0, 0, w, h, currentOutlineColor)
    draw.RoundedBox(8, thickness, thickness, w - thickness * 2, h - thickness * 2, self.backgroundColor)

    local x = onyx.ScaleWide(10)
    local material = self.wimage and self.wimage:GetMaterial() or self.material

    if (material and self.current > 0 and not self.m_bHideOptionIcon) then
        local size = onyx.ScaleTall(12)

        surface.SetDrawColor(color_white)
        surface.SetMaterial(material)
        surface.DrawTexturedRect(x, h * .5 - size * .5, size, size)

        x = x + size + onyx.ScaleWide(5)
    end

    draw.SimpleText(self.m_CurrentOptionText, self.m_Font, x, h * .5, self.current > 0 and color_white or colorGray, 0, 1)

    local sz = math.floor(h * .33)
    wimgArrow:DrawRotated(w - h * .5, h * .5, sz, sz, 0, color_white)
end

function PANEL:AddOption(text, data, bSelectedDefault, icon, url)
    return self:AddOptionAdvanced({
        text = text,
        data = data,
        bSelectedDefault = bSelectedDefault,
        icon = icon
    })
end

function PANEL:AddOptionAdvanced(tblOption)
    return table.insert(self.options, tblOption)
end

function PANEL:ChooseOptionID(index, bIgnoreProcessing)
    local option = self.options[index]
    assert(option, 'trying to set invalid option (index:' .. index .. ')')

    self:SetCurrentOptionText(option.text)
    self.current = index

    if (option.iconURL) then
        self.wimage = onyx.wimg.Simple(option.iconURL, option.iconParams)
    else
        self.wimage = nil
    end

    if (not bIgnoreProcessing) then
        self:Call('OnSelect', nil, index, option.text, option.data)
    end
end

function PANEL:GetSelectedID()
    return self.current
end

function PANEL:GetOptionData(index)
    index = index or self.current

    local option = self.options[index]
    if (option) then
        return option.data
    end
end

function PANEL:GetOptionText(index)
    index = index or self.current

    local option = self.options[index]
    if (option) then
        return option.text
    end
end

function PANEL:Reset()
    self.current = -1
    self.wimage = nil
    if (onyx.lang) then
        self:SetCurrentOptionText(onyx.lang:Get('Select an option'))
    else
        self:SetCurrentOptionText('Select an option')
    end
    if (IsValid(self.dmenu)) then
        self.dmenu:Close()
    end
end

function PANEL:Clear()
    self.options = {}
    self:Reset()
end

function PANEL:GetOptions()
    return self.options
end

function PANEL:FindOptionByData(data)
    for index, option in ipairs(self.options) do
        if (option.data and option.data == data) then
            return option, index
        end
    end
end

function PANEL:DoClick()
    if (self.active) then
        return
    end

    self:ResetHighlight()

    local x, y = self:LocalToScreen(0, 0)

    local dmenu = vgui.Create('onyx.Menu')
    dmenu:SetPos(x, y + self:GetTall())
    dmenu:SetMinimumWidth(self:GetWide())
    dmenu.parent = self
    dmenu.Think = function(panel)
        local parent = panel.parent
        if (IsValid(parent)) then
            local x, y = parent:LocalToScreen(0, 0)
            local targetY = y + parent:GetTall()
            if (dmenu:GetY() ~= targetY) then
                dmenu:Close()
            end
            -- dmenu:SetPos(x, targetY)
        end
    end

    for index, option in ipairs(self.options) do
        local opt = dmenu:AddOption(option.text, function()
            self:ChooseOptionID(index)
        end)

        if (option.iconURL) then
            opt:SetIconURL(option.iconURL, option.iconParams)
        end
    end

    dmenu:Open()

    self.dmenu = dmenu
end

function PANEL:SetActive(bBool)
    self.active = bBool
    onyx.anim.Simple(self, .2, {
        currentOutlineColor = (bBool and self.m_colOutlineActiveColor or self.m_colOutlineIdleColor)
    }, 1)
end

function PANEL:Think()
    local bRealActive = IsValid(self.dmenu)
    if (bRealActive ~= self.active) then
        self:SetActive(bRealActive)
    end
end

function PANEL:OnRemove()
    if (IsValid(self.dmenu)) then
        self.dmenu:Remove()
    end
end

function PANEL:OnDisabled()
    local offset = -5
    self.onyxAnims = nil
    self:SetColorIdle(onyx.OffsetColor(colorPrimary, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:OnEnabled()
    local offset = 0
    self.onyxAnims = nil
    self:SetColorIdle(onyx.OffsetColor(colorPrimary, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:Highlight(color, time)
    self.highlightColor = color
    self.highlightStartTime = CurTime()
    if (time) then
        self.highlightEndTime = CurTime() + time
    end
    self.highlight = true
end

function PANEL:ResetHighlight()
    self.highlightColor = nil
    self.highlightStartTime = nil
    self.highlightEndTime = nil
    self.highlight = nil
end

onyx.gui.Register('onyx.ComboBox', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     local content = self:Add('Panel')
--     content:Dock(FILL)
--     content:DockMargin(5, 5, 5, 5)

--     for i = 1, 10 do
--         local btn = content:Add('onyx.ComboBox')
--         btn:Dock(TOP)
--         btn:DockMargin(0, 0 ,0 ,5)
--         -- btn:AddOption('Apple')
--         -- btn:AddOption('Banana')
--         -- btn:AddOption('Pear')
--         btn:AddOptionAdvanced({
--             text = 'Apple',
--             iconURL = 'https://i.imgur.com/pkL906D.png',
--             iconParams = 'smooth mips'
--         })
--         btn:AddOptionAdvanced({
--             text = 'Pear',
--             iconURL = 'https://i.imgur.com/Y4UKPLO.png',
--             iconParams = 'smooth mips'
--         })
--         btn:AddOptionAdvanced({
--             text = 'Banana',
--             iconURL = 'https://i.imgur.com/qQl0sr8.png',
--             iconParams = 'smooth mips'
--         })
--         btn:Highlight(Color(212, 72, 72))
--         -- btn:SetHideOptionIcon(true   )
--         -- btn.OnSelect = function(panel, index, text, data)
--         --     panel:Clear()
--         --     panel.current = 1
--         --     panel:SetDisabled(true)
--         --     panel:SetCurrentOptionText('Thank you for your feedback.')
--         -- end
--     end

-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_frame.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_scrollpanel_canvas.lua:
--[[

Author: tochonement
Email: tochonement@gmail.com

22.08.2021

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_iSpace', 'Space')

function PANEL:Init()
    self.container = self:Add('Panel')

    self:SetSpace(ScreenScale(2))
end

function PANEL:PerformLayout(w, h)
    self:UpdateSize()
end

function PANEL:GetPanels()
    return self.container:GetChildren()
end

function PANEL:CalculateTall()
    local panels = self:GetPanels()
    local count = #panels
    local size = 0

    for index, child in ipairs(panels) do
        if child:IsVisible() then
            local _, top, _, bottom = child:GetDockMargin()

            size = size + child:GetTall()
            size = size + top
            size = size + (index ~= count and bottom or 0)
        end
    end

    return size
end

function PANEL:UpdateSize()
    local w, h = self:GetWide(), self:CalculateTall()

    self.container:SetSize(w, h)

    self:Call('OnContainerTallUpdated', nil, self:GetTall(), h)
end

function PANEL:AddPanel(panel)
    panel:SetParent(self.container)
    panel:Dock(TOP)
    panel:DockMargin(0, 0, 0, self:GetSpace())

    local class = panel.ClassName or 'Panel'
    if (not class:find('onyx')) then
        onyx.gui.Extend(panel)
    end

    panel:InjectEventHandler('PerformLayout')
    panel:On('PerformLayout', function()
        self:UpdateSize()
    end)

    panel:Call('OnPanelAdded', nil, panel)
end

function PANEL:OnPanelAdded()
end

onyx.gui.Register('onyx.ScrollPanel.Canvas', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .66, .66, function(self)
--     self:MakePopup()

--     local list = self:Add('onyx.ScrollPanel')
--     list:Dock(FILL)

--     for i = 1, 1024 do
--         local button = list:Add('onyx.Button')
--         button:SetText('Button #' .. i)
--         button:SetTall(32)
--     end
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_settings.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

08/03/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorNegative = onyx:Config('colors.negative')

local font0 = onyx.Font('Comfortaa Bold@16')
local font3 = onyx.Font('Comfortaa@14')

local wimgSave = onyx.wimg.Simple('https://i.imgur.com/ycSNF3m.png', 'smooth mips')

function PANEL:Init()
    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)

    self.categories = {}
    self.options = {}

    self.confirmPopup = self:Add('DPanel')
    self.confirmPopup:SetWide(onyx.ScaleWide(225))
    self.confirmPopup:SetTall(onyx.ScaleTall(75))
    self.confirmPopup:Hide()
    self.confirmPopup.Paint = function(panel, w, h)
        local x, y = panel:LocalToScreen(0, 0)

        if (panel.anim == 0 or panel.anim == 1) then
            onyx.bshadows.BeginShadow()
                draw.RoundedBox(8, x, y, w, h, colorSecondary)
            onyx.bshadows.EndShadow(1, 2, 2)
        else
            draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
        end
    end
    self.confirmPopup.PerformLayout = function(panel, w, h)
        local padding = ScreenScale(2)

        panel:DockPadding(padding, padding, padding, padding)

        panel.info:Dock(FILL)
        panel.info:DockMargin(0, 0, 0, onyx.ScaleTall(5))
        panel.button:Dock(BOTTOM)
        panel.button:SetTall(onyx.ScaleTall(20))
    end

    self.confirmPopup.info = self.confirmPopup:Add('Panel')
    self.confirmPopup.info.text1 = onyx.lang:GetWFallback('unsavedSettings', 'UNSAVED SETTINGS')
    self.confirmPopup.info.text2 = onyx.lang:GetWFallback('confirmSave', 'Confirm to save the changes')
    self.confirmPopup.info.Paint = function(panel, w ,h)
        local size = math.ceil(h * .5)

        wimgSave:Draw(h * .5 - size * .5, h * .5 - size * .5, size, size, colorNegative)

        draw.SimpleText(panel.text1, font0, h, h * .5, colorNegative, 0, 4)
        draw.SimpleText(panel.text2, font3, h, h * .5, color_white, 0, 0)
    end

    self.confirmPopup.button = self.confirmPopup:Add('onyx.Button')
    self.confirmPopup.button:SetText(onyx.lang:GetWFallback('save_u', 'SAVE'))
    self.confirmPopup.button:SetFont(font0)
    self.confirmPopup.button:SetColorIdle(colorNegative)
    self.confirmPopup.button:SetColorHover(onyx.OffsetColor(colorNegative, -20))
    self.confirmPopup.button.DoClick = function()
        local changes = self:GetChanges()
        if (changes) then
            local amount = table.Count(changes)
            if (amount > 0) then

                -- better than sending multiple packets bc a lot of large-scale servers have anti net spam and etc.
                net.Start('onyx.inconfig:SetTable')
                    net.WriteUInt(amount, 6)
                    for id, value in pairs(changes) do
                        net.WriteString(id)
                        net.WriteString(onyx.TypeToString(value))
                    end
                net.SendToServer()
            end
        end
    end
end

local translate do
    local enums = {}
    enums[onyx.inconfig.Error.INVALID_VALUE] = 'The value must be valid!'
    enums[onyx.inconfig.Error.NUMBER_EXPECTED] = 'The must enter a valid number!'
    enums[onyx.inconfig.Error.STRING_EXPECTED] = 'The text entry cannot be empty!'
    enums[onyx.inconfig.Error.MIN_CHARS] = 'The text must contain more than %i characters!'
    enums[onyx.inconfig.Error.MAX_CHARS] = 'The text must contain less than %i characters!'
    enums[onyx.inconfig.Error.MIN_NUMBER] = 'The number must be higher than %i!'
    enums[onyx.inconfig.Error.MAX_NUMBER] = 'The number must be lower than %i!'
    enums[onyx.inconfig.Error.INVALID_MODEL] = 'The model path must be valid!'

    function translate(enumError, argument)
        local text = enums[enumError] or 'invalid'
        return Format(text, argument)
    end
end

function PANEL:GetChanges(doNotify)
    local changes = {}

    for _, option in ipairs(self.options) do
        local id = option.id
        local newValue = option.getNewValue()
        local curValue = onyx.inconfig:Get(id)
        local valid, err, arg1 = onyx.inconfig:CheckValue(id, newValue)
        local field = option.field
        if (valid) then
            if (field._oldDesc) then
                field.lblDesc:SetText(field._oldDesc)
                field.lblDesc:SetTextColor(color_white)

                if (field.textEntry) then
                    field.textEntry:ResetHighlight()
                end

                field._oldDesc = nil
            end

            if (newValue ~= curValue) then
                changes[id] = newValue
            end
        else
            local entry = field.textEntry
            local textError = isstring(err) and err or translate(err, arg1)

            field._oldDesc = field._oldDesc or field.lblDesc:GetText()
            field.lblDesc:SetTextColor(colorNegative)
            field.lblDesc:SetText(textError)

            if (IsValid(entry)) then
                entry:Highlight(colorNegative)
            end

            if (doNotify) then
                notification.AddLegacy(textError, 1, 5)
            end
        end
    end

    return changes
end

function PANEL:Think()
    if ((self.nextThink or 0) <= CurTime()) then
        local changes = self:GetChanges()
        local anim = table.IsEmpty(changes) and 1 or 0
        local confirmPopup = self.confirmPopup

        if ((confirmPopup.targetAnim or -1) ~= anim) then
            confirmPopup.anim = confirmPopup.anim or anim -- skip first anim

            if (anim < 1) then
                confirmPopup:SetVisible(true)
            end

            onyx.anim.Create(confirmPopup, .2, {
                index = 2,
                easing = 'inOutQuad',
                target = {
                    anim = anim
                },
                think = function(anim, panel)
                    panel:AlignBottom(panel.anim * -panel:GetTall())
                end,
                onFinished = function(anim, panel)
                    panel:SetVisible(panel.anim < 1)
                end
            })

            confirmPopup.targetAnim = anim
        end

        self.nextThink = CurTime() + .25
    end
end

function PANEL:PerformLayout(w, h)
end

function PANEL:LoadAddonSettings(addonID)
    for _, id in ipairs(onyx.inconfig.index) do
        local option = onyx.inconfig.options[id]
        if (option and option.addon and option.addon == addonID) then
            self:AddOption(table.Copy(option))
        end
    end
end

function PANEL:OpenCategories()
    for name, cat in pairs(self.categories) do
        cat:SetExpanded(true)
        cat:UpdateInTick(1)
        cat:UpdateInTick(10)
    end
end

function PANEL:AddOption(option)
    local category = option.category or 'Other'

    table.insert(self.options, option)

    local categoryPanel = self.categories[category]
    if (not categoryPanel) then
        local translatedName = onyx.utf8.upper( onyx.lang:Get( category ) )

        categoryPanel = self.list:Add('onyx.Category')
        categoryPanel:Dock(TOP)
        categoryPanel:SetTitle(translatedName)
        categoryPanel:SetSpace(0)
        categoryPanel:SetInset(onyx.ScaleTall(5))
        categoryPanel:SetTextMargin(onyx.ScaleTall(10))
        categoryPanel:DockMargin(0, 0, 0, onyx.ScaleTall(10))

        categoryPanel.grid = categoryPanel:Add('onyx.Grid')
        categoryPanel.grid:Dock(TOP)
        categoryPanel.grid:SetColumnCount(2)
        categoryPanel.grid:SetSpace(onyx.ScaleTall(5))

        categoryPanel.canvas.Paint = function(p, w, h)
            draw.RoundedBox(8, 0, 0, w, h, colorPrimary)
        end

        self.categories[category] = categoryPanel
    end

    local padding = onyx.ScaleTall(7.5)
    local value = onyx.inconfig:Get(option.id)
    local desc = onyx.lang:Get(option.desc)
    local sType = option.type

    if (sType == 'int' and (option.min or option.max) and not option.combo) then
        desc = desc .. ' (' .. (option.min or '') .. ' - ' .. (option.max or '') .. ')'
    end

    local field = categoryPanel.grid:Add('DPanel')
    field:SetTall(onyx.ScaleTall(45))
    field:DockPadding(padding, padding, padding, padding)
    field.Paint = function(p, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end

    option.field = field

    local lblName = field:Add('onyx.Label')
    lblName:Font('Comfortaa Bold@16')
    lblName:SetText(onyx.lang:Get(option.title))
    lblName:Color(colorAccent)
    lblName:SetContentAlignment(1)
    lblName:Dock(FILL)

    local lblDesc = field:Add('onyx.Label')
    lblDesc:Font('Comfortaa@14')
    lblDesc:SetText(desc)
    lblDesc:SetContentAlignment(7)
    lblDesc:SetTall((field:GetTall() - padding * 2) * .5)
    lblDesc:Dock(BOTTOM)
    field.lblDesc = lblDesc

    local container = field:Add('Panel')
    container:Dock(RIGHT)
    container:SetWide(onyx.ScaleWide(150))
    container:SetZPos(-1)

    if (option.combo) then
        local combo = container:Add('onyx.ComboBox')
        combo:Dock(FILL)

        for i, opt in ipairs(option.combo) do
            combo:AddOption(onyx.lang:Get(opt[1]), opt[2])

            if (opt[2] == value) then
                combo:ChooseOptionID(i)
            end
        end

        container:SetWide(onyx.ScaleWide(200))

        option.getNewValue = function()
            return combo:GetOptionData( combo:GetSelectedID() )
        end

        field.combo = textEntry

        return
    end

    if (sType == 'string' or sType == 'int' or sType == 'model') then
        local textEntry = container:Add('onyx.TextEntry')
        textEntry:Dock(FILL)
        textEntry:SetValue(value)

        if (sType == 'int') then
            container:SetWide(onyx.ScaleWide(75))
        else
            container:SetWide(onyx.ScaleWide(200))
        end

        option.getNewValue = function()
            if (sType == 'int') then
                return tonumber(textEntry:GetValue())
            else
                return textEntry:GetValue()
            end
        end

        field.textEntry = textEntry
    elseif (sType == 'bool') then
        local check = container:Add('onyx.CheckBox')
        check:SetValue(value)

        option.getNewValue = function()
            return check:GetChecked()
        end

        container:SetWide(onyx.ScaleWide(75))

        container.PerformLayout = function(panel, w, h)
            local child = panel:GetChild(0)
            if (IsValid(child)) then
                child:AlignRight(0)
                child:CenterVertical()
            end
        end
    end
end

onyx.gui.Register('onyx.Configuration', PANEL)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_english.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_english.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

local LANG = {}

-- TABS
LANG.f4_jobs_u = 'JOBS'
LANG.f4_jobs_desc = 'Choose your path'

LANG.f4_dashboard_u = 'DASHBOARD'
LANG.f4_dashboard_desc = 'General information'

LANG.f4_shop_u = 'SHOP'
LANG.f4_shop_desc = 'Purchase any goods'

LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Configure the addon'

LANG.f4_donate_u = 'DONATE'
LANG.f4_donate_desc = 'Support the server'

LANG.addon_settings_u = 'SETTINGS'
LANG.addon_settings_desc = 'Configure the addon'

LANG.addon_stats_u = 'STATS'
LANG.addon_stats_desc = 'Check the addon stats'

LANG.addon_return_u = 'RETURN'
LANG.addon_return_desc = 'Return to the frame'

-- Other
LANG.f4_salary = 'Salary'
LANG.f4_price = 'Price'
LANG.f4_loading = 'Loading'
LANG.f4_purchases = 'Purchases'
LANG.f4_switches = 'Switches'
LANG.f4_unavailable = 'Unavailable'
LANG.f4_description_u = 'DESCRIPTION'
LANG.f4_weapons_u = 'WEAPONS'
LANG.f4_entities_u = 'ENTITIES'
LANG.f4_ammo_u = 'AMMO'
LANG.f4_food_u = 'FOOD'
LANG.f4_shipments_u = 'SHIPMENTS'
LANG.f4_become_u = 'BECOME'
LANG.f4_create_vote_u = 'CREATE VOTE'
LANG.f4_general_u = 'GENERAL'
LANG.f4_police_u = 'POLICE'
LANG.f4_mayor_u = 'MAYOR'
LANG.f4_confirm_u = 'CONFIRM'
LANG.f4_cancel_u = 'CANCEL'
LANG.f4_mostpopular_u = 'MOST POPULAR'
LANG.f4_chart_u = 'CHART'
LANG.f4_loading_u = 'LOADING'
LANG.f4_empty_u = 'EMPTY'
LANG.f4_favorite_u = 'FAVORITE'

LANG.f4_playersonline_u = 'PLAYERS ONLINE'
LANG.f4_totalmoney_u = 'TOTAL MONEY'
LANG.f4_staffonline_u = 'STAFF ONLINE'
LANG.f4_actions_u = 'ACTIONS'

LANG.f4_show_favorite = 'Show Favorites'

LANG.requires_level = 'Requires Level {level}'

-- Actions
LANG['f4_action_input_amount'] = 'Input the amount'
LANG['f4_action_input_text'] = 'Input the text'
LANG['f4_action_input_reason'] = 'Input the reason'
LANG['f4_action_choose_player'] = 'Choose a player'

LANG['f4_action_confirm_action'] = 'Confirm the action'
LANG['f4_action_drop_money'] = 'Drop Money'
LANG['f4_action_give_money'] = 'Give Money'
LANG['f4_action_change_name'] = 'Change Name'
LANG['f4_action_drop_weapon'] = 'Drop Weapon'
LANG['f4_action_sell_doors'] = 'Sell All Doors'

LANG['f4_action_warrant'] = 'Make Warrant'
LANG['f4_action_wanted'] = 'Make Wanted'

LANG['f4_toggle_lockdown'] = 'Toggle Lockdown'
LANG['f4_give_license'] = 'Give License'

-- Phrases
LANG['f4_search_text'] = 'Search by name...'

-- Settings
LANG['f4.option_url_desc'] = 'Input the URL (leave empty to disable)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Join our Discord server'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Meet the community'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Join our Steam group'

LANG['f4.rules_url.name'] = 'Rules'
LANG['f4.rules_url.desc'] = 'Know the rules'

LANG['f4.donate_url.name'] = 'Donate'

LANG['f4.website_ingame.name'] = 'Browser'
LANG['f4.website_ingame.desc'] = 'Use in-game browser to open website URL'

LANG['f4.title.name'] = 'Title'
LANG['f4.title.desc'] = 'The title for the frame'

LANG['f4.hide_donate_tab.name'] = 'Hide Donate Tab'
LANG['f4.hide_donate_tab.desc'] = 'Hide the creditstore integration tab'

LANG['f4.edit_job_colors.name'] = 'Modify Job Colors'
LANG['f4.edit_job_colors.desc'] = 'Should job colors be displayed lighter'

LANG['f4.hide_admins.name'] = 'Hide Admins Section'
LANG['f4.hide_admins.desc'] = 'Hide the dashboard admin list section'

LANG['f4.admin_on_duty.name'] = 'Admin Job Enabled'
LANG['f4.admin_on_duty.desc'] = 'Display as an admin only a person with a certain job'

LANG['f4.admin_on_duty_job.name'] = 'Admin Job Name'
LANG['f4.admin_on_duty_job.desc'] = 'The admin\'s job name*'

LANG['f4.colored_items.name'] = 'Colorized Gradient'
LANG['f4.colored_items.desc'] = 'Enable slight gradient on items/jobs'

LANG['f4.item_columns.name'] = 'Columns'
LANG['f4.item_columns.desc'] = 'The amount of columns for Items'

LANG['f4.job_columns.name'] = 'Columns'
LANG['f4.job_columns.desc'] = 'The amount of columns for Jobs'

LANG['f4.model_3d.name'] = '3D Models'
LANG['f4.model_3d.desc'] = 'Enable realtime rendering for Item/Job icons'

LANG['f4.item_show_unavailable.name'] = 'Unavailable Items'
LANG['f4.item_show_unavailable.desc'] = 'Show items that failed customCheck'

LANG['f4.job_show_unavailable.name'] = 'Unavailable Jobs'
LANG['f4.job_show_unavailable.desc'] = 'Show jobs that failed customCheck'

LANG['f4.job_show_requirejob.name'] = 'Dependent Jobs'
LANG['f4.job_show_requirejob.desc'] = 'Show jobs that cannot be chosen due player\'s wrong job'

onyx.lang:AddPhrases('english', LANG)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_polish.lua:
--[[
Kayzed @ 2024
--]]

local LANG = {}

-- TABS
LANG.f4_jobs_u = 'PRACE'
LANG.f4_jobs_desc = 'Wybierz swj zawd'

LANG.f4_dashboard_u = 'PULPIT'
LANG.f4_dashboard_desc = 'Oglne informacje'

LANG.f4_shop_u = 'SKLEP'
LANG.f4_shop_desc = 'Zakup dowolne dobra'

LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Skonfiguruj dodatek'

LANG.f4_donate_u = 'DONACJA'
LANG.f4_donate_desc = 'Wspieraj serwer'

LANG.addon_settings_u = 'USTAWIENIA'
LANG.addon_settings_desc = 'Skonfiguruj dodatek'

LANG.addon_stats_u = 'STATYSTYKI'
LANG.addon_stats_desc = 'Sprawd statystyki dodatku'

LANG.addon_return_u = 'POWRT'
LANG.addon_return_desc = 'Wr do poprzedniej zakadki'

-- Other
LANG.f4_salary = 'Pensja'
LANG.f4_price = 'Cena'
LANG.f4_loading = 'adowanie'
LANG.f4_purchases = 'Zakupy'
LANG.f4_switches = 'Przeczniki'
LANG.f4_unavailable = 'Niedostpne'
LANG.f4_description_u = 'OPIS'
LANG.f4_weapons_u = 'BRO'
LANG.f4_entities_u = 'BYTY'
LANG.f4_ammo_u = 'AMUNICJA'
LANG.f4_food_u = 'JEDZENIE'
LANG.f4_shipments_u = 'PACZKI'
LANG.f4_become_u = 'ZOSTA'
LANG.f4_create_vote_u = 'UTWRZ GOSOWANIE'
LANG.f4_general_u = 'OGLNE'
LANG.f4_police_u = 'POLICJA'
LANG.f4_mayor_u = 'BURMISTRZ'
LANG.f4_confirm_u = 'POTWIERD'
LANG.f4_cancel_u = 'ANULUJ'
LANG.f4_mostpopular_u = 'NAJPOPULARNIEJSZE'
LANG.f4_chart_u = 'WYKRES'
LANG.f4_loading_u = 'ADOWANIE'
LANG.f4_empty_u = 'PUSTE'
LANG.f4_favorite_u = 'ULUBIONE'

LANG.f4_playersonline_u = 'GRACZE ONLINE'
LANG.f4_totalmoney_u = 'CAKOWITA KASA'
LANG.f4_staffonline_u = 'ADMINISTRACJA ONLINE'
LANG.f4_actions_u = 'AKCJE'

LANG.f4_show_favorite = 'Poka Ulubione'

LANG.requires_level = 'Wymaga Poziomu {level}'

-- Actions
LANG['f4_action_input_amount'] = 'Wprowad ilo'
LANG['f4_action_input_text'] = 'Wprowad tekst'
LANG['f4_action_input_reason'] = 'Podaj powd'
LANG['f4_action_choose_player'] = 'Wybierz gracza'

LANG['f4_action_confirm_action'] = 'Potwierd akcj'
LANG['f4_action_drop_money'] = 'Upu Pienidze'
LANG['f4_action_give_money'] = 'Daj Pienidze'
LANG['f4_action_change_name'] = 'Zmie Imi'
LANG['f4_action_drop_weapon'] = 'Upu Bro'
LANG['f4_action_sell_doors'] = 'Sprzedaj Wszystkie Drzwi'

LANG['f4_action_warrant'] = 'Wystaw Nakaz'
LANG['f4_action_wanted'] = 'Oznacz jako Poszukiwany'

LANG['f4_toggle_lockdown'] = 'Przecz Blokad'
LANG['f4_give_license'] = 'Daj Licencj'

-- Phrases
LANG['f4_search_text'] = 'Szukaj po imieniu...'

-- Settings
LANG['f4.option_url_desc'] = 'Podaj URL (pozostaw puste, aby wyczy)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Docz do naszego serwera Discord'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Poznaj nasz spoeczno'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Docz do naszej grupy Steam'

LANG['f4.rules_url.name'] = 'Zasady'
LANG['f4.rules_url.desc'] = 'Poznaj zasady'

LANG['f4.donate_url.name'] = 'Donacja'

LANG['f4.website_ingame.name'] = 'Przegldarka'
LANG['f4.website_ingame.desc'] = 'Uyj przegldarki w grze, aby otworzy URL strony'

LANG['f4.title.name'] = 'Tytu'
LANG['f4.title.desc'] = 'Tytu dla ramki'

LANG['f4.hide_donate_tab.name'] = 'Ukryj zakadk Donacja'
LANG['f4.hide_donate_tab.desc'] = 'Ukryj zakadk integracji sklepu kredytowego'

LANG['f4.edit_job_colors.name'] = 'Modyfikuj Kolory Prac'
LANG['f4.edit_job_colors.desc'] = 'Czy kolory prac maj by janiejsze'

LANG['f4.hide_admins.name'] = 'Ukryj Sekcj Administratorw'
LANG['f4.hide_admins.desc'] = 'Ukryj sekcj listy adminw na pulpicie'

LANG['f4.admin_on_duty.name'] = 'Wczona Praca Administratora'
LANG['f4.admin_on_duty.desc'] = 'Wywietlaj jako administrator tylko osoby z okrelon prac'

LANG['f4.admin_on_duty_job.name'] = 'Nazwa Pracy Administratora'
LANG['f4.admin_on_duty_job.desc'] = 'Nazwa pracy administratora*'

LANG['f4.colored_items.name'] = 'Kolorowy Gradient'
LANG['f4.colored_items.desc'] = 'Wcz delikatny gradient dla przedmiotw/prac'

LANG['f4.item_columns.name'] = 'Kolumny'
LANG['f4.item_columns.desc'] = 'Liczba kolumn dla Przedmiotw'

LANG['f4.job_columns.name'] = 'Kolumny'
LANG['f4.job_columns.desc'] = 'Liczba kolumn dla Prac'

LANG['f4.model_3d.name'] = 'Modele 3D'
LANG['f4.model_3d.desc'] = 'Wcz renderowanie w czasie rzeczywistym dla ikon Przedmiotw/Prac'

LANG['f4.item_show_unavailable.name'] = 'Niedostpne Przedmioty'
LANG['f4.item_show_unavailable.desc'] = 'Poka przedmioty, ktre nie przeszy customCheck'

LANG['f4.job_show_unavailable.name'] = 'Niedostpne Prace'
LANG['f4.job_show_unavailable.desc'] = 'Poka prace, ktre nie przeszy customCheck'

LANG['f4.job_show_requirejob.name'] = 'Zalene Prace'
LANG['f4.job_show_requirejob.desc'] = 'Poka prace, ktrych nie mona wybra z powodu niewaciwej pracy gracza'

onyx.lang:AddPhrases('polish', LANG)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_russian.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_russian.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/01/2024

--]]

local LANG = {}

-- TABS
LANG.f4_jobs_u = ''
LANG.f4_jobs_desc = '  '

LANG.f4_dashboard_u = ''
LANG.f4_dashboard_desc = ' '

LANG.f4_shop_u = ''
LANG.f4_shop_desc = ' -'

LANG.f4_admin_u = ''
LANG.f4_admin_desc = ' '

LANG.f4_donate_u = ''
LANG.f4_donate_desc = ' '

LANG.addon_settings_u = ''

LANG.addon_stats_u = ''

LANG.addon_return_u = ''

-- Other
LANG.f4_salary = ''
LANG.f4_price = ''
LANG.f4_loading = ''
LANG.f4_purchases = ''
LANG.f4_switches = ''
LANG.f4_unavailable = ''
LANG.f4_description_u = ''
LANG.f4_weapons_u = ''
LANG.f4_entities_u = ''
LANG.f4_ammo_u = ''
LANG.f4_food_u = ''
LANG.f4_shipments_u = ''
LANG.f4_become_u = ''
LANG.f4_create_vote_u = ''
LANG.f4_general_u = ''
LANG.f4_police_u = ''
LANG.f4_mayor_u = ' '
LANG.f4_confirm_u = ''
LANG.f4_cancel_u = ''
LANG.f4_mostpopular_u = ' '
LANG.f4_chart_u = ''
LANG.f4_loading_u = ''
LANG.f4_empty_u = ''

LANG.f4_playersonline_u = ' '
LANG.f4_totalmoney_u = ' '
LANG.f4_staffonline_u = ' '
LANG.f4_actions_u = ''

LANG.f4_show_favorite = ' '

LANG.requires_level = ' {level} '

-- Actions
LANG['f4_action_input_amount'] = ' '
LANG['f4_action_input_text'] = ' '
LANG['f4_action_input_reason'] = ' '
LANG['f4_action_choose_player'] = ' '

LANG['f4_action_confirm_action'] = ' '
LANG['f4_action_drop_money'] = ' '
LANG['f4_action_give_money'] = ' '
LANG['f4_action_change_name'] = ' '
LANG['f4_action_drop_weapon'] = ' '
LANG['f4_action_sell_doors'] = '  '

LANG['f4_action_warrant'] = ' '
LANG['f4_action_wanted'] = '  '

LANG['f4_toggle_lockdown'] = '/ . '
LANG['f4_give_license'] = ' '

-- Phrases
LANG['f4_search_text'] = '  ...'

-- Settings
LANG['f4.option_url_desc'] = ' URL (  )'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = '  Discord '

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = ' '

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = '  '

LANG['f4.rules_url.name'] = ''
LANG['f4.rules_url.desc'] = '  '

LANG['f4.donate_url.name'] = ''

LANG['f4.website_ingame.name'] = ''
LANG['f4.website_ingame.desc'] = '   '

LANG['f4.title.name'] = ''
LANG['f4.title.desc'] = '  F4'

LANG['f4.hide_donate_tab.name'] = '  '
LANG['f4.hide_donate_tab.desc'] = '   Onyx Store'

LANG['f4.edit_job_colors.name'] = ' '
LANG['f4.edit_job_colors.desc'] = '   '

LANG['f4.hide_admins.name'] = ' '
LANG['f4.hide_admins.desc'] = '    '

LANG['f4.admin_on_duty.name'] = '-'
LANG['f4.admin_on_duty.desc'] = '       '

LANG['f4.admin_on_duty_job.name'] = ' -'
LANG['f4.admin_on_duty_job.desc'] = '   '

LANG['f4.colored_items.name'] = ' '
LANG['f4.colored_items.desc'] = '    '

LANG['f4.item_columns.name'] = ''
LANG['f4.item_columns.desc'] = '   '

LANG['f4.job_columns.name'] = ''
LANG['f4.job_columns.desc'] = '   '

LANG['f4.model_3d.name'] = '3D '
LANG['f4.model_3d.desc'] = ' 3D     '

LANG['f4.item_show_unavailable.name'] = ' '
LANG['f4.item_show_unavailable.desc'] = '   customCheck'

LANG['f4.job_show_unavailable.name'] = ' '
LANG['f4.job_show_unavailable.desc'] = '   customCheck'

LANG['f4.job_show_requirejob.name'] = ' '
LANG['f4.job_show_requirejob.desc'] = '    '

onyx.lang:AddPhrases('russian', LANG)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_spanish.lua:
--[[
 
Author: Goran
GmodStore Profile: https://www.gmodstore.com/users/Goran
 
05/01/2024
 
--]]
 
local LANG = {}
 
-- TABS
LANG.f4_jobs_u = 'TRABAJOS'
LANG.f4_jobs_desc = 'Elige tu camino'
 
LANG.f4_dashboard_u = 'TABLERO'
LANG.f4_dashboard_desc = 'Informacin general'
 
LANG.f4_shop_u = 'TIENDA'
LANG.f4_shop_desc = 'Compra bienes'
 
LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Configuracin del addon'
 
LANG.f4_donate_u = 'DONAR'
LANG.f4_donate_desc = 'Colabora con el servidor'
 
LANG.addon_settings_u = 'AJUSTES'
LANG.addon_settings_desc = 'Configuracin del addon'
 
LANG.addon_stats_u = 'ESTADSTICAS'
LANG.addon_stats_desc = 'Revisa las estadsticas del addon'
 
LANG.addon_return_u = 'REGRESAR'
LANG.addon_return_desc = 'Regresar'
 
-- Other
LANG.f4_salary = 'Salario'
LANG.f4_price = 'Precio'
LANG.f4_loading = 'Cargando'
LANG.f4_purchases = 'Compras'
LANG.f4_switches = 'Interruptores'
LANG.f4_unavailable = 'No disponible'
LANG.f4_description_u = 'DESCRIPCIN'
LANG.f4_weapons_u = 'ARMAS'
LANG.f4_entities_u = 'ENTIDADES'
LANG.f4_ammo_u = 'MUNICIN'
LANG.f4_food_u = 'COMIDA'
LANG.f4_shipments_u = 'CARGAMENTOS'
LANG.f4_become_u = 'TOMAR'
LANG.f4_create_vote_u = 'CREAR VOTACIN'
LANG.f4_general_u = 'GENERAL'
LANG.f4_police_u = 'POLICA'
LANG.f4_mayor_u = 'ALCALDE'
LANG.f4_confirm_u = 'CONFIRMAR'
LANG.f4_cancel_u = 'CANCELAR'
LANG.f4_mostpopular_u = 'EL MS POPULAR'
LANG.f4_chart_u = 'TABLA'
LANG.f4_loading_u = 'CARGANDO'
LANG.f4_empty_u = 'VACO'
 
LANG.f4_playersonline_u = 'JUGADORES EN LNEA'
LANG.f4_totalmoney_u = 'DINERO TOTAL'
LANG.f4_staffonline_u = 'STAFF EN LNEA'
LANG.f4_actions_u = 'ACCIONES'
 
-- Actions
LANG['f4_action_input_amount'] = 'Ingresa la cantidad'
LANG['f4_action_input_text'] = 'Ingresa el texto'
LANG['f4_action_input_reason'] = 'Ingresa la razn'
LANG['f4_action_choose_player'] = 'Elige a un jugador'
 
LANG['f4_action_confirm_action'] = 'Confirma la accin'
LANG['f4_action_drop_money'] = 'Soltar Dinero'
LANG['f4_action_give_money'] = 'Dar Dinero'
LANG['f4_action_change_name'] = 'Cambiar Nombre'
LANG['f4_action_drop_weapon'] = 'Soltar Arma'
LANG['f4_action_sell_doors'] = 'Vender Todas Las Puertas'
 
LANG['f4_action_warrant'] = 'Establecer Orden De Allanamiento'
LANG['f4_action_wanted'] = 'Establecer Orden De Bsqueda'
 
LANG['f4_toggle_lockdown'] = 'Alternar toque de queda'
LANG['f4_give_license'] = 'Dar Licencia'
 
-- Phrases
LANG['f4_search_text'] = 'Busca por nombre...'
 
-- Settings
LANG['f4.option_url_desc'] = 'Ingresa la URL (deja vaco para desactivar)'
 
LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'nete a nuestro servidor de Discord'
 
LANG['f4.forum_url.name'] = 'Foro'
LANG['f4.forum_url.desc'] = 'Conoce a la comunidad'
 
LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'nete a nuestro grupo de Steam'
 
LANG['f4.rules_url.name'] = 'Reglas'
LANG['f4.rules_url.desc'] = 'Conoce las reglas'
 
LANG['f4.donate_url.name'] = 'Donar'
 
LANG['f4.website_ingame.name'] = 'Buscador'
LANG['f4.website_ingame.desc'] = 'Utilizar el buscador del juego para abrir la URL del sitio'
 
LANG['f4.title.name'] = 'Ttulo'
LANG['f4.title.desc'] = 'El ttulo del men '
 
LANG['f4.hide_donate_tab.name'] = 'Ocultar ventana de Donaciones'
LANG['f4.hide_donate_tab.desc'] = 'Ocultar ventana de la integracin de Creditstore'
 
LANG['f4.edit_job_colors.name'] = 'Modificar color de los trabajos'
LANG['f4.edit_job_colors.desc'] = 'Deberan los colores de los trabajos mostrarse ms claros'
 
LANG['f4.hide_admins.name'] = 'Ocultar seccin de administracin'
LANG['f4.hide_admins.desc'] = 'Ocultar la seccin de administracin'
 
LANG['f4.admin_on_duty.name'] = 'Trabajo de Administrador habilitado'
LANG['f4.admin_on_duty.desc'] = 'Mostrar slo a las personas con un trabajo en especfico como admins.'
 
LANG['f4.admin_on_duty_job.name'] = 'Nombre del Trabajo de Administrador'
LANG['f4.admin_on_duty_job.desc'] = 'El nombre del Trabajo de Administrador*'
 
LANG['f4.colored_items.name'] = 'Degradado coloreado'
LANG['f4.colored_items.desc'] = 'Habilitar un ligero degradado en elementos/trabajos'
 
LANG['f4.item_columns.name'] = 'Columnas'
LANG['f4.item_columns.desc'] = 'La cantidad de columnas de objetos'
 
LANG['f4.job_columns.name'] = 'Columnas'
LANG['f4.job_columns.desc'] = 'La cantidad de columnas de trabajos'
 
LANG['f4.model_3d.name'] = 'Modelos 3D'
LANG['f4.model_3d.desc'] = 'Habilitar renderizacin en tiempo real de los conos de Objetos/Trabajos'
 
LANG['f4.item_show_unavailable.name'] = 'Objetos No Disponibles'
LANG['f4.item_show_unavailable.desc'] = 'Mostrar objetos que no pasan el customCheck'
 
LANG['f4.job_show_unavailable.name'] = 'Trabajos No Disponibles'
LANG['f4.job_show_unavailable.desc'] = 'Mostrar trabajos que no pasan el customCheck'
 
LANG['f4.job_show_requirejob.name'] = 'Trabajos Dependientes'
LANG['f4.job_show_requirejob.desc'] = 'Mostrar trabajos que no pueden ser tomados cuando el jugador no tiene el trabajo adecuado'
 
onyx.lang:AddPhrases('spanish', LANG)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/cl_core.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

onyx.f4.tabs = onyx.f4.tabs or {}
onyx.f4.actions = onyx.f4.actions or {}
onyx.f4.ranks = onyx.f4.ranks or {}

onyx.wimg.Register('favorite_fill', 'https://i.imgur.com/wviPFMQ.png')
onyx.wimg.Register('favorite_outline', 'https://i.imgur.com/FCXcBsu.png')

function onyx.f4:RegisterTab(id, data)
    onyx.AssertType(id, 'string', 'RegisterTab', 1)
    onyx.AssertType(data, 'table', 'RegisterTab', 2)

    data.id = id
    data.order = data.order or 99
    self.tabs[id] = data
end

function onyx.f4:DefineRank(id, data)
    onyx.AssertType(id, 'string', 'DefineRank', 1)
    onyx.AssertType(data, 'table', 'DefineRank', 2)
    assert(isstring(data.name), 'missing <name> field in data for `DefineRank`')

    data.id = id
    self.ranks[id] = data
end

function onyx.f4:RegisterAction(data)
    onyx.AssertType(data, 'table', 'RegisterAction', 1)

    table.insert(self.actions, data)
end

function onyx.f4.IsAdmin(ply)
    local jobOnly = onyx.f4:GetOptionValue('admin_on_duty')
    local jobName = onyx.f4:GetOptionValue('admin_on_duty_job')
    if (jobOnly) then
        local userGroup = ply:GetUserGroup()
        local jobTable = RPExtraTeams[ply:Team()]
        if (jobTable and userGroup ~= 'user' and jobTable.name == jobName) then
            return true
        else
            return false
        end
    else
        return (ply:IsAdmin() or onyx.f4.ranks[ply:GetUserGroup()])
    end
end

function onyx.f4:GetSortedTabs()
    local sorted = {}

    for id, tab in pairs(onyx.f4.tabs) do
        table.insert(sorted, tab)
    end

    table.sort(sorted, function(a, b)
        return a.order < b.order
    end)

    return sorted
end

function onyx.f4.ConvertJobColor(color)
    local bEnabled = onyx.f4:GetOptionValue('edit_job_colors')
    if (bEnabled) then
        local h, s, v = ColorToHSV(color)
        return onyx.ColorEditHSV(color, nil, s - .2, v + .2)
    else
        return color
    end
end

function onyx.f4.OpenFrame()
    local frame = vgui.Create('onyx.f4.Frame')
    frame:SetSize(ScrW() * .65, ScrH() * .65)
    frame:Center()
    frame:MakePopup()

    return frame
end

function onyx.f4.OpenAdminSettings()
    local frame = vgui.Create('onyx.Frame')
    frame:SetSize(ScrW() * .66, ScrH() * .66)
    frame:Center()
    frame:MakePopup()
    frame:SetTitle('ONYX F4 (ADMIN)')

    local p = onyx.ScaleTall(15)
    local content = frame:Add('Panel')
    content:Dock(FILL)
    content:DockPadding(p, p, p, p)

    local sidebar = frame:Add('onyx.Sidebar')
    sidebar:SetContainer(content)
    sidebar:SetWide(frame:GetWide() * .2)
    sidebar:Dock(LEFT)

    sidebar:AddTab({
        name = onyx.lang:Get('addon_settings_u'),
        desc = onyx.lang:Get('addon_settings_desc'),
        icon = 'https://i.imgur.com/ECLKU9s.png',
        class = 'onyx.Configuration',
        onSelected = function(panel)
            panel:LoadAddonSettings('f4')
            panel:OpenCategories()
        end
    })

    sidebar:AddTab({
        name = onyx.lang:Get('addon_stats_u'),
        desc = onyx.lang:Get('addon_stats_desc'),
        icon = 'https://i.imgur.com/L6jCQe0.png',
        class = 'onyx.f4.AdminStats'
    })

    sidebar:AddTab({
        name = onyx.lang:Get('addon_return_u'),
        desc = onyx.lang:Get('addon_return_desc'),
        icon = 'https://i.imgur.com/gCI6kX5.png',
        onClick = function()
            onyx.f4.OpenFrame()
            frame:Remove()
            return false
        end
    })

    sidebar:ChooseTab(1)

    return frame
end

hook.Add('ShowSpare2', 'onyx.f4', function(ply)
    if (not IsValid(onyx.f4.frame)) then
        onyx.f4.OpenFrame()
    end
    return true
end)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_tab_dashboard.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorGradient = onyx.OffsetColor(colorAccent, -50)
local colorTertiary = onyx:Config('colors.tertiary')
local colorCircleGray = Color(69, 69, 69)
local colorGray = Color(200, 200, 200)
local colorLabel = color_white
local fontTitle = onyx.Font('Comfortaa Bold@16')

local L = function(...) return onyx.lang:Get(...) end

local PANEL = {}

local formatMoney do
    local format = {
        {'t', 10 ^ 12, 2},
        {'b', 10 ^ 9, 2},
        {'m', 10 ^ 6, 2},
        {'k', 10 ^ 3}
    }
    local amount = #format

    function formatMoney(money)
        for index = 1, amount do
            local data = format[index]
            local name = data[1]
            local value = data[2]
            local decimals = data[3] or 1
            if (money > value) then
                return DarkRP.formatMoney( math.Round(money / value, decimals) ) .. name
            end
        end

        return DarkRP.formatMoney(money)
    end
end

local function drawShadowBG(panel, w, h, color)
    -- local x, y = panel:LocalToScreen(0, 0)

    -- onyx.bshadows.BeginShadow()
        draw.RoundedBox(8, 0, 0, w, h, color)
    -- onyx.bshadows.EndShadow(1, 1, 2, nil, nil, 2)
end

function PANEL:Init()
    self.space = onyx.ScaleTall(10)
    self.padding = onyx.ScaleTall(10)
    self.smallHeaderHeight = onyx.ScaleTall(25)

    self.divStats = self:Add('Panel')
    self.divStats.PerformLayout = function(panel, w, h)
        local children = panel:GetChildren()
        local amount = #children
        local space = self.space
        local wide = (w - (space * (amount - 1))) / amount

        for index, child in ipairs(children) do
            child:SetWide(wide)
            child:Dock(LEFT)
            child:DockMargin(0, 0, space, 0)
        end
    end

    self.divBody = self:Add('Panel')

    self.divActions = self.divBody:Add('Panel')
    self.divActions.Paint = function(panel, w, h)
        drawShadowBG(panel, w, h, colorPrimary)
    end

    self.lblActions = self.divActions:Add('onyx.Label')
    self.lblActions:SetText(L('f4_actions_u'))
    self.lblActions:SetFont(fontTitle)
    self.lblActions:SetTextColor(colorLabel)
    self.lblActions:Dock(TOP)
    self.lblActions:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.lblActions:CenterText()
    self.lblActions:SetTall(self.smallHeaderHeight)
    self.lblActions.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    self.listActions = self.divActions:Add('onyx.ScrollPanel')
    self.listActions:DockMargin(self.padding, 0, self.padding, self.padding)
    self.listActions:Dock(FILL)

    self.divAdmins = self.divBody:Add('Panel')
    self.divAdmins:SetVisible(not onyx.f4:GetOptionValue('hide_admins'))
    self.divAdmins.Paint = function(panel, w, h)
        drawShadowBG(panel, w, h, colorPrimary)
    end

    self.lblAdmins = self.divAdmins:Add('onyx.Label')
    self.lblAdmins:SetText(L('f4_staffonline_u'))
    self.lblAdmins:SetFont(fontTitle)
    self.lblAdmins:SetTextColor(colorLabel)
    self.lblAdmins:Dock(TOP)
    self.lblAdmins:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.lblAdmins:CenterText()
    self.lblAdmins:SetTall(self.smallHeaderHeight)
    self.lblAdmins.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    self.listAdmins = self.divAdmins:Add('onyx.ScrollPanel')
    self.listAdmins:DockMargin(self.padding, 0, self.padding, self.padding)
    self.listAdmins:Dock(FILL)

    self:InitActions()
    self:InitStats()
    self:InitAdmins()
end

function PANEL:PerformLayout(w, h)
    local space = self.space

    self.divStats:SetTall(h * .25)
    self.divStats:Dock(TOP)
    self.divStats:DockMargin(0, 0, 0, space)

    self.divBody:Dock(FILL)

    self.divActions:Dock(FILL)

    self.divAdmins:Dock(RIGHT)
    self.divAdmins:SetWide((w - space * 1) * .33)
    self.divAdmins:DockMargin(space, 0, 0, 0)
end

function PANEL:InitActions()
    local client = LocalPlayer()
    local listActions = self.listActions
    local categories = {}

    for _, action in ipairs(onyx.f4.actions) do
        local category = action.category
        local canSee = action.canSee

        if (canSee and not canSee(client)) then
            continue
        end

        if (not categories[category]) then
            local lblTitle = listActions:Add('onyx.Label')
            lblTitle:SetText(onyx.lang:Get(category))
            lblTitle:SetTextColor(color_white)
            lblTitle:Font('Overpass SemiBold@16')
            lblTitle:Dock(TOP)
            lblTitle:DockMargin(0, 0, 0, onyx.ScaleTall(10))

            local gridPanel = listActions:Add('onyx.Grid')
            gridPanel:Dock(TOP)
            gridPanel:SetColumnCount(3)
            gridPanel:SetSpaceX(onyx.ScaleTall(5))
            gridPanel:SetSpaceY(gridPanel:GetSpaceX())
            gridPanel:DockMargin(0, 0, 0, onyx.ScaleTall(10))

            categories[category] = gridPanel
        end

        self:AddAction(categories[category], action.name, action.func)
    end
end

function PANEL:AddAction(grid, name, func)
    local client = LocalPlayer()
    local button = grid:Add('onyx.Button')
    button:SetText(onyx.lang:Get(name))
    button:SetGradientColor(colorGradient)
    button:SetMasking(true)
    button:Font('Comfortaa Bold@16')
    button:SetTall(onyx.ScaleTall(25))
    button.DoClick = function()
        if (func) then
            func(client)
        end
    end
end

function PANEL:InitAdmins()
    local padding = onyx.ScaleTall(5)
    local client = LocalPlayer()
    for _, ply in ipairs(player.GetAll()) do
        if (onyx.f4.IsAdmin(ply)) then
            local customrank, customcolor = CustomRank(ply)
            if customrank then
                continue
            end
            local panel = self.listAdmins:Add('Panel')
            panel:Dock(TOP)
            panel:SetTall(onyx.ScaleTall(45))
            panel:DockPadding(padding, padding, padding, padding)
            panel.Paint = function(panel, w, h)
                draw.RoundedBox(8, 0, 0, w, h, colorTertiary)
            end

            local height = panel:GetTall() - padding * 2

            local avatar = panel:Add('onyx.RoundedAvatar')
            avatar:SetPlayer(ply, 64)
            avatar:SetWide(height)
            avatar:Dock(LEFT)
            avatar:DockMargin(0, 0, onyx.ScaleWide(10), 0)
            avatar.PaintOver = function(panel, w, h)
                onyx.DrawOutlinedCircle(w * .5, h * .5, h * .5, 3, color_white)
            end

            local fontName = onyx.Font('Comfortaa SemiBold@16')
            local fontRank = onyx.Font('Comfortaa@14')
            local rankID = ply:GetUserGroup()
            local scRankData = onyx.scoreboard and onyx.scoreboard:GetRankData(rankID) -- from scoreboard
            local defRankData = onyx.f4.ranks[rankID] -- from F4
            local rankName = rankID
            local plyName = ply:Name()
            local plyColor = defRankData and defRankData.color or color_white
    
            if ( scRankData ) then
                rankName = scRankData.name
            elseif ( defRankData ) then
                rankName = defRankData.name
            end
            
            local content = panel:Add('onyx.Panel')
            content:Dock(FILL)
            content.Paint = function(panel, w, h)
                if (scRankData) then
                    local color = istable(scRankData) and scRankData.color or color_white
                    local effectIndex = istable(scRankData) and scRankData.effect or 1
                    local effectData = onyx.scoreboard.nameEffects[effectIndex] or onyx.scoreboard.nameEffects[1]
                    local effectDrawFn = effectData.func
                    local realX, realY = panel:LocalToScreen( 0, 0 )
                    local x, y = 0, h * .5
            
                    -- common
                    effectDrawFn(plyName, x, y, color, 0, 4, realX + x, realY + y)
                else
                    draw.SimpleText(plyName, fontName, 0, h * .5, plyColor, 0, 4)
                end

                draw.SimpleText(rankName, fontRank, 0, h * .5, colorGray, 0, 0)
            end
        end
    end
end

function PANEL:InitStats()
    local client = LocalPlayer()
    local players = player.GetAll()
    local playerOnline = #players
    local playerMax = game.MaxPlayers()
    local clientMoney = client:getDarkRPVar('money') or 0
    local totalMoney = 0
    local staffOnline = 0

    for _, ply in ipairs(players) do
        local money = ply:getDarkRPVar('money') or 0
        totalMoney = totalMoney + money

        if (onyx.f4.IsAdmin(ply)) then
            staffOnline = staffOnline + 1
        end
    end

    self:AddStat(L('f4_playersonline_u'), playerOnline .. ' / ' .. playerMax, (playerOnline / playerMax), Color(255, 238, 108))
    self:AddStat(L('f4_totalmoney_u'), formatMoney(totalMoney), (clientMoney / totalMoney), Color(36, 129, 50), Color(179, 255, 170))
    self:AddStat(L('f4_staffonline_u'), staffOnline, (staffOnline > 0 and 1 or 0), Color(160, 61, 231))
end

function PANEL:AddStat(name, info, fraction, color, color2)
    local padding = onyx.ScaleTall(10)
    local angle = math.Round(fraction * 360, 0, 360)
    local font0 = onyx.Font('Comfortaa@18')

    local panel = self.divStats:Add('Panel')
    panel.Paint = function(this, w, h)
        drawShadowBG(this, w, h, colorPrimary)
    end

    local lblTitle = panel:Add('onyx.Label')
    lblTitle:SetText(name)
    lblTitle:SetFont(fontTitle)
    lblTitle:CenterText()
    lblTitle:SetTextColor(colorLabel)
    lblTitle:Dock(TOP)
    lblTitle:DockMargin(0, 0, 0, padding)
    lblTitle:SizeToContentsY(10)
    lblTitle.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    local content = panel:Add('Panel')
    content:Dock(FILL)
    content:DockMargin(padding, 0, padding, padding)
    content.Paint = function(panel, w, h)
        local size = math.min(w, h)
        local radius = math.floor(size * .5)
        local x0 = w * .5
        local y0 = h * .5
        local outlineWidth   = 5

        DisableClipping(true)
            onyx.DrawOutlinedCircle(x0 + 1, y0 + 1, radius, outlineWidth, Color(0, 0, 0, 100))
        DisableClipping(false)

        onyx.DrawOutlinedCircle(x0, y0, radius, outlineWidth, color2 or colorCircleGray)
        onyx.DrawWithPolyMask(panel.mask, function()
            onyx.DrawOutlinedCircle(x0, y0, radius, outlineWidth, color)
        end)

        draw.SimpleText(info, font0, w * .5, h * .5, color_white, 1, 1)
    end
    content.PerformLayout = function(panel, w, h)
        panel.mask = onyx.CalculateArc(w * .5, h * .5, 0, angle, h * .5 + 2, 24, true)
    end
end

onyx.gui.Register('onyx.f4.Dashboard', PANEL)

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.f4.Frame', .6, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(1)
-- end)
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_spanish.lua:
--[[

Editor: Benjaa635 | Rusherr
GmodStore Profile: https://www.gmodstore.com/users/Rusherr635

13/10/2024

--]]

local LANG = {}

--[[
    .............
    Palabras generales
]]--

LANG[ 'hud_status_wanted' ] = 'Buscado'
LANG[ 'hud_status_speaking' ] = 'Hablando'
LANG[ 'hud_status_typing' ] = 'Escribiendo'
LANG[ 'props' ] = 'Objetos'
LANG[ 'close' ] = 'Cerrar'
LANG[ 'alert' ] = 'Alerta'
LANG[ 'message' ] = 'Mensaje'
LANG[ 'unknown' ] = 'Desconocido'
LANG[ 'accept' ] = 'Aceptar'
LANG[ 'deny' ] = 'Denegar'
LANG[ 'none' ] = 'Ninguno'
LANG[ 'add' ] = 'Aadir'
LANG[ 'remove' ] = 'Eliminar'
LANG[ 'jobs' ] = 'Trabajos'
LANG[ 'door' ] = 'Puerta'
LANG[ 'vehicle' ] = 'Vehculo'
LANG[ 'door_groups' ] = 'Grupos de puertas'
LANG[ 'display' ] = 'Pantalla'
LANG[ 'general' ] = 'General'
LANG[ 'speedometer' ] = 'Velocmetro'
LANG[ 'fuel' ] = 'Combustible'
LANG[ 'vote' ] = 'Votar'
LANG[ 'question' ] = 'Pregunta'


--[[
    .......
    Timeout
]]--

LANG[ 'timeout_title' ] = 'CONEXIN PERDIDA'
LANG[ 'timeout_info' ] = 'El servidor no est disponible en este momento, lo sentimos'
LANG[ 'timeout_status' ] = 'Sers reconectado en %d segundos'


--[[
    ......
    Themes
]]--

LANG[ 'hud.theme.default.name' ] = 'Predeterminado'
LANG[ 'hud.theme.forest.name' ] = 'Bosque'
LANG[ 'hud.theme.violet_night.name' ] = 'Noche Violeta'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Brasa Rstica'
LANG[ 'hud.theme.green_apple.name' ] = 'Manzana Verde'
LANG[ 'hud.theme.lavender.name' ] = 'Lavanda'
LANG[ 'hud.theme.elegance.name' ] = 'Elegancia'
LANG[ 'hud.theme.mint_light.name' ] = 'Menta'
LANG[ 'hud.theme.gray.name' ] = 'Gris'
LANG[ 'hud.theme.rose_garden.name' ] = 'Jardn de Rosas'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Olas del Ocano'
LANG[ 'hud.theme.sky_blue.name' ] = 'Cielo Azul'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Amanecer Dorado'

--[[
    ....
    Help
    - Frase completa: "Escribe <commando> para abrir la configuracion"
]]

LANG[ 'hud_help_type' ] = 'Escribe'
LANG[ 'hud_help_to' ] = 'para abrir la configuracion'


--[[
    .............
    Puertas 3D2D
]]--

LANG[ 'door_purchase' ] = 'Comprar {object}'
LANG[ 'door_sell' ] = 'Vender {object}'
LANG[ 'door_addowner' ] = 'Agregar propietario'
LANG[ 'door_rmowner' ] = 'Eliminar propietario'
LANG[ 'door_rmowner_help' ] = 'Elige al jugador al que deseas revocar la propiedad'
LANG[ 'door_addowner_help' ] = 'Elige al jugador al que deseas otorgar la propiedad'
LANG[ 'door_title' ] = 'Establecer ttulo'
LANG[ 'door_title_help' ] = 'Qu ttulo deseas establecer?'
LANG[ 'door_admin_disallow' ] = 'Prohibir propiedad'
LANG[ 'door_admin_allow' ] = 'Permitir propiedad'
LANG[ 'door_admin_edit' ] = 'Editar acceso'
LANG[ 'door_owned' ] = 'Propiedad Privada'
LANG[ 'door_unowned' ] = 'En Venta'

LANG[ 'hud_door_help' ] = 'Presiona {bind} para comprar por {price}'
LANG[ 'hud_door_owner' ] = 'Propietario: {name}'
LANG[ 'hud_door_allowed' ] = 'Permitido poseer'
LANG[ 'hud_door_coowners' ] = 'Copropietarios'
LANG[ 'hud_and_more' ] = 'y ms...'


--[[
    .........
    Uppercase
]]--

LANG[ 'reconnect_u' ] = 'RECONEXIN'
LANG[ 'disconnect_u' ] = 'DESCONECTAR'
LANG[ 'settings_u' ] = 'AJUSTES'
LANG[ 'configuration_u' ] = 'CONFIGURACIN'
LANG[ 'introduction_u' ] = 'INTRODUCCIN'


--[[
    .........
    Lowercase
]]--

LANG[ 'seconds_l' ] = 'segundos'
LANG[ 'minutes_l' ] = 'minutos'

--[[
    .............
    Configuration
]]--

LANG[ 'hud.timeout.name' ] = 'Duracin del Tiempo de Espera'
LANG[ 'hud.timeout.desc' ] = 'Cuntos segundos antes de la reconexin automtica'

LANG[ 'hud.alert_queue.name' ] = 'Cola de Alertas'
LANG[ 'hud.alert_queue.desc' ] = 'Deben colocarse las alertas en cola?'

LANG[ 'hud.props_counter.name' ] = 'Contador de Objetos'
LANG[ 'hud.props_counter.desc' ] = 'Mostrar contador de objetos'

LANG[ 'hud.main_avatar_mode.name' ] = 'Tipo de Avatar Principal'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Elige el tipo'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Tipo de Avatar de Voz'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Elige el tipo'

LANG[ 'hud.restrict_themes.name' ] = 'Restringir Temas'
LANG[ 'hud.restrict_themes.desc' ] = 'Restringir a los jugadores la eleccin de temas'

LANG[ 'hud.speedometer_mph.name' ] = 'Usar Millas'
LANG[ 'hud.speedometer_mph.desc' ] = 'Cambiar unidades a millas por hora'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Velocidad Mxima Predeterminada'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'La velocidad mxima para el velocmetro'

LANG[ 'hud_should_draw' ] = 'Debe dibujar el elemento'
LANG[ 'hud.main.name' ] = 'HUD Principal'
LANG[ 'hud.ammo.name' ] = 'Municin'
LANG[ 'hud.agenda.name' ] = 'Agenda'
LANG[ 'hud.alerts.name' ] = 'Alertas'
LANG[ 'hud.pickup_history.name' ] = 'Historial de Recoleccin'
LANG[ 'hud.level.name' ] = 'Nivel'
LANG[ 'hud.voice.name' ] = 'Paneles de Voz'
LANG[ 'hud.overhead_health.name' ] = 'Salud Superior 3D2D'
LANG[ 'hud.overhead_armor.name' ] = 'Armadura Superior 3D2D'
LANG[ 'hud.vehicle.name' ] = 'HUD de Vehculo'


--[[
    ........
    Ajustes
]]--

LANG[ 'hud.theme.name' ] = 'Tema'
LANG[ 'hud.theme.desc' ] = 'Elige el tema del HUD'

LANG[ 'hud.scale.name' ] = 'Escala'
LANG[ 'hud.scale.desc' ] = 'Ajusta la escala del HUD'

LANG[ 'hud.roundness.name' ] = 'Redondez'
LANG[ 'hud.roundness.desc' ] = 'Ajusta la redondez del HUD'

LANG[ 'hud.margin.name' ] = 'Margen'
LANG[ 'hud.margin.desc' ] = 'La distancia entre el HUD y los bordes'

LANG[ 'hud.icons_3d.name' ] = 'Modelos 3D'
LANG[ 'hud.icons_3d.desc' ] = 'Renderizar conos de modelo en 3D'

LANG[ 'hud.compact.name' ] = 'Modo Compacto'
LANG[ 'hud.compact.desc' ] = 'Habilitar el modo compacto'

LANG[ 'hud.speedometer_blur.name' ] = 'Desenfoque del Velocmetro'
LANG[ 'hud.speedometer_blur.desc' ] = 'Habilitar el desenfoque para el velocmetro'

LANG[ 'hud.3d2d_max_details.name' ] = 'Mximo de Detalles 3D2D'
LANG[ 'hud.3d2d_max_details.desc' ] = 'La cantidad mxima de informacin detallada que se renderiza'

--[[
    ......
    Status
]]--

LANG[ 'hud_lockdown' ] = 'TOQUE DE QUEDA'
LANG[ 'hud_lockdown_help' ] = 'Por favor, regresen a sus hogares!'

LANG[ 'hud_wanted' ] = 'BUSCADO'
LANG[ 'hud_wanted_help' ] = 'Razn: {reason}'

LANG[ 'hud_arrested' ] = 'ARRESTADO'
LANG[ 'hud_arrested_help' ] = 'Sers liberado en {time}'


onyx.lang:AddPhrases( 'spanish', LANG )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_level_support.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_scaling.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

-- I made this to cache calculated values for UI scaling
-- It is working cheaper than using raw functions ;P

local CONVAR = CreateClientConVar( 'cl_onyx_hud_scale', '100', true, false, 'Scale', 50, 150 )

local currentContextID
local cache = {
    [ 1 ] = {}, -- ScaleWide
    [ 2 ] = {} -- ScaleTall
}

local scale do
    local Round = math.Round
    function scale( int, method, storageIndex )
        local scaleFunc = onyx[ method ]
        local scaleInt = onyx.hud.GetScale() -- from outside

        if ( currentContextID ) then
            local cacheTable = cache[ storageIndex ]
            local cached = cacheTable[ int ]

            if ( cached ) then
                return cached
            else
                local result = Round( scaleFunc( int ) * scaleInt )
    
                cache[ storageIndex ][ int ] = result
    
                return result
            end
        else
            return Round( scaleFunc( int ) * scaleInt )
        end
    end
end

function onyx.hud.GetScale()
    return ( CONVAR:GetInt() / 100 )
end

function onyx.hud.StartScaling( contextID )
    currentContextID = contextID
end

function onyx.hud.EndScaling()
    if ( currentContextID ) then
        currentContextID = nil
    end
end

function onyx.hud.ScaleWide( int )
    return scale( int, 'ScaleWide', 1 )
end

function onyx.hud.ScaleTall( int )
    return scale( int, 'ScaleTall', 2 )
end

function onyx.hud.ResetScaleCache()
    local client = LocalPlayer()

    for index = 1, 2 do
        cache[ index ] = {}
    end

    for id, element in pairs( onyx.hud.elements ) do
        if ( element.onSizeChanged ) then
            element:onSizeChanged( client )
        end
    end
end

cvars.AddChangeCallback( 'cl_onyx_hud_scale', function( _, _, new )
    onyx.hud.ResetScaleCache()
    onyx.hud.BuildFonts()
end, 'onyx.hud.Update' )

hook.Add( 'OnScreenSizeChanged', 'onyx.hud.ResetScaleCache', function()
    onyx.hud.ResetScaleCache()
    onyx.hud.BuildFonts()
end )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_theme.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_ammo.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

local COLOR_OUTLINE = onyx:Config( 'colors.primary' )
local COLOR_LOW = Color( 255, 98, 98)

local WIMG_SPEC_AMMO = onyx.wimg.Simple( 'https://i.imgur.com/CHWwWOq.png', 'smooth mips' )

local BUILD_WEAPONS = {
    [ 'weapon_physgun' ] = true,
    [ 'gmod_tool' ] = true,
}

local lastWeapon = NULL
local lerpClip1

local function drawAmmoHUD( client, scrW, scrH, weapon )
    local primaryAmmoType = weapon:GetPrimaryAmmoType()
    if ( primaryAmmoType < 0 ) then return end

    if ( lastWeapon ~= weapon ) then
        lastWeapon = weapon
        lerpClip1 = nil
    end

    local primaryAmmoCount = client:GetAmmoCount( primaryAmmoType )
    local primaryClip = weapon:Clip1()

    local secondaryAmmoType = weapon:GetSecondaryAmmoType()
    local hasSecondaryAmmo = secondaryAmmoType > 0
    local secondaryClip = weapon:Clip2()
    local secondaryAmmoCount = client:GetAmmoCount( secondaryAmmoType )
    
    local hideAmmoCount = false

    -- For grenades and etc.
    if ( primaryClip == -1 ) then 
        primaryClip = primaryAmmoCount
        hideAmmoCount = true
    end

    local lowAmmoStartRange = math.Round( weapon:GetMaxClip1() / 3 )
    local lowAmmoFraction = lowAmmoStartRange > 0 and math.min( 1, primaryClip / lowAmmoStartRange ) or 1
    if ( primaryClip == 0 ) then lowAmmoFraction = 0 end

    lerpClip1 = Lerp( FrameTime() * 16, lerpClip1 or primaryClip, primaryClip )
    
    -- Grab text size
    local textClip = math.Round( lerpClip1 )
    local textRemaining = hideAmmoCount and '' or ( ' / ' .. primaryAmmoCount )
    
    surface.SetFont( onyx.hud.fonts.AmmoClip )
    local textW1, textH1 = surface.GetTextSize( textClip )

    surface.SetFont( onyx.hud.fonts.AmmoRemaining )
    local textW2, textH2 = surface.GetTextSize( textRemaining )
    local totalW = textW1 + textW2
    
    -- Calculate positions and sizes
    local space = onyx.hud.GetScreenPadding()
    local padding = onyx.hud.ScaleTall( 20 )
    local w = totalW + padding * 2
    local h = onyx.hud.ScaleTall( 50 )

    local x = scrW - w - space
    local y = scrH - h - space

    local colorTextPrimary = onyx.hud:GetColor( 'textPrimary' )
    local colorTextSecondary = onyx.hud:GetColor( 'textSecondary' )

    -- Draw secondary ammo
    if ( hasSecondaryAmmo ) then
        local iconSize = h * .35
        surface.SetFont( onyx.hud.fonts.AmmoRemaining )
        local secAmmoTextW, secAmmoTextH = surface.GetTextSize( secondaryAmmoCount )
        local secAmmoTextSpace = onyx.hud.ScaleTall( 2 )
        local secAmmoTotalW = secAmmoTextW + secAmmoTextSpace + iconSize

        local secAmmoBlockWidth = secAmmoTotalW + padding * 1
        x = x - secAmmoBlockWidth

        local secAmmoStartX = x + w + secAmmoBlockWidth * .5 - secAmmoTotalW * .5
        local secAmmoColor = secondaryAmmoCount == 0 and colorTextSecondary or colorTextPrimary

        onyx.hud.DrawRoundedBoxEx( x + w, y, secAmmoBlockWidth, h, onyx.hud:GetColor( 'secondary' ), false, true, false, true )

        WIMG_SPEC_AMMO:Draw( secAmmoStartX, y + h * .5 - iconSize * .5, iconSize, iconSize, colorTextSecondary )
        onyx.hud.DrawCheapText( secondaryAmmoCount, onyx.hud.fonts.AmmoRemaining, secAmmoStartX + secAmmoTextSpace + iconSize, y + h * .5 - secAmmoTextH * .5, secAmmoColor )
    end

    -- Draw primary ammo
    local x0, y0 = x + w * .5, y + h * .5
    local textStartX = x0 - totalW * .5
    local colorClip = onyx.LerpColor( lowAmmoFraction, COLOR_LOW, colorTextPrimary )

    onyx.hud.DrawRoundedBoxEx( x, y, w, h, onyx.hud:GetColor( 'primary' ), true, not hasSecondaryAmmo, true, not hasSecondaryAmmo )
    onyx.hud.DrawCheapText( textClip, onyx.hud.fonts.AmmoClip, textStartX, y0 - textH1 * .5, colorClip, 0, 1 )
    onyx.hud.DrawCheapText( textRemaining, onyx.hud.fonts.AmmoRemaining, textStartX + textW1, y0 - textH2 * .5, colorTextSecondary, 0, 1 )

    -- Draw weapon name
    local name = weapon:GetPrintName()
    draw.SimpleTextOutlined( name, onyx.hud.fonts.SmallBold, scrW - space, y - onyx.hud.ScaleTall( 5 ), color_white, 2, 4, 1, COLOR_OUTLINE )
end

local function drawPropsHUD( client, scrW, scrH )
    local curProps = client:GetCount( 'props' )
    local maxProps = onyx.hud.GetMaxProps( client)
    if ( maxProps < 1 ) then
        maxProps = ''
    end
    
    local clipText = curProps
    local maxText = ' / ' .. maxProps

    surface.SetFont( onyx.hud.fonts.AmmoRemaining )
    local clipTextW, clipTextH = surface.GetTextSize( clipText )
    local maxTextW, maxTextH = surface.GetTextSize( maxText )
    local totalTextW = clipTextW + maxTextW

    -- Positions
    local space = onyx.hud.GetScreenPadding()
    local horPadding = onyx.hud.ScaleTall( 20 )
    local verPadding = onyx.hud.ScaleTall( 5 )
    local w = totalTextW + horPadding * 2
    local h = onyx.hud.ScaleTall( 55 )

    local x = scrW - w - space
    local y = scrH - h - space

    local colorTextPrimary = onyx.hud:GetColor( 'textPrimary' )
    local colorTextSecondary = onyx.hud:GetColor( 'textSecondary' )

    -- Draw
    onyx.hud.DrawRoundedBox( x, y, w, h, onyx.hud:GetColor( 'primary' ) )
    draw.SimpleText( onyx.lang:Get( 'props' ), onyx.hud.fonts.Small, x + w * .5, y + verPadding, colorTextSecondary, 1, 0 )
    onyx.hud.DrawCheapText( clipText, onyx.hud.fonts.AmmoRemaining, x + horPadding, y + h - clipTextH - verPadding, colorTextPrimary )
    onyx.hud.DrawCheapText( maxText, onyx.hud.fonts.AmmoRemaining, x + horPadding + clipTextW, y + h - clipTextH - verPadding, colorTextSecondary )
end

onyx.hud:RegisterElement( 'ammo', {
    drawFn = function( self, client, scrW, scrH )
        local weapon = client:GetActiveWeapon()
        if ( not IsValid( weapon ) ) then return end
        if ( client:InVehicle() ) then return end

        local class = weapon:GetClass()
        if ( BUILD_WEAPONS[ class ] ) then
            if ( onyx.hud:GetOptionValue( 'props_counter' ) ) then
                drawPropsHUD( client, scrW, scrH )
            end
        else
            drawAmmoHUD( client, scrW, scrH, weapon )
        end
    end,
    hideElements = { 
        [ 'CHudAmmo' ] = true, 
        [ 'CHudSecondaryAmmo' ] = true 
    }
} )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_door_info.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/08/2024

--]]

local RANGE = 400
local FONT_NAME = onyx.hud.CreateFont3D2D( 'DoorName', 'Comfortaa SemiBold', 60 )
local FONT_SMALL_NAME = onyx.hud.CreateFont3D2D( 'DoorSmallName', 'Comfortaa SemiBold', 40 )
local FONT_HELP = onyx.hud.CreateFont3D2D( 'DoorHelp', 'Comfortaa', 32 )
local COLOR_GRAY = Color( 200, 200, 200 )
local COLOR_GREEN = Color( 147, 255, 108)
local COLOR_RED = Color( 255, 87, 87)
local L = function( ... ) return onyx.lang:Get( ... ) end

local nearest = {}
local traceOut = {}
local traceIn = { output = traceOut, mask = MASK_SHOT }

local bindKey = ''

-- To get a nice string containing players' name from DarkRP
local function getPlayersStr( players, maxNames )
    local maxNames = maxNames or 2
    local result = {}
    local added = 0
    local limitExceeded = false

    for playerIndex in pairs( players ) do
        local ply = Player( playerIndex )
        if ( IsValid( ply ) ) then
            added = added + 1
            if ( added > maxNames ) then
                limitExceeded = true
                break
            end

            result[ added ] = ply:Name()
        end
    end

    local finalStr = table.concat( result, ', ' )

    if ( limitExceeded ) then
        finalStr = finalStr .. ', ...'
    end

    return finalStr 
end

local function drawInfo( ent, client )
    local screenPos = ent:LocalToWorld( ent:OBBCenter() ) + Vector( 0, 0, 16 )
    
    -- I wish I could put this in a timer, but it would look bad when the door is moving
    traceIn.start = client:GetShootPos()
    traceIn.endpos = screenPos
    traceIn.filter = client
    util.TraceLine( traceIn )

    if ( traceOut.Entity ~= ent ) then return end

    local hitPos = traceOut.HitPos
    local hitNormal = traceOut.HitNormal
    local length = ( hitPos - screenPos ):Length2D()

    if ( length > 6 ) then return end

    local renderPos = hitPos + hitNormal
    local renderAng = hitNormal:Angle() + Angle( 0, 90, 90 )

    local doorTeams = ent:getKeysDoorTeams()
    local doorGroup = ent:getKeysDoorGroup()
    local doorCoowners = ent:getKeysCoOwners() or {}
    local doorPrice = GAMEMODE.Config.doorcost ~= 0 and GAMEMODE.Config.doorcost or 30
    local playerOwned = ent:isKeysOwned() or table.GetFirstValue( doorCoowners ) ~= nil
    local isOwned = playerOwned or doorGroup or doorTeams
    local allowedCoOwn = ent:getKeysAllowedToOwn()

    local title = ''
    local subtitle = ''
    local color = color_white
    local titleFont = FONT_NAME

    if ( isOwned ) then
        local doorOwner = ent:getDoorOwner()
        local ownedByClient = playerOwned and ( doorOwner == client or doorCoowners[ client:UserID() ] )
    
        title = ent:getKeysTitle()

        if ( not title ) then
            if ( playerOwned ) then
                title = L( 'door_owned' )
                color = ownedByClient and COLOR_GREEN or COLOR_RED
            else
                if ( doorGroup ) then
                    title = doorGroup
                    titleFont = FONT_SMALL_NAME
                else
                    title = L( 'door_owned' )
                end
    
                if ( doorTeams ) then
                    for teamIndex in pairs( doorTeams ) do
                        subtitle = subtitle .. team.GetName( teamIndex ) .. '\n'
                    end
                end
            end
        elseif ( not playerOwned ) then
            if ( doorGroup ) then
                subtitle = doorGroup
            elseif ( doorTeams ) then
                for teamIndex in pairs( doorTeams ) do
                    subtitle = subtitle .. team.GetName( teamIndex ) .. '\n'
                end
            end
        end

        if ( playerOwned ) then
            subtitle = L( 'hud_door_owner', { name = IsValid( doorOwner ) and doorOwner:Name() or '' } )

            if ( not table.IsEmpty( doorCoowners ) ) then
                subtitle = subtitle .. Format( '\n%s: %s', L( 'hud_door_coowners' ), getPlayersStr( doorCoowners ) )
            end

            if ( allowedCoOwn and not table.IsEmpty( allowedCoOwn ) ) then
                subtitle = subtitle .. Format( '\n%s: %s', L( 'hud_door_allowed' ), getPlayersStr( allowedCoOwn ) )
            end
        end
    else
        title = L( 'door_unowned' )
        subtitle = L( 'hud_door_help', { bind = bindKey, price = DarkRP.formatMoney( doorPrice ) } )
    end

    cam.Start3D2D( renderPos, renderAng, .085 )

        onyx.hud.DrawShadowText( title, titleFont, 0, 0, color, 1, 0 )
        draw.DrawText( subtitle, FONT_HELP .. '.Blur', 2, 60 + 2, color_black, 1 )
        draw.DrawText( subtitle, FONT_HELP, 0, 60, COLOR_GRAY, 1 )

    cam.End3D2D()
end

do
    local DOORS = {
        [ 'prop_door_rotating' ] = true,
        [ 'func_door_rotating' ] = true,
        [ 'func_door' ] = true,
    }
    timer.Create( 'onyx.hud.CatchNearestDoors', 1 / 5, 0, function()
        local client = LocalPlayer()
        if ( IsValid( client ) ) then
            local entities = ents.FindInCone( client:GetShootPos(), client:GetAimVector(), RANGE, math.cos( math.rad( 45 ) ) )
    
            nearest = {}
            bindKey = input.LookupBinding( 'gm_showteam' ) or ''
    
            for _, ent in ipairs( entities ) do
                if ( IsValid( ent ) and ent:isDoor() and not ent:getKeysNonOwnable() and DOORS[ ent:GetClass() ] and not ent:GetNoDraw() ) then
                    table.insert( nearest, ent )
                end
            end
        end
    end )
end

hook.Add( 'PostDrawTranslucentRenderables', 'onyx.hud.DrawDoors', function()
    local client = LocalPlayer()
    for _, ent in ipairs( nearest ) do
        if ( IsValid( ent ) ) then
            drawInfo( ent, client )
        end
    end
end )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_gesture_menu.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/08/2024

--]]

local animationsTable = {}
animationsTable[ ACT_GMOD_GESTURE_BOW ] = 'bow'
animationsTable[ ACT_GMOD_TAUNT_MUSCLE ] = 'sexy_dance'
animationsTable[ ACT_GMOD_GESTURE_BECON ] = 'follow_me'
animationsTable[ ACT_GMOD_TAUNT_LAUGH ] = 'laugh'
animationsTable[ ACT_GMOD_TAUNT_PERSISTENCE ] = 'lion_pose'
animationsTable[ ACT_GMOD_GESTURE_DISAGREE ] = 'nonverbal_no'
animationsTable[ ACT_GMOD_GESTURE_AGREE ] = 'thumbs_up'
animationsTable[ ACT_GMOD_GESTURE_WAVE ] = 'wave'
animationsTable[ ACT_GMOD_TAUNT_DANCE ] = 'dance'

local animationsFrame
local function openGestureMenu()
    if ( IsValid( animationsFrame ) ) then
        return
    end

    local size = onyx.hud.ScaleTall( 512 )

    local choiceWheel = vgui.Create( 'onyx.hud.ChoiceWheel' )
    animationsFrame = choiceWheel
    choiceWheel:SetSize( size, size )
    choiceWheel:SetShowLabel( false )
    choiceWheel:MakePopup()
    choiceWheel:Center()
    choiceWheel.OnRemove = function()
        animationsFrame = nil
    end

    choiceWheel:AddChoice( { name = onyx.lang:Get( 'close' ) } )
    
    for animID, animName in pairs( animationsTable ) do
        choiceWheel:AddChoice( {
            name = DarkRP.getPhrase( animName ),
            callback = function()
                RunConsoleCommand( '_DarkRP_DoAnimation', animID )                                                                                                                                                                                                                                                              -- 5409e8b9-5bf9-4f0d-8990-ecb0a7db9134
            end
        } )
    end
end

onyx.hud.OverrideGamemode( 'onyx.hud.OverrideGesturesMenu', function()
    concommand.Add( '_DarkRP_AnimationMenu', openGestureMenu )
end )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_overhead.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_timeout.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

19/08/2024

--]]

local hud = onyx.hud

local L = function( ... ) return onyx.lang:Get( ... ) end
local WIMG_ICON = onyx.wimg.Create( 'hud_connection_lost', 'smooth mips' )
local COLOR_GRAY = Color( 200, 200, 200 )

-- It is mandatory to run this command as soon as possible
RunConsoleCommand( 'cl_timeout', '300' )

local function startFadeAnimation( panel, target, callback )
    panel.animAlpha = panel:GetAlpha() / 255
    
    onyx.anim.Create( panel, 1, {
        index = 1,
        target = { animAlpha = target },
        easing = 'inOutSine',
        think = function( _, panel )
            panel:SetAlpha( panel.animAlpha * 255 )
        end,
        onFinished = function( _, panel )
            if ( callback ) then
                callback( panel )
            end
        end
    } )
end

local function createPanel()
    local scrW, scrH = ScrW(), ScrH()
    local x0, y0 = scrW * .5, scrH * .5
    local theme = hud:GetCurrentTheme()
    local colors = theme.colors
    local space = hud.ScaleTall( 30 )

    local btnWide, btnTall = hud.ScaleWide( 200 ), hud.ScaleTall( 30 )
    local btnY = scrH * .75 - btnTall * .5

    local textTitle = L( 'timeout_title' )
    local textInfo = L( 'timeout_info' )
    local textStatus = L( 'timeout_status' )
    local fontInfo = hud.fonts.Medium

    surface.SetFont( fontInfo )
    local textInfoW, textInfoH = surface.GetTextSize( textInfo )
    local textStatusW, textStatusH = surface.GetTextSize( textStatus )

    local frame = vgui.Create( 'Panel' )
    onyx.hud.TimeoutPanel = frame

    frame:SetSize( ScrW(), ScrH() )
    frame:SetDrawOnTop( true )
    frame:SetAlpha( 0 )
    frame.statusFraction = 0
    frame.reconnectTime = 0
    frame.Paint = function( panel, w, h )
        if ( panel.reconnectTime > 0 and panel.reconnectTime <= SysTime() ) then
            RunConsoleCommand( 'retry' )
        end
        
        local alpha = panel:GetAlpha() / 255
        local iconSize = hud.ScaleTall( 128 )
        
        if ( alpha > 0) then
            onyx.DrawBlurExpensive( panel, 6 * alpha )
        end

        surface.SetDrawColor( ColorAlpha( colors.primary, theme.isDark and 230 or 150 ) )
        surface.DrawRect( 0, 0, w, h )

        draw.SimpleText( textTitle, hud.fonts.BigBold, x0, y0, colors.textPrimary, 1, 4 )

        WIMG_ICON:DrawRotated( x0, h * .4, iconSize, iconSize, 0, colors.textPrimary )
    end
    frame.OnRemove = function()
        timer.Remove( 'onyx.hud.TimeoutShowDetails' )
    end
    frame.Close = function( panel )
        if ( not panel.closed ) then
            panel.closed = true
            startFadeAnimation( panel, 0, function( this )
                this:Remove()
            end )
        end
    end

    local lblDesc = frame:Add( 'Panel' )
    lblDesc:SetTall( math.max( textInfoH, textStatusH ) )
    lblDesc:SetWide( scrW )
    lblDesc:SetPos( 0, y0 )
    lblDesc.Paint = function( panel, w, h )
        local statusFraction = frame.statusFraction
        local infoFraction = 1 - statusFraction
        local timeLeft = math.Round( math.max( 0, frame.reconnectTime - SysTime() ) )
        local prevAlpha = surface.GetAlphaMultiplier()

        surface.SetAlphaMultiplier( math.min( infoFraction, prevAlpha ) )
            onyx.hud.DrawCheapText( textInfo, fontInfo, w * .5 - textInfoW * .5, h * statusFraction, colors.textSecondary )
        surface.SetAlphaMultiplier( math.min( statusFraction, prevAlpha ) )
            draw.SimpleText( textStatus:format( timeLeft ), fontInfo, w * .5, -h * infoFraction, colors.negative, 1, 0 )
        surface.SetAlphaMultiplier( prevAlpha )
    end

    local btnReconnect = frame:Add( 'onyx.Button' )
    btnReconnect:SetText( L( 'reconnect_u' ) )
    btnReconnect:SetFont( hud.fonts.Tiny )
    btnReconnect:SetTextColor( colors.textPrimary )
    btnReconnect:SetColorIdle( colors.secondary )
    btnReconnect:SetColorHover( colors.tertiary )
    btnReconnect:SetSize( btnWide, btnTall )
    btnReconnect:SetPos( x0 - btnWide - space / 2, btnY )
    btnReconnect:Hide()
    btnReconnect.DoClick = function() RunConsoleCommand( 'retry' ) end

    local btnDisconnect = frame:Add( 'onyx.Button' )
    btnDisconnect:SetText( L( 'disconnect_u' ) )
    btnDisconnect:SetFont( hud.fonts.Tiny )
    btnDisconnect:SetTextColor( colors.textPrimary )
    btnDisconnect:SetColorIdle( colors.secondary )
    btnDisconnect:SetColorHover( colors.tertiary )
    btnDisconnect:SetSize( btnWide, btnTall )
    btnDisconnect:SetPos( x0 + space / 2, btnY )
    btnDisconnect:Hide()
    btnDisconnect.DoClick = function() RunConsoleCommand( 'disconnect' ) end

    startFadeAnimation( frame, 1 )

    timer.Create( 'onyx.hud.TimeoutShowDetails', 3, 1, function()
        if ( IsValid( frame ) ) then
            frame.reconnectTime = SysTime() + hud:GetOptionValue( 'timeout' )
            frame:MakePopup()
        
            onyx.anim.Create( frame, 1, {
                index = 2,
                target = { statusFraction = 1 },
                easing = 'outQuad',
                think = function( _, panel )
                    if ( IsValid( btnDisconnect ) and IsValid( btnReconnect ) ) then
                        local alpha = panel.statusFraction * 255

                        btnReconnect:SetVisible( true )
                        btnReconnect:SetAlpha( alpha )

                        btnDisconnect:SetVisible( true )
                        btnDisconnect:SetAlpha( alpha )
                    end
                end
            } )
        end
    end )
end

timer.Create( 'onyx.hud.TimeoutController', 1, 0, function()
    local isTimingOut, lastPing = GetTimeoutInfo()
    local panel = onyx.hud.TimeoutPanel
    local isValid = IsValid( panel )

    if ( isTimingOut ) then
        if ( isValid ) then
        else
            createPanel()
        end
    elseif ( isValid ) then
        panel:Close()
    end
end )

concommand.Add( 'onyx_hud_test_timeout', function( ply, _, args )
    if ( ply:IsSuperAdmin() ) then
        local freezeDuration = tonumber( args[ 1 ] ) or 10
        local resetTime = SysTime() + freezeDuration
        local hookName = 'onyx.hud.TimeoutTest'

        ply:ConCommand( 'net_fakeloss 100' )

        hook.Add( 'DrawOverlay', hookName, function()
            if ( resetTime <= SysTime() ) then
                hook.Remove( 'DrawOverlay', hookName )
                ply:ConCommand( 'net_fakeloss 0' )
            end
        end )
    end
end )
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/sh_init.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/columns/sh_columns.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/03/2024

--]]

onyx.scoreboard.columns = onyx.scoreboard.columns or {}
onyx.scoreboard.columnsCustomizable = onyx.scoreboard.columnsCustomizable or {}
onyx.scoreboard.columnsMaxAmount = 5
onyx.scoreboard.columnsDefault = {
    [1] = 'team',
    [2] = 'rank',
    [3] = 'money',
    [4] = 'playtime',
}

function onyx.scoreboard:RegisterColumn(id, data)
    if (SERVER) then data = {} end -- server doesn't need that

    data.name = 'scoreboard_col_' .. id
    data.id = id

    onyx.scoreboard.columns[id] = data
end

do
    local BASE_COLUMNS = {

    }

    function onyx.scoreboard:GetActiveColumns()
        local columns = {}

        -- configurable options
        for index = 1, self.columnsMaxAmount do
            local cfgID = self.columnsCustomizable[index]
            if (cfgID) then
                local cfgData = self.columns[cfgID]
                if (cfgData and (not cfgData.customCheck or cfgData.customCheck())) then
                    table.insert(columns, cfgData)
                end
            else
                local defaultID = onyx.scoreboard.columnsDefault[index]
                if (defaultID) then
                    local defaultData = self.columns[defaultID]
                    if (defaultData and (not defaultData.customCheck or defaultData.customCheck())) then
                        table.insert(columns, defaultData)
                    end
                end
            end
        end

        -- default columns
        for _, column in ipairs(BASE_COLUMNS) do
            table.insert(columns, column)
        end

        return columns
    end
end
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_column_editor.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_columns_row.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_ACCENT = onyx:Config('colors.accent')
local SHADOW_ALPHA = 200
local COLOR_SHADOW = Color(0, 0, 0, 100)
local COLOR_GRAY = Color(149, 149, 149)
local COLOR_GRAY_LIGHT = Color(198, 198, 198)
local SHADOW_DISTANCE = 2

--[[------------------------------
PANEL
--------------------------------]]
local PANEL = {}

AccessorFunc(PANEL, 'm_Font', 'Font')
AccessorFunc(PANEL, 'm_bHeader', 'Header')

function PANEL:Init()
    self.m_Font = onyx.Font('Comfortaa@16')
    self.columns = {}
end

function PANEL:InitColumns()
    local activeColumns = onyx.scoreboard:GetActiveColumns()

    self.columnsAmount = #activeColumns
    self.realColumnsAmount = self.columnsAmount - 2

    for index, column in ipairs(activeColumns) do
        self.columns[index] = self:CreateColumn(column, index)
    end
end

function PANEL:CreateColumn(data, index)
    local column = self:Add('onyx.Label')
    if (data.id == 'team' and DarkRP) then
        column:SetText(onyx.lang:Get('scoreboard_col_job'))
    else
        column:SetText(onyx.lang:Get(data.name))
    end

    column:SetFont(self.m_Font)
    column:CenterText()
    column:SetExpensiveShadow(SHADOW_DISTANCE, COLOR_SHADOW)
    column.data = data

    if (not data.small and self.realColumnsAmount == 1) then
        column:SetContentAlignment(4)
        column.TextLeft = true
    end

    if (self:GetHeader()) then
        column:SetTextColor(COLOR_GRAY)

        if (data.icon) then
            local wimgIcon = onyx.wimg.Simple(data.icon, 'smooth mips')
            column:SetText('')
            column.Paint = function(panel, w, h)
                local size = math.min(h, onyx.ScaleTall(16))
                local space = onyx.ScaleTall(5)
                local font = panel:GetFont()
                local textColor = panel:GetTextColor()
                local text = data.small and '' or data.name
                local textNotEmpty = text ~= ''
                local y0 = h * .5
                local x0 = w * .5
                local textW, textH

                if (textNotEmpty) then
                    surface.SetFont(font)
                    textW, textH = surface.GetTextSize(text)

                    local totalW = textW + size + space
                    local x = x0 - totalW * .5

                    wimgIcon:Draw(x + SHADOW_DISTANCE, y0 - size * .5 + SHADOW_DISTANCE, size, size, COLOR_SHADOW)
                    wimgIcon:Draw(x, y0 - size * .5, size, size, textColor)
                    draw.SimpleText(text, font, x + size + space, y0, textColor, 0, 1)
                else
                    wimgIcon:Draw(x0 - size * .5 + SHADOW_DISTANCE, y0 - size * .5 + SHADOW_DISTANCE, size, size, COLOR_SHADOW)
                    wimgIcon:Draw(x0 - size * .5, y0 - size * .5, size, size, textColor)
                end
            end
        end
    else
        if (data.buildFunc) then
            column:SetText('')
            column.NoText = true
            column.Paint = nil
        end
    end

    return column
end

function PANEL:SetValue(index, formattedValue, rawValue)
    local column = self:GetColumn(index)
    if (not column.NoText) then
        column:SetText(formattedValue)
    end
    column.TextValue = formattedValue -- if GetText got overrided
    column.Value = rawValue or formattedValue
end

function PANEL:SetColor(index, value)
    self:GetColumn(index):SetTextColor(value)
end

function PANEL:SetClickFunc(index, func)
    local column = self:GetColumn(index)
    column:Import('click')
    column.DoClick = func
    column.Think = function(panel)
        if (not panel.hoverBlocked) then
            panel:SetTextColor(panel:IsHovered() and color_white or COLOR_GRAY)
        end
    end
end

function PANEL:GetColumn(index)
    local column = self.columns[index]
    assert(column, 'Invalid column')
    return column
end

function PANEL:PerformLayout(w, h)
    local bEqual = false
    local widthLeft = 1
    local columnsAmount = #self.columns

    local smallWidth = w * .066
    local smallAmount = 0

    local bigAmount = 0
    local bigAreaWidth = w

    -- calculate sizes
    if (not bEqual) then
        for index = columnsAmount, 1, -1 do
            local column = self.columns[index]
            local data = column.data
            if (data.small) then
                smallAmount = smallAmount + 1
                bigAreaWidth = bigAreaWidth - smallWidth
            else
                bigAmount = bigAmount + 1
            end
        end
    end

    -- set sizes
    for index, column in ipairs(self.columns) do
        local width = not bEqual and math.Round(column.data.small and smallWidth or bigAreaWidth / bigAmount) or math.Round(w / columnsAmount)
        local side = bigAmount == 0 and RIGHT or LEFT
        local zpos = bigAmount == 0 and (columnsAmount - index) or index

        column:SetWide(width)
        column:SetZPos(zpos)
        column:Dock(side)
    end
end

onyx.gui.Register('onyx.Scoreboard.ColumnsRow', PANEL)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_frame.lua:
return gluapack()()
--PATH lua/openpermissions/cl.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/derma/cl_config.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_card.lua:
return gluapack()()
--PATH lua/autorun/proto.lua:
return gluapack()()
--PATH lua/autorun/r2.lua:
return gluapack()()
--PATH lua/reality_development/client/cl_imgur.lua:
local materials = {}
local grabbingMaterials = {}

function RDV.LIBRARY.GetImgur(id, callback, useproxy, matSettings)
    if materials[id] then return callback(materials[id]) end

    file.CreateDir("ncs/")

    if file.Exists("ncs/" .. id .. ".png", "DATA") then
        materials[id] = Material("../data/ncs/" .. id .. ".png", matSettings or "noclamp smooth mips")
        return callback(materials[id])
    end

    http.Fetch(useproxy and "https://proxy.duckduckgo.com/iu/?u=https://i.imgur.com" or "https://i.imgur.com/" .. id .. ".png",
        function(body, len, headers, code)
            if len > 2097152 then
                materials[id] = Material("nil")
                return callback(materials[id])
            end

            file.Write("ncs/" .. id .. ".png", body)
            materials[id] = Material("../data/ncs/" .. id .. ".png", matSettings or "noclamp smooth mips")

            return callback(materials[id])
        end,
        function(error)
            if useproxy then
                materials[id] = Material("nil")
                return callback(materials[id])
            end
            return RDV.LIBRARY.GetImgur(id, callback, true)
        end
    )
end

function RDV.LIBRARY.DrawImgur(x, y, w, h, imgurId, col)
    col = col or color_white

    if not materials[imgurId] then
        if grabbingMaterials[imgurId] then return end
        grabbingMaterials[imgurId] = true

        RDV.LIBRARY.GetImgur(imgurId, function(mat)
            materials[imgurId] = mat
            grabbingMaterials[imgurId] = nil
        end)

        return
    end

    surface.SetMaterial( materials[imgurId] )
        surface.SetDrawColor( col.r, col.g, col.b, col.a )
    surface.DrawTexturedRect(x, y, w, h)
end
--PATH lua/reality_development/client/vgui/cl_scroll.lua:
return gluapack()()
--PATH lua/reality_development/client/vgui/cl_textbutton.lua:
return gluapack()()
--PATH lua/reality_development/functions/net/sh_net.lua:
return gluapack()()
--PATH lua/reality_development/functions/notifications/sh_chat_notifications.lua:
function RDV.LIBRARY.AddText(receivers, ...)
    if SERVER then
        net.Start("RDV.LIBRARY.AddText")
            net.WriteTable({...})
        net.Send(receivers)
    else
        chat.AddText(...)

        surface.PlaySound("common/talk.wav")
    end
end

function RDV.LIBRARY.PlaySound(client, snd)
    if !IsValid(client) or !snd then
        return
    end
    
    if SERVER then
        net.Start("RDV.LIBRARY.PlaySound")
            net.WriteString(snd)
        net.Send(client)
    else
        surface.PlaySound(snd)
    end
end

if CLIENT then
    net.Receive("RDV.LIBRARY.PlaySound", function()
        local SND = net.ReadString()

        surface.PlaySound(SND)
    end)

    net.Receive("RDV.LIBRARY.AddText", function()
        chat.AddText(unpack(net.ReadTable()))

        surface.PlaySound("common/talk.wav")
    end)
else
    util.AddNetworkString("RDV.LIBRARY.PlaySound")
    util.AddNetworkString("RDV.LIBRARY.AddText")
end
--PATH lua/reality_development/functions/sid64_finder/sh_main.lua:
local Players = {}
local SPlayers = {}
local SCOUNT = 0

RDV = RDV or {}

function RDV.GetBySteamID64(SID)
    if not Players[SID] then
        return false
    end

    local PLAYER = Players[SID].Player

    if IsValid(PLAYER) then
        return PLAYER
    else
        return false
    end
end

if SERVER then
    util.AddNetworkString("RDV.PLAYER_SEND_ONLINE_PLAYERS")

    hook.Add("PlayerReadyForNetworking", "RDV.PLAYER_CONNECT_TRACK", function(ply)
        if ply:IsBot() then return end

        local SID64 = ply:SteamID64()
        local INDEX = ply:EntIndex()

        --[[
            Send Currently Connected Players
        --]]

        net.Start("RDV.PLAYER_SEND_ONLINE_PLAYERS")
            net.WriteBool(true)
            net.WriteUInt(SCOUNT, 8)

            for i = 1, SCOUNT do
                if !SPlayers[i] then
                    continue
                end

                net.WriteUInt(SPlayers[i].Index, 8)
            end
        net.Send(ply)

        --[[
            Send Player to Currently Connected Players
        --]]

        net.Start("RDV.PLAYER_SEND_ONLINE_PLAYERS")
            net.WriteBool(false)
            net.WriteUInt(INDEX, 8)
        net.Broadcast()

        local INSERT = table.insert(SPlayers, {
            SteamID64 = SID64,
            Player = ply,
            Index = INDEX,
        })

        Players[SID64] = {
            Player = ply,
            Sequential = INSERT,
        }

        SCOUNT = SCOUNT + 1
    end)

    hook.Add("PlayerDisconnected", "RDV.PLAYER_CONNECT_TRACK", function(ply)
        if ply:IsBot() then return end

        local SID64 = ply:SteamID64()

        local TAB = Players[SID64]

        if TAB then
            if TAB.Sequential then
                table.remove(SPlayers, TAB.Sequential)
            end

            Players[SID64] = nil

            SCOUNT = SCOUNT - 1
        end
    end)
else
    gameevent.Listen( "player_disconnect" )
    hook.Add( "player_disconnect", "RDV.PLAYER.DISCONNECT.SID64", function( data )
        local SID = data.networkid	// Same as Player:SteamID()

        SID = util.SteamIDTo64(SID)

        local TAB = Players[SID]

        if TAB then
            Players[SID] = nil

            SCOUNT = SCOUNT - 1
        end
    end )

    net.Receive("RDV.PLAYER_SEND_ONLINE_PLAYERS", function(len, ply)
        local MULTIPLE = net.ReadBool()
        
        if MULTIPLE then
            local COUNT = net.ReadUInt(8)

            local TAB = {}
            
            for i = 1, COUNT do
                local ENTITY = net.ReadUInt(8)
                ENTITY = Entity(ENTITY)

                if !IsValid(ENTITY) then return end

                if !ENTITY.SteamID64 then
                    continue
                end

                local SID64 = ENTITY:SteamID64()

                TAB[SID64] = ENTITY
            end

            SCOUNT = COUNT
            Players = TAB
        else
            local ENTITY = net.ReadUInt(8)
            ENTITY = Entity(ENTITY)
            
            if !IsValid(ENTITY) then return end

            if !ENTITY.SteamID64 then
                return
            end

            local SID64 = ENTITY:SteamID64()

            Players[SID64] = ENTITY

            SCOUNT = SCOUNT + 1
        end
    end)
end
--PATH lua/reality_development/functions/vars/sh_vars.lua:
return gluapack()()
--PATH lua/reality_development/functions/vars/sh_vars.lua:
local VARS = {}

function RDV.LIBRARY.SetVar(addon, key, val)
    VARS[addon] = VARS[addon] or {}
    VARS[addon][key] = val
end

function RDV.LIBRARY.GetVar(addon, key)
    if !VARS[addon] or !VARS[addon][key] then
        return false
    end

    return VARS[addon][key]
end
--PATH lua/reality_development/libs/characters/list/sh_aden.lua:
local OBJ = RDV.LIBRARY.RegisterCharacter("aden")

if SERVER then
    local DELETE = {}
    local LOAD = {}
    local CHANGE = {}

    hook.Add("Tick", "RDV_ADEN_LOAD", function()

        if Aden_DC and Aden_DC.Support and Aden_DC.Support.List then
            print("We've Found Aden's Character System...")

            hook.Remove("Tick", "RDV_ADEN_LOAD")

            function OBJ:GetCharacterID(p)
                if not p.adcInformation.selectedCharacter then
                    return
                end
            
                return (p.adcInformation.selectedCharacter or 1)
            end
        
            Aden_DC.Support.List["RDV"] = {
                preChangeCharacter = function(ply, OCHAR, char)
                    if OCHAR and ( char ~= OCHAR ) then
                        for k, v in ipairs(CHANGE) do
                            v(ply, char, OCHAR)
                        end
                    end
                end,
                deleteCharacter = function(ply, char)
                    for k, v in ipairs(DELETE) do
                        v(ply, char)
                    end
                end,
                loadCharacter = function(ply, char)
                    for k, v in ipairs(LOAD) do
                        v(ply, char)
                    end
                end,
            }
        end
    end )

    function OBJ:OnCharacterDeleted(CALLBACK)
        table.insert(DELETE, CALLBACK)
    end
        
    function OBJ:OnCharacterLoaded(CALLBACK)
        table.insert(LOAD, CALLBACK)
    end
        
    function OBJ:OnCharacterChanged(CALLBACK)
        table.insert(CHANGE, CALLBACK)
    end
end
--PATH lua/autorun/rw_cvars_dispencer.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/libs/sh_sfs.lua:
-- SFS (Srlion's Fast Serializer)
-- we try to avoid NYI operations in luajit as much as possible
-- unforunately, we can't avoid all of them in luajit 2.0.5 - pairs & table.concat
-- https://github.com/tarantool/tarantool/wiki/LuaJIT-Not-Yet-Implemented
-- we don't use string concating because it's also NYI in luajit 2.0.5
-- we never error so we don't get blacklisted by the jit compiler
-- errors return strings instead of throwing errors

-- this is intentionally made for net messages, so you don't have to use pcall to check if there are any errors
-- you should use this without using util.Compress, as this just adds one byte to each value, you will probably end up with a larger string if you compress it

-- this idea is from messagepack which is really smart
-- small numbers (0 ~ 127) and (-32 ~ -1) are encoded as a single byte
-- tables and arrays are encoded with a prefix byte, which is the number of elements in the table or array, but it can be one byte if it's less than 16
-- strings are encoded with a prefix byte, which is the length of the string, but it can be one byte if it's less than 32

local math = math
local HUGE = math.huge
local floor = math.floor
local internal_type = type
local IsColor = IsColor
local type = function(v)
    if IsColor(v) then
        return "Color"
    end
    return internal_type(v)
end

-- string.char is not jit compiled in luajit 2.0.5
local chars = {}; do
    for i = 0, 255 do
        chars[i] = string.char(i)
    end
end

local MAX_NUMBER = 1.7976931348623e+308
local MIN_NUMBER = -MAX_NUMBER

---
local POSITIVE_INT = 0x00
local POSITIVE_INT_END = 0x7f

local TABLE_FIXED = 0x80
local TABLE_FIXED_END = 0x8f

local ARRAY_FIXED = 0x90
local ARRAY_FIXED_END = 0x9f

local STR_FIXED = 0xa0
local STR_FIXED_END = 0xbf

local NIL = 0xc0
local FALSE = 0xc1
local TRUE = 0xc2

local UINT_8 = 0xc3
local UINT_16 = 0xc4
local UINT_32 = 0xc5
local UINT_52 = 0xc6

local NINT_8 = 0xc7
local NINT_16 = 0xc8
local NINT_32 = 0xc9
local NINT_52 = 0xca

local DOUBLE = 0xcb

local STR_8 = 0xcc
local STR_16 = 0xcd
local STR_32 = 0xce

local ARRAY_8 = 0xcf
local ARRAY_16 = 0xd0
local ARRAY_32 = 0xd1

local TABLE_8 = 0xd2
local TABLE_16 = 0xd3
local TABLE_32 = 0xd4

local VECTOR = 0xd5
local ANGLE = 0xd6

local ENTITY = 0xd7
local PLAYER = 0xd8

local COLOR = 0xd9

-- this was added in version 2.0.0
-- it's used for arrays that start at 0, I'm not sure if lua 5.1 has same behavior as luajit 2.0.5
-- but luajit 2.0.5 supports starting arrays at 0 index, so checking if table is an array or not gets messed up and output is wrong
-- so if you supply local t = {[0] = 0, 1, 2, 3} and do next(t, #t) it will return (nil, nil) instead of (0, 0)
local ARRAY_ZERO_BASED_INDEX = 0xda

local FREE_FOR_CUSTOM = 0xdb
local FREE_FOR_CUSTOM_END = 0xdf

local NEGATIVE_INT = 0xe0
local NEGATIVE_INT_END = 0xff
---

local encoders = {}
local Encoder = {
    encoders = encoders
}
do
    local pairs = pairs
    local next = next
    local ceil = math.ceil
    local log = math.log
    local concat = table.concat
    local write, write_unsigned, write_double

    -- garry's mod related
    local Vector_Unpack, Angle_Unpack
    local Entity_EntIndex, Player_UserID
    if FindMetaTable then
        Vector_Unpack = FindMetaTable("Vector").Unpack
        Angle_Unpack = FindMetaTable("Angle").Unpack

        Entity_EntIndex = FindMetaTable("Entity").EntIndex
        Player_UserID = FindMetaTable("Player").UserID
    end
    --

    local get_encoder = function(buf, t)
        local encoder = encoders[type(t)]
        if encoder == nil then
            write(buf, "Unsupported type: ")
            write(buf, type(t))
            return nil
        end
        return encoder
    end

    local buffer = {
        [0] = 0 -- buffer length
    }

    -- this function is obviously not jit compiled in luajit 2.0.5 but internal functions are
    function Encoder.encode(val, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        local encoder = get_encoder(buffer, val)
        if encoder == nil then
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        if encoder(buffer, val, arg) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function Encoder.encode_array(arr, len, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        if encoders.array(buffer, arr, len) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function write(buf, chr)
        local buf_len = buf[0] + 1
        buf[0] = buf_len
        buf[buf_len] = chr
    end
    Encoder.write = write

    encoders["nil"] = function(buf)
        write(buf, chars[NIL])
    end

    function encoders.boolean(buf, bool)
        if bool == true then
            write(buf, chars[TRUE])
        else
            write(buf, chars[FALSE])
        end
    end

    function encoders.array(buf, arr, len, start_index)
        start_index = (start_index == nil or start_index ~= 0 and start_index ~= 1) and 1 or start_index

        if len < 0 then
            write(buf, "Array size cannot be negative: ")
            write(buf, len)
            return true
        elseif len > 0xFFFFFFFF then
            write(buf, "Array size too large to encode: ")
            write(buf, len)
            return true
        end

        if len <= 0xF then
            write(buf, chars[ARRAY_FIXED + len])
        else
            write_unsigned(buf, ARRAY_8, len)
        end

        if start_index == 0 then
            write(buf, chars[ARRAY_ZERO_BASED_INDEX])
        end

        for idx = start_index, len do
            local val = arr[idx]
            local encoder = get_encoder(buf, val)
            if encoder == nil then return true end
            encoder(buf, val)
        end
    end

    -- we can't check if a table is an array or not because lua tables are not arrays, they are tables
    -- use Encoder.encode_array if you want to encode an array
    function encoders.table(buf, tbl)
        -- check if it's an array, it's not accurate for arrays with holes but better than nothing
        do
            -- this is the fastest possible way, a lot better than cbor's/messagepack's/pon's way of checking if it's an array
            local tbl_len = #tbl
            if tbl_len > 0 and next(tbl, tbl_len) == nil and ((tbl_len == 1 and next(tbl) == 1) or (tbl_len > 1 and next(tbl, tbl_len - 1) == tbl_len)) then
                if tbl[0] ~= nil then
                    return encoders.array(buf, tbl, tbl_len, 0)
                else
                    return encoders.array(buf, tbl, tbl_len)
                end
            end
        end

        local buf_len = buf[0]
        local table_start = buf_len -- we store the start of the table so when we write the table size, we can change the current buffer index to the start of the table
        -- we have no way to get the table size without iterating through it, so we just add 5 empty strings to the buffer as a placeholder
        -- we add 5 empty strings because we don't know if table size is going to be a fixed number, uint8, uint16 or uint32
        -- uint32 takes 5 bytes, so we add 5 empty strings
        do
            for idx = 1, 5 do
                buf[buf_len + idx] = ""
            end
            buf_len = buf_len + 5
            buf[0] = buf_len
        end

        local table_count = 0
        for key, val in pairs(tbl) do
            table_count = table_count + 1

            local encoder_key = get_encoder(buf, key)
            if encoder_key == nil then return true end
            encoder_key(buf, key)

            local encoder_val = get_encoder(buf, val)
            if encoder_val == nil then return true end
            encoder_val(buf, val)
        end

        local table_end = buf[0] -- we store the end of the table because we need to change current buffer index to the start of the table to write the table size
        buf[0] = table_start -- change current buffer index to the start of the table

        -- write the table size
        if table_count <= 0xF then
            write(buf, chars[TABLE_FIXED + table_count])
        else
            if table_count > 0xFFFFFFFF then
                write(buf, "Table size too large to encode: ")
                write(buf, table_count)
                return true
            end
            write_unsigned(buf, TABLE_8, table_count)
        end

        buf[0] = table_end -- change current buffer index back to the end of the table
    end

    function encoders.string(buf, str)
        local str_len = #str
        if str_len > 0xFFFFFFFF then
            write(buf, "String too large to encode: ")
            write(buf, str_len)
            return true
        end

        if str_len <= 0x1F then
            write(buf, chars[STR_FIXED + str_len])
        else
            write_unsigned(buf, STR_8, str_len)
        end
        write(buf, str)
    end

    function encoders.number(buf, num)
        if (num > MAX_NUMBER and num ~= HUGE) or (num < MIN_NUMBER and num ~= -HUGE) then
            write(buf, "Number too large to encode: ")
            write(buf, num)
            return true
        end

        if num % 1 ~= 0 or num > 0xFFFFFFFFFFFFF or num < -0xFFFFFFFFFFFFF then -- DOUBLE
            write_double(buf, DOUBLE, num)
            return
        end

        if num < 0 then
            num = -num
            if num <= 0x1F then
                write(buf, chars[NEGATIVE_INT + num])
            else
                write_unsigned(buf, NINT_8, num)
            end
        else
            if num <= 0x7F then
                write(buf, chars[POSITIVE_INT + num])
            else
                write_unsigned(buf, UINT_8, num)
            end
        end
    end

    function encoders.Vector(buf, vec)
        write(buf, chars[VECTOR])
        local x, y, z = Vector_Unpack(vec)
        encoders.number(buf, x)
        encoders.number(buf, y)
        encoders.number(buf, z)
    end

    function encoders.Angle(buf, ang)
        write(buf, chars[ANGLE])
        local p, y, r = Angle_Unpack(ang)
        encoders.number(buf, p)
        encoders.number(buf, y)
        encoders.number(buf, r)
    end

    function encoders.Entity(buf, ent)
        write(buf, chars[ENTITY])
        encoders.number(buf, Entity_EntIndex(ent))
    end

    function encoders.Player(buf, ply)
        write(buf, chars[PLAYER])
        encoders.number(buf, Player_UserID(ply))
    end

    function encoders.Color(buf, col)
        write(buf, chars[COLOR])
        encoders.number(buf, col.r)
        encoders.number(buf, col.g)
        encoders.number(buf, col.b)
        encoders.number(buf, col.a)
    end

    function write_unsigned(buf, tag, num)
        if num <= 0xFF then -- uint8
            write(buf, chars[tag + 0x00])
            write(buf, chars[num])
        elseif num <= 0xFFFF then -- uint16
            write(buf, chars[tag + 0x01])
            write(buf, chars[floor(num / 256)])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFF then -- uint32
            write(buf, chars[tag + 0x02])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFFFFFFF then -- uint52
            write(buf, chars[tag + 0x3])
            write(buf, chars[num % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x100000000) % 256])
            write(buf, chars[floor(num / 0x10000000000) % 256])
            write(buf, chars[floor(num / 0x1000000000000) % 256])
        end
    end
    Encoder.write_unsigned = write_unsigned

    -- i can't remember where i got this from, but it's not mine (i swear i always credit people)
    local log2 = log(2)
    function write_double(buf, tag, value)
        local abs_value = value < 0 and -value or value
        --IEEE double-precision floating point number
        --Specification: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
        --Separate out the sign, exponent and fraction
        local sign = value < 0 and 1 or 0
        local exponent = ceil(log(abs_value) / log2) - 1
        local fraction = abs_value / (2 ^ exponent) - 1
        --Make sure the exponent stays in range - allowed values are -1023 through 1024
        if exponent < -1023 then
            --We allow this case for subnormal numbers and just clamp the exponent and re-calculate the fraction
            --without the offset of 1
            exponent = -1023
            fraction = abs_value / (2 ^ exponent)
        elseif abs_value ~= HUGE and exponent > 1024 then
            write(buf, "Exponent out of range: ")
            write(buf, value)
            return true
        end

        --Handle special cases
        if value == 0 then
            --Zero
            exponent = -1023
            fraction = 0
        elseif abs_value == HUGE then
            --Infinity
            exponent = 1024
            fraction = 0
        elseif value ~= value then
            --NaN
            exponent = 1024
            fraction = 1
        end

        local exp_out = exponent + 1023
        local fraction_out = fraction * 0x10000000000000

        write(buf, chars[tag])
        write(buf, chars[128 * sign + floor(exp_out / 16)])
        write(buf, chars[(exp_out % 16) * 16 + floor(fraction_out / 0x1000000000000)])
        write(buf, chars[floor(fraction_out / 0x10000000000) % 256])
        write(buf, chars[floor(fraction_out / 0x100000000) % 256])
        write(buf, chars[floor(fraction_out / 0x1000000) % 256])
        write(buf, chars[floor(fraction_out / 0x10000) % 256])
        write(buf, chars[floor(fraction_out / 0x100) % 256])
        write(buf, chars[floor(fraction_out % 256)])
    end
    Encoder.write_double = write_double
end

local decoders = {}
local Decoder = {
    decoders = decoders
}
do
    local sub = string.sub

    local read_type, read_byte, read_word, read_dword
    local decode_array, decode_table, decode_string, decode_double

    -- garry's mod related
    local Vector, Angle, Entity, Player, Color = Vector, Angle, Entity, Player, Color
    --

    local str_byte = string.byte
    local byte = function(ctx, size)
        local index = ctx[1]
        if index + size - 1 > ctx[3] then -- buffer length
            return nil, "Attemped to read beyond buffer size"
        elseif index + size - 1 > ctx[4] then -- max size
            return nil, "Max decode size exceeded"
        end
        ctx[1] = index + size
        return str_byte(ctx[2], index, index + size - 1)
    end
    Decoder.byte = byte

    local get_decoder = function(ctx)
        local t = read_type(ctx)
        local decoder = decoders[t]
        if decoder == nil then
            return nil, "Unsupported type: ", t
        end
        return decoder
    end
    Decoder.get_decoder = get_decoder

    local context = {
        1,  -- index
        "", -- buffer
        0,  -- buffer length
        HUGE, -- max size for decode, useful when decoding from user input that was sent over netmessages
    }

    local decode = function()
        if context[3] < 1 then -- this will make string.byte fail
            return nil, "Buffer is empty"
        end

        local err, err_2
        local decoder
        local val

        decoder, err, err_2 = get_decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        val, err, err_2 = decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        return val
    end

    function Decoder.decode(str)
        if type(str) ~= "string" then
            return nil, "str is not a string", str
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = HUGE

        return decode()
    end

    function Decoder.decode_with_max_size(str, max_size)
        if type(str) ~= "string" then
            return nil, "str is not a string", str
        end

        if type(max_size) ~= "number" then
            return nil, "max_size is not a number", max_size
        end

        if max_size < 0 then
            return nil, "max_size can either be a positive number or math.huge for unlimited", max_size
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = max_size

        return decode()
    end

    decoders[NIL] = function(ctx)
        ctx[1] = ctx[1] + 1
        return nil
    end

    decoders[FALSE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return false
    end

    decoders[TRUE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return true
    end

    --
    decoders[ARRAY_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - ARRAY_FIXED
        return decode_array(ctx, len)
    end

    for i = ARRAY_FIXED + 1, ARRAY_FIXED_END do
        decoders[i] = decoders[ARRAY_FIXED]
    end
    --

    decoders[ARRAY_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if len == nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    --
    decoders[TABLE_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - TABLE_FIXED
        return decode_table(ctx, len)
    end

    for i = TABLE_FIXED + 1, TABLE_FIXED_END do
        decoders[i] = decoders[TABLE_FIXED]
    end
    --

    decoders[TABLE_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    --
    decoders[STR_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        local len = bty - STR_FIXED
        return decode_string(ctx, len)
    end

    for i = STR_FIXED + 1, STR_FIXED_END do
        decoders[i] = decoders[STR_FIXED]
    end
    --

    decoders[STR_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    --
    decoders[POSITIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return bty - POSITIVE_INT
    end

    for i = POSITIVE_INT + 1, POSITIVE_INT_END do
        decoders[i] = decoders[POSITIVE_INT]
    end
    --

    decoders[UINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u8, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return u8
    end

    decoders[UINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return u16
    end

    decoders[UINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return u32
    end

    decoders[UINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000)
    end

    --
    decoders[NEGATIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        return NEGATIVE_INT - bty
    end

    for i = NEGATIVE_INT + 1, NEGATIVE_INT_END do
        decoders[i] = decoders[NEGATIVE_INT]
    end
    --

    decoders[NINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n8, err = read_byte(ctx)
        if n8 == nil then
            return nil, err
        end
        return -n8
    end

    decoders[NINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n16
    end

    decoders[NINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n32
    end

    decoders[NINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return -(b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000))
    end

    decoders[DOUBLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return decode_double(ctx)
    end

    decoders[VECTOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local x, y, z

        -- x
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        x, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- z
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        z, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Vector(x, y, z)
    end

    decoders[ANGLE] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local p, y, r

        -- p
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        p, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Angle(p, y, r)
    end

    decoders[ENTITY] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local ent_index

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        ent_index, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Entity(ent_index)
    end

    decoders[PLAYER] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local user_id

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        user_id, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Player(user_id)
    end

    decoders[COLOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local r, g, b, a

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- g
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        g, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- b
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        b, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- a
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        a, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Color(r, g, b, a)
    end

    function decode_array(ctx, len)
        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local arr = {nil, nil, nil, nil, nil, nil, nil, nil}

        local start_index = 1
        if read_type(ctx) == ARRAY_ZERO_BASED_INDEX then
            ctx[1] = ctx[1] + 1
            start_index = 0
        end

        for idx = start_index, len do
            local err, err_2
            local decoder
            local val

            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end

            arr[idx] = val
        end

        return arr
    end
    Decoder.decode_array = decode_array

    function decode_table(ctx, len)
        local err, err_2
        local decoder
        local key, val

        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local tbl = {nil, nil, nil, nil, nil, nil, nil, nil}
        for _ = 1, len do
            -- key
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            key, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            -- val
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            tbl[key] = val
        end

        return tbl
    end
    Decoder.decode_table = decode_table

    function decode_string(ctx, len)
        local index = ctx[1]
        if index + len - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + len - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + len

        return sub(ctx[2], index, index + len - 1)
    end
    Decoder.decode_string = decode_string

    function decode_double(ctx)
        local b1, b2, b3, b4, b5, b6, b7, b8 = byte(ctx, 8)
        if b1 == nil then
            return nil, b2
        end

        --Separate out the values
        local sign = b1 >= 128 and 1 or 0
        local exponent = (b1 % 128) * 16 + floor(b2 / 16)
        local fraction = (b2 % 16) * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8
        --Handle special cases
        if exponent == 2047 then
            --Infinities
            if fraction == 0 then return ((sign == 0 and 1) or -1) * HUGE end
            --NaN
            if fraction == 0xfffffffffffff then return 0 / 0 end
        end

        --Combine the values and return the result
        if exponent == 0 then
            --Handle subnormal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * (fraction / 0x10000000000000)
        else
            --Handle normal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * ((fraction / 0x10000000000000) + 1)
        end
    end
    Decoder.decode_double = decode_double

    function read_type(ctx)
        local typ = str_byte(ctx[2], ctx[1])
        return typ
    end
    Decoder.read_type = read_type

    function read_byte(ctx)
        local bty, err = byte(ctx, 1)
        if bty == nil then
            return nil, err
        end
        return bty
    end
    Decoder.read_byte = read_byte

    function read_word(ctx)
        local b1, b2 = byte(ctx, 2)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x100 + b2
    end
    Decoder.read_word = read_word

    function read_dword(ctx)
        local b1, b2, b3, b4 = byte(ctx, 4)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x1000000 + b2 * 0x10000 + b3 * 0x100 + b4
    end
    Decoder.read_dword = read_dword
end

return {
    Encoder = Encoder, -- to allow usage of internal functions
    Decoder = Decoder, -- to allow usage of internal functions

    encode = Encoder.encode,
    encode_with_buffer = Encoder.encode_with_buffer,
    encode_array = Encoder.encode_array,

    decode = Decoder.decode,
    decode_with_max_size = Decoder.decode_with_max_size,

    set_type_function = function(t_fn) -- this is for me as I have custom type function in sam/scb to allow type function to get jit compiled :c
        type = t_fn
    end,

    add_encoder = function(typ, encoder)
        encoders[typ] = encoder
        if FREE_FOR_CUSTOM == FREE_FOR_CUSTOM_END then
            return nil, "No more free slots for custom encoders"
        end
        FREE_FOR_CUSTOM = FREE_FOR_CUSTOM + 1
        return FREE_FOR_CUSTOM - 1
    end,

    add_decoder = function(typ, decoder)
        decoders[typ] = decoder
    end,

    chars = chars,
    VERSION = "2.0.8"
}

--PATH addons/[admin] sam-160/lua/sam/libs/sh_promises.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam_language.lua:
return "english"
--PATH addons/[admin] sam-160/lua/sam/player/sh_player.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/map.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("map")
	:OnExecute(function(argument, input, ply, _, result)
		local map_name = sam.is_valid_map(input)
		if not map_name and not (argument.optional and input == "None") then
			ply:sam_send_message("invalid", {
				S = "map", S_2 = input
			})
			return false
		end

		table.insert(result, map_name)
	end)

	:Menu(function(set_result, _, buttons, argument)
		local maps = buttons:Add("SAM.ComboBox")
		maps:SetTall(25)

		if argument.optional then
			maps:AddChoice("None", nil, true)
		end

		for _, map_name in ipairs(sam.get_global("Maps", {})) do
			if not (argument.exclude_current and map_name == game.GetMap()) then
				maps:AddChoice(map_name)
			end
		end

		function maps:OnSelect(_, value)
			set_result(value)
		end

		local value = argument.optional and "None" or maps:GetOptionText(1)
		maps:SetValue(value)
		maps:OnSelect(nil, value)

		return maps
	end)

	:AutoComplete(function(_, result, name)
		for _, map_name in ipairs(sam.get_global("Maps", {})) do
			if map_name:lower():find(name, 1, true) then
				table.insert(result, map_name)
			end
		end
	end)
:End()

--PATH addons/[admin] sam-160/lua/sam/command/arguments/number.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local get_number = function(argument, input, gsub)
	if (input == "" or input == nil) and argument.optional then
		if argument.default ~= nil then
			return argument.default
		end
		return ""
	end

	local number = tonumber(input)
	if gsub ~= false and not isnumber(number) then
		number = tonumber(input:gsub("%D", ""), 10 /*gsub returns two args*/)
	end

	return number
end

command.new_argument("number")
	:OnExecute(function(argument, input, ply, _, result, i)
		local number = get_number(argument, input)
		if number == "" then
			result[i] = nil
		elseif not number then
			ply:sam_send_message("invalid", {
				S = argument.hint or "number", S_2 = input
			})
			return false
		else
			if argument.min then
				number = math.max(number, argument.min)
			end

			if argument.max then
				number = math.min(number, argument.max)
			end

			if argument.round then
				number = math.Round(number)
			end

			result[i] = number
		end
	end)
	:Menu(function(set_result, body, buttons, argument)
		local number_entry = buttons:Add("SAM.TextEntry")
		number_entry:SetUpdateOnType(true)
		number_entry:SetNumeric(true)
		number_entry:SetTall(25)

		number_entry:SetCheck(function(number)
			number = get_number(argument, number, false)
			set_result(number)
			return number or false
		end)

		local hint = argument.hint or "number"
		if argument.default then
			hint = hint .. " = " .. tostring(argument.default)
		end
		number_entry:SetPlaceholder(hint)

		return number_entry
	end)
:End()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/steamid.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local cached_ranks = {}
local targeting_offline = {}

local check_steamid = function(steamid)
	if not sam.is_steamid(steamid) then
		if sam.is_steamid64(steamid) then
			return util.SteamIDFrom64(steamid)
		else
			return nil
		end
	end

	return steamid
end

local can_target_steamid_callback = function(data, promise)
	local ply, steamid = promise.ply, promise.steamid

	if not data or sam.ranks.can_target(promise.rank, data.rank) then
		promise:resolve({steamid})
	elseif IsValid(ply) then
		ply:sam_send_message("cant_target_player", {
			S = steamid
		})
	end

	targeting_offline[ply] = nil
	cached_ranks[steamid] = data ~= nil and data or false
end

command.new_argument("steamid")
	:OnExecute(function(argument, input, ply, _, result, i)
		local steamid = check_steamid(input)
		if not steamid then
			ply:sam_send_message("invalid", {
				S = "steamid/steamid64", S_2 = input
			})
			return false
		end

		if argument.allow_higher_target then
			result[i] = steamid
			return
		end

		local promise = sam.Promise.new()
		promise.ply = ply
		promise.rank = ply:GetUserGroup()
		promise.steamid = steamid

		local target = player.GetBySteamID(steamid)
		if sam.isconsole(ply) then
			promise:resolve({steamid})
		elseif target then
			if ply:CanTarget(target) then
				promise:resolve({steamid, target})
			else
				ply:sam_send_message("cant_target_player", {
					S = steamid
				})
			end
		elseif cached_ranks[steamid] ~= nil then
			can_target_steamid_callback(cached_ranks[steamid], promise)
		else
			targeting_offline[ply] = true

			sam.SQL.FQuery([[
				SELECT
					`rank`
				FROM
					`sam_players`
				WHERE
					`steamid` = {1}
			]], {steamid}, can_target_steamid_callback, true, promise)
		end

		result[i] = promise
	end)
	:Menu(function(set_result, body, buttons, argument)
		local steamid_entry = buttons:Add("SAM.TextEntry")
		steamid_entry:SetTall(25)
		steamid_entry:SetUpdateOnType(true)
		steamid_entry:SetPlaceholder("steamid/steamid64")

		steamid_entry:SetCheck(function(steamid)
			steamid = check_steamid(steamid)
			set_result(steamid)
			return steamid or false
		end)

		return steamid_entry
	end)
:End()

timer.Create("SAM.ClearCachedRanks", 60 * 2.5, 0, function()
	table.Empty(cached_ranks)
end)

hook.Add("SAM.ChangedSteamIDRank", "RemoveIfCached", function(steamid)
	cached_ranks[steamid] = nil
end)

hook.Add("SAM.CanRunCommand", "StopIfTargetingOffline", function(ply)
	if targeting_offline[ply] then
		return false
	end
end)

--PATH addons/[lib] sui/lua/sui/vgui/sui_combobox.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/libs/png_encoder.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_text_entry.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/config/server.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/players.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/sh_motd.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config
local command = sam.command

if CLIENT then
	config.add_menu_setting("MOTD URL (Leave empty for no MOTD)", function()
		local entry = vgui.Create("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetNoBar(true)
		entry:SetConfig("MOTDURL", "")

		return entry
	end)
end

local motd
local load_motd = function()
	local url = config.get("MOTDURL", "")
	if url == "" then
		command.remove_command("motd")
		hook.Remove("HUDPaint", "SAM.OpenMOTD")
		return
	end

	if IsValid(motd) then
		motd:Remove()
	end

	command.set_category("Menus")

	command.new("motd")
		:Help("Open MOTD menu")
		:OnExecute(function(ply)
			sam.netstream.Start(ply, "OpenMOTD")
		end)
	:End()

	if CLIENT then
		function sam.menu.open_motd()
			if IsValid(motd) then
				motd:Remove()
			end

			motd = vgui.Create("SAM.Frame")
			motd:Dock(FILL)
			motd:DockMargin(40, 40, 40, 40)
			motd:MakePopup()

			function motd.close.DoClick()
				motd:Remove()
			end

			local html = motd:Add("DHTML")
			html:Dock(FILL)
			html:OpenURL(url)
		end

		sam.netstream.Hook("OpenMOTD", function()
			sam.menu.open_motd()
		end)

		hook.Add("HUDPaint", "SAM.OpenMOTD", function()
			sam.menu.open_motd()
			hook.Remove("HUDPaint", "SAM.OpenMOTD")
		end)
	end
end
config.hook({"MOTDURL"}, load_motd)
--PATH addons/[admin] sam-160/lua/sam/modules/vote.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_label.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local MOUSE_LEFT = MOUSE_LEFT

local SysTime = SysTime

local PANEL = {}

AccessorFunc(PANEL, "m_colText", "TextColor")
AccessorFunc(PANEL, "m_colTextStyle", "TextStyleColor")
AccessorFunc(PANEL, "m_FontName", "Font")

AccessorFunc(PANEL, "m_bDoubleClicking", "DoubleClickingEnabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_bAutoStretchVertical", "AutoStretchVertical", FORCE_BOOL)
AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBackground", "PaintBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bBackground", "DrawBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bDisabled", "Disabled", FORCE_BOOL)

AccessorFunc(PANEL, "m_bIsToggle", "IsToggle", FORCE_BOOL)
AccessorFunc(PANEL, "m_bToggle", "Toggle", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBright", "Bright", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDark", "Dark", FORCE_BOOL)
AccessorFunc(PANEL, "m_bHighlight",	"Highlight", FORCE_BOOL)

PANEL:SetIsToggle(false)
PANEL:SetToggle(false)
PANEL:SetDisabled(false)
PANEL:SetDoubleClickingEnabled(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local SetPaintBackgroundEnabled = Panel.SetPaintBackgroundEnabled
local SetPaintBorderEnabled = Panel.SetPaintBorderEnabled
local InvalidateLayout = Panel.InvalidateLayout
local SetFGColor = Panel.SetFGColor
function PANEL:Init()
	SetMouseInputEnabled(self, false)
	SetPaintBackgroundEnabled(self, false)
	SetPaintBorderEnabled(self, false)
end

function PANEL:AllowScale()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self:SizeToContents()
end

function PANEL:SetFont(font)
	if self.m_FontName == font then return end

	self.m_FontName = font
	self:SetFontInternal(self.m_FontName)
end

function PANEL:SetTextColor(col)
	if self.m_colText == col then return end

	self.m_colText = col
	SetFGColor(self, col.r, col.g, col.b, col.a)
end
PANEL.SetColor = PANEL.SetTextColor

function PANEL:GetColor()
	return self.m_colText or self.m_colTextStyle
end

function PANEL:Toggle()
	if not self:GetIsToggle() then return end

	self:SetToggle(not self:GetToggle())
	self:OnToggled(self:GetToggle())
end

function PANEL:SetDisabled(bDisabled)
	self.m_bDisabled = bDisabled
	InvalidateLayout(self)
end

function PANEL:SetEnabled(bEnabled)
	self:SetDisabled(not bEnabled)
end

function PANEL:IsEnabled()
	return not self:GetDisabled()
end

function PANEL:ApplySchemeSettings()
	local col = self:GetColor()
	if not col then return end

	self:SetFGColor(col.r, col.g, col.b, col.a)
end

function PANEL:AutoStretchVerticalThink()
	self:SizeToContentsY()
end

function PANEL:SetAutoStretchVertical(enable)
	self.m_bAutoStretchVertical = enable
	self.Think = enable and self.AutoStretchVerticalThink or nil
end

function PANEL:OnCursorEntered()
	InvalidateLayout(self, true)
end

function PANEL:OnCursorExited()
	InvalidateLayout(self, true)
end

function PANEL:OnMousePressed(mousecode)
	if self:GetDisabled() then return end

	if mousecode == MOUSE_LEFT and not dragndrop.IsDragging() and self.m_bDoubleClicking then
		if self.LastClickTime and SysTime() - self.LastClickTime < 0.2 then

			self:DoDoubleClickInternal()
			self:DoDoubleClick()
			return
		end

		self.LastClickTime = SysTime()
	end

	if self:IsSelectable() and mousecode == MOUSE_LEFT and input.IsShiftDown() then
		return self:StartBoxSelection()
	end

	self:MouseCapture(true)
	self.Depressed = true
	self:OnDepressed()
	InvalidateLayout(self, true)

	self:DragMousePress(mousecode)
end

function PANEL:OnMouseReleased(mousecode)
	self:MouseCapture(false)

	if self:GetDisabled() then return end
	if not self.Depressed and dragndrop.m_DraggingMain ~= self then return end

	if self.Depressed then
		self.Depressed = nil
		self:OnReleased()
		InvalidateLayout(self, true)
	end

	if self:DragMouseRelease(mousecode) then return end

	if self:IsSelectable() and mousecode == MOUSE_LEFT then
		local canvas = self:GetSelectionCanvas()
		if canvas then
			canvas:UnselectAll()
		end
	end

	if not self.Hovered then return end

	self.Depressed = true

	if mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end

	if mousecode == MOUSE_LEFT then
		self:DoClickInternal()
		self:DoClick()
	end

	if mousecode == MOUSE_MIDDLE then
		self:DoMiddleClick()
	end

	self.Depressed = nil
end

function PANEL:OnReleased()
end

function PANEL:OnDepressed()
end

function PANEL:OnToggled(bool)
end

function PANEL:DoClick()
	self:Toggle()
end

function PANEL:DoRightClick()
end

function PANEL:DoMiddleClick()
end

function PANEL:DoClickInternal()
end

function PANEL:DoDoubleClick()
end

function PANEL:DoDoubleClickInternal()
end

sui.register("Label", PANEL, "Label")
--PATH addons/[lib] sui/lua/sui/vgui/sui_threegrid.lua:
local math = math
local table = table
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local Panel = {}

AccessorFunc(Panel, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "columns", "Columns", FORCE_NUMBER)
AccessorFunc(Panel, "Wide2", "Wide2", FORCE_NUMBER)

function Panel:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)
	self.Rows = {}
	self.Cells = {}
end

function Panel:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells / cols) + 1

	local rows = self.Rows[idx]
	if not rows then
		rows = self:CreateRow()
		self.Rows[idx] = rows
	end

	local margin = self:GetHorizontalMargin()

	local dockl, dockt, _, dockb = pnl:GetDockMargin()
	pnl:SetParent(rows)
	pnl:Dock(LEFT)
	pnl:DockMargin(dockl, dockt, #rows.Items + 1 < cols and self:GetHorizontalMargin() or 0, dockb)
	pnl:SetWide(((self:GetWide2() or self:GetWide()) - margin * (cols - 1)) / cols)

	table.insert(rows.Items, pnl)
	table.insert(self.Cells, pnl)

	self:CalculateRowHeight(rows)
end

function Panel:CreateRow()
	local row = self:Add("Panel")
	row:Dock(TOP)
	row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Items = {}

	return row
end

function Panel:CalculateRowHeight(row)
	local height = 0

	for k, v in ipairs(row.Items) do
		local _, t, _, b = v:GetDockMargin()
		height = math.max(height, v:GetTall() + t + b)
	end

	row:SetTall(height)
end

function Panel:Skip()
	local cell = vgui.Create("Panel")
	self:AddCell(cell)
end

function Panel:CalculateRowHeights()
	for _, row in ipairs(self.Rows) do
		self:CalculateRowHeight(row)
	end
end

function Panel:Clear()
	for _, row in ipairs(self.Rows) do
		for _, cell in ipairs(row.Items) do
			cell:Remove()
		end

		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
end

Panel.OnRemove = Panel.Clear
sui.register("ThreeGrid", Panel, NAME .. ".ScrollPanel")
--PATH addons/[lib] sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_zmenu.lua:
local BSHADOWS = sui.BSHADOWS
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local OPTION_FONT = SUI.CreateFont("MenuOption", "Roboto Medium", 15, 500)

local PANEL = {}

AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_SetInternal", "Internal")

PANEL:SetIsMenu(true)
PANEL:SetDeleteSelf(true)

local pad = 4
local max_height = 300

local PerformLayout = function(s)
	local w, h = s:ChildrenSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end
	s:SetSize(math.max(s:GetMinimumWidth(), w), h)
end

function PANEL:Init()
	self:GetCanvas():DockPadding(0, pad, 0, pad)
	self:SetMinimumWidth(SUI.Scale(100))
	self:SetKeyboardInputEnabled(false)
	self:SetTall(pad * 2)
	self:SetAlpha(0)
	self.tall = pad * 2
	RegisterDermaMenuForClose(self)
	self:On("PerformLayoutInternal", PerformLayout)
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
		self:RoundedBox("Background", pad, x, y, w, h, GetColor("menu"))
	BSHADOWS.EndShadow(1, 3, 3)

	self:MoveToFront()
end

function PANEL:Open(x, y)
	self:SizeToChildren(true, false)

	local w, h = self:GetSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end

	local internal = self:GetInternal()
	internal:On("OnRemove", function()
		self:Remove()
	end)
	if not x then
		x, y = internal:LocalToScreen(0, 0)
		y = y + (internal:GetTall() + 2)
	end

	if y + h > ScrH() then
		y = y - h
	end

	if x + w > ScrW() then
		x = x - w
	end

	if y < 1 then
		y = 1
	end

	if x < 1 then
		x = 1
	end

	self:SetPos(x, y)
	self:MakePopup()
	self:AlphaTo(255, 0.23)
	self:SetDrawOnTop(true)
	self:MoveToFront()
end

local option_OnMouseReleased = function(s, mousecode)
	if s.Depressed and mousecode == MOUSE_LEFT then
		CloseDermaMenus()
	end
	DButton.OnMouseReleased(s, mousecode)
end

function PANEL:AddOption(str, callback)
	local option = self:Add("DButton")
	option:Dock(TOP)
	option:SetFont(OPTION_FONT)
	option:SetText(str)
	option:SizeToContentsX(20)
	option:SizeToContentsY(10)
	option:InvalidateLayout(true)
	option.OnMouseReleased = option_OnMouseReleased

	function option:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, self.Hovered and GetColor("menu_option_hover") or GetColor("menu_option"))
		TextColor(self, self.Hovered and GetColor("menu_option_hover_text") or GetColor("menu_option_text"))
	end

	option.DoClick = callback

	self.tall = self.tall + option:GetTall()
	self:SetTall(self.tall)

	return option
end

function PANEL:AddSpacer()
	local spacer = self:Add("Panel")
	spacer:Dock(TOP)
	spacer:DockMargin(0, 1, 0, 1)
	spacer:SetTall(2)

	function spacer:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, GetColor("menu_spacer"))
	end

	spacer:InvalidateLayout(true)
end

sui.register("Menu", PANEL, NAME .. ".ScrollPanel")
--PATH addons/[chat] scb-29/lua/scb/libs/message_pack/sh_messagepack.lua:
if SCB_LOADED then return end

--
-- lua-MessagePack : <https://fperrad.frama.io/lua-MessagePack/>
--

local SIZEOF_NUMBER = string.pack and #string.pack('n', 0.0) or 8
local maxinteger
local mininteger

local assert = assert
local error = error
local pairs = pairs
local pcall = pcall
local setmetatable = setmetatable
local tostring = tostring
local char = string.char
local format = string.format
local floor = math.floor
local tointeger = floor
local frexp = math.frexp
local ldexp = math.ldexp
local huge = math.huge
local tconcat = table.concat

local type = scb.type
local isnumber = scb.isnumber
local _ENV = nil
local m = {}

--[[ debug only
local function hexadump (s)
	return (s:gsub('.', function (c) return format('%02X ', c:byte()) end))
end
m.hexadump = hexadump
--]]

local function argerror (caller, narg, extramsg)
	error("bad argument #" .. tostring(narg) .. " to "
		  .. caller .. " (" .. extramsg .. ")")
end

local function typeerror (caller, narg, arg, tname)
	argerror(caller, narg, tname .. " expected, got " .. type(arg))
end

local function checktype (caller, narg, arg, tname)
	if type(arg) ~= tname then
		typeerror(caller, narg, arg, tname)
	end
end

local packers = setmetatable({}, {
	__index = function (t, k)
		if k == 1 then return end   -- allows ipairs
		error("pack '" .. k .. "' is unimplemented")
	end
})
m.packers = packers

packers['nil'] = function (buffer)
	buffer[#buffer+1] = char(0xC0)	-- nil
end

packers['boolean'] = function (buffer, bool)
	if bool then
		buffer[#buffer+1] = char(0xC3)	-- true
	else
		buffer[#buffer+1] = char(0xC2)	-- false
	end
end

packers['string_compat'] = function (buffer, str)
	local n = #str
	if n <= 0x1F then
		buffer[#buffer+1] = char(0xA0 + n)	-- fixstr
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDA,		-- str16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDB,		-- str32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'string_compat'"
	end
	buffer[#buffer+1] = str
end

packers['_string'] = function (buffer, str)
	local n = #str
	if n <= 0x1F then
		buffer[#buffer+1] = char(0xA0 + n)		-- fixstr
	elseif n <= 0xFF then
		buffer[#buffer+1] = char(0xD9,			-- str8
								 n)
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDA,			-- str16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDB,			-- str32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'string'"
	end
	buffer[#buffer+1] = str
end

packers['binary'] = function (buffer, str)
	local n = #str
	if n <= 0xFF then
		buffer[#buffer+1] = char(0xC4,		-- bin8
								 n)
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xC5,		-- bin16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xC6,		-- bin32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'binary'"
	end
	buffer[#buffer+1] = str
end

local set_string = function (str)
	if str == 'string_compat' then
		packers['string'] = packers['string_compat']
	elseif str == 'string' then
		packers['string'] = packers['_string']
	elseif str == 'binary' then
		packers['string'] = packers['binary']
	else
		argerror('set_string', 1, "invalid option '" .. str .."'")
	end
end
m.set_string = set_string

packers['map'] = function (buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer+1] = char(0x80 + n)		-- fixmap
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDE,			-- map16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDF,			-- map32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'map'"
	end
	for k, v in pairs(tbl) do
		packers[type(k)](buffer, k)
		packers[type(v)](buffer, v)
	end
end

packers['array'] = function (buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer+1] = char(0x90 + n)		-- fixarray
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDC,			-- array16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDD,			-- array32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'array'"
	end
	for i = 1, n do
		local v = tbl[i]
		packers[type(v)](buffer, v)
	end
end

local set_array = function (array)
	if array == 'without_hole' then
		packers['_table'] = function (buffer, tbl)
			local is_map, n, max = false, 0, 0
			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end
				n = n + 1
			end
			if max ~= n then	-- there are holes
				is_map = true
			end
			if is_map then
				packers['map'](buffer, tbl, n)
			else
				packers['array'](buffer, tbl, n)
			end
		end
	elseif array == 'with_hole' then
		packers['_table'] = function (buffer, tbl)
			local is_map, n, max = false, 0, 0
			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end
				n = n + 1
			end
			if is_map then
				packers['map'](buffer, tbl, n)
			else
				packers['array'](buffer, tbl, max)
			end
		end
	elseif array == 'always_as_map' then
		packers['_table'] = function(buffer, tbl)
			local n = 0
			for k in pairs(tbl) do
				n = n + 1
			end
			packers['map'](buffer, tbl, n)
		end
	else
		argerror('set_array', 1, "invalid option '" .. array .."'")
	end
end
m.set_array = set_array

packers['table'] = function (buffer, tbl)
	packers['_table'](buffer, tbl)
end

packers['unsigned'] = function (buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer+1] = char(n)			-- fixnum_pos
		elseif n <= 0xFF then
			buffer[#buffer+1] = char(0xCC,		-- uint8
									 n)
		elseif n <= 0xFFFF then
			buffer[#buffer+1] = char(0xCD,		-- uint16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n <= 4294967295.0 then
			buffer[#buffer+1] = char(0xCE,		-- uint32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xCF,		-- uint64
									 0,			-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	else
		if n >= -0x20 then
			buffer[#buffer+1] = char(0x100 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer+1] = char(0xD0,		-- int8
									 0x100 + n)
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer+1] = char(0xD1,		-- int16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer+1] = char(0xD2,		-- int32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xD3,		-- int64
									 0xFF,		-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	end
end

packers['signed'] = function (buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer+1] = char(n)			-- fixnum_pos
		elseif n <= 0x7FFF then
			buffer[#buffer+1] = char(0xD1,		-- int16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n <= 0x7FFFFFFF then
			buffer[#buffer+1] = char(0xD2,		-- int32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xD3,		-- int64
									 0,			-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	else
		if n >= -0x20 then
			buffer[#buffer+1] = char(0xE0 + 0x20 + n)   -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer+1] = char(0xD0,		-- int8
									 0x100 + n)
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer+1] = char(0xD1,		-- int16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer+1] = char(0xD2,		-- int32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xD3,		-- int64
									 0xFF,		-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	end
end

local set_integer = function (integer)
	if integer == 'unsigned' then
		packers['integer'] = packers['unsigned']
	elseif integer == 'signed' then
		packers['integer'] = packers['signed']
	else
		argerror('set_integer', 1, "invalid option '" .. integer .."'")
	end
end
m.set_integer = set_integer

packers['float'] = function (buffer, n)
	local sign = 0
	if n < 0.0 then
		sign = 0x80
		n = -n
	end
	local mant, expo = frexp(n)
	if mant ~= mant then
		buffer[#buffer+1] = char(0xCA,  -- nan
								 0xFF, 0x88, 0x00, 0x00)
	elseif mant == huge or expo > 0x80 then
		if sign == 0 then
			buffer[#buffer+1] = char(0xCA,	  -- inf
									 0x7F, 0x80, 0x00, 0x00)
		else
			buffer[#buffer+1] = char(0xCA,	  -- -inf
									 0xFF, 0x80, 0x00, 0x00)
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
		buffer[#buffer+1] = char(0xCA,  -- zero
								 sign, 0x00, 0x00, 0x00)
	else
		expo = expo + 0x7E
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 24))
		buffer[#buffer+1] = char(0xCA,
								 sign + floor(expo / 0x2),
								 (expo % 0x2) * 0x80 + floor(mant / 0x10000),
								 floor(mant / 0x100) % 0x100,
								 mant % 0x100)
	end
end

packers['double'] = function (buffer, n)
	local sign = 0
	if n < 0.0 then
		sign = 0x80
		n = -n
	end
	local mant, expo = frexp(n)
	if mant ~= mant then
		buffer[#buffer+1] = char(0xCB,  -- nan
								 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
	elseif mant == huge or expo > 0x400 then
		if sign == 0 then
			buffer[#buffer+1] = char(0xCB,	  -- inf
									 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
		else
			buffer[#buffer+1] = char(0xCB,	  -- -inf
									 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x3FE then
		buffer[#buffer+1] = char(0xCB,  -- zero
								 sign, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
	else
		expo = expo + 0x3FE
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 53))
		buffer[#buffer+1] = char(0xCB,
								 sign + floor(expo / 0x10),
								 (expo % 0x10) * 0x10 + floor(mant / 0x1000000000000),
								 floor(mant / 0x10000000000) % 0x100,
								 floor(mant / 0x100000000) % 0x100,
								 floor(mant / 0x1000000) % 0x100,
								 floor(mant / 0x10000) % 0x100,
								 floor(mant / 0x100) % 0x100,
								 mant % 0x100)
	end
end

local set_number = function (number)
	if number == 'float' then
		packers['number'] = function (buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers['integer'](buffer, n)
			else
				packers['float'](buffer, n)
			end
		end
	elseif number == 'double' then
		packers['number'] = function (buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers['integer'](buffer, n)
			else
				packers['double'](buffer, n)
			end
		end
	else
		argerror('set_number', 1, "invalid option '" .. number .."'")
	end
end
m.set_number = set_number

for k = 0, 4 do
	local n = tointeger(2^k)
	local fixext = 0xD4 + k
	packers['fixext' .. tostring(n)] = function (buffer, tag, data)
		assert(#data == n, "bad length for fixext" .. tostring(n))
		buffer[#buffer+1] = char(fixext,
								 tag < 0 and tag + 0x100 or tag)
		buffer[#buffer+1] = data
	end
end

packers['ext'] = function (buffer, tag, data)
	local n = #data
	if n <= 0xFF then
		buffer[#buffer+1] = char(0xC7,		  -- ext8
								 n,
								 tag < 0 and tag + 0x100 or tag)
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xC8,		  -- ext16
								 floor(n / 0x100),
								 n % 0x100,
								 tag < 0 and tag + 0x100 or tag)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xC9,		  -- ext&32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100,
								 tag < 0 and tag + 0x100 or tag)
	else
		error"overflow in pack 'ext'"
	end
	buffer[#buffer+1] = data
end

function m.pack (data)
	local buffer = {}
	packers[type(data)](buffer, data)
	return tconcat(buffer)
end


local unpackers		 -- forward declaration

local function unpack_cursor (c)
	local s, i, j = c.s, c.i, c.j
	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end
	local val = s:byte(i)
	c.i = i+1
	return unpackers[val](c, val)
end
m.unpack_cursor = unpack_cursor

local function unpack_str (c, n)
	local s, i, j = c.s, c.i, c.j
	local e = i+n-1
	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i+n-1
	end
	c.i = i+n
	return s:sub(i, e)
end

local function unpack_array (c, n)
	local t = {}
	for i = 1, n do
		t[i] = unpack_cursor(c)
	end
	return t
end

local function unpack_map (c, n)
	local t = {}
	for i = 1, n do
		local k = unpack_cursor(c)
		local val = unpack_cursor(c)
		if k == nil or k ~= k then
			k = m.sentinel
		end
		if k ~= nil then
			t[k] = val
		end
	end
	return t
end

local function unpack_float (c)
	local s, i, j = c.s, c.i, c.j
	if i+3 > j then
		c:underflow(i+3)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4 = s:byte(i, i+3)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x2 + floor(b2 / 0x80)
	local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4
	if sign then
		sign = -1
	else
		sign = 1
	end
	local n
	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0xFF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0/0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 0x800000, expo - 0x7F)
	end
	c.i = i+4
	return n
end

local function unpack_double (c)
	local s, i, j = c.s, c.i, c.j
	if i+7 > j then
		c:underflow(i+7)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i+7)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
	local mant = ((((((b2 % 0x10) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	if sign then
		sign = -1
	else
		sign = 1
	end
	local n
	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0x7FF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0/0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 4503599627370496.0, expo - 0x3FF)
	end
	c.i = i+8
	return n
end

local function unpack_uint8 (c)
	local s, i, j = c.s, c.i, c.j
	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end
	local b1 = s:byte(i)
	c.i = i+1
	return b1
end

local function unpack_uint16 (c)
	local s, i, j = c.s, c.i, c.j
	if i+1 > j then
		c:underflow(i+1)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2 = s:byte(i, i+1)
	c.i = i+2
	return b1 * 0x100 + b2
end

local function unpack_uint32 (c)
	local s, i, j = c.s, c.i, c.j
	if i+3 > j then
		c:underflow(i+3)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4 = s:byte(i, i+3)
	c.i = i+4
	return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
end

local function unpack_uint64 (c)
	local s, i, j = c.s, c.i, c.j
	if i+7 > j then
		c:underflow(i+7)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i+7)
	c.i = i+8
	return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
end

local function unpack_int8 (c)
	local s, i, j = c.s, c.i, c.j
	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end
	local b1 = s:byte(i)
	c.i = i+1
	if b1 < 0x80 then
		return b1
	else
		return b1 - 0x100
	end
end

local function unpack_int16 (c)
	local s, i, j = c.s, c.i, c.j
	if i+1 > j then
		c:underflow(i+1)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2 = s:byte(i, i+1)
	c.i = i+2
	if b1 < 0x80 then
		return b1 * 0x100 + b2
	else
		return ((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) - 1
	end
end

local function unpack_int32 (c)
	local s, i, j = c.s, c.i, c.j
	if i+3 > j then
		c:underflow(i+3)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4 = s:byte(i, i+3)
	c.i = i+4
	if b1 < 0x80 then
		return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
	else
		return ((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) - 1
	end
end

local function unpack_int64 (c)
	local s, i, j = c.s, c.i, c.j
	if i+7 > j then
		c:underflow(i+7)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i+7)
	c.i = i+8
	if b1 < 0x80 then
		return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	else
		return ((((((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) * 0x100 + (b5 - 0xFF)) * 0x100 + (b6 - 0xFF)) * 0x100 + (b7 - 0xFF)) * 0x100 + (b8 - 0xFF)) - 1
	end
end

function m.build_ext (tag, data)
	return nil
end

local function unpack_ext (c, n, tag)
	local s, i, j = c.s, c.i, c.j
	local e = i+n-1
	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i+n-1
	end
	c.i = i+n
	return m.build_ext(tag, s:sub(i, e))
end

local fn_1 = function(c, val)
	return val
end

local fn_2 = function(c, val)
	return unpack_map(c, val % 0x10)
end

local fn_3 = function(c, val)
	return unpack_array(c, val % 0x10)
end

local fn_4 = function(c, val)
	return unpack_str(c, val % 0x20)
end

local fn_5 = function(c, val)
	return val - 0x100
end

unpackers = setmetatable({
	[0xC0] = function () return nil end,
	[0xC2] = function () return false end,
	[0xC3] = function () return true end,
	[0xC4] = function (c) return unpack_str(c, unpack_uint8(c)) end,	-- bin8
	[0xC5] = function (c) return unpack_str(c, unpack_uint16(c)) end,   -- bin16
	[0xC6] = function (c) return unpack_str(c, unpack_uint32(c)) end,   -- bin32
	[0xC7] = function (c) return unpack_ext(c, unpack_uint8(c), unpack_int8(c)) end,
	[0xC8] = function (c) return unpack_ext(c, unpack_uint16(c), unpack_int8(c)) end,
	[0xC9] = function (c) return unpack_ext(c, unpack_uint32(c), unpack_int8(c)) end,
	[0xCA] = unpack_float,
	[0xCB] = unpack_double,
	[0xCC] = unpack_uint8,
	[0xCD] = unpack_uint16,
	[0xCE] = unpack_uint32,
	[0xCF] = unpack_uint64,
	[0xD0] = unpack_int8,
	[0xD1] = unpack_int16,
	[0xD2] = unpack_int32,
	[0xD3] = unpack_int64,
	[0xD4] = function (c) return unpack_ext(c, 1, unpack_int8(c)) end,
	[0xD5] = function (c) return unpack_ext(c, 2, unpack_int8(c)) end,
	[0xD6] = function (c) return unpack_ext(c, 4, unpack_int8(c)) end,
	[0xD7] = function (c) return unpack_ext(c, 8, unpack_int8(c)) end,
	[0xD8] = function (c) return unpack_ext(c, 16, unpack_int8(c)) end,
	[0xD9] = function (c) return unpack_str(c, unpack_uint8(c)) end,
	[0xDA] = function (c) return unpack_str(c, unpack_uint16(c)) end,
	[0xDB] = function (c) return unpack_str(c, unpack_uint32(c)) end,
	[0xDC] = function (c) return unpack_array(c, unpack_uint16(c)) end,
	[0xDD] = function (c) return unpack_array(c, unpack_uint32(c)) end,
	[0xDE] = function (c) return unpack_map(c, unpack_uint16(c)) end,
	[0xDF] = function (c) return unpack_map(c, unpack_uint32(c)) end,
}, {
	__index = function (t, k)
		if k < 0xC0 then
			if k < 0x80 then
				return fn_1
			elseif k < 0x90 then
				return fn_2
			elseif k < 0xA0 then
				return fn_3
			else
				return fn_4
			end
		elseif k > 0xDF then
			return fn_5
		else
			return function () error("unpack '" .. format('%#x', k) .. "' is unimplemented") end
		end
	end
})

local function cursor_string (str)
	return {
		s = str,
		i = 1,
		j = #str,
		underflow = function ()
						error "missing bytes"
					end,
	}
end

local function cursor_loader (ld)
	return {
		s = '',
		i = 1,
		j = 0,
		underflow = function (self, e)
						self.s = self.s:sub(self.i)
						e = e - self.i + 1
						self.i = 1
						self.j = 0
						while e > self.j do
							local chunk = ld()
							if not chunk then
								error "missing bytes"
							end
							self.s = self.s .. chunk
							self.j = #self.s
						end
					end,
	}
end

function m.unpack (s)
	checktype('unpack', 1, s, 'string')
	local cursor = cursor_string(s)
	local data = unpack_cursor(cursor)
	if cursor.i <= cursor.j then
		error "extra bytes"
	end
	return data
end

function m.unpacker (src)
	if type(src) == 'string' then
		local cursor = cursor_string(src)
		return function ()
			if cursor.i <= cursor.j then
				return cursor.i, unpack_cursor(cursor)
			end
		end
	elseif type(src) == 'function' then
		local cursor = cursor_loader(src)
		return function ()
			if cursor.i > cursor.j then
				pcall(cursor.underflow, cursor, cursor.i)
			end
			if cursor.i <= cursor.j then
				return true, unpack_cursor(cursor)
			end
		end
	else
		argerror('unpacker', 1, "string or function expected, got " .. type(src))
	end
end

set_string'string_compat'
set_integer'unsigned'
if SIZEOF_NUMBER == 4 then
	maxinteger = 16777215
	mininteger = -maxinteger
	m.small_lua = true
	unpackers[0xCB] = nil	   -- double
	unpackers[0xCF] = nil	   -- uint64
	unpackers[0xD3] = nil	   -- int64
	set_number'float'
else
	maxinteger = 9007199254740991
	mininteger = -maxinteger
	set_number'double'
	if SIZEOF_NUMBER > 8 then
		m.long_double = true
	end
end
set_array'without_hole'

m._VERSION = '0.5.2'
m._DESCRIPTION = "lua-MessagePack : a pure Lua implementation"
m._COPYRIGHT = "Copyright (c) 2012-2019 Francois Perrad"

return m

--
-- This library is licensed under the terms of the MIT/X11 license,
-- like Lua itself.
--

--PATH addons/[chat] scb-29/lua/scb/cl_emojis_data.lua:
return {["jack_o_lantern"]="41",["sloth"]="254",["flag_nl"]="8179",["man_raising_hand"]="1240",["crossed_swords"]="6187",["flag_ck"]="853",["flag_mn"]="8160",["woman_kiss_man"]="1447",["heartpulse"]="1120",["man_girl"]="1472",["flag_se"]="8210",["woman_with_probing_cane"]="1372",["flag_bd"]="827",["rolled_up_newspaper"]="6117",["fog"]="5195",["flag_af"]="811",["aries"]="760",["japan"]="56",["arrow_forward"]="776",["stadium"]="517",["five"]="7139",["flag_kr"]="8135",["guitar"]="663",["woman_kiss_woman"]="1449",["flag_ro"]="8202",["man_getting_massage"]="1356",["exclamation"]="7127",["flag_gt"]="8103",["princess"]="1315",["skunk"]="256",["world_map"]="55",["flag_sm"]="8217",["crab"]="380",["flag_bl"]="834",["grey_exclamation"]="7126",["rainbow"]="5198",["woman_mountain_biking"]="1421",["racing_motorcycle"]="592",["deaf_person"]="1242",["kangaroo"]="257",["stethoscope"]="6212",["flag_cz"]="865",["spider"]="2101",["man_girl_boy"]="1473",["smirk"]="137",["ophiuchus"]="772",["flag_uy"]="8249",["cool"]="7154",["woman_getting_massage"]="1357",["whale"]="285",["frog"]="276",["man_standing"]="1365",["running_shirt_with_sash"]="451",["wind_chime"]="414",["imp"]="192",["thought_balloon"]="1148",["biohazard_sign"]="726",["m"]="7158",["sparkler"]="44",["jigsaw"]="465",["clock430"]="5149",["bust_in_silhouette"]="1481",["wine_glass"]="3105",["no_bicycles"]="718",["sneezing_face"]="152",["carousel_horse"]="558",["flag_ps"]="8196",["chipmunk"]="248",["ant"]="297",["man_running"]="1380",["nine"]="7143",["bamboo"]="411",["facepunch"]="1171",["earth_africa"]="51",["woman_running"]="1381",["lower_left_fountain_pen"]="6147",["wedding"]="538",["disappointed_relieved"]="176",["clock530"]="5151",["man_woman_girl_girl"]="1459",["computer"]="677",["mantelpiece_clock"]="5139",["woman_heart_woman"]="1453",["broom"]="6223",["trackball"]="682",["martial_arts_uniform"]="445",["lemon"]="35",["flag_qa"]="8200",["surfer"]="1401",["child"]="1199",["flag_cr"]="859",["male_singer"]="1288",["rice_scene"]="415",["metro"]="568",["flag_jo"]="8126",["drum_with_drumsticks"]="668",["black_right_pointing_double_triangle_with_vertical_bar"]="778",["blue_heart"]="1131",["house_buildings"]="521",["male_judge"]="1264",["wheelchair"]="74",["field_hockey_stick_and_ball"]="439",["fish_cake"]="374",["spoon"]="3119",["man_woman_boy_boy"]="1458",["dark_sunglasses"]="62",["lock_with_ink_pen"]="6177",["u5408"]="7178",["man_in_business_suit_levitating"]="1384",["raised_back_of_hand"]="1151",["probing_cane"]="6196",["currency_exchange"]="6130",["person_in_lotus_position"]="1437",["flag_pk"]="8191",["flag_ua"]="8244",["hot_pepper"]="323",["large_orange_circle"]="7185",["male_firefighter"]="1300",["paperclip"]="6167",["flag_km"]="8132",["pizza"]="346",["massage"]="1355",["female_astronaut"]="1298",["postbox"]="6143",["railway_track"]="5102",["label"]="6120",["microscope"]="6205",["mask"]="147",["ramen"]="368",["boxing_glove"]="444",["man_walking"]="1362",["jeans"]="68",["flag_iq"]="8120",["statue_of_liberty"]="540",["flag_bw"]="843",["flag_my"]="8171",["axe"]="6182",["money_with_wings"]="6126",["tophat"]="636",["flag_no"]="8180",["milky_way"]="5184",["flag_cu"]="860",["on"]="745",["flag_tk"]="8234",["high_brightness"]="793",["flag_eh"]="877",["arrow_double_up"]="784",["white_flower"]="2108",["flag_gb"]="889",["male_astronaut"]="1297",["face_palm"]="1248",["llama"]="237",["bald_man"]="1209",["angel"]="1325",["female_doctor"]="1256",["flag_om"]="8185",["abacus"]="687",["abcd"]="7146",["printer"]="679",["man_kiss_man"]="1448",["moyai"]="6233",["construction"]="5109",["arrow_upper_right"]="728",["man_dancing"]="1383",["female_artist"]="1292",["smile_cat"]="1104",["pig"]="228",["flag_sl"]="8216",["star2"]="5182",["tennis"]="435",["radio"]="661",["beers"]="3109",["custard"]="397",["blue_book"]="6108",["flag_bo"]="837",["flag_mq"]="8163",["flag_ls"]="8145",["flag_hk"]="8107",["volcano"]="510",["weary"]="184",["spider_web"]="2102",["sweat_smile"]="16",["leaves"]="2127",["car"]="585",["white_haired_man"]="1208",["flag_cm"]="855",["flag_tz"]="8243",["art"]="477",["pouch"]="623",["flag_ng"]="8177",["rooster"]="262",["boom"]="1138",["supervillain"]="1331",["u7121"]="7174",["earth_americas"]="52",["clock11"]="5162",["six"]="7140",["shopping_bags"]="624",["mushroom"]="329",["wc"]="79",["ng"]="7160",["flag_lc"]="8141",["flag_ge"]="891",["hatched_chick"]="265",["flag_pr"]="8195",["clock3"]="5146",["diamonds"]="469",["unlock"]="6176",["o"]="7106",["credit_card"]="6127",["flags"]="413",["mailbox_with_no_mail"]="6142",["softball"]="430",["melon"]="32",["bride_with_veil"]="1322",["unamused"]="138",["taco"]="349",["helicopter"]="5124",["snow_cloud"]="5192",["nazar_amulet"]="460",["goat"]="234",["flag_aq"]="817",["repeat_one"]="775",["astonished"]="169",["newspaper"]="6116",["speaking_head_in_silhouette"]="1480",["lower_left_crayon"]="6150",["purple_heart"]="1132",["athletic_shoe"]="627",["dancers"]="1385",["large_blue_circle"]="7188",["fries"]="345",["flag_lk"]="8143",["u7533"]="7177",["cinema"]="791",["flag_tr"]="8239",["pray"]="1179",["man_playing_water_polo"]="1429",["womans_clothes"]="620",["musical_note"]="654",["confused"]="163",["no_entry_sign"]="717",["calling"]="670",["cookie"]="389",["pushpin"]="6165",["female_pilot"]="1295",["weight_lifter"]="1413",["admission_tickets"]="420",["gift"]="418",["lightning"]="5193",["restroom"]="77",["broccoli"]="326",["manual_wheelchair"]="594",["sagittarius"]="768",["no_mobile_phones"]="723",["purse"]="621",["sunflower"]="2113",["double_vertical_bar"]="787",["om_symbol"]="750",["flag_za"]="8263",["flushed"]="170",["male_pilot"]="1294",["curry"]="367",["chair"]="6216",["panda_face"]="253",["large_blue_square"]="7197",["lollipop"]="396",["oden"]="371",["flying_disc"]="436",["flag_ai"]="813",["ice_cream"]="387",["flag_gg"]="893",["cow2"]="227",["sleuth_or_spy"]="1305",["high_heel"]="630",["flag_hr"]="8110",["fearful"]="174",["flag_mx"]="8170",["flag_nf"]="8176",["person_in_steamy_room"]="1388",["joystick"]="462",["garlic"]="327",["speaker"]="645",["video_camera"]="695",["male_farmer"]="1267",["flag_tj"]="8233",["female_detective"]="1307",["see_no_evil"]="1112",["dromedary_camel"]="235",["ear_of_rice"]="2121",["heavy_minus_sign"]="7114",["male_supervillain"]="1332",["straight_ruler"]="6169",["robot_face"]="1102",["flag_bv"]="842",["sparkling_heart"]="1119",["trumpet"]="665",["no_entry"]="716",["up"]="7165",["flag_dk"]="869",["ledger"]="6112",["headphones"]="660",["full_moon"]="5168",["no_smoking"]="719",["flag_pm"]="8193",["couplekiss"]="1446",["flag_cd"]="848",["chart_with_upwards_trend"]="6161",["two_women_holding_hands"]="1443",["man_woman_boy"]="1455",["tiger2"]="217",["sunrise_over_mountains"]="552",["flag_bf"]="829",["man_woman_girl"]="1456",["flag_so"]="8219",["hugging_face"]="128",["flag_mp"]="8162",["clock1030"]="5161",["yum"]="122",["chart"]="6129",["ox"]="225",["camping"]="512",["bath"]="1440",["onion"]="328",["rice_cracker"]="364",["beverage_box"]="3113",["flag_hu"]="8112",["clock830"]="5157",["flag_cl"]="854",["large_yellow_circle"]="7186",["last_quarter_moon_with_face"]="5175",["handball"]="1431",["spiral_note_pad"]="6158",["flag_tm"]="8236",["female_construction_worker"]="1313",["female_office_worker"]="1280",["yellow_heart"]="1129",["hotsprings"]="557",["beach_with_umbrella"]="513",["flag_bn"]="836",["shield"]="6190",["film_projector"]="690",["o2"]="7161",["ok_woman"]="1233",["flag_lb"]="8140",["flag_gd"]="890",["package"]="6138",["clock2"]="5144",["candle"]="699",["clock10"]="5160",["person_with_blond_hair"]="1203",["elephant"]="239",["small_red_triangle_down"]="7213",["man_man_girl"]="1461",["koko"]="7167",["elf"]="1346",["clock630"]="5153",["camera"]="693",["money_mouth_face"]="127",["first_quarter_moon"]="5166",["male_sign"]="798",["duck"]="270",["snow_capped_mountain"]="58",["clown_face"]="196",["no_bell"]="652",["flag_kw"]="8136",["kiwifruit"]="315",["tanabata_tree"]="410",["eyeglasses"]="61",["ok_hand"]="1155",["last_quarter_moon"]="5170",["lower_left_paintbrush"]="6149",["anguished"]="173",["womans_hat"]="635",["parking"]="7163",["flag_sg"]="8211",["wrestlers"]="1425",["closed_lock_with_key"]="6178",["circus_tent"]="562",["expressionless"]="135",["symbols"]="7148",["wrench"]="6191",["flag_lu"]="8147",["fire"]="5208",["phone"]="671",["flag_gn"]="898",["scarf"]="69",["man_gesturing_no"]="1231",["two_hearts"]="1123",["arrows_clockwise"]="741",["airplane_arriving"]="5121",["movie_camera"]="688",["man_man_girl_girl"]="1464",["woman_frowning"]="1226",["orange_book"]="6109",["petri_dish"]="6203",["clipboard"]="6164",["clock130"]="5143",["question"]="7124",["flag_yt"]="8262",["iphone"]="669",["dolls"]="412",["tea"]="3102",["three"]="7137",["flag_pt"]="8197",["baby_bottle"]="399",["film_frames"]="689",["spiral_calendar_pad"]="6159",["waxing_crescent_moon"]="5165",["octagonal_sign"]="5108",["male_construction_worker"]="1312",["shirt"]="67",["maple_leaf"]="2125",["female_police_officer"]="1304",["barber"]="561",["man_wrestling"]="1426",["menorah_with_nine_branches"]="758",["woman"]="1210",["burrito"]="350",["ballot_box_with_ballot"]="6144",["bus"]="575",["bell"]="651",["hamster"]="245",["heart_decoration"]="1124",["grinning"]="11",["man_boy"]="1470",["bulb"]="6100",["small_orange_diamond"]="7210",["flag_tt"]="8240",["secret"]="7181",["congratulations"]="7180",["male_superhero"]="1329",["chart_with_downwards_trend"]="6162",["flag_sv"]="8223",["part_alternation_mark"]="7118",["wavy_dash"]="7128",["yo_yo"]="456",["white_large_square"]="7201",["black_large_square"]="7200",["left_luggage"]="713",["arrow_down"]="731",["flag_is"]="8122",["small_red_triangle"]="7212",["tractor"]="590",["green_book"]="6107",["sleeping_accommodation"]="1441",["baseball"]="429",["thumbsdown"]="1169",["arrow_up"]="727",["shell"]="293",["arrow_heading_down"]="740",["arrow_heading_up"]="739",["koala"]="252",["desert"]="514",["loop"]="7117",["flag_vi"]="8255",["flag_pl"]="8192",["children_crossing"]="715",["lizard"]="279",["curly_loop"]="7116",["arrow_right"]="729",["middle_finger"]="1165",["heavy_division_sign"]="7115",["second_place_medal"]="426",["rowboat"]="1404",["stars"]="5183",["heavy_heart_exclamation_mark_ornament"]="1125",["flag_td"]="8229",["grey_question"]="7125",["cat2"]="214",["flag_ne"]="8175",["x"]="7111",["sparkle"]="7121",["flag_ye"]="8261",["flag_kg"]="8129",["bar_chart"]="6163",["hocho"]="3120",["snowflake"]="5204",["potable_water"]="73",["flag_jp"]="8127",["santa"]="1326",["accept"]="7176",["star_of_david"]="751",["busts_in_silhouette"]="1482",["eyes"]="1194",["wave"]="1150",["heavy_multiplication_x"]="7110",["heavy_check_mark"]="7109",["cocktail"]="3106",["black_nib"]="6146",["full_moon_with_face"]="5178",["pencil2"]="6145",["thermometer"]="5176",["flag_de"]="866",["calendar"]="6157",["flag_gw"]="8105",["flag_ht"]="8111",["writing_hand"]="1180",["v"]="1157",["rocket"]="5129",["point_up"]="1167",["email"]="6132",["door"]="6213",["satellite"]="5128",["scissors"]="6171",["zap"]="5203",["clock5"]="5150",["loudspeaker"]="648",["flag_by"]="844",["church"]="541",["footprints"]="1483",["fuelpump"]="5104",["tent"]="548",["flag_sn"]="8218",["capricorn"]="769",["customs"]="711",["person_with_ball"]="1410",["rice"]="366",["smiley_cat"]="1103",["hotel"]="530",["woman_bouncing_ball"]="1412",["man_heart_man"]="1452",["ice_skate"]="448",["skier"]="1396",["boat"]="5111",["flag_ms"]="8165",["female_fairy"]="1339",["female_cook"]="1271",["snowman"]="5205",["woman_girl_girl"]="1479",["palm_tree"]="2119",["european_post_office"]="527",["ferry"]="5115",["dress"]="613",["flag_dm"]="870",["golf"]="447",["female_supervillain"]="1333",["flag_zm"]="8264",["vibration_mode"]="795",["flag_uz"]="8250",["flag_wf"]="8258",["umbrella_on_ground"]="5202",["ribbon"]="417",["point_left"]="1162",["mouse2"]="243",["mountain"]="59",["shinto_shrine"]="545",["blond_haired_woman"]="1219",["large_purple_circle"]="7189",["orange_heart"]="1128",["flag_scotland"]="8267",["sunrise"]="553",["helmet_with_white_cross"]="639",["man_wearing_turban"]="1317",["pick"]="6183",["anchor"]="5110",["partly_sunny"]="5186",["snowman_without_snow"]="5206",["busstop"]="5100",["flag_na"]="8173",["loud_sound"]="647",["rat"]="244",["file_cabinet"]="6173",["beginner"]="7105",["flag_mc"]="8151",["fleur_de_lis"]="7102",["musical_score"]="653",["desktop_computer"]="678",["kiss"]="1115",["frowning"]="172",["postal_horn"]="650",["coffin"]="6231",["linked_paperclips"]="6168",["man_boy_boy"]="1471",["black_circle"]="7191",["tooth"]="1192",["warning"]="714",["face_with_cowboy_hat"]="158",["clock230"]="5145",["four_leaf_clover"]="2124",["flag_lt"]="8146",["meat_on_bone"]="340",["flag_sc"]="8208",["first_place_medal"]="425",["kissing_closed_eyes"]="120",["alembic"]="6201",["ticket"]="421",["medical_symbol"]="799",["flag_bq"]="838",["hammer"]="6181",["thunder_cloud_and_rain"]="5187",["derelict_house_building"]="522",["waving_black_flag"]="84",["flag_as"]="819",["flag_cg"]="850",["hammer_and_pick"]="6184",["sandal"]="631",["gift_heart"]="1118",["dragon"]="282",["japanese_ogre"]="197",["infinity"]="7100",["champagne"]="3104",["recycle"]="7101",["hearts"]="468",["right_facing_fist"]="1173",["oncoming_police_car"]="582",["chess_pawn"]="471",["flag_ni"]="8178",["pisces"]="771",["tram"]="571",["diamond_shape_with_a_dot_inside"]="7214",["scorpius"]="767",["flag_mk"]="8157",["wheel_of_dharma"]="752",["libra"]="766",["mosque"]="542",["virgo"]="765",["one"]="7135",["shopping_trolley"]="6229",["woman_rowing_boat"]="1406",["vertical_traffic_light"]="5107",["revolving_hearts"]="1122",["sound"]="646",["bowl_with_spoon"]="357",["female_technologist"]="1286",["man_with_bunny_ears_partying"]="1386",["rewind"]="781",["flag_ba"]="825",["crying_cat_face"]="1110",["free"]="7155",["flag_pw"]="8198",["female_sign"]="797",["flag_ac"]="88",["arrow_double_down"]="786",["white_frowning_face"]="166",["heartbeat"]="1121",["small_airplane"]="5119",["peace_symbol"]="757",["star_and_crescent"]="756",["orthodox_cross"]="755",["monkey"]="22",["radioactive_sign"]="725",["mega"]="649",["skull_and_crossbones"]="194",["old_key"]="6180",["flag_es"]="879",["fist"]="1170",["shamrock"]="2123",["black_circle_for_record"]="789",["coffee"]="3101",["file_folder"]="6153",["man_mountain_biking"]="1420",["male_detective"]="1306",["ballot_box_with_check"]="7108",["candy"]="395",["comet"]="5207",["flag_in"]="8118",["cloud"]="5185",["sunny"]="5177",["flag_gq"]="8100",["woman_in_steamy_room"]="1390",["id"]="7157",["cricket_bat_and_ball"]="438",["female_zombie"]="1354",["nerd_face"]="161",["flag_kn"]="8133",["white_medium_small_square"]="7205",["flag_ag"]="812",["page_with_curl"]="6113",["white_medium_square"]="7203",["dumpling"]="377",["copyright"]="7129",["clock330"]="5147",["fried_shrimp"]="373",["arrow_backward"]="780",["flag_bi"]="832",["fish"]="288",["fax"]="674",["drop_of_blood"]="6209",["house"]="523",["woman_wearing_turban"]="1318",["bald_woman"]="1217",["low_brightness"]="792",["seven"]="7141",["flag_ec"]="874",["card_index_dividers"]="6155",["safety_vest"]="65",["flag_ir"]="8121",["timer_clock"]="5138",["mag_right"]="698",["otter"]="255",["flag_mz"]="8172",["stopwatch"]="5137",["takeout_box"]="379",["alarm_clock"]="5136",["ocean"]="5210",["black_right_pointing_triangle_with_double_vertical_bar"]="779",["cl"]="7153",["black_left_pointing_double_triangle_with_vertical_bar"]="782",["relaxed"]="119",["fast_forward"]="777",["registered"]="7130",["woman_in_manual_wheelchair"]="1378",["eject"]="790",["keyboard"]="680",["flag_cv"]="861",["aerial_tramway"]="5127",["ballet_shoes"]="632",["male_scientist"]="1282",["smoking"]="6230",["woman_walking"]="1363",["leftwards_arrow_with_hook"]="737",["badger"]="258",["swimmer"]="1407",["hourglass_flowing_sand"]="5134",["underage"]="724",["woman_juggling"]="1436",["flamingo"]="273",["one_piece_swimsuit"]="616",["left_right_arrow"]="736",["information_source"]="7156",["woman_in_lotus_position"]="1439",["clock1130"]="5163",["fallen_leaf"]="2126",["woman_biking"]="1418",["horse_racing"]="1395",["interrobang"]="7123",["hushed"]="168",["man_in_motorized_wheelchair"]="1374",["mrs_claus"]="1327",["closed_umbrella"]="5199",["lower_left_ballpoint_pen"]="6148",["razor"]="6220",["ringed_planet"]="5180",["woman_heart_man"]="1451",["parachute"]="5122",["raised_hand_with_fingers_splayed"]="1152",["kite"]="457",["male_police_officer"]="1303",["star"]="5181",["trident"]="7103",["mute"]="644",["balloon"]="47",["relieved"]="142",["flag_cf"]="849",["kaaba"]="546",["flag_gi"]="895",["flag_fk"]="884",["earth_asia"]="53",["ambulance"]="579",["date"]="6156",["flag_sy"]="8225",["clock4"]="5148",["partying_face"]="159",["speak_no_evil"]="1114",["adhesive_bandage"]="6211",["blond_haired_man"]="1220",["rugby_football"]="434",["notebook_with_decorative_cover"]="6104",["flag_az"]="824",["white_small_square"]="7207",["shorts"]="618",["flag_to"]="8238",["flag_bg"]="830",["arrow_up_down"]="735",["open_file_folder"]="6154",["flag_np"]="8181",["police_car"]="581",["watch"]="5135",["guide_dog"]="27",["sponge"]="6227",["flag_mr"]="8164",["soap"]="6226",["roll_of_paper"]="6225",["basket"]="6224",["tongue"]="1196",["teddy_bear"]="466",["penguin"]="267",["male_cook"]="1270",["e_mail"]="6133",["spaghetti"]="369",["flag_st"]="8222",["eight"]="7142",["thread"]="478",["sa"]="7168",["flag_cn"]="856",["clock12"]="5140",["face_with_hand_over_mouth"]="129",["vampire"]="1340",["service_dog"]="28",["bed"]="6214",["clapper"]="691",["female_superhero"]="1330",["flag_um"]="8246",["bricks"]="520",["link"]="6197",["snowboarder"]="1397",["flag_pg"]="8189",["crown"]="634",["laughing"]="15",["new_moon_with_face"]="5173",["toolbox"]="6199",["diving_mask"]="450",["fire_extinguisher"]="6228",["compass"]="57",["large_purple_square"]="7198",["baby"]="1198",["test_tube"]="6202",["woozy_face"]="155",["red_envelope"]="416",["socks"]="612",["coat"]="611",["flag_gf"]="892",["flag_us"]="8248",["aquarius"]="770",["brain"]="1191",["fried_egg"]="354",["male_zombie"]="1353",["genie"]="1349",["adult"]="1202",["flag_ie"]="8115",["female_genie"]="1351",["hibiscus"]="2112",["joy_cat"]="1105",["male_elf"]="1347",["female_elf"]="1348",["merperson"]="1343",["merman"]="1344",["mermaid"]="1345",["butterfly"]="295",["lotion_bottle"]="6221",["flag_cw"]="862",["person_with_pouting_face"]="1227",["national_park"]="516",["shushing_face"]="130",["male_fairy"]="1338",["mage"]="1334",["fishing_pole_and_fish"]="449",["female_mage"]="1336",["flag_ar"]="818",["pineapple"]="37",["safety_pin"]="6222",["tm"]="7131",["juggling"]="1434",["traffic_light"]="5106",["male_factory_worker"]="1276",["clock7"]="5154",["avocado"]="318",["video_game"]="461",["flag_tg"]="8231",["control_knobs"]="658",["eye"]="1195",["family"]="1454",["t_rex"]="284",["person_with_headscarf"]="1320",["rhinoceros"]="240",["bow_and_arrow"]="6189",["eggplant"]="319",["older_adult"]="1221",["male_genie"]="1350",["bikini"]="619",["flag_im"]="8117",["face_with_monocle"]="162",["icecream"]="385",["deaf_man"]="1243",["flag_mu"]="8167",["deaf_woman"]="1244",["man_swimming"]="1408",["kneeling_person"]="1367",["man_kneeling"]="1368",["flag_sa"]="8206",["clock9"]="5158",["mortar_board"]="637",["ship"]="5117",["standing_person"]="1364",["crossed_flags"]="83",["ice_cube"]="3115",["red_haired_man"]="1206",["pancakes"]="337",["mate_drink"]="3114",["black_joker"]="472",["woman_swimming"]="1409",["croissant"]="333",["bouquet"]="2106",["butter"]="360",["speech_balloon"]="1144",["factory"]="535",["man_with_turban"]="1316",["grimacing"]="140",["place_of_worship"]="748",["salt"]="361",["flag_er"]="878",["basketball"]="431",["cupcake"]="392",["parrot"]="275",["sushi"]="372",["globe_with_meridians"]="54",["monorail"]="572",["motorized_wheelchair"]="595",["ear_with_hearing_aid"]="1189",["arrow_lower_left"]="732",["fountain"]="547",["superhero"]="1328",["flag_ky"]="8137",["flag_me"]="8153",["performing_arts"]="475",["flag_fr"]="887",["magnet"]="6200",["white_circle"]="7192",["foot"]="1187",["falafel"]="352",["city_sunrise"]="555",["smirk_cat"]="1107",["banjo"]="667",["hospital"]="528",["watermelon"]="33",["receipt"]="6128",["water_buffalo"]="226",["sweet_potato"]="370",["hash"]="7132",["oyster"]="384",["flag_bh"]="831",["hotdog"]="347",["arrow_upper_left"]="734",["orangutan"]="24",["swan"]="271",["microbe"]="2105",["ice_hockey_stick_and_puck"]="440",["tada"]="48",["woman_woman_boy"]="1465",["briefs"]="617",["gem"]="643",["raccoon"]="212",["flag_au"]="821",["train"]="574",["flag_wales"]="8268",["cheese_wedge"]="339",["man_pouting"]="1228",["hippopotamus"]="241",["flag_vc"]="8252",["peacock"]="274",["cricket"]="2100",["man"]="1204",["man_in_steamy_room"]="1389",["boar"]="230",["flag_mm"]="8159",["sauropod"]="283",["reminder_ribbon"]="419",["hedgehog"]="249",["telescope"]="6206",["zebra_face"]="222",["woman_golfing"]="1400",["giraffe_face"]="238",["squid"]="383",["shrimp"]="382",["tiger"]="216",["izakaya_lantern"]="6102",["flag_zw"]="8265",["bearded_person"]="1205",["evergreen_tree"]="2117",["gun"]="6188",["gorilla"]="23",["potato"]="320",["deer"]="223",["fox_face"]="211",["barely_sunny"]="5189",["man_surfing"]="1402",["nut_and_bolt"]="6192",["mountain_railway"]="573",["owl"]="272",["shark"]="291",["bat"]="250",["flag_ae"]="810",["eagle"]="269",["pound"]="6125",["leopard"]="218",["boot"]="633",["first_quarter_moon_with_face"]="5174",["desert_island"]="515",["sled"]="453",["turkey"]="260",["repeat"]="774",["scorpion"]="2103",["mailbox_closed"]="6140",["person_climbing"]="1391",["flag_eu"]="881",["womans_flat_shoe"]="629",["fireworks"]="43",["hole"]="1142",["tumbler_glass"]="3111",["hiking_boot"]="628",["ram"]="232",["flag_gh"]="894",["flag_fj"]="883",["female_teacher"]="1262",["large_orange_square"]="7194",["goggles"]="63",["flag_sx"]="8224",["sports_medal"]="424",["flag_tf"]="8230",["sake"]="3103",["lab_coat"]="64",["cupid"]="1117",["left_facing_fist"]="1172",["water_polo"]="1428",["pleading_face"]="171",["moneybag"]="6121",["cold_face"]="154",["hot_face"]="153",["fortune_cookie"]="378",["dove_of_peace"]="268",["firecracker"]="45",["radio_button"]="7215",["flag_am"]="815",["three_button_mouse"]="681",["chopsticks"]="3116",["notebook"]="6111",["smiling_face_with_3_hearts"]="114",["trophy"]="423",["pretzel"]="335",["vhs"]="696",["moon_cake"]="375",["woman_lifting_weights"]="1415",["bowling"]="437",["flag_ee"]="875",["ab"]="7151",["canned_food"]="362",["flag_it"]="8123",["four"]="7138",["sandwich"]="348",["ear"]="1188",["woman_pouting"]="1229",["rosette"]="2109",["hankey"]="195",["flag_do"]="871",["euro"]="6124",["bagel"]="336",["pie"]="393",["lobster"]="381",["cup_with_straw"]="3112",["flag_tn"]="8237",["gemini"]="762",["yawning_face"]="186",["peanuts"]="330",["heart_eyes"]="115",["luggage"]="5132",["egg"]="353",["male_doctor"]="1255",["8ball"]="458",["stuffed_flatbread"]="351",["female_guard"]="1310",["green_salad"]="358",["baguette_bread"]="334",["carrot"]="321",["dango"]="376",["bacon"]="343",["kimono"]="614",["round_pushpin"]="6166",["tulip"]="2115",["cucumber"]="324",["knife_fork_plate"]="3117",["woman_climbing"]="1393",["sparkles"]="46",["bathtub"]="6219",["camera_with_flash"]="694",["flag_th"]="8232",["flag_id"]="8114",["medal"]="422",["third_place_medal"]="427",["bear"]="251",["flag_ki"]="8131",["chocolate_bar"]="394",["ok"]="7162",["birthday"]="390",["heavy_plus_sign"]="7113",["rose"]="2110",["clinking_glasses"]="3110",["hear_no_evil"]="1113",["man_playing_handball"]="1432",["chicken"]="261",["flag_fm"]="885",["crocodile"]="277",["sari"]="615",["feet"]="259",["doughnut"]="388",["woman_wrestling"]="1427",["oncoming_taxi"]="584",["fencer"]="1394",["man_juggling"]="1435",["arrow_lower_right"]="730",["fork_and_knife"]="3118",["flag_nc"]="8174",["clock6"]="5152",["classical_building"]="518",["person_doing_cartwheel"]="1422",["cityscape"]="551",["man_cartwheeling"]="1423",["woman_cartwheeling"]="1424",["night_with_stars"]="550",["shrug"]="1251",["man_shrugging"]="1252",["woman_shrugging"]="1253",["man_in_tuxedo"]="1321",["male_teacher"]="1261",["handshake"]="1178",["no_pedestrians"]="722",["man_gesturing_ok"]="1234",["flag_il"]="8116",["red_circle"]="7184",["prince"]="1314",["office"]="525",["flag_mt"]="8166",["flag_lv"]="8148",["selfie"]="1182",["flag_tv"]="8241",["breast_feeding"]="1324",["i_love_you_hand_sign"]="1159",["male_artist"]="1291",["exploding_head"]="157",["violin"]="666",["flag_bs"]="840",["flag_dg"]="867",["runner"]="1379",["arrow_down_small"]="785",["face_vomiting"]="151",["oncoming_bus"]="576",["joy"]="18",["strawberry"]="314",["face_with_symbols_on_mouth"]="190",["u7a7a"]="7179",["zany_face"]="125",["stew"]="356",["the_horns"]="1160",["man_facepalming"]="1249",["woman_facepalming"]="1250",["lying_face"]="141",["stuck_out_tongue_winking_eye"]="124",["briefcase"]="6152",["compression"]="6194",["rolling_on_the_floor_laughing"]="17",["nauseated_face"]="150",["atom_symbol"]="749",["flag_ca"]="846",["older_woman"]="1223",["pregnant_woman"]="1323",["school"]="533",["cactus"]="2120",["triangular_ruler"]="6170",["studio_microphone"]="656",["clock8"]="5156",["flag_md"]="8152",["crossed_fingers"]="1158",["clubs"]="470",["slot_machine"]="463",["call_me_hand"]="1161",["lock"]="6175",["face_with_raised_eyebrow"]="133",["bangbang"]="7122",["muscle"]="1183",["man_rowing_boat"]="1405",["zipper_mouth_face"]="132",["brown_heart"]="1133",["pinching_hand"]="1156",["white_heart"]="1135",["flag_sh"]="8212",["large_brown_square"]="7199",["large_green_square"]="7196",["large_yellow_square"]="7195",["microphone"]="659",["camel"]="236",["soon"]="746",["blush"]="112",["large_red_square"]="7193",["large_brown_circle"]="7190",["chains"]="6198",["lips"]="1197",["large_green_circle"]="7187",["scroll"]="6114",["cherries"]="313",["flag_at"]="820",["auto_rickshaw"]="596",["skateboard"]="599",["christmas_tree"]="42",["sleepy"]="144",["canoe"]="5112",["pig2"]="229",["flag_xk"]="8260",["motor_scooter"]="593",["flag_ru"]="8204",["scooter"]="598",["flag_ci"]="852",["flag_ml"]="8158",["envelope_with_arrow"]="6135",["keycap_ten"]="7144",["non_potable_water"]="721",["white_check_mark"]="7107",["airplane_departure"]="5120",["cop"]="1302",["yin_yang"]="753",["waning_gibbous_moon"]="5169",["pig_nose"]="231",["keycap_star"]="7133",["man_frowning"]="1225",["man_golfing"]="1399",["motorway"]="5101",["oil_drum"]="5103",["hammer_and_wrench"]="6185",["name_badge"]="7104",["hindu_temple"]="543",["cold_sweat"]="175",["flag_ga"]="888",["no_mouth"]="136",["necktie"]="66",["left_speech_bubble"]="1146",["clock730"]="5155",["baggage_claim"]="712",["walking"]="1361",["passport_control"]="710",["flag_ad"]="89",["fairy"]="1337",["ferris_wheel"]="559",["toilet"]="6217",["baby_symbol"]="78",["oncoming_automobile"]="586",["mens"]="75",["mountain_bicyclist"]="1419",["flag_py"]="8199",["flag_re"]="8201",["umbrella_with_rain_drops"]="5201",["flag_kp"]="8134",["man_man_boy"]="1460",["flag_et"]="880",["card_index"]="6160",["man_biking"]="1417",["flag_ma"]="8150",["passenger_ship"]="5114",["football"]="433",["eight_pointed_black_star"]="7120",["monkey_face"]="21",["do_not_litter"]="720",["flag_vu"]="8257",["dvd"]="686",["clock1230"]="5141",["lion_face"]="215",["airplane"]="5118",["no_good"]="1230",["rotating_light"]="5105",["put_litter_in_its_place"]="72",["tropical_drink"]="3107",["speedboat"]="5113",["face_with_thermometer"]="148",["cancer"]="763",["woman_kneeling"]="1369",["hourglass"]="5133",["mountain_cableway"]="5126",["flag_rw"]="8205",["shaved_ice"]="386",["mechanical_arm"]="1184",["articulated_lorry"]="589",["flag_al"]="814",["a"]="7150",["1234"]="7147",["blue_car"]="587",["green_apple"]="310",["key"]="6179",["womens"]="76",["couple_with_heart"]="1450",["female_scientist"]="1283",["older_man"]="1222",["flag_cx"]="863",["crystal_ball"]="459",["spades"]="467",["fire_engine"]="580",["minibus"]="578",["trolleybus"]="577",["table_tennis_paddle_and_ball"]="442",["grin"]="14",["train2"]="567",["light_rail"]="569",["flag_ve"]="8253",["bullettrain_front"]="566",["dart"]="455",["love_hotel"]="531",["baby_chick"]="264",["bullettrain_side"]="565",["railway_car"]="564",["flag_bz"]="845",["steam_locomotive"]="563",["hand"]="1153",["female_vampire"]="1342",["leg"]="1186",["skull"]="193",["motor_boat"]="5116",["raised_hands"]="1175",["white_haired_woman"]="1215",["raising_hand"]="1239",["woman_raising_hand"]="1241",["post_office"]="526",["flag_nr"]="8182",["wilted_flower"]="2111",["bow"]="1245",["man_bowing"]="1246",["woman_bowing"]="1247",["woman_gesturing_ok"]="1235",["triangular_flag_on_post"]="82",["black_square_button"]="7217",["woman_gesturing_no"]="1232",["face_with_rolling_eyes"]="139",["u7981"]="7175",["slightly_smiling_face"]="19",["slightly_frowning_face"]="165",["u6708"]="7169",["pouting_cat"]="1111",["point_down"]="1166",["kissing_cat"]="1108",["heart_eyes_cat"]="1106",["bee"]="298",["man_bouncing_ball"]="1411",["woman_woman_girl_girl"]="1469",["prayer_beads"]="640",["couch_and_lamp"]="6215",["chestnut"]="331",["male_technologist"]="1285",["scream"]="179",["bellhop_bell"]="5131",["face_with_head_bandage"]="149",["open_mouth"]="167",["sob"]="178",["poultry_leg"]="341",["flag_ea"]="873",["green_heart"]="1130",["flying_saucer"]="5130",["level_slider"]="657",["thumbsup"]="1168",["triumph"]="187",["bridge_at_night"]="556",["broken_heart"]="1126",["cry"]="177",["rage"]="188",["beer"]="3108",["amphora"]="3121",["disappointed"]="182",["stuck_out_tongue_closed_eyes"]="126",["stuck_out_tongue"]="123",["rabbit"]="246",["flag_pa"]="8186",["kissing_smiling_eyes"]="121",["flag_je"]="8124",["kissing_heart"]="117",["flag_cp"]="858",["kissing"]="118",["mans_shoe"]="626",["confounded"]="180",["pensive"]="143",["sweat"]="183",["neutral_face"]="134",["large_blue_diamond"]="7209",["memo"]="6151",["sunglasses"]="160",["house_with_garden"]="524",["wink"]="111",["flag_io"]="8119",["smiling_imp"]="191",["flag_ss"]="8221",["european_castle"]="537",["flag_mw"]="8169",["flag_br"]="839",["woman_getting_haircut"]="1360",["smile"]="13",["flag_co"]="857",["red_haired_woman"]="1211",["tokyo_tower"]="539",["mount_fuji"]="511",["tired_face"]="185",["dagger_knife"]="6186",["drooling_face"]="145",["male_student"]="1258",["wastebasket"]="6174",["pear"]="311",["u6709"]="7170",["flag_ug"]="8245",["moon"]="5167",["soccer"]="428",["card_file_box"]="6172",["new"]="7159",["deciduous_tree"]="2118",["blossom"]="2114",["frame_with_picture"]="476",["u55b6"]="7182",["tomato"]="316",["flag_mh"]="8156",["back"]="743",["flag_nu"]="8183",["flag_jm"]="8125",["clock930"]="5159",["bento"]="363",["cake"]="391",["flag_ta"]="8227",["zombie"]="1352",["curling_stone"]="454",["flag_tc"]="8228",["synagogue"]="544",["b"]="7152",["banana"]="36",["suspension_railway"]="5125",["flag_bb"]="826",["flag_si"]="8213",["negative_squared_cross_mark"]="7112",["black_square_for_stop"]="788",["inbox_tray"]="6137",["flag_kz"]="8138",["spock_hand"]="1154",["hamburger"]="344",["pager"]="673",["flag_pf"]="8188",["abc"]="7149",["taxi"]="583",["flag_cc"]="847",["leo"]="764",["tornado"]="5194",["dash"]="1141",["sun_with_face"]="5179",["goal_net"]="446",["yen"]="6122",["peach"]="312",["flag_be"]="828",["golfer"]="1398",["syringe"]="6208",["waving_white_flag"]="85",["cyclone"]="5197",["flag_ly"]="8149",["honey_pot"]="398",["grapes"]="31",["flag_aw"]="822",["flashlight"]="6101",["rainbow_flag"]="86",["flag_ch"]="851",["twisted_rightwards_arrows"]="773",["corn"]="322",["thinking_face"]="131",["flag_sd"]="8209",["two"]="7136",["black_small_square"]="7206",["man_in_lotus_position"]="1438",["flag_ke"]="8128",["flag_mo"]="8161",["flag_fi"]="882",["lacrosse"]="441",["roller_coaster"]="560",["mechanical_leg"]="1185",["flag_sk"]="8215",["flag_ax"]="823",["scream_cat"]="1109",["flag_bj"]="833",["smiley"]="12",["umbrella"]="5200",["pirate_flag"]="87",["truck"]="588",["flag_mg"]="8155",["gloves"]="610",["woman_woman_girl_boy"]="1467",["rain_cloud"]="5191",["flag_hn"]="8109",["arrow_up_small"]="783",["flag_tl"]="8235",["wind_blowing_face"]="5196",["flag_tw"]="8242",["bug"]="296",["woman_girl"]="1477",["mailbox"]="6139",["female_farmer"]="1268",["100"]="1136",["woman_tipping_hand"]="1238",["couple"]="1444",["angry"]="189",["female_student"]="1259",["bomb"]="1143",["bike"]="597",["snake"]="280",["bone"]="1193",["man_with_probing_cane"]="1371",["flag_gy"]="8106",["book"]="6106",["black_medium_square"]="7202",["gear"]="6193",["flag_li"]="8142",["floppy_disk"]="684",["crescent_moon"]="5172",["mostly_sunny"]="5188",["dizzy_face"]="156",["clock1"]="5142",["diya_lamp"]="6103",["new_moon"]="5164",["top"]="747",["ski"]="452",["dragon_face"]="281",["cow"]="224",["coconut"]="317",["person_frowning"]="1224",["tv"]="692",["flag_ic"]="8113",["waning_crescent_moon"]="5171",["shower"]="6218",["woman_standing"]="1366",["game_die"]="464",["flag_va"]="8251",["flag_dz"]="872",["poodle"]="29",["bird"]="266",["zero"]="7134",["male_mage"]="1335",["foggy"]="549",["flag_ws"]="8259",["flag_ao"]="816",["building_construction"]="519",["dog2"]="26",["flag_rs"]="8203",["anger"]="1137",["cherry_blossom"]="2107",["space_invader"]="1101",["man_man_boy_boy"]="1463",["mahjong"]="473",["flag_nz"]="8184",["herb"]="2122",["tangerine"]="34",["white_square_button"]="7216",["u6e80"]="7183",["school_satchel"]="625",["black_medium_small_square"]="7204",["flag_sz"]="8226",["atm"]="71",["flag_gu"]="8104",["zzz"]="1149",["flag_lr"]="8144",["love_letter"]="1116",["popcorn"]="359",["page_facing_up"]="6115",["flag_pn"]="8194",["ideograph_advantage"]="7172",["man_girl_girl"]="1474",["flag_bm"]="835",["apple"]="39",["male_guard"]="1309",["convenience_store"]="532",["boy"]="1200",["flag_england"]="8266",["department_store"]="534",["cut_of_meat"]="342",["badminton_racquet_and_shuttlecock"]="443",["flag_la"]="8139",["flower_playing_cards"]="474",["rabbit2"]="247",["pill"]="6210",["black_heart"]="1134",["whale2"]="286",["snail"]="294",["racehorse"]="220",["woman_playing_handball"]="1433",["glass_of_milk"]="3100",["woman_boy_boy"]="1476",["octopus"]="292",["arrow_left"]="733",["nail_care"]="1181",["persevere"]="181",["notes"]="655",["woman_woman_boy_boy"]="1468",["flag_dj"]="868",["beetle"]="299",["tropical_fish"]="289",["outbox_tray"]="6136",["seedling"]="2116",["flag_un"]="8247",["dolphin"]="287",["mouse"]="242",["bookmark"]="6119",["bread"]="332",["sos"]="7164",["male_vampire"]="1341",["six_pointed_star"]="759",["cat"]="213",["wolf"]="210",["books"]="6110",["latin_cross"]="754",["nose"]="1190",["end"]="744",["flag_gr"]="8101",["female_firefighter"]="1301",["point_up_2"]="1164",["point_right"]="1163",["innocent"]="113",["sheep"]="233",["upside_down_face"]="110",["open_hands"]="1176",["clap"]="1174",["ghost"]="199",["people_holding_hands"]="1442",["star_struck"]="116",["female_mechanic"]="1274",["unicorn_face"]="221",["lipstick"]="641",["japanese_castle"]="536",["arrows_counterclockwise"]="742",["bookmark_tabs"]="6118",["bicyclist"]="1416",["man_woman_girl_boy"]="1457",["sleeping"]="146",["shallow_pan_of_food"]="355",["arrow_right_hook"]="738",["woman_girl_boy"]="1478",["flag_sr"]="8220",["man_tipping_hand"]="1237",["flag_gm"]="897",["information_desk_person"]="1236",["flag_hm"]="8108",["female_singer"]="1289",["vs"]="7166",["woman_playing_water_polo"]="1430",["flag_vn"]="8256",["mag"]="697",["closed_book"]="6105",["woman_woman_girl"]="1466",["curly_haired_woman"]="1213",["flag_kh"]="8130",["japanese_goblin"]="198",["incoming_envelope"]="6134",["mailbox_with_mail"]="6141",["musical_keyboard"]="664",["hatching_chick"]="263",["taurus"]="761",["female_judge"]="1265",["minidisc"]="683",["handbag"]="622",["man_with_gua_pi_mao"]="1319",["dna"]="6204",["u6307"]="7171",["woman_in_motorized_wheelchair"]="1375",["mosquito"]="2104",["alien"]="1100",["u5272"]="7173",["flag_ph"]="8190",["eight_spoked_asterisk"]="7119",["male_mechanic"]="1273",["rice_ball"]="365",["flag_mv"]="8168",["scales"]="6195",["dancer"]="1382",["city_sunset"]="554",["two_men_holding_hands"]="1445",["flag_sb"]="8207",["ring"]="642",["haircut"]="1358",["flag_cy"]="864",["flag_eg"]="876",["woman_with_bunny_ears_partying"]="1387",["horse"]="219",["flag_pe"]="8187",["flag_gs"]="8102",["woman_surfing"]="1403",["right_anger_bubble"]="1147",["sweat_drops"]="1140",["partly_sunny_rain"]="5190",["battery"]="675",["waffle"]="338",["dollar"]="6123",["saxophone"]="662",["guardsman"]="1308",["seat"]="5123",["bank"]="529",["man_getting_haircut"]="1359",["man_in_manual_wheelchair"]="1377",["large_orange_diamond"]="7208",["male_office_worker"]="1279",["man_climbing"]="1392",["confetti_ball"]="49",["girl"]="1201",["flag_fo"]="886",["leafy_green"]="325",["woman_boy"]="1475",["telephone_receiver"]="672",["cd"]="685",["satellite_antenna"]="6207",["turtle"]="278",["flag_mf"]="8154",["female_factory_worker"]="1277",["racing_car"]="591",["funeral_urn"]="6232",["mobile_phone_off"]="796",["mango"]="38",["volleyball"]="432",["billed_cap"]="638",["man_man_girl_boy"]="1462",["blowfish"]="290",["palms_up_together"]="1177",["heart"]="1127",["flag_gp"]="899",["dizzy"]="1139",["flag_sj"]="8214",["electric_plug"]="676",["man_lifting_weights"]="1414",["yarn"]="479",["station"]="570",["construction_worker"]="1311",["droplet"]="5209",["capital_abcd"]="7145",["curly_haired_man"]="1207",["flag_vg"]="8254",["flag_bt"]="841",["checkered_flag"]="81",["heavy_dollar_sign"]="6131",["flag_gl"]="896",["small_blue_diamond"]="7211",["signal_strength"]="794",["dog"]="25",["worried"]="164",}
--PATH addons/[chat] scb-29/lua/scb/sh_chatbox.lua:
if SCB_LOADED then return end

local scb = scb

local PLAYER = FindMetaTable("Player")
function PLAYER:IsTyping()
	return self:GetNWBool("SCB.IsTyping", false)
end

function PLAYER:SCB_GetTag()
	local tags = scb.tags
	return tags[self:SteamID()] or tags[self:SteamID64()] or tags[self:GetUserGroup()] or false
end

local permissions = scb.config.permissions
function scb.has_permission(ply, permission)
	if not IsValid(ply) then return true end

	permission = permissions[permission]
	return permission[1] or permission[ply:GetUserGroup()] or permission[ply:SteamID()] or permission[ply:SteamID64()]
end
--PATH addons/[chat] scb-29/lua/scb/cl_chatbox.lua:
if SCB_LOADED then return end

local draw = draw
local surface = surface
local math = math
local hook = hook
local gui = gui
local net = net

local IsValid = IsValid
local ipairs = ipairs

local color_white = color_white

local scb = scb
local sui = sui
local SUI = scb.SUI
local utf8 = sui.utf8
local language = scb.language
local UnPredictedCurTime = UnPredictedCurTime

for k, v in ipairs({18, 16, 14}) do
	_G["SCB_" .. v] = SUI.CreateFont(tostring(v), "Roboto", v)
end

scb.pattern = "%{ *([%w_%#%$@%*!]+)([^%{}]-) *%}"

local SetVisible = FindMetaTable("Panel").SetVisible

function scb.open_parsers_menu()
	if IsValid(scb.parsers_menu) then
		return scb.parsers_menu:Remove()
	end

	local text_entry = scb.chatbox.text_entry

	local parsers_menu = vgui.Create("SCB.Frame")
	scb.parsers_menu = parsers_menu

	parsers_menu:Center()
	parsers_menu:MakePopup()
	parsers_menu:SetTitle("SCB | Chat Parsers")
	parsers_menu:AddAnimations(320, 340)

	local parsers_list = parsers_menu:Add("SCB.ScrollPanel")
	parsers_list:Dock(FILL)
	parsers_list:DockMargin(4, 4, 4, 4)
	parsers_list:InvalidateParent(true)
	parsers_list:InvalidateLayout(true)

	for k, v in ipairs(scb.chat_parsers) do
		local parser = parsers_list:Add("DButton")
		parser:Dock(TOP)
		parser:DockMargin(2, 2, 2, 2)
		parser:DockPadding(2, 2, 2, 2)
		parser:InvalidateParent(true)
		parser:SetText("")

		parser:SUI_TDLib()
		parser:ClearPaint()
		parser:Background(SUI.GetColor("on_sheet"), 3)
		parser:FadeHover(SUI.GetColor("on_sheet_hover"), _, 3)

		function parser:DoClick()
			parsers_menu:Remove()
			scb.chatbox:MoveToFront()
			text_entry:RequestFocus()
			text_entry:AddValue(v[3] .. " ")
		end

		local title = parser:Add("SCB.Label")
		title:Dock(TOP)
		title:SetAutoStretchVertical(true)
		title:SetWrap(true)
		title:SetFont(SCB_16)
		title:SetText(v[1])
		title:InvalidateParent(true)

		local example = parser:Add("SCB.ChatLine")
		example:Dock(TOP)
		example:DockMargin(0, 1, 0, 0)
		example:InvalidateParent(true)
		example:InvalidateLayout(true)
		example:Parse(v[2])
		example:SetMouseInputEnabled(false)

		function parser:PerformLayout()
			self:SizeToChildren(false, true)
		end
	end
end

local function invalidate_children(self, recursive)
	local children = self:GetChildren()
	for i = 1, #children do
		if recursive then
			invalidate_children(children[i])
		else
			children[i]:InvalidateLayout(true)
		end
	end

	self:InvalidateLayout(true)
end

function scb.create_chatbox()
	if IsValid(scb.chatbox) then return end

	sui.TDLib.Start()

	local frame = vgui.Create("SCB.Frame", nil, "SCB")
	scb.chatbox = frame

	local c_x = CreateClientConVar("scb_x", sui.scale(18), true, false, "")
	local c_y = CreateClientConVar("scb_y", ScrH() - SUI.Scale(220) - sui.scale(170), true, false, "")
	local c_w = CreateClientConVar("scb_w", 480, true, false, "")
	local c_h = CreateClientConVar("scb_h", 220, true, false, "")

	frame.SetSize = frame.RealSetSize
	-- remove scaling for chatbox
	SUI.RemoveScaleHook(frame)

	frame:SetSizable(true)
	frame:SetMinWidth(SUI.Scale(300))
	frame:SetMinHeight(SUI.Scale(160))
	frame:SetSize(c_w:GetInt(), c_h:GetInt())
	frame:SetPos(c_x:GetInt(), c_y:GetInt())
	frame:ParentToHUD()
	frame:MakePopup()

	frame.title.background_color = true

	local chatbox_title = scb.config.chatbox_title
	frame:SetTitle(chatbox_title)
	if chatbox_title:find("SERVER_NAME") or chatbox_title:find("PLAYER_COUNT") then
		local delay = 2
		local next_run = UnPredictedCurTime()

		frame:On("Think", function(s)
			if UnPredictedCurTime() < next_run then return end
			next_run = UnPredictedCurTime() + delay
			s:SetTitle(chatbox_title:gsub("SERVER_NAME", GetHostName()):gsub("PLAYER_COUNT", player.GetCount()))
		end)
	end

	function frame:OnPosChanged()
		c_x:SetInt(self.x)
		c_y:SetInt(self.y)
	end

	function frame:OnSizeChanged(w, h)
		c_w:SetInt(w)
		c_h:SetInt(h)
	end

	function frame:AddPanelToHide(panel)
		if not self.panels_to_hide then
			self.panels_to_hide = {self}
		end
		table.insert(self.panels_to_hide, panel)
	end

	function frame:SetVisible(visible)
		self.hidden = not visible
		local panels_to_hide = self.panels_to_hide
		for i = 1, #panels_to_hide do
			local v = panels_to_hide[i]
			v.Paint, v.oldPaint = visible and (v.oldPaint or v.Paint) or nil, not visible and v.Paint or nil
			if v.background_color or v.old_bg_color then
				v.background_color, v.old_bg_color = visible and (v.old_bg_color or v.background_color) or nil, not visible and v.background_color or nil
				v:SetBGColor(v.background_color)
			end
		end
		return self.hidden
	end

	function frame:IsVisible()
		return not self.hidden
	end

	frame.close.DoClick = chat.Close

	local scroll_panel = frame:Add("SCB.ScrollPanel")
	scroll_panel:Dock(FILL)
	scroll_panel:DockMargin(4, 4, 4, 0)
	scroll_panel:SetFromBottom(true)

	function scroll_panel:ScrollToBottom()
		self:GetParent():InvalidateLayout(true)
		invalidate_children(self)

		local vbar = self.VBar
		vbar:SetScroll(vbar.CanvasSize)
	end

	local canvas = scroll_panel:GetCanvas()
	canvas:DockPadding(2, 2, 2, 2)

	function scroll_panel:ShouldScrollDown()
		local vbar = self.VBar
		local canvas_size = vbar.CanvasSize
		return frame.hidden or canvas_size == 1 or canvas_size <= vbar.scroll_target
	end

	local count = 0
	local max_messages_convar = GetConVar("scb_max_messages")
	local fixed_width = false
	function scroll_panel:ChildAdded()
		local vbar = self.VBar
		if vbar.Enabled then
			if not fixed_width then
				for k, v in ipairs(canvas.children) do
					if v.ScaleChanged then
						v:ScaleChanged()
					end
				end
				fixed_width = true
				return self:ChildAdded()
			end
		else
			fixed_width = nil
		end

		count = count + 1

		local max = max_messages_convar:GetInt()
		if count <= max then return end

		local down = self:ShouldScrollDown()

		local full_h = 0
		local children = canvas.children
		for i = count, max + 1, -1 do
			local child = children[i - max]
			if not child.being_removed then
				child.being_removed = true
				full_h = full_h + child:GetTotalH()
				child:Remove()

				count = count - 1
			end
		end

		local scroll = vbar.Scroll
		if down then
			vbar.Scroll = scroll - full_h
		else
			vbar.Scroll = scroll - full_h
			vbar.scroll_target = scroll
		end
	end

	frame:InvalidateLayout(true)
	invalidate_children(frame, true)

	local preview = vgui.Create("Panel")
	preview:SetMouseInputEnabled(false)
	preview:ParentToHUD()

	local preview_bg = vgui.Create("Panel")
	preview_bg:ParentToHUD()
	preview_bg:MoveToBack()
	SetVisible(preview_bg, false)

	preview_bg:Blur()
		:Background(Color(50, 50, 50, 200))

	frame:On("PerformLayout", function(s, w, h)
		local f_x, f_y = s:GetPos()
		local new_x, new_y = f_x + ((w / 2) - ((preview.w or 0) / 2)), f_y + h + 4
		preview:SetPos(new_x, new_y)
		preview_bg:SetPos(new_x - 4, new_y - 4)
	end)

	local text_entry = frame:Add("SCB.TextEntry")
	text_entry:Dock(BOTTOM)
	text_entry:DockMargin(4, 4, 4, 4)
	text_entry:SetTall(24)
	text_entry:SetPlaceholder(language.type_something)
	text_entry:SetFont(SCB_18)
	text_entry:SetMultiline(true)
	text_entry:SetVerticalScrollbarEnabled(false)
	text_entry:InvalidateParent(true)
	text_entry:SetMaxChars(126)
	text_entry:SetNoBar(true)
	text_entry.no_scale = true

	if scb.config.hide_language_sign then
		text_entry:SetDrawLanguageID(false)
	end

	function text_entry:OnEnter()
		local txt = self:GetValue()
		if txt == "" then chat.Close() return end
		local length = #txt
		net.Start(frame.bteam ~= 1 and "SCB.SendMessageTeam" or "SCB.SendMessage")
			net.WriteUInt(length, 8)
			net.WriteData(txt, length)
		net.SendToServer()
		self:AddHistory(txt)
		chat.Close()
	end

	local old_Paint = text_entry.Paint
	function text_entry:Paint(w, h)
		local outline = SUI.GetColor("scroll_panel_outline")
		if outline then
			sui.TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
		else
			draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
		end

		old_Paint(self, w, h)
	end

	function text_entry:OnValueChange(value)
		local down = scroll_panel:ShouldScrollDown()

		-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L3790
		self:SetTall(self:GetNumLines() * (SUI.Scale(18) --[[font size]] + 1) + 1 + 2)

		if down then
			scroll_panel:ScrollToBottom()
		end

		if value == "" then
			gui.InternalKeyCodeTyped(KEY_LEFT)
		end

		hook.Run("ChatTextChanged", value)
	end
	text_entry:OnValueChange("")

	do
		local emojis_table = {
			"grinning", "grin", "joy",
			"smiley", "smile", "sweat_smile",
			"laughing", "innocent", "smiling_imp",
			"wink", "blush", "yum", "relieved",
			"heart_eyes", "sunglasses", "smirk",
			"neutral_face", "expressionless", "unamused",
			"sweat", "pensive", "confused",
			"rage", "partying_face", "cold_face",
			"hot_face", "face_with_cowboy_hat"
		}

		local real_size = 0
		local mat, padding = SUI.Material("scb/emojis/flushed.png"), 3

		local emojis_button = text_entry:Add("DButton")
		emojis_button:SetText("")
		emojis_button:SetMouseInputEnabled(true)
		emojis_button:NoClipping(true)

		function emojis_button:IsActive()
			return self:IsHovered() or IsValid(scb.emojis_menu)
		end

		local inactive_col = Color(175, 175, 175)
		function emojis_button:Paint(w, h)
			surface.SetDrawColor(self:IsActive() and color_white or inactive_col)
			surface.SetMaterial(mat)
			surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, real_size, real_size, 0)
		end

		function emojis_button:OnCursorEntered()
			if not IsValid(scb.emojis_menu) then
				mat = SUI.Material("scb/emojis/" .. emojis_table[math.random(1, #emojis_table)] .. ".png")
			end
		end

		function emojis_button:Think()
			self:MoveToFront()
			real_size = Lerp(RealFrameTime() * 15, real_size, self:IsActive() and SUI.Scale(22) or SUI.Scale(18))
		end

		function emojis_button:DoClick()
			if IsValid(scb.emojis_menu) then
				return self:OnRemove()
			end

			local emojis_menu = vgui.Create("SCB.EmojiList")
			emojis_menu.button = self
			emojis_menu:FixPos()

			scb.emojis_menu = emojis_menu
		end

		function emojis_button:OnRemove()
			if IsValid(scb.emojis_menu) then
				scb.emojis_menu:Remove()
			end
		end

		text_entry:On("PerformLayout", function(s, w, h)
			local size = SUI.ScaleEven(18)
			emojis_button:SetSize(size, size)
			emojis_button:SetPos(w - (size + padding), h / 2 - size / 2)
		end)

		frame.emojis_button = emojis_button
		frame:AddPanelToHide(emojis_button)
	end

	-- Message Preview
	text_entry:On("OnValueChange", function(self, value)
		preview:SetWide(SUI.Scale(340))
		preview:Clear()
		SetVisible(preview_bg, false)

		if value == "" then return end

		local line = preview:Add("SCB.ChatLine")
		line:SetPlayer(LocalPlayer())
		line:SetAlpha(255)
		line:Parse(value)
		line:SizeToChildren(true, true)

		preview:SizeToChildren(false, true)
		preview:SetWide(line:GetMessageW())
		preview.w = line:GetMessageW()
		preview_bg:SetSize(preview.w + 8, preview:GetTall() + 8)
		SetVisible(preview_bg, true)
	end)
	--

	-- Emoji Select
	local emoji_list

	local open_emojis_list = function(emoji_name, start, _end)
		local selected_text
		if IsValid(emoji_list) then
			selected_text = emoji_list.selected_emoji and emoji_list.selected_emoji.name
			emoji_list:Remove()
		end

		local emojis = scb.search_emojis(emoji_name)
		if #emojis == 0 then return end

		emoji_list = frame:Add("SCB.EmojisSelect")
		emoji_list:SetWide(text_entry:GetWide())
		emoji_list:SetTextEntry(text_entry)
		emoji_list:SetStartEnd(start, _end)

		for _, v in ipairs(emojis) do
			local emoji = emoji_list:AddEmoji(v.name)
			if emoji.name == selected_text then
				emoji_list.selected_emoji = emoji
			end

			if #emoji_list.emojis == math.floor(SUI.Scale(120) / SUI.Scale(22)) then
				break
			end
		end

		emoji_list:SetPos(text_entry.x, text_entry.y - emoji_list:GetTall())
	end

	local typing_emoji = function()
		local value = text_entry:GetValue()
		local start, _end, emoji_name = 0
		while true do
			start, _end, emoji_name = value:find("%:([%w_]+)", _end)
			if not start then break end
			if utf8.len(value:sub(1, _end)) == text_entry:GetCaretPos() and not value:sub(_end + 1, _end + 1):match("%S") then
				return open_emojis_list(emoji_name:lower(), start, _end)
			end
			_end = _end + 1
		end

		if IsValid(emoji_list) then
			emoji_list:Remove()
		end
	end

	local old = text_entry.OnKeyCodeTyped
	function text_entry:OnKeyCodeTyped(code)
		if frame.hidden then return end
		if emoji_list and emoji_list[code] then
			return emoji_list[code](emoji_list)
		elseif code == KEY_ESCAPE then
			gui.HideGameUI()
			chat.Close()
			return
		elseif code == KEY_TAB then
			local text = hook.Run("OnChatTab", self:GetValue())
			if scb.isstring(text) then
				self:SetValue(text)
			end
			self:SetCaretPos(#self:GetValue())
			self:RequestFocus()
			return true
		end

		return old(self, code)
	end

	text_entry:On("OnValueChange", typing_emoji)
	text_entry:On("OnKeyCodeReleased", function(_, code)
		if code == KEY_LEFT or code == KEY_RIGHT then
			typing_emoji()
		end
	end)

	SUI.OnScaleChanged("EmojisListRemove", function()
		if IsValid(emoji_list) then
			emoji_list:Remove()
		end

		timer.Simple(0, function()
			text_entry:OnValueChange(text_entry:GetValue())
		end)
	end)
	--

	local settings = frame:AddHeaderButton("scb/settings.png", "settings", function()
		scb.open_settings()
	end)
	local parsers = frame:AddHeaderButton("scb/mind.png", "settings", function()
		scb.open_parsers_menu()
	end)

	frame:AddPanelToHide(frame.header)
	frame:AddPanelToHide(frame.title)
	frame:AddPanelToHide(frame.close)
	frame:AddPanelToHide(frame.close.image)
	frame:AddPanelToHide(settings)
	frame:AddPanelToHide(settings.image)
	frame:AddPanelToHide(parsers)
	frame:AddPanelToHide(parsers.image)
	frame:AddPanelToHide(scroll_panel)
	frame:AddPanelToHide(scroll_panel.VBar)
	frame:AddPanelToHide(scroll_panel.VBar.btnGrip)
	frame:AddPanelToHide(text_entry)

	frame.scroll_panel = scroll_panel
	frame.text_entry = text_entry

	sui.TDLib.End()

	local camera_hidden = false
	timer.Create("SCB.CameraCheck", 1, 0, function()
		local wep = LocalPlayer():GetActiveWeapon()
		if IsValid(wep) and wep:GetClass() == "gmod_camera" then
			camera_hidden = true
			SetVisible(scb.chatbox, false)
		else
			if camera_hidden then
				camera_hidden = false
				SetVisible(scb.chatbox, true)
			end
		end
	end)
end

SUI.RemoveTheme("Light")

SUI.AddToTheme("Dark", {
	settings = Color(255, 255, 255, 133),
	settings_hover = Color(65, 185, 255),
	settings_press = Color(255, 255, 255, 30),

	emoji_select_menu = Color(18, 18, 18),
	emoji_select_menu_selected = Color(200, 200, 200, 1),
})

SUI.AddToTheme("Blur", {
	settings = Color(200, 200, 200),
	settings_hover = Color(65, 185, 255),
	settings_press = Color(255, 255, 255, 30),

	emoji_select_menu = Color(50, 50, 50, 230),
	emoji_select_menu_selected = Color(40, 40, 40),
})

--PATH addons/[chat] scb-29/lua/scb/cl_overrides.lua:
if SCB_LOADED then return end

local table = table
local gui = gui
local team = team
local chat = chat
local hook = hook

local tonumber = tonumber
local Color = Color
local SetClipboardText = SetClipboardText
local IsValid = IsValid
local date = os.date
local team_GetColor = team.GetColor

local scb = scb
local config = scb.config
local language = scb.language

chat.OldOpen = chat.OldOpen or chat.Open
chat.OldClose = chat.OldClose or chat.Close

-- sometimes default chatbox prevents opening the console???
chat.OldClose()

local TEAM = "(" .. language.team .. ") "

function chat.Open(mode)
	mode = tonumber(mode)

	local dont_open = hook.Run("StartChat", mode ~= 1)
	if dont_open == true then return end

	do
		local succ, err = pcall(scb.create_chatbox)
		if not succ then
			if scb.chatbox then
				if scb.chatbox.Remove then
					scb.chatbox:Remove()
				end
				scb.chatbox = nil
			end
			SetClipboardText(err)
			hook.Add("HUDPaint", "SCB.FailedToLoad", function()
				local w, h = ScrW(), ScrH()
				draw.SimpleText("SCB Failed to load - Error is copied to your clipboard", "Trebuchet24", w / 2, h / 2, Color(255, 255, 255))
				draw.SimpleText(err, "Trebuchet24", w / 2, h / 2 + 20, Color(255, 255, 255))
			end)
			return
		end
	end

	local chatbox = scb.chatbox
	if chatbox.hidden == false then return end

	chatbox.bteam = mode
	chatbox.text_entry:SetPlaceholder((mode ~= 1 and TEAM or "") .. language.type_something)

	chatbox:SetVisible(true)
	chatbox.text_entry:RequestFocus()
	chatbox.text_entry:InvalidateLayout()
	chatbox:MakePopup()

	local childs = chatbox.scroll_panel:GetCanvas():GetChildren()
	for i = 1, #childs do
		local v = childs[i]
		v:Stop()
		v:AlphaTo(255, 0)
	end

	net.Start("SCB.IsTyping")
		net.WriteBool(true)
	net.SendToServer()
end

function chat.Close()
	local chatbox = scb.chatbox
	if not chatbox then return end

	if IsValid(scb.emojis_menu) then
		scb.emojis_menu:Remove()
	end

	chatbox.text_entry:SetValue("")
	chatbox.text_entry:OnTextChanged() -- reset chat history

	local childs = chatbox.scroll_panel:GetCanvas():GetChildren()
	for i = 1, #childs do
		local v = childs[i]
		if v.can_hide == nil then
			v:Stop()
			v:AlphaTo(0, 0)
		end
	end

	chatbox:SetVisible(false)
	chatbox:SetMouseInputEnabled(false)
	chatbox:SetKeyboardInputEnabled(false)

	chatbox.scroll_panel:ScrollToBottom()

	hook.Run("FinishChat")

	net.Start("SCB.IsTyping")
		net.WriteBool(false)
	net.SendToServer()
end

chat.OldGetChatBoxPos = chat.OldGetChatBoxPos or chat.GetChatBoxPos
function chat.GetChatBoxPos()
	if IsValid(scb.chatbox) then
		return scb.chatbox:GetPos()
	end
	return chat.OldGetChatBoxPos()
end

chat.OldGetChatBoxSize = chat.OldGetChatBoxSize or chat.GetChatBoxSize
function chat.GetChatBoxSize()
	if IsValid(scb.chatbox) then
		return scb.chatbox:GetSize()
	end
	return chat.OldGetChatBoxSize()
end

local fade_out_time = GetConVar("scb_message_fade_out_time"):GetFloat()
cvars.AddChangeCallback("scb_message_fade_out_time", function(_, _, value_new)
	fade_out_time = value_new
end)

chat.OldAddText = chat.OldAddText or chat.AddText
local AddText_queue = {}
local allow_parsing = config.parse_in_chat
function chat.AddText(...)
	local args
	if AddText_queue == true then
		args = ...
	else
		chat.OldAddText(...)
		args = {n = select("#", ...), ...}
	end

	if not scb.chatbox then
		table.insert(AddText_queue, args)
		return
	end

	local scroll_panel = scb.chatbox.scroll_panel
	local down = scroll_panel:ShouldScrollDown()

	local line = scroll_panel:Add("SCB.ChatLine")
	line:HideAfterTime(fade_out_time)

	line.parsing = true

	local current_color = line.text_color
	for i = 1, args.n do
		local v = args[i]
		local t = scb.type(v)
		if t == "Color" then
			current_color = v
		elseif t == "string" then
			if allow_parsing then
				line:Parse(v, current_color)
			else
				line:NewLabel(v, current_color)
			end
		elseif scb.isentity(v) and not IsValid(v) and not v:IsWorld() then
			line:NewLabel("NULL", current_color)
		elseif t == "Player" then
			line:NewLabel(v:Name(), team_GetColor(v:Team()))
		elseif t == "Entity" then
			line:NewLabel(v:GetClass(), current_color)
		end
	end

	line.parsing = nil

	line:SizeToChildren(false, true)

	if down then
		scroll_panel:ScrollToBottom()
	end
end

local gamemodes_OnPlayerChat = {}
do
	local add_say = function(key, func)
		gamemodes_OnPlayerChat[key] = func
	end

	local line_DoRightClick = function(s)
		local d_menu = DermaMenu()

		local text = s.text
		d_menu:AddOption(language.copy_text, function()
			SetClipboardText(text)
		end)

		local message = s.message
		d_menu:AddOption(language.copy_message, function()
			SetClipboardText(message)
		end)

		local steamid = s.steamid
		if steamid then
			d_menu:AddSpacer()

			d_menu:AddOption(language.copy_steamid, function()
				SetClipboardText(util.SteamIDFrom64(steamid))
			end)

			d_menu:AddOption(language.copy_steamid64, function()
				SetClipboardText(steamid)
			end)

			d_menu:AddOption(language.show_profile, function()
				gui.OpenURL("https://steamcommunity.com/profiles/" .. steamid)
			end)
		end

		d_menu:AddSpacer()
		local time = s.time
		d_menu:AddOption(language.copy_time, function()
			SetClipboardText(time)
		end)

		d_menu:Open()
		d_menu:MakePopup()
	end

	local show_timestamps = GetConVar("scb_show_timestamps"):GetBool()
	cvars.AddChangeCallback("scb_show_timestamps", function(_, _, value_new)
		show_timestamps = tobool(value_new)
	end)

	local show_avatars = config.enable_avatars and GetConVar("scb_show_avatars"):GetBool() or false
	cvars.AddChangeCallback("scb_show_avatars", function(_, _, value_new)
		show_avatars = tobool(value_new)
	end)

	local default_say = function(ply, text, bteam, is_dead, name_replacement, name_color_replacement, text_color)
		local is_console = not ply:IsValid()

		local scroll_panel = scb.chatbox.scroll_panel
		local down = scroll_panel:ShouldScrollDown()

		local line = scroll_panel:Add("SCB.ChatLine")
		line:HideAfterTime(fade_out_time)

		line.parsing = true
		line.time = date(config.timestamps_format)

		if show_timestamps then
			line:SetFont(SCB_16)
			line:NewLabel(line.time .. " ", Color(164, 164, 164))
			line:SetFont(SCB_18)
		end

		local name, name_color
		if not is_console then
			if show_avatars then
				line:NewAvatar(ply)
			end

			if is_dead then
				line:NewLabel(language.dead, Color(244, 67, 54))
			end

			if bteam then
				line:NewLabel(TEAM, Color(76, 175, 80))
			end

			local tag = ply:SCB_GetTag()
			if tag then
				line.emoji_size = 18
				line:Parse(tag .. " ")
				line.emoji_size = 24
			end

			if name_replacement then
				name = name_replacement
			else
				name = ply:Name()
			end

			if name_color_replacement then
				name_color = name_color_replacement
			else
				name_color = team_GetColor(ply:Team())
			end

			line.steamid = ply:SteamID64()
		else
			line:NewLabel("*")
			name, name_color = language.console, Color(13, 130, 223)
		end

		line:NewLabel(name, name_color)
		line:NewLabel(": ")
		line:SetPlayer(ply)
		line:Parse(text, text_color)

		line.message = text
		line.DoRightClick = line_DoRightClick

		if down then
			scroll_panel:ScrollToBottom()
		end

		chat.OldAddText(Color(164, 164, 164), line.time .. " - ", name_color, name, line.text_color, ": ", text_color, text)

		return true
	end
	add_say(1, default_say)

	add_say("darkrp", function(ply, text, _, is_dead, prefix, col1, col2)
		return default_say(ply, text, false, is_dead, prefix, col1, col2 ~= color_white and col2 or nil)
	end)

	add_say("terrortown", function(ply, text, bteam, is_dead)
		if not IsValid(ply) then
			return default_say(ply, text, bteam, is_dead)
		end

		local is_spec = ply:Team() == TEAM_SPEC
		if is_spec then
			is_dead = true
		end

		if bteam and ((not is_spec and not ply:IsSpecial()) or is_spec) then
			bteam = false
		end

		local name_color
		if ply:GetTraitor() then
			name_color = Color(244, 67, 54)
		elseif ply:GetDetective() then
			name_color = Color(13, 130, 223)
		end

		return default_say(ply, text, bteam, is_dead, nil, name_color)
	end)

	scb.add_chat_say = add_say
end

local OnPlayerChat_queue = {}
hook.Add("OnPlayerChat", "SCB", function(...)
	table.insert(OnPlayerChat_queue, {n = select("#", ...), ...})
	return true
end)

local OnPlayerChat
hook.Add("HUDPaint", "SCB", function()
	chat.Open(1)

	for _, v in ipairs(AddText_queue) do
		AddText_queue = true
		chat.AddText(v)
	end
	AddText_queue = nil

	hook.Remove("OnPlayerChat", "SCB")
	OnPlayerChat = gamemodes_OnPlayerChat[engine.ActiveGamemode()] or gamemodes_OnPlayerChat[1]
	function GAMEMODE:OnPlayerChat(...)
		return OnPlayerChat(...)
	end
	for _, v in ipairs(OnPlayerChat_queue) do
		OnPlayerChat(unpack(v, 1, v.n))
	end
	OnPlayerChat_queue = nil

	chat.Close()
	hook.Remove("HUDPaint", "SCB")
end)

hook.Add("PlayerButtonDown", "SCB", function()
	local chatbox = scb.chatbox
	if chatbox and not chatbox.hidden and IsValid(chatbox) then
		chatbox.text_entry:RequestFocus()
	end
end)

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/game/client/clientmode_shared.cpp#L651
timer.Simple(5, function()
	local binds = {
		messagemode = 1,
		say = 1,

		messagemode2 = 0,
		say_team = 0
	}

	local old_PlayerBindPress = GAMEMODE.PlayerBindPress
	function GAMEMODE:PlayerBindPress(ply, bind, pressed)
		if old_PlayerBindPress(self, ply, bind, pressed) == true then
			return true
		end

		local team_mode = binds[bind]
		if team_mode then
			if pressed then
				chat.Open(team_mode)
			end
			return true
		end
	end
end)

timer.Simple(5, function()
	local types = {
		namechange = 1,
		servermsg = 1,
		teamchange = 1,
		none = 1,
	}

	if not config.enable_custom_join_messages and not config.enable_custom_leave_messages then
		types.joinleave = 1
	end

	local old_ChatText = GAMEMODE.ChatText
	function GAMEMODE:ChatText(index, name, text, type, ...)
		if old_ChatText(self, index, name, text, type) == true then
			return true
		end

		if types[type] then
			chat.AddText(text)
			return true
		end

		if type == "joinleave" then
			return true
		end
	end
end)

if config.enable_custom_join_messages then
	local show_var = GetConVar("scb_joindisconnect_message")

	local printed_join = {}
	gameevent.Listen("player_connect_client")
	hook.Add("player_connect_client", "SCB.JoinMessage", function(data)
		if not show_var:GetBool() then return end

		if data.bot == 1 then
			chat.AddText((
				language.bot_joined:gsub("NAME", scb.escape(data.name))
			))
			return
		end

		local steamid = data.networkid
		if not printed_join[steamid] then
			printed_join[steamid] = true

			timer.Simple(4, function()
				printed_join[steamid] = nil
			end)

			chat.AddText((
				language.player_connecting:gsub("NAME", scb.escape(data.name)):gsub("STEAMID", data.networkid)
			))
		end
	end)
end

if config.enable_custom_leave_messages then
	local show_var = GetConVar("scb_joindisconnect_message")

	local printed_left = {}
	gameevent.Listen("player_disconnect")
	hook.Add("player_disconnect", "SCB.LeaveMessage", function(data)
		if not show_var:GetBool() then return end

		if data.bot == 1 then
			chat.AddText((
				language.bot_left:gsub("NAME", scb.escape(data.name))
			))
			return
		end

		local steamid = data.networkid
		if not printed_left[steamid] then
			printed_left[steamid] = true

			timer.Simple(4, function()
				printed_left[steamid] = nil
			end)

			chat.AddText((
				language.player_left:gsub("NAME", scb.escape(data.name)):gsub("REASON", scb.escape(data.reason)):gsub("STEAMID", data.networkid)
			))
		end
	end)
end

hook.Add("HUDShouldDraw", "SCB", function(name)
	if name == "CHudChat" then
		return false
	end
end)

net.Receive("SCB.TTTRadio", function()
	local sender = net.ReadEntity()
	local msg = net.ReadString()
	local param = net.ReadString()
	if not IsValid(sender) and sender:IsPlayer() then return end

	GAMEMODE:PlayerSentRadioCommand(sender, msg, param)

	local lang_param = LANG.GetNameParam(param)
	if lang_param then
		if lang_param == "quick_corpse_id" then
			param = LANG.GetParamTranslation(lang_param, {player = net.ReadString()})
		else
			param = LANG.GetTranslation(lang_param)
		end
	end

	local text = LANG.GetParamTranslation(msg, {player = param})

	if lang_param then
		text = util.Capitalize(text)
	end

	OnPlayerChat(sender, text, false, false)
end)

--PATH addons/[chat] scb-29/lua/scb/vgui/scb_chat_line.lua:
if SCB_LOADED then return end

local timer = timer
local draw = draw
local math = math
local table = table
local vgui = vgui

local Lerp = Lerp
local Color = Color
local DermaMenu = DermaMenu
local unpack = unpack
local IsValid = IsValid
local UnPredictedCurTime = UnPredictedCurTime
local RoundedBox = draw.RoundedBox
local sub = string.sub
local find = string.find
local gsub = string.gsub
local lower = string.lower

local scb = scb
local sui = sui
local SUI = scb.SUI
local config = scb.config
local language = scb.language
local get_text_size = sui.get_text_size

scb.chat_parsers = {}
local add_parser_example = function(title, example, output)
	table.insert(scb.chat_parsers, {title, example, output:format("change_me")})
end

do
	local available_colors = "\n\nAvailable Colors:\n"
	for k in pairs(config.colors) do
		available_colors = available_colors .. k .. " - "
	end
	available_colors = available_colors:sub(1, -4) .. "\n"

	add_parser_example("{cyan This text will be in cyan.}" .. available_colors, "{cyan What is this?}", "{cyan %s}")
end
add_parser_example("{#d4af37 This text will be in gold.}\nUsage: {#hex text}\n", "{#d4af37 Gold is my favourite color UwU}", "{#d4af37 %s}")
add_parser_example("{*This text will be in rainbow.}", "{*Nice rainbow text OwO}", "{*%s}")
add_parser_example("{!This text will be flashing in red.}", "{!OwO I like it ^-^}", "{!%s}")
add_parser_example("{!blue This text will be flashing in blue.}", "{!blue I love flashing blue ^~^}", "{!blue %s}")
add_parser_example("{!#d4af37 This text will be flashing in gold.}", "{!#d4af37 flashing & gold?}", "{!#d4af37 %s}")
add_parser_example("\\{*This text will be escaped.}", "\\{*This text will be escaped.}", "\\{*%s}")

local ESCAPE_CHAR = "\\"

local created_panels = {}

local Panel = {}

AccessorFunc(Panel, "m_bFont", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_bPlayer", "Player")

local current_x
local current_line
local current_y, line_h
function Panel:Init()
	self:Dock(TOP)
	self:SetFont(SCB_18)

	self:InvalidateParent(true)

	self:SetAlpha(0)
	self:AlphaTo(255, 0.5)

	self:SetCursor("hand")

	self.text_color = SUI.GetColor("text_entry")

	self.added = {}

	-- Methods
	local children = {}
	function self:Add(pnl)
		pnl = vgui.Create(pnl, self)
		pnl.line = current_line
		table.insert(children, pnl)
		return pnl
	end
	function self:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	function self:GetChildren()
		return children
	end
	--

	-- self.next_pos = 639735932

	self:ScaleChanged()
	table.insert(created_panels, self)
end

function Panel:ScaleChanged()
	self:Clear()
	self:InvalidateParent(true)
	self:InvalidateLayout(true)

	current_x = 0
	current_line = 0
	current_y, line_h = 0, 0

	self.max_w = -1
	self.max_h = {0}
	self.text = ""

	self.emoji_size = 24

	self.parsing = true

	local added = self.added
	self.added = {}
	for i = 1, #added do
		local v = added[i]
		local v_1 = v[1]

		local func = (v_1 == 1 and self.NewLabel) or (v_1 == 2 and self.NewEmoji) or (v_1 == 3 and self.NewAvatar)
		func(self, unpack(v, 2, table.maxn(v)))

		added[i] = nil
	end

	self.parsing = nil
	self:SizeToChildren(false, true)
end

local hovered = Color(50, 50, 50, 150)
function Panel:Paint(w, h)
	if self.Hovered then
		RoundedBox(3, 0, 0, w, h, hovered)
	end
end

function Panel:DoRightClick()
	local d_menu = DermaMenu()
	local text = self.text
	d_menu:AddOption(language.copy_text, function()
		SetClipboardText(text)
	end)
	d_menu:Open()
	d_menu:MakePopup()
end

function Panel:OnMouseReleased(mousecode)
	if self.Hovered and mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end
end

function Panel:IncrementLine()
	current_x = 0
	current_line = current_line + 1
	current_y, line_h = current_y + line_h, 0
	self.max_h[current_line + 1] = 0
end

function Panel:SetLineH(h)
	if h > line_h then
		line_h = h
		self.max_h[current_line + 1] = h

		local childs = self:GetChildren()
		for i = #childs, 1, -1 do
			local v = childs[i]
			if v.line ~= current_line then break end
			v.y = self:GetCurrentY(v:GetTall())
		end
	end
end

function Panel:SizeToChildren(width, height)
	if self.parsing then return end

	if width then
		self:SetWide(self.max_w)
	end

	if height then
		self:SetTall(self:GetTotalH())
	end
end

function Panel:GetTotalH()
	local h = 0
	local max_h = self.max_h
	if max_h then
		for i = 1, #max_h do
			h = h + max_h[i]
		end
	end
	return h
end

function Panel:GetCurrentY(_h)
	local y = current_y
	if _h == line_h then return y end
	return math.floor((y + ((line_h / 2) - (_h / 2))) + 0.5)
end

function Panel:AddW(w)
	current_x = current_x + w

	if current_x > self.max_w then
		self.max_w = current_x
	end

	if current_x >= self:GetWide() then
		self:IncrementLine()
	end
end

function Panel:GetMessageW()
	return self.max_w
end

do
	local label_time

	local underline_color = Color(23, 115, 196)
	local url_underline = function(s, w, h)
		if s:IsHovered() then
			s:SetTextColor(underline_color)
		else
			s:SetTextColor(s.text_color)
		end
		RoundedBox(0, 0, h - 1, w, 1, s:GetTextColor())
	end

	local url_click = function(s)
		gui.OpenURL(s.url)
	end

	local url_right_click = function(s)
		local d_menu = DermaMenu()
		local url = s.url
		d_menu:AddOption(language.copy_url, function()
			SetClipboardText(url)
		end)
		d_menu:Open()
		d_menu:MakePopup()
	end

	local disable_rainbow_colors = GetConVar("scb_disable_rainbow_colors"):GetBool()
	cvars.AddChangeCallback("scb_disable_rainbow_colors", function(_, _, value_new)
		disable_rainbow_colors = tobool(value_new)
	end)
	local label_rainbow = function(s)
		if disable_rainbow_colors then
			s:SetTextColor(s.text_color)
			return
		end

		local r, g, b = sui.hsv_to_rgb((s.time + UnPredictedCurTime()) % 360 * 0.6, 1, 1)
		s:SetFGColor(r, g, b, s.text_color_obj.a)
	end

	local disable_flashing_texts = GetConVar("scb_disable_flashing_texts"):GetBool()
	cvars.AddChangeCallback("scb_disable_flashing_texts", function(_, _, value_new)
		disable_flashing_texts = tobool(value_new)
	end)
	local label_flash = function(s)
		if disable_flashing_texts then
			s:SetTextColor(s.text_color)
			return
		end

		local col = s.text_color_obj
		s:SetFGColor(col.r, col.g, col.b, (s.time + UnPredictedCurTime()) * 300 % 255)
	end

	function Panel:AddLabel(text, color, url, is_hovered, font)
		if text == "" then return end

		local w, h = get_text_size(text, font)
		self:SetLineH(h)

		local label = self:Add("SCB.Label")
		label:SetFont(font)
		label:SetText(text:sub(1, 1) == "#" and ("#" .. text) or text)
		label:SetExpensiveShadow(1, color_black)
		label:SetSize(w, h)
		label:SetPos(current_x, self:GetCurrentY(h))

		label.text_color = scb.type(color) == "Color" and color or self.text_color

		if color == "rainbow" or self.flashing then
			label.text_color_obj = Color(label.text_color:Unpack())
			label.time = label_time
			label.Paint = color == "rainbow" and label_rainbow or label_flash
		else
			label:SetTextColor(label.text_color)
		end

		if url then
			label:SetMouseInputEnabled(true)
			label:SetCursor("hand")
			label.Paint = url_underline
			label.DoClick = url_click
			label.DoRightClick = url_right_click
			label.url = url
			label.IsHovered = is_hovered
		end

		self.text = self.text .. text
		self:AddW(w)

		-- if scb.type(color) ~= "Color" then
			-- hook.Add("SCB.ThemeChanged", label, function(s)
			-- 	s.text_color = SUI.GetColor("text_entry")
			-- 	s:SetTextColor(s.text_color)
			-- end)
		-- end

		return label
	end

	local AddLabel = Panel.AddLabel
	local IncrementLine = Panel.IncrementLine
	function Panel:NewLabel(text, color, is_url, font)
		if text == "" then return end

		font = font or self:GetFont()
		table.insert(self.added, {1, text, color, is_url, flashing, font})

		local url
		if is_url then
			url = text
		end

		local wide = self:GetWide()
		text = sui.wrap_text(text, font, wide, wide - current_x)

		local urls, is_hovered
		if is_url then
			urls, is_hovered = {}, function()
				for k, v in ipairs(urls) do
					if v.Hovered then
						return true
					end
				end
			end
		end

		label_time = math.sin(UnPredictedCurTime()) + math.random()

		local lines = text:Split("\n")
		local lines_n = #lines
		for i = 1, lines_n do
			local v = lines[i]

			local line = current_line

			local label = AddLabel(self, v, color, url, is_hovered, font)
			if urls then
				table.insert(urls, label)
			end

			if i ~= lines_n and line == current_line then
				IncrementLine(self)
			end
		end

		self:SizeToChildren(false, true)
	end
end

function Panel:NewEmoji(name, info, size)
	local _size = size or self.emoji_size
	table.insert(self.added, {2, name, info, _size})

	if scb.isnumber(_size) then
		size = SUI.ScaleEven(_size)
	else
		size = tonumber(_size)
	end

	if size >= self:GetWide() - current_x then
		self:IncrementLine()
	end

	self:SetLineH(size)

	local image = self:Add("SCB.Image")
	image:SetImage(scb.is_custom_emoji(info) and info or ("scb/emojis/" .. name .. ".png"))
	image:SetSize(size, size)
	image:SetPos(current_x, self:GetCurrentY(size))

	if size == SUI.ScaleEven(24) then
		image:SetMinus(2)
	end

	self:AddW(size)

	self.text = self.text .. (":" .. name .. ":")

	self:SizeToChildren(false, true)

	return image
end

function Panel:NewAvatar(ply, size)
	table.insert(self.added, {3, ply, size})

	size = SUI.ScaleEven(size or 26)

	self:SetLineH(size)

	local avatar = self:Add("Panel")
	avatar:SetSize(size, size)
	avatar:SetPos(current_x, self:GetCurrentY(size))
	avatar:SetMouseInputEnabled(false)
	avatar:SUI_TDLib()
		:CircleAvatar()

	if scb.isentity(ply) then
		avatar:SetPlayer(ply, size)
	else
		avatar:SetSteamID(ply, size)
	end

	self:AddW(size + get_text_size(" ", self:GetFont()))
end

function Panel:HideAfterTime(time)
	self.can_hide = false
	timer.Simple(time, function()
		if not IsValid(self) then return end
		self.can_hide = nil
		if IsValid(scb.chatbox) and scb.chatbox.hidden then
			self:AlphaTo(0, 0.5)
		end
	end)
end

do
	local NewLabel = Panel.NewLabel

	local trim = function(s)
		return s:match("^%s*(.-)%s*$") or s
	end

	local parse_arg = function(text)
		local arg = ""
		local i, n = 1, #text
		while i <= n do
			local c = sub(text, i, i)
			if c == " " then break end
			if c == "}" then break end
			arg = arg .. c

			i = i + 1
		end
		return lower(arg), i + 1
	end

	local color_parsers = {}
	for k, v in pairs(config.colors) do
		color_parsers[k] = {
			permission = "colored_texts",
			callback = function(self, text, arg)
				text = trim(text)
				if text == "" then return false end
				NewLabel(self, text, scb.hex_rgb(v))
			end
		}
	end

	local parsers; parsers = {
		["$"] = {
			callback = function(self, emoji, ply, color)
				emoji = lower(emoji)

				local emoji_info = scb.emojis[emoji]
				if emoji_info and not (scb.is_custom_emoji(emoji_info) and not scb.has_permission(ply, "custom_emojis")) then
					self:NewEmoji(emoji, emoji_info)
				else
					return false, ":" .. emoji .. ":"
				end
			end
		},
		["#"] = {
			permission = "colored_texts",
			callback = function(self, text, _, color)
				local hex_col, start = parse_arg(text)
				if #hex_col < 3 or not find(hex_col, "^[%da-fA-F]+$") then
					return false
				end
				text = trim(sub(text, start))
				if text == "" then return false end
				NewLabel(self, text, scb.hex_rgb(hex_col), nil, flashing)
			end
		},
		["*"] = {
			permission = "rainbow",
			callback = function(self, text, ...)
				text = trim(text)
				if text == "" then return false end
				NewLabel(self, text, "rainbow")
			end
		},
		["@"] = {
			callback = function(self, text)
				if scb.find_url(text) then
					NewLabel(self, text, nil, true)
				else
					return false
				end
			end
		},
		["!"] = {
			permission = "flashing",
			callback = function(self, text, ply)
				local ret

				self.flashing = true

				local arg, start = parse_arg(text)
				if scb.has_permission(ply, "colored_texts") then
					if sub(arg, 1, 1) == "#" then
						ret = parsers["#"].callback(self, sub(text, 2))
						goto skip
					elseif color_parsers[arg] then
						color_parsers[arg].callback(self, sub(text, start), "flash")
						goto skip
					end
				end

				text = trim(text)
				if text == "" then
					ret = false
					goto skip
				end
				NewLabel(self, text, Color(255, 0, 0))
				::skip::

				self.flashing = false

				return ret
			end
		}
	}

	local parse_between_braces = function(text, pos, len)
		local tmp_text = ""
		local end_pos = pos
		local closed = false
		local escape = false
		for i = pos, len do
			end_pos = i
			local c = sub(text, i, i)
			if escape then
				tmp_text = tmp_text .. c
				escape = false
				continue
			end
			if c == ESCAPE_CHAR then
				escape = true
			elseif c == "}" then
				closed = true
				break
			else
				tmp_text = tmp_text .. c
			end
		end
		return tmp_text, closed, end_pos
	end

	function Panel:Parse(text, color)
		self.parsing = true

		text = gsub(text, "()%:([%w_]+)%:", function(start, found)
			if text[start - 1] ~= ESCAPE_CHAR then
				return "{$" .. found .. "}"
			end
		end)

		do
			local pos = 0
			while true do
				local start, url, _end = scb.find_url(text, pos + 1)
				if not start then break end
				if text:sub(start - 1, start - 1) ~= ESCAPE_CHAR then
					text = text:sub(1, start - 1) .. ("{@" .. url .. "}") .. text:sub(_end + 1)
				end
				pos = _end + 1
			end
		end

		local ply = self:GetPlayer()

		local len = #text
		local tmp_text = ""
		local i = 0
		while true do
			i = i + 1
			if i > len then break end

			local c = sub(text, i, i)
			if c == ESCAPE_CHAR then
				tmp_text = tmp_text .. sub(text, i + 1, i + 1)
				i = i + 1
				continue
			end

			if c ~= "{" then
				tmp_text = tmp_text .. c
				continue
			end

			local ret_text, closed, end_pos = parse_between_braces(text, i + 1, len)
			if not closed then
				tmp_text = tmp_text .. sub(text, i, end_pos)
				break
			end

			local tag, tag_end = sub(ret_text, 1 , 1), 1
			if not scb.is_letter_digit(tag) then
				tag = parsers[tag]
			else
				for i2 = 2, #ret_text do
					local c2 = sub(ret_text, i2, i2)
					if not scb.is_letter_digit(c2) then break end
					tag = tag .. c2
					tag_end = tag_end + 1
				end
				tag_end = tag_end + 1
				tag = color_parsers[tag]
			end

			i = end_pos

			local failed_text = "{" .. ret_text .. "}"

			if tag == nil then
				tmp_text = tmp_text .. failed_text
				continue
			end

			local permission = tag.permission
			if permission and not scb.has_permission(ply, permission) then
				tmp_text = tmp_text .. failed_text
				continue
			end

			ret_text = sub(ret_text, tag_end + 1)

			NewLabel(self, tmp_text, color)
			local done, ret = tag.callback(self, ret_text, ply, color)
			if done == false then
				if ret then
					NewLabel(self, ret, color)
				else
					NewLabel(self, failed_text, color)
				end
			end
			tmp_text = ""
		end

		NewLabel(self, tmp_text, color)
		self.parsing = nil
		self:SizeToChildren(false, true)
	end
end

do
	local AnimationThink = function(s)
		local anim = s.anim
		if not anim then return end

		local time = UnPredictedCurTime()
		if time >= anim.start_time then
			local frac = math.TimeFraction(anim.start_time, anim.end_time, time)
			frac = math.Clamp(frac, 0, 1)

			s:SetAlpha(Lerp(frac ^ (1 - (frac - 0.5)), s:GetAlpha(), anim.alpha))

			if frac == 1 then
				s.anim = nil
				s.AnimationThink = nil
			end
		end
	end

	function Panel:AlphaTo(alpha, length)
		local time = UnPredictedCurTime()

		self.anim = {
			start_time = time,
			end_time = time + length,

			alpha = alpha
		}

		self.AnimationThink = AnimationThink
	end

	function Panel:Stop()
		self.anim = nil
	end
end

function Panel:OnRemove()
	for i = 1, #created_panels do
		if created_panels[i] == self then
			table.remove(created_panels, i)
			break
		end
	end
end

SUI.OnScaleChanged("ChatLines", function()
	timer.Simple(0, function()
		for i = 1, #created_panels do
			local v = created_panels[i]
			if v:IsValid() then
				v:ScaleChanged()
			end
		end
	end)
end)

sui.register("ChatLine", Panel, "Panel")

--PATH lua/arc9/common/localization/font_en.lua:
L = {}

/////////////////////////////////////// Font
//////////////////// If a custom font should be used, rename the string. Useful for Pinyin, Kanji, etc.
////////// Do not create a font file if your language does not need it.

L["font"] = "Venryn Sans"
--PATH lua/arc9/common/localization/base_en.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_sv-se.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_sv-se.lua:
L = {}

/////////////////////////////////////// Font
////////////////////// See "font_en" file

/////////////////////////////////////// General
////////////////////// Units of measurement
L["unit.second"] = "s"
L["unit.meter"] = "m"
L["unit.millimeter"] = "mm"
L["unit.meterpersecond"] = "m/s"
L["unit.hammerunit"] = "H-E"
L["unit.decibel"] = "dB"
L["unit.rpm"] = "SPM"
L["unit.moa"] = "BM"
L["unit.dmg"] = "SKD"
L["unit.projectiles"] = "PROJ"

L["unit.inch"] = "in"
L["unit.foot"] = "ft"
L["unit.footpersecond"] = "ft/s"
L["unit.yard"] = "yd"

////////////////////// Ammo types
L["ammo.pistol"] = "Pistol Ammo"
L["ammo.357"] = "Magnum Ammo"
L["ammo.smg1"] = "Karbin Ammo"
L["ammo.ar2"] = "Gevrs Ammo"
L["ammo.buckshot"] = "Hagelbssa Ammo"
L["ammo.sniperpenetratedround"] = "Prickskytt. Ammo"
L["ammo.smg1_grenade"] = "Gevrsgranater"
L["ammo.xbowbolt"] = "Armborstpilar"
L["ammo.rpg_round"] = "Raketer"
L["ammo.grenade"] = "Granater"
L["ammo.slam"] = "SLAM"
L["ammo.alyxgun"] = "Alyxs Vapenammo"

/////////////////////////////////////// HUD
L["hud.version"] = "ARCTIC SYSTEMS HUD v"
L["hud.jammed"] = "ELDAVBROTT!"
L["hud.therm_deco"] = "ELDRR TEMP"

L["hud.firemode.single"] = "ENKEL"
L["hud.firemode.burst"] = "SALVO"
L["hud.firemode.auto"] = "AUTO"
L["hud.firemode.safe"] = "SKER"

L["hud.hint.bash"] = "Nrstrid"
L["hud.hint.bipod"] = "Vxla Skjutstd"
L["hud.hint.breath"] = "Hll Andan"
L["hud.hint.customize"] = "Anpassa"
L["hud.hint.cycle"] = "Cykel"
L["hud.hint.firemode"] = "Vxla Skjutlgen"
L["hud.hint.inspect"] = "Inspektera"
L["hud.hint.lean"] = "Luta"
L["hud.hint.peek"] = "Kika"
L["hud.hint.reload"] = "Ladda om"
L["hud.hint.safe"] = "Vxla Skring"
L["hud.hint.switchsights"] = "Vxla Sikten"
L["hud.hint.toggleatts"] = "Vxla Tillbehr"
L["hud.hint.ubgl"] = "Vxla"
L["hud.hint.unjam"] = "Fixa Eldavbrott"
L["hud.hint.zoom"] = "ndra Zoom"
L["hud.hint.quicknade"] = "Snabbkasta "

L["hud.hint.lowammo"] = "Lg Ammo"
L["hud.hint.noammo"] = "Ingen Ammo"

L["hud.error.missingbind"] = "Ingen knapp bunden till %s"
L["hud.error.missingbind_zoom"] = "Bind \"Suit Zoom\" i instllningarna!"
L["hud.error.missingbind_context"] = "Bind \"Open Context Menu\" i instllningarna!"

/////////////////////////////////////// Customization menu
L["customize.panel.customize"] = "ANPASSA"
L["customize.panel.personalize"] = "PERSONALISERA"
L["customize.panel.stats"] = "STATS & BALLISTIK"
L["customize.panel.trivia"] = "TRIVIA"
L["customize.panel.inspect"] = "INSPEKTERA"
L["customize.panel.presets"] = "Frinstll."

L["customize.stats.aimtime"] = "Siktetid"
L["customize.stats.ammo"] = "Patrontyp"
L["customize.stats.armorpiercing"] = "Pansarbrytande"
L["customize.stats.burstdelay"] = "Salvo Frdrj."
L["customize.stats.capacity"] = "Kapacitet"
L["customize.stats.cyclic"] = "Cykel Eldhastighet"
L["customize.stats.explosive"] = "Explosiv Skada"
L["customize.stats.firemodes"] = "Skjutlgen"
L["customize.stats.firepower"] = "Eldkraft"
L["customize.stats.freeaim"] = "Fritt Sikte Radie"
L["customize.stats.muzzlevelocity"] = "Utgngshastighet"
L["customize.stats.noise"] = "Ljud"
L["customize.stats.penetration"] = "Penetration"
L["customize.stats.precision"] = "Precision"
L["customize.stats.range"] = "Rckvidd"
L["customize.stats.ricochet"] = "Rikoschett Chans"
L["customize.stats.rof"] = "Eldhastighet"
L["customize.stats.speed"] = "Rrelsehastighet"
L["customize.stats.sprinttofire"] = "Spring-till-Sikte Tid"
L["customize.stats.supplylimit"] = "Pfyll Begrnsning"
L["customize.stats.sway"] = "Svngning"
L["customize.stats.triggerdelay"] = "Avtryckare Frdrj."

L["customize.hint.attach"] = "Stt P"
L["customize.hint.controller"] = "Kontrollerlge r p."
L["customize.hint.cursor"] = "Pekare"
L["customize.hint.cycle"] = "Vxla Plats"
L["customize.hint.delete"] = "Ta Bort"
L["customize.hint.deselect"] = "Vlj Bort"
L["customize.hint.expand"] = "Expandera"
L["customize.hint.export"] = "Exportera"
L["customize.hint.favorite"] = "Favorit"
L["customize.hint.import"] = "Importera"
L["customize.hint.install"] = "Installera"
L["customize.hint.last"] = "Sista Plats"
L["customize.hint.lastmode"] = "Freg. Lge"
L["customize.hint.nextmode"] = "Nsta Lge"
L["customize.hint.open"] = "ppna"
L["customize.hint.pan"] = "Panorera"
L["customize.hint.quicksave"] = "Snabbspara"
L["customize.hint.randomize"] = "Stt p Slumpmssig"
L["customize.hint.recalculate"] = "Omkalkylera"
L["customize.hint.recenter"] = "Centrera Om"
L["customize.hint.rotate"] = "Rotera"
L["customize.hint.save"] = "Spara"
L["customize.hint.select"] = "Vlj"
L["customize.hint.unattach"] = "Ta Av"
L["customize.hint.unfavorite"] = "Ta bort Favorit"
L["customize.hint.zoom"] = "Zooma"

L["customize.trivia.description"] = "Beskrivning"

L["customize.stats.explain.firepower"] = "Skadepotential p nrdistans."
L["customize.stats.explain.rof"] = "Vapnets eldhastighet."
L["customize.stats.explain.cyclic"] = "Vapnets cykel eldhastighet. Ignorerar faktorer som salvo frdrjning eller omladdning krav."
L["customize.stats.explain.capacity"] = "Hur mycket ammo vapnet kan hlla i magasin + slutstycket."
L["customize.stats.explain.range"] = "Rckvidden d vapnet delar ut minimum skada."
L["customize.stats.explain.precision"] = "Vapnets trffskerhet. Mts i \"Minutes of Accuracy\" (MOA)."
L["customize.stats.explain.muzzlevelocity"] = "Patronernas utgngshastighet efter dem skjutits frn detta vapnet."
L["customize.stats.explain.ammo"] = "Vilket sorts ammo detta vapen anvnder."
L["customize.stats.explain.penetration"] = "Antal material detta vapnet kan penetrera."
L["customize.stats.explain.ricochet"] = "Maximal chans fr att skott frn detta vapnet ska studsa."
L["customize.stats.explain.armorpiercing"] = "Antal skada detta vapen gr som totalt ignorerar dem flesta skademotstnd."
L["customize.stats.explain.explosive"] = "Antal explosiv skada detta vapnet kommer gra."
L["customize.stats.explain.speed"] = "Hastigheten du kan frflytta dig medans du anvnder vapnet."
L["customize.stats.explain.aimtime"] = "Hur lnge det tar att g in i siktet frn hften."
L["customize.stats.explain.sprinttofire"] = "Hur lnge det tar att avsluta springning och brja skjuta."
L["customize.stats.explain.firemodes"] = "Vilka skjutlgen detta vapnet har tillgng till."
L["customize.stats.explain.burstdelay"] = "Antal tid det tar efter man skjutit en spurt innan vapnet kan skjuta igen."
L["customize.stats.explain.triggerdelay"] = "Frdrjning mellan att trycka p avtryckaren och att ett skott skjuts."
L["customize.stats.explain.noise"] = "Hur hga vapnets skott r."
L["customize.stats.explain.sway"] = "Antal svngning som tillmpas p vapnet."
L["customize.stats.explain.freeaim"] = "Maximal fritt sikte vinkel. Lgre r bttre."
L["customize.stats.explain.supplylimit"] = "Antal ammo vapnet kan motta frn ARC9-ammo kllor."

L["customize.bench.dummy"] = "BALLISTIK DUMMY TEST"
L["customize.bench.effect"] = "EFFEKT P RCKVIDD"
L["customize.bench.ballistics"] = "TERMINAL BALLISTISK PRESTANDA EVALUERING"
L["customize.bench.precision"] = "MEKANISK TRFFSKERHET TEST"

L["folder.back"] = "Tillbaka"
L["folder.deselect"] = "Vlj Bort"
L["folder.favorites"] = "Favoriter"
L["folder.select"] = "Vlj"

////////////////////// Automatic stats
L["autostat.enable.pre"] = "Aktiverar"
L["autostat.disable.pre"] = "Avaktiverar"
L["autostat.enable.post"] = ""
L["autostat.disable.post"] = ""

L["autostat.aimdownsightstime"] = "Res/Snk Sikte Tid"
L["autostat.alwaysphysbullet"] = "Alltid Fysiska Skott"
L["autostat.ammopershot"] = "Ammo Per Skott"
L["autostat.armdamage"] = "Armskada"
L["autostat.armorpiercing"] = "Pansarbrytande"
L["autostat.autoburst"] = "Automatisk Salvo Eld"
L["autostat.autoreload"] = "Idle Reloading"
L["autostat.bash"] = "Nrstrid Angrepp"
L["autostat.bashdamage"] = "Nrstridskada"
L["autostat.bashlungerange"] = "Nrstrid Longera Rckvidd"
L["autostat.bashrange"] = "Nrstrid Rckvidd"
L["autostat.bashspeed"] = "Nrstridshastighet"
L["autostat.bipod"] = "Skjutstd"
L["autostat.bottomlessclip"] = "Bottenlst Magasin"
L["autostat.breathholdtime"] = "Fokustid"
L["autostat.bulletguidance"] = "Guidade Skott"
L["autostat.bulletguidanceamount"] = "Guidande Faktor"
L["autostat.canfireunderwater"] = "Under Vatten Skjutning"
L["autostat.cantpeek"] = "Avaktiverar Kikande"
L["autostat.chambersize"] = "Eldrr Laddantal"
L["autostat.chestdamage"] = "Skada till Brstkorgen"
L["autostat.clipsize"] = "Magasinkapacitet"
L["autostat.cycletime"] = "Cykeltid"
L["autostat.damagemax"] = "Nrdistans Skada"
L["autostat.damagemin"] = "Lngdistans Skada"
L["autostat.damagerand"] = "Skadevariering"
L["autostat.deploytime"] = "Ta Fram Tid"
L["autostat.distance"] = "Patron Avstnd"
L["autostat.entitymuzzlevelocity"] = "Projektilens Utgngshastighet"
L["autostat.explosiondamage"] = "Explosiv Skada"
L["autostat.explosionradius"] = "Explosion Stnkradie"
L["autostat.fixtime"] = "Fixa Felfunktion Tid"
L["autostat.freeaimradius"] = "Fritt Sikte Radie"
L["autostat.headshotdamage"] = "Huvudskott Skada"
L["autostat.heatcapacity"] = "Hetta Kapacitet"
L["autostat.heatdissipation"] = "Hetta Frlust"
L["autostat.heatpershot"] = "Hetta Per Skott"
L["autostat.hybridreload"] = "Hybrid Individuell Omladdning"
L["autostat.infiniteammo"] = "Ondlig Ammo"
L["autostat.legdamage"] = "Benskada"
L["autostat.malfunction"] = "Felfunktion"
L["autostat.malfunctionmeanshotstofail"] = "Elaka Skott Mellan Fel"
L["autostat.malfunctionwait"] = "Felfunktion Vntetid"
L["autostat.manualaction"] = "Manuell Handling"
L["autostat.manualactionchamber"] = "Skott Per Cykel"
L["autostat.neverphysbullet"] = "Ej Fysiska Skott"
L["autostat.noflash"] = "Ingen Mynningseld"
L["autostat.num"] = "Antal Projektiler"
L["autostat.overheat"] = "verhettning"
L["autostat.overheattime"] = "verhet. Fix Tid"
L["autostat.pelletspread"] = "Klump Spridning"
L["autostat.penetration"] = "Material Penetration"
L["autostat.penetrationdelta"] = "Skada Efter Penetration"
L["autostat.physbulletdrag"] = "Skottmotstnd"
L["autostat.physbulletgravity"] = "Skott Nedslpp"
L["autostat.physbulletmuzzlevelocity"] = "Utgngshastighet"
L["autostat.postburstdelay"] = "Salvo Frdrjning"
L["autostat.pushbackforce"] = "Tillbakatryckt Styrka"
L["autostat.rangemax"] = "Maximal Rckvidd"
L["autostat.rangemin"] = "Minimum Rckvidd"
L["autostat.recoil"] = "Rekyl"
L["autostat.recoilautocontrol"] = "Rekylkontroll"
L["autostat.recoildissipationrate"] = "Rekyl Frlust Takt"
L["autostat.recoilkick"] = "Knd Rekyl"
L["autostat.recoilmodifiercap"] = "Maximal Kumulativ Rekyl"
L["autostat.recoilpatterndrift"] = "Rekyl Drift"
L["autostat.recoilpershot"] = "Rekyl per Skott"
L["autostat.recoilrandomside"] = "Horisontell Rekyl Spridning"
L["autostat.recoilrandomup"] = "Vertikal Rekyl Spridning"
L["autostat.recoilresettime"] = "Rekyl terstllningstid"
L["autostat.recoilside"] = "Horisontell Rekyl"
L["autostat.recoilup"] = "Vertikal Rekyl"
L["autostat.reloadtime"] = "Omladdningstid"
L["autostat.ricochetanglemax"] = "Rikoschett Vinkel"
L["autostat.ricochetchance"] = "Rikoschett Chans"
L["autostat.rpm"] = "Eldhastighet"
L["autostat.runawayburst"] = "Bortsprungen Salvo"
L["autostat.secondarysupplylimit"] = "Reserv Sekundr Ammo"
L["autostat.shootvolume"] = "Rapportera Volym"
L["autostat.shootwhilesprint"] = "Skjut i Sprint"
L["autostat.shotgunreload"] = "Individuell Omladdning"
L["autostat.speed"] = "Rrelsehastighet"
L["autostat.spread"] = "Spridning"
L["autostat.sprinttofiretime"] = "Spring-till-Sikte Tid"
L["autostat.stomachdamage"] = "Magskada"
L["autostat.supplylimit"] = "Reservmagasin"
L["autostat.sway"] = "Svngning"
L["autostat.triggerdelay"] = "Avtryckare Frdrj. Tid"
L["autostat.triggerdelaytime"] = "Avtryckare Frdrj. Tid"
L["autostat.visualrecoil"] = "Visuell Rekyl"
L["autostat.visualrecoilpunch"] = "Visuell Rekylkick"
L["autostat.visualrecoilroll"] = "Visuell Rekylrullning"
L["autostat.visualrecoilside"] = "Horisontell Visuell Rekyl"
L["autostat.visualrecoilup"] = "Vertikal Visuell Rekyl"

L["autostat.secondary._beforephrase"] = false
-- if true, secondary stat phrasing comes before the stat
L["autostat.secondary._divider"] = " "
-- space between the secondary phrase from the stat phrase. set true to use empty string

-- L["autostat.secondary.blindfire"] = "under blind skjutning"
L["autostat.secondary.bipod"] = "med Skjutstd"
L["autostat.secondary.crouch"] = "medans Hukad"
L["autostat.secondary.empty"] = "p Sista skottet i magasinet"
L["autostat.secondary.evenreload"] = "varje Jmn Omladdning"
L["autostat.secondary.evenshot"] = "varje Jmnt skott"
L["autostat.secondary.first"] = "p Frsta Skottet"
L["autostat.secondary.firstshot"] = "p Frsta Skottet"
L["autostat.secondary.heated"] = "nr den r Het"
L["autostat.secondary.hipfire"] = "frn Hften"
L["autostat.secondary.hot"] = "frn Hetta"
L["autostat.secondary.last"] = "p Sista Skottet i magasinet"
L["autostat.secondary.lastshot"] = "p Sista skottet i magasinet"
L["autostat.secondary.midair"] = "i Luften"
L["autostat.secondary.move"] = "under Rrelse"
L["autostat.secondary.oddreload"] = "varje Udda Omladdning"
L["autostat.secondary.oddshot"] = "varje Udda skott"
L["autostat.secondary.recoil"] = "frn Rekylen" --"With Each Shot"
L["autostat.secondary.shooting"] = "under Skjutning"
L["autostat.secondary.sighted"] = "i Siktet"
L["autostat.secondary.sights"] = "i Siktet"
L["autostat.secondary.silenced"] = "nr Ljuddmpad"
L["autostat.secondary.sprint"] = "i Sprint"
L["autostat.secondary.true"] = "nr Sanna Namn r p"
L["autostat.secondary.ubgl"] = "p Tillsats"

////////////////////// Blacklist menu
L["blacklist.title"] = "ARC9-Tillbehr Svartlista"
L["blacklist.desc"] = "Tillbehr avbockade hr kommer blockeras frn att anvndas"
L["blacklist.blisted"] = "SVARTLISTAD"
L["blacklist.all"] = "ALLA"
L["blacklist.id"] = "ID"
L["blacklist.name"] = "NAMN"
L["blacklist.filter"] = "FILTER"

////////////////////// Incompatible addons
L["incompatible.title"] = "ARC9: INKOMPATIBLA TILLGG"
L["incompatible.line1"] = "Du har ngra tillgg som r knda att inte fungera med ARC9."
L["incompatible.line2"] = "Avaktivera dem eller frvnta brutet beteende!"
L["incompatible.confirm"] = "Bekrfta"
L["incompatible.wait"] = "Vnta {time}s"
L["incompatible.never"] = "Varna mig aldrig igen"
L["incompatible.never.hover"] = "r du absolut sker p att du frstr konsekvenserna?"
L["incompatible.never.confirm"] = "Du har valt att aldrig igen visa inkompatibla varningar igen. Om du upplever problem eller brutet beteende s r det ditt eget ansvar."

////////////////////// Warning panel
L["badconf.title"] = "ARC9: DLIG GMOD-INSTLLNINGSVARNING"
L["badconf.line1"] = "Ser ut som att ngra instllningar p Garry's Mod orsakar problem."
L["badconf.line2"] = "Nedanfr finns problem som upptckts och lsningar till dem."
L["badconf.confirm"] = "Bekrfta"
L["badconf.wait"] = "Vnta {time}s"

L["badconf.directx.title"] = "Gammal DirectX-Version"
L["badconf.directx.desc"] = "Du kr just nu DirectX 8 eller 8.1. D mnga vapentillgg tar bort tillgngar med lgre kvalitet fr att snka filstorleken s kanske du inte ser dessa modeller."
L["badconf.directx.solution"] = "Lsning: G till startinstllningarna p Garry's Mod och lgg till \"-dxlevel 95\" i startparametern. Om \"-dxlevel 70/80/85\" r med dr, ta bort det."

L["badconf.tickrate.title"] = "Fr lg server \"tickrate\""
L["badconf.tickrate.desc"] = "Servern du r p kr p fr lg \"tickrate\". ARC9 r bst nr du kr p minumum 20 tickrate (66+ rekommenderas)."
L["badconf.tickrate.solution"] = "Lsning: Om du r serverns gare, lgg till \"-tickrate 33\", eller det vrdet du vill anvnda, i serverns startkonfiguration."

L["badconf.matbumpmap.title"] = "mat_bumpmap avaktiverat"
L["badconf.matbumpmap.desc"] = "Du har avaktiverat \"bumpmaps\" vilket gr att vapen och modeller ser vrre ut. Det kan ocks pverka vissa ARC9-riktmedel."
L["badconf.matbumpmap.solution"] = "Lsning: I konsolen, skriv in \"mat_bumpmap 1\". Om du anvnder en \"FPS config\" s mste du hitta och ta bort \"mat_bumpmap 0\" frn \"autoexec.cfg\"."

L["badconf.addons.title"] = "Fr mnga tillgg! LUA-filbegrnsning ndd!"
L["badconf.addons.desc"] = "Du har installerat fr mnga tillgg och ntt LUA-filbegrnsningen. ARC9 har drfr inte kunnat laddas korrekt, vilket betyder att tillbehr kanske inte fungerar."
L["badconf.addons.solution"] = "Lsning: Avinstallera tyngre tillgg via spelets Tillgg meny, eller via Steam workshop (exempelvis andra vapenbaser, JMod, Entity-Tillgg, mm.)."

L["badconf.warning"] = "Varning! Din prestanda r ej optimal! - Markera fr att visa detaljer."
L["badconf.warning.desc"] = "Hgre FPS r alltid bst. Speciellt p vapenbaser som den hr.\n\nMarkera fremlen nedanfr fr att se lsningar."

L["badconf.x64.title"] = " Slig 32-Bitars branch Upptckt"
L["badconf.x64.desc"] = [[Du kr just nu Garry's Mod i 32-bitars. Detta begrnsar hur mycket prestanda du kan ha, ganska drastiskt.

Lsning: I Garry's Mods startinstllningar, g till "Betan", och byt till "x86-64 - Chromium + 64-bit binaries".

Googla "gmod x64" fr att hitta hjlp p ntet.]]

L["badconf.multicore.title"] = " Inga Multicore-Rendering Kommandon"
L["badconf.multicore.desc"] = [[Vissa multicore-rendering instllningar r fr tillfllat avstngda. Detta ger frvrrad spelprestanda.

Lsning: Du kan skriva in vissa kommandon in i autoexec.cfg

Google "gmod multicore" fr att hitta hjlp p ntet.

Alla kommandon som han ka prestandan:
gmod_mcore_test 1
mat_queue_mode 2
cl_threaded_bone_setup 1
cl_threaded_client_leaf_system 1
r_threaded_client_shadow_manager 1
r_threaded_renderables 1]]

////////////////////// Presets
L["customize.presets.atts"] = " Tillbehr"
L["customize.presets.back"] = "Tillbaka"
L["customize.presets.cancel"] = "Avbryt"
L["customize.presets.code"] = "Frinstll. Kod (Kopierad till Urklipp)"
L["customize.presets.default"] = "Standard"
L["customize.presets.default.long"] = "Standard frinstllning"
L["customize.presets.dumb"] = "r du korkad"
L["customize.presets.import"] = "Importera"
L["customize.presets.invalid"] = "Ogiltig strng!"
L["customize.presets.new"] = "Nytt Frinstll. Namn"
L["customize.presets.paste"] = "Klistra in Frinstll. Kod Hr"
L["customize.presets.random"] = "Slumpmssig"
L["customize.presets.save"] = "Spara"
L["customize.presets.unnamed"] = "Namnls"

L["customize.presets.deldef"] = "r du sker p att du vill plocka bort standard frinstllning \"{name}\"?"
L["customize.presets.deldef2"] = "Du kommer behva terstlla vapnet via tillverkare instllningar fr att f tillbaka den."
L["customize.presets.yes"] = "Ja"

////////////////////// Tips
L["tips.arc-9"] = "Det r ARC9, inte ARC-9, inte Arc9."
L["tips.blacklist"] = "Du kan svartlista tillbehr! Se ARC9 Workshop-beskrivningen fr mer information."
L["tips.bugs"] = "Rapportera buggar p den officiella Discord-servern, eller nnu bttre, ppna ett Github-problem."
L["tips.custombinds"] = "ARC9-knappkombinationer kan ersttas med anpassade knappar. Brja skriva in +arc9_ fr att hitta dem tillgngliga knapparna!"
L["tips.cyberdemon"] = "Fr att dda en terrorist s skjuter du honom tills han dr."
L["tips.description"] = "Vi freslr att du lser beskrivningen p tillggen innan du kommenterar."
L["tips.development"] = "Vill du skapa ARC9-innehll? Den officiella Discord-servern har massvis med resurser fr att hjlpa till!"
L["tips.discord"] = "G med Diamond Doves p Discord! Lnken r i ARC9-beskrivningen."
L["tips.external"] = "Om du anvnder Github-versionen av ARC9, frskra dig att du ofta uppdaterar den!"
L["tips.hints"] = "Behll ARC9-grnssnittet fr att se kontrolltips."
L["tips.lean"] = "Fr att manuellt luta p dig, koppla knappar till +alt1 och +alt2."
L["tips.love"] = "Tacka grna tillverkarna om du tycker om deras arbete! Det hjlper oss verkligen att fortstta framt."
L["tips.m9k"] = "Checka ut M9K-vapnen!"
L["tips.official"] = "Ladda endast ner ARC9 frn officiella kllor. Tredje part uppladdningar kan vara farliga eller frldrade!"
L["tips.presets"] = "Dela med dig av dina favorita frinstllningar med dina vnner genom att exportera dem!"
L["tips.settings"] = "Du kan stnga av dessa tips, och mycket mer, via ARC9-instllningarna. Klicka p knappen i topphgra hrnet!"
L["tips.tips"] = "Tips har en fast ordning. Fortstt lsa s ser du till sist allihopa."
L["tips.tolerance"] = "Alla vapenpaket fungerar bra tillsammans. Det finns ingen anledning fr favorisering."

////////////////////// Other
L["atts.favourites"] = "Favoriter"
L["atts.filter"] = "Filtrera"

/////////////////////////////////////// Settings menu
-- Use this method to localize convars in settings menu:
-- settings.convar.title = "Convar Title"
-- settings.convar.desc = "Convar Description"

L["settings.title"] = "ARC9-Instllningar"
L["settings.desc"] = "Beskrivning"

L["settings.default_convar"] = "Standard vrde"
L["settings.convar_server"] = "Servervariabel"
L["settings.convar_client"] = "Client-variabel"

////////////////////// General
L["settings.tabname.general"] = "Generellt"

L["settings.general.client"] = "Klient"
L["settings.language_id.title"] = "Sprk"
L["settings.language_id.desc"] = "Sprkpaket som anvnds till ARC9."
L["settings.truenames.title"] = "Sanna Namn"
L["settings.truenames.desc"] = "Vlj om vapnen ska anvnda riktiga namn eller fiktiva namn valda av utvecklarna. Notera att inte alla vapen anvnder detta.\n\nServerinstllningar kan verskrida denna preferens."
L["settings.resetsettings.cl.title"] = "terstll alla KLIENT instll."

L["settings.general.server"] = "Server"
L["settings.truenames_default.title"] = "Standard Sanna Namn"
L["settings.truenames_default.desc"] = "Stt standard sanna namn lget p servern. Alla spelare som anvnder \"Standard\" i preferensen kommer anvnda detta."
L["settings.truenames_enforced.title"] = "Standard Sanna Namn (Tvinga)"
L["settings.truenames_enforced.desc"] = "Vlj fr att tvinga alla spelare att anvnda serverinstllningen fr sanna namn."

L["settings.resetsettings.sv.title"] = "terstll alla SERVER instll."

L["settings.reset"] = "terstll!"

////////////////////// Performance
L["settings.tabname.performance"] = "Prestanda"

L["settings.performance.important"] = "Viktigt"
L["settings.cheapscopes.title"] = "Billiga Sikten"
L["settings.cheapscopes.desc"] = "En billig RT-sikte genomfrande genom att zooma in hela din vy nr du siktar istllet fr att framstlla vrlden igen i siktet. kar drastiskt prestandan p strre kartor."
L["settings.tpik.title"] = "TPIK"
L["settings.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) r ett system som tillter dem flesta vapen att visa detaljerade och oftast samma frsta person positioner, omladdning och skjut animationer i tredje person.\n\nKonfiguera den i Visuellt-fliken."
L["settings.allflash.title"] = "Alla Ficklampor"
L["settings.allflash.desc"] = "Framstll helt alla ficklampor frn alla spelare.\n\nVldigt dyr p servrar."

L["settings.performance.blur.title"] = "Sudd"
L["settings.cust_blur.title"] = "Anpassnings Bakgrund"
L["settings.cust_blur.desc"] = "Suddar ut anpassnings bakgrunden."
L["settings.fx_reloadblur.title"] = "Under Omladdning"
L["settings.fx_reloadblur.desc"] = "Suddar ut vrlden under omladdning."
L["settings.fx_animblur.title"] = "Under frberedelse"
L["settings.fx_animblur.desc"] = "Suddar ut vrlden nr ett vapen tas fram fr frsta gngen."
L["settings.fx_rtblur.title"] = "I Magnifierade Sikten"
L["settings.fx_rtblur.desc"] = "Suddar ut vrlden nr ett magnifierat sikte anvnds."
L["settings.fx_adsblur.title"] = "I Siktet"
L["settings.fx_adsblur.desc"] = "Suddar ut vrlden i siktet."
L["settings.fx_rtvm.title"] = "Visa vapnet genom RT-Sikten"
L["settings.fx_rtvm.desc"] = "! EXPERIMENTAL !\nVisar vapnet och dess tillbehr genom RT-sikten. Krver att \"Billiga Sikten\" r avstngt.\nSnker drastiskt prestandan."

L["settings.performance.shelleject.title"] = "Patron Utmatning"
L["settings.eject_fx.title"] = "Rkeffekter"
L["settings.eject_fx.desc"] = "Tillverkar rkeffekter frn spenderade patroner om vapnet stdjer denna funktion"
L["settings.eject_time.title"] = "Lgg Till Livstid"
L["settings.eject_time.desc"] = "Tillt att patroner hller sig kvar i vrlden lngre. Kan vara dyrt."

L["settings.performance.fx.title"] = "Effekter"
L["settings.muzzle_light.title"] = "Mynningseld"
L["settings.muzzle_light.desc"] = "Aktiverar ljus frn mynningseld nr du skjuter ett vapen."
L["settings.muzzle_others.title"] = "Andras Mynningseld"
L["settings.muzzle_others.desc"] = "Aktivera mynningseld effekter frn andra spelares vapen."

////////////////////// Optics
L["settings.tabname.optics"] = "Sikten"

L["settings.optics.control"] = "Kontroll"
L["settings.optics.sensmult.title"] = "Mult. Knslighet i Siktet"
L["settings.optics.sensmult.desc"] = "Multiplicerar titta runt knsligheten med detta antal i siktet.\nJu lgre vrdet r ju lgre r knsligheten.\nAnvndbar nr kontroller anvnds, eller om anvndaren vill ha lgre knslighet i siktet."
L["settings.optics.compensate_sens.title"] = "Kompensera Knslighet"
L["settings.optics.compensate_sens.desc"] = "Kompensera knsligheten fr magnifiering."
L["settings.optics.toggleads.title"] = "Vxla Sikte"
L["settings.optics.toggleads.desc"] = "Anvndning av sikten vxlas."

L["settings.optics.dtap_sights.title"] = "Dubbeltryck fr att Vxla Sikten"
L["settings.optics.dtap_sights.desc"] = "Tillter dubbeltryckning av USE-knappen fr att vxla sikten."

L["settings.optics.color"] = "Frg"
L["settings.optics.reflex.title"] = "Reflexsikten"
L["settings.optics.reflex.desc"] = "Frg att anvnda fr reflex-/holografiska sikten.\n\nInte alla sikten stdjer denna funktion."
L["settings.optics.scope.title"] = "Kikarsikten"
L["settings.optics.scope.desc"] = "Frg att anvnda fr magnifierade sikten.\n\nInte alla sikten stdjer denna funktion."

////////////////////// Crosshair
L["settings.tabname.crosshair"] = "Hrkors"

L["settings.crosshair.crosshair"] = "Hrkors"
L["settings.crosshair.cross_enable.title"] = "Aktivera Hrkors"
L["settings.crosshair.cross_enable.desc"] = "Aktiverar hrkorset. Vissa sikten tillter inte dig att anvnda hrkorset."
L["settings.crosshair.cross.title"] = "Hrkors Frg"
L["settings.crosshair.cross.desc"] = "Hrkorsets frg."
L["settings.crosshair.cross_size_mult.title"] = "Hrkors Frg"
L["settings.crosshair.cross_size_mult.desc"] = "Multiplicera storleken p ditt hrkors."
L["settings.crosshair.cross_size_dot.title"] = "Punktstorlek"
L["settings.crosshair.cross_size_dot.desc"] = "Multiplicera storleken p den mittersta punkten."
L["settings.crosshair.cross_size_prong.title"] = "Klostorlek"
L["settings.crosshair.cross_size_prong.desc"] = "Multiplicera storleken p de yttre klorna."
L["settings.crosshair.crosshair_static.title"] = "Statiskt Hrkors"
L["settings.crosshair.crosshair_static.desc"] = "Aktiverar en statisk hrkors som inte frflyttar sig under skjutning."
L["settings.crosshair.crosshair_force.title"] = "Tvinga Hrkors"
L["settings.crosshair.crosshair_force.desc"] = "Tvingar att hrkorset visas p vapen som inte vill att du ser den.\n\nServerinstllning."
L["settings.crosshair.crosshair_target.title"] = "Rtt Hrkors p Mltavla"
L["settings.crosshair.crosshair_target.desc"] = "Gr hrkorset rtt nr man siktar p en mltavla.\nAktiverar ocks sikthjlp om den r pslagen."
L["settings.crosshair.crosshair_peeking.title"] = "Visa Hrkors nr man Kikar"
L["settings.crosshair.crosshair_peeking.desc"] = "Visar hrkorset nr man r i siktet och anvnder kika funktionen."

////////////////////// Customization
L["settings.tabname.hud_cust"] = "Anpassning"

L["settings.hud_cust.hud"] = "Grnssnitt"
L["settings.hud_cust.hud_scale.title"] = "Grnssnitt Skala"
L["settings.hud_cust.hud_scale.desc"] = "Skalmodifierare fr ARC9-grnssnittet."
L["settings.hud_cust.hud_deadzonex.title"] = "Grns. Bredd Ddszon"
L["settings.hud_cust.hud_deadzonex.desc"] = "Horisontell \"ddszon\" fr anpassningsmenyn och grnssnitt panelen.\nAnvndbra fr ultrawide-skrmar."
L["settings.hud_cust.hud_color.title"] = "Grnssnitt Frg"
L["settings.hud_cust.hud_color.desc"] = "Markerar frgen fr grnssnittet.\nAccentfrgen."
L["settings.hud_cust.hud_holiday.title"] = "Hgtidsteman"
L["settings.hud_cust.hud_holiday.desc"] = "Teman som aktiverar under vissa hgtider.\nSkriver ver grnssnitt frger"
L["settings.hud_cust.hud_darkmode.title"] = "Mrkt Tema"
L["settings.hud_cust.hud_darkmode.desc"] = "Aktiverar mrka frger p grnssnittet istllet fr ljusgrtt och avaktiverar vinjetteffekten i bakgrunden."
L["settings.hud_cust.cust_light.title"] = "Aktivera Ljus"
L["settings.hud_cust.cust_light.desc"] = "Aktiverar vapenljus i anpassnings menyn.\n\nSamma som knappen nra instllningar knappen."
L["settings.hud_cust.cust_light_brightness.title"] = "Ljusstyrka fr ljus"
L["settings.hud_cust.cust_light_brightness.desc"] = "Hur starkt ljuset kommer vara i anpassnings panelen.\n\nGlm inte att stta p den frst!"

L["settings.hud_cust.customization"] = "Anpassning"
L["settings.hud_cust.cust_hints.title"] = "Knapptips"
L["settings.hud_cust.cust_hints.desc"] = "Aktivera knapptips i anpassnings menyn."
L["settings.hud_cust.cust_tips.title"] = "Tips"
L["settings.hud_cust.cust_tips.desc"] = "Tips om ARC9-basen nra knapptipsen."
L["settings.hud_cust.cust_exit_reset_sel.title"] = "Stngning terstller Val"
L["settings.hud_cust.cust_exit_reset_sel.desc"] = "Stngning av anpassnings menyn terstller den aktiva valda platsen."
L["settings.hud_cust.imperial.title"] = "Brittiska mttenheter"
L["settings.hud_cust.imperial.desc"] = "Erstter diverse mttenhetsystem med deras Brittiska varianter.\nGller endast i \"Stats & Ballistik\" anpassningsskrmen."

////////////////////// Game HUD
L["settings.tabname.hud_game"] = "Spelgrnssnitt"

L["settings.hud_game.lcd"] = "LCD-Panel"
L["settings.hud_game.hud_arc9.title"] = "Aktivera Grnssnitt"
L["settings.hud_game.hud_arc9.desc"] = "Aktiverar grnssnittet p ARC9-vapen."
L["settings.hud_game.hud_always.title"] = "P alla vapen"
L["settings.hud_game.hud_always.desc"] = "Aktiverar grnssnittet p alla vapen."
L["settings.hud_game.hud_compact.title"] = "Kompaktlge"
L["settings.hud_game.hud_compact.desc"] = "Kompakt utseende fr grnssnitt panelen."
L["settings.hud_game.hud_nohints.title"] = "Avaktivera Tips"
L["settings.hud_game.hud_nohints.desc"] = "Avaktiverar tips helt och hllet. Dem kommer inte visas upp i 3D eller 2D grnssnittet."
L["settings.hud_game.hud_keephints.title"] = "Behll Tips"
L["settings.hud_game.hud_keephints.desc"] = "Visa ARC9-kontroll tipsen p toppen av grnssnitt panelen."
L["settings.hud_game.hud_force_disable.title"] = "Tvinga Av ARC9 Grnssnitt"
L["settings.hud_game.hud_force_disable.desc"] = "Stnger av ARC9 Grnssnittet till alla spelare. Gller ej fr knapptips."

L["settings.hud_game.killfeed"] = "Killfeed"
L["settings.hud_game.killfeed_enable.title"] = "Killfeed-Ikoner"
L["settings.hud_game.killfeed_enable.desc"] = "Aktivera automatisk generering av killfeed-ikoner p ARC9-vapen."
L["settings.hud_game.killfeed_dynamic.title"] = "Dynamisk uppdatering"
L["settings.hud_game.killfeed_dynamic.desc"] = "Killfeed-ikoner genereras om efter varje ddad.\n\nStng av om du vill ha den dr 0.1 FPS:en."
L["settings.hud_game.killfeed_colour.title"] = "Fullfrgade Ikoner"
L["settings.hud_game.killfeed_colour.desc"] = "Dem dynamiskt skapade ikonerna r fullfrgade."

L["settings.hud_game.breath"] = "Anda"
L["settings.hud_game.breath_hud.title"] = "Andning Grnssnitt"
L["settings.hud_game.breath_hud.desc"] = "Visar en stng som visar din kvarstende andetag nr du stabiliserar ditt vapen i siktet."
L["settings.hud_game.breath_pp.title"] = "Andning Efterbehandling"
L["settings.hud_game.breath_pp.desc"] = "Hlla andan lgger ocks till ett efterbehandling effekt p skrmen."
L["settings.hud_game.breath_sfx.title"] = "Andning Ljudeffekt"
L["settings.hud_game.breath_sfx.desc"] = "Hlla andan spelar ocks associerade ljudeffekter."

L["settings.hud_game.centerhint"] = "Verktygstips"
L["settings.hud_game.centerhint_reload.title"] = "Visa Omladdning Tips"
L["settings.hud_game.centerhint_reload.desc"] = "Visar ett omladdning tips nr ammunition r lgt."
L["settings.hud_game.centerhint_reload_percent.title"] = "Magasinprocent"
L["settings.hud_game.centerhint_reload_percent.desc"] = "Visar omladdningstipset nr det nuvarande magasinet r vid detta procentvrde."
L["settings.hud_game.centerhint_bipod.title"] = "Visa Vxla Skjutstd"
L["settings.hud_game.centerhint_bipod.desc"] = "Visa ett tips nr skjutstdet kan vxlas."
L["settings.hud_game.centerhint_jammed.title"] = "Visa Eldavbrott Tips"
L["settings.hud_game.centerhint_jammed.desc"] = "Visar ett tips nr ditt vapen har ftt ett eldavbrott."

L["settings.hud_game.centerhint_firemode.title"] = "Visa Skjutlgestips"
L["settings.hud_game.centerhint_firemode.desc"] = "Visar ett tips nr du vxlar skjutlgen eller vxlar din skring."
L["settings.hud_game.centerhint_firemode_time.title"] = "Visa Skjutlgestips Tid"
L["settings.hud_game.centerhint_firemode_time.desc"] = "Hur lnge skjutlget ska visas."

L["settings.hud_game.centerhint_overheat.title"] = "Visa verhettningstips"
L["settings.hud_game.centerhint_overheat.desc"] = "Visar ett verlgg tips som visar hur nra vapnet r att verhettas.\n\nVisas ej om ARC9-grnssnittet r aktivt eller vapnet inte stdjet verhettning."

L["settings.hud_game.hud_glyph"] = "Sortens Glyfer"

L["settings.hud_game.hud_glyph_type_hud.title"] = "Grnssnitt"
L["settings.hud_game.hud_glyph_type_hud.desc"] = "ndrar vilken familj av glyfer du vill anvnda.\nDetta gller fr grnssnittens tips."

L["settings.hud_game.hud_glyph_type_cust.title"] = "Anpassningsmeny"
L["settings.hud_game.hud_glyph_type_cust.desc"] = "ndrar vilken familj av glyfer du vill anvnda.\nDetta gller fr anpassningsmenyns tips.\nndringar tillmpas nsta gng anpassnignsmenyn ppnas."

L["settings.hud_game.hud_glyph_light"] = "Ljusa"
L["settings.hud_game.hud_glyph_dark"] = "Mrka"
L["settings.hud_game.hud_glyph_knockout"] = "\"Knockout\""

////////////////////// NPCs
L["settings.tabname.npc"] = "NPC:er"

L["settings.npc.weapons"] = "NPC Vapen"
L["settings.npc.npc_equality.title"] = "Skadejmlikhet"
L["settings.npc.npc_equality.desc"] = "NPC:er gr lika mycket skada som spelare gr.\n\nDetta r en servervariabel."
L["settings.npc.npc_spread.title"] = "NPC Spridning"
L["settings.npc.npc_spread.desc"] = "Multiplikator fr hur otrffskra NPC:er r nr de skjuter."
L["settings.npc.npc_atts.title"] = "Ge Tillbehr"
L["settings.npc.npc_atts.desc"] = "Spawnade eller upplockade ARC9-vapen ger en slumpmssig samling tillbehr.\n\nDetta r en servervariabel."
L["settings.npc.npc_autoreplace.title"] = "Erstt NPC Vapen"
L["settings.npc.npc_autoreplace.desc"] = "Erstter NPC:ernas vapen med slumpmssigt valda ARC9-vapen.\n\nDetta r en servervariabel."
L["settings.npc.replace_spawned.title"] = "Erstt Markvapen"
L["settings.npc.replace_spawned.desc"] = "Erstter karta/spawnade HL2 vapen med slumpmssigt valda ARC9-vapen.\n\nDetta r en servervariabel."
L["settings.npc.npc_give_weapons.title"] = "Spelare Kan Ge Vapen"
L["settings.npc.npc_give_weapons.desc"] = "Spelare kan trycka p E p NPC:er fr att kunna ge de deras vapen.\n\nDetta r en servervariabel."

////////////////////// Gameplay
L["settings.tabname.gameplay"] = "Spel"

L["settings.gameplay.controls"] = "Kontroller"
L["settings.gameplay.toggleads.title"] = "Vxla Sikte"
L["settings.gameplay.toggleads.desc"] = "Anvndning av sikten vxlas."
L["settings.gameplay.autolean.title"] = "Automatisk Lutning"
L["settings.gameplay.autolean.desc"] = "Frsker automatiskt luta i siktet nr mjligt."
L["settings.gameplay.autoreload.title"] = "Automatisk Omladdning"
L["settings.gameplay.autoreload.desc"] = "Tomma ARC9-vapen kommer automatiskt laddas om."
L["settings.gameplay.togglelean.title"] = "Vxla Lutning"
L["settings.gameplay.togglelean.desc"] = "Tryck p luta-knapparna kommer vxla lutningen istllet fr att den behvs hllas inne."
L["settings.gameplay.togglepeek.title"] = "Vxla Kikande"
L["settings.gameplay.togglepeek.desc"] = "Tryck p kika-knapparna kommer vxla kikandet istllet fr att den behvs hllas inne."
L["settings.gameplay.togglepeek_reset.title"] = "terstll Kikande Status Efter Sikte"
L["settings.gameplay.togglepeek_reset.desc"] = "(Endast om Vxla Kikande r p)\nKik-status kommer inte behllas efter du gr ur siktet."
L["settings.gameplay.togglebreath.title"] = "Vxla Hlla Andan"
L["settings.gameplay.togglebreath.desc"] = "Att trycka p Hlla Andan-knappen kommer vxla Hlla Andan istllet fr att den krvs att hllas ner."

L["settings.gameplay.mechanics"] = "Spelfunktioner"
L["settings.gameplay.infinite_ammo.title"] = "Ondlig Ammo"
L["settings.gameplay.infinite_ammo.desc"] = "Vapen fr ondligt med ammo.\n\nDetta r en servervariabel."
L["settings.gameplay.realrecoil.title"] = "Fysisk Visuell Rekyl"
L["settings.gameplay.realrecoil.desc"] = "Valda vapen uppsatta fr denna funktion fr fysisk mynningstigning, vilket betyder att dem skjuter dit deras viewmodel visar istllet fr skrmens center. Vldigt viktigt fr vissa vapenpakes balansering.\n\nDetta r en servervariabel."
L["settings.gameplay.lean.title"] = "Lutning"
L["settings.gameplay.lean.desc"] = "Om spelare kan luta med +alt1 och +alt2, inklusive automatisk lutning.\n\nDetta r en servervariabel."
L["settings.gameplay.mod_sway.title"] = "Svngning"
L["settings.gameplay.mod_sway.desc"] = "Vapen kommer svnga om de r uppsatta att anvnda det.\n\nDetta r en servervariabel."
L["settings.gameplay.mod_freeaim.title"] = "Fritt Sikte"
L["settings.gameplay.mod_freeaim.desc"] = "Vapen kommer f fritt sikte och kommer inte alltid skjuta p skrmens mitt.\n\nDetta r en servervariabel."
L["settings.gameplay.mod_bodydamagecancel.title"] = "Kroppsskada Avbrytning"
L["settings.gameplay.mod_bodydamagecancel.desc"] = "Avbryt standard kroppsskada modifierare. Avaktivera endast om en annan modd erbjuder denna sorts funktion\nex. Moddar som ndrar standard lem modifierare.\n\nDetta r en servervariabel."
L["settings.gameplay.breath_slowmo.title"] = "Slow-Mo Andning"
L["settings.gameplay.breath_slowmo.desc"] = "Hlla andan saktar ner tiden.\n\nEndast Singleplayer."
L["settings.gameplay.manualbolt.title"] = "Manuell Cykel"
L["settings.gameplay.manualbolt.desc"] = "Cylinderrepeter vapen konfiguerademed denna funktion laddarendast om nr R tryckas ner och inte nr attack-knappen slpps."
L["settings.gameplay.never_ready.title"] = "Inga \"Redo\" Anim."
L["settings.gameplay.never_ready.desc"] = "Avaktivera \"Redo\" animationer nr du tar fram ett vapen.\n\nDetta r en servervariabel."
L["settings.gameplay.recoilshake.title"] = "Rekyl skakning i synflt"
L["settings.gameplay.recoilshake.desc"] = "Knpper synfltet under skjutning"
L["settings.gameplay.equipment_generate_ammo.title"] = "Unik Ammo Typ fr Utrustning"
L["settings.gameplay.equipment_generate_ammo.desc"] = "Det finns en begrnsning p 255 ammo typer och avaktiverar du detta alternativ kan det fixa ngra problem ifall du har mnga tillgg.\n\nDetta r en servervariabel.\n\nKrver omstart."

-- ??
L["settings.gameplay.mult_defaultammo.title"] = "Standard Reserv Ammo"
L["settings.gameplay.mult_defaultammo.desc"] = "Hur mnga magasin/granater/utrustning som ges till spelaren nr hen plockar upp ett vapen fr frsta gngen?\n\nDetta r en servervariabel."
L["settings.gameplay.nearwall.title"] = "Nra Vggen"
L["settings.gameplay.nearwall.desc"] = "Tillt inte att vapnet skjuts nr du str fr nra en vgg eller ett hinder."

////////////////////// Visuals
L["settings.tabname.visuals"] = "Visuellt"

L["settings.visuals.viewmodel"] = "Viewmodel"
L["settings.visuals.vm_bobstyle.title"] = "Gupp Stil"
L["settings.visuals.vm_bobstyle.desc"] = "Vlj olika gupp stilar till smaken av olika medlemmar av ARC9-teamet (och valve software)."
L["settings.visuals.fov.title"] = "Synflt"
L["settings.visuals.fov.desc"] = "Lgg till vymodell synflt. Gr vymodellen strre eller mindre. Anvnd ansvarsfullt."
L["settings.visuals.vm_addx.title"] = "Lgg till X"
L["settings.visuals.vm_addx.desc"] = "Flyttar vymodellen till vnster eller hger."
L["settings.visuals.vm_addy.title"] = "Lgg till Y"
L["settings.visuals.vm_addy.desc"] = "Flyttar vymodellen fram- eller bakt."
L["settings.visuals.vm_addz.title"] = "Lgg till Z"
L["settings.visuals.vm_addz.desc"] = "Flyttar vymodellen upp eller ner."

L["settings.visuals.cambob"] = "Vy Guppande"
L["settings.visuals.vm_cambob.title"] = "Spring Vy Guppande"
L["settings.visuals.vm_cambob.desc"] = "Gr att din kamera frflyttar sig nr du springer"
L["settings.visuals.vm_cambobwalk.title"] = "G Vy Guppande"
L["settings.visuals.vm_cambobwalk.desc"] = "Gr att din kamera ltt frflyttar sig nr du gr runt (krver spring guppande)"
L["settings.visuals.vm_cambobintensity.title"] = "Intensitet"
L["settings.visuals.vm_cambobintensity.desc"] = "Hur intensiv guppandet r"

L["settings.visuals.tpik"] = "TPIK"
L["settings.visuals.tpik.title"] = "Aktivera TPIK"
L["settings.visuals.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) r ett system tom tillter dem flesta vapen att visa detaljerade och oftast samma frsta person positioner, omladdning och skjut animationer i tredje person."
L["settings.visuals.tpik_others.title"] = "Andra Spelares TPIK"
L["settings.visuals.tpik_others.desc"] = "Visa TPIK p andra spelare frutom dig sjlv. Pverkar prestandan negativt."
L["settings.visuals.tpik_framerate.title"] = "TPIK-Bildhastighet"
L["settings.visuals.tpik_framerate.desc"] = "Maximal bildhastighet d TPIK kan kras. Stt till 0 fr ondlig."

////////////////////// Bullet Physics
L["settings.tabname.bullets"] = "Skottfysik"

L["settings.bullets.bullets"] = "Skottfysik"
L["settings.bullets.bullet_physics.title"] = "Fysiska Skott"
L["settings.bullets.bullet_physics.desc"] = "Vapen som stdjer denna funktion kommer skjuta fysiska skott, som har avslpp, restid och motstnd.\n\nDetta r en servervariabel."
L["settings.bullets.bullet_gravity.title"] = "Gravitation"
L["settings.bullets.bullet_gravity.desc"] = "Multiplikator fr skott gravitation.\n\nDetta r en servervariabel."
L["settings.bullets.bullet_drag.title"] = "Motstnd"
L["settings.bullets.bullet_drag.desc"] = "Multiplikator fr skottmotstnd.\n\nDetta r en servervariabel."
L["settings.bullets.ricochet.title"] = "Rikoschett"
L["settings.bullets.ricochet.desc"] = "Skott skjutna frn valda vapen kan ibland studsa av ytor och fortstta att resa och gra skada.\n\nDetta r en servervariabel."
L["settings.bullets.mod_penetration.title"] = "Penetration"
L["settings.bullets.mod_penetration.desc"] = "Skott skjutna frn valda vapen kan penetrera ytor och gra skada till vad som finns p andra sidan.\n\nDetta r en servervariabel."
L["settings.bullets.bullet_lifetime.title"] = "Livstid"
L["settings.bullets.bullet_lifetime.desc"] = "Tid i sekunder d ett skott ska plockas bort.\n\nDetta r en servervariabel."
L["settings.bullets.bullet_imaginary.title"] = "Inbillade Skott"
L["settings.bullets.bullet_imaginary.desc"] = "Skott ser ut att de flyger till skyboxen, frbi kartans grnser."

////////////////////// Attachments
L["settings.tabname.attachments"] = "Tillbehr"

L["settings.attachments.customization"] = "Anpassning"
L["settings.attachments.atts_nocustomize.title"] = "Avaktivera Anpassning"
L["settings.attachments.atts_nocustomize.desc"] = "Tillter ingen mer anpassning via anpassnings menyn.\n\nDetta r en servervariabel."
L["settings.attachments.atts_max.title"] = "Max. Tillbehr"
L["settings.attachments.atts_max.desc"] = "Maximalt antal tillbehr som kan utrustas p ett vapen, inklusive kosmetiska tillbehr.\n\nDetta r en servervariabel."
L["settings.attachments.autosave.title"] = "Autospar"
L["settings.attachments.autosave.desc"] = "Ditt sista vapens anpassningsinstllningar kommer sparas och automatiskt utrustas nsta gng du spawnar det vapen."
L["settings.attachments.blacklist.title"] = "Svartlista Meny"
L["settings.attachments.blacklist.open"] = "ppna"

L["settings.attachments.inventory"] = "Lager"
L["settings.attachments.free_atts.title"] = "Gratis Tillbehr"
L["settings.attachments.free_atts.desc"] = "Tillbehr kan anvndas utan att plockas upp frst.\n\nDetta r en servervariabel."
L["settings.attachments.atts_lock.title"] = "En Fr Alla"
L["settings.attachments.atts_lock.desc"] = "Nr du plockar upp ett tillbehr s kan du anvnda den ondligt mnga gnger p alla dina vapen.\n\nDetta r en servervariabel."
L["settings.attachments.atts_loseondie.title"] = "Frlora Vid Dd"
L["settings.attachments.atts_loseondie.desc"] = "Ditt tillbehrlager frloras nr du dr.\n\nDetta r en servervariabel."
L["settings.attachments.atts_generateentities.title"] = "Generera Entiteter"
L["settings.attachments.atts_generateentities.desc"] = "Generera entiteter som kan spawnas som tillter dig att plockas upp tillbehr nr gratis tillbehr r avaktiverade.\n\nKan ka laddtiden.\n\nDetta r en servervariabel."

////////////////////// Modifiers
L["settings.tabname.modifiers"] = "Modifierare"

L["settings.modifiers.quick.title"] = "Snabbstatistik Modifierare"
L["settings.modifiers.quick.desc"] = " "

L["settings.mod_damage.title"] = "Skada"
L["settings.mod_spread.title"] = "Spridning"
L["settings.mod_recoil.title"] = "Rekyl"
L["settings.mod_visualrecoil.title"] = "Visuell Rekyl"
L["settings.mod_adstime.title"] = "Res/Snk Sikte Tid"
L["settings.mod_sprinttime.title"] = "Spring-till-Sikte Tid"
L["settings.mod_damagerand.title"] = "Skadevariering"
L["settings.mod_muzzlevelocity.title"] = "Utgngshastighet"
L["settings.mod_rpm.title"] = "Eldhastighet"
L["settings.mod_headshotdamage.title"] = "Huvudskott Skada"
L["settings.mod_malfunction.title"] = "Felfunktion Chans"

////////////////////// Controller
L["settings.tabname.controller"] = "Kontroller"

L["settings.controller.misc"] = "Annat"
L["settings.controller.misc.desc"] = "Det borde vara en knapp fr att ppna panelen med avancerad kontroller konfiguering, men fr tillfllet r det Spawnmeny > Options > ARC9 > Kontroller."
L["settings.controller.controller.title"] = "Kontroller Glyfer"
L["settings.controller.controller.desc"] = "Aktiverar anpassade kontroller-kompatibla glyfer som visar kontroller knappar istllet fr standard knappar."
-- L["settings.controller.controller_rumble.title"] = "Rumble"
-- L["settings.controller.controller_rumble.desc"] = "Enable controller rumble as long as Fesiug's DLL mod is loaded.\n\ngithub.com/Fesiug/\ngmod-sinput"
L["settings.controller.controller_config.title"] = "Avancerad konfig."
L["settings.controller.controller_config.content"] = "ppna panel"
L["settings.controller.controller_config.desc"] = "ppna avancerad kontroller konfigurering panel."

L["settings.controller.glyphs.title"] = "Familj av Glyfer"
L["settings.controller.glyphs.desc"] = "Vlj frn vilken familj av glyfer du vill anvnda.\nStt upp glyfer i \"Spawnmeny\" > Options > ARC9 > Controller."

////////////////////// Aim Assist
L["settings.tabname.aimassist"] = "Siktehjlp"
L["settings.tabname.aimassist.desc"] = "Du kan aktivera siktehjlp om du har problem att hlla ditt sikte p din mltavla, eller om du fredrar att inte anstrnga dig nr du skjuter p dina mltavlor."

L["settings.aimassist.enable.title"] = "Aktivera Siktehjlp"
L["settings.aimassist.enable.desc"] = "Aktiverar en siktehjlp som frflyttar din vy mot en mltavla nr du siktar nra dem.\n\nDetta r en servervariabel.\n\nKrver att Siktehjlp r aktiverad p CLIENT."

L["settings.aimassist.enable_general.desc"] = "Aktiverar en siktehjlp som frflyttar din vy mot en mltavla nr du siktar nra dem.\n\nKonfiguera den i \"Siktehjlp\"-fliken."

L["settings.aimassist.enable_client.desc"] = "Aktiverar en siktehjlp som frflyttar din vy mot en mltavla nr du siktar nra dem.\n\nKrver att Siktehjlp r aktiverad p SERVER."

L["settings.aimassist.intensity.title"] = "Kraft"
L["settings.aimassist.intensity.desc"] = "Hur kraftfull siktehjlpen r.\n\nDetta r en servervariabel."

L["settings.aimassist.cone.title"] = "Kon"
L["settings.aimassist.cone.desc"] = "Hur nra eller hur lngt borta du mste titta p en mltavla innan siktehjlpen aktiveras.\n\nDetta r en servervariabel."

L["settings.aimassist.head.title"] = "Ls mot huvud"
L["settings.aimassist.head.desc"] = "Om siktehjlpen ska lsa sig mot mltavlans huvud istllet fr dess brst.\n\nDetta r en servervariabel."

L["settings.aimassist.sensmult.desc"] = "Multiplicerar titta runt knsligheten med detta antal nr du siktar p en giltig mltavla.\nJu lgre vrdet r ju lgre r knsligheten."

////////////////////// Asset Caching
L["settings.tabname.caching"] = "Tillgng-Cache"
L["settings.caching.title"] = "Tillgng-Cache"
L["settings.caching.desc"] = "Du kan cacha ngra ARC9-tillgngar (spara i minnet utan att ladda nr du spelar) fr att frhindra stamning fr en bra spel upplevelse!\n\nDu borde skert aktivera ngra grejer om ditt GMod spelas p en HDD."

L["settings.caching.precache_sounds_onfirsttake.title"] = "P frsta upplock: Cache vapenljud"
L["settings.caching.precache_sounds_onfirsttake.desc"] = "Cache alla ljud endast fr det vapnet du tar upp i handen (frutom omladdning ljud).\n\nInte vldigt effektfull men kan hjlpa att frhindra stamning nr man skjuter."

L["settings.caching.precache_attsmodels_onfirsttake.title"] = "P frsta upplock: Cache alla tillbehr"
L["settings.caching.precache_attsmodels_onfirsttake.desc"] = "Cache alla ARC9-tillbehr modeller nr ett ARC9-vapen r i hnderna.\n\nOrsakar en stor frysning, speciellt nr du har mnga vapen."
L["settings.caching.precache_wepmodels_onfirsttake.title"] = "P frsta upplock: Cache alla vapenmodeller"
L["settings.caching.precache_wepmodels_onfirsttake.desc"] = "Cache alla ARC9-vapen viewmodeller nr ett ARC9-vapen r i hnderna.\n\nOrsakar en MASSIV frysning, speciellt nr du har mnga vapen."

L["settings.caching.precache_allsounds_onstartup.title"] = "P spelstart: Cache alla vapenljud"
L["settings.caching.precache_allsounds_onstartup.desc"] = "Cache alla ljud frn alla vapen vid serverstart (frutom omladdning ljud).\n\nInte vldigt effektfull men det r bttre att du anvnder frsta alternativet hr."
L["settings.caching.precache_attsmodels_onstartup.title"] = "P spelstart: Cache alla tillbehr"
L["settings.caching.precache_attsmodels_onstartup.desc"] = "Cache alla ARC9-tillbehr modeller vid serverstart.\n\nOrsakar vldigt hgt kad laddningstid, speciellt nr du har mnga vapen."
L["settings.caching.precache_wepmodels_onstartup.title"] = "P spelstart: Cache alla vapenmodeller"
L["settings.caching.precache_wepmodels_onstartup.desc"] = "Cache alla ARC9-vapen viewmodeller vid serverstart.\n\nOrsakar VLDIGT kad laddningstid, speciellt nr du har mnga vapen."

L["settings.caching.precache_allsounds.title"] = "Alla vapenljud"
L["settings.caching.precache_wepmodels.title"] = "Alla vapenmodeller"
L["settings.caching.precache_attsmodels.title"] = "Alla tillbehr modeller"

L["settings.developer.cache"] = "Cache"

////////////////////// Developer
L["settings.tabname.developer"] = "Tillverkare"

L["settings.developer.developer"] = "Tillverkare Instll."
L["settings.developer.dev_always_ready.title"] = "Alltid Redo"
L["settings.developer.dev_always_ready.desc"] = "Spela alltid \"redo\"-animationen nr du tar fram ett vapen.\n\nDetta r en servervariabel."
L["settings.developer.dev_benchgun.title"] = "Benchgun"
L["settings.developer.dev_benchgun.desc"] = "Behll vapnet dr den fr tillfllet r."
L["settings.developer.dev_crosshair.title"] = "Tillv. Hrkors"
L["settings.developer.dev_crosshair.desc"] = "Ett konstigt hrkors som visar exakt sikte pukt och ngra anvndbara nummer.\n\nDetta r en servervariabel och fungerar endast fr admins - frsk inte fuska med detta!"
L["settings.developer.dev_show_affectors.title"] = "Visa Affectors"
L["settings.developer.dev_show_affectors.desc"] = "Visar nuvarande affectors som tillmpas.\n\nKrver \"Tillv. Hrkors\"."
L["settings.developer.dev_show_shield.title"] = "Visa Skld"
L["settings.developer.dev_show_shield.desc"] = "Visa modellen fr spelarens skld."
L["settings.developer.dev_greenscreen.title"] = "Grn Skrm"
L["settings.developer.dev_greenscreen.desc"] = "Visar en grn skrm bakgrund i anpassningsmenyn fr skrmbilder.\n\nOm du anvnder HDR, glm inte att stta mat_bloom_scalefactor_scalar till 0!"
L["settings.developer.reloadatts.title"] = "Ladda om Tillbehr"
L["settings.developer.reloadlangs.title"] = "Ladda om Sprk"
L["settings.developer.dev_listmyatts.title"] = "Lista Mina Tillbehr"
L["settings.developer.dev_listanims.title"] = "Lista Anim."
L["settings.developer.dev_listbones.title"] = "Lista Ben"
L["settings.developer.dev_listbgs.title"] = "Lista Bodygroups"
L["settings.developer.dev_listatts.title"] = "Lista QCAttachments"
L["settings.developer.dev_export.title"] = "Skaffa Export Kod"
L["settings.developer.dev_getjson.title"] = "Skaffa Vapen JSON"

L["settings.developer.presets_clear.title"] = "Rensa vapendata"
L["settings.developer.presets_clear.desc"] = "Rensar frinstllningar, alla ikoner och standard frinstllningar fr vapnet du hller i.\n\nVarning: om menyn r ppnad utan ett ARC9-vapen i hnderna s kommer den plocka bort alla ARC9-frinstllningar och ikoner!"

L["settings.developer.clear"] = "Rensa"
L["settings.developer.print"] = "Skriv till Konsol"
L["settings.developer.reload"] = "Ladda Om"

////////////////////// ARC9 Premium
L["premium.title"] = "ARC9 Premium"
L["premium.desc"] = "ARC9 Premium tillter mer anpassning som ett stort tack fr att ha stttat tillgget finansiellt."

L["premium.requires"] = "Krver <color=255,106,0>ARC9 Premium</color>."
L["premium.acquire"] = "Prenumerera till <color=255,106,0>ARC9 Premium</color>"

L["premium.ownedno"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Ej gd</color>"
L["premium.owned"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>gd</color>"

L["premium.help"] = "Vad r ARC9 Premium?"
L["premium.help.header"] = "Guide till ARC9 Premium"
L["premium.help.desc"] = "Creating addons takes time and resources. ARC9 has always been available for free, and it will remain that way. However, if you wish to support the base financially, you may do so, and get rewarded for it!"

L["premium.help.ownedbutnoaccess"] = "Have you recently purchased ARC9 Premium, but do not have automatic access to it? Contact us on the Diamond Doves Discord Server for assistance.\nEnsure you can provide proof of purchase before contacting. Simply saying \"I buy, now give\" is not good enough."

L["premium.content"] = "Inkluderat i <color=255,106,0>ARC9 Premium</color>:"
L["premium.content.list"] = [[
- Ondliga Anpassningsplatser (kat frn 32)
- Ondliga Frinstllningar (kat frn 10 per vapen)
- Tillgng till "Supermodifier"-instllningar*
- Tillgng till exklusivt Mrkt Grnssnittlge
- Frmga att frga riktmedel hrkors, grnssnitt och mer
- Exklusiva kamouflage gjort tillgngliga via basen
- Exklusiv supportkanal p Discord

*Krver administratr p servrar
]]

L["premium.payment.month"] = [[
$%s
Skaffa ARC9 Premium i 1 Mnad.
]]

L["premium.payment.months"] = [[
$%s
Skaffa ARC9 Premium i %s Mnader och f <color=100,255,100>%s%% rabatt</color>!
]]

L["premium.payment.info"] = [[
Kp av ARC9 Premium ger omedelbar tillgng till all innehll som visats innan efter kp.
Tid kan frlngas genom att kpa valfritt alternativ en gng till, och tiden ndras automatiskt nr originaltiden har gtt ut.
Nr tiden har gtt ut, och ingen tillagd betalning har gjorts, s tas tillgng till ARC9 Premium bort.

All anpassningsalternativ, inklusive anpassningsplatser, frinstllningar och frgade hrkors gjorda med ARC9 Premium kommer fortstta vara tillgngliga, men du kan inte lngre ndra dem eller lgga till fler.
]]

L["premium.purchased"] = "<color=255,106,0>ARC9 Premium</color> kpt!"
L["premium.purchased.desc"] = [[
Tack fr att du kpt ARC9 Premium! Du har gjort en fgel vldigt glad!

Ett kvitto kommer skickas till din kopplad E-post.

Om du inte omedelbart fr tillgng till ARC9 Premium bonusarna, vnligen teranslut till servern, eller starta om spelet.

Om du fortfarande har problem med det, eller du inte ftt tillgng till Premium, besk d Diamond Doves Discord-servern och ge giltigt bevis av kp s fixar vi till det t dig.
]]

--PATH lua/arc9/common/localization/content_base_zh-cn.lua:
return gluapack()()
--PATH lua/arc9/common/localization/content_base_zh-cn.lua:
L = {}

//////// Folders
-- L["folder.arc9"] = "ARC9"
-- L["folder.arc9.community"] = "Community"

-- L["attachment.sticker"] = "Sticker"

//////// Flat Camo
-- L["camo_arc9_base_flat_od.printname"] = "Olive Drab"
-- L["camo_arc9_base_flat_od.compactname"] = "OD"
-- L["camo_arc9_base_flat_od.description"] = "Standard Olive Drab camouflage."

-- L["camo_arc9_base_flat_deserttan.printname"] = "Desert Tan"
-- L["camo_arc9_base_flat_deserttan.compactname"] = "Tan"
-- L["camo_arc9_base_flat_deserttan.description"] = "Standard Desert Tan camouflage."

-- L["camo_arc9_base_flat_arctic.printname"] = "Arctic White"
-- L["camo_arc9_base_flat_arctic.compactname"] = "Arctic"
-- L["camo_arc9_base_flat_arctic.description"] = "Standard Arctic White camouflage."

-- L["camo_arc9_base_flat_black.printname"] = "Factory Black"
-- L["camo_arc9_base_flat_black.compactname"] = "Black"
-- L["camo_arc9_base_flat_black.description"] = "Standard Factory Issue Black."

-- L["camo_arc9_base_flat_urbangray.printname"] = "Urban Gray"
-- L["camo_arc9_base_flat_urbangray.compactname"] = "Urban"
-- L["camo_arc9_base_flat_urbangray.description"] = "Standard Urban Gray camouflage."

-- L["camo_arc9_base_flat_forestgreen.printname"] = "Forest Green"
-- L["camo_arc9_base_flat_forestgreen.compactname"] = "Forest"
-- L["camo_arc9_base_flat_forestgreen.description"] = "Standard Forest Green camouflage."

-- L["camo_arc9_base_flat_navy.printname"] = "Navy Blue"
-- L["camo_arc9_base_flat_navy.compactname"] = "Navy"
-- L["camo_arc9_base_flat_navy.description"] = "Standard Navy Blue color."

-- L["camo_arc9_base_flat_mountbattenpink.printname"] = "Mountbatten Pink"
-- L["camo_arc9_base_flat_mountbattenpink.compactname"] = "MP"
-- L["camo_arc9_base_flat_mountbattenpink.description"] = "Standard Mountbatten Pink camouflage.\nShockingly effective in desert conditions."

-- L["camo_arc9_base_flat_fde.printname"] = "Flat Dark Earth"
-- L["camo_arc9_base_flat_fde.compactname"] = "FDE"
-- L["camo_arc9_base_flat_fde.description"] = "Standard Flat Dark Earth camouflage."

//////// Flat Colour
-- L["camo_arc9_base_flat_red.printname"] = "Red"
-- L["camo_arc9_base_flat_red.compactname"] = "Red"
-- L["camo_arc9_base_flat_red.description"] = "Basic red color."

-- L["camo_arc9_base_flat_orange.printname"] = "Orange"
-- L["camo_arc9_base_flat_orange.compactname"] = "Orange"
-- L["camo_arc9_base_flat_orange.description"] = "Basic orange color."

-- L["camo_arc9_base_flat_yellow.printname"] = "Yellow"
-- L["camo_arc9_base_flat_yellow.compactname"] = "Yellow"
-- L["camo_arc9_base_flat_yellow.description"] = "Basic yellow color."

-- L["camo_arc9_base_flat_green.printname"] = "Green"
-- L["camo_arc9_base_flat_green.compactname"] = "Green"
-- L["camo_arc9_base_flat_green.description"] = "Basic green color."

-- L["camo_arc9_base_flat_blue.printname"] = "Blue"
-- L["camo_arc9_base_flat_blue.compactname"] = "Blue"
-- L["camo_arc9_base_flat_blue.description"] = "Basic blue color."

-- L["camo_arc9_base_flat_purple.printname"] = "Purple"
-- L["camo_arc9_base_flat_purple.compactname"] = "Purple"
-- L["camo_arc9_base_flat_purple.description"] = "Basic purple color."

-- L["camo_arc9_base_flat_pink.printname"] = "Pink"
-- L["camo_arc9_base_flat_pink.compactname"] = "Pink"
-- L["camo_arc9_base_flat_pink.description"] = "Eye searingly bright pink color."

-- L["camo_arc9_base_flat_arc9orange.printname"] = "ARC9 Orange"
-- L["camo_arc9_base_flat_arc9orange.compactname"] = "ARC9 Orange"
-- L["camo_arc9_base_flat_arc9orange.description"] = "The perfect shade of orange for that cute little ARC9 Logo sticker."

//////// Charms
-- L["charm_gs_killcounter.printname"] = "Kill Counter"
-- L["charm_gs_killcounter.compactname"] = "KILL"
-- L["charm_gs_killcounter.description"] = "Device for tracking your weapon's kill stats."

-- L["charm_gs_clock.printname"] = "Basic Clock"
-- L["charm_gs_clock.compactname"] = "CLOCK"
-- L["charm_gs_clock.description"] = "Device that displays the real-world time."

-- L["charm_gs_sticker.printname"] = "Sticker Panel"
-- L["charm_gs_sticker.compactname"] = "STICKER"
-- L["charm_gs_sticker.description"] = "Device that allows a custom sticker to be applied onto its screen."

//////// Stickers, Base
-- L["sticker_spray.printname"] = "Player Spray"
-- L["sticker_spray.compactname"] = "Spray"
-- L["sticker_spray.description"] = [[Your own spray as a sticker!
-- You will only be able to see your own and not ones from other players.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_arc9.printname"] = "ARC9 Logo (Low Vis.)"
-- L["sticker_arc9.compactname"] = "ARC9"
-- L["sticker_arc9.description"] = [[Dark version of the ARC9 logo.
-- Design by The Villain.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_arc9_lowvis.printname"] = "ARC9 Logo"
-- L["sticker_arc9_lowvis.compactname"] = "ARC9"
-- L["sticker_arc9_lowvis.description"] = [[Here's to you.
-- Design by The Villain.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_a9k.printname"] = "ARCTICTHRON 9.000 WEAPON BASE"
-- L["sticker_a9k.compactname"] = "A9K"
-- L["sticker_a9k.description"] = [[this is what "arc9" actually means

-- Sticker included in the ARC9 Base.]]

-- L["sticker_a9cylo.printname"] = "ARC9 Concept logo by CyloWalker"
-- L["sticker_a9cylo.compactname"] = "A9 Cylo"
-- L["sticker_a9cylo.description"] = [[One of the first concepts for ARC9 logo/icon by CyloWalker (he's cool!)

-- Sticker included in the ARC9 Base.]]

-- L["sticker_sus9.printname"] = "Sus 9"
-- L["sticker_sus9.compactname"] = "Sus 9"
-- L["sticker_sus9.description"] = [[The impostor could be anywhere among us...
-- Design by Darsu.

-- Sticker included in the ARC9 Base.]]

//////// Stickers, Com. Wave 1
-- L["sticker_alien_lean.printname"] = "Legalize Alien Lean"
-- L["sticker_alien_lean.compactname"] = "Alien Lean"
-- L["sticker_alien_lean.description"] = [[Hop down to Agartha with the white boys for a cup of alien lean and... other things.
-- Design by Opt1ca.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_tomatocat.printname"] = "Tomato Cat"
-- L["sticker_tomatocat.compactname"] = "Tomato Cat"
-- L["sticker_tomatocat.description"] = [[Sometimes people ask whether tomatoes are fruits or vegetables... This one might be a tougher question.
-- Design by Ender2Point0.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_actionbird.printname"] = "Action Bird"
-- L["sticker_actionbird.compactname"] = "Action Bird"
-- L["sticker_actionbird.description"] = [[This is what Arctic looks like in real life.
-- Design by CyloWalker.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_warcrimes.printname"] = "War Crimes"
-- L["sticker_warcrimes.compactname"] = "War Crimes"
-- L["sticker_warcrimes.description"] = [[You're already doing them, so why not shout it out loud? Who's gonna stop you, the UN?
-- Design by Rimuchii. Made using Project Sekai sticker base.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_sillycat.printname"] = "Silly Cat"
-- L["sticker_sillycat.compactname"] = "Silly Cat"
-- L["sticker_sillycat.description"] = [[imsillyimsillyimsillyimsillyimsillyimsillyimsillyimsilly
-- Design by Stan_Jacobs.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_muertosskull.printname"] = "Dia De Los Muertos Calavera"
-- L["sticker_muertosskull.compactname"] = "Los Muertos"
-- L["sticker_muertosskull.description"] = [["this should be my final version i think, unless anyone gives me suggestions to change it, the name: "Dia de los muertos calavera" the description: i cant think of one, something about day of the dead skull mexico blah blah blah"
-- Design by rooneyviz.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_bandaid.printname"] = "Band-Aid"
-- L["sticker_bandaid.compactname"] = "Band-Aid"
-- L["sticker_bandaid.description"] = [[Put it on your boo-boo and kiss it all better.
-- Design by Itzal.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_peacedove.printname"] = "Peace Through Superior Firepower"
-- L["sticker_peacedove.compactname"] = "PTSF"
-- L["sticker_peacedove.description"] = [[The dove brings peace, but the gun brings peace through superior firepower.
-- Design by Xipil.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_borntomodify.printname"] = "Born To Modify"
-- L["sticker_borntomodify.compactname"] = "BTM"
-- L["sticker_borntomodify.description"] = [[Another sight - another scope - a grenade launcher, here and there...
-- Design by Duck.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_cad.printname"] = "cad"
-- L["sticker_cad.compactname"] = "cad"
-- L["sticker_cad.description"] = [[cad
-- Design by Opt1ca.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_fumo.printname"] = "Fumo"
-- L["sticker_fumo.compactname"] = "Fumo"
-- L["sticker_fumo.description"] = [[D-don't look at me like that, raifu-kun...
-- Design by Itzal.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_hotlead.printname"] = "Hot Lead"
-- L["sticker_hotlead.compactname"] = "Hot Lead"
-- L["sticker_hotlead.description"] = [[Careful! It's hot!
-- Design by Arqu.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_steamhappy.printname"] = ":steamhappy:"
-- L["sticker_steamhappy.compactname"] = ":steamhappy:"
-- L["sticker_steamhappy.description"] = [[Happy about it
-- Design from Steam.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_amidstus.printname"] = "Amidstus"
-- L["sticker_amidstus.compactname"] = "Amidstus"
-- L["sticker_amidstus.description"] = [[Why settle for the original when you could have a cheap knockoff?!
-- Design from Optica.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_arcglory.printname"] = "Glory!"
-- L["sticker_arcglory.compactname"] = "Glory!"
-- L["sticker_arcglory.description"] = [[Took nine brain cells to scribble this
-- Design from Optica.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_wp.printname"] = "World Peace!"
-- L["sticker_wp.compactname"] = "World Peace!"
-- L["sticker_wp.description"] = [[A delusion!
-- Design from Fidget.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_tonkr.printname"] = "Send It"
-- L["sticker_tonkr.compactname"] = "Send It"
-- L["sticker_tonkr.description"] = [[Yeah, it's that heavy. Yeah, it's that powerful.
-- Design from CyloWalker.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_s6amblem.printname"] = "Section 6"
-- L["sticker_s6amblem.compactname"] = "Section 6"
-- L["sticker_s6amblem.description"] = [[Reach for the stars. Forward to Glory!
-- Design from CyloWalker.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_babies.printname"] = "Baby Hazard"
-- L["sticker_babies.compactname"] = "Baby Hazard"
-- L["sticker_babies.description"] = [[Children ages 0-3 should be kept away from this.. firearm.
-- Design from Itzal.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_drawberf.printname"] = "Berf"
-- L["sticker_drawberf.compactname"] = "Berf"
-- L["sticker_drawberf.description"] = [[Draw Berf.
-- Design by The Villain.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_arcbird.printname"] = "Arc Bird"
-- L["sticker_arcbird.compactname"] = "Arc Bird"
-- L["sticker_arcbird.description"] = [[Arc Bird.
-- Design by Nori/Chewable.

-- Sticker included in the ARC9 Base.]]

--PATH lua/arc9/shared/sh_physbullet.lua:
ARC9.PhysBullets = {}

ARC9.PhysBulletModels = ARC9.PhysBulletModels or {}
ARC9.PhysBulletModelsLookup = ARC9.PhysBulletModelsLookup or {}

if SERVER then
    util.AddNetworkString("arc9_physbulletmodels")

    net.Receive("arc9_physbulletmodels", function(len, ply)
        if !ply.ARC9_HASPHYSBULLETMODELS then
            ARC9:SendPhysBulletModels(ply)
            ply.ARC9_HASPHYSBULLETMODELS = true
        end
    end)

    function ARC9:SendPhysBulletModels(ply)
        net.Start("arc9_physbulletmodels")
        local t = ARC9.PhysBulletModels
        local count = #t

        net.WriteUInt(count, 8)
        for i=1, count do
            net.WriteString(t[i])
        end

        if ply then
            net.Send(ply)
        else
            net.Broadcast()
        end
    end
end

function ARC9:RegisterPhysBulletModel(model)
    model = string.lower(model)
    local count = #ARC9.PhysBulletModels

    if count >= 255 then return -1 end
    if ARC9.PhysBulletModelsLookup[model] then return ARC9.PhysBulletModelsLookup[model] end
    count = count+1

    ARC9.PhysBulletModels[count] = model
    ARC9.PhysBulletModelsLookup[model] = count

    return count
end

function ARC9:SendBullet(bullet, attacker)
    net.Start("ARC9_sendbullet", true)
    net.WriteVector(bullet.Pos)
    net.WriteAngle(bullet.Vel:Angle())
    net.WriteFloat(bullet.Vel:Length())
    net.WriteFloat(bullet.Travelled)
    net.WriteFloat(bullet.Drag)
    net.WriteFloat(bullet.Gravity)
    net.WriteBool(bullet.Indirect or false)
    net.WriteEntity(bullet.Weapon)
    net.WriteUInt(bullet.ModelIndex or 0, 8)

    if attacker and attacker:IsValid() and attacker:IsPlayer() and !game.SinglePlayer() then
        net.SendOmit(attacker)
    else
        if game.SinglePlayer() then
            net.WriteEntity(attacker)
        end
        net.Broadcast()
    end
end

function ARC9:ShootPhysBullet(wep, pos, vel, tbl)

    local physmdl = wep:GetProcessedValue("PhysBulletModel", true)
    local mdlindex = ARC9.PhysBulletModelsLookup[string.lower(physmdl or "")] or 0

    if physmdl and mdlindex == 0 then
        print("\nARC9 encountered unregistered PhysBulletModel '" .. physmdl .. "'!\nWe will register and refresh this model for all clients, but this is network-intensive!\n\nPlease tell the addon developer to register the model in a shared lua file like so: ARC9:RegisterPhysBulletModel(\"" .. physmdl .. "\")")
        mdlindex = ARC9:RegisterPhysBulletModel(physmdl)
        if SERVER then ARC9:SendPhysBulletModels() end
    end

    local bullet = {
        Penleft = wep:GetProcessedValue("Penetration"),
        Gravity = wep:GetProcessedValue("PhysBulletGravity", true),
        Pos = pos,
        Vel = vel,
        Drag = wep:GetProcessedValue("PhysBulletDrag", true),
        Travelled = 0,
        StartTime = CurTime(),
        Imaginary = false,
        Underwater = false,
        Weapon = wep,
        ModelIndex = mdlindex,
        Attacker = wep:GetOwner(),
        Filter = {wep:GetOwner()},
        Damaged = {},
        Dead = false,
        Color = wep:GetProcessedValue("TracerColor"),
        Fancy = wep:GetProcessedValue("FancyBullets"),
        Size = wep:GetProcessedValue("TracerSize"),
        Guidance = wep:GetProcessedValue("BulletGuidance", true),
        GuidanceAmount = wep:GetProcessedValue("BulletGuidanceAmount", true),
        Secondary = wep:GetUBGL(),
        Distance = wep:GetProcessedValue("Distance"),
        FirstTimeProcessed = true
    }

    if tbl then
        for i, k in pairs(tbl) do
            bullet[i] = k
        end
    end

    if bit.band( util.PointContents( pos ), CONTENTS_WATER ) == CONTENTS_WATER then
        bullet.Underwater = true
    end

    wep:RunHook("HookP_ModifyNewBullet", bullet)
    if bullet.Dead then return end

    table.insert(ARC9.PhysBullets, bullet)

    if !game.SinglePlayer() then
        if CLIENT and mdlindex > 0 then
            local mdl = ARC9.PhysBulletModels[mdlindex]
            bullet.ClientModel = ClientsideModel(mdl, RENDERGROUP_OPAQUE)
            bullet.ClientModel:SetMoveType(MOVETYPE_NONE)

            table.insert(ARC9.CSModelPile, {Model = bullet.ClientModel, Weapon = wep})
        end

        if SERVER then
            -- ARC9:ProgressPhysBullet(bullet, FrameTime())

            ARC9:SendBullet(bullet, wep:GetOwner())
        end

        ARC9:ProgressPhysBullet(bullet, FrameTime())

        -- local owner = wep:GetOwner()
        -- if owner:IsPlayer() and (CLIENT or !owner:IsListenServerHost()) then
        --     -- local latency = engine.TickCount() - owner:GetCurrentCommand():TickCount()
        --     local ping = owner:Ping() / 1000
        --     local timestep = 0.2

        --     ping = math.min(ping, 0.25) -- can't let people cheat TOO hard

        --     while ping > 0 do
        --         ARC9:ProgressPhysBullet(bullet, timestep)
        --         ping = ping - timestep
        --     end
        -- end
    else
        if SERVER then
            -- ARC9:ProgressPhysBullet(bullet, FrameTime())

            ARC9:SendBullet(bullet, wep:GetOwner())
        end

        ARC9:ProgressPhysBullet(bullet, FrameTime())
    end
end

if CLIENT then
    
    net.Receive("arc9_sendbullet", function(len, ply)
        local pos = net.ReadVector()
        local ang = net.ReadAngle()
        local vel = net.ReadFloat()
        local trav = net.ReadFloat()
        local drag = net.ReadFloat()
        local grav = net.ReadFloat()
        local indirect = net.ReadBool()
        local weapon = net.ReadEntity()
        local modelindex = net.ReadUInt(8)
        local ent = nil
    
        if game.SinglePlayer() then
            ent = net.ReadEntity()
        end
    
        if !IsValid(weapon) then return end
        if !weapon.ARC9 then return end
    
        local bullet = {
            Pos = pos,
            Vel = ang:Forward() * vel,
            Travelled = trav or 0,
            StartTime = CurTime(),
            Imaginary = false,
            Underwater = false,
            Indirect = indirect,
            Dead = false,
            Damaged = {},
            Drag = drag,
            Attacker = ent,
            Gravity = grav,
            Weapon = weapon,
            ModelIndex = modelindex,
            Color = weapon:GetProcessedValue("TracerColor"),
            Fancy = weapon:GetProcessedValue("FancyBullets"),
            Size = weapon:GetProcessedValue("TracerSize"),
            Filter = {ent},
            Guidance = weapon:GetProcessedValue("BulletGuidance", true),
            GuidanceAmount = weapon:GetProcessedValue("BulletGuidanceAmount", true),
            GuidanceTarget = weapon:GetLockOnTarget(),
            Invisible = false,
            Secondary = weapon:GetUBGL(),
            Distance = weapon:GetProcessedValue("Distance")
        }
    
        if !weapon:ShouldTracer() then
            bullet.Invisible = true
        end
    
        if bit.band( util.PointContents( pos ), CONTENTS_WATER ) == CONTENTS_WATER then
            bullet.Underwater = true
        end
    
        if modelindex > 0 then
            local mdl = ARC9.PhysBulletModels[modelindex]
            bullet.ClientModel = ClientsideModel(mdl, RENDERGROUP_OPAQUE)
            bullet.ClientModel:SetMoveType(MOVETYPE_NONE)
            table.insert(ARC9.CSModelPile, {Model = bullet.ClientModel, Weapon = weapon})
        end
    
        table.insert(ARC9.PhysBullets, bullet)
    end)
    
    net.Receive("arc9_physbulletmodels", function()
        ARC9.PhysBulletModels = {}
        local count = net.ReadUInt(8)
        for i = 1, count do
            ARC9.PhysBulletModels[i] = net.ReadString()
            ARC9.PhysBulletModelsLookup[ARC9.PhysBulletModels[i]] = i
        end
    end)
    
    hook.Add("InitPostEntity", "ARC9_RetrievePhysBulletModels", function()
        net.Start("arc9_physbulletmodels")
        net.SendToServer()
    end)

end

function ARC9:DoPhysBullets()
    local i=1
    local tab = ARC9.PhysBullets
    local frameTime = FrameTime()
    while true do
        local v = tab[i]
        if not v then break end

        ARC9:ProgressPhysBullet(v, frameTime)

        if v.Dead then
            table.remove(tab, i)
        else
            i = i+1
        end
    end
end

hook.Add("Think", "ARC9_DoPhysBullets", ARC9.DoPhysBullets)

local function indim(vec, maxdim)
    if math.abs(vec.x) > maxdim or math.abs(vec.y) > maxdim or math.abs(vec.z) > maxdim then
        return false
    else
        return true
    end
end

local bulletGravity = GetConVar("ARC9_bullet_gravity")
local bulletDrag = GetConVar("ARC9_bullet_drag")
local bulletImaginary = GetConVar("ARC9_bullet_imaginary")
local bulletLifetime = GetConVar("ARC9_bullet_lifetime")
local traceResultTab = {}
local traceTab = {
    output = traceResultTab
}
local fireBullets = {
    Tracer = 0,
    Damage = 0
}
local fireBullets2 = {
    Spread = vector_origin,
    Tracer = 0,
    Num = 1
}

function ARC9:ProgressPhysBullet(bullet, timestep)
    timestep = timestep or FrameTime()

    if bullet.Dead then return end

    local oldpos = bullet.Pos
    local oldvel = bullet.Vel

    local attacker = bullet.Attacker
    local weapon = bullet.Weapon

    if !IsValid(attacker) then bullet.Dead = true return end

    local dir = bullet.Vel:GetNormalized()
    local spd = bullet.Vel:Length() * timestep

    local drag = bullet.Drag * spd * spd * 6.666666666666667e-06
    local gravity = timestep * bulletGravity:GetFloat() * (bullet.Gravity or 1) * 600

    -- if !IsValid(attacker) then
    --     bullet.Dead = true
    --     return
    -- end

    if !IsValid(weapon) then
        bullet.Dead = true
        return
    end

    if bullet.Fancy then
        weapon:RunHook("HookP_ModifyBullet", bullet)

        if bullet.Dead then return end
    end

    if bullet.Underwater then
        drag = drag * 3
    end

    drag = drag * bulletDrag:GetFloat()

    if spd <= 0.001 then bullet.Dead = true return end

    local newpos = oldpos + (oldvel * timestep)
    local newvel = oldvel - (dir * drag)

    newvel[3] = newvel[3] - gravity
    
    local IsPlayer = attacker:IsPlayer()


    if bullet.Imaginary then
        -- the bullet has exited the map, but will continue being visible.
        bullet.Pos = newpos
        bullet.Vel = newvel
        bullet.Travelled = bullet.Travelled + spd

        if CLIENT and !bulletImaginary:GetBool() then
            bullet.Dead = true
        end
    else
        if isPlayer and !attacker.ARC9_LAGCOMP then
            attacker:LagCompensation(true)
            attacker.ARC9_LAGCOMP = true
        end


        traceTab.start = oldpos
        traceTab.endpos = newpos
        traceTab.filter = bullet.Filter
        traceTab.mask = MASK_SHOT

        util.TraceLine(traceTab)
        
        local tr = traceResultTab

        if isPlayer then
            attacker:LagCompensation(false)
            attacker.ARC9_LAGCOMP = false
        end

        if ARC9.Dev(2) then
            if SERVER then
                debugoverlay.Line(oldpos, tr.HitPos, 5, Color(100,100,255), true)
            else
                debugoverlay.Line(oldpos, tr.HitPos, 5, Color(255,200,100), true)
            end
        end

        if tr.HitSky then
            if CLIENT and bulletImaginary:GetBool() then
                bullet.Imaginary = true
            else
                bullet.Dead = true
            end

            bullet.Pos = newpos
            bullet.Vel = newvel
            bullet.Travelled = bullet.Travelled + spd

            if SERVER then
                bullet.Dead = true
            end
        elseif tr.Hit then
            bullet.Travelled = bullet.Travelled + (oldpos - tr.HitPos):Length()
            bullet.Pos = tr.HitPos
            -- if we're the client, we'll get the bullet back when it exits.

            if isPlayer and !attacker.ARC9_LAGCOMP then
                attacker:LagCompensation(true) -- Sometimes this line is called before the first lag compensation finishes, somehow.
                attacker.ARC9_LAGCOMP = true
            end

            if ARC9.Dev(2) then
                if SERVER then
                    debugoverlay.Cross(tr.HitPos, 5, 5, Color(100,100,255), true)
                else
                    debugoverlay.Cross(tr.HitPos, 5, 5, Color(255,200,100), true)
                end
            end

            local eid = tr.Entity:EntIndex()

            if CLIENT then
                -- do an impact effect and forget about it
                if !game.SinglePlayer() and !ARC9.IsPointOutOfBounds(oldpos) then
                    fireBullets.Src = oldpos
                    fireBullets.Dir = dir
                    fireBullets.Distance = spd + 16

                    fireBullets.IgnoreEntity = bullet.Attacker

                    attacker:FireBullets(fireBullets)
                end
                if IsValid(bullet.ClientModel) then
                    local t = weapon:GetProcessedValue("PhysBulletModelStick", true) or 0
                    if t > 0 then
                        local entity = tr.Entity

                        local bone = entity:TranslatePhysBoneToBone(tr.PhysicsBone) or entity:GetHitBoxBone(tr.HitBox, entity:GetHitboxSet())
                        local matrix = entity:GetBoneMatrix(bone or 0)
                        if bone and matrix then
                            local pos = matrix:GetTranslation()
                            local ang = matrix:GetAngles()
                            bullet.ClientModel:FollowBone(entity, bone)
                            local n_pos, n_ang = WorldToLocal(tr.HitPos, tr.Normal:Angle(), pos, ang)
                            bullet.ClientModel:SetLocalPos(n_pos)
                            bullet.ClientModel:SetLocalAngles(n_ang)
                        else
                            bullet.ClientModel:SetPos(bullet.Pos)
                            bullet.ClientModel:SetAngles(bullet.Vel:Angle())
                            bullet.ClientModel:SetParent(entity)
                        end
                    end
                    SafeRemoveEntityDelayed(bullet.ClientModel, t)
                end
                bullet.Dead = true
            elseif SERVER then
                bullet.Damaged[eid] = true
                bullet.Dead = true

                if IsValid(bullet.Attacker) and IsValid(weapon) and !ARC9.IsPointOutOfBounds(oldpos) then

                    if !game.SinglePlayer() and !bullet.FirstTimeProcessed then
                        SuppressHostEvents(bullet.Attacker)
                    end

                    fireBullets2.Damage = weapon:GetProcessedValue("DamageMax")
                    fireBullets2.Force = weapon:GetProcessedValue("ImpactForce")
                    fireBullets2.Dir = bullet.Vel:GetNormalized()
                    fireBullets2.Src = oldpos
                    fireBullets2.Spread = vector_origin
                    fireBullets2.Callback = function(att, btr, dmg)
                        local range = bullet.Travelled

                        weapon.Penned = 0
                        weapon:AfterShotFunction(btr, dmg, range, bullet.Penleft, bullet.Damaged, bullet.Secondary)
                    end

                    bullet.Attacker:FireBullets(fireBullets2)

                    if !game.SinglePlayer() and !bullet.FirstTimeProcessed then
                        SuppressHostEvents()
                    end
                end
            end

            if isPlayer and attacker.ARC9_LAGCOMP then
                attacker:LagCompensation(false)
                attacker.ARC9_LAGCOMP = false
            end
        else
            -- bullet did not impact anything
            -- break glass in the way
            -- if CLIENT or game.SinglePlayer() then
            --     bullet.Attacker:FireBullets({
            --         Src = oldpos,
            --         Dir = dir,
            --         Distance = spd * 5,
            --         -- Distance = 10000,
            --         Tracer = 0,
            --         Damage = 0,
            --         IgnoreEntity = bullet.Attacker
            --     })
            -- end

            bullet.Pos = tr.HitPos
            bullet.Vel = newvel
            bullet.Travelled = bullet.Travelled + spd

            if CLIENT or game.SinglePlayer() then
                local utr = {}
                if bullet.Underwater then
                    if bit.band( util.PointContents( tr.HitPos ), CONTENTS_WATER ) != CONTENTS_WATER then
                        
                        traceTab.start = tr.HitPos
                        traceTab.endpos = oldpos
                        traceTab.filter = bullet.Attacker
                        traceTab.mask = MASK_WATER
                        traceTab.output = utr

                        util.TraceLine(traceTab)

                        
                        traceTab.output = traceResultTab

                        if utr.Hit then
                            local fx = EffectData()
                            fx:SetOrigin(utr.HitPos)
                            fx:SetScale(5)
                            fx:SetFlags(0)
                            util.Effect("gunshotsplash", fx, true)
                        end

                        bullet.Underwater = false
                    end
                else
                    if bit.band( util.PointContents( tr.HitPos ), CONTENTS_WATER ) == CONTENTS_WATER then
                        traceTab.start = oldpos
                        traceTab.endpos = tr.HitPos
                        traceTab.filter = bullet.Attacker
                        traceTab.mask = MASK_WATER
                        traceTab.output = utr

                        util.TraceLine(traceTab)

                        traceTab.output = traceResultTab

                        if utr.Hit then
                            local fx = EffectData()
                            fx:SetOrigin(utr.HitPos)
                            fx:SetScale(5)
                            fx:SetFlags(0)
                            util.Effect("gunshotsplash", fx, true)
                        end

                        bullet.Underwater = true
                    end
                end
            end
        end
    end

    if bullet.Guidance and IsValid(bullet.GuidanceTarget) then
        local tgt_point = bullet.GuidanceTarget:GetPos()

        tgt_point:Sub(oldpos)
        tgt_point:Normalize()
        tgt_point:Mul(timestep)
        tgt_point:Mul(bullet.GuidanceAmount or 15000)

     --   local tgt_dir = (tgt_point - oldpos):GetNormalized()

        -- needs work

        bullet.Vel:Add(tgt_point)

        local bdir = bullet.Vel:Forward()
        local vel = bullet.Vel:Length()

        vel = math.Clamp(vel, 0, bullet.GuidanceAmount)

        bullet.Vel = bdir * vel
    end

    local MaxDimensions = 65536
    local WorldDimensions = 16384

    if bullet.Travelled > bullet.Distance then
        bullet.Dead = true
    end

    if bullet.StartTime <= (CurTime() - bulletLifetime:GetFloat()) then
        bullet.Dead = true
    elseif !indim(bullet.Pos, MaxDimensions) then
        bullet.Dead = true
    elseif !indim(bullet.Pos, WorldDimensions) then
        bullet.Imaginary = true
    end

    bullet.FirstTimeProcessed = false
end

local head = Material("particle/fire")
local tracer = Material("arc9/tracer")

local col = Color(255, 225, 200)

function ARC9.DrawPhysBullets()
    cam.Start3D()
    for _, i in ipairs(ARC9.PhysBullets) do
        if i.Invisible then continue end
        -- if i.Travelled <= (i.ModelIndex == 0 and 512 or 64) then continue end

        local pos = i.Pos

        local speedvec = i.Vel:GetNormalized()
        local vec = speedvec
        local shoulddraw = true

        if IsValid(i.Weapon) then
            shoulddraw = i.Weapon:RunHook("HookC_DrawBullet", i)

            local fromvec = -(i.Weapon:GetTracerOrigin() - pos):GetNormalized()

            local d = math.min(i.Travelled / 1024, 1)
            if i.Indirect then
                d = 1
            end

            vec = LerpVector(d, fromvec, speedvec)
        end

        if !shoulddraw then continue end

        if i.ModelIndex != 0 then
            if IsValid(i.ClientModel) then
                i.ClientModel:SetPos(pos)
                i.ClientModel:SetAngles(i.Vel:Angle())
                --i.ClientModel:DrawModel()
            end
            continue
        end

        local size = 1

        size = size * math.log(EyePos():DistToSqr(pos) - math.pow(512, 2))

        size = math.Clamp(size, 0, math.huge)

        size = size * i.Size

        local headsize = size

        headsize = headsize * math.min(EyePos():DistToSqr(pos) / math.pow(2500, 2), 1)

        local vel = i.Vel - LocalPlayer():GetVelocity()

        local dot = EyeAngles():Forward():Dot(vel:GetNormalized())

        dot = math.abs(dot)

        dot = math.Clamp(((dot * dot) - 0.5) * 5, 0, 1)

        headsize = headsize * dot * 2
        -- size = size * (1 - dot)

        -- cam.Start3D()

        local col = i.Color or col
        -- local col = Color(255, 225, 200)

        render.SetMaterial(head)
        render.DrawSprite(pos, headsize, headsize, col)

        render.SetMaterial(tracer)

        local t = vec:GetNormalized()
        t:Mul(math.min(vel:Length() * 0.5, math.min(512, i.Travelled - 64)))

        local tail = t

        render.DrawBeam(pos, pos - tail, size * 0.75, 1, 0, col)

        -- cam.End3D()
    end
    cam.End3D()
end

hook.Add("PreDrawEffects", "ARC9_DrawPhysBullets", ARC9.DrawPhysBullets)

hook.Add("PostCleanupMap", "ARC9_CleanPhysBullets", function()
    ARC9.PhysBullets = {}
end)
--PATH lua/arc9/client/cl_blacklist.lua:
return gluapack()()
--PATH lua/arc9/client/cl_garbage.lua:
return gluapack()()
--PATH lua/arc9/client/cl_thirdperson.lua:
return gluapack()()
--PATH lua/arc9/client/zzz_cl_lualoadcheck.lua:
return gluapack()()
--PATH lua/autorun/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2019 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Structures:
    CAMI_USERGROUP, defines the charactaristics of a usergroup:
    {
        Name
            string
            The name of the usergroup
        Inherits
            string
            The name of the usergroup this usergroup inherits from
    }

    CAMI_PRIVILEGE, defines the charactaristics of a privilege:
    {
        Name
            string
            The name of the privilege
        MinAccess
            string
            One of the following three: user/admin/superadmin
        Description
            string
            optional
            A text describing the purpose of the privilege
        HasAccess
            function(
                privilege :: CAMI_PRIVILEGE,
                actor     :: Player,
                target    :: Player
            ) :: bool
            optional
            Function that decides whether a player can execute this privilege,
            optionally on another player (target).
    }

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20190102

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version

--[[
usergroups
    Contains the registered CAMI_USERGROUP usergroup structures.
    Indexed by usergroup name.
]]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user"
    },
    admin = {
        Name = "admin",
        Inherits = "user"
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin"
    }
}

--[[
privileges
    Contains the registered CAMI_PRIVILEGE privilege structures.
    Indexed by privilege name.
]]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--[[
CAMI.RegisterUsergroup
    Registers a usergroup with CAMI.

    Parameters:
        usergroup
            CAMI_USERGROUP
            (see CAMI_USERGROUP structure)
        source
            any
            Identifier for your own admin mod. Can be anything.
            Use this to make sure CAMI.RegisterUsergroup function and the
            CAMI.OnUsergroupRegistered hook don't cause an infinite loop



    Return value:
        CAMI_USERGROUP
            The usergroup given as argument.
]]
function CAMI.RegisterUsergroup(usergroup, source)
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--[[
CAMI.UnregisterUsergroup
    Unregisters a usergroup from CAMI. This will call a hook that will notify
    all other admin mods of the removal.

    Call only when the usergroup is to be permanently removed.

    Parameters:
        usergroupName
            string
            The name of the usergroup.
        source
            any
            Identifier for your own admin mod. Can be anything.
            Use this to make sure CAMI.UnregisterUsergroup function and the
            CAMI.OnUsergroupUnregistered hook don't cause an infinite loop

    Return value:
        bool
            Whether the unregistering succeeded.
]]
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--[[
CAMI.GetUsergroups
    Retrieves all registered usergroups.

    Return value:
        Table of CAMI_USERGROUP, indexed by their names.
]]
function CAMI.GetUsergroups()
    return usergroups
end

--[[
CAMI.GetUsergroup
    Receives information about a usergroup.

    Return value:
        CAMI_USERGROUP
            Returns nil when the usergroup does not exist.
]]
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--[[
CAMI.UsergroupInherits
    Returns true when usergroupName1 inherits usergroupName2.
    Note that usergroupName1 does not need to be a direct child.
    Every usergroup trivially inherits itself.

    Parameters:
        usergroupName1
            string
            The name of the usergroup that is queried.
        usergroupName2
            string
            The name of the usergroup of which is queried whether usergroupName
            inherits from.

    Return value:
        bool
            Whether usergroupName1 inherits usergroupName2.
]]
function CAMI.UsergroupInherits(usergroupName1, usergroupName2)
    repeat
        if usergroupName1 == usergroupName2 then return true end

        usergroupName1 = usergroups[usergroupName1] and
                         usergroups[usergroupName1].Inherits or
                         usergroupName1
    until not usergroups[usergroupName1] or
          usergroups[usergroupName1].Inherits == usergroupName1

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName1 == usergroupName2 or usergroupName2 == "user"
end

--[[
CAMI.InheritanceRoot
    All usergroups must eventually inherit either user, admin or superadmin.
    Regardless of what inheritance mechism an admin may or may not have, this
    always applies.

    This method always returns either user, admin or superadmin, based on what
    usergroups eventually inherit.

    Parameters:
        usergroupName
            string
            The name of the usergroup of which the root of inheritance is
            requested

    Return value:
        string
            The name of the root usergroup (either user, admin or superadmin)
]]
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--[[
CAMI.RegisterPrivilege
    Registers a privilege with CAMI.
    Note: do NOT register all your admin mod's privileges with this function!
    This function is for third party addons to register privileges
    with admin mods, not for admin mods sharing the privileges amongst one
    another.

    Parameters:
        privilege
            CAMI_PRIVILEGE
            See CAMI_PRIVILEGE structure.

    Return value:
        CAMI_PRIVILEGE
            The privilege given as argument.
]]
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--[[
CAMI.UnregisterPrivilege
    Unregisters a privilege from CAMI. This will call a hook that will notify
    all other admin mods of the removal.

    Call only when the privilege is to be permanently removed.

    Parameters:
        privilegeName
            string
            The name of the privilege.

    Return value:
        bool
            Whether the unregistering succeeded.
]]
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--[[
CAMI.GetPrivileges
    Retrieves all registered privileges.

    Return value:
        Table of CAMI_PRIVILEGE, indexed by their names.
]]
function CAMI.GetPrivileges()
    return privileges
end

--[[
CAMI.GetPrivilege
    Receives information about a privilege.

    Return value:
        CAMI_PRIVILEGE when the privilege exists.
            nil when the privilege does not exist.
]]
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

--[[
CAMI.PlayerHasAccess
    Queries whether a certain player has the right to perform a certain action.

    Parameters:
        actorPly
            Player
            The player of which is requested whether they have the privilege.
        privilegeName
            string
            The name of the privilege.
        callback
            function(bool, string) or nil
            This function will be called with the answer. The bool signifies the
            yes or no answer as to whether the player is allowed. The string
            will optionally give a reason.

            Give an explicit nil here to get an answer immediately
                Important note: May throw an error when the admin mod doesn't
                give an answer immediately!
        targetPly
            Optional.
            The player on which the privilege is executed.
        extraInfoTbl
            Optional.
            Table containing extra information.
            Officially supported members:
                Fallback
                    string
                    Either of user/admin/superadmin. When no admin mod replies,
                    the decision is based on the admin status of the user.
                    Defaults to admin if not given.
                IgnoreImmunity
                    bool
                    Ignore any immunity mechanisms an admin mod might have.
                CommandArguments
                    table
                    Extra arguments that were given to the privilege command.

    Return value:
        If callback is specified:
            None
        Otherwise:
            hasAccess
                bool
                Whether the player has access
            reason
                Optional.
                The reason why a player does or does not have access.
]]
-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, _, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        callback(
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()
            , "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--[[
CAMI.GetPlayersWithAccess
    Finds the list of currently joined players who have the right to perform a
    certain action.
    NOTE: this function will NOT return an immediate result!
    The result is in the callback!

    Parameters:
        privilegeName
            string
            The name of the privilege.
        callback
            function(players)
            This function will be called with the list of players with access.
        targetPly
            Optional.
            The player on which the privilege is executed.
        extraInfoTbl
            Optional.
            Table containing extra information.
            Officially supported members:
                Fallback
                    string
                    Either of user/admin/superadmin. When no admin mod replies,
                    the decision is based on the admin status of the user.
                    Defaults to admin if not given.
                IgnoreImmunity
                    bool
                    Ignore any immunity mechanisms an admin mod might have.
                CommandArguments
                    table
                    Extra arguments that were given to the privilege command.
]]
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--[[
CAMI.SteamIDHasAccess
    Queries whether a player with a steam ID has the right to perform a certain
    action.
    Note: the player does not need to be in the server for this to
    work.

    Note: this function does NOT return an immediate result!
    The result is in the callback!

    Parameters:
        actorSteam
            Player
            The SteamID of the player of which is requested whether they have
            the privilege.
        privilegeName
            string
            The name of the privilege.
        callback
            function(bool, string)
            This function will be called with the answer. The bool signifies the
            yes or no answer as to whether the player is allowed. The string
            will optionally give a reason.
        targetSteam
            Optional.
            The SteamID of the player on which the privilege is executed.
        extraInfoTbl
            Optional.
            Table containing extra information.
            Officially supported members:
                IgnoreImmunity
                    bool
                    Ignore any immunity mechanisms an admin mod might have.
                CommandArguments
                    table
                    Extra arguments that were given to the privilege command.

    Return value:
        None, the answer is given in the callback function in order to allow
        for the admin mod to perform e.g. a database lookup.
]]
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--[[
CAMI.SignalUserGroupChanged
    Signify that your admin mod has changed the usergroup of a player. This
    function communicates to other admin mods what it thinks the usergroup
    of a player should be.

    Listen to the hook to receive the usergroup changes of other admin mods.

    Parameters:
        ply
            Player
            The player for which the usergroup is changed
        old
            string
            The previous usergroup of the player.
        new
            string
            The new usergroup of the player.
        source
            any
            Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--[[
CAMI.SignalSteamIDUserGroupChanged
    Signify that your admin mod has changed the usergroup of a disconnected
    player. This communicates to other admin mods what it thinks the usergroup
    of a player should be.

    Listen to the hook to receive the usergroup changes of other admin mods.

    Parameters:
        ply
            string
            The steam ID of the player for which the usergroup is changed
        old
            string
            The previous usergroup of the player.
        new
            string
            The new usergroup of the player.
        source
            any
            Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--PATH addons/[misc] szachy/lua/chess/sh_player_ext.lua:
return gluapack()()
--PATH lua/autorun/sh_pixelui_loader.lua:
return gluapack()()
--PATH lua/pixelui/core/cl_color.lua:
return gluapack()()
--PATH lua/pixelui/core/cl_overrides.lua:
return gluapack()()
--PATH lua/pixelui/core/cl_scaling.lua:
return gluapack()()
--PATH lua/pixelui/drawing/cl_misc.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_color_picker.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

local gradientMat = Material("nil")
PIXEL.GetImage("https://pixel-cdn.lythium.dev/i/zxlflz5vp", function(mat)
    gradientMat = mat
end)

local colorWheelMat = Material("nil")
PIXEL.GetImage("https://pixel-cdn.lythium.dev/i/4lsnfph3b", function(mat)
    colorWheelMat = mat
end)

local pickerMat = Material("nil")
PIXEL.GetImage("https://pixel-cdn.lythium.dev/i/rhz6llj2", function(mat)
    pickerMat = mat
end)

function PANEL:Init()
    self.Hue = 0
    self.SmoothHue = 0

    self.Lightness = 0
    self.Saturation = 0

    self.TriX = 0
    self.TriY = 0

    self:UpdateColor()
    self:UpdatePositions()
end

function PANEL:OnChange(color) end

function PANEL:UpdateColor()
    self.Color = PIXEL.HSLToColor(self.Hue, self.Saturation, self.Lightness)
    self:OnChange(self.Color)
end

function PANEL:SetColor(color)
    local h, s, l = ColorToHSL(color)
    h = h / (360 / 5)
    self.Hue = h
    self.Saturation = s
    self.Lightness = l

    self.Color = color
    self:OnChange(color)

    self:UpdatePositions()
end

function PANEL:UpdatePositions()
    local hue = self.Hue
    local third = (2 / 3) * math.pi
    local sat = self.Saturation
    local light = 1 - self.Lightness

    local hX = math.cos(hue)
    local hY = math.sin(hue)
    local sX = math.cos(hue - third)
    local sY = math.sin(hue - third)
    local vX = math.cos(hue + third)
    local vY = math.sin(hue + third)

    local mX = (sX + vX) / 2
    local mY = (sY + vY) / 2
    local a = (1 - 2 * math.abs(light - 0.5)) * sat

    self.TriX = sX + (vX - sX) * light + (hX - mX) * a
    self.TriY = sY + (vY - sY) * light + (hY - mY) * a
end

function PANEL:Think()
    local cursorX, cursorY = self:CursorPos()
    local cX, cY = self:GetCenter()
    local triangleRadius = self:GetTriangleRadius()

    if not self.Pressed then return end

    local diffX = cursorX - cX
    local diffY = cursorY - cY
    local rad = math.atan2(diffY, diffX)

    if rad < 0 then
        rad = rad + (2 * math.pi)
    end

    if self.PressedWheel then
        self.Hue = rad
        self:UpdatePositions()
        self:UpdateColor()
        return
    end

    local rad0 = (rad + 2 * math.pi - self.Hue) % (2 * math.pi)
    local rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
    local a = 0.5 * triangleRadius
    local b = math.tan(rad1) * a
    local r = math.sqrt(diffX * diffX + diffY * diffY)
    local maxR = math.sqrt(a * a + b * b)

    if r > maxR then
        local dx = math.tan(rad1) * r
        local rad2 = math.Clamp(math.atan(dx / maxR), -math.pi / 3, math.pi / 3)
        rad = rad + (rad2 - rad1)
        rad0 = (rad + 2 * math.pi - self.Hue) % (2 * math.pi)
        rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
        b = math.tan(rad1) * a
        maxR = math.sqrt(a * a + b * b)
        r = maxR
    end

    self.TriX = math.cos(rad) * r / triangleRadius
    self.TriY = math.sin(rad) * r / triangleRadius

    local triangleSideLen = math.sqrt(3) * triangleRadius
    local light = ((math.sin(rad0) * r) / triangleSideLen) + 0.5
    local widthShare = 1.0 - math.abs(light - 0.5) * 2.0
    local saturation = (((math.cos(rad0) * r) + (triangleRadius / 2)) / (1.5 * triangleRadius)) / widthShare
    saturation = math.Clamp(saturation, 0, 1)

    self.Lightness = 1 - light
    self.Saturation = saturation

    self:UpdateColor()
end

function PANEL:OnMousePressed()
    self:MouseCapture(true)
    self.Pressed = true

    local cX, cY = self:GetCenter()
    local cursorX, cursorY = self:CursorPos()
    local cursor = Vector(cursorX, cursorY)
    local center = Vector(cX, cY, 0)

    if cursor:Distance(center) > self:GetTriangleRadius() then
        self.PressedWheel = true
        return
    end

    self.PressedTriangle = true
end

function PANEL:OnMouseReleased()
    self:MouseCapture(false)
    self.Pressed = false
    self.PressedWheel = false
    self.PressedTriangle = false
end

function PANEL:GetCenter()
    return self:GetWide() / 2, self:GetTall() / 2
end

function PANEL:GetRadius()
    return self:GetTall() / 2
end

function PANEL:GetTriangleRadius()
    return self:GetRadius() * 0.7
end

function PANEL:GetRingThickness()
    return self:GetRadius() * 0.2
end

function PANEL:GetHueColor()
    return PIXEL.HSLToColor(self.Hue, 1, 0.5)
end

local whiteTexture = surface.GetTextureID("vgui/white")
function PANEL:Paint(w, h)
    local cX, cY = self:GetCenter()
    local radius = self:GetRadius()
    local triangleRadius = self:GetTriangleRadius()

    surface.SetTexture(whiteTexture)

    local triangleAng = self.Hue
    local triangleOff = math.pi * 2 / 3
    local vertices = {
        {
            x = cX + math.cos(triangleAng - triangleOff) * triangleRadius,
            y = cY + math.sin(triangleAng - triangleOff) * triangleRadius,
            u = 0.5,
            v = 0.99
        },
        {
            x = cX + math.cos(triangleAng) * triangleRadius,
            y = cY + math.sin(triangleAng) * triangleRadius,
            u = 0.99,
            v = 0.01
        },
        {
            x = cX + math.cos(triangleAng + triangleOff * 1) * triangleRadius,
            y = cY + math.sin(triangleAng + triangleOff * 1) * triangleRadius,
            u = 0.01,
            v = 0.01
        }
    }

    local col = self:GetHueColor()
    surface.SetDrawColor(col)
    surface.DrawPoly(vertices)

    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(gradientMat)
    surface.DrawPoly(vertices)
    surface.DrawPoly(vertices)

    vertices[1].u = 0.99
    vertices[1].v = 0.01

    vertices[2].u = 0.01
    vertices[2].v = 0.01

    vertices[3].u = 0.5
    vertices[3].v = 0.99

    surface.SetDrawColor(0, 0, 0, 255)
    surface.SetMaterial(gradientMat)
    surface.DrawPoly(vertices)

    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(colorWheelMat)
    surface.DrawTexturedRect(cX - radius, cY - radius, radius * 2, radius * 2)

    local pickerSize = PIXEL.Scale(5)
    local pickerVerts = {
        {
            x = cX + self.TriX * triangleRadius + pickerSize,
            y = cY + self.TriY * triangleRadius + pickerSize,
            u = 1,
            v = 1
        },
        {
            x = cX + self.TriX * triangleRadius - PIXEL.Scale(5),
            y = cY + self.TriY * triangleRadius + PIXEL.Scale(5),
            u = 0,
            v = 1
        },
        {
            x = cX + self.TriX * triangleRadius - PIXEL.Scale(5),
            y = cY + self.TriY * triangleRadius - PIXEL.Scale(5),
            u = 0,
            v = 0
        },
        {
            x = cX + self.TriX * triangleRadius + pickerSize,
            y = cY + self.TriY * triangleRadius - pickerSize,
            u = 1,
            v = 0
        }
    }

    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(pickerMat)
    surface.DrawPoly(pickerVerts)

    local hpX = cX + math.cos(self.Hue) * (radius - self:GetRingThickness() / 2)
    local hpY = cY + math.sin(self.Hue) * (radius - self:GetRingThickness() / 2)
    local size = PIXEL.Scale(16)
    local huePickerVerts = {
        {
            x = hpX + size / 2,
            y = hpY + size / 2,
            u = 1,
            v = 1
        },
        {
            x = hpX - size / 2,
            y = hpY + size / 2,
            u = 0,
            v = 1
        },
        {
            x = hpX - size / 2,
            y = hpY - size / 2,
            u = 0,
            v = 0
        },
        {
            x = hpX + size / 2,
            y = hpY - size / 2,
            u = 1,
            v = 0
        }
    }
    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(pickerMat)
    surface.DrawPoly(huePickerVerts)
end

vgui.Register("PIXEL.ColorPicker", PANEL, "Panel")
--PATH lua/pixelui/elements/cl_imgur_button.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING)
AccessorFunc(PANEL, "ImgurSize", "ImgurSize", FORCE_NUMBER)

function PANEL:SetImgurID(id)
    self.ImgurID = id
    self:SetImageURL("https://i.imgur.com/" .. id .. ".png")
end

function PANEL:GetImgurID()
    return (self:GetImageURL() or ""):match("https://i.imgur.com/(.*).png")
end

function PANEL:SetImgurSize(size)
    self.ImgurSize = size
    self:SetImageSize(size, size)
end

function PANEL:GetImgurSize()
    return self:GetImageSize()
end

function PANEL:Init()
end

vgui.Register("PIXEL.ImgurButton", PANEL, "PIXEL.ImageButton")
--PATH lua/pixelui/elements/cl_sidebar.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_text_button.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "TextAlign", "TextAlign", FORCE_NUMBER)
AccessorFunc(PANEL, "TextSpacing", "TextSpacing", FORCE_NUMBER)
AccessorFunc(PANEL, "Font", "Font", FORCE_STRING)

PIXEL.RegisterFont("UI.TextButton", "Open Sans SemiBold", 20)

function PANEL:Init()
    self:SetText("Button")
    self:SetTextAlign(TEXT_ALIGN_CENTER)
    self:SetTextSpacing(PIXEL.Scale(6))
    self:SetFont("UI.TextButton")

    self:SetSize(PIXEL.Scale(100), PIXEL.Scale(30))
end

function PANEL:SizeToText()
    PIXEL.SetFont(self:GetFont())
    self:SetSize(PIXEL.GetTextSize(self:GetText()) + PIXEL.Scale(14), PIXEL.Scale(30))
end

function PANEL:PaintExtra(w, h)
    local textAlign = self:GetTextAlign()
    local textX = (textAlign == TEXT_ALIGN_CENTER and w / 2) or (textAlign == TEXT_ALIGN_RIGHT and w - self:GetTextSpacing()) or self:GetTextSpacing()

    if not self:IsEnabled() then
        PIXEL.DrawSimpleText(self:GetText(), self:GetFont(), textX, h / 2, PIXEL.Colors.DisabledText, textAlign, TEXT_ALIGN_CENTER)
        return
    end

    PIXEL.DrawSimpleText(self:GetText(), self:GetFont(), textX, h / 2, PIXEL.Colors.PrimaryText, textAlign, TEXT_ALIGN_CENTER)
end

vgui.Register("PIXEL.TextButton", PANEL, "PIXEL.Button")
--PATH lua/pixelui/elements/cl_text_entry.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_text_entry_internal.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_sframe.lua:
local PANEL = {}

slib.setTheme("maincolor", Color(36,36,36))
slib.setTheme("accentcolor", Color(66,179,245))
slib.setTheme("margin", slib.getScaledSize(3, "x"))
slib.setTheme("textcolor", Color(255,255,255))
slib.setTheme("neutralcolor", Color(0,0,200,40))
slib.setTheme("topbarcolor", Color(44,44,44))
slib.setTheme("sidebarcolor", Color(34,34,34))
slib.setTheme("sidebarbttncolor", Color(39,39,39))
slib.setTheme("whitecolor", Color(255,255,255))
slib.setTheme("hovercolor", Color(255,255,255,100))
slib.setTheme("orangecolor", Color(130, 92, 10))
slib.setTheme("successcolor", Color(0,200,0))
slib.setTheme("failcolor", Color(200,0,0))
slib.setTheme("bgblur", true)

local topbarcolor, topbarcolor_min10, sidebarcolor, sidebarbttncolor, textcolor, accentcolor, maincolor, maincolor_7, maincolor_15, hovercolor = slib.getTheme("topbarcolor"), slib.getTheme("topbarcolor", -10), slib.getTheme("sidebarcolor"), slib.getTheme("sidebarbttncolor"), slib.getTheme("textcolor"), slib.getTheme("accentcolor"), slib.getTheme("maincolor"), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 15), slib.getTheme("hovercolor")
local accentcol_a100 = slib.getTheme("accentcolor")
accentcol_a100.a = 100

local black_a160 = Color(0,0,0,160)
local black_a140 = Color(0,0,0,140)

function PANEL:Init()
	self.topbarheight = slib.getScaledSize(30, "y")
	self.font = slib.createFont("Roboto", 21)
	self.tab = {}
	self.iterator = 0

	self.topbar = vgui.Create("EditablePanel", self)
	self.topbar:SetCursor("sizeall")
	self.topbar:SetSize(self:GetWide(), self.topbarheight)

	self.topbar.OnSizeChanged = function()
		if IsValid(self.close) then
			self.close:SetPos(self.topbar:GetWide() - self.close:GetWide() - slib.getScaledSize(3,"x"), 0)
		end
	end

	self.topbar.Paint = function(s, w, h)
		if !s.Holding and input.IsMouseDown(MOUSE_LEFT) then
				if s:IsHovered() then
					s.Move = true
				end

				s.Holding = true
				local x, y = gui.MouseX(), gui.MouseY()
				s.startedx, s.startedy = s:ScreenToLocal(x, y)
		elseif s.Holding and !input.IsMouseDown(MOUSE_LEFT) then
			s.Holding = nil
			s.Move = nil
		end

		if s.Move then
			local x, y = gui.MouseX(), gui.MouseY()
			local offsetx, offsety =  s:ScreenToLocal(x, y)
			
			self:SetPos(x - s.startedx, y - s.startedy)
		end

		draw.RoundedBoxEx(5, 0, 0, w, h, topbarcolor, true, true)

		surface.SetDrawColor(black_a160)
		surface.DrawRect(0, h - 1, w, 1)

		surface.SetDrawColor(black_a140)
		surface.DrawRect(0, h - 2, w, 1)
		draw.SimpleText(self.title, self.font, slib.getScaledSize(3,"x"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	self.frame = vgui.Create("EditablePanel", self)

	self.frame.Resize = function()
		local wide = 0

		if self.tabmenu then
			wide = wide + self.tabmenu:GetWide()
		end

		self.frame:SetPos(wide,self.topbarheight)
		self.frame:SetSize(self:GetWide() - wide, self:GetTall() - self.topbarheight)
		
		for k,v in pairs(self.tab) do
			self.tab[k]:SetSize(self.frame:GetWide(), self.frame:GetTall())
		end
	end

	self.frame.Resize()

	self.MadePanel = SysTime()

	slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
	slib.wrapFunction(self, "SetWide", nil, function() return self end, true)
	slib.wrapFunction(self, "Center", nil, function() return self end, true)
	slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
	slib.wrapFunction(self, "MakePopup", nil, function() return self end, true)
	slib.wrapFunction(self, "DockPadding", nil, function() return self end, true)
end

function PANEL:OnRemove()
	if !IsValid(self.bgclose) then return end
	self.bgclose:Remove()
end

function PANEL:SetBG(bool, close, col, makepopup)
	if !bool and IsValid(self.bgclose) then
		self:SetParent()
		self.bgclose:Remove()
		
		return
	end

	local parent = self:GetParent()

	local w, h

	if IsValid(parent) then
		w, h = parent:GetSize() 
	else
		w, h = ScrW(), ScrH()
	end

	self.bgclose = vgui.Create("SButton", parent)
	self.bgclose:SetSize(w, h)

	if makepopup then
		self.bgclose:MakePopup()
	else
		self.bgclose:MoveToFront()
	end

	self.bgclose.DoClick = function()
		if !close then return end

		if IsValid(self.bgclose) then
			self.bgclose:Remove()
		end

		if IsValid(self) then
			self:Remove()
		end
	end

	self.bgclose.bg = col

	self.bgclose.Paint = function(s,w,h)
		if !IsValid(self) then s:Remove() end
		
		if !s.bg then return end
		surface.SetDrawColor(s.bg)
		surface.DrawRect(0,0,w,h)
	end

	self:SetParent(self.bgclose)
	self:MoveToFront()
	
	return self
end

function PANEL:SetDraggable(bool)
	if IsValid(self.topbar) then
		self.topbar:SetMouseInputEnabled(bool)
	end

	return self
end

function PANEL:setTitle(str, font)
	self.title = str

	if font then
		self.font = font
	end
	
	return self
end

function PANEL:addCloseButton()
	self.close = vgui.Create("DButton", self)
	self.close:SetSize(slib.getScaledSize(25, "y"),slib.getScaledSize(25, "y"))
	self.close:SetMouseInputEnabled(true)
	self.close:SetPos(self.topbar:GetWide() - self.close:GetWide() - slib.getScaledSize(3,"x"), self.topbarheight * .5 - self.close:GetTall() * .5)
	self.close:SetText("")

	self.close.DoClick = function()
		if isfunction(self.onClose) then
			self.onClose()
		end
		
		if self.onlyHide then
			self:SetVisible(false)
		return end

		self:Remove()
	end

	self.close.Paint = function(s,w,h)
		local width = slib.getScaledSize(2, "X")
		local height = h * .7

		draw.NoTexture()

		local wantedCol = s:IsHovered() and color_white or hovercolor

        surface.SetDrawColor(slib.lerpColor(s, wantedCol))
		surface.DrawTexturedRectRotated(w - (height * .5), h * .5 - (width * .5), width, height, 45)
		surface.DrawTexturedRectRotated(w - (height * .5), h * .5 - (width * .5), width, height, -45)
	end

	return self
end

function PANEL:OnSizeChanged()
	self.topbar:SetSize(self:GetWide(), self.topbarheight)
	self.frame.Resize()
end

function PANEL:setBlur(bool)
	self.blur = bool

	return self
end

function PANEL:setDoClick(func)
	self.DoClick = func

	return self
end

function PANEL:Paint(w, h)
	if slib.getTheme("bgblur") and self.blur then
		Derma_DrawBackgroundBlur( self, self.MadePanel )
	end
	
	draw.RoundedBox(5, 0, 0, w, h, maincolor)
end

function PANEL:addTab(name, icon)
	if !IsValid(self.tabmenu) then
		self.tabmenu = vgui.Create("DScrollPanel", self)
		self.tabmenu:SetTall(self:GetTall() - self.topbarheight)
		self.tabmenu:SetPos(0, self.topbarheight)
		self.tabmenu.font = slib.createFont("Roboto", 14)
		self.tabmenu.Paint = function(s,w,h)
			draw.RoundedBoxEx(5, 0, 0, w, h, sidebarcolor, false, false, true, false)
		end

		self.tabmenu.OnSizeChanged = function()
			self.frame.Resize()
		end

		self.frame.Resize()
	end

	self.tab[name] = vgui.Create("EditablePanel", self.frame)
	self.tab[name]:SetSize(self.frame:GetWide(), self.frame:GetTall())
	self.tab[name]:SetVisible(false)
	self.tab[name].addTab = function(tab_name)
		local w, h, tab_h = self.tab[name]:GetWide(), self.tab[name]:GetTall(), slib.getScaledSize(32, "y")
		if !IsValid(self.tab[name].topbar) then
			self.tab[name].topbar = vgui.Create("EditablePanel", self.tab[name])
			self.tab[name].topbar:Dock(TOP)
			self.tab[name].topbar:SetTall(tab_h)
			self.tab[name].topbar.Paint = function(s,w,h)
				surface.SetDrawColor(maincolor_7)
				surface.DrawRect(0,0,w,h)
			end
		end

		local frame = vgui.Create("EditablePanel", self.tab[name])
		frame:SetPos(0, tab_h)
		frame:SetSize(w, h - tab_h)
		frame:SetVisible(false)

		local tab_button = vgui.Create("SButton", self.tab[name].topbar)
		tab_button.font = slib.createFont("Roboto", 16)
		tab_button.bg = maincolor_7
		tab_button.tab = frame

		tab_button.DoClick = function()
			if IsValid(self.tab[name].selTab) and self.tab[name].selTab:IsVisible() then
				self.tab[name].selTab.tabbttn.forcehover = nil
				self.tab[name].selTab.tabbttn.bg = maincolor_7
				self.tab[name].selTab:SetVisible(false)
			end

			frame:SetVisible(true)
			self.tab[name].selTab = frame

			tab_button.bg = maincolor_15
			tab_button.forcehover = true
		end

		frame.tabbttn = tab_button

		tab_button:setTitle(tab_name)
		:Dock(LEFT)

		local childs = self.tab[name].topbar:GetChildren()
		local width = math.ceil(self.frame:GetWide() / #childs)
		for k,v in ipairs(childs) do
			v:SetWide(width)
		end

		if #childs == 1 then
			tab_button.DoClick()
		end

		return frame
	end

	local height = slib.getScaledSize(28, "y")
	self.iterator = self.iterator + 1
	local tabbttn = vgui.Create("DButton", self.tabmenu)
	tabbttn:Dock(TOP)
	tabbttn:SetZPos(self.iterator)
	tabbttn:SetTall(height)
	tabbttn:SetText("")
	tabbttn.name = name

	tabbttn.getFrame = function()
		return self.tab[name]
	end

	if icon then
		tabbttn.icon = Material(icon, "smooth")
	end

	local icosize = height * .6
	local gap = height * .20

	tabbttn.Paint = function(s,w,h)
		surface.SetDrawColor(sidebarbttncolor)
		surface.DrawRect(0, 0, w, h)

		local wantedh = self.seltab == name and h or 0
		local curH = slib.lerpNum(s, wantedh, .9, true)

		if self.seltab == name then
			surface.SetDrawColor(accentcol_a100)
			surface.DrawRect(0, h * .5 - curH * .5, w, curH)
		end

		if s.icon then
			surface.SetDrawColor(color_white)
			surface.SetMaterial(s.icon)
			surface.DrawTexturedRect(gap,gap,icosize,icosize)
		end

		draw.SimpleText(name, self.tabmenu.font, (s.icon and icosize + gap or 0) + slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	tabbttn.DoClick = function()
		self:setActiveTab(name)

		if isfunction(self.changedTab) then
			self.changedTab(name)
		end
	end

	self.tab[name].tabbttn = tabbttn
	
	surface.SetFont(self.tabmenu.font)
	local w = select(1, surface.GetTextSize(name)) + (slib.getTheme("margin") * 4) + height

	if w > self.tabmenu:GetWide() then
		self.tabmenu:SetWide(w)
	end

	return self, tabbttn
end

function PANEL:setActiveTab(name)
	if !name then
		local childs = self.tabmenu:GetCanvas():GetChildren()
		local lowest, selected = math.huge
		for k,v in ipairs(childs) do
			local zpos = v:GetZPos()
			if zpos < lowest then
				selected = v.name
				lowest = zpos
			end

		end

		if selected then
			self:setActiveTab(selected)
		end

		return
	end

	if self.seltab and IsValid(self.tab[self.seltab]) then
		self.tab[self.seltab]:SetVisible(false)
	end

	self.seltab = name

	self.tab[name]:SetVisible(true)

	return self
end

vgui.Register("SFrame", PANEL, "EditablePanel")
--PATH lua/slib/vgui/cl_slistpanel.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_slistview.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/client/cl_overrides.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_german.lua:
if SERVER then
	slib.setLang("gprotect", "de", "colliding-too-much", "%s's Entities kollidieren zu sehr!")
	slib.setLang("gprotect", "de", "too-many-obstructs", "%s's Entity blockiert zu viele schlechte Entities!")
	slib.setLang("gprotect", "de", "blacklisted-multiple", "Du hast %s Modelle erfolgreich zu den blockieren Modellen hinzugefgt!")
	slib.setLang("gprotect", "de", "unblacklisted-multiple", "Du hast %s Modelle erfolgreich von den blockierten Modellen entfernt!")
	slib.setLang("gprotect", "de", "blacklisted-multiple-ent", "Du hast %s Entities erfolgreich zur Blacklist hinzugefgt!")
	slib.setLang("gprotect", "de", "unblacklisted-multiple-ent", "Du hast %s Entities erfolgreich von der Blacklist entfernt!")
	slib.setLang("gprotect", "de", "added-blacklist", "Du hast %s erfolgreich zu den blockieren Modellen hinzugefgt!")
	slib.setLang("gprotect", "de", "removed-blacklist", "Du hast %s erfolgreich von den blockierten Modellen entfernt")
	slib.setLang("gprotect", "de", "added-blacklist-ent", "Du hast %s erfolgreich zur Entity-Blacklist hinzugefgt!")
	slib.setLang("gprotect", "de", "removed-blacklist-ent", "Du hast %s erfolgreich von der Entity-Blacklist entfernt!")
	slib.setLang("gprotect", "de", "attempted-unfreeze-all", "%s hat versucht, alles nach dem Spawn einer Duplikation zu entfrieren!")
	slib.setLang("gprotect", "de", "attempted-upscaled-ent", "%s hat versucht, ein hochskaliertes Entity mit Adv Dupe 2 zu spawnen!")
	slib.setLang("gprotect", "de", "attempted-rope-spawning", "%s hat versucht, Seile mit Adv Dupe 2 zu spawnen!")
	slib.setLang("gprotect", "de", "attempted-no-gravity", "%s hat versucht, Entities ohne Schwerkraft mit Adv Dupe 2 zu spawnen!")

	slib.setLang("gprotect", "de", "model-restricted", "Die Nutzung dieses Modells wurde beschrnkt!")
	slib.setLang("gprotect", "de", "classname-restricted", "Die Nutzung dieser Entity-Klasse wurde beschrnkt!")
	slib.setLang("gprotect", "de", "attempted-blackout", "%s hat versucht, den Blackout-Exploit zu nutzen!")
	slib.setLang("gprotect", "de", "spam-spawning", "%s versucht, Entities/Props zu spammen.")

	slib.setLang("gprotect", "de", "too-complex-model", "Dieses Modell wurde eingeschrnkt, es ist zu komplex!")
	slib.setLang("gprotect", "de", "too-big-prop", "Dein Prop ist zu gro, desshalb haben wir es entfernt!")
	slib.setLang("gprotect", "de", "successfull-fpp-blockedmodels", "Du hast die blockierten Modelle erfolgreich von FPP nach gProtect bertragen!")
	slib.setLang("gprotect", "de", "successfull-fpp-grouptools", "Du hast die Gruppentools erfolgreich von FPP nach gProtect bertragen!")
	slib.setLang("gprotect", "de", "unsuccessfull-transfer", "Es scheint so als gbe es ein Problem mit der Datenbertragung! (MySQL wird nicht untersttzt)")

	slib.setLang("gprotect", "de", "you-ghosted-props", "Du hast %s's Props geghostet")
	slib.setLang("gprotect", "de", "you-frozen-props", "Du hast %s's Props eingefroren!")
	slib.setLang("gprotect", "de", "you-removed-props", "Du hast %s's Props entfernt!")

	slib.setLang("gprotect", "de", "props-ghosted", "Deine Props wurden geghostet!")
	slib.setLang("gprotect", "de", "props-frozen", "Deine Props wurden eingefroren!")
	slib.setLang("gprotect", "de", "props-removed", "Deine Props wurden entfernt!")

	slib.setLang("gprotect", "de", "everyones-props-ghosted", "Jemand hat alle Props gehostet!")
	slib.setLang("gprotect", "de", "everyones-props-frozen", "Jemand hat alle Props eingefroren")
	slib.setLang("gprotect", "de", "disconnected-ents-removed", "Du hast alle Entities von getrennten Spielern etnfernt!")

	slib.setLang("gprotect", "de", "insufficient-permission", "Du hast nicht die Berechtigung, dies zu tun!")
	slib.setLang("gprotect", "de", "spawn-to-close", "Dein Prop kann nicht in jemanden gespawnt werden!")
	slib.setLang("gprotect", "de", "entity-ghosted", "Dein Entitiy wurde gehostet!")
elseif CLIENT then
	slib.setLang("gprotect", "de", "title", "gProtect - Einstellungen")
	slib.setLang("gprotect", "de", "buddies-title", "gProtect - Freunde")

	slib.setLang("gprotect", "de", "world", "Welt")
	slib.setLang("gprotect", "de", "disconnected", "Getrennt")
	slib.setLang("gprotect", "de", "toolgun-name", "Blacklist Props")
	slib.setLang("gprotect", "de", "toolgun-desc", "Verwalte blockierte Modelle")
	slib.setLang("gprotect", "de", "toolgun-leftclick", "Fge zu blockierten Modellen hinzu")
	slib.setLang("gprotect", "de", "toolgun-rightclick", "Entferne von blockieren Modellen")
	slib.setLang("gprotect", "de", "toolgun-help", "Schiee auf ein Prop mit dem Werkzeug")
	slib.setLang("gprotect", "de", "remove-on-blacklist", "Entferne prop auf der Blacklist")
	slib.setLang("gprotect", "de", "player-list", "Spielerliste")

	slib.setLang("gprotect", "de", "toolgun", "Toolgun")
	slib.setLang("gprotect", "de", "physgun", "Physgun")
	slib.setLang("gprotect", "de", "gravity-gun", "Gravity Gun")
	slib.setLang("gprotect", "de", "canproperty", "Kann-Eigenschaft")

	slib.setLang("gprotect", "de", "add-blocked-models", "Fge zu blockierten Modellen hinzu")
	slib.setLang("gprotect", "de", "remove-blocked-models", "Entferne von blockierten Modellen")

	slib.setLang("gprotect", "de", "add-blacklisted-ents", "Fge zur Entity-Blacklist hinzu")
	slib.setLang("gprotect", "de", "remove-blacklisted-ents", "Entferne von Entity-Blacklist")
	slib.setLang("gprotect", "de", "copy-clipboard", "In Zwischenablage kopieren")

	slib.setLang("gprotect", "de", "general", "Allgemeines")
	slib.setLang("gprotect", "de", "ghosting", "Ghosting")
	slib.setLang("gprotect", "de", "damage", "Schaden")
	slib.setLang("gprotect", "de", "anticollide", "Anti Kollision")
	slib.setLang("gprotect", "de", "spamprotection", "Spam Schutz")
	slib.setLang("gprotect", "de", "spawnrestriction", "Spawn Beschrnkung")
	slib.setLang("gprotect", "de", "toolgunsettings", "Toolgun Einstellungen")
	slib.setLang("gprotect", "de", "physgunsettings", "Physgun Einstellungen")
	slib.setLang("gprotect", "de", "gravitygunsettings", "Gravgun Einstellungen")
	slib.setLang("gprotect", "de", "canpropertysettings", "Kann-Eigenschaft Einstellungen")
	slib.setLang("gprotect", "de", "advdupe2", "Adv Dupe 2")
	slib.setLang("gprotect", "de", "miscs", "Sonstiges")

	slib.setLang("gprotect", "de", "ghost-props", "Props ghosten")
	slib.setLang("gprotect", "de", "remove-props", "Props entfernen")
	slib.setLang("gprotect", "de", "freeze-props", "Props einfrieren")
	slib.setLang("gprotect", "de", "highlight-ents", "Markiere Entities")
	slib.setLang("gprotect", "de", "unhighlight-ents", "Demarkiere Entities")

	slib.setLang("gprotect", "de", "ghost-everyones-props", "Ghoste alle Props")
	slib.setLang("gprotect", "de", "freeze-everyones-props", "Friere alle Props ein")
	slib.setLang("gprotect", "de", "remove-disconnected-props", "Entferne Props von getrennten Spielern")

	slib.setLang("gprotect", "de", "general_remDiscPlyEnt", "Entferne Entities von getrennten Spielern")
	slib.setLang("gprotect", "de", "general_remDiscPlyEnt_tooltip", "Dies entfernt Entities von getrennten Spielern (deaktiviert falls -1.)")
	slib.setLang("gprotect", "de", "general_blacklist", "Blacklist")
	slib.setLang("gprotect", "de", "general_blacklist_tooltip", "Hier werden Klassennamen hinzugefgt, welche von allen Modulen beschtzt werden.")
	slib.setLang("gprotect", "de", "general_protectedFrozenEnts", "Geschtzte eingefrorene Entities")
	slib.setLang("gprotect", "de", "general_protectedFrozenEnts_tooltip", "Dies ist eine Liste von Entities, die im eingefrorenen Zustand geschtzt werden.")
	slib.setLang("gprotect", "de", "general_protectedFrozenGroup", "Geschtzte eingefrorene Gruppe")
	slib.setLang("gprotect", "de", "general_protectedFrozenGroup_tooltip", "Diese Kollisionsgruppe wird eingefrorenen Entities zugewiesen.")

	slib.setLang("gprotect", "de", "ghosting_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "ghosting_enabled_tooltip", "Aktiviere das Ghosting-Modul?")
	slib.setLang("gprotect", "de", "ghosting_ghostColor", "Ghosting Farbe")
	slib.setLang("gprotect", "de", "ghosting_ghostColor_tooltip", "Whle eine Farbe fr geghostete Entities")
	slib.setLang("gprotect", "de", "ghosting_antiObscuring", "Anti-Obscuring")
	slib.setLang("gprotect", "de", "ghosting_antiObscuring_tooltip", "Dies verhindert, dass Props entfroren werden, whrend sie in anderen Objekten stecken. Fg einfach Entities ein, welche nicht verdeckt werden sollen!")
	slib.setLang("gprotect", "de", "ghosting_onPhysgun", "Ghost bei Physgun?")
	slib.setLang("gprotect", "de", "ghosting_onPhysgun_tooltip", "Dies ghostet Entities, welche von der Physgun gehalten werden.")
	slib.setLang("gprotect", "de", "ghosting_useBlacklist", "Verwende Blacklist")
	slib.setLang("gprotect", "de", "ghosting_useBlacklist_tooltip", "Diese Option ghostet Gegenstnde auf der Blacklist, falls das Modul aktiv ist.")
	slib.setLang("gprotect", "de", "ghosting_entities", "Entities")
	slib.setLang("gprotect", "de", "ghosting_entities_tooltip", "Klassennamen in dieser Liste werden geghostet. Dies verndert nicht die Blacklist von anderen Modulen.")

	slib.setLang("gprotect", "de", "damage_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "damage_enabled_tooltip", "Aktiviere das Schadens-Modul?")
	slib.setLang("gprotect", "de", "damage_useBlacklist", "Verwende Blacklist")
	slib.setLang("gprotect", "de", "damage_useBlacklist_tooltip", "Diese Option betrachtet die allgemeine Blacklist als eine Entity Blacklist in diesem Modul!")
	slib.setLang("gprotect", "de", "damage_entities", "Entitiy Blacklist")
	slib.setLang("gprotect", "de", "damage_entities_tooltip", "Klassennamen in dieser Liste werden keinen Schaden zufgen, wenn Deaktiviere Schaden aktiv ist, dies modifiziert nicht die Blacklist, die durch andere Module verwendet wird.")
	slib.setLang("gprotect", "de", "damage_blacklistedEntPlayerDamage", "Deaktiviere Schaden von Entities auf der Blacklist")
	slib.setLang("gprotect", "de", "damage_blacklistedEntPlayerDamage_tooltip", "Wenn dies aktiviert ist, dann bekommen Spieler keinen Schaden von Entities, welche auf der Blacklist stehen.")
	slib.setLang("gprotect", "de", "damage_vehiclePlayerDamage", "Deaktiviere Fahrzeugschaden")
	slib.setLang("gprotect", "de", "damage_vehiclePlayerDamage_tooltip", "Wenn dies aktiviert ist, dann bekommen Spieler keinen Schaden von Fahrzeugen.")
	slib.setLang("gprotect", "de", "damage_worldPlayerDamage", "Deaktivierte Weltschaden")
	slib.setLang("gprotect", "de", "damage_worldPlayerDamage_tooltip", "Wenn dies aktiviert ist, dann bekommen Spieler keinen Schaden von Entities, die auf der Blacklist stehen.")
	slib.setLang("gprotect", "de", "damage_immortalEntities", "Unsterbliche Entities")
	slib.setLang("gprotect", "de", "damage_immortalEntities_tooltip", "Klassennamen in dieser Liste werden keinen Schaden nehmen, es sei denn, der Spieler ist in einer Ausnahmegruppe!")
	slib.setLang("gprotect", "de", "damage_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "damage_bypassGroups_tooltip", "Fge Gruppen in dieser Liste hinzu, welche die Schadensbeschrnkung umgehen. '*' heit alle!")
	slib.setLang("gprotect", "de", "damage_canDamageWorldEntities", "Kann Welt-Entities schaden")
	slib.setLang("gprotect", "de", "damage_canDamageWorldEntities_tooltip", "Gruppen in dieser Liste knnen Welt-Entities Schaden zufgen. '*' heit alle!")

	slib.setLang("gprotect", "de", "anticollide_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "anticollide_enabled_tooltip", "Aktiviere das Anti-Kollisions Modul?")
	slib.setLang("gprotect", "de", "anticollide_notifyStaff", "Benachrichtige Teammitglieder")
	slib.setLang("gprotect", "de", "anticollide_notifyStaff_tooltip", "Sollen Erkennungen Teammitglieder benachrichtigen? NB: Dies kann verwendet werden, um Teammitglieder zu nerven.")
	slib.setLang("gprotect", "de", "anticollide_protectDarkRPEntities", "Schtze DarkRP Entities")
	slib.setLang("gprotect", "de", "anticollide_protectDarkRPEntities_tooltip", "Sollen wir DarkRP-Entities schtzen? (0 = Deaktiviert, 1 = Ghost, 2 = Einfrieren, 3 = Entfernen, 4 = Entfernen & Erstattung)")
	slib.setLang("gprotect", "de", "anticollide_DRPentitiesThreshold", "DRP Entities Schwelle")
	slib.setLang("gprotect", "de", "anticollide_DRPentitiesThreshold_tooltip", "Wie viele Kollisionen kann ein DRP Entity innerhalb einer Sekunde haben, bevor das System ausgelst wird?")
	slib.setLang("gprotect", "de", "anticollide_DRPentitiesException", "DRP Entities Ausnahme")
	slib.setLang("gprotect", "de", "anticollide_DRPentitiesException_tooltip", "Welche Kollisionen sollen wir ignorieren? (0 = Keine, 1 = Unterschiedliche Besitzer, 2 = Kein Besitzer)")
	slib.setLang("gprotect", "de", "anticollide_protectSpawnedEntities", "Schtze gespawnte Entities")
	slib.setLang("gprotect", "de", "anticollide_protectSpawnedEntities_tooltip", "Sollen wir gespawnte Entities schtzen? (0 = Deaktiviert, 1 = Ghost, 2 = Einfrieren, 3 = Entfernen")
	slib.setLang("gprotect", "de", "anticollide_entitiesThreshold", "Gespawnte Entities Schwelle")
	slib.setLang("gprotect", "de", "anticollide_entitiesThreshold_tooltip", "Wie viele Kollisionen kann ein Entity innerhalb einer Sekunde haben, bevor das System ausgelst wird?")
	slib.setLang("gprotect", "de", "anticollide_entitiesException", "Gespawnte Entities Ausnahme")
	slib.setLang("gprotect", "de", "anticollide_entitiesException_tooltip", "Welche Kollisionen sollen wir ignorieren? (0 = Keine, 1 = Unterschiedliche Besitzer, 2 = Kein Besitzer)")
	slib.setLang("gprotect", "de", "anticollide_protectSpawnedProps", "Schtze gespawnte Props")
	slib.setLang("gprotect", "de", "anticollide_protectSpawnedProps_tooltip", "Sollen wir gespawnte Props schtzen? (0 = Deaktiviert, 1 = Ghost, 2 = Einfrieren, 3 = Entfernen")
	slib.setLang("gprotect", "de", "anticollide_propsThreshold", "Gespawnte Props Schwelle")
	slib.setLang("gprotect", "de", "anticollide_propsThreshold_tooltip", "Wie viele Kollisionen kann ein Prop innerhalb einer Sekunde haben, bevor das System ausgelst wird?")
	slib.setLang("gprotect", "de", "anticollide_propsException", "Gespawnte Props Ausnahme")
	slib.setLang("gprotect", "de", "anticollide_propsException_tooltip", "Welche Kollisionen sollen wir ignorieren? (0 = Keine, 1 = Unterschiedliche Besitzer, 2 = Kein Besitzer)")
	slib.setLang("gprotect", "de", "anticollide_useBlacklist", "Verwende Blacklist")
	slib.setLang("gprotect", "de", "anticollide_useBlacklist_tooltip", "Entities auf der Blacklist werden geghostet falls diese zu sehr kollidieren und dies aktiviert ist.")
	slib.setLang("gprotect", "de", "anticollide_ghostEntities", "Entities")
	slib.setLang("gprotect", "de", "anticollide_ghostEntities_tooltip", "Klassennamen in dieser Liste werden geghostet, falls diese zu sehr kollidieren.")

	slib.setLang("gprotect", "de", "spamprotection_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "spamprotection_enabled_tooltip", "Aktiviere das Spamschutz Modul?")
	slib.setLang("gprotect", "de", "spamprotection_threshold", "Schwelle")
	slib.setLang("gprotect", "de", "spamprotection_threshold_tooltip", "Wenn du so viele Props gleichzeitig spawnst, dann greift das System ein, es sei denn, die unten definierte Verzgerung ist abgelaufen.")
	slib.setLang("gprotect", "de", "spamprotection_delay", "Verzgerung")
	slib.setLang("gprotect", "de", "spamprotection_delay_tooltip", "Dieser Timer lscht die obere Schwelle.")
	slib.setLang("gprotect", "de", "spamprotection_action", "Bestrafung")
	slib.setLang("gprotect", "de", "spamprotection_action_tooltip", "Dies entscheidet, wie mit Spammern umgegangen werden soll! (1 = Verweigere Spawn, 2 = Entity/Prop ghosten)")
	slib.setLang("gprotect", "de", "spamprotection_notifyStaff", "Benachrichtige Teammitglieder")
	slib.setLang("gprotect", "de", "spamprotection_notifyStaff_tooltip", "Sollen Erkennungen Teammitglieder benachrichtigen? NB: Dies kann verwendet werden, um Teammitglieder zu nerven.")
	slib.setLang("gprotect", "de", "spamprotection_protectProps", "Schtze Props")
	slib.setLang("gprotect", "de", "spamprotection_protectProps_tooltip", "Dies schtzt Props vor Spam.")
	slib.setLang("gprotect", "de", "spamprotection_protectEntities", "Schtze Entities")
	slib.setLang("gprotect", "de", "spamprotection_protectEntities_tooltip", "Dies schtzt Entities vor Spam")

	slib.setLang("gprotect", "de", "spawnrestriction_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "spawnrestriction_enabled_tooltip", "Aktiviere das Spawn-EinschrnkungsModul?")
	slib.setLang("gprotect", "de", "spawnrestriction_propSpawnPermission", "Prop Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_propSpawnPermission_tooltip", "Dies schrnkt das Spawnen von Props vollstndig ein! (Fge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_SENTSpawnPermission", "SENT Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_SENTSpawnPermission_tooltip", "Dies schrnkt das Spawnen von SENTs vollstndig ein! (Fge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_SWEPSpawnPermission", "SWEP Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_SWEPSpawnPermission_tooltip", "Dies schrnkt das Spawnen von SWEPs vollstndig ein! (Fge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_vehicleSpawnPermission", "Fahrzeug Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_vehicleSpawnPermission_tooltip", "Dies schrnkt das Spawnen von Fahrzeugen vollstndig ein! (Fge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_NPCSpawnPermission", "NPC Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_NPCSpawnPermission_tooltip", "Dies schrnkt das Spawnen von NPCs vollstndig ein! (Fge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_ragdollSpawnPermission", "Ragdoll Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_ragdollSpawnPermission_tooltip", "Dies schrnkt das Spawnen von Ragdolls vollstndig ein! (Fge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_effectSpawnPermission", "Effekte Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_effectSpawnPermission_tooltip", "Dies schrnkt das Spawnen von Effekten vollstndig ein! (Fge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedEntities", "Blockierte SENTs")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedEntities_tooltip", "Platziere hier Klassennamen von Entities, welche nie gespawnt werden sollen!")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedEntitiesIsBlacklist", "Blockierte Klassen sind Blacklist")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedEntitiesIsBlacklist_tooltip", "Falls aktiviert, dann werden Klassen in der Liste blockiert, ansonsten kannst du nur diese Klassen spawnen.")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedModels", "Blockierte Modelle")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedModels_tooltip", "Platziere Modellnamen, damit Props mit diesem Modellnamen nicht spawnen!")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedModelsisBlacklist", "Blockierte Modelle sind Blacklist")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedModelsisBlacklist_tooltip", "Falls aktiviert, dann werden Modelle in dieser Liste blockiert, ansonsten kannst du nur diese Modelle spawnen.")
	slib.setLang("gprotect", "de", "spawnrestriction_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "spawnrestriction_bypassGroups_tooltip", "Diese Gruppen knnen blockierte SENTs und Modelle umgehen.")
	slib.setLang("gprotect", "de", "spawnrestriction_maxModelSize", "Maximale Modellgre")
	slib.setLang("gprotect", "de", "spawnrestriction_maxModelSize_tooltip", "Falls dies grer 0 ist, entfernt es grere Props direkt nach dem Spawn.")

	slib.setLang("gprotect", "de", "toolgunsettings_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "toolgunsettings_enabled_tooltip", "Aktiviere das Werkzeug-Einstellungsmodul?")
	slib.setLang("gprotect", "de", "toolgunsettings_targetWorld", "Kann Weltentities anvisieren")
	slib.setLang("gprotect", "de", "toolgunsettings_targetWorld_tooltip", "Dies bedeutet, dass sie Weltentities und -props anvisieren knnen! (Fge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "toolgunsettings_targetPlayerOwned", "Kann Spielerentities anvisieren")
	slib.setLang("gprotect", "de", "toolgunsettings_targetPlayerOwned_tooltip", "Dies bedeutet, dass sie Spielerentities und -props anvisieren knnen! (Fge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "toolgunsettings_restrictTools", "Eingeschrnkte Werkzeuge")
	slib.setLang("gprotect", "de", "toolgunsettings_restrictTools_tooltip", "Die Werkzeuge hier knnen von niemanden auer den Ausnahmegruppen benutzt werden.")
	slib.setLang("gprotect", "de", "toolgunsettings_groupToolRestrictions", "Gruppen Werkzeugeinschrnkungen")
	slib.setLang("gprotect", "de", "toolgunsettings_groupToolRestrictions_tooltip", "Konfiguriere Werkzeugbeschrnkungen nach Werkzeug")
	slib.setLang("gprotect", "de", "toolgunsettings_entityTargetability", "Entity Anvisierbarkeit")
	slib.setLang("gprotect", "de", "toolgunsettings_entityTargetability_tooltip", "Dies ist ntzlich, wenn z.B Spieler die Toolgun nur auf ihre eigenen Props anwenden knnen!")
	slib.setLang("gprotect", "de", "toolgunsettings_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "toolgunsettings_bypassGroups_tooltip", "Gruppen in dieser Liste umgehen die Wekzeugbeschrnkungsliste von oben!")

	slib.setLang("gprotect", "de", "physgunsettings_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "physgunsettings_enabled_tooltip", "Aktiviere das Physgun Einstellungsmodul?")
	slib.setLang("gprotect", "de", "physgunsettings_targetWorld", "Kann Welt-Entities anvisieren")
	slib.setLang("gprotect", "de", "physgunsettings_targetWorld_tooltip", "Dies bedeutet, dass sie Weltentities und -props anvisieren knnen! (Fge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "physgunsettings_targetPlayerOwned", "Kann Spielerentities anvisieren")
	slib.setLang("gprotect", "de", "physgunsettings_targetPlayerOwned_tooltip", "Dies bedeutet, dass sie Spielerentities und -props anvisieren knnen! (Fge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "physgunsettings_DisableReloadUnfreeze", "Deaktiviere Nachladen-Entfrieren")
	slib.setLang("gprotect", "de", "physgunsettings_DisableReloadUnfreeze_tooltip", "Dies verhindert, dass Personen Props mit Nachladen entfrieren.")
	slib.setLang("gprotect", "de", "physgunsettings_PickupVehiclePermission", "Fahrzeug aufheben Berechtigung")
	slib.setLang("gprotect", "de", "physgunsettings_PickupVehiclePermission_tooltip", "Personen in diesen Gruppen knnen Fahrzeuge aufheben!")
	slib.setLang("gprotect", "de", "physgunsettings_StopMotionOnDrop", "Stoppe Bewegung beim Fallenlassen")
	slib.setLang("gprotect", "de", "physgunsettings_StopMotionOnDrop_tooltip", "Dies verhindert Proppushing/Propkilling.")
	slib.setLang("gprotect", "de", "physgunsettings_blockMultiplePhysgunning", "Blockiere mehrfaches Physgunnen")
	slib.setLang("gprotect", "de", "physgunsettings_blockMultiplePhysgunning_tooltip", "Dies verhindert, dass jemand ein Entity physgunnt, welches bereits gephysgunnt wird!")
	slib.setLang("gprotect", "de", "physgunsettings_maxDropObstructs", "Maximale Blockierschwelle")
	slib.setLang("gprotect", "de", "physgunsettings_maxDropObstructs_tooltip", "Dies ist die Schwelle von wie vielen Blockierungen von Entities, welche auf der Blacklist stehen, bis das System ausgelst wird!")
	slib.setLang("gprotect", "de", "physgunsettings_maxDropObstructsAction", "Maximale Blockierschwelle Auslsaktion")
	slib.setLang("gprotect", "de", "physgunsettings_maxDropObstructsAction_tooltip", "Dies ist wie wir mit Auslsungen umgehen (1 = Ghost, 2 = Einfrieren, 3 = Entfernen)")
	slib.setLang("gprotect", "de", "physgunsettings_blockedEntities", "Blockierte Entities")
	slib.setLang("gprotect", "de", "physgunsettings_blockedEntities_tooltip", "Fge hier Entities hinzu und sie werden von niemanden, der nicht in einer Ausnahmegruppe ist, gephysgunnt werden knnen.")
	slib.setLang("gprotect", "de", "physgunsettings_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "physgunsettings_bypassGroups_tooltip", "Fge Nutzergruppen in dieser Liste hinzu, damit diese die blockierten Entities umgehen, '*' bedeutet alle!")

	slib.setLang("gprotect", "de", "gravitygunsettings_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "gravitygunsettings_enabled_tooltip", "Aktiviere das Gravity Gun Einstellungsmodul?")
	slib.setLang("gprotect", "de", "gravitygunsettings_targetWorld", "Kann Welt-Entities anvisieren")
	slib.setLang("gprotect", "de", "gravitygunsettings_targetWorld_tooltip", "Dies bedeutet, dass sie Weltentities und -props anvisieren knnen! (Fge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "gravitygunsettings_targetPlayerOwned", "Kann Spielerentities anvisieren")
	slib.setLang("gprotect", "de", "gravitygunsettings_targetPlayerOwned_tooltip", "Dies bedeutet, dass sie Spielerentities und -props anvisieren knnen! (Fge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "gravitygunsettings_DisableGravityGunPunting", "Deaktiviere Gravity Gun Werfen")
	slib.setLang("gprotect", "de", "gravitygunsettings_DisableGravityGunPunting_tooltip", "Dies ist die Wurfattacke der Gravity Gun.")
	slib.setLang("gprotect", "de", "gravitygunsettings_blockedEntities", "Blockierte Entities")
	slib.setLang("gprotect", "de", "gravitygunsettings_blockedEntities_tooltip", "Fge hier Entities hinzu und sie werden von niemanden, der nicht in einer Ausnahmegruppe ist, gephysgunnt werden knnen.")
	slib.setLang("gprotect", "de", "gravitygunsettings_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "gravitygunsettings_bypassGroups_tooltip", "Fge Nutzergruppen in dieser Liste hinzu, damit diese die blockierten Entities umgehen, '*' bedeutet alle!")

	slib.setLang("gprotect", "de", "canpropertysettings_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "canpropertysettings_enabled_tooltip", "Aktiviere das Kann-Eigenschaft Einstellungsmodul?")
	slib.setLang("gprotect", "de", "canpropertysettings_targetWorld", "Kann Welt-Entities anvisieren")
	slib.setLang("gprotect", "de", "canpropertysettings_targetWorld_tooltip", "Dies bedeutet, dass sie Weltentities und -props anvisieren knnen! (Fge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "canpropertysettings_targetPlayerOwned", "Kann Spielerentities anvisieren")
	slib.setLang("gprotect", "de", "canpropertysettings_targetPlayerOwned_tooltip", "Dies bedeutet, dass sie Spielerentities und -props anvisieren knnen! (Fge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedProperties", "Blockierte Eigenschaften")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedProperties_tooltip", "Fge Eigenschaften zu dieser Liste hinzu")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedPropertiesisBlacklist", "Blockierte Eigenschaften sind Blacklist")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedPropertiesisBlacklist_tooltip", "Falls aktiviert, dann werden Eigenschaften in der Liste blockiert, ansonsten kannst du nur diese Eigenschaften nutzen.")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedEntities", "Blockierte Entities")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedEntities_tooltip", "Fge hier Entities hinzu, damit sie von niemanden mehr anvisiert knnen, auer von den Leuten in der Ausnahme Gruppe!")
	slib.setLang("gprotect", "de", "canpropertysettings_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "canpropertysettings_bypassGroups_tooltip", "Gruppen in dieser Liste umgehen die Kann-Eigenschaft Beschrnkungsliste von oben!")

	slib.setLang("gprotect", "de", "advdupe2_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "advdupe2_enabled_tooltip", "Sollen Erkennungen Teammitglieder benachrichtigen? NB: Dies kann verwendet werden, um Teammitglieder zu nerven.")
	slib.setLang("gprotect", "de", "advdupe2_notifyStaff", "Benachrichtige Teammitglieder")
	slib.setLang("gprotect", "de", "advdupe2_notifyStaff_tooltip", "Sollen Erkennungen Teammitglieder benachrichtigen? NB: Dies kann verwendet werden, um Teammitglieder zu nerven.")
	slib.setLang("gprotect", "de", "advdupe2_PreventRopes", "Verhindere Seil-Spawn")
	slib.setLang("gprotect", "de", "advdupe2_PreventRopes_tooltip", "Verhindere das Spawnen von Seilen! (1 = Verhindere Spawn, 2 = Spawn aber beheben)")
	slib.setLang("gprotect", "de", "advdupe2_PreventScaling", "Verhindere Skalierung")
	slib.setLang("gprotect", "de", "advdupe2_PreventScaling_tooltip", "Verhindere das Spawnen von hochskalierten Props. (1 = Verhindere Spawn, 2 = Spawn aber beheben)")
	slib.setLang("gprotect", "de", "advdupe2_PreventNoGravity", "Verhindere keine Schwerkraft")
	slib.setLang("gprotect", "de", "advdupe2_PreventNoGravity_tooltip", "Verhindere das Spawnen von Props ohne Schwerkraft. (1 = Verhindere Spawn, 2 = Spawn aber beheben)")
	slib.setLang("gprotect", "de", "advdupe2_PreventUnfreezeAll", "Verhindere Unfreeze All")
	slib.setLang("gprotect", "de", "advdupe2_PreventUnfreezeAll_tooltip", "Verhindere, dass Personen alle Props entfrieren. (1 = Verhindere Spawn, 2 = Spawn aber beheben)")
	slib.setLang("gprotect", "de", "advdupe2_BlacklistedCollisionGroups", "Kollisionsgruppe Blacklist")
	slib.setLang("gprotect", "de", "advdupe2_BlacklistedCollisionGroups_tooltip", "Dies schtzt vor Props die du nicht anvisieren kannst. NB: Werte mssen Kollisions-ENUMs sein")
	slib.setLang("gprotect", "de", "advdupe2_WhitelistedConstraints", "Verbindungs Whitelist")
	slib.setLang("gprotect", "de", "advdupe2_WhitelistedConstraints_tooltip", "Dies dient um ungewollte Verbindungen zu verhindern.")

	slib.setLang("gprotect", "de", "miscs_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "miscs_enabled_tooltip", "Aktiviere das Sonstiges Modul?")
	slib.setLang("gprotect", "de", "miscs_ClearDecals", "Clear decals Timer")
	slib.setLang("gprotect", "de", "miscs_ClearDecals_tooltip", "Timer in Sekunden. Dies lscht die Decals fr alle Spieler nach dem Timer :)")
	slib.setLang("gprotect", "de", "miscs_NoBlackoutGlitch", "Verhindere Blackout-Exploit")
	slib.setLang("gprotect", "de", "miscs_NoBlackoutGlitch_tooltip", "Zahl Dies verhindert den 'pp/copy'  (1 = Benachrichtigung, 2 = Kick, 3 = Ban).")
	slib.setLang("gprotect", "de", "miscs_FadingDoorLag", "Verhindere Fading Door Lag")
	slib.setLang("gprotect", "de", "miscs_FadingDoorLag_tooltip", "Dies verhindert, dass Personen den Server mit dem Fading Door Werkzeug zum Absturz bringen.")
	slib.setLang("gprotect", "de", "miscs_DisableMotion", "Deaktiviere Bewegung")
	slib.setLang("gprotect", "de", "miscs_DisableMotion_tooltip", "Dies deaktiviert die Bewegung fr alle Entities auf der Blacklist.")
	slib.setLang("gprotect", "de", "miscs_freezeOnSpawn", "Friere beim Spawn ein")
	slib.setLang("gprotect", "de", "miscs_freezeOnSpawn_tooltip", "Dies friert Props ein, sobald diese gespawnt werden")
	slib.setLang("gprotect", "de", "miscs_preventFadingDoorAbuse", "Verhindere Fading Door Missbrauch")
	slib.setLang("gprotect", "de", "miscs_preventFadingDoorAbuse_tooltip", "Dies verhindert, dass Personen in Fading Doors festgesetzt werden.")
	slib.setLang("gprotect", "de", "miscs_preventSpawnNearbyPlayer", "Verhindere Spawn in der Nhe")
	slib.setLang("gprotect", "de", "miscs_preventSpawnNearbyPlayer_tooltip", "Falls jemand nher als dieser Wert zur Spawnposition befindet, wird das Prop nicht gespawnt (0 bedeutet deaktiviert)")
	slib.setLang("gprotect", "de", "miscs_DRPEntForceOwnership", "Erzwinge Besitz auf DarkRP Entities")
	slib.setLang("gprotect", "de", "miscs_DRPEntForceOwnership_tooltip", "Dies erzwingt den Besitz von Entities, welche im F4 Men gekauft wurden")
end
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_russian.lua:
--russian translate from the MinimalRP team & St11l for Stromic <300

if SERVER then
	slib.setLang("gprotect", "ru", "colliding-too-much", "%s    ")
	slib.setLang("gprotect", "ru", "too-many-obstructs", "%s     ")
	slib.setLang("gprotect", "ru", "blacklisted-multiple", "  %s    ")
	slib.setLang("gprotect", "ru", "unblacklisted-multiple", " %s    ")
	slib.setLang("gprotect", "ru", "blacklisted-multiple-ent", " %s    ")
	slib.setLang("gprotect", "ru", "unblacklisted-multiple-ent", " %s    ")
	slib.setLang("gprotect", "ru", "added-blacklist", " %s    ")
	slib.setLang("gprotect", "ru", "removed-blacklist", " %s   ")
	slib.setLang("gprotect", "ru", "added-blacklist-ent", " %s    ")
	slib.setLang("gprotect", "ru", "removed-blacklist-ent", " %s    ")
	slib.setLang("gprotect", "ru", "attempted-unfreeze-all", "%s      ")
	slib.setLang("gprotect", "ru", "attempted-upscaled-ent", "%s        ")
	slib.setLang("gprotect", "ru", "attempted-rope-spawning", "%s   ,  ")
	slib.setLang("gprotect", "ru", "attempted-no-gravity", "%s     ,  ")
	slib.setLang("gprotect", "ru", "attempted-trail", "%s       ")

	slib.setLang("gprotect", "ru", "model-restricted", "   ")
	slib.setLang("gprotect", "ru", "classname-restricted", "    ")
	slib.setLang("gprotect", "ru", "attempted-blackout", "%s    ")
	slib.setLang("gprotect", "ru", "spam-spawning", "%s     ")

    slib.setLang("gprotect", "ru", "too-complex-model", "   ,     !")
	slib.setLang("gprotect", "ru", "too-big-prop", "  ,    ")
	slib.setLang("gprotect", "ru", "successfull-fpp-blockedmodels", "      FPP  gProtect")
	slib.setLang("gprotect", "ru", "successfull-fpp-grouptools", "      FPP  gProtect")
	slib.setLang("gprotect", "ru", "unsuccessfull-transfer", ",     ! (MySQL  )")

	slib.setLang("gprotect", "ru", "you-ghosted-props", "  %s   ")
	slib.setLang("gprotect", "ru", "you-frozen-props", "    %s ")
	slib.setLang("gprotect", "ru", "you-removed-props", "    %s ")
	slib.setLang("gprotect", "ru", "you-removed-ents", "    %s")

	slib.setLang("gprotect", "ru", "props-ghosted", "   ")
	slib.setLang("gprotect", "ru", "props-frozen", "   ")
	slib.setLang("gprotect", "ru", "props-removed", "   ")
	slib.setLang("gprotect", "ru", "ents-removed", "   ")

	slib.setLang("gprotect", "ru", "everyones-props-ghosted", "    ")
	slib.setLang("gprotect", "ru", "everyones-props-frozen", "   ")
	slib.setLang("gprotect", "ru", "disconnected-ents-removed", "    , ,  ")

	slib.setLang("gprotect", "ru", "spawn-to-close", "     ")
	slib.setLang("gprotect", "ru", "entity-ghosted", "    ")

	slib.setLang("gprotect", "ru", "ratelimited_toolgun", ",   !     ")
	slib.setLang("gprotect", "ru", "too_many_obstructs_purchase", "     .   ,   ")

	slib.setLang("gprotect", "ru", "mysql_successfull", "[gProtect]      ")
    slib.setLang("gprotect", "ru", "mysql_failed", "[gProtect]      ")
elseif CLIENT then
	slib.setLang("gprotect", "ru", "title", " gProtect")
	slib.setLang("gprotect", "ru", "buddies-title", "   ")

	slib.setLang("gprotect", "ru", "world", "World")
	slib.setLang("gprotect", "ru", "disconnected", "")
	slib.setLang("gprotect", "ru", "toolgun-name", " ")
	slib.setLang("gprotect", "ru", "toolgun-desc", "  ")
	slib.setLang("gprotect", "ru", "toolgun-leftclick", "    ")
	slib.setLang("gprotect", "ru", "toolgun-rightclick", "    ")
	slib.setLang("gprotect", "ru", "toolgun-help", "   ")
	slib.setLang("gprotect", "ru", "remove-on-blacklist", "     ")
	slib.setLang("gprotect", "ru", "player-list", " ")

	slib.setLang("gprotect", "ru", "submit", "")
	slib.setLang("gprotect", "ru", "input_number", " ")

	slib.setLang("gprotect", "ru", "toolgun", "")
	slib.setLang("gprotect", "ru", "physgun", "")
	slib.setLang("gprotect", "ru", "gravity-gun", "")
	slib.setLang("gprotect", "ru", "canproperty", " ")

	slib.setLang("gprotect", "ru", "add-blocked-models", "   ")
	slib.setLang("gprotect", "ru", "remove-blocked-models", "   ")

	slib.setLang("gprotect", "ru", "add-blacklisted-ents", "   ")
	slib.setLang("gprotect", "ru", "remove-blacklisted-ents", "   ")
	slib.setLang("gprotect", "ru", "copy-clipboard", "")

	slib.setLang("gprotect", "ru", "general", "")
	slib.setLang("gprotect", "ru", "ghosting", "")
	slib.setLang("gprotect", "ru", "damage", "")
	slib.setLang("gprotect", "ru", "anticollide", "-")
	slib.setLang("gprotect", "ru", "spamprotection", "  ")
	slib.setLang("gprotect", "ru", "spawnrestriction", "  ")
	slib.setLang("gprotect", "ru", "toolgunsettings", " ")
	slib.setLang("gprotect", "ru", "physgunsettings", " ")
	slib.setLang("gprotect", "ru", "gravitygunsettings", " ")
	slib.setLang("gprotect", "ru", "canpropertysettings", " ")
	slib.setLang("gprotect", "ru", "advdupe2", "")
	slib.setLang("gprotect", "ru", "miscs", "")

	slib.setLang("gprotect", "ru", "ghost-props", " ")
	slib.setLang("gprotect", "ru", "remove-props", " ")
	slib.setLang("gprotect", "ru", "freeze-props", " ")
	slib.setLang("gprotect", "ru", "remove-entities", " ")
	slib.setLang("gprotect", "ru", "highlight-ents", "  ")
	slib.setLang("gprotect", "ru", "unhighlight-ents", "  ")

	slib.setLang("gprotect", "ru", "ghost-everyones-props", "   ")
	slib.setLang("gprotect", "ru", "freeze-everyones-props", "  ")
	slib.setLang("gprotect", "ru", "remove-disconnected-entities", "   ")

	slib.setLang("gprotect", "ru", "general_remDiscPlyEnt", "   ")
	slib.setLang("gprotect", "ru", "general_remDiscPlyEnt_tooltip", "      ( -1,   )")
	slib.setLang("gprotect", "ru", "general_remDiscPlyEntSpecific", "    ")
	slib.setLang("gprotect", "ru", "general_remDiscPlyEntSpecific_tooltip", "  .    ,      .   -1,     ")
    slib.setLang("gprotect", "ru", "general_blacklist", " ")
	slib.setLang("gprotect", "ru", "general_blacklist_tooltip", " ,      ")
	slib.setLang("gprotect", "ru", "general_protectedFrozenEnts", "  ")
	slib.setLang("gprotect", "ru", "general_protectedFrozenEnts_tooltip", "  ,      ")
	slib.setLang("gprotect", "ru", "general_protectedFrozenGroup", "ollision groups    ")
	slib.setLang("gprotect", "ru", "general_protectedFrozenGroup_tooltip", "ollision group,      ")

	slib.setLang("gprotect", "ru", "ghosting_enabled", "")
	slib.setLang("gprotect", "ru", "ghosting_enabled_tooltip", "  ?")
	slib.setLang("gprotect", "ru", "ghosting_ghostColor", " ")
	slib.setLang("gprotect", "ru", "ghosting_ghostColor_tooltip", "   ")
	slib.setLang("gprotect", "ru", "ghosting_antiObscuring", "-")
	slib.setLang("gprotect", "ru", "ghosting_antiObscuring_tooltip", "    ,    .  ,     ")
	slib.setLang("gprotect", "ru", "ghosting_onPhysgun", "   ")
	slib.setLang("gprotect", "ru", "ghosting_onPhysgun_tooltip", "     ")
	slib.setLang("gprotect", "ru", "ghosting_useBlacklist", "  ")
	slib.setLang("gprotect", "ru", "ghosting_useBlacklist_tooltip", "      ,   ")
	slib.setLang("gprotect", "ru", "ghosting_entities", "")
	slib.setLang("gprotect", "ru", "ghosting_entities_tooltip", "      ,     ,   ")

	slib.setLang("gprotect", "ru", "damage_enabled", "")
	slib.setLang("gprotect", "ru", "damage_enabled_tooltip", "  ?")
	slib.setLang("gprotect", "ru", "damage_useBlacklist", "  ")
	slib.setLang("gprotect", "ru", "damage_useBlacklist_tooltip", "     '',     ")
	slib.setLang("gprotect", "ru", "damage_entities", "  ")
	slib.setLang("gprotect", "ru", "damage_entities_tooltip", "       ,   ,     ,   ")
	slib.setLang("gprotect", "ru", "damage_blacklistedEntPlayerDamage", "      ")
	slib.setLang("gprotect", "ru", "damage_blacklistedEntPlayerDamage_tooltip", "   ,          ")
	slib.setLang("gprotect", "ru", "damage_vehiclePlayerDamage", "   ")
	slib.setLang("gprotect", "ru", "damage_vehiclePlayerDamage_tooltip", "   ,        ")
	slib.setLang("gprotect", "ru", "damage_worldPlayerDamage", "     World")
	slib.setLang("gprotect", "ru", "damage_worldPlayerDamage_tooltip", "   ,         ")
	slib.setLang("gprotect", "ru", "damage_immortalEntities", " ")
	slib.setLang("gprotect", "ru", "damage_immortalEntities_tooltip", "      ,  ,       ")
	slib.setLang("gprotect", "ru", "damage_bypassGroups", " ")
	slib.setLang("gprotect", "ru", "damage_bypassGroups_tooltip", " ,      .  '*'   ")
	slib.setLang("gprotect", "ru", "damage_canDamageWorldEntities", "   World ")
	slib.setLang("gprotect", "ru", "damage_canDamageWorldEntities_tooltip", ",     ,    World .  '*'   ")

	slib.setLang("gprotect", "ru", "anticollide_enabled", "")
	slib.setLang("gprotect", "ru", "anticollide_enabled_tooltip", "    ?")
	slib.setLang("gprotect", "ru", "anticollide_notifyStaff", " ")
	slib.setLang("gprotect", "ru", "anticollide_notifyStaff_tooltip", "  ,   ")
	slib.setLang("gprotect", "ru", "anticollide_protectDarkRPEntities", " DRP ")
	slib.setLang("gprotect", "ru", "anticollide_protectDarkRPEntities_tooltip", "  DarkRP? (0 = , 1 =  , 2 = , 3 = , 4 =    )")
	slib.setLang("gprotect", "ru", "anticollide_DRPentitiesThreshold", "   DRP")
	slib.setLang("gprotect", "ru", "anticollide_DRPentitiesThreshold_tooltip", "       ,      1 ?")
	slib.setLang("gprotect", "ru", "anticollide_DRPentitiesException", " DRP  ")
	slib.setLang("gprotect", "ru", "anticollide_DRPentitiesException_tooltip", "   ? (0 = , 1 =   , 2 =   )")
	slib.setLang("gprotect", "ru", "anticollide_protectSpawnedEntities", "  ")
	slib.setLang("gprotect", "ru", "anticollide_protectSpawnedEntities_tooltip", "    ? (0 = , 1 =  , 2 = , 3 = )")
	slib.setLang("gprotect", "ru", "anticollide_entitiesThreshold", "  ")
	slib.setLang("gprotect", "ru", "anticollide_entitiesThreshold_tooltip", "       ,      1 ?")
	slib.setLang("gprotect", "ru", "anticollide_entitiesException", "  ")
	slib.setLang("gprotect", "ru", "anticollide_entitiesException_tooltip", "   ? (0 = , 1 =   , 2 =   )")
	slib.setLang("gprotect", "ru", "anticollide_protectSpawnedProps", "  ")
	slib.setLang("gprotect", "ru", "anticollide_protectSpawnedProps_tooltip", "     ? (0 = , 1 =  , 2 = , 3 = )")
	slib.setLang("gprotect", "ru", "anticollide_propsThreshold", "  ")
	slib.setLang("gprotect", "ru", "anticollide_propsThreshold_tooltip", "           1 ?")
	slib.setLang("gprotect", "ru", "anticollide_propsException", "  ")
	slib.setLang("gprotect", "ru", "anticollide_propsException_tooltip", "   ? (0 = , 1 =   , 2 =   )")
	slib.setLang("gprotect", "ru", "anticollide_useBlacklist", "  ")
	slib.setLang("gprotect", "ru", "anticollide_useBlacklist_tooltip", ",    ,   ,     ,   ")
	slib.setLang("gprotect", "ru", "anticollide_ghostEntities", "")
	slib.setLang("gprotect", "ru", "anticollide_ghostEntities_tooltip", "      ,      ")
	slib.setLang("gprotect", "ru", "anticollide_specificEntities", " ")
	slib.setLang("gprotect", "ru", "anticollide_specificEntities_tooltip", ",     ,    .   0   ")

	slib.setLang("gprotect", "ru", "spamprotection_enabled", "")
	slib.setLang("gprotect", "ru", "spamprotection_enabled_tooltip", "    ?")
	slib.setLang("gprotect", "ru", "spamprotection_threshold", "  ")
	slib.setLang("gprotect", "ru", "spamprotection_threshold_tooltip", "    ,     ")
	slib.setLang("gprotect", "ru", "spamprotection_delay", "  ")
	slib.setLang("gprotect", "ru", "spamprotection_delay_tooltip", ",       ")
	slib.setLang("gprotect", "ru", "spamprotection_action", "     ")
	slib.setLang("gprotect", "ru", "spamprotection_action_tooltip", " ,    ! (1 =  , 2 =   )")
	slib.setLang("gprotect", "ru", "spamprotection_notifyStaff", " ")
	slib.setLang("gprotect", "ru", "spamprotection_notifyStaff_tooltip", "  ,   ")
	slib.setLang("gprotect", "ru", "spamprotection_protectProps", " ")
	slib.setLang("gprotect", "ru", "spamprotection_protectProps_tooltip", "   ")
	slib.setLang("gprotect", "ru", "spamprotection_protectEntities", " ")
	slib.setLang("gprotect", "ru", "spamprotection_protectEntities_tooltip", "   ")

	slib.setLang("gprotect", "ru", "spawnrestriction_enabled", "")
	slib.setLang("gprotect", "ru", "spawnrestriction_enabled_tooltip", "    ?")
	slib.setLang("gprotect", "ru", "spawnrestriction_propSpawnPermission", "   ")
	slib.setLang("gprotect", "ru", "spawnrestriction_propSpawnPermission_tooltip", "      (*  )")
	slib.setLang("gprotect", "ru", "spawnrestriction_SENTSpawnPermission", "   ")
	slib.setLang("gprotect", "ru", "spawnrestriction_SENTSpawnPermission_tooltip", "      (*  )")
	slib.setLang("gprotect", "ru", "spawnrestriction_SWEPSpawnPermission", "     Q-")
	slib.setLang("gprotect", "ru", "spawnrestriction_SWEPSpawnPermission_tooltip", "     Q-   (*  )")
	slib.setLang("gprotect", "ru", "spawnrestriction_vehicleSpawnPermission", "    ")
	slib.setLang("gprotect", "ru", "spawnrestriction_vehicleSpawnPermission_tooltip", "      Q-   (*  )")
	slib.setLang("gprotect", "ru", "spawnrestriction_NPCSpawnPermission", "   NPC")
	slib.setLang("gprotect", "ru", "spawnrestriction_NPCSpawnPermission_tooltip", "   NPC  Q-   (*  )")
	slib.setLang("gprotect", "ru", "spawnrestriction_ragdollSpawnPermission", "   Ragdoll'")
	slib.setLang("gprotect", "ru", "spawnrestriction_ragdollSpawnPermission_tooltip", "   Ragdoll'   (*  )")
	slib.setLang("gprotect", "ru", "spawnrestriction_effectSpawnPermission", "   ")
	slib.setLang("gprotect", "ru", "spawnrestriction_effectSpawnPermission_tooltip", "      (*  )")
	slib.setLang("gprotect", "ru", "spawnrestriction_blockedEntities", " ")
	slib.setLang("gprotect", "ru", "spawnrestriction_blockedEntities_tooltip", " ,   ")
	slib.setLang("gprotect", "ru", "spawnrestriction_blockedEntitiesIsBlacklist", "    ")
	slib.setLang("gprotect", "ru", "spawnrestriction_blockedEntitiesIsBlacklist_tooltip", "   ,       ,       ")
	slib.setLang("gprotect", "ru", "spawnrestriction_blockedModels", " ")
	slib.setLang("gprotect", "ru", "spawnrestriction_blockedModels_tooltip", "  ,   ")
	slib.setLang("gprotect", "ru", "spawnrestriction_blockedModelsisBlacklist", "     ")
	slib.setLang("gprotect", "ru", "spawnrestriction_blockedModelsisBlacklist_tooltip", "   ,        ,        ")
	slib.setLang("gprotect", "ru", "spawnrestriction_bypassGroups", " ")
	slib.setLang("gprotect", "ru", "spawnrestriction_bypassGroups_tooltip", " ,       (*  )")
	slib.setLang("gprotect", "ru", "spawnrestriction_maxModelSize", "  ")
	slib.setLang("gprotect", "ru", "spawnrestriction_maxModelSize_tooltip", "  0,         ")

	slib.setLang("gprotect", "ru", "toolgunsettings_enabled", "")
	slib.setLang("gprotect", "ru", "toolgunsettings_enabled_tooltip", "   ?")
	slib.setLang("gprotect", "ru", "toolgunsettings_targetWorld", ",     World ")
	slib.setLang("gprotect", "ru", "toolgunsettings_targetWorld_tooltip", ",     World    (*  )")
	slib.setLang("gprotect", "ru", "toolgunsettings_targetPlayerOwned", ",     ,  ")
	slib.setLang("gprotect", "ru", "toolgunsettings_targetPlayerOwned_tooltip", ",          (*  )")
	slib.setLang("gprotect", "ru", "toolgunsettings_restrictTools", "    ")
	slib.setLang("gprotect", "ru", "toolgunsettings_restrictTools_tooltip", "  ,   ")
	slib.setLang("gprotect", "ru", "toolgunsettings_groupToolRestrictions", "  ")
	slib.setLang("gprotect", "ru", "toolgunsettings_groupToolRestrictions_tooltip", "    ")
	slib.setLang("gprotect", "ru", "toolgunsettings_entityTargetability", ",    ")
	slib.setLang("gprotect", "ru", "toolgunsettings_entityTargetability_tooltip", " ,     , ,    ")
	slib.setLang("gprotect", "ru", "toolgunsettings_bypassTargetabilityTools", "  ")
	slib.setLang("gprotect", "ru", "toolgunsettings_bypassTargetabilityTools_tooltip", "       ")
    slib.setLang("gprotect", "ru", "toolgunsettings_bypassGroups", " ")
	slib.setLang("gprotect", "ru", "toolgunsettings_bypassGroups_tooltip", " ,       (*  )")
	slib.setLang("gprotect", "ru", "toolgunsettings_antiSpam", "")
	slib.setLang("gprotect", "ru", "toolgunsettings_antiSpam_tooltip", "      ")

	slib.setLang("gprotect", "ru", "physgunsettings_enabled", "")
	slib.setLang("gprotect", "ru", "physgunsettings_enabled_tooltip", "   ?")
	slib.setLang("gprotect", "ru", "physgunsettings_targetWorld", "   World ")
	slib.setLang("gprotect", "ru", "physgunsettings_targetWorld_tooltip", ",     World    (*  )")
	slib.setLang("gprotect", "ru", "physgunsettings_targetPlayerOwned", ",     ,  ")
	slib.setLang("gprotect", "ru", "physgunsettings_targetPlayerOwned_tooltip", ",          (*  )")
	slib.setLang("gprotect", "ru", "physgunsettings_DisableReloadUnfreeze", " ")
	slib.setLang("gprotect", "ru", "physgunsettings_DisableReloadUnfreeze_tooltip", "       ")
	slib.setLang("gprotect", "ru", "physgunsettings_PickupVehiclePermission", "    ")
	slib.setLang("gprotect", "ru", "physgunsettings_PickupVehiclePermission_tooltip", "      ")
	slib.setLang("gprotect", "ru", "physgunsettings_StopMotionOnDrop", "   ")
	slib.setLang("gprotect", "ru", "physgunsettings_StopMotionOnDrop_tooltip", " proppushing/propkilling")
	slib.setLang("gprotect", "ru", "physgunsettings_blockMultiplePhysgunning", " ")
	slib.setLang("gprotect", "ru", "physgunsettings_blockMultiplePhysgunning_tooltip", "      ,      ")
    slib.setLang("gprotect", "ru", "physgunsettings_maxDropObstructs", "  ")
	slib.setLang("gprotect", "ru", "physgunsettings_maxDropObstructs_tooltip", "  ,    ,  ")
	slib.setLang("gprotect", "ru", "physgunsettings_maxDropObstructsAction", "   ")
	slib.setLang("gprotect", "ru", "physgunsettings_maxDropObstructsAction_tooltip", "   (1 = , 2 = , 3 = )")
	slib.setLang("gprotect", "ru", "physgunsettings_blockedEntities", " ")
	slib.setLang("gprotect", "ru", "physgunsettings_blockedEntities_tooltip", ",       .    ")
	slib.setLang("gprotect", "ru", "physgunsettings_bypassGroups", " ")
	slib.setLang("gprotect", "ru", "physgunsettings_bypassGroups_tooltip", " ,       (*  )")

	slib.setLang("gprotect", "ru", "gravitygunsettings_enabled", "")
	slib.setLang("gprotect", "ru", "gravitygunsettings_enabled_tooltip", "   ?")
	slib.setLang("gprotect", "ru", "gravitygunsettings_targetWorld", "   World ")
	slib.setLang("gprotect", "ru", "gravitygunsettings_targetWorld_tooltip", ",     World    (*  )")
	slib.setLang("gprotect", "ru", "gravitygunsettings_targetPlayerOwned", ",     ,  ")
	slib.setLang("gprotect", "ru", "gravitygunsettings_targetPlayerOwned_tooltip", ",          (*  )")
	slib.setLang("gprotect", "ru", "gravitygunsettings_DisableGravityGunPunting", "  ")
	slib.setLang("gprotect", "ru", "gravitygunsettings_DisableGravityGunPunting_tooltip", "  ")
	slib.setLang("gprotect", "ru", "gravitygunsettings_blockedEntities", " ")
	slib.setLang("gprotect", "ru", "gravitygunsettings_blockedEntities_tooltip", ",       .    ")
	slib.setLang("gprotect", "ru", "gravitygunsettings_bypassGroups", " ")
	slib.setLang("gprotect", "ru", "gravitygunsettings_bypassGroups_tooltip", " ,       (*  )")

	slib.setLang("gprotect", "ru", "canpropertysettings_enabled", "")
	slib.setLang("gprotect", "ru", "canpropertysettings_enabled_tooltip", "   ?")
	slib.setLang("gprotect", "ru", "canpropertysettings_targetWorld", "   World ")
	slib.setLang("gprotect", "ru", "canpropertysettings_targetWorld_tooltip", ",     World    (*  )")
	slib.setLang("gprotect", "ru", "canpropertysettings_targetPlayerOwned", ",     ,  ")
	slib.setLang("gprotect", "ru", "canpropertysettings_targetPlayerOwned_tooltip", ",          (*  )")
	slib.setLang("gprotect", "ru", "canpropertysettings_blockedProperties", "  (properties)")
	slib.setLang("gprotect", "ru", "canpropertysettings_blockedProperties_tooltip", "  (properties),  ")
	slib.setLang("gprotect", "ru", "canpropertysettings_blockedPropertiesisBlacklist", "    ")
	slib.setLang("gprotect", "ru", "canpropertysettings_blockedPropertiesisBlacklist_tooltip", "   ,     ,       ")
	slib.setLang("gprotect", "ru", "canpropertysettings_blockedEntities", " ")
	slib.setLang("gprotect", "ru", "canpropertysettings_blockedEntities_tooltip", ",    .    ")
	slib.setLang("gprotect", "ru", "canpropertysettings_bypassGroups", " ")
	slib.setLang("gprotect", "ru", "canpropertysettings_bypassGroups_tooltip", " ,       (*  )")

	slib.setLang("gprotect", "ru", "advdupe2_enabled", "")
	slib.setLang("gprotect", "ru", "advdupe2_enabled_tooltip", " ")
	slib.setLang("gprotect", "ru", "advdupe2_notifyStaff", " ?")
	slib.setLang("gprotect", "ru", "advdupe2_notifyStaff_tooltip", "  ,   ")
	slib.setLang("gprotect", "ru", "advdupe2_PreventRopes", "  ")
	slib.setLang("gprotect", "ru", "advdupe2_PreventRopes_tooltip", "    (1 =  , 2 = ,  )")
	slib.setLang("gprotect", "ru", "advdupe2_PreventScaling", "  ")
	slib.setLang("gprotect", "ru", "advdupe2_PreventScaling_tooltip", "    . (1 =  , 2 = ,  )")
	slib.setLang("gprotect", "ru", "advdupe2_PreventNoGravity", "   ")
	slib.setLang("gprotect", "ru", "advdupe2_PreventNoGravity_tooltip", "    . (1 =  , 2 = ,  )")
	slib.setLang("gprotect", "ru", "advdupe2_PreventTrail", " ")
	slib.setLang("gprotect", "ru", "advdupe2_PreventTrail_tooltip", "    . (1 =  , 2 = ,  )")
    slib.setLang("gprotect", "ru", "advdupe2_PreventUnfreezeAll", "   ")
	slib.setLang("gprotect", "ru", "advdupe2_PreventUnfreezeAll_tooltip", "    . (1 =  , 2 = ,  )")
	slib.setLang("gprotect", "ru", "advdupe2_BlacklistedCollisionGroups", "  collision groups")
	slib.setLang("gprotect", "ru", "advdupe2_BlacklistedCollisionGroups_tooltip", "  ,    .     ENUM")
	slib.setLang("gprotect", "ru", "advdupe2_WhitelistedConstraints", "  ")
	slib.setLang("gprotect", "ru", "advdupe2_WhitelistedConstraints_tooltip", "  -  ")

	slib.setLang("gprotect", "ru", "miscs_enabled", "")
	slib.setLang("gprotect", "ru", "miscs_enabled_tooltip", " ")
	slib.setLang("gprotect", "ru", "miscs_ClearDecals", "  ")
	slib.setLang("gprotect", "ru", "miscs_ClearDecals_tooltip", "  .        ")
	slib.setLang("gprotect", "ru", "miscs_NoBlackoutGlitch", "  ")
	slib.setLang("gprotect", "ru", "miscs_NoBlackoutGlitch_tooltip", "   'pp/copy' (1 = , 2 = , 3 = )")
	slib.setLang("gprotect", "ru", "miscs_FadingDoorLag", "   fading door")
	slib.setLang("gprotect", "ru", "miscs_FadingDoorLag_tooltip", "     fading door")
	slib.setLang("gprotect", "ru", "miscs_DisableMotion", " ")
	slib.setLang("gprotect", "ru", "miscs_DisableMotion_tooltip", "       ")
	slib.setLang("gprotect", "ru", "miscs_freezeOnSpawn", "  ")
	slib.setLang("gprotect", "ru", "miscs_freezeOnSpawn_tooltip", "   ")
	slib.setLang("gprotect", "ru", "miscs_preventFadingDoorAbuse", "   fading door")
	slib.setLang("gprotect", "ru", "miscs_preventFadingDoorAbuse_tooltip", "    fading door")
	slib.setLang("gprotect", "ru", "miscs_preventSpawnNearbyPlayer", "    ")
	slib.setLang("gprotect", "ru", "miscs_preventSpawnNearbyPlayer_tooltip", " -      ,   ,      (0 ,  )")
    slib.setLang("gprotect", "ru", "miscs_DRPEntForceOwnership", "   DarkRP ")
    slib.setLang("gprotect", "ru", "miscs_DRPEntForceOwnership_tooltip", "   ,    F4")
	slib.setLang("gprotect", "ru", "miscs_DRPMaxObstructsOnPurchaseEnts", "   DRP   ")
	slib.setLang("gprotect", "ru", "miscs_DRPMaxObstructsOnPurchaseEnts_tooltip", "     DRP   ")
	slib.setLang("gprotect", "ru", "miscs_DRPObstructsFilter", "  DarkRP")
	slib.setLang("gprotect", "ru", "miscs_DRPObstructsFilter_tooltip", "  (1 =  DRP, 2 = )")
end

slib.setLang("gprotect", "ru", "insufficient-permission", " ")
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/client/cl_buddies.lua:
if gProtect.config.DisableBuddySystem then return end

gProtect = gProtect or {}
gProtect.BuddiesData = gProtect.BuddiesData or {}

if (file.Exists( "gp_buddies.txt", "DATA" )) then
	local data = file.Read( "gp_buddies.txt")
	data = util.JSONToTable(data)

	gProtect.BuddiesData = data or {}
end

local classtoInt = {
	["weapon_physcannon"] = 1,
	["weapon_physgun"] = 2,
	["gmod_tool"] = 3,
	["canProperty"] = 4,
	["canUse"] = 5
}

local permissions = {
	{title = slib.getLang("gprotect", gProtect.config.SelectedLanguage, "toolgun"), classname = "gmod_tool", int = 3},
	{title = slib.getLang("gprotect", gProtect.config.SelectedLanguage, "gravity-gun"), classname = "weapon_physcannon", int = 1},
	{title = slib.getLang("gprotect", gProtect.config.SelectedLanguage, "physgun"), classname = "weapon_physgun", int = 2},
	{title = slib.getLang("gprotect", gProtect.config.SelectedLanguage, "canproperty"), classname = "canProperty", int = 4},
	{title = slib.getLang("gprotect", gProtect.config.SelectedLanguage, "canuse"), classname = "canUse", int = 5}
}

local function handleBuddies(ply, weapon, int, forced)
	if !IsValid(ply) or !weapon or !int then return end

	local sid = ply:SteamID()
	local lsid = LocalPlayer():SteamID()

	gProtect.BuddiesData[lsid] = gProtect.BuddiesData[lsid] or {}
	gProtect.BuddiesData[lsid][weapon] = gProtect.BuddiesData[lsid][weapon] or {}

	local isBuddy = forced and forced or !gProtect.BuddiesData[lsid][weapon][sid]

	net.Start("gP:Buddies")
	net.WriteInt(ply:EntIndex(), 15)
	net.WriteUInt(int, 3)
	net.WriteBool(isBuddy)
	net.SendToServer()

	if !isBuddy then isBuddy = nil end

	gProtect.BuddiesData[lsid][weapon][sid] = isBuddy

	if(file.Exists( "gp_buddies.txt", "DATA" )) then
		local data = file.Read( "gp_buddies.txt")
		data = util.JSONToTable(data) or {}

		data[lsid] = data[lsid] or {}
		data[lsid][weapon] = data[lsid][weapon] or {}
		data[lsid][weapon][sid] = isBuddy
		
		file.Write("gp_buddies.txt", util.TableToJSON(data))
	else
		local data = {[lsid] = {[weapon] = {[sid] = isBuddy}}}
		file.Write("gp_buddies.txt", util.TableToJSON(data))
	end
end

local function openBuddies()
	local buddies = vgui.Create("SFrame")
    buddies:SetSize(slib.getScaledSize(400, "x"),slib.getScaledSize(370, "y"))
    :setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "buddies-title"))
    :Center()
    :addCloseButton()
    :MakePopup()

	local player_list = vgui.Create("SListPanel", buddies.frame)
    player_list:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "player-list"))
	:addSearchbar()
	:Dock(FILL)
	:DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))

    for k,v in pairs(player.GetAll()) do
        if v:IsBot() or v == LocalPlayer() then continue end
		local _, entry = player_list:addEntry(v)
		if v:GetFriendStatus() == "friend" then entry:SetZPos(-10) end
	end
	
	for k,v in ipairs(permissions) do
		local _, bttn = player_list:addButton(v.title, function() handleBuddies(player_list.selected, v.classname, v.int) end)
		bttn:setToggleable(true)

		bttn.toggleCheck = function()
			local lply = LocalPlayer()
			local ply = player_list.selected

			if !ply or !lply then return slib.getTheme("maincolor", 20) end

			local lsid = lply:SteamID()
			local sid = ply:SteamID()

			return (gProtect.BuddiesData[lsid] and gProtect.BuddiesData[lsid][v.classname] and gProtect.BuddiesData[lsid][v.classname][sid] and true or false)
		end
	end
end

hook.Add("Think", "gP:WaitOnLocalPlayer", function()
	if !IsValid(LocalPlayer()) then return end
	hook.Add("OnEntityCreated", "gP:HandleJoinedFriends", function(ent)
		if ent:IsPlayer() then
			local lply = LocalPlayer()
			
			if !IsValid(lply) then return end
	
			local lsid = lply:SteamID()
			local sid = ent:SteamID()
			if !gProtect.BuddiesData[lsid] then return end
			for k,v in pairs(gProtect.BuddiesData[lsid]) do
				if v[sid] then
					handleBuddies(ent, k, classtoInt[k], true)
				end
			end
		end
	end)
	
	for k,ply in ipairs(player.GetAll()) do
		local lsid = LocalPlayer():SteamID()
		local sid = ply:SteamID()
		if !gProtect.BuddiesData[lsid] then return end
		for k,v in pairs(gProtect.BuddiesData[lsid]) do
			if v[sid] then
				handleBuddies(ply, k, classtoInt[k], true)
			end
		end
	end

	hook.Remove("Think", "gP:WaitOnLocalPlayer")
end)

list.Set("DesktopWindows", "gp_buddies",{
	title = "gP: Buddies",
	icon = "gProtect/buddies.png",
	init = openBuddies
})

concommand.Add("buddies", openBuddies)
concommand.Add("gp_buddies", openBuddies)
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn_loader.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/autorun/sreward_loader.lua:
if slib then slib.loadFolder("s_reward/", true, {{"s_reward/", "sh_sreward_config.lua"}, {"s_reward/", "sv_sreward_config.lua"}, {"s_reward/core/", "sv_storage.lua"}}) end
hook.Add("slib:loadedUtils", "sR:Init_SReward", function() slib.loadFolder("s_reward/", true, {{"s_reward/", "sh_sreward_config.lua"}, {"s_reward/", "sv_sreward_config.lua"}, {"s_reward/core/", "sv_storage.lua"}}) end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/sh_sreward_config.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_elevel.lua:
sReward.RegisterReward("elevel_xp", function(ply, xp)
    if !isfunction(ply.addEXP) then return end
    ply:addEXP(xp)
end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_essentialpacks.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_misc.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_misc.lua:

sReward.RegisterReward("give_weapon", function(ply, classname)
    if !isfunction(ply.Give) then return end
    ply:Give(classname)
end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_pointshop.lua:
return gluapack()()
--PATH lua/streamradio_core/error.lua:
return gluapack()()
--PATH lua/streamradio_core/stream.lua:
return gluapack()()
--PATH lua/streamradio_core/stream.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Stream = StreamRadioLib.Stream or {}
local LIB = StreamRadioLib.Stream

local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url
local LIBError = StreamRadioLib.Error

local catchAndErrorNoHaltWithStack = LIBUtil.CatchAndErrorNoHaltWithStack

local function buildMode(bass3Mode, worldSound, noBlock)
	local mode = nil

	if bass3Mode then
		mode = BASS3.ENUM.MODE_NOPLAY

		if worldSound then
			mode = bit.bor(mode, BASS3.ENUM.MODE_3D)
		end

		if noBlock then
			mode = bit.bor(mode, BASS3.ENUM.MODE_NOBLOCK)
		end

		return mode
	end

	mode = "noplay "

	if worldSound then
		mode = mode .. "3d "
	end

	if noBlock then
		mode = mode .. "noblock "
	end

	mode = string.Trim(mode)

	return mode
end

function LIB.PlayOffline(url, bass3Mode, worldSound, noBlock, callback)
	local safeCallback = function(...)
		catchAndErrorNoHaltWithStack(callback, ...)
	end

	-- Avoid playing non existing files to avoid crashing
	if not file.Exists(url, "GAME") then
		safeCallback(nil, LIBError.STREAM_ERROR_FILEOPEN)
		return
	end

	local mode = buildMode(bass3Mode, worldSound, noBlock)

	url = LIBUrl.SanitizeOfflineUrl(url)

	if bass3Mode then
		local status = BASS3.PlayFile(url, mode, safeCallback)

		if not status then
			safeCallback(nil, LIBError.STREAM_ERROR_UNKNOWN)
		end

		return
	end

	sound.PlayFile(url, mode, safeCallback)
end

function LIB.PlayOnline(url, bass3Mode, worldSound, noBlock, callback)
	local safeCallback = function(...)
		catchAndErrorNoHaltWithStack(callback, ...)
	end

	url = LIBUrl.SanitizeOnlineUrl(url)

	local mode = buildMode(bass3Mode, worldSound, noBlock)

	if bass3Mode then
		local status = BASS3.PlayURL(url, mode, safeCallback)

		if not status then
			safeCallback(nil, LIBError.STREAM_ERROR_UNKNOWN)
		end

		return
	end

	sound.PlayURL(url, mode, safeCallback)
end

return true


--PATH lua/streamradio_core/timer.lua:
return gluapack()()
--PATH lua/streamradio_core/shoutcast.lua:
return gluapack()()
--PATH lua/streamradio_core/shoutcast.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Shoutcast = StreamRadioLib.Shoutcast or {}

local LIB = StreamRadioLib.Shoutcast
table.Empty(LIB)

local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url
local LIBHttp = StreamRadioLib.Http

local g_streamUrl = "https://yp.shoutcast.com/sbin/tunein-station.m3u"
local g_browseByGenreUrl = "https://directory.shoutcast.com/Home/BrowseByGenre"

local g_list_cache = LIBUtil.CreateCacheArray(2048)

local g_genres = {
	{
		title = "Alternative",
		subitems = {
			{
				title = "Adult Alternative"
			},
			{
				title = "Britpop"
			},
			{
				title = "Classic Alternative"
			},
			{
				title = "College"
			},
			{
				title = "Dancepunk"
			},
			{
				title = "Dream Pop"
			},
			{
				title = "Emo"
			},
			{
				title = "Goth"
			},
			{
				title = "Grunge"
			},
			{
				title = "Hardcore"
			},
			{
				title = "Indie Pop"
			},
			{
				title = "Indie Rock"
			},
			{
				title = "Industrial"
			},
			{
				title = "LoFi"
			},
			{
				title = "Modern Rock"
			},
			{
				title = "New Wave"
			},
			{
				title = "Noise Pop"
			},
			{
				title = "Post Punk"
			},
			{
				title = "Power Pop"
			},
			{
				title = "Punk"
			},
			{
				title = "Ska"
			},
			{
				title = "Xtreme"
			}
		}
	},
	{
		title = "Blues",
		subitems = {
			{
				title = "Acoustic Blues"
			},
			{
				title = "Chicago Blues"
			},
			{
				title = "Contemporary Blues"
			},
			{
				title = "Country Blues"
			},
			{
				title = "Delta Blues"
			},
			{
				title = "Electric Blues"
			},
			{
				title = "Cajun and Zydeco"
			}
		}
	},
	{
		title = "Classical",
		subitems = {
			{
				title = "Baroque"
			},
			{
				title = "Chamber"
			},
			{
				title = "Choral"
			},
			{
				title = "Classical Period"
			},
			{
				title = "Early Classical"
			},
			{
				title = "Impressionist"
			},
			{
				title = "Modern"
			},
			{
				title = "Opera"
			},
			{
				title = "Piano"
			},
			{
				title = "Romantic"
			},
			{
				title = "Symphony"
			}
		}
	},
	{
		title = "Country",
		subitems = {
			{
				title = "Alt Country"
			},
			{
				title = "Americana"
			},
			{
				title = "Bluegrass"
			},
			{
				title = "Classic Country"
			},
			{
				title = "Contemporary Bluegrass"
			},
			{
				title = "Contemporary Country"
			},
			{
				title = "Honky Tonk"
			},
			{
				title = "Hot Country Hits"
			},
			{
				title = "Western"
			}
		}
	},
	{
		title = "Easy Listening",
		subitems = {
			{
				title = "Exotica"
			},
			{
				title = "Light Rock"
			},
			{
				title = "Lounge"
			},
			{
				title = "Orchestral Pop"
			},
			{
				title = "Polka"
			},
			{
				title = "Space Age Pop"
			}
		}
	},
	{
		title = "Electronic",
		subitems = {
			{
				title = "Acid House"
			},
			{
				title = "Ambient"
			},
			{
				title = "Big Beat"
			},
			{
				title = "Breakbeat"
			},
			{
				title = "Dance"
			},
			{
				title = "Demo"
			},
			{
				title = "Disco"
			},
			{
				title = "Downtempo"
			},
			{
				title = "Drum and Bass"
			},
			{
				title = "Electro"
			},
			{
				title = "Garage"
			},
			{
				title = "Hard House"
			},
			{
				title = "House"
			},
			{
				title = "IDM"
			},
			{
				title = "Jungle"
			},
			{
				title = "Progressive"
			},
			{
				title = "Techno"
			},
			{
				title = "Trance"
			},
			{
				title = "Tribal"
			},
			{
				title = "Trip Hop"
			},
			{
				title = "Dubstep"
			}
		}
	},
	{
		title = "Folk",
		subitems = {
			{
				title = "Alternative Folk"
			},
			{
				title = "Contemporary Folk"
			},
			{
				title = "Folk Rock"
			},
			{
				title = "New Acoustic"
			},
			{
				title = "Traditional Folk"
			},
			{
				title = "World Folk"
			},
			{
				title = "Old Time"
			}
		}
	},
	{
		title = "Themes",
		subitems = {
			{
				title = "Adult"
			},
			{
				title = "Best Of"
			},
			{
				title = "Chill"
			},
			{
				title = "Eclectic"
			},
			{
				title = "Experimental"
			},
			{
				title = "Female"
			},
			{
				title = "Heartache"
			},
			{
				title = "Instrumental"
			},
			{
				title = "LGBT"
			},
			{
				title = "Love and Romance"
			},
			{
				title = "Party Mix"
			},
			{
				title = "Patriotic"
			},
			{
				title = "Rainy Day Mix"
			},
			{
				title = "Reality"
			},
			{
				title = "Sexy"
			},
			{
				title = "Shuffle"
			},
			{
				title = "Travel Mix"
			},
			{
				title = "Tribute"
			},
			{
				title = "Trippy"
			},
			{
				title = "Work Mix"
			}
		}
	},
	{
		title = "Rap",
		subitems = {
			{
				title = "Alternative Rap"
			},
			{
				title = "Dirty South"
			},
			{
				title = "East Coast Rap"
			},
			{
				title = "Freestyle"
			},
			{
				title = "Hip Hop"
			},
			{
				title = "Gangsta Rap"
			},
			{
				title = "Mixtapes"
			},
			{
				title = "Old School"
			},
			{
				title = "Turntablism"
			},
			{
				title = "Underground Hip Hop"
			},
			{
				title = "West Coast Rap"
			}
		}
	},
	{
		title = "Inspirational",
		subitems = {
			{
				title = "Christian"
			},
			{
				title = "Christian Metal"
			},
			{
				title = "Christian Rap"
			},
			{
				title = "Christian Rock"
			},
			{
				title = "Classic Christian"
			},
			{
				title = "Contemporary Gospel"
			},
			{
				title = "Gospel"
			},
			{
				title = "Praise and Worship"
			},
			{
				title = "Sermons and Services"
			},
			{
				title = "Southern Gospel"
			},
			{
				title = "Traditional Gospel"
			}
		}
	},
	{
		title = "International",
		subitems = {
			{
				title = "African"
			},
			{
				title = "Arabic"
			},
			{
				title = "Asian"
			},
			{
				title = "Bollywood"
			},
			{
				title = "Brazilian"
			},
			{
				title = "Caribbean"
			},
			{
				title = "Celtic"
			},
			{
				title = "Chinese"
			},
			{
				title = "European"
			},
			{
				title = "Filipino"
			},
			{
				title = "French"
			},
			{
				title = "Greek"
			},
			{
				title = "Hawaiian and Pacific"
			},
			{
				title = "Hindi"
			},
			{
				title = "Indian"
			},
			{
				title = "Japanese"
			},
			{
				title = "Hebrew"
			},
			{
				title = "Klezmer"
			},
			{
				title = "Korean"
			},
			{
				title = "Mediterranean"
			},
			{
				title = "Middle Eastern"
			},
			{
				title = "North American"
			},
			{
				title = "Russian"
			},
			{
				title = "Soca"
			},
			{
				title = "South American"
			},
			{
				title = "Tamil"
			},
			{
				title = "Worldbeat"
			},
			{
				title = "Zouk"
			},
			{
				title = "German"
			},
			{
				title = "Turkish"
			},
			{
				title = "Islamic"
			},
			{
				title = "Afrikaans"
			},
			{
				title = "Creole"
			}
		}
	},
	{
		title = "Jazz",
		subitems = {
			{
				title = "Acid Jazz"
			},
			{
				title = "Avant Garde"
			},
			{
				title = "Big Band"
			},
			{
				title = "Bop"
			},
			{
				title = "Classic Jazz"
			},
			{
				title = "Cool Jazz"
			},
			{
				title = "Fusion"
			},
			{
				title = "Hard Bop"
			},
			{
				title = "Latin Jazz"
			},
			{
				title = "Smooth Jazz"
			},
			{
				title = "Swing"
			},
			{
				title = "Vocal Jazz"
			},
			{
				title = "World Fusion"
			}
		}
	},
	{
		title = "Latin",
		subitems = {
			{
				title = "Bachata"
			},
			{
				title = "Banda"
			},
			{
				title = "Bossa Nova"
			},
			{
				title = "Cumbia"
			},
			{
				title = "Latin Dance"
			},
			{
				title = "Latin Pop"
			},
			{
				title = "Latin Rap and Hip Hop"
			},
			{
				title = "Latin Rock"
			},
			{
				title = "Mariachi"
			},
			{
				title = "Merengue"
			},
			{
				title = "Ranchera"
			},
			{
				title = "Reggaeton"
			},
			{
				title = "Regional Mexican"
			},
			{
				title = "Salsa"
			},
			{
				title = "Tango"
			},
			{
				title = "Tejano"
			},
			{
				title = "Tropicalia"
			},
			{
				title = "Flamenco"
			},
			{
				title = "Samba"
			}
		}
	},
	{
		title = "Metal",
		subitems = {
			{
				title = "Black Metal"
			},
			{
				title = "Classic Metal"
			},
			{
				title = "Extreme Metal"
			},
			{
				title = "Grindcore"
			},
			{
				title = "Hair Metal"
			},
			{
				title = "Heavy Metal"
			},
			{
				title = "Metalcore"
			},
			{
				title = "Power Metal"
			},
			{
				title = "Progressive Metal"
			},
			{
				title = "Rap Metal"
			},
			{
				title = "Death Metal"
			},
			{
				title = "Thrash Metal"
			}
		}
	},
	{
		title = "New Age",
		subitems = {
			{
				title = "Environmental"
			},
			{
				title = "Ethnic Fusion"
			},
			{
				title = "Healing"
			},
			{
				title = "Meditation"
			},
			{
				title = "Spiritual"
			}
		}
	},
	{
		title = "Decades",
		subitems = {
			{
				title = "30s"
			},
			{
				title = "40s"
			},
			{
				title = "50s"
			},
			{
				title = "60s"
			},
			{
				title = "70s"
			},
			{
				title = "80s"
			},
			{
				title = "90s"
			},
			{
				title = "00s"
			}
		}
	},
	{
		title = "Pop",
		subitems = {
			{
				title = "Adult Contemporary"
			},
			{
				title = "Barbershop"
			},
			{
				title = "Bubblegum Pop"
			},
			{
				title = "Dance Pop"
			},
			{
				title = "Idols"
			},
			{
				title = "Oldies"
			},
			{
				title = "JPOP"
			},
			{
				title = "Soft Rock"
			},
			{
				title = "Teen Pop"
			},
			{
				title = "Top 40"
			},
			{
				title = "World Pop"
			},
			{
				title = "KPOP"
			}
		}
	},
	{
		title = "R&B and Urban",
		subitems = {
			{
				title = "Classic R&B"
			},
			{
				title = "Contemporary R&B"
			},
			{
				title = "Doo Wop"
			},
			{
				title = "Funk"
			},
			{
				title = "Motown"
			},
			{
				title = "Neo Soul"
			},
			{
				title = "Quiet Storm"
			},
			{
				title = "Soul"
			},
			{
				title = "Urban Contemporary"
			}
		}
	},
	{
		title = "Reggae",
		subitems = {
			{
				title = "Contemporary Reggae"
			},
			{
				title = "Dancehall"
			},
			{
				title = "Dub"
			},
			{
				title = "Pop Reggae"
			},
			{
				title = "Ragga"
			},
			{
				title = "Rock Steady"
			},
			{
				title = "Reggae Roots"
			}
		}
	},
	{
		title = "Rock",
		subitems = {
			{
				title = "Adult Album Alternative"
			},
			{
				title = "British Invasion"
			},
			{
				title = "Classic Rock"
			},
			{
				title = "Garage Rock"
			},
			{
				title = "Glam"
			},
			{
				title = "Hard Rock"
			},
			{
				title = "Jam Bands"
			},
			{
				title = "Piano Rock"
			},
			{
				title = "Prog Rock"
			},
			{
				title = "Psychedelic"
			},
			{
				title = "Rock & Roll"
			},
			{
				title = "Rockabilly"
			},
			{
				title = "Singer and Songwriter"
			},
			{
				title = "Surf"
			},
			{
				title = "JROCK"
			},
			{
				title = "Celtic Rock"
			}
		}
	},
	{
		title = "Seasonal and Holiday",
		subitems = {
			{
				title = "Anniversary"
			},
			{
				title = "Birthday"
			},
			{
				title = "Christmas"
			},
			{
				title = "Halloween"
			},
			{
				title = "Hanukkah"
			},
			{
				title = "Honeymoon"
			},
			{
				title = "Kwanzaa"
			},
			{
				title = "Valentine"
			},
			{
				title = "Wedding"
			},
			{
				title = "Winter"
			}
		}
	},
	{
		title = "Soundtracks",
		subitems = {
			{
				title = "Anime"
			},
			{
				title = "Kids"
			},
			{
				title = "Original Score"
			},
			{
				title = "Showtunes"
			},
			{
				title = "Video Game Music"
			}
		}
	},
	{
		title = "Talk",
		subitems = {
			{
				title = "Comedy"
			},
			{
				title = "Community"
			},
			{
				title = "Educational"
			},
			{
				title = "Government"
			},
			{
				title = "News"
			},
			{
				title = "Old Time Radio"
			},
			{
				title = "Other Talk"
			},
			{
				title = "Political"
			},
			{
				title = "Scanner"
			},
			{
				title = "Spoken Word"
			},
			{
				title = "Sports"
			},
			{
				title = "Technology"
			},
			{
				title = "BlogTalk"
			}
		}
	},
	{
		title = "Misc",
		subitems = {}
	},
	{
		title = "Public Radio",
		subitems = {
			{
				title = "News"
			},
			{
				title = "Talk"
			},
			{
				title = "College"
			},
			{
				title = "Sports"
			},
			{
				title = "Weather"
			}
		}
	}
}

local function mapGenres(genres)
	local recursiveMapper = nil

	recursiveMapper = function(thisTab, thisKey, thisTitle)
		if not thisTab then
			return nil
		end

		local subItems = thisTab.subitems or {}

		local map = {}
		map.title = thisTitle
		map.key = thisKey

		for _, v in ipairs(subItems) do
			if not v then
				continue
			end

			local title = string.Trim(v.title or "")
			if title == "" then
				continue
			end

			local key = string.lower(title)
			if map.children and map.children[key] then
				continue
			end

			local subItem = recursiveMapper(v, key, title)
			if not subItem then
				continue
			end

			if not map.children then
				map.children = {}
			end

			if not map.childrenTitles then
				map.childrenTitles = {}
			end

			map.children[key] = subItem
			table.insert(map.childrenTitles, title)
		end

		return map
	end

	local map = recursiveMapper({subitems = genres})
	map.isRoot = true

	return map
end

local g_genres_map = mapGenres(g_genres)


function LIB.GetHierarchy(hierarchy)
	hierarchy = StreamRadioLib.GetHierarchy(hierarchy)
	local newHierarchy = {}

	for i, v in ipairs(hierarchy or {}) do
		v = tostring(v or "")
		v = string.Trim(v)
		v = string.lower(v)

		if v == "" then
			continue
		end

		table.insert(newHierarchy, v)
	end

	return newHierarchy
end

function LIB.GetHierarchyString(hierarchy)
	hierarchy = LIB.GetHierarchy(hierarchy)
	hierarchy = table.concat(hierarchy, "/")

	return hierarchy
end

function LIB.GetGenre(hierarchy)
	hierarchy = LIB.GetHierarchy(hierarchy)

	local curMap = g_genres_map

	for i, v in ipairs(hierarchy) do
		if not curMap then
			return nil
		end

		local children = curMap.children
		if not children then
			return nil
		end

		local child = children[v]
		if not child then
			return nil
		end

		curMap = child
	end

	if not curMap then
		return nil
	end

	return curMap
end

function LIB.GenreExists(hierarchy)
	local genres = LIB.GetGenre(hierarchy)
	if not genres then
		return false
	end

	return true
end

local g_format_blacklist = {
	-- ["audio/mpeg"] = true,
}

function LIB.IsValidFormat(format)
	format = tostring(format or "")
	format = string.Trim(format)
	format = string.lower(format)

	return not g_format_blacklist[format]
end

local lower = string.lower

local function sorter(a, b)
	local a_name = lower(a.name)
	local b_name = lower(b.name)

	return a_name < b_name
end

function LIB.GetListOfGenre(hierarchy, callback)
	hierarchy = LIB.GetHierarchy(hierarchy)
	local hierarchyString = LIB.GetHierarchyString(hierarchy)

	local genre = LIB.GetGenre(hierarchy)

	if not genre then
		callback(false)
		return
	end

	local cache = g_list_cache:Get(hierarchyString)
	if cache then
		callback(true, cache)
		return
	end

	g_list_cache:Remove(hierarchyString)

	local searchGenre = genre.title or ""
	if searchGenre == "" then
		callback(false)
		return
	end

	local resultCallback = function(success, data)
		if not success then
			callback(false)
			return
		end

		local body = string.Trim(data.body or "")
		if body == "" then
			callback(false)
			return
		end

		local listItems = StreamRadioLib.JSON.Decode(body)
		if not listItems then
			callback(false)
			return
		end

		local results = {}

		for i, v in ipairs(listItems) do
			local id = tostring(v.ID or "")
			local name = string.Trim(v.Name or "")
			local genre = string.Trim(v.Genre or "")
			local format = string.Trim(v.Format or "")

			if id == "" then
				continue
			end

			if name == "" then
				continue
			end

			if not LIB.IsValidFormat(format) then
				continue
			end

			local streamUrl = LIB.GetStreamUrlById(id)
			if not streamUrl then
				continue
			end

			local result = {}

			result.id = id
			result.name = name
			result.genre = genre
			result.format = format
			result.streamUrl = streamUrl

			table.insert(results, result)
		end

		table.sort(results, sorter)

		g_list_cache:Set(hierarchyString, results)
		callback(true, results)
	end

	LIBHttp.Request(g_browseByGenreUrl, resultCallback, {
		genrename = searchGenre
	}, "POST")
end

function LIB.GetStreamUrlById(id)
	id = tostring(id or "")

	if id == "" then
		return nil
	end

	local url = LIBUrl.URIAddParameter(g_streamUrl, {
		id = id,
	})

	return url
end

function LIB.IsShoutcastUrl(url)
	if string.StartsWith(url, g_streamUrl) then
		return true
	end

	local interface = StreamRadioLib.Interface.GetInterface("SHOUTcast")

	if interface and interface:CheckURL(url) then
		return true
	end

	return nil
end

return true


--PATH lua/streamradio_core/models/cs_office_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- CS:S Office Radio
RADIOMDL.model = "models/props/cs_office/radio.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, -3.75, 3.5)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(2.40, -6.90, 6.80) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(2.40,  6.90, 0.50) -- Bottom Right

RADIOMDL.DisplayWidth = 768
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {21,	1000},
	Default	= {20,	700},
	Tooltip	= {18,	800},
	Big		= {22,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 16)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/default.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Default, Failback, No Display
RADIOMDL.model = "default"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false
RADIOMDL.HiddenInTool = true

return true


--PATH lua/streamradio_core/models/fallout3_jukebox.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Fallout 3 Jukebox
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=529954000
RADIOMDL.model = "models/fallout3/jukebox.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(5, 18.25, -7.75)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 73.5)

                              --      F,     R,     U
RADIOMDL.DisplayOffset    = Vector(8.85,  9.45, 11.70) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(8.85, 26.75, 17.10) -- Bottom Right

RADIOMDL.DisplayWidth = 1024
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {25,	1000},
	Default	= {23,	700},
	Tooltip	= {23,	1000},
	Big		= {26,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 3, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 60)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 50)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 7

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

RADIOMDL.Sounds = {
	Noise = "",
}

return true


--PATH lua/streamradio_core/models/hl2_crtscreen_big.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- HL2 Big CRT Screen
RADIOMDL.model = "models/props_lab/monitor01a.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, 0, 0)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 85.5)

                              --       F,     R,     U
RADIOMDL.DisplayOffset    = Vector(11.75, -9.55, 11.65) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(11.75,  9.55, -4.05) -- Bottom Right

RADIOMDL.DisplayWidth = 1400
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {45,	1000},
	Small	= {36,	700},
	Default	= {42,	700},
	Tooltip	= {42,	800},
	Big		= {50,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Small)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 80)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 1, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 60)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 60)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 100)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 60)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 60)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 90)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 80)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 32)

	local shadow = 10
	local padding = 10
	local margin = 10

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/hl2_speaker.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- HL2 Industrial Speaker
RADIOMDL.model = "models/props_wasteland/speakercluster01a.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( -90, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false
RADIOMDL.SpawnAtOrigin = false

return true


--PATH lua/streamradio_core/models/kresopolski_radio.lua:
return gluapack()()
--PATH lua/streamradio_core/models/minecraft_jukebox.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Minecraft Jukebox
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=116592647
RADIOMDL.model = "models/mcmodelpack/blocks/jukebox.mdl"

RADIOMDL.SpawnAng = Angle(0, 90, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, 0, 18)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 0, 90)

                              --        F,      R,     U
RADIOMDL.DisplayOffset    = Vector(-15.50, -18.50, 33.75) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(-18.50, 12.45, 2.75) -- Bottom Right

RADIOMDL.DisplayWidth = 700
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)


local fontoptions = {
	antialias = false,
}

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname, Options
	Header	= {22,	1000, "Terminal", fontoptions},
	Small	= {18,	700,  "Terminal", fontoptions},
	Default	= {20,	700,  "Terminal", fontoptions},
	Tooltip	= {20,	800,  "Terminal", fontoptions},
	Big		= {25,	700,  "Terminal", fontoptions},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Small)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 1, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 10)

	local shadow = 0
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/nm_screen.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- NM Screen
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=605223544
RADIOMDL.model = "models/nickmaps/monitors/nm_monitor_ultraslim.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, 0, 0)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)


RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,      R,      U
RADIOMDL.DisplayOffset    = Vector(1.25, -18.85,  11.10) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(1.25,  18.85, -11.10) -- Bottom Right

RADIOMDL.DisplayWidth = 1536
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {50,	1000},
	Default	= {44,	700},
	Tooltip	= {44,	1000},
	Big		= {60,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 8})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 8})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 100)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 80)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 10
	local padding = 10
	local margin = 10

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/portal_gladosball.lua:
return gluapack()()
--PATH lua/streamradio_core/models/sw_ghettoblaster.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/progressbar.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/radio/list_playlistview.lua:
return gluapack()()
--PATH lua/streamradio_core/cfchttp.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_presets.lua:
local StreamRadioLib = StreamRadioLib

local LIBPrint = StreamRadioLib.Print
local LIBUtil = StreamRadioLib.Util

local g_mainPath = LIBUtil.GetMainDirectory("presets_test")
local g_radioColorToolName = "streamradio_gui_color_global"

-- Generated stock presets via concommand "debug_streamradio_convertpresets"
local g_settings = {
	[g_radioColorToolName] = {
		["Cold"] = {
			["streamradio_gui_color_global_border_color_border_a"] = "255",
			["streamradio_gui_color_global_border_color_border_b"] = "0",
			["streamradio_gui_color_global_border_color_border_g"] = "0",
			["streamradio_gui_color_global_border_color_border_r"] = "0",
			["streamradio_gui_color_global_button_color_a"] = "255",
			["streamradio_gui_color_global_button_color_b"] = "173",
			["streamradio_gui_color_global_button_color_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_disabled_b"] = "64",
			["streamradio_gui_color_global_button_color_disabled_g"] = "64",
			["streamradio_gui_color_global_button_color_disabled_r"] = "64",
			["streamradio_gui_color_global_button_color_foreground_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_disabled_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_disabled_r"] = "0",
			["streamradio_gui_color_global_button_color_foreground_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_r"] = "0",
			["streamradio_gui_color_global_button_color_foreground_r"] = "0",
			["streamradio_gui_color_global_button_color_g"] = "173",
			["streamradio_gui_color_global_button_color_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_hover_b"] = "128",
			["streamradio_gui_color_global_button_color_hover_g"] = "128",
			["streamradio_gui_color_global_button_color_hover_r"] = "128",
			["streamradio_gui_color_global_button_color_icon_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_r"] = "255",
			["streamradio_gui_color_global_button_color_r"] = "0",
			["streamradio_gui_color_global_button_color_shadow_a"] = "255",
			["streamradio_gui_color_global_button_color_shadow_b"] = "40",
			["streamradio_gui_color_global_button_color_shadow_g"] = "40",
			["streamradio_gui_color_global_button_color_shadow_r"] = "40",
			["streamradio_gui_color_global_cursor_color_cursor_a"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_b"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_g"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_r"] = "255",
			["streamradio_gui_color_global_error_color_a"] = "255",
			["streamradio_gui_color_global_error_color_b"] = "113",
			["streamradio_gui_color_global_error_color_foreground_a"] = "255",
			["streamradio_gui_color_global_error_color_foreground_b"] = "255",
			["streamradio_gui_color_global_error_color_foreground_g"] = "255",
			["streamradio_gui_color_global_error_color_foreground_r"] = "255",
			["streamradio_gui_color_global_error_color_g"] = "105",
			["streamradio_gui_color_global_error_color_r"] = "90",
			["streamradio_gui_color_global_error_color_shadow_a"] = "255",
			["streamradio_gui_color_global_error_color_shadow_b"] = "40",
			["streamradio_gui_color_global_error_color_shadow_g"] = "40",
			["streamradio_gui_color_global_error_color_shadow_r"] = "40",
			["streamradio_gui_color_global_header_color_a"] = "255",
			["streamradio_gui_color_global_header_color_b"] = "88",
			["streamradio_gui_color_global_header_color_foreground_a"] = "255",
			["streamradio_gui_color_global_header_color_foreground_b"] = "255",
			["streamradio_gui_color_global_header_color_foreground_g"] = "255",
			["streamradio_gui_color_global_header_color_foreground_r"] = "255",
			["streamradio_gui_color_global_header_color_g"] = "82",
			["streamradio_gui_color_global_header_color_r"] = "68",
			["streamradio_gui_color_global_header_color_shadow_a"] = "255",
			["streamradio_gui_color_global_header_color_shadow_b"] = "40",
			["streamradio_gui_color_global_header_color_shadow_g"] = "40",
			["streamradio_gui_color_global_header_color_shadow_r"] = "40",
			["streamradio_gui_color_global_main_color_a"] = "255",
			["streamradio_gui_color_global_main_color_b"] = "68",
			["streamradio_gui_color_global_main_color_g"] = "0",
			["streamradio_gui_color_global_main_color_r"] = "15",
			["streamradio_gui_color_global_spectrum_color_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_b"] = "52",
			["streamradio_gui_color_global_spectrum_color_foreground_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_foreground_b"] = "182",
			["streamradio_gui_color_global_spectrum_color_foreground_g"] = "170",
			["streamradio_gui_color_global_spectrum_color_foreground_r"] = "110",
			["streamradio_gui_color_global_spectrum_color_g"] = "50",
			["streamradio_gui_color_global_spectrum_color_icon_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_b"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_g"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_r"] = "255",
			["streamradio_gui_color_global_spectrum_color_r"] = "46",
			["streamradio_gui_color_global_spectrum_color_shadow_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_shadow_b"] = "40",
			["streamradio_gui_color_global_spectrum_color_shadow_g"] = "40",
			["streamradio_gui_color_global_spectrum_color_shadow_r"] = "40",
		},
		["Gray"] = {
			["streamradio_gui_color_global_border_color_border_a"] = "255",
			["streamradio_gui_color_global_border_color_border_b"] = "2",
			["streamradio_gui_color_global_border_color_border_g"] = "2",
			["streamradio_gui_color_global_border_color_border_r"] = "2",
			["streamradio_gui_color_global_button_color_a"] = "255",
			["streamradio_gui_color_global_button_color_b"] = "173",
			["streamradio_gui_color_global_button_color_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_disabled_b"] = "52",
			["streamradio_gui_color_global_button_color_disabled_g"] = "52",
			["streamradio_gui_color_global_button_color_disabled_r"] = "52",
			["streamradio_gui_color_global_button_color_foreground_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_foreground_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_foreground_r"] = "0",
			["streamradio_gui_color_global_button_color_g"] = "173",
			["streamradio_gui_color_global_button_color_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_hover_b"] = "79",
			["streamradio_gui_color_global_button_color_hover_g"] = "79",
			["streamradio_gui_color_global_button_color_hover_r"] = "79",
			["streamradio_gui_color_global_button_color_icon_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_r"] = "255",
			["streamradio_gui_color_global_button_color_r"] = "173",
			["streamradio_gui_color_global_button_color_shadow_a"] = "255",
			["streamradio_gui_color_global_button_color_shadow_b"] = "40",
			["streamradio_gui_color_global_button_color_shadow_g"] = "40",
			["streamradio_gui_color_global_button_color_shadow_r"] = "40",
			["streamradio_gui_color_global_cursor_color_cursor_a"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_b"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_g"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_r"] = "255",
			["streamradio_gui_color_global_error_color_a"] = "255",
			["streamradio_gui_color_global_error_color_b"] = "200",
			["streamradio_gui_color_global_error_color_foreground_a"] = "255",
			["streamradio_gui_color_global_error_color_foreground_b"] = "0",
			["streamradio_gui_color_global_error_color_foreground_g"] = "0",
			["streamradio_gui_color_global_error_color_foreground_r"] = "0",
			["streamradio_gui_color_global_error_color_g"] = "200",
			["streamradio_gui_color_global_error_color_r"] = "200",
			["streamradio_gui_color_global_error_color_shadow_a"] = "255",
			["streamradio_gui_color_global_error_color_shadow_b"] = "40",
			["streamradio_gui_color_global_error_color_shadow_g"] = "40",
			["streamradio_gui_color_global_error_color_shadow_r"] = "40",
			["streamradio_gui_color_global_header_color_a"] = "255",
			["streamradio_gui_color_global_header_color_b"] = "107",
			["streamradio_gui_color_global_header_color_foreground_a"] = "255",
			["streamradio_gui_color_global_header_color_foreground_b"] = "0",
			["streamradio_gui_color_global_header_color_foreground_g"] = "0",
			["streamradio_gui_color_global_header_color_foreground_r"] = "0",
			["streamradio_gui_color_global_header_color_g"] = "107",
			["streamradio_gui_color_global_header_color_r"] = "109",
			["streamradio_gui_color_global_header_color_shadow_a"] = "255",
			["streamradio_gui_color_global_header_color_shadow_b"] = "40",
			["streamradio_gui_color_global_header_color_shadow_g"] = "40",
			["streamradio_gui_color_global_header_color_shadow_r"] = "40",
			["streamradio_gui_color_global_main_color_a"] = "255",
			["streamradio_gui_color_global_main_color_b"] = "0",
			["streamradio_gui_color_global_main_color_g"] = "0",
			["streamradio_gui_color_global_main_color_r"] = "0",
			["streamradio_gui_color_global_spectrum_color_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_b"] = "59",
			["streamradio_gui_color_global_spectrum_color_foreground_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_foreground_b"] = "194",
			["streamradio_gui_color_global_spectrum_color_foreground_g"] = "194",
			["streamradio_gui_color_global_spectrum_color_foreground_r"] = "195",
			["streamradio_gui_color_global_spectrum_color_g"] = "59",
			["streamradio_gui_color_global_spectrum_color_icon_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_b"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_g"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_r"] = "255",
			["streamradio_gui_color_global_spectrum_color_r"] = "59",
			["streamradio_gui_color_global_spectrum_color_shadow_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_shadow_b"] = "40",
			["streamradio_gui_color_global_spectrum_color_shadow_g"] = "40",
			["streamradio_gui_color_global_spectrum_color_shadow_r"] = "40",
		},
		["Jamaica"] = {
			["streamradio_gui_color_global_border_color_border_a"] = "255",
			["streamradio_gui_color_global_border_color_border_b"] = "0",
			["streamradio_gui_color_global_border_color_border_g"] = "0",
			["streamradio_gui_color_global_border_color_border_r"] = "0",
			["streamradio_gui_color_global_button_color_a"] = "255",
			["streamradio_gui_color_global_button_color_b"] = "0",
			["streamradio_gui_color_global_button_color_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_disabled_b"] = "0",
			["streamradio_gui_color_global_button_color_disabled_g"] = "0",
			["streamradio_gui_color_global_button_color_disabled_r"] = "43",
			["streamradio_gui_color_global_button_color_foreground_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_b"] = "161",
			["streamradio_gui_color_global_button_color_foreground_disabled_g"] = "161",
			["streamradio_gui_color_global_button_color_foreground_disabled_r"] = "161",
			["streamradio_gui_color_global_button_color_foreground_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_r"] = "0",
			["streamradio_gui_color_global_button_color_foreground_r"] = "0",
			["streamradio_gui_color_global_button_color_g"] = "86",
			["streamradio_gui_color_global_button_color_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_hover_b"] = "91",
			["streamradio_gui_color_global_button_color_hover_g"] = "91",
			["streamradio_gui_color_global_button_color_hover_r"] = "91",
			["streamradio_gui_color_global_button_color_icon_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_r"] = "255",
			["streamradio_gui_color_global_button_color_r"] = "0",
			["streamradio_gui_color_global_button_color_shadow_a"] = "255",
			["streamradio_gui_color_global_button_color_shadow_b"] = "0",
			["streamradio_gui_color_global_button_color_shadow_g"] = "0",
			["streamradio_gui_color_global_button_color_shadow_r"] = "0",
			["streamradio_gui_color_global_cursor_color_cursor_a"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_b"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_g"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_r"] = "255",
			["streamradio_gui_color_global_error_color_a"] = "255",
			["streamradio_gui_color_global_error_color_b"] = "64",
			["streamradio_gui_color_global_error_color_foreground_a"] = "255",
			["streamradio_gui_color_global_error_color_foreground_b"] = "200",
			["streamradio_gui_color_global_error_color_foreground_g"] = "200",
			["streamradio_gui_color_global_error_color_foreground_r"] = "200",
			["streamradio_gui_color_global_error_color_g"] = "64",
			["streamradio_gui_color_global_error_color_r"] = "64",
			["streamradio_gui_color_global_error_color_shadow_a"] = "255",
			["streamradio_gui_color_global_error_color_shadow_b"] = "0",
			["streamradio_gui_color_global_error_color_shadow_g"] = "0",
			["streamradio_gui_color_global_error_color_shadow_r"] = "0",
			["streamradio_gui_color_global_header_color_a"] = "255",
			["streamradio_gui_color_global_header_color_b"] = "0",
			["streamradio_gui_color_global_header_color_foreground_a"] = "255",
			["streamradio_gui_color_global_header_color_foreground_b"] = "0",
			["streamradio_gui_color_global_header_color_foreground_g"] = "0",
			["streamradio_gui_color_global_header_color_foreground_r"] = "0",
			["streamradio_gui_color_global_header_color_g"] = "86",
			["streamradio_gui_color_global_header_color_r"] = "86",
			["streamradio_gui_color_global_header_color_shadow_a"] = "255",
			["streamradio_gui_color_global_header_color_shadow_b"] = "0",
			["streamradio_gui_color_global_header_color_shadow_g"] = "0",
			["streamradio_gui_color_global_header_color_shadow_r"] = "0",
			["streamradio_gui_color_global_main_color_a"] = "255",
			["streamradio_gui_color_global_main_color_b"] = "40",
			["streamradio_gui_color_global_main_color_g"] = "40",
			["streamradio_gui_color_global_main_color_r"] = "40",
			["streamradio_gui_color_global_spectrum_color_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_b"] = "0",
			["streamradio_gui_color_global_spectrum_color_foreground_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_foreground_b"] = "0",
			["streamradio_gui_color_global_spectrum_color_foreground_g"] = "195",
			["streamradio_gui_color_global_spectrum_color_foreground_r"] = "195",
			["streamradio_gui_color_global_spectrum_color_g"] = "0",
			["streamradio_gui_color_global_spectrum_color_icon_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_b"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_g"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_r"] = "255",
			["streamradio_gui_color_global_spectrum_color_r"] = "77",
			["streamradio_gui_color_global_spectrum_color_shadow_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_shadow_b"] = "0",
			["streamradio_gui_color_global_spectrum_color_shadow_g"] = "0",
			["streamradio_gui_color_global_spectrum_color_shadow_r"] = "0",
		},
		["Lava"] = {
			["streamradio_gui_color_global_border_color_border_a"] = "255",
			["streamradio_gui_color_global_border_color_border_b"] = "0",
			["streamradio_gui_color_global_border_color_border_g"] = "0",
			["streamradio_gui_color_global_border_color_border_r"] = "104",
			["streamradio_gui_color_global_button_color_a"] = "255",
			["streamradio_gui_color_global_button_color_b"] = "84",
			["streamradio_gui_color_global_button_color_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_disabled_b"] = "64",
			["streamradio_gui_color_global_button_color_disabled_g"] = "64",
			["streamradio_gui_color_global_button_color_disabled_r"] = "64",
			["streamradio_gui_color_global_button_color_foreground_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_b"] = "130",
			["streamradio_gui_color_global_button_color_foreground_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_b"] = "200",
			["streamradio_gui_color_global_button_color_foreground_disabled_g"] = "200",
			["streamradio_gui_color_global_button_color_foreground_disabled_r"] = "200",
			["streamradio_gui_color_global_button_color_foreground_g"] = "130",
			["streamradio_gui_color_global_button_color_foreground_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_foreground_r"] = "255",
			["streamradio_gui_color_global_button_color_g"] = "84",
			["streamradio_gui_color_global_button_color_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_hover_b"] = "0",
			["streamradio_gui_color_global_button_color_hover_g"] = "0",
			["streamradio_gui_color_global_button_color_hover_r"] = "38",
			["streamradio_gui_color_global_button_color_icon_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_r"] = "255",
			["streamradio_gui_color_global_button_color_r"] = "84",
			["streamradio_gui_color_global_button_color_shadow_a"] = "255",
			["streamradio_gui_color_global_button_color_shadow_b"] = "27",
			["streamradio_gui_color_global_button_color_shadow_g"] = "27",
			["streamradio_gui_color_global_button_color_shadow_r"] = "27",
			["streamradio_gui_color_global_cursor_color_cursor_a"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_b"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_g"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_r"] = "255",
			["streamradio_gui_color_global_error_color_a"] = "255",
			["streamradio_gui_color_global_error_color_b"] = "16",
			["streamradio_gui_color_global_error_color_foreground_a"] = "255",
			["streamradio_gui_color_global_error_color_foreground_b"] = "64",
			["streamradio_gui_color_global_error_color_foreground_g"] = "64",
			["streamradio_gui_color_global_error_color_foreground_r"] = "255",
			["streamradio_gui_color_global_error_color_g"] = "16",
			["streamradio_gui_color_global_error_color_r"] = "16",
			["streamradio_gui_color_global_error_color_shadow_a"] = "255",
			["streamradio_gui_color_global_error_color_shadow_b"] = "27",
			["streamradio_gui_color_global_error_color_shadow_g"] = "27",
			["streamradio_gui_color_global_error_color_shadow_r"] = "27",
			["streamradio_gui_color_global_header_color_a"] = "255",
			["streamradio_gui_color_global_header_color_b"] = "36",
			["streamradio_gui_color_global_header_color_foreground_a"] = "255",
			["streamradio_gui_color_global_header_color_foreground_b"] = "0",
			["streamradio_gui_color_global_header_color_foreground_g"] = "0",
			["streamradio_gui_color_global_header_color_foreground_r"] = "255",
			["streamradio_gui_color_global_header_color_g"] = "36",
			["streamradio_gui_color_global_header_color_r"] = "36",
			["streamradio_gui_color_global_header_color_shadow_a"] = "255",
			["streamradio_gui_color_global_header_color_shadow_b"] = "27",
			["streamradio_gui_color_global_header_color_shadow_g"] = "27",
			["streamradio_gui_color_global_header_color_shadow_r"] = "27",
			["streamradio_gui_color_global_main_color_a"] = "255",
			["streamradio_gui_color_global_main_color_b"] = "45",
			["streamradio_gui_color_global_main_color_g"] = "45",
			["streamradio_gui_color_global_main_color_r"] = "45",
			["streamradio_gui_color_global_spectrum_color_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_b"] = "0",
			["streamradio_gui_color_global_spectrum_color_foreground_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_foreground_b"] = "0",
			["streamradio_gui_color_global_spectrum_color_foreground_g"] = "0",
			["streamradio_gui_color_global_spectrum_color_foreground_r"] = "255",
			["streamradio_gui_color_global_spectrum_color_g"] = "14",
			["streamradio_gui_color_global_spectrum_color_icon_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_b"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_g"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_r"] = "255",
			["streamradio_gui_color_global_spectrum_color_r"] = "54",
			["streamradio_gui_color_global_spectrum_color_shadow_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_shadow_b"] = "27",
			["streamradio_gui_color_global_spectrum_color_shadow_g"] = "27",
			["streamradio_gui_color_global_spectrum_color_shadow_r"] = "27",
		},
		["Nature"] = {
			["streamradio_gui_color_global_border_color_border_a"] = "255",
			["streamradio_gui_color_global_border_color_border_b"] = "23",
			["streamradio_gui_color_global_border_color_border_g"] = "128",
			["streamradio_gui_color_global_border_color_border_r"] = "0",
			["streamradio_gui_color_global_button_color_a"] = "255",
			["streamradio_gui_color_global_button_color_b"] = "0",
			["streamradio_gui_color_global_button_color_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_disabled_b"] = "3",
			["streamradio_gui_color_global_button_color_disabled_g"] = "36",
			["streamradio_gui_color_global_button_color_disabled_r"] = "0",
			["streamradio_gui_color_global_button_color_foreground_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_b"] = "175",
			["streamradio_gui_color_global_button_color_foreground_disabled_g"] = "175",
			["streamradio_gui_color_global_button_color_foreground_disabled_r"] = "175",
			["streamradio_gui_color_global_button_color_foreground_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_hover_r"] = "0",
			["streamradio_gui_color_global_button_color_foreground_r"] = "0",
			["streamradio_gui_color_global_button_color_g"] = "132",
			["streamradio_gui_color_global_button_color_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_hover_b"] = "112",
			["streamradio_gui_color_global_button_color_hover_g"] = "175",
			["streamradio_gui_color_global_button_color_hover_r"] = "116",
			["streamradio_gui_color_global_button_color_icon_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_r"] = "255",
			["streamradio_gui_color_global_button_color_r"] = "0",
			["streamradio_gui_color_global_button_color_shadow_a"] = "255",
			["streamradio_gui_color_global_button_color_shadow_b"] = "40",
			["streamradio_gui_color_global_button_color_shadow_g"] = "40",
			["streamradio_gui_color_global_button_color_shadow_r"] = "40",
			["streamradio_gui_color_global_cursor_color_cursor_a"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_b"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_g"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_r"] = "255",
			["streamradio_gui_color_global_error_color_a"] = "255",
			["streamradio_gui_color_global_error_color_b"] = "64",
			["streamradio_gui_color_global_error_color_foreground_a"] = "255",
			["streamradio_gui_color_global_error_color_foreground_b"] = "175",
			["streamradio_gui_color_global_error_color_foreground_g"] = "175",
			["streamradio_gui_color_global_error_color_foreground_r"] = "175",
			["streamradio_gui_color_global_error_color_g"] = "64",
			["streamradio_gui_color_global_error_color_r"] = "64",
			["streamradio_gui_color_global_error_color_shadow_a"] = "255",
			["streamradio_gui_color_global_error_color_shadow_b"] = "40",
			["streamradio_gui_color_global_error_color_shadow_g"] = "40",
			["streamradio_gui_color_global_error_color_shadow_r"] = "40",
			["streamradio_gui_color_global_header_color_a"] = "255",
			["streamradio_gui_color_global_header_color_b"] = "0",
			["streamradio_gui_color_global_header_color_foreground_a"] = "255",
			["streamradio_gui_color_global_header_color_foreground_b"] = "177",
			["streamradio_gui_color_global_header_color_foreground_g"] = "177",
			["streamradio_gui_color_global_header_color_foreground_r"] = "177",
			["streamradio_gui_color_global_header_color_g"] = "80",
			["streamradio_gui_color_global_header_color_r"] = "91",
			["streamradio_gui_color_global_header_color_shadow_a"] = "255",
			["streamradio_gui_color_global_header_color_shadow_b"] = "40",
			["streamradio_gui_color_global_header_color_shadow_g"] = "40",
			["streamradio_gui_color_global_header_color_shadow_r"] = "40",
			["streamradio_gui_color_global_main_color_a"] = "255",
			["streamradio_gui_color_global_main_color_b"] = "34",
			["streamradio_gui_color_global_main_color_g"] = "56",
			["streamradio_gui_color_global_main_color_r"] = "0",
			["streamradio_gui_color_global_spectrum_color_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_b"] = "0",
			["streamradio_gui_color_global_spectrum_color_foreground_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_foreground_b"] = "0",
			["streamradio_gui_color_global_spectrum_color_foreground_g"] = "128",
			["streamradio_gui_color_global_spectrum_color_foreground_r"] = "51",
			["streamradio_gui_color_global_spectrum_color_g"] = "0",
			["streamradio_gui_color_global_spectrum_color_icon_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_b"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_g"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_r"] = "255",
			["streamradio_gui_color_global_spectrum_color_r"] = "0",
			["streamradio_gui_color_global_spectrum_color_shadow_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_shadow_b"] = "40",
			["streamradio_gui_color_global_spectrum_color_shadow_g"] = "40",
			["streamradio_gui_color_global_spectrum_color_shadow_r"] = "40",
		},
		["Pink"] = {
			["streamradio_gui_color_global_border_color_border_a"] = "255",
			["streamradio_gui_color_global_border_color_border_b"] = "0",
			["streamradio_gui_color_global_border_color_border_g"] = "0",
			["streamradio_gui_color_global_border_color_border_r"] = "0",
			["streamradio_gui_color_global_button_color_a"] = "255",
			["streamradio_gui_color_global_button_color_b"] = "186",
			["streamradio_gui_color_global_button_color_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_disabled_b"] = "61",
			["streamradio_gui_color_global_button_color_disabled_g"] = "61",
			["streamradio_gui_color_global_button_color_disabled_r"] = "61",
			["streamradio_gui_color_global_button_color_foreground_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_b"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_foreground_g"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_foreground_r"] = "255",
			["streamradio_gui_color_global_button_color_g"] = "0",
			["streamradio_gui_color_global_button_color_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_hover_b"] = "0",
			["streamradio_gui_color_global_button_color_hover_g"] = "0",
			["streamradio_gui_color_global_button_color_hover_r"] = "168",
			["streamradio_gui_color_global_button_color_icon_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_r"] = "255",
			["streamradio_gui_color_global_button_color_r"] = "174",
			["streamradio_gui_color_global_button_color_shadow_a"] = "255",
			["streamradio_gui_color_global_button_color_shadow_b"] = "91",
			["streamradio_gui_color_global_button_color_shadow_g"] = "91",
			["streamradio_gui_color_global_button_color_shadow_r"] = "91",
			["streamradio_gui_color_global_cursor_color_cursor_a"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_b"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_g"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_r"] = "255",
			["streamradio_gui_color_global_error_color_a"] = "255",
			["streamradio_gui_color_global_error_color_b"] = "29",
			["streamradio_gui_color_global_error_color_foreground_a"] = "255",
			["streamradio_gui_color_global_error_color_foreground_b"] = "255",
			["streamradio_gui_color_global_error_color_foreground_g"] = "255",
			["streamradio_gui_color_global_error_color_foreground_r"] = "255",
			["streamradio_gui_color_global_error_color_g"] = "29",
			["streamradio_gui_color_global_error_color_r"] = "93",
			["streamradio_gui_color_global_error_color_shadow_a"] = "255",
			["streamradio_gui_color_global_error_color_shadow_b"] = "91",
			["streamradio_gui_color_global_error_color_shadow_g"] = "91",
			["streamradio_gui_color_global_error_color_shadow_r"] = "91",
			["streamradio_gui_color_global_header_color_a"] = "255",
			["streamradio_gui_color_global_header_color_b"] = "71",
			["streamradio_gui_color_global_header_color_foreground_a"] = "255",
			["streamradio_gui_color_global_header_color_foreground_b"] = "255",
			["streamradio_gui_color_global_header_color_foreground_g"] = "255",
			["streamradio_gui_color_global_header_color_foreground_r"] = "255",
			["streamradio_gui_color_global_header_color_g"] = "0",
			["streamradio_gui_color_global_header_color_r"] = "102",
			["streamradio_gui_color_global_header_color_shadow_a"] = "255",
			["streamradio_gui_color_global_header_color_shadow_b"] = "91",
			["streamradio_gui_color_global_header_color_shadow_g"] = "91",
			["streamradio_gui_color_global_header_color_shadow_r"] = "91",
			["streamradio_gui_color_global_main_color_a"] = "255",
			["streamradio_gui_color_global_main_color_b"] = "125",
			["streamradio_gui_color_global_main_color_g"] = "0",
			["streamradio_gui_color_global_main_color_r"] = "102",
			["streamradio_gui_color_global_spectrum_color_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_b"] = "141",
			["streamradio_gui_color_global_spectrum_color_foreground_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_foreground_b"] = "152",
			["streamradio_gui_color_global_spectrum_color_foreground_g"] = "0",
			["streamradio_gui_color_global_spectrum_color_foreground_r"] = "127",
			["streamradio_gui_color_global_spectrum_color_g"] = "141",
			["streamradio_gui_color_global_spectrum_color_icon_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_b"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_g"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_r"] = "255",
			["streamradio_gui_color_global_spectrum_color_r"] = "141",
			["streamradio_gui_color_global_spectrum_color_shadow_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_shadow_b"] = "91",
			["streamradio_gui_color_global_spectrum_color_shadow_g"] = "91",
			["streamradio_gui_color_global_spectrum_color_shadow_r"] = "91",
		},
		["Steam Original"] = {
			["streamradio_gui_color_global_border_color_border_a"] = "255",
			["streamradio_gui_color_global_border_color_border_b"] = "68",
			["streamradio_gui_color_global_border_color_border_g"] = "88",
			["streamradio_gui_color_global_border_color_border_r"] = "76",
			["streamradio_gui_color_global_button_color_a"] = "255",
			["streamradio_gui_color_global_button_color_b"] = "68",
			["streamradio_gui_color_global_button_color_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_disabled_b"] = "61",
			["streamradio_gui_color_global_button_color_disabled_g"] = "61",
			["streamradio_gui_color_global_button_color_disabled_r"] = "61",
			["streamradio_gui_color_global_button_color_foreground_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_b"] = "149",
			["streamradio_gui_color_global_button_color_foreground_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_b"] = "120",
			["streamradio_gui_color_global_button_color_foreground_disabled_g"] = "120",
			["streamradio_gui_color_global_button_color_foreground_disabled_r"] = "120",
			["streamradio_gui_color_global_button_color_foreground_g"] = "170",
			["streamradio_gui_color_global_button_color_foreground_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_foreground_r"] = "160",
			["streamradio_gui_color_global_button_color_g"] = "88",
			["streamradio_gui_color_global_button_color_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_hover_b"] = "103",
			["streamradio_gui_color_global_button_color_hover_g"] = "123",
			["streamradio_gui_color_global_button_color_hover_r"] = "113",
			["streamradio_gui_color_global_button_color_icon_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_r"] = "255",
			["streamradio_gui_color_global_button_color_r"] = "76",
			["streamradio_gui_color_global_button_color_shadow_a"] = "255",
			["streamradio_gui_color_global_button_color_shadow_b"] = "34",
			["streamradio_gui_color_global_button_color_shadow_g"] = "46",
			["streamradio_gui_color_global_button_color_shadow_r"] = "40",
			["streamradio_gui_color_global_cursor_color_cursor_a"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_b"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_g"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_r"] = "255",
			["streamradio_gui_color_global_error_color_a"] = "255",
			["streamradio_gui_color_global_error_color_b"] = "46",
			["streamradio_gui_color_global_error_color_foreground_a"] = "255",
			["streamradio_gui_color_global_error_color_foreground_b"] = "80",
			["streamradio_gui_color_global_error_color_foreground_g"] = "181",
			["streamradio_gui_color_global_error_color_foreground_r"] = "196",
			["streamradio_gui_color_global_error_color_g"] = "56",
			["streamradio_gui_color_global_error_color_r"] = "99",
			["streamradio_gui_color_global_error_color_shadow_a"] = "255",
			["streamradio_gui_color_global_error_color_shadow_b"] = "34",
			["streamradio_gui_color_global_error_color_shadow_g"] = "46",
			["streamradio_gui_color_global_error_color_shadow_r"] = "40",
			["streamradio_gui_color_global_header_color_a"] = "255",
			["streamradio_gui_color_global_header_color_b"] = "68",
			["streamradio_gui_color_global_header_color_foreground_a"] = "255",
			["streamradio_gui_color_global_header_color_foreground_b"] = "80",
			["streamradio_gui_color_global_header_color_foreground_g"] = "181",
			["streamradio_gui_color_global_header_color_foreground_r"] = "196",
			["streamradio_gui_color_global_header_color_g"] = "88",
			["streamradio_gui_color_global_header_color_r"] = "76",
			["streamradio_gui_color_global_header_color_shadow_a"] = "255",
			["streamradio_gui_color_global_header_color_shadow_b"] = "34",
			["streamradio_gui_color_global_header_color_shadow_g"] = "46",
			["streamradio_gui_color_global_header_color_shadow_r"] = "40",
			["streamradio_gui_color_global_main_color_a"] = "255",
			["streamradio_gui_color_global_main_color_b"] = "46",
			["streamradio_gui_color_global_main_color_g"] = "58",
			["streamradio_gui_color_global_main_color_r"] = "52",
			["streamradio_gui_color_global_spectrum_color_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_b"] = "68",
			["streamradio_gui_color_global_spectrum_color_foreground_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_foreground_b"] = "80",
			["streamradio_gui_color_global_spectrum_color_foreground_g"] = "181",
			["streamradio_gui_color_global_spectrum_color_foreground_r"] = "196",
			["streamradio_gui_color_global_spectrum_color_g"] = "88",
			["streamradio_gui_color_global_spectrum_color_icon_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_b"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_g"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_r"] = "255",
			["streamradio_gui_color_global_spectrum_color_r"] = "76",
			["streamradio_gui_color_global_spectrum_color_shadow_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_shadow_b"] = "34",
			["streamradio_gui_color_global_spectrum_color_shadow_g"] = "46",
			["streamradio_gui_color_global_spectrum_color_shadow_r"] = "40",
		},
		["Warm"] = {
			["streamradio_gui_color_global_border_color_border_a"] = "255",
			["streamradio_gui_color_global_border_color_border_b"] = "0",
			["streamradio_gui_color_global_border_color_border_g"] = "0",
			["streamradio_gui_color_global_border_color_border_r"] = "0",
			["streamradio_gui_color_global_button_color_a"] = "255",
			["streamradio_gui_color_global_button_color_b"] = "0",
			["streamradio_gui_color_global_button_color_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_disabled_b"] = "132",
			["streamradio_gui_color_global_button_color_disabled_g"] = "132",
			["streamradio_gui_color_global_button_color_disabled_r"] = "132",
			["streamradio_gui_color_global_button_color_foreground_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_b"] = "190",
			["streamradio_gui_color_global_button_color_foreground_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_disabled_b"] = "0",
			["streamradio_gui_color_global_button_color_foreground_disabled_g"] = "0",
			["streamradio_gui_color_global_button_color_foreground_disabled_r"] = "0",
			["streamradio_gui_color_global_button_color_foreground_g"] = "190",
			["streamradio_gui_color_global_button_color_foreground_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_foreground_hover_b"] = "190",
			["streamradio_gui_color_global_button_color_foreground_hover_g"] = "190",
			["streamradio_gui_color_global_button_color_foreground_hover_r"] = "190",
			["streamradio_gui_color_global_button_color_foreground_r"] = "190",
			["streamradio_gui_color_global_button_color_g"] = "35",
			["streamradio_gui_color_global_button_color_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_hover_b"] = "0",
			["streamradio_gui_color_global_button_color_hover_g"] = "0",
			["streamradio_gui_color_global_button_color_hover_r"] = "79",
			["streamradio_gui_color_global_button_color_icon_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_disabled_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_a"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_b"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_g"] = "255",
			["streamradio_gui_color_global_button_color_icon_hover_r"] = "255",
			["streamradio_gui_color_global_button_color_icon_r"] = "255",
			["streamradio_gui_color_global_button_color_r"] = "97",
			["streamradio_gui_color_global_button_color_shadow_a"] = "255",
			["streamradio_gui_color_global_button_color_shadow_b"] = "63",
			["streamradio_gui_color_global_button_color_shadow_g"] = "63",
			["streamradio_gui_color_global_button_color_shadow_r"] = "113",
			["streamradio_gui_color_global_cursor_color_cursor_a"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_b"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_g"] = "255",
			["streamradio_gui_color_global_cursor_color_cursor_r"] = "255",
			["streamradio_gui_color_global_error_color_a"] = "255",
			["streamradio_gui_color_global_error_color_b"] = "52",
			["streamradio_gui_color_global_error_color_foreground_a"] = "255",
			["streamradio_gui_color_global_error_color_foreground_b"] = "190",
			["streamradio_gui_color_global_error_color_foreground_g"] = "190",
			["streamradio_gui_color_global_error_color_foreground_r"] = "190",
			["streamradio_gui_color_global_error_color_g"] = "52",
			["streamradio_gui_color_global_error_color_r"] = "75",
			["streamradio_gui_color_global_error_color_shadow_a"] = "255",
			["streamradio_gui_color_global_error_color_shadow_b"] = "63",
			["streamradio_gui_color_global_error_color_shadow_g"] = "63",
			["streamradio_gui_color_global_error_color_shadow_r"] = "113",
			["streamradio_gui_color_global_header_color_a"] = "255",
			["streamradio_gui_color_global_header_color_b"] = "54",
			["streamradio_gui_color_global_header_color_foreground_a"] = "255",
			["streamradio_gui_color_global_header_color_foreground_b"] = "190",
			["streamradio_gui_color_global_header_color_foreground_g"] = "190",
			["streamradio_gui_color_global_header_color_foreground_r"] = "190",
			["streamradio_gui_color_global_header_color_g"] = "54",
			["streamradio_gui_color_global_header_color_r"] = "93",
			["streamradio_gui_color_global_header_color_shadow_a"] = "255",
			["streamradio_gui_color_global_header_color_shadow_b"] = "63",
			["streamradio_gui_color_global_header_color_shadow_g"] = "63",
			["streamradio_gui_color_global_header_color_shadow_r"] = "113",
			["streamradio_gui_color_global_main_color_a"] = "255",
			["streamradio_gui_color_global_main_color_b"] = "0",
			["streamradio_gui_color_global_main_color_g"] = "47",
			["streamradio_gui_color_global_main_color_r"] = "61",
			["streamradio_gui_color_global_spectrum_color_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_b"] = "0",
			["streamradio_gui_color_global_spectrum_color_foreground_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_foreground_b"] = "129",
			["streamradio_gui_color_global_spectrum_color_foreground_g"] = "129",
			["streamradio_gui_color_global_spectrum_color_foreground_r"] = "139",
			["streamradio_gui_color_global_spectrum_color_g"] = "46",
			["streamradio_gui_color_global_spectrum_color_icon_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_b"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_g"] = "255",
			["streamradio_gui_color_global_spectrum_color_icon_r"] = "255",
			["streamradio_gui_color_global_spectrum_color_r"] = "100",
			["streamradio_gui_color_global_spectrum_color_shadow_a"] = "255",
			["streamradio_gui_color_global_spectrum_color_shadow_b"] = "63",
			["streamradio_gui_color_global_spectrum_color_shadow_g"] = "63",
			["streamradio_gui_color_global_spectrum_color_shadow_r"] = "113",
		},
	},
}

function StreamRadioLib.GetPresets( Toolname, Setting )
	if not Toolname then return end
	if not Setting then return end
	if Toolname == "" then return end
	if Setting == "" then return end
	if not g_settings[Toolname] then return end

	return table.Copy(g_settings[Toolname][Setting])
end

function StreamRadioLib.GetPresetsTable( Toolname )
	if not Toolname then return end
	if Toolname == "" then return end

	return table.Copy(g_settings[Toolname])
end

do
	-- Preset to lua converter
	local function createpresets( ply, cmd, args )
		if not LIBUtil.IsAdminForCMD(ply) then
			return
		end

		local files = file.Find( "settings/presets/streamradio_gui_color_global/*.txt", "GAME" )

		local data = {}

		local settings = StreamRadioLib.GetPresetsTable(g_radioColorToolName)

		for _, f in ipairs( files or {} ) do
			local presetsString = file.Read( "settings/presets/streamradio_gui_color_global/" .. f, "GAME" ) or ""
			if presetsString == "" then
				continue
			end

			local presetsData = util.KeyValuesToTable(presetsString) or {}
			if table.IsEmpty(presetsData) then
				continue
			end

			local name = string.sub( f, 1, -5 )
			settings[name] = presetsData
		end

		table.insert(data, "{")
		table.insert(data, "\n")

		for name, items in SortedPairs(settings) do
			table.insert(data, "\t")
			table.insert(data, "[\"")
			table.insert(data, name)
			table.insert(data, "\"] = {")
			table.insert(data, "\n")

			for k, v in SortedPairs(items) do
				local len = #k
				local is_t = string.sub(k, len - 1) == "_t"

				if is_t then
					if name == "default" then
						v = 1
					else
						continue
					end
				end

				table.insert(data, "\t\t")
				table.insert(data, "[\"")
				table.insert(data, tostring(k or ""))
				table.insert(data, "\"] = \"")
				table.insert(data, tostring(v or ""))
				table.insert(data, "\",")
				table.insert(data, "\n")
			end

			table.insert(data, "\t")
			table.insert(data, "},")
			table.insert(data, "\n")
		end

		table.insert(data, "}")
		table.insert(data, "\n")

		data = table.concat(data, "")

		local filePath = g_mainPath .. "/streamradio_gui_color_global.txt"

		LIBUtil.CreateDirectoryForFile(filePath)

		file.Delete(filePath)
		file.Write(filePath, data)

		if file.Exists(filePath, "DATA") then
			LIBPrint.Msg(ply, "Lua formated presets for 'streamradio_gui_color_global' saved to '%s'", filePath)
		else
			LIBPrint.Msg(ply, "Could not write to '%s'", filePath)
		end
	end

	concommand.Add( "debug_streamradio_convertpresets", createpresets, nil, nil, FCVAR_CHEAT )
end

return true


--PATH lua/streamradio_core/client/cl_skin.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_whitelist.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/files-sound-folder.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/pls.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "PLS"
RADIOFS.type = "pls"
RADIOFS.extension = "pls"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("table_sound", true)

RADIOFS.priority = 9000
RADIOFS.loadToWhitelist = true

local function decodePLS(RawPlaylist)
	local RawPlaylistTab = string.Split( RawPlaylist, "\n" )

	local Header = string.lower( string.Trim( RawPlaylistTab[1] or "" ) )
	local Version = string.lower( string.Trim( RawPlaylistTab[#RawPlaylistTab] or "" ) )

	if Header ~= "[playlist]" then
		return nil
	end

	if Version ~= "version=2" then
		return nil
	end

	local CountHeader = string.lower( string.Trim( RawPlaylistTab[2] or "" ) )
	local Count = tonumber(string.match(CountHeader, "%s*numberofentries%s*=%s*([0-9]+)")) or 0

	local Playlist = {}

	if Count <= 0 then
		return Playlist
	end

	for i = 1, Count do
		local line = i * 3

		local UrlLine = RawPlaylistTab[line] or ""
		local NameLine = RawPlaylistTab[line + 1] or ""

		local url = string.Trim(string.match(UrlLine, "%s*File" .. i .. "%s*=%s*([^\n]+)") or "")
		local name = string.Trim(string.match(NameLine, "%s*Title" .. i .. "%s*=%s*([^\n]+)") or "")

		if name == "" then
			name = url
		end

		if url == "" then
			continue
		end

		local item = {
			name = name,
			url = url
		}

		table.insert(Playlist, item)
	end

	return Playlist
end

function RADIOFS:Read(globalpath, vpath, callback)
	file.AsyncRead(globalpath, "DATA", function(fileName, gamePath, status, data)
		if status ~= FSASYNC_OK then
			callback(false, nil)
			return
		end

		local RawPlaylist = string.Trim(data or "")
		if RawPlaylist == "" then
			callback(true, {})
			return
		end

		local Playlist = decodePLS(RawPlaylist)
		if not Playlist then
			callback(false, nil)
			return
		end

		callback(true, Playlist)
	end)

	return true
end

function RADIOFS:Write(globalpath, vpath, data, callback)
	if not self:CreateDirectoryForFile(globalpath) then
		callback(false)
		return false
	end

	local f = file.Open(globalpath, "w", "DATA")
	if not f then
		callback(false)
		return false
	end

	local dataOut = {}
	local Count = #data
	local Seperator = "\n"
	local Seperator2 = "="

	dataOut[#dataOut + 1] = string.format( "[playlist]\nNumberOfEntries=%i\n", Count )

	for i, v in ipairs( data ) do
		local name = string.Replace( v.name, Seperator, "" )
		local url = string.Replace( v.url, Seperator, "" )
		name = string.Trim( string.Replace( name, Seperator2, "" ) )
		url = string.Trim( string.Replace( url, Seperator2, "" ) )

		dataOut[#dataOut + 1] = string.format( "File%i" .. Seperator2 .. "%s" .. Seperator .. "Title%i" .. Seperator2 .. "%s" .. Seperator .. "Length%i" .. Seperator2 .. "-1\n", k, url, k, name, k )
	end

	dataOut[#dataOut + 1] = "Version=2"
	local DataString = table.concat(dataOut, "")

	DataString = string.Trim(DataString)
	DataString = DataString .. "\n\n"

	f:Write( DataString )
	f:Close( )

	callback(true)
	return true
end

return true


--PATH addons/[bronie] kajdanki/lua/autorun/sv_handcuffs.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- sv_handcuffs.lua         SERVER --
--                                 --
-- Server-side handcuff stuff.     --
-------------------------------------

if CLIENT then return end

util.AddNetworkString( "Cuffs_GagPlayer" )
util.AddNetworkString( "Cuffs_BlindPlayer" )
util.AddNetworkString( "Cuffs_FreePlayer" )
util.AddNetworkString( "Cuffs_DragPlayer" )

util.AddNetworkString( "Cuffs_TiePlayers" )
util.AddNetworkString( "Cuffs_UntiePlayers" )

util.AddNetworkString( "Cuffs_Przeszukanie" )
util.AddNetworkString( "Cuffs_Przeszukanie_strip" )

local function GetTrace( ply )
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
		local cuffed,wep = tr.Entity:IsHandcuffed()
		if cuffed then return tr,wep end
	end
end

//
// Standard hooks
CreateConVar( "cuffs_restrictsuicide", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE} )
hook.Add( "CanPlayerSuicide", "Cuffs RestrictSuicide", function( ply )
	if ply:IsHandcuffed() and cvars.Bool("cuffs_restrictarrest") then return false end
end)
CreateConVar( "cuffs_restrictteams", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE} )
hook.Add( "PlayerCanJoinTeam", "Cuffs RestrictTeam", function( ply )
	if ply:IsHandcuffed() and cvars.Bool("cuffs_restrictteams") then return false end
end)
hook.Add( "PlayerCanSeePlayersChat", "Cuffs ChatGag", function( _,_,_, ply )
	if not IsValid(ply) then return end
	
	local cuffed,wep = ply:IsHandcuffed()
	if cuffed and wep:GetIsGagged() then return false end
end)
hook.Add( "PlayerCanHearPlayersVoice", "Cuffs VoiceGag", function( _, ply )
	if not IsValid(ply) then return end
	
	local cuffed,wep = ply:IsHandcuffed()
	if cuffed and wep:GetIsGagged() then return false end
end)

// 
// DarkRP
CreateConVar( "cuffs_restrictwarrant", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE,FCVAR_REPLICATED} )
hook.Add( "canRequestWarrant", "Cuffs PreventWarrant", function( crim, cop, reason )
	if cvars.Bool("cuffs_restrictwarrant") and cop:IsHandcuffed() then return false,"You can issue warrants when cuffed!" end
end)
hook.Add( "canWanted", "Cuffs PreventWarrant", function( crim, cop, reason )
	if cvars.Bool("cuffs_restrictwarrant") and cop:IsHandcuffed() then return false,"You can issue warrants when cuffed!" end
end)
CreateConVar( "cuffs_restrictarrest", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE} )
hook.Add( "canArrest", "Cuffs RestrictArrest", function( cop, crim ) // DarkRP Arrest hook
	if IsValid(crim) and cvars.Bool("cuffs_restrictarrest") and not crim:IsHandcuffed() then return false,"You must handcuff a suspect to arrest them!" end
end)
hook.Add( "playerCanChangeTeam", "Cuffs RestrictTeam", function( ply, tm, force )
	if ply:IsHandcuffed() and cvars.Bool("cuffs_restrictteams") and not force then return false,"You can't change jobs when cuffed!" end
end)
hook.Add( "CanChangeRPName", "Cuffs RestrictName", function( ply )
	if ply:IsHandcuffed() then return false,"You can't change your name when cuffed!" end
end)

//
// Think
local NextTieHookCleanup
local notthatfast = CurTime()
hook.Add( "Think", "Cuffs ForceJump CleanupTieHooks", function()
    if notthatfast > CurTime() then return end
	notthatfast = CurTime() + 1
	for _,v in pairs(player.GetAll()) do
		if v.Cuff_ForceJump then
			if not v:OnGround() then return end
			
			local tr = util.TraceLine( {start = v:GetPos(), endpos = v:GetPos()+Vector(0,0,20), filter = v} )
			if tr.Hit then return end
			
			v:SetPos(v:GetPos()+Vector(0,0,5) )
			
			v.Cuff_ForceJump = nil
		end
	end
	
	if CurTime()>=(NextTieHookCleanup or 0) then
		for _,v in pairs(ents.FindByClass("prop_physics")) do
			if v.IsHandcuffHook and v.TiedHandcuffs then
				for i=#v.TiedHandcuffs,0,-1 do
					if not IsValid(v.TiedHandcuffs[i]) then
						table.remove( v.TiedHandcuffs, i )
					end
				end
				if #v.TiedHandcuffs<=0 then
					v:Remove()
					continue
				end
			end
		end
	end
end)

//
// Cuffed player interaction
net.Receive( "Cuffs_GagPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetCanGag()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldGag = net.ReadBit()==1
	cuffs:SetIsGagged( shouldGag )
	hook.Call( shouldGag and "OnHandcuffGag" or "OnHandcuffUnGag", GAMEMODE, ply, target, cuffs )
end)
net.Receive( "Cuffs_BlindPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetCanBlind()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldBlind = net.ReadBit()==1
	cuffs:SetIsBlind( shouldBlind )
	hook.Call( shouldBlind and "OnHandcuffBlindfold" or "OnHandcuffUnBlindfold", GAMEMODE, ply, target, cuffs )
end)
net.Receive( "Cuffs_FreePlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	if !ply:Alive() then return end
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs)) then return end
	if IsValid(cuffs:GetFriendBreaking()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	cuffs:SetFriendBreaking( ply )
end)
net.Receive( "Cuffs_DragPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetRopeLength()>0) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldDrag = net.ReadBit()==1
	if shouldDrag then
		if not (IsValid(cuffs:GetKidnapper())) then
			cuffs:SetKidnapper( ply )
			hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, target, cuffs )
		end
	else
		if ply==cuffs:GetKidnapper() then
			cuffs:SetKidnapper( nil )
			hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, target, cuffs )
		end
	end
end)
net.Receive( "Cuffs_Przeszukanie", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	if !ply:Alive() then return end
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	if !target:IsHandcuffed() then return end
	if ply:GetPos():Distance(target:GetPos()) > 200 then return end 
	local weapons_table = target:GetWeapons()
	net.Start("Cuffs_Przeszukanie")
		net.WriteTable( weapons_table )
		net.WriteEntity( target)
	net.Send(ply)
end)

net.Receive( "Cuffs_Przeszukanie_strip", function(_,ply)
	local target = net.ReadEntity()
	local weapons_strip_table = net.ReadTable()
	if not target:Alive() then
		return
	end
	for _, i in pairs(weapons_strip_table) do
		if not IsValid(target:GetWeapon( i )) then
			return
		end
	end
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	if !ply:Alive() then return end
	if (not IsValid(target)) or target==ply then return end
	if !target:IsHandcuffed() then return end
	if ply:GetPos():Distance(target:GetPos()) > 200 then return end 
	for _, n in pairs(weapons_strip_table) do
		local canStrip = true
		for k, j in pairs(przeszukanie_config.safeWeapons) do
			if n==j then
				canStrip = false
			end
		end
		if canStrip == true then
			target:StripWeapon( n )
		end
	end
	net.Start("Cuffs_Przeszukanie_strip")
		net.WriteEntity( ply)
		net.WriteTable( weapons_strip_table)
	net.Send(target)
end)

local HookModel = Model("models/props_c17/TrapPropeller_Lever.mdl")
net.Receive( "Cuffs_TiePlayers", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local DraggedCuffs = {}
	for _,c in pairs(ents.FindByClass("weapon_handcuffed")) do
		if c:GetRopeLength()>0 and c:GetKidnapper()==ply then
			table.insert( DraggedCuffs, c )
		end
	end
	if #DraggedCuffs<=0 then return end
	
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if not tr.Hit then return end
	
	if IsValid(tr.Entity) then // Pass to another player
		if tr.Entity:IsPlayer() then
			for i=1,#DraggedCuffs do
				if DraggedCuffs[i].Owner==tr.Entity then
					DraggedCuffs[i]:SetKidnapper(nil)
					hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				else
					DraggedCuffs[i]:SetKidnapper(tr.Entity)
					hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
					hook.Call( "OnHandcuffStartDragging", GAMEMODE, tr.Entity, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				end
			end
			return
		elseif tr.Entity.IsHandcuffHook and tr.Entity.TiedHandcuffs then
			for i=1,#DraggedCuffs do
				DraggedCuffs[i]:SetKidnapper(tr.Entity)
				table.insert( tr.Entity.TiedHandcuffs, DraggedCuffs[i] )
				hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				hook.Call( "OnHandcuffTied", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i], tr.Entity )
			end
			return
		end
	end
	
	local hk = ents.Create("prop_physics")
	hk:SetPos( tr.HitPos + tr.HitNormal )
	local ang = tr.HitNormal:Angle()
	ang:RotateAroundAxis( ang:Up(), -90 )
	hk:SetAngles( ang )
	hk:SetModel( HookModel )
	hk:Spawn()
	
	-- hk:SetMoveType( MOVETYPE_NONE )
	if IsValid(tr.Entity) then
		hk:SetParent( tr.Entity )
		hk:SetMoveType( MOVETYPE_VPHYSICS )
	else
		hk:SetMoveType( MOVETYPE_NONE )
	end
	hk:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	
	hk:SetNWBool("Cuffs_TieHook", true)
	hk.IsHandcuffHook = true
	hk.TiedHandcuffs = {}
	
	for i=1,#DraggedCuffs do
		DraggedCuffs[i]:SetKidnapper( hk )
		table.insert( hk.TiedHandcuffs, DraggedCuffs[i] )
		hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
		hook.Call( "OnHandcuffTied", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i], hk )
	end
end)

local function DoUntie( ply, ent )
	for i=1,#ent.TiedHandcuffs do
		if not IsValid(ent.TiedHandcuffs[i]) then continue end
		
		ent.TiedHandcuffs[i]:SetKidnapper( ply )
		hook.Call( "OnHandcuffUnTied", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i], ent )
		hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i] )
	end
	
	ent:Remove()
end
net.Receive( "Cuffs_UntiePlayers", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if IsValid(tr.Entity) and tr.Entity.IsHandcuffHook and tr.Entity.TiedHandcuffs then
		DoUntie( ply, tr.Entity )
	end
end)
hook.Add( "AllowPlayerPickup", "Cuffs UntieHook", function(ply,ent)
	if IsValid(ent) and ent.IsHandcuffHook and ent.TiedHandcuffs then
		if (not IsValid(ply)) or ply:IsHandcuffed() then return end
		
		DoUntie( ply, ent )
		return false
	end
end)

//
// GmodDayZ support
// Created by and added with permission of Phoenix129 ( http://steamcommunity.com/profiles/76561198039440140/ )
hook.Add("OnHandcuffed", "DayZCuffs RemoveInventoryItem", function(ply, cuffedply, handcuffs)
	if engine.ActiveGamemode() == "dayz" then
		ply:TakeCharItem( handcuffs.CuffType )
	end
end)
 
hook.Add("OnHandcuffBreak", "DayZCuffs GiveInventoryItemIfFriend", function(cuffedply, handcuffs, friend)
	if engine.ActiveGamemode() == "dayz" then
		if IsValid(friend) and handcuffs.CuffType and handcuffs.CuffType~="" then
			friend:GiveItem(handcuffs.CuffType, 1)
		end
	end
end)

hook.Add( "CuffsCanHandcuff", "DayZCuffs SafezoneProtectCuffs", function( ply, target )
	if engine.ActiveGamemode() == "dayz" then
		if target.SafeZone or target.SafeZoneEdge or target.Loading or !target.Ready then
			return false
		end
	end
end)
hook.Add("PlayerDisconnected", "DayZCuffs DieHandcuffs", function(ply)
	if engine.ActiveGamemode() == "dayz" then
		if ply:IsHandcuffed() then ply:Kill() end
	end
end)


hook.Add( "CuffsCanHandcuff", "CuffProtectCoolAdmins", function( ply, target )

    if RPExtraTeams[target:Team()].category == "Podmioty SCP" and (target:Team() != TEAM_SCP14 and target:Team() != TEAM_SCP11 and target:Team() != TEAM_SCP457 and target:Team() != TEAM_SCP527) then return false end

    if ply:GetActiveWeapon():GetClass() != "weapon_cuff_cage" and (target:Team() == TEAM_SCP14 or target:Team() == TEAM_SCP11 or target:Team() == TEAM_SCP457) then
        return false
    end

    if ply:GetActiveWeapon():GetClass() == "weapon_cuff_cage" and (target:Team() == TEAM_SCP14 or target:Team() == TEAM_SCP11 or target:Team() == TEAM_SCP457 or target:Team() == TEAM_SCP527) then
        return true
    end

end)
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/sv_timer.lua:
return gluapack()()
--PATH lua/autorun/sw_imperial_seats.lua:

-- Don't try to edit this file if you're trying to add new vehicles
-- Just make a new file and copy the format below.

local function AddVehicle( t, class )
	list.Set( "Vehicles", class, t )
end

local Category = "Star Wars Seats"

AddVehicle( {
	-- Required information
	Name = "Emperors Throne",
	Model = "models/KingPommes/starwars/misc/seats/palp_chair_full.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Emperors Throne",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "emperors_throne" )

AddVehicle( {
	-- Required information
	Name = "Imperial Conferencechair",
	Model = "models/KingPommes/starwars/misc/seats/imp_chaira.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Imperial Covfefe-chair",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "imperial_conference_chair" )

AddVehicle( {
	-- Required information
	Name = "Tarkins Conferencechair",
	Model = "models/KingPommes/starwars/misc/seats/imp_chairb.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Tarkins Covfefe-chair",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "tarkins_conference_chair" )


AddVehicle( {
	-- Required information
	Name = "Senat Armchair",
	Model = "models/KingPommes/starwars/misc/seats/imp_armchair.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Senat Armchair",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "senat_armchair" )

AddVehicle( {
	-- Required information
	Name = "Bridgecrew Seat",
	Model = "models/lordtrilobite/starwars/props/imp_chair01.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "Lord Trilobite",
	Information = "Bridgecrew Seat",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "bridgecrew_seat" )

--PATH lua/autorun/swrc_autorun.lua:
/*--------------------------------------------------
	=============== Autorun File ===============
	*** Copyright (c) 2012-2018 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
------------------ Addon Information ------------------
local PublicAddonName = "[VJ] Hard Contact Era"
local AddonName = "HC SNPCs"
local AddonType = "SNPC"
local AutorunFile = "autorun/vj_wotw_autorun.lua"
-------------------------------------------------------
local VJExists = file.Exists("lua/autorun/vj_base_autorun.lua","GAME")
if VJExists == true then
	include('autorun/vj_controls.lua')

	local vCat = "[SWRC] Droids" -- Category, you can also set a category individually by replacing the vCat with a string value

	VJ.AddNPC("Battle Droid","npc_vj_battle_droid_swrc",vCat)

	VJ.AddNPC("Droideka","npc_vj_droideka_droid_swrc",vCat)

	VJ.AddNPC("Magna Guard","npc_vj_magna_guard_swrc",vCat)


-- !!!!!! DON'T TOUCH ANYTHING BELOW THIS !!!!!! -------------------------------------------------------------------------------------------------------------------------
	AddCSLuaFile(AutorunFile)
	VJ.AddAddonProperty(AddonName,AddonType)
else
	if (CLIENT) then
		chat.AddText(Color(0,200,200),PublicAddonName,
		Color(0,255,0)," was unable to install, you are missing ",
		Color(255,100,0),"VJ Base!")
	end
	timer.Simple(1,function()
		if not VJF then
			if (CLIENT) then
				VJF = vgui.Create("DFrame")
				VJF:SetTitle("ERROR!")
				VJF:SetSize(790,560)
				VJF:SetPos((ScrW()-VJF:GetWide())/2,(ScrH()-VJF:GetTall())/2)
				VJF:MakePopup()
				VJF.Paint = function()
					draw.RoundedBox(8,0,0,VJF:GetWide(),VJF:GetTall(),Color(200,0,0,150))
				end
				
				local VJURL = vgui.Create("DHTML",VJF)
				VJURL:SetPos(VJF:GetWide()*0.005, VJF:GetTall()*0.03)
				VJURL:Dock(FILL)
				VJURL:SetAllowLua(true)
				VJURL:OpenURL("https://sites.google.com/site/vrejgaming/vjbasemissing")
			elseif (SERVER) then
				timer.Create("VJBASEMissing",5,0,function() print("VJ Base is Missing! Download it from the workshop!") end)
			end
		end
	end)
end
--PATH addons/[chat] talk-modes/lua/talk_modes/config/sh_config.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_turkish.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/core/sh_core.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/core/cl_core.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/networking/cl_net.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_previewslider.lua:
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
AccessorFunc(PANEL, "value", "Value")
function PANEL:Init()
    self.slider = self:Add("TalkModes.Slider")
    self.slider:SetSize(256, 12)
    self.slider:SetPos(8, 100 - 6 - 24)

    self.preview = self:Add("DButton")
    self.preview:SetFont("TalkModes:Small")
    self.preview:SetText(string.upper(TalkModes.Languages:GetPhrase("Preview")))
    self.preview:DockMargin(6, 6, 6, 6)
    self.preview:SetColor(THEME["White"])
    self.preview:SizeToContents()
    self.preview:SetPos(8 + 256, 100 - 6 - 18 - self.preview:GetTall()/2)
    self.preview.Alpha = 90
    self.preview.Paint = function(self, intW, intH)
        self.Alpha = Lerp(FrameTime() * 8, self.Alpha, self:IsHovered() && 230 || 90)
        draw.RoundedBox(6, 0, 0, intW, intH, Color(THEME["Hover"].r, THEME["Hover"].g, THEME["Hover"].b, self.Alpha))
    end
    self.preview.DoClick = function(this)
        net.Start("TalkModes.AttemptPreview")
            net.WriteUInt(self.slider:GetValue(), 32)
        net.SendToServer()
    end
end

function PANEL:RefreshValue()
    self.slider:SetValue(self:GetValue())
end

function PANEL:Think()
    self:SetValue(self.slider:GetValue())
end
vgui.Register("TalkModes.PreviewSlider", PANEL, "EditablePanel")

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_theme.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_spheres.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_attachments.lua:
TFA.Attachments = TFA.Attachments or {}
TFA.Attachments.Atts = {}

TFA.Attachments.Colors = {
	["active"] = Color(252, 151, 50, 255),
	["error"] = Color(225, 0, 0, 255),
	["error_attached"] = Color(140, 80, 30, 255),
	["background"] = Color(15, 15, 15, 64),
	["primary"] = Color(245, 245, 245, 255),
	["secondary"] = Color(153, 253, 220, 255),
	["+"] = Color(128, 255, 128, 255),
	["-"] = Color(255, 128, 128, 255),
	["="] = Color(192, 192, 192, 255)
}

TFA.Attachments.UIPadding = 2
TFA.Attachments.IconSize = 64
TFA.Attachments.CategorySpacing = 128

if SERVER then
	util.AddNetworkString("TFA_Attachment_Set")
	util.AddNetworkString("TFA_Attachment_SetStatus")
	util.AddNetworkString("TFA_Attachment_Reload")
	util.AddNetworkString("TFA_Attachment_Request")

	local function UpdateWeapon(wep, ply)
		for category, data in pairs(wep.Attachments or {}) do
			if type(category) ~= "string" then
				net.Start("TFA_Attachment_Set")
				net.WriteEntity(wep)

				net.WriteUInt(category, 8)
				if data.atts and data.atts[data.sel] then
					net.WriteString(data.atts[data.sel])
				else
					net.WriteString("")
				end

				net.Send(ply)
			end
		end
	end

	net.Receive("TFA_Attachment_Request", function(len, ply)
		if not IsValid(ply) then return end
		local wep = net.ReadEntity()
		if not IsValid(wep) or not wep.IsTFAWeapon or not wep.HasInitAttachments or wep.AttachmentCount < 1 then return end
		local ctime = SysTime()

		local currentScheduleRequest = ply.__TFA_Base_Next_Attachment_Request or ctime
		local nextScheduleRequest = math.max(ctime + 0.2, currentScheduleRequest + 0.2)
		ply.__TFA_Base_Next_Attachment_Request = nextScheduleRequest

		if currentScheduleRequest <= ctime then
			UpdateWeapon(wep, ply)
		-- elseif currentScheduleRequest - ctime >= 10 then
			-- ply:Kick("TFA_Attachment_Request spam")
		else
			timer.Simple(nextScheduleRequest - ctime, function()
				if IsValid(ply) and IsValid(wep) then
					UpdateWeapon(wep, ply)
				end
			end)
		end
	end)

	net.Receive("TFA_Attachment_Set", function(len, ply)
		local wep = ply:GetWeapon(net.ReadString())
		if not IsValid(wep) or not wep.IsTFAWeapon then return end

		local cat = net.ReadUInt(8)
		local ind = net.ReadString()
		local status = wep:SetTFAAttachment(cat, ind, ply)

		net.Start("TFA_Attachment_SetStatus")
		net.WriteEntity(wep)
		net.WriteBool(status)

		if not status then
			if wep.Attachments and wep.Attachments[cat] then
				local data = wep.Attachments[cat]
				net.WriteUInt(cat, 8)

				if data.atts and data.atts[data.sel] then
					net.WriteString(data.atts[data.sel])
				else
					net.WriteString("")
				end
			end
		end

		net.Send(ply)
	end)
else
	sql.Query([[
		CREATE TABLE IF NOT EXISTS tfa_savedattachments (
			class VARCHAR(80) NOT NULL,
			atts TEXT NOT NULL,
			PRIMARY KEY (class)
		)
	]])

	net.Receive("TFA_Attachment_Set", function(len)
		local wep = net.ReadEntity()

		local cat = net.ReadUInt(8)
		local ind = net.ReadString()

		if IsValid(wep) and wep.SetTFAAttachment then
			wep:SetTFAAttachment(cat, ind, false)
		end
	end)

	net.Receive("TFA_Attachment_Reload", function(len)
		TFAUpdateAttachments()
	end)

	net.Receive("TFA_Attachment_SetStatus", function(len)
		local weapon = net.ReadEntity()
		if not IsValid(weapon) then return end
		local status = net.ReadBool()

		if status then
			weapon:SaveAttachments()
			return
		end
		surface.PlaySound("buttons/button2.wav")

		local cat = net.ReadUInt(8)
		local ind = net.ReadString()
		weapon:SetTFAAttachment(cat, ind, false)
	end)

	local function request(self)
		if self._TFA_Attachment_Request then return end
		if not self.HasInitAttachments or self.AttachmentCount < 1 then return end
		net.Start("TFA_Attachment_Request")
		net.WriteEntity(self)
		net.SendToServer()
		self._TFA_Attachment_Request = true
	end

	hook.Add("NotifyShouldTransmit", "TFA_AttachmentsRequest", function(self, notDormant)
		if not self.IsTFAWeapon or not notDormant then return end
		request(self)
	end)

	hook.Add("NetworkEntityCreated", "TFA_AttachmentsRequest", function(self)
		timer.Simple(0, function()
			if not IsValid(self) or not self.IsTFAWeapon then return end
			request(self)
		end)
	end)

	hook.Add("OnEntityCreated", "TFA_AttachmentsRequest", function(self)
		timer.Simple(0, function()
			if not IsValid(self) or not self.IsTFAWeapon then return end
			request(self)
		end)
	end)

	local LoadQuery = [[SELECT atts FROM tfa_savedattachments WHERE class = '%s']]
	function TFA.GetSavedAttachments(Weapon)
		if not IsValid(Weapon) or not Weapon.IsTFAWeapon then return end

		local data = sql.QueryRow(string.format(LoadQuery, sql.SQLStr(Weapon:GetClass(), true)))

		if data and data.atts then
			return util.JSONToTable(data.atts)
		end
	end

	local SaveQuery = [[REPLACE INTO tfa_savedattachments (class, atts) VALUES ('%s', '%s');]]
	function TFA.SetSavedAttachments(Weapon)
		if not IsValid(Weapon) or not Weapon.IsTFAWeapon or not next(Weapon.Attachments or {}) then return end

		local seltbl = {}
		for cat, catTbl in pairs(Weapon.Attachments or {}) do
			if cat ~= "BaseClass" and catTbl.atts then
				seltbl[cat] = catTbl.atts[catTbl.sel or -1] or ""
			end
		end

		return sql.Query(string.format(SaveQuery, sql.SQLStr(Weapon:GetClass(), true), sql.SQLStr(util.TableToJSON(seltbl), true)))
	end
end

local function basefunc(t, k)
	if k == "Base" then return end

	if t.Base then
		local bt = TFA.Attachments.Atts[t.Base]
		if bt then return bt[k] end
	end
end

function TFA.Attachments.SetupBaseTable(id, path)
	local ATTACHMENT = {}

	setmetatable(ATTACHMENT, {
		__index = basefunc
	})

	ATTACHMENT.ID = id

	ProtectedCall(function()
		hook.Run("TFABase_PreBuildAttachment", id, path, ATTACHMENT)
	end)

	return ATTACHMENT
end

function TFA.Attachments.Register(id, ATTACHMENT, path)
	if istable(id) then
		ATTACHMENT = id
		id = ATTACHMENT.ID
	end

	assert(istable(ATTACHMENT), "Invalid attachment argument provided")
	assert(isstring(id), "Invalid attachment ID provided")
	local size = table.Count(ATTACHMENT)

	if size == 0 or size == 1 and ATTACHMENT.ID ~= nil then
		local id2 = id or ATTACHMENT.ID

		if id2 then
			ErrorNoHalt("[TFA Base] Attempt to register an empty attachment " .. id2 .. "\n")
		else
			ErrorNoHalt("[TFA Base] Attempt to register an empty attachment\n")
		end

		ErrorNoHalt(debug.traceback() .. "\n")
		MsgC("\n")
		return
	end

	ProtectedCall(function()
		hook.Run("TFABase_BuildAttachment", id, path, ATTACHMENT)
	end)

	ATTACHMENT.ID = ATTACHMENT.ID or id

	if ATTACHMENT.ID and ATTACHMENT.ID ~= "base" then
		ATTACHMENT.Base = ATTACHMENT.Base or "base"
	end

	--[[if not TFA_ATTACHMENT_ISUPDATING and istable(ATTACHMENT.WeaponTable) then
		TFA.MigrateStructure(ATTACHMENT, ATTACHMENT.WeaponTable, id or "<attachment>", false)
	end]]

	ProtectedCall(function()
		hook.Run("TFABase_RegisterAttachment", id, ATTACHMENT)
	end)

	TFA.Attachments.Atts[ATTACHMENT.ID or ATTACHMENT.Name] = ATTACHMENT
end

function TFA.Attachments.RegisterFromTable(id, tbl, path)
	local status

	ProtectedCall(function()
		status = hook.Run("TFABase_ShouldLoadAttachment", id, path)
	end)

	if status == false then return end

	local ATTACHMENT = TFA.Attachments.SetupBaseTable(id)

	for k, v in pairs(tbl) do
		ATTACHMENT[k] = v
	end

	TFA.Attachments.Register(id, ATTACHMENT)
end

TFARegisterAttachment = TFA.Attachments.Register
TFA.Attachments.Path = "tfa/att/"
TFA.Attachments.Path_Batch = "tfa/attbatch/"
TFA_ATTACHMENT_ISUPDATING = false

local inheritanceCached = {}
local missingBaseWarningShown = {}

local function patchInheritance(t, basetbl)
	if t.Base and t.Base ~= "base" and not TFA.Attachments.Atts[t.Base] then
		if t.ID and not missingBaseWarningShown[t.ID] then
			missingBaseWarningShown[t.ID] = true

			print("[TFA Base] [!] Attachment '" .. t.ID .. "' depends on unknown attachment '" .. t.Base .. "'!")
		end

		t.Base = "base"
	end

	if not basetbl and t.Base then
		basetbl = TFA.Attachments.Atts[t.Base]

		if basetbl and istable(basetbl) and basetbl.ID and not inheritanceCached[basetbl.ID] then
			inheritanceCached[basetbl.ID] = true
			patchInheritance(basetbl)
		end
	end

	if not (basetbl and istable(basetbl)) then return end

	for k, v in pairs(t) do
		local baseT = basetbl[k]

		if istable(v) and baseT then
			patchInheritance(v, baseT)
		end
	end

	for k, v in pairs(basetbl) do
		if rawget(t, k) == nil then
			t[k] = v
		end
	end
end

function TFAUpdateAttachments(network)
	if SERVER and network ~= false then
		net.Start("TFA_Attachment_Reload")
		net.Broadcast()
	end

	TFA.AttachmentColors = TFA.Attachments.Colors --for compatibility
	TFA.Attachments.Atts = {}
	TFA_ATTACHMENT_ISUPDATING = true
	local tbl = file.Find(TFA.Attachments.Path .. "*base*", "LUA")
	local addtbl = file.Find(TFA.Attachments.Path .. "*", "LUA")

	for _, v in ipairs(addtbl) do
		if not string.find(v, "base") then
			table.insert(tbl, #tbl + 1, v)
		end
	end

	table.sort(tbl)

	for _, fname in ipairs(tbl) do
		local path = TFA.Attachments.Path .. fname
		local id = fname:lower():Replace(".lua", "")

		local status

		ProtectedCall(function()
			status = hook.Run("TFABase_ShouldLoadAttachment", id, path)
		end)

		if status ~= false then
			ATTACHMENT = TFA.Attachments.SetupBaseTable(id, path)

			if SERVER then
				AddCSLuaFile(path)
				include(path)
			else
				include(path)
			end

			TFA.Attachments.Register(id, ATTACHMENT, path)
			ATTACHMENT = nil
		end
	end

	local tbl2 = file.Find(TFA.Attachments.Path_Batch .. "*", "LUA")

	for _, fname in ipairs(tbl2) do
		local path = TFA.Attachments.Path_Batch .. fname

		if SERVER then
			AddCSLuaFile(path)
			include(path)
		else
			include(path)
		end
	end

	ProtectedCall(function()
		hook.Run("TFAAttachmentsLoaded")
	end)

	for _, v in pairs(TFA.Attachments.Atts) do
		patchInheritance(v)

		--[[if istable(v.WeaponTable) then
			TFA.MigrateStructure(v, v.WeaponTable, v.ID or "<attachment>", false)
		end]]
	end

	ProtectedCall(function()
		hook.Run("TFAAttachmentsInitialized")
	end)

	TFA_ATTACHMENT_ISUPDATING = false

	TFA.ATTACHMENTS_LOADED = true
end

if not VLL2_FILEDEF and TFA.ATTACHMENTS_LOADED then
	TFAUpdateAttachments(false)
end

concommand.Add("sv_tfa_attachments_reload", function(ply, cmd, args, argStr)
	if SERVER and (not IsValid(ply) or ply:IsAdmin()) then
		TFAUpdateAttachments()
	end
end, function() end, "Reloads all TFA Attachments", {FCVAR_SERVER_CAN_EXECUTE})

--PATH lua/tfa/modules/tfa_ballistics.lua:
-- Degrees to accuracy vector, Valve's formula from SDK 2013
TFA.DegreesToAccuracy = math.sin((math.pi / 180) / 2) -- approx. 0.00873

--default cvar integration
local cv_gravity = GetConVar("sv_gravity")

--[[local function TimeScale(v)
	return v * game.GetTimeScale() / TFA.Ballistics.SubSteps
end]]

--init code
TFA.Ballistics = TFA.Ballistics or {}
TFA.Ballistics.Enabled = false
TFA.Ballistics.Gravity = Vector(0, 0, -cv_gravity:GetFloat())
TFA.Ballistics.Bullets = TFA.Ballistics.Bullets or {}
TFA.Ballistics.Bullets.bullet_registry = TFA.Ballistics.Bullets.bullet_registry or {}
TFA.Ballistics.BulletLife = 10
TFA.Ballistics.UnitScale = TFA.UnitScale or 39.3701 --meters to inches
TFA.Ballistics.AirResistance = 1
TFA.Ballistics.WaterResistance = 3
TFA.Ballistics.WaterEntranceResistance = 6

TFA.Ballistics.DamageVelocityLUT = {
	[13] = 350, --shotgun
	[25] = 425, --mp5k etc.
	[35] = 900, --ak-12
	[65] = 830, --SVD
	[120] = 1100 --sniper cap
}

TFA.Ballistics.VelocityMultiplier = 1
TFA.Ballistics.SubSteps = 1
TFA.Ballistics.BulletCreationNetString = "TFABallisticsBullet"

TFA.Ballistics.TracerStyles = {
	[0] = "",
	[1] = "tfa_bullet_smoke_tracer",
	[2] = "tfa_bullet_fire_tracer"
}

setmetatable(TFA.Ballistics.TracerStyles, {
	["__index"] = function(t, k) return t[math.Round(tonumber(k) or 1)] or t[1] end
})

if SERVER then
	util.AddNetworkString(TFA.Ballistics.BulletCreationNetString)
end

--bullet class
local function IncludeClass(fn)
	include("tfa/ballistics/" .. fn .. ".lua")
	AddCSLuaFile("tfa/ballistics/" .. fn .. ".lua")
end

IncludeClass("bullet")
--cvar code
local function CreateReplConVar(cvarname, cvarvalue, description, ...)
	return CreateConVar(cvarname, cvarvalue, CLIENT and {FCVAR_REPLICATED} or {FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY}, description, ...)
end -- replicated only on clients, archive/notify on server

local cv_enabled = CreateReplConVar("sv_tfa_ballistics_enabled", "0", "Enable TFA Ballistics?")
local cv_bulletlife = CreateReplConVar("sv_tfa_ballistics_bullet_life", 10, "Time to process bullets before removing.")
local cv_res_air = CreateReplConVar("sv_tfa_ballistics_bullet_damping_air", 1, "Air resistance, which makes bullets arc faster.")
local cv_res_water = CreateReplConVar("sv_tfa_ballistics_bullet_damping_water", 3, "Water resistance, which makes bullets arc faster in water.")
local cv_vel = CreateReplConVar("sv_tfa_ballistics_bullet_velocity", 1, "Global velocity multiplier for TFA ballistics bullets.")
local cv_substep = CreateReplConVar("sv_tfa_ballistics_substeps", 1, "Substeps for ballistics; more is more precise, at the cost of performance.")
local sv_tfa_ballistics_custom_gravity = CreateReplConVar("sv_tfa_ballistics_custom_gravity", 0, "Enable sv_gravity override for ballistics")
local sv_tfa_ballistics_custom_gravity_value = CreateReplConVar("sv_tfa_ballistics_custom_gravity_value", 0, "Z velocity down of custom gravity")
CreateReplConVar("sv_tfa_ballistics_mindist", -1, "Minimum distance to activate; -1 for always.")

local function updateCVars()
	TFA.Ballistics.BulletLife = cv_bulletlife:GetFloat()
	TFA.Ballistics.AirResistance = cv_res_air:GetFloat()
	TFA.Ballistics.WaterResistance = cv_res_water:GetFloat()
	TFA.Ballistics.WaterEntranceResistance = TFA.Ballistics.WaterResistance * 2
	TFA.Ballistics.VelocityMultiplier = cv_vel:GetFloat()

	if sv_tfa_ballistics_custom_gravity:GetBool() then
		TFA.Ballistics.Gravity.z = -sv_tfa_ballistics_custom_gravity_value:GetFloat()
	else
		TFA.Ballistics.Gravity.z = -cv_gravity:GetFloat()
	end

	TFA.Ballistics.Enabled = cv_enabled:GetBool()
	TFA.Ballistics.SubSteps = cv_substep:GetInt()
end

cvars.AddChangeCallback("sv_tfa_ballistics_enabled", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_bullet_life", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_bullet_damping_air", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_bullet_damping_water", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_bullet_velocity", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_substeps", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_mindist", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_custom_gravity", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_custom_gravity_value", updateCVars, "TFA")
cvars.AddChangeCallback("sv_gravity", updateCVars, "TFA Ballistics")
updateCVars()

--client cvar code
local cv_receive, cv_tracers_style, cv_tracers_mp

if CLIENT then
	cv_receive = CreateClientConVar("cl_tfa_ballistics_mp", "1", true, false, "Receive bullet data from other players?")
	CreateClientConVar("cl_tfa_ballistics_fx_bullet", "1", true, false, "Display bullet models for each TFA ballistics bullet?")
	cv_tracers_style = CreateClientConVar("cl_tfa_ballistics_fx_tracers_style", "1", true, false, "Style of tracers for TFA ballistics? 0=disable,1=smoke")
	cv_tracers_mp = CreateClientConVar("cl_tfa_ballistics_fx_tracers_mp", "1", true, false, "Enable tracers for other TFA ballistics users?")
	CreateClientConVar("cl_tfa_ballistics_fx_tracers_adv", "1", true, false, "Enable advanced tracer calculations for other users? This corrects smoke trail to their barrel")
end

--utility func
local function Remap(inp, u, v, x, y)
	return (inp - u) / (v - u) * (y - x) + x
end

--Accessors
local CopyTable = table.Copy

function TFA.Ballistics.Bullets:Add(bulletStruct, originalBulletData)
	local bullet = TFA.Ballistics:Bullet(bulletStruct)
	bullet.bul = CopyTable(originalBulletData or bullet.bul)
	bullet.last_update = CurTime() - TFA.FrameTime()

	table.insert(self.bullet_registry, bullet)

	bullet:_setup()

	if SERVER and game.GetTimeScale() > 0.99 then
		-- always update bullet since they are being added from predicted hook
		bullet:Update(CurTime())
	end
end

function TFA.Ballistics.Bullets:Update(ply)
	--local delta = TimeScale(SysTime() - (self.lastUpdate or (SysTime() - FrameTime())))
	local delta = CurTime()

	--self.lastUpdate = SysTime()
	local toremove
	local lply = CLIENT and LocalPlayer()

	for i, bullet in ipairs(self.bullet_registry) do
		if bullet.delete then
			if not toremove then
				toremove = {}
			end

			table.insert(toremove, i)
		elseif not ply and not bullet.playerOwned or CLIENT and bullet.owner ~= lply or ply == bullet.owner then
			for _ = 1, TFA.Ballistics.SubSteps do
				bullet:Update(delta)
			end
		end
	end

	if toremove then
		for i = #toremove, 1, -1 do
			table.remove(self.bullet_registry, toremove[i])
		end
	end
end

function TFA.Ballistics:AutoDetectVelocity(damage)
	local lutMin, lutMax, LUT, DMGs
	LUT = self.DamageVelocityLUT
	DMGs = table.GetKeys(LUT)
	table.sort(DMGs)

	for _, v in ipairs(DMGs) do
		if v < damage then
			lutMin = v
		elseif lutMin then
			lutMax = v
			break
		end
	end

	if not lutMax then
		lutMax = DMGs[#DMGs]
		lutMin = DMGs[#DMGs - 1]
	elseif not lutMin then
		lutMin = DMGs[1]
		lutMax = DMGs[2]
	end

	return Remap(damage, lutMin, lutMax, LUT[lutMin], LUT[lutMax])
end

function TFA.Ballistics:ShouldUse(wep)
	if not IsValid(wep) or not wep.IsTFAWeapon then
		return false
	end

	local shouldUse = wep:GetStatL("UseBallistics")

	if shouldUse == nil then
		if wep:GetStatL("TracerPCF") then
			return false
		end

		return self.Enabled
	else
		return shouldUse
	end
end

local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")

function TFA.Ballistics:FireBullets(wep, bulletStruct, angIn, bulletOverride)
	if not IsValid(wep) then return end
	if not IsValid(wep:GetOwner()) then return end

	local vel

	if bulletStruct.Velocity then
		vel = bulletStruct.Velocity
	elseif wep.GetStat and wep:GetStatL("Primary.Velocity") then
		vel = wep:GetStatL("Primary.Velocity") * TFA.Ballistics.UnitScale
	elseif wep.Primary and wep.Primary.Velocity then
		vel = wep.Primary.Velocity * TFA.Ballistics.UnitScale
	elseif wep.Velocity then
		vel = wep.Velocity * TFA.Ballistics.UnitScale
	else
		local dmg

		if wep.GetStat and wep:GetStatL("Primary.Damage") then
			dmg = wep:GetStatL("Primary.Damage")
		else
			dmg = wep.Primary.Damage or wep.Damage or 30
		end

		vel = TFA.Ballistics:AutoDetectVelocity(dmg) * TFA.Ballistics.UnitScale
	end

	vel = vel * (TFA.Ballistics.VelocityMultiplier or 1)

	local oldNum = bulletStruct.Num
	bulletStruct.Num = 1
	bulletStruct.IsBallistics = true

	local owner = wep:GetOwner()
	local isnpc = owner:IsNPC()
	local ac = bulletStruct.Spread
	local sharedRandomSeed = "Ballistics" .. CurTime()

	for i = 1, oldNum do
		local ang

		if angIn then
			ang = angIn
		else
			ang = owner:GetAimVector():Angle()

			if sv_tfa_recoil_legacy:GetBool() and not isnpc then
				ang:Add(owner:GetViewPunchAngles())
			else
				ang.p = ang.p + wep:GetViewPunchP()
				ang.y = ang.y + wep:GetViewPunchY()
			end
		end

		if not angIn then
			ang:RotateAroundAxis(ang:Up(), util.SharedRandom(sharedRandomSeed, -ac.x * 45, ac.x * 45, 0 + i))
			ang:RotateAroundAxis(ang:Right(), util.SharedRandom(sharedRandomSeed, -ac.y * 45, ac.y * 45, 1 + i))
		end

		local struct = {
			owner = owner, --used for dmginfo SetAttacker
			inflictor = wep, --used for dmginfo SetInflictor
			damage = bulletStruct.Damage, --floating point number representing inflicted damage
			force = bulletStruct.Force,
			pos = bulletOverride and bulletStruct.Src or owner:GetShootPos(), --b.Src, --vector representing current position
			velocity = (bulletOverride and bulletStruct.Dir or ang:Forward()) * vel, --b.Dir * vel, --vector representing movement velocity
			model = wep.BulletModel or bulletStruct.Model, --optional variable representing the given model
			smokeparticle = bulletStruct.SmokeParticle,
			customPosition = bulletStruct.CustomPosition or bulletOverride,
			IgnoreEntity = bulletStruct.IgnoreEntity
		}

		if CLIENT then
			if not struct.smokeparticle then
				struct.smokeparticle = TFA.Ballistics.TracerStyles[cv_tracers_style:GetInt()]
			end
		end

		self.Bullets:Add(struct, bulletStruct)

		if SERVER then
			net.Start(TFA.Ballistics.BulletCreationNetString)

			net.WriteEntity(struct.owner)
			net.WriteEntity(struct.inflictor)
			net.WriteFloat(struct.damage)
			net.WriteFloat(struct.force)
			net.WriteVector(struct.pos)

			net.WriteDouble(struct.velocity.x)
			net.WriteDouble(struct.velocity.y)
			net.WriteDouble(struct.velocity.z)

			net.WriteString(struct.model or '')
			net.WriteString(struct.smokeparticle or '')
			net.WriteBool(struct.customPosition == true)
			net.WriteEntity(struct.IgnoreEntity or NULL)

			net.WriteVector(bulletStruct.Src)
			net.WriteNormal(bulletStruct.Dir)
			net.WriteEntity(bulletStruct.Attacker)
			net.WriteVector(bulletStruct.Spread)
			net.WriteFloat(vel)

			if game.SinglePlayer() or isnpc then
				net.SendPVS(struct.pos)
			else
				net.SendOmit(owner)
			end
		end
	end
end

function TFA.Ballistics.Bullets:Render()
	for i = 1, #self.bullet_registry do
		self.bullet_registry[i]:Render()
	end
end

local sp = game.SinglePlayer()

--Netcode and Hooks
if CLIENT then
	net.Receive(TFA.Ballistics.BulletCreationNetString, function()
		if not sp and not cv_receive:GetBool() then return end

		local owner =           net.ReadEntity()
		local inflictor =       net.ReadEntity()
		local damage =          net.ReadFloat()
		local force =           net.ReadFloat()
		local pos =             net.ReadVector()
		local velocity =        Vector(net.ReadDouble(), net.ReadDouble(), net.ReadDouble())
		local model =           net.ReadString()
		local smokeparticle =   net.ReadString()
		local customPosition =  net.ReadBool()
		local IgnoreEntity =    net.ReadEntity()


		local Src =             net.ReadVector()
		local Dir =             net.ReadNormal()
		local Attacker =        net.ReadEntity()
		local Spread =          net.ReadVector()
		local Velocity =        net.ReadFloat()

		if not IsValid(owner) or not IsValid(inflictor) then return end

		if not cv_tracers_mp:GetBool() and owner ~= LocalPlayer() then
			smokeparticle = ""
		elseif smokeparticle == "" then
			smokeparticle = TFA.Ballistics.TracerStyles[cv_tracers_style:GetInt()]
		end

		local struct = {
			owner = owner,
			inflictor = inflictor,
			damage = damage,
			force = force,
			pos = pos,
			velocity = velocity,
			model = model ~= "" and model or nil,
			smokeparticle = smokeparticle,
			customPosition = customPosition,
			IgnoreEntity = IgnoreEntity,
		}

		local bulletStruct = {
			Damage = damage,
			Force = force,
			Num = 1,
			Src = Src,
			Dir = Dir,
			Attacker = Attacker,
			Spread = Spread,
			SmokeParticle = smokeparticle,
			CustomPosition = customPosition,
			Model = model ~= "" and model or nil,
			Velocity = Velocity,
			IsBallistics = true,
		}

		TFA.Ballistics.Bullets:Add(struct, bulletStruct)
	end)
end

if CLIENT then
	hook.Add("FinishMove", "TFABallisticsTick", function(self)
		if IsFirstTimePredicted() then
			TFA.Ballistics.Bullets:Update(self)
		end
	end)
else
	hook.Add("PlayerPostThink", "TFABallisticsTick", function(self)
		TFA.Ballistics.Bullets:Update(self)
	end)
end

hook.Add("Tick", "TFABallisticsTick", function()
	TFA.Ballistics.Bullets:Update()

	if CLIENT and sp then
		TFA.Ballistics.Bullets:Update(LocalPlayer())
	end
end)

--Rendering
hook.Add("PostDrawOpaqueRenderables", "TFABallisticsRender", function()
	TFA.Ballistics.Bullets:Render()
end)

--PATH lua/tfa/ballistics/bullet.lua:
local vector_origin = Vector()

--[[Bullet Struct:
[BULLET_ID] = {
	["owner"] = Entity, --used for dmginfo SetAttacker
	["inflictor"] = Entity, --used for dmginfo SetInflictor
	["damage"] = Double, --floating point number representing inflicted damage
	["force"] = Double,
	["pos"] = Vector, --vector representing current position
	["velocity"] = Vector, --vector representing movement velocity
	["model"] = String --optional variable representing the given model,
	["bul"] = {} --optional table containing bullet data,
	["smokeparticle"] = String, --smoke particle name from within pcf
	["bulletOverride"] = Bool --disable coming out of gun barrel on clientside
}
]]
local BallisticBullet = {
	["owner"] = NULL,
	["inflictor"] = NULL,
	["damage"] = 0,
	["force"] = 0,
	["pos"] = vector_origin,
	["velocity"] = vector_origin,
	["model"] = "models/bullets/w_pbullet1.mdl",
	["bul"] = {},
	["delete"] = false,
	["smokeparticle"] = "tfa_bullet_smoke_tracer"
}

local traceRes = {}

local traceData = {
	mask = MASK_SHOT,
	collisiongroup = COLLISION_GROUP_NONE,
	ignoreworld = false,
	output = traceRes
}

local MASK_SHOT_NOWATER = MASK_SHOT

--main update block
function BallisticBullet:Update(delta)
	if self.delete then return end
	self:_setup()
	if self.delete then return end

	local realdelta = (delta - self.last_update) / TFA.Ballistics.SubSteps
	self.last_update = delta

	local newPos = self:_getnewPosition(realdelta)
	newPos = self:_checkWater(realdelta, newPos)
	self:_accelerate(realdelta)
	self:_moveSafe(newPos)
end

--internal function for sanity checks, etc.
function BallisticBullet:_setup()
	self.creationTime = CurTime()

	if (not IsValid(self.owner)) or (not IsValid(self.inflictor)) then
		self:Remove()
	end

	if CurTime() > self.creationTime + TFA.Ballistics.BulletLife then
		self:Remove()
	end

	self.playerOwned = self.owner.IsPlayer and self.owner:IsPlayer()
	self.startVelocity = self.velocity:Length()
	self.startDamage = self.damage
end

function BallisticBullet:_think()
	if (not IsValid(self.owner)) or (not IsValid(self.inflictor)) then
		self:Remove()
	end

	if CurTime() > self.creationTime + TFA.Ballistics.BulletLife then
		self:Remove()
	end
end

--internal function for calculating position change
function BallisticBullet:_getnewPosition(delta)
	--verlet
	return self.pos + (self.velocity + TFA.Ballistics.Gravity * delta * 0.5) * delta
end

--internal function for handling water
function BallisticBullet:_checkWater(delta, target)
	local newPos = target
	traceData.start = self.pos
	traceData.endpos = newPos
	traceData.filter = {self.owner, self.inflictor}
	traceData.mask = MASK_WATER
	util.TraceLine(traceData)

	if traceRes.Hit and traceRes.Fraction < 1 and traceRes.Fraction > 0 and not self.Underwater then
		self.Underwater = true
		newPos = traceRes.HitPos + traceRes.Normal
		self.velocity = self.velocity / TFA.Ballistics.WaterEntranceResistance
		local fx = EffectData()
		fx:SetOrigin(newPos)
		local sc = math.sqrt(self.damage / 28) * 6
		fx:SetScale(sc)
		util.Effect("gunshotsplash", fx)
	end

	return newPos
end

--internal function for handling acceleration
local function GetWind()
	return vector_origin
end

if StormFox and StormFox.Version then
	if StormFox.Version < 2 then -- SF1
		local SF_GetNetworkData = StormFox.GetNetworkData

		function GetWind()
			local windSpeed = SF_GetNetworkData("Wind") * TFA.Ballistics.UnitScale
			local windAng = Angle(0, SF_GetNetworkData("WindAngle"), 0)

			return windSpeed * windAng:Forward():GetNormalized()
		end
	elseif StormFox.Wind then -- SF2
		local SFW_GetForce = StormFox.Wind.GetForce
		local SFW_GetYaw = StormFox.Wind.GetYaw

		function GetWind()
			local windSpeed = SFW_GetForce() * TFA.Ballistics.UnitScale
			local windAng = Angle(0, SFW_GetYaw(), 0)

			return windSpeed * windAng:Forward():GetNormalized()
		end
	end
end

function BallisticBullet:_accelerate(delta)
	local dragDensity = self.Underwater and TFA.Ballistics.WaterResistance or TFA.Ballistics.AirResistance
	local drag = -self.velocity:GetNormalized() * self.velocity:Length() * self.velocity:Length() * 0.00006 * dragDensity
	local wind = GetWind()

	if self.Underwater then
		self.velocity = self.velocity / (1 + TFA.Ballistics.WaterResistance * delta)
	end

	self.velocity = self.velocity + (TFA.Ballistics.Gravity + drag + wind) * delta
	self.damage = self.startDamage * math.sqrt(self.velocity:Length() / self.startVelocity)
end

local IsInWorld, IsInWorld2

do
	local tr = {collisiongroup = COLLISION_GROUP_WORLD}

	function IsInWorld2(pos)
		tr.start = pos
		tr.endpos = pos
		return not util.TraceLine(tr).AllSolid
	end
end

if CLIENT then
	IsInWorld = IsInWorld2
else
	IsInWorld = util.IsInWorld
end

--internal function for moving with collision test
function BallisticBullet:_moveSafe(newPos)
	if not self.tr_filter then
		if IsValid(self.IgnoreEntity) then
			self.tr_filter = {self.owner, self.inflictor, self.IgnoreEntity}
		else
			self.tr_filter = {self.owner, self.inflictor}
		end
	end

	traceData.start = self.pos
	traceData.endpos = newPos + (newPos - self.pos):GetNormalized()
	traceData.filter = self.tr_filter
	traceData.mask = MASK_SHOT_NOWATER

	--collision trace
	if self.playerOwned then
		self.owner:LagCompensation(true)
	end

	util.TraceLine(traceData)

	if self.playerOwned then
		self.owner:LagCompensation(false)
	end

	--collision check
	if traceRes.Hit and traceRes.Fraction < 1 and traceRes.Fraction > 0 then
		self:Impact(traceRes)
	elseif IsInWorld(newPos) then
		self.pos = newPos
	else
		self:Remove()
	end
end

--called when hitting something, or manually if necessary
function BallisticBullet:Impact(tr)
	self.pos = tr.HitPos
	self:Remove()

	if CLIENT and (game.SinglePlayer() or self.owner ~= LocalPlayer()) then return end

	if tr.HitSky then return end
	local vn = self.velocity:GetNormalized()

	local bul = {
		["Damage"] = self.damage,
		["Force"] = self.force,
		["Num"] = 1,
		["Src"] = self.pos - vn * 4,
		["Dir"] = vn * 8,
		["Spread"] = vector_origin,
		["IgnoreEntity"] = self.owner,
		["Attacker"] = self.owner,
		["Distance"] = 8,
		["Tracer"] = 0
	}

	setmetatable(bul, {
		["__index"] = self.bul
	})

	self.owner:FireBullets(bul)
end

--Render
--local cv_bullet_style, cv_tracers_adv
local cv_bullet_style

if CLIENT then
	CreateClientConVar("cl_tfa_ballistics_mp", "1", true, false, "Receive bullet data from other players?")
	cv_bullet_style = CreateClientConVar("cl_tfa_ballistics_fx_bullet", "1", true, false, "Display bullet models for each TFA ballistics bullet?")
	CreateClientConVar("cl_tfa_ballistics_fx_tracers_style", "1", true, false, "Style of tracers for TFA ballistics? 0=disable,1=smoke")
	CreateClientConVar("cl_tfa_ballistics_fx_tracers_mp", "1", true, false, "Enable tracers for other TFA ballistics users?")
	--cv_tracers_adv = CreateClientConVar("cl_tfa_ballistics_fx_tracers_adv", "1", true, false, "Enable advanced tracer calculations for other users? This corrects smoke trail to their barrel")
	--[[
	cv_receive = GetConVar("cl_tfa_ballistics_mp")
	cv_bullet_style = GetConVar("cl_tfa_ballistics_fx_bullet")
	cv_tracers_style = GetConVar("cl_tfa_ballistics_fx_tracers_style")
	cv_tracers_mp = GetConVar("cl_tfa_ballistics_fx_tracers_mp")
	cv_tracers_adv = GetConVar("cl_tfa_ballistics_fx_tracers_adv")
	]]
	--
end

--[[local DEFANGPOS = {
	Pos = vector_origin,
	Ang = angle_zero
}]]

function BallisticBullet:Render()
	if SERVER then return end
	if self.delete then return end

	if not self.curmodel then
		self.curmodel = ClientsideModel(self.model, RENDERGROUP_OPAQUE)
		self.curmodel:SetNoDraw(not cv_bullet_style:GetBool())
	end

	--[==[if IsValid(self.curmodel) and (cv_bullet_style:GetBool() or self.smokeparticle ~= "") then
		if self.customPosition then
			fpos = self.pos
			--fang = self.velocity:Angle()
		else
			if self.owner == GetViewEntity() or self.owner == LocalPlayer() then
				local spos, sang = self.pos, self.velocity:Angle()
				self.curmodel:SetPos(spos)
				self.curmodel:SetAngles(sang)

				if not self.vOffsetPos then
					local att

					if self.inflictor.GetMuzzleAttachment and self.inflictor:GetMuzzleAttachment() then
						att = self.inflictor:GetMuzzleAttachment()
					else
						att = self.inflictor.MuzzleAttachmentRaw or 1
					end

					if LocalPlayer():ShouldDrawLocalPlayer() then
						local npos = LocalPlayer():GetActiveWeapon():GetAttachment(att) or DEFANGPOS
						self.vOffsetPos = self.curmodel:WorldToLocal(npos.Pos)
						self.vOffsetAng = self.curmodel:WorldToLocalAngles(npos.Ang)
					else
						local npos = LocalPlayer():GetViewModel():GetAttachment(att) or DEFANGPOS
						self.vOffsetPos = self.curmodel:WorldToLocal(npos.Pos)
						self.vOffsetAng = self.curmodel:WorldToLocalAngles(npos.Ang)
					end
				end

				fpos = self.curmodel:LocalToWorld(self.vOffsetPos)
				--fang = self.curmodel:LocalToWorldAngles(self.vOffsetAng)
			elseif self.owner:IsPlayer() and cv_tracers_adv:GetBool() then
				local spos, sang = self.pos, self.velocity:Angle()
				self.curmodel:SetPos(spos)
				self.curmodel:SetAngles(sang)

				if not self.vOffsetPos then
					local npos = self.owner:GetActiveWeapon():GetAttachment(1) or DEFANGPOS
					self.vOffsetPos = self.curmodel:WorldToLocal(npos.Pos)
					self.vOffsetAng = self.curmodel:WorldToLocalAngles(npos.Ang)
				end

				fpos = self.curmodel:LocalToWorld(self.vOffsetPos)
				--fang = self.curmodel:LocalToWorldAngles(self.vOffsetAng)
			else
				fpos = self.pos
				--fang = self.velocity:Angle()
			end
		end

		--[[if cv_bullet_style:GetBool() then
			self.curmodel:SetupBones()
			self.curmodel:DrawModel()
		end]]
	end]==]

	local fpos, fang = self.pos, self.velocity:Angle()

	self.curmodel:SetPos(fpos)
	self.curmodel:SetAngles(fang)

	if self.smokeparticle ~= "" and not self.cursmoke then
		self.cursmoke = CreateParticleSystem(self.curmodel, self.smokeparticle, PATTACH_ABSORIGIN_FOLLOW, 1)
		if not self.cursmoke then return end
		self.cursmoke:StartEmission()
	elseif self.cursmoke and IsValid(self.owner) then
		self.cursmoke:SetSortOrigin(self.owner.GetShootPos and self.owner:GetShootPos() or self.owner.EyePos and self.owner:EyePos() or vector_origin)

		if self.Underwater then
			self.cursmoke:StopEmission()
			self.cursmoke = nil
			self.smokeparticle = ""
		end
	end
end

function BallisticBullet:Remove()
	if self.cursmoke then
		self.cursmoke:StopEmission()
		self.cursmoke = nil
	end

	if self.curmodel and self.curmodel.Remove then
		self.curmodel:Remove()
		self.curmodel = nil
	end

	self.delete = true
end

local CopyTable = table.Copy

function TFA.Ballistics:Bullet(t)
	local b = CopyTable(t or {})

	setmetatable(b, {
		["__index"] = BallisticBullet
	})

	return b
end
--PATH lua/tfa/modules/tfa_small_entities.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_changelog.lua:
local changes = TFA_BASE_VERSION_CHANGES or ""
local cvar_changelog = GetConVar("sv_tfa_changelog")

local sp = game.SinglePlayer()
local pdatavar = "tfa_base_version_" .. util.CRC(game.GetIPAddress())

local function CheckAndDisplayChangeLog(ply)
	if not IsValid(ply) then return end

	if not cvar_changelog:GetBool() then return end

	if not sp or not ply:IsAdmin() then return end

	local version = tonumber(ply:GetPData(pdatavar))

	if not version or version < TFA_BASE_VERSION then
		chat.AddText("Updated to TFA Base Version: " .. TFA_BASE_VERSION_STRING)

		if changes ~= "" then
			chat.AddText(changes)
		end
	end

	ply:SetPData(pdatavar, TFA_BASE_VERSION)
end

hook.Add("HUDPaint", "TFA_DISPLAY_CHANGELOG", function()
	if not LocalPlayer():IsValid() then return end

	CheckAndDisplayChangeLog(LocalPlayer())

	hook.Remove("HUDPaint", "TFA_DISPLAY_CHANGELOG")
end)

--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1, band(rshift(state, 28), 1) == 0 and 0 or 1		end
	
--PATH lua/tfa/modules/cl_tfa_rendertarget.lua:
TFA.DrawingRenderTarget = false

local props = {
	["$translucent"] = 1
}

local TFA_RTMat = CreateMaterial("tfa_rtmaterial", "UnLitGeneric", props) --Material("models/weapons/TFA/shared/optic")
local TFA_RTScreen, TFA_RTScreenO = {}, {}
local tgt
local old_bt
local ply, vm, wep
local w, h
local qualitySizes

local function callFunc()
	if wep.RTCode then
		wep:RTCode(TFA_RTMat, w, h)
	end

	if wep:GetStatL("RTDrawEnabled") then
		wep:CallAttFunc("RTCode", TFA_RTMat, w, h)
	end
end

hook.Add("OnScreenSizeChanged", "TFA_rendertargets", function()
	qualitySizes = nil
	TFA_RTScreen, TFA_RTScreenO = {}, {}
end)

local function TFARenderScreen()
	ply = GetViewEntity()

	if not IsValid(ply) or not ply:IsPlayer() then
		ply = LocalPlayer()

		return
	end

	wep = ply:GetActiveWeapon()
	if not IsValid(wep) or not wep.IsTFAWeapon then return end

	if not IsValid(vm) then
		if not wep:VMIV() then return end

		vm = wep.OwnerViewModel
	end

	if not wep.MaterialCached then
		wep.MaterialCached = true
		wep.MaterialCached_V = nil
		wep.MaterialCached_W = nil
	end

	local skinStat = wep:GetStatL("Skin")
	if isnumber(skinStat) then
		if vm:GetSkin() ~= skinStat then
			vm:SetSkin(skinStat)
		end
	end

	if wep:GetStatL("MaterialTable_V") and not wep.MaterialCached_V then
		wep.MaterialCached_V = {}
		vm:SetSubMaterial()
		local collectedKeys = table.GetKeys(wep:GetStatL("MaterialTable_V"))
		table.Merge(collectedKeys, table.GetKeys(wep:GetStatL("MaterialTable")))

		for _, k in pairs(collectedKeys) do
			if k ~= "BaseClass" then
				local v = wep:GetStatL("MaterialTable_V")[k]

				if not wep.MaterialCached_V[k] then
					vm:SetSubMaterial(k - 1, v)
					wep.MaterialCached_V[k] = true
				end
			end
		end
	end

	if not (wep:GetStatL("RTDrawEnabled") or wep.RTCode ~= nil) then return end
	w, h = ScrW(), ScrH()

	if not qualitySizes then
		qualitySizes = {
			[0] = h,
			[1] = math.Round(h * 0.5),
			[2] = math.Round(h * 0.25),
			[3] = math.Round(h * 0.125),
		}
	end

	local quality = TFA.RTQuality()

	if wep:GetStatL("RTOpaque") then
		tgt = TFA_RTScreenO[quality]

		if not tgt then
			local size = qualitySizes[quality] or qualitySizes[0]
			tgt = GetRenderTargetEx("TFA_RT_ScreenO_" .. size, size, size, RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_SHARED, 0, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGB888)
			TFA_RTScreenO[quality] = tgt
		end
	else
		tgt = TFA_RTScreen[quality]

		if not tgt then
			local size = qualitySizes[quality] or qualitySizes[0]
			tgt = GetRenderTargetEx("TFA_RT_Screen_" .. size, size, size, RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_SHARED, 0, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGBA8888)
			TFA_RTScreen[quality] = tgt
		end
	end

	TFA.LastRTUpdate = CurTime() + 0.01

	render.PushRenderTarget(tgt)
	render.Clear(0, 0, 0, 255, true, true)

	TFA.DrawingRenderTarget = true
	render.CullMode(MATERIAL_CULLMODE_CCW)
	ProtectedCall(callFunc)
	TFA.DrawingRenderTarget = false

	render.SetScissorRect(0, 0, 0, 0, false)
	render.PopRenderTarget()

	if old_bt ~= tgt then
		TFA_RTMat:SetTexture("$basetexture", tgt)
		old_bt = tgt
	end

	if wep:GetStatL("RTMaterialOverride", -1) >= 0 then
		vm:SetSubMaterial(wep:GetStatL("RTMaterialOverride"), "!tfa_rtmaterial")
	end
end

hook.Remove("PostRender", "TFASCREENS")

hook.Add("PreRender", "TFASCREENS", function()
	if not TFA.RT_DRAWING then
		TFA.RT_DRAWING = true
		TFARenderScreen()
		TFA.RT_DRAWING = false
	end
end)

TFA.RT_DRAWING = false

--PATH lua/tfa/modules/cl_tfa_rtbgblur.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_stencilsights.lua:
return gluapack()()
--PATH lua/tfa/att/blue_stun.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Blue Tibanna Stun Cartridges"
ATTACHMENT.ShortName = "BTSGC" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
TFA.AttachmentColors["="],"Stun ammo. Uses the same unique ammo as the explosive and assination types.",
TFA.AttachmentColors["-"],"%50 increase to Clip Size",
TFA.AttachmentColors["-"],"",
}
ATTACHMENT.Icon = "entities/tfa_ammo_fragshell.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"
ATTACHMENT.Damage = 8

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["Damage"] = 8,
		["ClipSize"] = 50,
		["DefaultClip"] = 50,
		["RPM"] = 200,
		["RPM_Burst"] = function( wep, val) return val * 0.75 end,
		["Spread"] = function( wep, val) return val * 2 end,
		["IronAccuracy"] = function( wep, val) return val * 10 end,
		["Force "] = 500,
		["AmmoConsumption"] = 5,
		["Ammo"] = "RPG_Round",
		["Sound"] = "weapons/bf3/e11_light.wav"
	},
	["MoveSpeed"] = 1.05,
	["TracerName"] = "effect_sw_laser_blue_stun",
	["CustomBulletCallback"] = function(a,b,c)
	TFA_RP_MeltEasy(a,b,c,8,"BGOLightning")
end
}



if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--PATH lua/autorun/tfa_comm_sw_yodamundi.lua:
return gluapack()()
--PATH lua/autorun/tfres_tscp.lua:
tfres = tfres or {}
tfres.Global = tfres.Global or {}

local rootDirectory = "tfres"
local function startload()
print([[
========================================================
_____ __              _                 _ _           
|_   _/ _|_ _ ___ ___ | |   ___  __ _ __| (_)_ _  __ _ 
  | ||  _| '_/ -_|_-< | |__/ _ \/ _` / _` | | ' \/ _` |
  |_||_| |_| \___/__/ |____\___/\__,_\__,_|_|_||_\__, |
                                                 |___/ 
========================================================
]])
end 

local filesc = 0
local function AddFile(File, directory)
    local prefix = string.lower(string.Left(File, 3))
    filesc = filesc + 1
    if SERVER and prefix == "sv_" then
        include(directory .. File)
    elseif prefix == "sh_" then
        if SERVER then
            AddCSLuaFile(directory .. File)
        end

        include(directory .. File)
    elseif prefix == "cl_" then
        if SERVER then
            AddCSLuaFile(directory .. File)
        elseif CLIENT then
            include(directory .. File)
        end
    elseif file ~= "config.lua" then
        if SERVER then
            AddCSLuaFile(directory .. File)
        end

        include(directory .. File)
    end
    if string.find(directory:lower(),"weapons") then
        if not SWEP then return end
        weapons.Register(SWEP, SWEP.ClassName or file)
    end
end

local function IncludeDir(directory)
    directory = directory .. "/"
    local files, directories = file.Find(directory .. "*", "LUA")

    for _, v in ipairs(files) do
        if string.StartsWith(v, "sv_") then
            AddFile(v, directory)
        end
    end

    for _, v in ipairs(directories) do
        if directory == rootDirectory .. "/" then
            print("Wczytywanie [" .. v .. "]")
        end
        IncludeDir(directory .. v)
    end
end

local function IncludeCir(directory)
    directory = directory .. "/"
    local files, directories = file.Find(directory .. "*", "LUA")

    for _, v in ipairs(files) do
        if string.EndsWith(v, "_lib.lua") then
            AddFile(v, directory)
        end
    end

    for _, v in ipairs(directories) do
        IncludeCir(directory .. v)
    end
end

local function IncludeCLir(directory)
    directory = directory .. "/"
    local files, directories = file.Find(directory .. "*", "LUA")
    
    for _, v in ipairs(files) do
        if !string.StartsWith(v, "sv_") then
            AddFile(v, directory)
        end
    end
    print(directory)
    for _, v in ipairs(directories) do
        print(directory .. "/" .. v)
        IncludeCLir(directory .. v)
    end
end

local function tfresLoad()
    if MRBEAST then
        MRBEAST()
    end
    if startload then
        startload()
    end
    print("[Tfres] Wczytywanie plikw")
        print("CONFIGI")
        IncludeCir(rootDirectory)
        print("CLIENT")
        IncludeCLir(rootDirectory)
    print("[Tfres] Zakoczono wczytywanie", "Plikw: " .. filesc)
    FMAIN = FMAIN or {}
end

local function tfresLoadSV()
    print("[Tfres] Wczytywanie plikw")
        print("SERVER")
        filesc = 0
        IncludeDir(rootDirectory)
    print("[Tfres] Zakoczono wczytywanie", "Plikw: " .. filesc)
end

hook.Add("InitPostEntity","tfres_ClientLoaded",function()
    if CLIENT then
        hook.Run("tfres_Loaded")
    end
end)

hook.Add("tfres_Loaded","ConsolePrint",function()
    print("[Tfres] Loaded All scripts")
end)

hook.Add("Initialize", "tfres_loader", function()
    tfresLoad()
    if SERVER then
        if game.GetIPAddress() == nil or string.find(tostring(game.GetIPAddress()),"0.0.0.0:") then
            print("[Tfres] Waiting for valid IP")
            timer.Create("Tfres_waitingip",5,0,function()
                if game.SinglePlayer() then
                    tfresLoadSV()
                    timer.Remove("Tfres_waitingip")
                    hook.Run("tfres_Loaded")
                    print("[Tfres] Loading SinglePlayer. Not all addons can work")
                    
                    return
                end
                if game.GetIPAddress() == nil or string.find(tostring(game.GetIPAddress()),"0.0.0.0:") then return end
                tfresLoadSV()
                if game.IsDedicated() and util.IsBinaryModuleInstalled("fdrm") then
                    require("fdrm")
                else
                    print("[Tfres] No DRM installed")
                end
                timer.Remove("Tfres_waitingip")
                hook.Run("tfres_Loaded")
            end)
        else
            print("[Tfres] Valid IP no waiting")
            timer.Create("Tfres_waitingip",10,1,function()
                tfresLoadSV()
                if game.IsDedicated() and util.IsBinaryModuleInstalled("fdrm") then
                    require("fdrm")
                else
                    print("[Tfres] No DRM installed")
                end
                hook.Run("tfres_Loaded")
            end)
        end
    end
    
end)
--PATH lua/autorun/turret_stopfire.lua:
if SERVER then
	AddCSLuaFile()
	util.AddNetworkString("TurretBlockAttackToggle")

elseif CLIENT then
	local shouldBlockAttack = false
	net.Receive("TurretBlockAttackToggle",function()
		local blockBit = net.ReadBit()
		if blockBit == 1 then
			shouldBlockAttack = true
		elseif blockBit == 0 then
			shouldBlockAttack = false
		end
	end)

	hook.Add("CreateMove","RedirectTurretAttack",function(cmd)
		local lp = LocalPlayer()
		if shouldBlockAttack and IsValid(lp) and bit.band(cmd:GetButtons(), IN_ATTACK) > 0 then
			cmd:SetButtons(bit.bor(cmd:GetButtons() - IN_ATTACK, IN_BULLRUSH))
		end
	end)
end
--PATH lua/autorun/venator_border_toggle.lua:
// Created by Airfox aka. Konsti
// Huge thanks to him!

if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end

local nextTick = nextTick or 0
local material = Material("kingpommes/map_borders/red_opacity3")
local defaultTexture = "kingpommes/map_borders/red_opacity3"
local invisibleTexture = "kingpommes/starwars/venator/invis"
local borderVisible = true
material:SetTexture("$basetexture", defaultTexture)

if SERVER then
	util.AddNetworkString("Venator_Ext_BorderNet")

	-- Networks current state to every new player that joins the server.
	hook.Add("PlayerInitialSpawn", "Venator_Ext_BorderConnectSync", function(ply)
		net.Start("Venator_Ext_BorderNet")
			net.WriteBool(borderVisible)
		net.Send(ply)
	end)
end

hook.Add("Think", "Venator_Ext_BorderThink", function()
	if nextTick > CurTime() then return end

	nextTick = CurTime() + 1
	
	if SERVER then
		-- Finds all entities with this name.
		local entities = ents.FindByName("border_target")

		-- Checks if an entity has been found and alarm is on. Also if the network has already been sent.
		if #entities >= 1 and borderVisible then
			borderVisible = false
			net.Start("Venator_Ext_BorderNet")
				net.WriteBool(borderVisible)
			net.Broadcast()
			
			if material:GetTexture("$basetexture"):GetName() == defaultTexture then
				material:SetTexture("$basetexture", invisibleTexture)
			end
		elseif #entities == 0 and not borderVisible then
			borderVisible = true
			net.Start("Venator_Ext_BorderNet")
				net.WriteBool(borderVisible)
			net.Broadcast()

			if material:GetTexture("$basetexture"):GetName() == invisibleTexture then
				material:SetTexture("$basetexture", defaultTexture)
			end
		end
	elseif CLIENT then
		-- Checks if alarm is on. 
		if not borderVisible then
			-- Changes between textured.
			if material:GetTexture("$basetexture"):GetName() == defaultTexture then
				material:SetTexture("$basetexture", invisibleTexture)
			end
		else
			-- Resets the texture to default, when the border should be visible.
			if material:GetTexture("$basetexture"):GetName() == invisibleTexture then
				material:SetTexture("$basetexture", defaultTexture)
			end
		end
	end
end)

if CLIENT then
	-- Receives current state.
	net.Receive("Venator_Ext_BorderNet", function(len)
		borderVisible = net.ReadBool()
	end)
end
--PATH lua/autorun/vj_controls.lua:
/*--------------------------------------------------
	=============== VJ Controls ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ VJ Spawnmenu Controls ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local killIconColor = Color(255, 80, 0, 255)

if !VJ then VJ = {} end -- If VJ isn't initialized, initialize it!

-- Variables ----------------------------------------------------------------------------------------------------
if !VJ.Plugins then VJ.Plugins = {} end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers the addon to the VJ plugin list
		- name = Addon name
		- type = Type of addon | EX: NPC, Weapon, etc.
-----------------------------------------------------------]]
VJ.AddAddonProperty = function(name, type)
	table.insert(VJ.Plugins, {Name = name, Type = type})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers spawn menu category information
		- name = Category name
		- options = Table that holds all possible options
			- Icon = Category icon
-----------------------------------------------------------]]
VJ.AddCategoryInfo = function(category, options)
	list.Set("VJBASE_CATEGORY_INFO", category, {
		icon = options.Icon or "icon16/monkey.png",
	})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC = function(name, class, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a human NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- weapons = Default weapon list for this NPC
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC_HUMAN = function(name, class, weapons, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Weapons = weapons, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the NPC weapon override list
		- name = Weapon's name
		- class = Weapon's class
		- category = The category group it should be in
-----------------------------------------------------------]]
VJ.AddNPCWeapon = function(name, class, category)
	local property = {title = name, class = class, category = category or "VJ Base"}
	list.Add("NPCUsableWeapons", property)
	list.Add("VJBASE_SPAWNABLE_NPC_WEAPON", property)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the weapon spawn list
		- name = Weapon's name
		- class = Weapon's class
		- adminOnly = Is this an admin only weapon?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddWeapon = function(name, class, adminOnly, category, customFunc)
	local property = {PrintName = name, ClassName = class, Category = category, AdminOnly = adminOnly, Spawnable = true}
	if (customFunc) then customFunc(property) end
	list.Set("Weapon", class, property)
	list.Set("VJBASE_SPAWNABLE_WEAPON", class, property)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an entity to the weapon spawn list
		- name = Entity's name
		- class = Entity's class
		- author = Author's name
		- adminOnly = Is this an admin only entity?
		- offset = Spawn offset
		- dropToFloor = Should it drop to the floor on spawn?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddEntity = function(name, class, author, adminOnly, offset, dropToFloor, category, customFunc)
	local Ent = {PrintName = name, ClassName = class, Author = author, AdminOnly = adminOnly, NormalOffset = offset, DropToFloor = dropToFloor, Category = category, Spawnable = true}
	if (customFunc) then customFunc(Ent) end
	list.Set("SpawnableEntities", class, Ent)
	list.Set("VJBASE_SPAWNABLE_ENTITIES", class, Ent)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds and registers a particle file
		- fileName = Addon name | EX: "particles/explosion.pcf"
		- particleList = List of particles to precache from the given particle file
-----------------------------------------------------------]]
VJ.AddParticle = function(fileName, particleList)
	game.AddParticles(fileName)
	for _, name in ipairs(particleList) do
		PrecacheParticleSystem(name)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a ConVar
		- name = Convar name
		- defValue = Default value
		- flags = Convar's flags | Can be a bitflag or a table | Flag List: https://wiki.facepunch.com/gmod/Enums/FCVAR
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddConVar = function(name, defValue, flags, helpText, min, max)
	if !ConVarExists(name) then
		CreateConVar(name, defValue, flags or FCVAR_NONE, helpText or "", min, max)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a client ConVar
		- name = ConVar name
		- defValue = Default value
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddClientConVar = function(name, defValue, helpText, min, max)
	if !ConVarExists(name) then
		CreateClientConVar(name, defValue, true, true, helpText or "", min, max)
	end
end

/*
if CLIENT then
local gmod_npcweapon = CreateConVar("gmod_npcweapon","",{FCVAR_ARCHIVE})
spawnmenu.AddContentType( "vjbase_npc", function( container, obj )
	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end
	if ( !obj.weapon ) then obj.weapon = { "" } end
	local icon = vgui.Create( "ContentIcon", container )
		icon:SetContentType( "vjbase_npc" )
		icon:SetSpawnName( obj.spawnname )
		icon:SetName( obj.nicename )
		icon:SetMaterial( obj.material )
		icon:SetAdminOnly( obj.admin )
		icon:SetNPCWeapon( obj.weapon )
		icon:SetColor(Color(244,164,96,255))
		icon.DoClick = function() 
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			RunConsoleCommand( "vjbase_spawnnpc", obj.spawnname, weapon ) 
			surface.PlaySound( "ui/buttonclickrelease.wav" )
		end
		icon.OpenMenu = function( icon ) 
			local menu = DermaMenu()
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			menu:AddOption( "Copy to Clipboard", function() SetClipboardText( obj.spawnname ) end )
			menu:AddOption( "Spawn Using Toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "2" ) RunConsoleCommand( "creator_name", obj.spawnname ) RunConsoleCommand( "creator_arg", weapon ) end )
			menu:AddSpacer()
			menu:AddOption( "Delete", function() icon:Remove() hook.Run( "SpawnlistContentChanged", icon ) end )
			menu:Open()
		end
	if (IsValid(container)) then
		container:Add(icon)
	end
	return icon
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseWeapons","AddVJBaseSpawnMenu_weapon",function(pnlContent,tree,node)
	local weapontree = tree:AddNode("Weapons", "icon16/gun.png")
	local Weapons = list.Get("VJBASE_SPAWNABLE_WEAPON")  -- Get a list of available Weapons
	local WeaponCatagory = {}
	for k, weapon in pairs( Weapons ) do
		if ( !weapon.Spawnable ) then continue end
		WeaponCatagory[ weapon.Category ] = WeaponCatagory[ weapon.Category ] or {}
		table.insert( WeaponCatagory[ weapon.Category ], weapon )
	end
	Weapons = nil
	for CategoryName, v in SortedPairs(WeaponCatagory) do -- Create an icon for each one and put them on the panel
		local node = weapontree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= "entities/"..ent.ClassName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	weapontree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseEntities","AddVJBaseSpawnMenu_Entity",function(pnlContent,tree,node)
	local entitytree = tree:AddNode("Entities", "icon16/bricks.png")
	local EntitiesCategories = {}
	local EntitiesList = list.Get("VJBASE_SPAWNABLE_ENTITIES") -- Get a list of available Entities
	if (EntitiesList) then
		for k, v in pairs(EntitiesList) do
			v.SpawnName = k
			v.Category = v.Category or "Other"
			EntitiesCategories[ v.Category ] = EntitiesCategories[ v.Category ] or {}
			table.insert( EntitiesCategories[ v.Category ], v )
		end
	end
	for CategoryName, v in SortedPairs(EntitiesCategories) do -- Create an icon for each one and put them on the panel
		local node = entitytree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= "entities/"..ent.SpawnName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	entitytree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseNPC","AddVJBaseSpawnMenu_NPC",function(pnlContent,tree,node)
	local npctree = tree:AddNode("NPCs", "icon16/monkey.png")
	local NPCList = list.Get("VJBASE_SPAWNABLE_NPC") -- Get a list of available NPCs
	local NPCCategories = {} -- Categorize them
	for k, v in pairs(NPCList) do
		local Category = v.Category or "Other"
		local Tab = NPCCategories[Category] or {}
		Tab[ k ] = v
		NPCCategories[Category] = Tab
	end
	for CategoryName, v in SortedPairs(NPCCategories) do -- Create an icon for each one and put them on the panel
		local node = npctree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for name, ent in SortedPairsByMemberValue( v, "Name" ) do
				spawnmenu.CreateContentIcon( "vjbase_npc", self.PropPanel, 
				{ 
					nicename	= ent.Name or name,
					spawnname	= name,
					material	= "entities/"..name..".png",
					weapon		= ent.Weapons,
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel(self.PropPanel)
		end	
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if (IsValid(FirstNode)) then
		//FirstNode:InternalDoClick()
	//end
	npctree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
spawnmenu.AddCreationTab("VJ Base",function()
	local ctrl = vgui.Create("SpawnmenuContentPanel")
	ctrl:CallPopulateHook("PopulateVJBaseWeapons")
	ctrl:CallPopulateHook("PopulateVJBaseEntities")
	ctrl:CallPopulateHook("PopulateVJBaseNPC")
	return ctrl
end, "icon16/plugin.png", 60 )
*/
--PATH lua/autorun/vj_files_language.lua:
return gluapack()()
--PATH lua/autorun/vj_controls.lua:
return gluapack()()
--PATH lua/autorun/vj_sbd_autorun.lua:
/*--------------------------------------------------
	=============== Autorun File ===============
	*** Copyright (c) 2012-2018 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
------------------ Addon Information ------------------
local PublicAddonName = "[VJ] Hard Contact Era"
local AddonName = "HC SNPCs"
local AddonType = "SNPC"
local AutorunFile = "autorun/vj_wotw_autorun.lua"
-------------------------------------------------------
local VJExists = file.Exists("lua/autorun/vj_base_autorun.lua","GAME")
if VJExists == true then
	include('autorun/vj_controls.lua')

	local vCat = "[HC] SBD" -- Category, you can also set a category individually by replacing the vCat with a string value

	VJ.AddNPC("SBD [Normal]","npc_vj_sbdnew",vCat)

	VJ.AddNPC("SBD [Wounded]","npc_vj_sbdnew_wounded",vCat)

	VJ.AddNPC("SBD [Crowling]","npc_vj_sbdnew_crowl",vCat)




-- !!!!!! DON'T TOUCH ANYTHING BELOW THIS !!!!!! -------------------------------------------------------------------------------------------------------------------------
	AddCSLuaFile(AutorunFile)
	VJ.AddAddonProperty(AddonName,AddonType)
else
	if (CLIENT) then
		chat.AddText(Color(0,200,200),PublicAddonName,
		Color(0,255,0)," was unable to install, you are missing ",
		Color(255,100,0),"VJ Base!")
	end
	timer.Simple(1,function()
		if not VJF then
			if (CLIENT) then
				VJF = vgui.Create("DFrame")
				VJF:SetTitle("ERROR!")
				VJF:SetSize(790,560)
				VJF:SetPos((ScrW()-VJF:GetWide())/2,(ScrH()-VJF:GetTall())/2)
				VJF:MakePopup()
				VJF.Paint = function()
					draw.RoundedBox(8,0,0,VJF:GetWide(),VJF:GetTall(),Color(200,0,0,150))
				end
				
				local VJURL = vgui.Create("DHTML",VJF)
				VJURL:SetPos(VJF:GetWide()*0.005, VJF:GetTall()*0.03)
				VJURL:Dock(FILL)
				VJURL:SetAllowLua(true)
				VJURL:OpenURL("https://sites.google.com/site/vrejgaming/vjbasemissing")
			elseif (SERVER) then
				timer.Create("VJBASEMissing",5,0,function() print("VJ Base is Missing! Download it from the workshop!") end)
			end
		end
	end)
end
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/loader/loader.lua:

--[[-------------------------------------------------------------------

	wiltOS Animation Register:

		A simple register to keep track of all wiltOS extensions installed

			Powered by

						  _ _ _    ___  ____  

				__      _(_) | |_ / _ \/ ___| 

				\ \ /\ / / | | __| | | \___ \ 

				 \ V  V /| | | |_| |_| |___) |

				  \_/\_/ |_|_|\__|\___/|____/ 

											  

 _____         _                 _             _           

|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 

  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|

  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \

  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/

                                         |___/             

-------------------------------------------------------------------]]--[[

							  

	Lua Developer: King David

	Contact: http://steamcommunity.com/groups/wiltostech

		

----------------------------------------]]--



wOS = wOS or {}

wOS.AnimExtension = wOS.AnimExtension or {}

wOS.AnimExtension.Mounted = wOS.AnimExtension.Mounted or {}



local string = string

local file = file



local function _AddCSLuaFile( lua )



	if SERVER then

		AddCSLuaFile( lua )

	end

	

end



local function _include( load_type, lua )



	if load_type then

		include( lua )

	end

	

end



function wOS.AnimExtension:Autoloader()

	

	for _,source in pairs( file.Find( "wos/anim_extension/extensions/*", "LUA"), true ) do

		local lua = "wos/anim_extension/extensions/" .. source

		_AddCSLuaFile( lua )

		_include( SERVER, lua )

		_include( CLIENT, lua )

	end

	

	_AddCSLuaFile( "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )

	_include( CLIENT, "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )

	

	_AddCSLuaFile( "wos/anim_extension/core/sh_metatable.lua" )

	_include( SERVER, "wos/anim_extension/core/sh_metatable.lua" )

	_include( CLIENT, "wos/anim_extension/core/sh_metatable.lua" )

	

	_AddCSLuaFile( "wos/anim_extension/core/sh_holdtypes.lua" )

	_include( SERVER, "wos/anim_extension/core/sh_holdtypes.lua" )

	_include( CLIENT, "wos/anim_extension/core/sh_holdtypes.lua" )



	_AddCSLuaFile( "wos/anim_extension/core/sh_prone_support.lua" )

	_include( SERVER, "wos/anim_extension/core/sh_prone_support.lua" )

	_include( CLIENT, "wos/anim_extension/core/sh_prone_support.lua" )

	

	for _,source in pairs( file.Find( "wos/anim_extension/holdtypes/*", "LUA"), true ) do

		local lua = "wos/anim_extension/holdtypes/" .. source

		_AddCSLuaFile( lua )

		_include( SERVER, lua )

		_include( CLIENT, lua )

	end

	

end



wOS.AnimExtension:Autoloader()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/extensions/wos_base.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Base" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted wiltOS Animation Base\n" )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/extensions/wos_bs.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_exp.lua:
return gluapack()()
--PATH lua/wos/anim_extension/extensions/wos_prone.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/a_combo2.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "a_combo2"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "pose_ducking_01"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_fist"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "a_combo2" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "a_combo2" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/agresif.lua:
local DATA = {}
DATA.Name = "TEST"
DATA.HoldType = "wos_agresif_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "run_knife", Weight = -10 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "walk_knife", Weight = -100 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_r_run", Weight = -10 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "phalanx_r_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/basit_melee.lua:
local DATA = {}
DATA.Name = "TEST"
DATA.HoldType = "wos_test_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "run_melee", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "run_melee", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "run_melee", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "idle_melee", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/defensive.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/dynamic.lua:
local DATA = {}
DATA.Name = "Dynamic"
DATA.HoldType = "wos_dynamic_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "walk_knife", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "wos_judge_h_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH lua/wos/anim_extension/holdtypes/g_combo4.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo4"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo4" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo4" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/greater_melee.lua:
local DATA = {}
DATA.Name = "TEST"
DATA.HoldType = "wos-test-type"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "b_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "balanced_jump", Weight = 1 },
}


wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/versalite.lua:

local DATA = {}
DATA.Name = "[LSCS] HoldType Juggernaut"
DATA.HoldType = "wos_versalite_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "walk_knife", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "vanguard_h_run", Weight = -3 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "vanguard_f_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH lua/wos/dynabase/core/cl_local_copy.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}

function wOS.DynaBase:CreateUserMount( data )
	if not data then return end
	if not data.Name then return end
	self.UserMounts[ data.Name ] = data
	
	local mounts = file.Read( "wos/dynabase/usermounts/mounts.txt", "DATA" ) or "{}"
	local local_mounts = util.JSONToTable( mounts )

	local_mounts[ data.Name ] = data
	local_mounts = util.TableToJSON( local_mounts )
	file.Write( "wos/dynabase/usermounts/mounts.txt", local_mounts )
end

function wOS.DynaBase:DeleteUserMount( name )
	if not name then return end
	if not self.UserMounts[ name ] then return end
    self.UserMounts[ name ] = nil

	local mounts = file.Read( "wos/dynabase/usermounts/mounts.txt", "DATA" ) or "{}"
	local local_mounts = util.JSONToTable( mounts )
	local_mounts[ name ] = nil

	local_mounts = util.TableToJSON( local_mounts )
	file.Write( "wos/dynabase/usermounts/mounts.txt", local_mounts )
end

function wOS.DynaBase:GetAllUserMounts()
	return self.UserMounts
end

function wOS.DynaBase:GetUserMount( name )
	return self.UserMounts[ name ] 
end

function wOS.DynaBase:CreateLocalMenu( parent, old_data )
    old_data = old_data or {}
    local w, h = parent:GetSize()

    local frame = vgui.Create( "DFrame", parent )
    frame:SetSize( w*0.5, h*0.4 )
    frame:Center()
    frame:MakePopup()
    frame:SetTitle( "Create User Mount" )
    frame.OnClose = function()
        parent:Remove()
    end
    frame.OldThink = frame.Think
    frame.Think = function( pan )
        pan:OldThink()
        if parent:HasFocus() then pan:MoveToFront() end
        if not self.AnimMenu then parent:Remove() end 
    end

    local fw, fh = frame:GetSize()

    local addon_list = vgui.Create( "DListView", frame )
    addon_list:SetWide( fw*0.3 )
    addon_list:Dock( LEFT )
    addon_list:SetMultiSelect( false )
    addon_list:AddColumn( "Addon Name" )

    local row = addon_list:AddLine( "Base Game" )
    row.title = "GAME"

    for _, addon in ipairs( engine.GetAddons() ) do
        if not addon.downloaded then continue end
        if not addon.mounted then continue end
        local row = addon_list:AddLine( addon.title )
    end

    local browser = vgui.Create( "DFileBrowser", frame )
    browser:SetTall( fh )
    browser:SetWide( fw*0.4 )
    browser:Dock( LEFT )
    browser:SetPath( "GAME" )
    browser:SetBaseFolder( "models" )
    browser:SetFileTypes( "*.mdl" )
    browser:SetOpen( true )

    addon_list.OnRowSelected = function( pan, i, row )
        browser:SetPath( row.title or row:GetColumnText(1) )
        browser:SetBaseFolder( "models" )
        browser:SetOpen( true )
    end

    local div = vgui.Create( "DPanel", frame )
    div:SetBackgroundColor( Color( 0, 0, 0 ) )
    div:SetWide( fw*0.01 )
    div:Dock( LEFT )

    local creation_frame = vgui.Create( "DPanel", frame )
    creation_frame:SetWide( fw*0.29 )
    creation_frame:SetBackgroundColor( Color( 130, 130, 130 ) )
    creation_frame:Dock( LEFT )
    creation_frame:DockPadding( fw*0.005, 0, fw*0.01, 0 )

    local cw, ch = creation_frame:GetSize()

    local name_lab =  vgui.Create( "DLabel", creation_frame )
    name_lab:SetTextColor( color_white )
    name_lab:SetFont( "wOS.DynaBase.DescFont" )
    name_lab:SetText( "Name of User Mount" )
    name_lab:Dock( TOP )
    name_lab.DefaultCol = name_lab:GetColor()

    local name_ent = vgui.Create( "DTextEntry", creation_frame )
    name_ent:Dock( TOP )
    name_ent:SetFont( "DermaDefaultBold" )
    name_ent:SetText( old_data.Name or "" )
    name_ent:SetPlaceholderText( "Enter name of mount" )
    name_ent:DockMargin( fw*0.01, 0, 0, 0 )
    name_ent.OnGetFocus = function(pan)
        name_lab:SetTextColor( name_lab.DefaultCol )
    end

    local name =  vgui.Create( "DLabel", creation_frame )
    name:SetTextColor( color_white )
    name:SetFont( "wOS.DynaBase.DescFont" )
    name:SetText( "Shared Mounting Model" )
    name:Dock( TOP )
    name:DockMargin( 0, fh*0.02, 0, 0 )

    local share_ent = vgui.Create( "DTextEntry", creation_frame )
    share_ent:Dock( TOP )
    share_ent:SetFont( "DermaDefaultBold" )
    share_ent:SetText( old_data.Shared or "" )
    share_ent:SetPlaceholderText( "Enter path or right click on model in browser" )
    share_ent:DockMargin( fw*0.01, 0, 0, 0 )

    local name =  vgui.Create( "DLabel", creation_frame )
    name:SetTextColor( color_white )
    name:SetFont( "wOS.DynaBase.DescFont" )
    name:SetText( "Male Mounting Model" )
    name:Dock( TOP )
    name:DockMargin( 0, fh*0.02, 0, 0 )

    local male_ent = vgui.Create( "DTextEntry", creation_frame )
    male_ent:Dock( TOP )
    male_ent:SetText( old_data.Male or "" )
    male_ent:SetFont( "DermaDefaultBold" )
    male_ent:SetPlaceholderText( "Enter path or right click on model in browser" )
    male_ent:DockMargin( fw*0.01, 0, 0, 0 )

    local name =  vgui.Create( "DLabel", creation_frame )
    name:SetTextColor( color_white )
    name:SetFont( "wOS.DynaBase.DescFont" )
    name:SetText( "Female Mounting Model" )
    name:Dock( TOP )
    name:DockMargin( 0, fh*0.02, 0, 0 )

    local female_ent = vgui.Create( "DTextEntry", creation_frame )
    female_ent:Dock( TOP )
    female_ent:SetText( old_data.Female or "" )
    female_ent:SetFont( "DermaDefaultBold" )
    female_ent:SetPlaceholderText( "Enter path or right click on model in browser" )
    female_ent:DockMargin( fw*0.01, 0, 0, 0 )

    local name =  vgui.Create( "DLabel", creation_frame )
    name:SetTextColor( color_white )
    name:SetFont( "wOS.DynaBase.DescFont" )
    name:SetText( "Zombie Mounting Model" )
    name:Dock( TOP )
    name:DockMargin( 0, fh*0.02, 0, 0 )

    local zombie_ent = vgui.Create( "DTextEntry", creation_frame )
    zombie_ent:Dock( TOP )
    zombie_ent:SetText( old_data.Zombie or "" )
    zombie_ent:SetFont( "DermaDefaultBold" )
    zombie_ent:SetPlaceholderText( "Enter path or right click on model in browser" )
    zombie_ent:DockMargin( fw*0.01, 0, 0, 0 )

    local cancel = vgui.Create("DButton", creation_frame )
    cancel:SetTall( fh*0.05 )
    cancel:Dock( BOTTOM )
    cancel:SetText( "Cancel" )
    cancel.DoClick = function() frame:Close() end

    local save = vgui.Create("DButton", creation_frame )
    save:SetTall( fh*0.05 )
    save:Dock( BOTTOM )
    save:SetText( "Save User Mount" )
    save.DoClick = function()
        local name = name_ent:GetText()
        if #name < 1 then
            name_lab:SetTextColor( Color( 255, 0, 0 ) )
            surface.PlaySound( "buttons/button10.wav" )
            return
        end

        local tbl = {
            Name = name,
            Shared = ( #share_ent:GetText() > 1 and share_ent:GetText() ) or nil,
            Male = ( #male_ent:GetText() > 1 and male_ent:GetText() ) or nil,
            Female = ( #female_ent:GetText() > 1 and female_ent:GetText() ) or nil,
            Zombie = ( #zombie_ent:GetText() > 1 and zombie_ent:GetText() ) or nil,
        }
        if old_data.Name then
            self:DeleteUserMount( old_data.Name )
        end
        self:CreateUserMount( tbl )
        parent:RefreshList()
        frame:Close()
    end

    function browser:OnRightClick( path, pnl ) -- Called when a file is clicked
        local menu = DermaMenu()
        menu:AddOption( "Set as Shared Mount", function()
            share_ent:SetText( path )
        end ):SetIcon( "icon16/group.png" )

        menu:AddOption( "Set as Male Mount", function()
            male_ent:SetText( path )
        end ):SetIcon( "icon16/male.png" )

        menu:AddOption( "Set as Female Mount", function()
            female_ent:SetText( path )
        end ):SetIcon( "icon16/female.png" )

        menu:AddOption( "Set as Zombie Mount", function()
            zombie_ent:SetText( path )
        end ):SetIcon( "icon16/bug.png" )

        menu:Open()
    end

end

hook.Add( "Initialize", "wOS.DynaBase.LoadUserMounts", function()
	local mounts = file.Read( "wos/dynabase/usermounts/mounts.txt", "DATA" ) or "{}"
	local local_mounts = util.JSONToTable( mounts )		

	for mount, data in pairs( local_mounts ) do
		wOS.DynaBase.UserMounts[ mount ] = data
	end

end )
--PATH addons/[miecze] moce i hilty/lua/wos/dynabase/registers/vader_stance_register.lua:
wOS.DynaBase:RegisterSource({
    Name = "Darth Vader Stance",
    Type =  WOS_DYNABASE.EXTENSION,
    Shared = "models/player/wiltos/vader_stance.mdl",
})

hook.Add( "PreLoadAnimations", "wOS.DynaBase.MountVader", function( gender )
    if gender != WOS_DYNABASE.SHARED then return end
    IncludeModel( "models/player/wiltos/vader_stance.mdl" )
end )

--PATH lua/wos/dynabase/registers/wos_legacy_registers.lua:
//  These are a bunch of legacy functions to register addons that don't have integrated support for animation management
// This is not how  you should be doing your registers. See other addons

local function GenericRegister( data )
    wOS.DynaBase:RegisterSource({
        Name = data.Name,
        Type =  ( data.Extension and WOS_DYNABASE.EXTENSION ) or WOS_DYNABASE.REANIMATION,
        Male = ( data.Male and "models/xdreanims/m_anm_slot_" .. data.BaseSlot .. ".mdl" ) or nil,
        Female = ( data.Female and "models/xdreanims/f_anm_slot_" .. data.BaseSlot .. ".mdl" ) or nil,
        Zombie = ( data.Zombie and "models/xdreanims/z_anm_slot_" .. data.BaseSlot .. ".mdl" ) or nil,
    })

    hook.Add( "PreLoadAnimations", "wOS.DynaBase.Mount" .. data.Name, function( gender )
        if gender == WOS_DYNABASE.MALE and data.Male then
            IncludeModel( "models/xdreanims/m_anm_slot_" .. data.BaseSlot .. ".mdl" )
        elseif gender == WOS_DYNABASE.FEMALE and data.Female then
            IncludeModel( "models/xdreanims/f_anm_slot_" .. data.BaseSlot .. ".mdl" )
        elseif gender == WOS_DYNABASE.ZOMBIE and data.Zombie then
            IncludeModel( "models/xdreanims/z_anm_slot_" .. data.BaseSlot .. ".mdl" )  
        end
    end )
end

local tbl = {
    ['2261825706'] = {
        Name = "CSGO Reanimations",
        BaseSlot = '046',
        Male = true,
        Female = true,
        Zombie = true,
    },
    ['2143589929'] = {
        Name = "Two-Hand Pistol Reanimations",
        BaseSlot = '002',
        Male = true,
        Female = true,
        Zombie = true,
    },
    ['2493356270'] = {
        Name = "Ironight Reanimations",
        BaseSlot = '011',
        Male = true,
        Female = true,
        Zombie = true,
    },
    ['2737372889'] = {
        Name = "COD Zombie Reanimations",
        BaseSlot = '035',
        Male = true,
        Female = true,
        Zombie = true,
    },
    ['2432553338'] = {
        Name = "Combine Passive Reanimations",
        BaseSlot = '018',
        Male = true,
        Female = true,
        Zombie = true,
    },
    ['2424958167'] = {
        Name = "Drip Idle Reanimations",
        BaseSlot = '019',
        Male = true,
        Female = true,
        Zombie = true,
    },
    ['2348399590'] = {
        Name = "Cut Fist Reanimations",
        BaseSlot = '016',
        Male = true,
        Female = true,
        Zombie = true,
    },
    ['2169293226'] = {
        Name = "Radio Chatter Reanimations",
        BaseSlot = '038',
        Male = true,
        Female = true,
        Zombie = true,
    },   
    ['2148772437'] = {
        Name = "Reduced Breath Reanimations",
        BaseSlot = '029',
        Male = true,
        Female = true,
        Zombie = true,
    },  
    ['2903472153'] = {
        Name = "Human Realm Reanimations",
        BaseSlot = '039',
        Male = true,
        Female = true,
        Zombie = true,
    },  
    ['2918092137'] = {
        Name = "COD Modern Warfare Reanimations",
        BaseSlot = '046',
        Male = true,
        Female = false,
        Zombie = false,
    }, 
    ['2791673215'] = {
        Name = "CODIW Idle Reanimations",
        BaseSlot = '030',
        Male = true,
        Female = true,
        Zombie = true,
    }, 
    ['2792431263'] = {
        Name = "CODIW Last Stand Extension",
        BaseSlot = '040',
        Extension = true,
        Male = true,
        Female = true,
        Zombie = true,
    }, 
    ['2912631064'] = {
        Name = "Feminine Sitting Reanimations",
        BaseSlot = '015',
        Male = false,
        Female = true,
        Zombie = false,
    },  
    ['2742793067'] = {
        Name = "TF2 Laughing Reanimations",
        BaseSlot = '031',
        Male = true,
        Female = true,
        Zombie = false,
    },  
    ['2891284985'] = {
        Name = "SadCat Dance Reanimations",
        BaseSlot = '027',
        Male = true,
        Female = true,
        Zombie = false,
    },  
    ['2895861489'] = {
        Name = "Zero Two Dance Reanimations",
        BaseSlot = '013',
        Male = true,
        Female = true,
        Zombie = false,
    },  
    ['2892723717'] = {
        Name = "KDA Dance Reanimations",
        BaseSlot = '026',
        Male = true,
        Female = true,
        Zombie = false,
    },  
}

// Workshop addon  check  first because that's the most reliable
local op_table = table.Copy( tbl )
for _, addon in ipairs( engine.GetAddons() ) do
    if not addon.mounted then continue  end
    if addon.wsid == "2247494212" then //have to hardcode this cause Yongli needs to do an update..
        wOS.DynaBase:RegisterSource({
            Name = "Sword Art Extension",
            Type =  WOS_DYNABASE.EXTENSION,
            Shared = "models/player/wiltos/anim_extension_mod18.mdl",
        })

        hook.Add( "PreLoadAnimations", "wOS.DynaBase.MountSwordArt", function( gender )
            if gender != WOS_DYNABASE.SHARED then return end
            IncludeModel( "models/player/wiltos/anim_extension_mod18.mdl" )
        end )
    end
    if not op_table[addon.wsid] then continue end
    GenericRegister( op_table[addon.wsid] )
    op_table[addon.wsid] = nil
end

// Now for the longer version we have to do for servers.
for _, data in pairs( op_table ) do
    local base_path = "models/xdreanims/f_anm_slot_" .. data.BaseSlot .. ".mdl" //They happen to all have female so we'll use that
    if !file.Exists(base_path, "GAME") then continue end
    GenericRegister( data )
end

if CLIENT then
    hook.Add( "wOS.DynaBase.PopulateHelperFunctions", "wOS.DynaBase.LEgacyAddHelper", function( parent ) 
        local download_butt = vgui.Create( "DButton", parent )
        download_butt:SetSize( parent:GetWide(), parent:GetTall()*0.0625 )
        download_butt:Dock( TOP )
        download_butt:SetText( "Create User Mounts from Legacy Addon (Will overwrite mounts with the same name!)" )
        download_butt.DoClick = function(pan) 
            for wsid, data in pairs( tbl ) do
                local ndata = {
                    Name = data.Name,
                    Male = ( data.Male and "models/xdreanims/m_anm_slot_" .. data.BaseSlot .. ".mdl" ) or nil,
                    Female = ( data.Female and "models/xdreanims/f_anm_slot_" .. data.BaseSlot .. ".mdl" ) or nil,
                    Zombie = ( data.Zombie and "models/xdreanims/z_anm_slot_" .. data.BaseSlot .. ".mdl" ) or nil,
                }
                wOS.DynaBase:CreateUserMount( ndata )
            end
            chat.AddText( color_white, "[", Color( 0, 175, 255 ), "wOS-DynaBase", color_white, "] All legacy mounts regardless of subscription status have been added!" )
            parent:ReloadAddons()
        end
    end )
end
--PATH lua/autorun/wounded.lua:
local Category = "[LVS] Republic Vehicle"

local function StandAnimation( vehicle, player )
	return player:SelectWeightedSequence( ACT_HL2MP_IDLE_PASSIVE )
end

local V = {
	Name = "Stretcher pod",
	Model = "models/nova/airboat_seat.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,
	Author = "",
	Information = "Seat for wounded.",
	Offset = 0,

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt",
		limitview = "0"
	},
	
	Members = {
		HandleAnimation = StandAnimation
	}
}
list.Set( "Vehicles", "wounded", V )
--PATH lua/xeninui/libs/loader.lua:
return gluapack()()
--PATH lua/xeninui/libs/essentials.lua:
return gluapack()()
--PATH lua/xeninui/libs/icon_dl.lua:
XeninUI.CachedIcons = XeninUI.CachedIcons or {}

if (!file.IsDir("xenin/icons", "DATA")) then
	file.CreateDir("xenin/icons")
end
if (!file.IsDir("xenin/icons/imgur", "DATA")) then
	file.CreateDir("xenin/icons/imgur")
end



local function DownloadImage(tbl)
	local p = XeninUI.Promises.new()

	if (!isstring(tbl.id)) then
		return p:reject("ID invalid")
	end

	local id = tbl.id
	local idLower = id:lower()
	local url = tbl.url or "https://i.imgur.com"
	local type = tbl.type or "png"

	if (XeninUI.CachedIcons[id] and XeninUI.CachedIcons[id] != "Loading") then
		return p:resolve(XeninUI.CachedIcons[id])
	end

	local read = file.Read("xenin/icons/imgur/" .. idLower .. "." .. type)
	if read then
		XeninUI.CachedIcons[id] = Material("../data/xenin/icons/imgur/" .. idLower .. "." .. type, "smooth")

		return p:resolve(XeninUI.CachedIcons[id])
	end

	local fullURL = tbl.fullURL or url .. "/" .. id .. "." .. type
	http.Fetch(fullURL, function(body, size, headers, code)
		if (code != 200) then
			return p:reject("Unable to download image due to code not being 200. Code: " .. code .. " ID:  " .. id .. " URL: " .. url .. "/" .. id .. "." .. type)
		end

		local str = "xenin/icons/imgur/" .. idLower .. "." .. type
		file.Write(str, body)

		XeninUI.CachedIcons[id] = Material("../data/" .. str, "smooth")

		p:resolve(XeninUI.CachedIcons[id])
	end, function(err)
		p:reject("Unable to download image. ID: " .. id .. " URL: " .. url .. "/" .. id .. "." .. type)
	end)

	return p
end

function XeninUI:DownloadIcon(pnl, tbl, pnlVar)
	if (!tbl) then return end

	local p = XeninUI.Promises.new()

	if isstring(tbl) then
		tbl = {
		{
		id = tbl } }
	end

	local i = 1
	local function AsyncDownload()
		if (!tbl[i]) then p:reject()end

		pnl[pnlVar or "Icon"] = "Loading"
		DownloadImage(tbl[i]):next(function(result)
			p:resolve(result):next(function()
				pnl[pnlVar or "Icon"] = result
			end, function(err)
				print(err)
			end)
		end, function(err)
			print(err)

			i = i + 1

			AsyncDownload()
		end)
	end

	AsyncDownload()

	return p
end

function XeninUI:DrawIcon(x, y, w, h, pnl, col, loadCol, var)
	col = col or color_white
	loadCol = loadCol or XeninUI.Theme.Accent
	var = var or "Icon"

	if (pnl[var] and type(pnl[var]) == "IMaterial") then
		surface.SetMaterial(pnl[var])
		surface.SetDrawColor(col)
		surface.DrawTexturedRect(x, y, w, h)
	elseif (pnl[var] != nil) then
		XeninUI:DrawLoadingCircle(h, h, h, loadCol)
	end
end



function XeninUI:GetIcon(id)
	local _type = type(id)
	if (_type == "IMaterial") then
		return id
	end

	if self.CachedIcons[id] then
		return self.CachedIcons[id]
	end

	local read = file.Read("xenin/icons/" .. id:lower() .. ".png")
	if read then
		self.CachedIcons[id] = Material("../data/xenin/icons/" .. id:lower() .. ".png", "smooth")
	else
		self.CachedIcons[id] = "Loading"
	end

	http.Fetch("https://i.imgur.com/" .. id .. ".png", function(body, len)
		local str = "xenin/icons/" .. id:lower() .. ".png"
		file.Write(str, body)

		self.CachedIcons[id] = Material("../data/" .. str, "smooth")
	end)
end

--PATH lua/xeninui/libs/permissions.lua:
local Permissions
do
  local _class_0
  local _base_0 = {
    __name = "Permissions",
    canAccessFramework = function(self, ply)
      local dev = self:isXeninDeveloper(ply)
      if (dev and tonumber(GetConVar("xenin_easy_permissions")) == 1) then
        return true
      end

      return self:isSuperAdmin(ply)
    end,
    isAdmin = function(self, ply, level)
      if level == nil then level = 1
      end
      return ply:IsAdmin()
    end,
    isSuperAdmin = function(self, ply)
      return ply:IsSuperAdmin()
    end,
    isXeninDeveloper = function(self, ply)
      return self.xeninDevelopers[ply:SteamID64()]
    end,
    __type = function(self)
      return "XeninUI.Permissions"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.xeninDevelopers = {
        ["76561198202328247"] = "sleeppyy",
        ["76561198058042338"] = "Hoofy"
      }
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Permissions = _class_0
end

XeninUI.Permissions = Permissions()

CreateConVar("xenin_easy_permissions", 1)

--PATH lua/xeninui/libs/shadows.lua:
return gluapack()()
--PATH lua/xeninui/libs/v0n_sh.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/classes/controller.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/classes/entity.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Configurator.Entity",
    setDatabaseEntity = function(self, databaseEntity)
      self.databaseEntity = databaseEntity
      return self
    end,
    getDatabaseEntity = function(self)
      return self.databaseEntity
    end,
    getColumns = function(self)
      return self.columns
    end,
    getColumn = function(self, id)
      for i, v in ipairs(self.columns) do
        if (v.id != id) then continue end

        return v, i
      end
    end,
    addColumn = function(self, id, data)
      table.insert(self.columns, __laux_concat_0({
      id = id
      }, data))

      local name = id:sub(1, 1):upper() .. id:sub(2)
      self["set" .. tostring(name)] = function(self, val, deserialize)
        if deserialize then
          if (data.csv and isstring(val)) then
            val = string.Explode(",", val)
          elseif (isstring(val) and (data.type == "list" or data.json)) then
            val = util.JSONToTable(val)
          end
        end

        self[id] = val

        return self
      end
      self["set" .. tostring(id)] = function(self, ...)
        self["set" .. tostring(name)](self, ...)end
      self["get" .. tostring(name)] = function(self, serialize)
        if serialize then
          if (data.csv and istable(self[id])) then
            return table.concat(self[id], ",")
          elseif istable(self[id]) then
            return util.TableToJSON(self[id])
          end
        end

        return self[id]
      end
      self["get" .. tostring(id)] = function(self, ...)
        return self["get" .. tostring(name)](self, ...)end
    end,
    getSQLTableName = function(self)
      local str = self:getDatabaseEntity():lower()
      str = str:Replace(".", "_")

      return "xenin_configurator_entity_" .. str
    end,
    createSQLTable = function(self)
      local tableName = self:getSQLTableName()
      XeninUI.ORM.Table(XeninDB, tableName, function(tbl)
        for i, v in ipairs(self:getColumns()) do
          assert(v ~= nil, "cannot destructure nil value")
          local type, length, primary, null, default = v.type, v.length, v.primary, v.null, v.default
          local dataType = type == "list" and "text" or type
          local col = tbl[dataType](tbl, v.id)
          if primary then col:primary()end
          if length then col:length(length)end
          if null then col:nullable()end
          if default then
            local notExpressions = {
              integer = true,
              string = true
            }

            local isExpression = !notExpressions[type]
            col:default(default, isExpression)
          end
        end
      end, function()
        self:seed()
      end)
    end,
    seedData = function(self) end,
    seed = function(self)
      local data = self:seedData()
      if (!data) then return end
      local name = self:getSQLTableName()

      for i, v in ipairs(data) do
        XeninUI.Configurator.ORM:seed(name, v.version, v.code())
      end
    end,
    onNetworkSend = function(self)

      local cols = self:getColumns()
      local size = #cols
      local tbl = {}
      for i, v in ipairs(cols) do
        assert(v ~= nil, "cannot destructure nil value")
        local id = v.id
        local val = self["get" .. tostring(id)](self, true)
        if (!val) then continue end
        if (isstring(val) and val == "") then continue end

        tbl[id] = val
      end

      local size = table.Count(tbl)
      net.WriteUInt(size, 12)
      for i, v in pairs(tbl) do
        net.WriteString(i)
        XeninUI.Configurator.Network:write(v)
      end
    end,
    onNetworkReceive = function(self)
      local cols = self:getColumns()
      local size = net.ReadUInt(12)
      for i = 1, size do
        local id = net.ReadString()
        local val = XeninUI.Configurator.Network:read()

        self["set" .. tostring(id)](self, val, true)
      end
    end,
    onSave = function(self) end,
    onDelete = function(self) end,
    onLoad = function(self) end,
    validateColumn = function(self, id, input)
      local col = self:getColumn(id)
      if (!col) then return end

      if (!col.validate) then return true, "No validation"end

      return col.validate(input)
    end,
    shouldAllowNetwork = function(self, ply)
      return true end,
    save = function(self, admin)
      self:onSave()

      if (!admin) then return end

      if CLIENT then
        XeninUI.Configurator.Network:sendSaveEntity(self)

        return
      end

      XeninUI.Configurator.ORM:saveEntity(self)

      self:network()
    end,
    network = function(self, target)
      if (!target) then
        target = {}
        for i, v in ipairs(player.GetAll()) do
          if (!self:shouldAllowNetwork(v)) then continue end

          table.insert(target, v)
        end

        if (table.IsEmpty(target)) then return end
      end

      XeninUI.Configurator.Network:sendEntity(target, self)
    end,
    createNewEntity = function(self)
      if CLIENT then
        XeninUI.Configurator.Network:sendCreateEntity(self)

        return
      end

      XeninUI.Configurator.ORM:createEntity(self)
    end,
    delete = function(self, admin)
      self:onDelete()

      if (!admin) then return end

      if CLIENT then
        XeninUI.Configurator.Network:sendDeleteEntity(self)

        return
      end

      XeninUI.Configurator.ORM:deleteEntity(self)
    end,
    isDatabaseEntity = function(self)
      return true end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.columns = {}
    end,
    __base = _base_0,
    register = function(name, entity)
      local __laux_type = (istable(entity) and entity.__type and entity:__type()) or type(entity)
      assert(__laux_type == "XeninUI.Configurator.Entity", "Expected parameter `entity` to be type `XeninUI.Configurator.Entity` instead of `" .. __laux_type .. "`")
      XeninUI.Configurator.Entities:register(name, entity)
    end
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Configurator.Entity = _class_0
end

--PATH lua/xeninui/libs/configurator/ui/frame.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/entities/entity_list_row.lua:
return gluapack()()
--PATH lua/xeninui/libs/config/network/client.lua:
return gluapack()()
--PATH lua/xeninui/libs/players/ui/frame.lua:
local PANEL = {}

function PANEL:Init()
  if IsValid(XeninUI.Players.Frame) then
    XeninUI.Players.Frame:Remove()
  end

  XeninUI.Players.Frame = self

  self:SetTitle("Xenin Hub")
  self:MakePopup()

  self.Sidebar = self:Add("XeninUI.SidebarV2")
  self.Sidebar:Dock(LEFT)
  self.Sidebar:SetBody(self)
  self.Sidebar:CreateDivider()
  self.Sidebar:CreatePanel("Notifications", nil, "XeninUI.Players.Notifications", "8JweIot")
  self.Sidebar:SetActiveByName("Notifications")

  self.Player = self.Sidebar:Add("XeninUI.Sidebar.Player")
  self.Player:Dock(TOP)
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  self:SetSize(XeninUI.Frame.Width, XeninUI.Frame.Height)
  self:Center()

  local sw = 0
  for i, v in ipairs(self.Player.Text.Rows) do
    surface.SetFont(v.font)
    local tw = surface.GetTextSize(v.text)

    sw = math.max(sw, 68 + tw + 68 / 2 + 8)
  end
  for i, v in ipairs(self.Sidebar.Sidebar) do
    surface.SetFont("XeninUI.SidebarV2.Name")
    local nameTw = surface.GetTextSize(v.Name or "")
    surface.SetFont(v.DescFont)
    local descTw = surface.GetTextSize(v.Desc or "")

    local tw = math.max(nameTw, descTw) + 12 + 8
    if v.Icon then
      tw = tw + 68
    end

    sw = math.max(sw, tw)
  end
  self.Sidebar:SetWide(sw)
  self.Sidebar:SetTall(56)

  self.Player:SetTall(68)
end

vgui.Register("XeninUI.Players", PANEL, "XeninUI.Frame")

--PATH lua/xeninui/libs/players/ui/notifications/main.lua:
return gluapack()()
--PATH lua/xeninui/libs/players/network/shared.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Players.NetworkHelper",
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self) end,
    __base = _base_0,
    sendNotification = function(notification)
      assert(notification ~= nil, "cannot destructure nil value")
      local scriptId, type, content, createdAt, readAt, data, id = notification.scriptId, notification.type, notification.content, notification.createdAt, notification.readAt, notification.data, notification.id

      net.WriteString(scriptId)
      net.WriteString(type)
      net.WriteString(content)
      net.WriteString(createdAt)
      net.WriteBool(istable(data))
      if istable(data) then
        net.WriteTable(data)
      end
      net.WriteBool(readAt != nil)
      if readAt then
        net.WriteString(readAt)
      end
      net.WriteBool(id != nil)
      if id then
        net.WriteUInt(id, 32)
      end
    end,
    receiveNotification = function()
      local notification = {
        scriptId = net.ReadString(),
        type = net.ReadString(),
        content = net.ReadString(),
        createdAt = net.ReadString()
      }
      local hasData = net.ReadBool()
      if hasData then
        notification.data = net.ReadTable()
      end
      local hasRead = net.ReadBool()
      if hasRead then
        notification.readAt = net.ReadString()
      end
      local hasId = net.ReadBool()
      if hasId then
        notification.id = net.ReadUInt(32)
      end

      return notification
    end
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Players.NetworkHelper = _class_0
end

--PATH lua/xeninui/elements/animated_texture.lua:
local PANEL = {}

AccessorFunc(PANEL, "m_paused", "Paused")

function PANEL:Init()
    self.images = {}
    self.slots = {}
    self:SetPaused(false)
end

function PANEL:SetDirectory(dir)
    local files = file.Find("materials/" .. dir .. "/*", "GAME") or {}
    for k, v in pairs(files) do
        files[k] = tonumber(string.StripExtension(v))
    end

    table.sort(files, function(a, b)
        return a < b end)

    local new = {}
    for k, v in pairs(files) do
        new[k] = Material(dir .. "/" .. v .. ".png", "smooth")
    end

    self.dir = dir
    self.images = new
end

function PANEL:SetImages(tbl)
    self.images = tbl
end

function PANEL:SetTimes(normal, idle)
    self.times = {
        normal = normal or .02,
        idle = idle or 1
    }
end

function PANEL:PostInit()
    self.start_slot = 1
    self.end_slot = #self.images

    self.slots = {
        min = 1,
        max = #self.images
    }

    self.cur_image = self.slots.min
    self.next_change = UnPredictedCurTime() + self.times.normal

    self.can_draw = true
end

function PANEL:Paint(w, h)
    if !self.can_draw then return end

    if !self.images[self.cur_image] then return end

    surface.SetMaterial(self.images[self.cur_image])
    surface.SetDrawColor(255, 255, 255)
    surface.DrawTexturedRect(0, 0, w, h)

    if self.next_change < UnPredictedCurTime() and !self:GetPaused() then
        self.cur_image = self.cur_image < self.slots.max and self.cur_image + 1 or self.slots.min
        self.next_change = UnPredictedCurTime() + (self.cur_image < self.slots.max and self.times.normal or self.times.idle)
    end
end

vgui.Register("XeninUI.AnimatedTexture", PANEL, "Panel")

--PATH lua/xeninui/elements/button_v2.lua:
return gluapack()()
--PATH lua/xeninui/elements/checkbox_slider.lua:
return gluapack()()
--PATH lua/xeninui/elements/checkbox_slider.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Checkbox.Slider", 14)

AccessorFunc(PANEL, "m_state", "State")
AccessorFunc(PANEL, "m_offColor", "OffColor")
AccessorFunc(PANEL, "m_onColor", "OnColor")
AccessorFunc(PANEL, "m_btnOffColor", "ButtonOffColor")
AccessorFunc(PANEL, "m_btnOnColor", "ButtonOnColor")

function PANEL:Init()
  self:SetText("")
  self:SetState(false)

  self:SetOffColor(XeninUI.Theme.Primary)
  self:SetOnColor(XeninUI.Theme.GreenDark)

  self:SetButtonOffColor(Color(72, 72, 72))
  self:SetButtonOnColor(color_white)

  self.Color = self:GetOffColor()
  self.Pos = 0
  self.ButtonColor = self:GetButtonOffColor()
end

function PANEL:Paint(w, h)
  XeninUI:DrawRoundedBox(h / 2, 0, 0, w, h, self.Color)

  local size = h / 2
  local frac = self.Pos
  local x = frac * (w - (size * 2))





  XeninUI:DrawCircle(size + x, size, size - 3, 30, self.ButtonColor)
end


function PANEL:OnStateChanged(state) end

function PANEL:SetState(state)
  self.m_state = state
  self:OnStateChanged(state)
end

function PANEL:UpdateState(instant)
  local state = self:GetState()
  local col = state and self:GetOnColor() or self:GetOffColor()
  local btnCol = state and self:GetButtonOnColor() or self:GetButtonOffColor()
  local pos = state and 1 or 0

  if instant then
    self.Color = col
    self.ButtonColor = btnCol
    self.Pos = pos
  else
    self:EndAnimations()
    self:LerpColor("Color", col)
    self:LerpColor("ButtonColor", btnCol)
    self:Lerp("Pos", pos)
  end
end

function PANEL:DoClick()
  self:SetState(!self:GetState())
  self:UpdateState()
end

vgui.Register("XeninUI.Checkbox.Slider", PANEL, "DButton")

--PATH lua/xeninui/elements/combobox.lua:
return gluapack()()
--PATH lua/xeninui/elements/frame.lua:
XeninUI:CreateFont("XeninUI.Frame.Title", 28)

local PANEL = {}

function PANEL:Init()
	self.top = vgui.Create("Panel", self)
	self.top:Dock(TOP)
	self.top.Paint = function(pnl, w, h)
		draw.RoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Primary, true, true, false, false)
	end

	if XeninUI.Branding then
		local isMat = type(XeninUI.Branding) == "IMaterial"

		self.branding = vgui.Create("Panel", self.top)
		self.branding:Dock(LEFT)
		if (!isMat) then
			XeninUI:DownloadIcon(self.branding, XeninUI.Branding)
		end
		self.branding.Paint = function(pnl, w, h)
			if isMat then
				surface.SetDrawColor(color_white)
				surface.SetMaterial(XeninUI.Branding)
				surface.DrawTexturedRect(4, 4, w - 8, h - 8)
			else
				XeninUI:DrawIcon(4, 4, w - 8, h - 8, pnl)
			end
		end
	end

	self.title = vgui.Create("DLabel", self.top)
	self.title:Dock(LEFT)
	self.title:DockMargin(IsValid(self.branding) and 0 or 10, 0, 0, 0)
	self.title:SetFont("XeninUI.Frame.Title")
	self.title:SetTextColor(color_white)

	self.closeBtn = vgui.Create("DButton", self.top)
	self.closeBtn:Dock(RIGHT)
	self.closeBtn:SetText("")
	self.closeBtn.CloseButton = Color(195, 195, 195)
	self.closeBtn.Alpha = 0
	self.closeBtn.DoClick = function(pnl)
		self:Remove()
	end
	self.closeBtn.Paint = function(pnl, w, h)
		draw.RoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Red, pnl.Alpha))

		surface.SetDrawColor(pnl.CloseButton)
		surface.SetMaterial(XeninUI.Materials.CloseButton)
		surface.DrawTexturedRect(12, 12, w - 24, h - 24)
	end
	self.closeBtn.OnCursorEntered = function(pnl)
		pnl:Lerp("Alpha", 255)
		pnl:LerpColor("CloseButton", Color(255, 255, 255))
	end
	self.closeBtn.OnCursorExited = function(pnl)
		pnl:Lerp("Alpha", 0)
		pnl:LerpColor("CloseButton", Color(195, 195, 195))
	end
end

function PANEL:SetTitle(str)
	self.title:SetText(str)
	self.title:SizeToContents()
end

function PANEL:PerformLayout(w, h)
	self.top:SetTall(40)

	if IsValid(self.branding) then
		self.branding:SetWide(self.top:GetTall())
	end

	self.closeBtn:SetWide(self.top:GetTall())
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
	draw.RoundedBox(6, x, y, w, h, XeninUI.Theme.Background)
	BSHADOWS.EndShadow(1, 2, 2, 255, 0, 0)
end

function PANEL:ShowCloseButton(show)
	self.closeBtn:SetVisible(show)
end

vgui.Register("XeninUI.Frame", PANEL, "EditablePanel")

concommand.Add("xeninui", function()
	local frame = vgui.Create("XeninUI.Frame")
	frame:SetSize(960, 720)
	frame:Center()
	frame:MakePopup()
	frame:SetTitle("Party")
end)

--PATH lua/xeninui/elements/navbar.lua:
return gluapack()()
--PATH lua/xeninui/elements/notifications.lua:
return gluapack()()
--PATH lua/xeninui/elements/options.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
local PANEL = {}

AccessorFunc(PANEL, "m_font", "Font")

XeninUI:CreateFont("XeninUI.Options.Button", 22)

function PANEL:Init()
  self:SetDrawOnTop(true)
  self:SetZPos(125)
  self:DockPadding(8, 8, 8, 8)
  self.Alpha = 0
  self:LerpAlpha(255, 0.3)
  self:SetFont("XeninUI.Options.Button")
end

function PANEL:OnFocusChanged(gained)
  if (gained) then return end

  self:Close()
end

function PANEL:Close()
  if (self.Removing) then return end

  self.Removing = true
  self:LerpAlpha(255, 0.1)
  self:LerpHeight(0, 0.1, function()
    if (!IsValid(self)) then return end

    self:Remove()
  end)
end

function PANEL:GetNewSize()
  local width = 16
  local height = 16

  local children = self:GetChildren()
  local size = #children
  for i, v in ipairs(children) do
    if (v.RowType == self.Options.BUTTON) then
      surface.SetFont(v.Font)
      local tW = surface.GetTextSize(v.Text)

      tW = tW + 32

      if v.IconBackground then tW = tW + 53
      end

      width = math.max(width, tW)
    end

    height = height + v:GetTall()
    if (i != size) then height = height + 8
    end
  end

  return math.max(150, width), height
end

function PANEL:UpdatePos()
  local parent = self.Parent
  if (!IsValid(parent)) then self:Remove()end

  local aX, aY = parent:LocalToScreen()
  local x = self:GetWide() - parent:GetWide()
  local y = parent:GetTall()
  self:SetPos(aX - x, aY + y)
end

function PANEL:CreateButton(data)
  local btn = self:Add("DButton")
  btn:SetTall(53)
  btn:SetText("")
  local hoverColor = data.hoverColor or XeninUI.Theme.Primary
  btn.Background = ColorAlpha(hoverColor, 0)
  btn.Text = data.text
  btn.TextColor = data.textColor or color_white
  btn.Font = data.font or self:GetFont()
  if data.icon then
    XeninUI:DownloadIcon(btn, data.icon)
    btn.IconBackground = Color(58, 58, 58)
    btn.IconColor = data.iconColor or btn.TextColor
    btn.IconHoverColor = data.iconHoverColor or btn.IconColor
  end
  btn.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Background)

    local x = 8
    if pnl.Icon then
      local size = h - 16
      XeninUI:DrawCircle(x + size / 2, size / 2 + x, size / 2, 30, pnl.IconBackground)
      size = size - 16
      XeninUI:DrawIcon(x + 8, 16, size, size, pnl, pnl.IconColor)

      x = x + h
    end

    draw.SimpleText(pnl.Text, pnl.Font, x, h / 2, pnl.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  btn.PaintOver = function(pnl, w, h)
    if (!pnl.Pressing) then return end
    local frac = math.TimeFraction(pnl.Pressing, pnl.End, CurTime())
    local col = XeninUI:LerpColor(frac, XeninUI.Theme.Red, XeninUI.Theme.Green)

    local aX, aY = pnl:LocalToScreen()
    render.SetScissorRect(aX, aY, aX + (w * frac), aX + h, true)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, ColorAlpha(data.hold.color, 100))
    render.SetScissorRect(0, 0, ScrW(), ScrH(), false)
  end
  btn.OnCursorEntered = function(pnl)
    pnl:LerpColor("Background", ColorAlpha(hoverColor, 100))
    if data.icon then
      pnl:LerpColor("IconColor", pnl.IconHoverColor)
    end
  end
  btn.OnCursorExited = function(pnl)
    pnl:LerpColor("Background", ColorAlpha(hoverColor, 0))
    if data.icon then
      pnl:LerpColor("IconColor", data.iconColor or btn.TextColor)
    end
  end
  if data.hold then
    btn.Think = function(pnl)
      if (!pnl.Pressing) then return end
      local frac = math.Clamp(math.TimeFraction(pnl.Pressing, pnl.End, CurTime()), 0, 1)
      if (frac < 1) then return end
      if (pnl.Clicked) then return end
      pnl.Clicked = true

      if data.onClick then
        data:onClick(pnl)
      end

      self:Close()
    end
    btn.OnMousePressed = function(pnl)
      local wait = data.hold.time
      local time = CurTime()

      pnl.Clicked = nil
      pnl.Pressing = time
      pnl.End = CurTime() + wait
    end
    btn.OnMouseReleased = function(pnl)
      pnl.Clicked = nil
      pnl.Pressing = nil
      pnl.End = nil
    end
  else
    btn.DoClick = function(pnl)
      if data.onClick then
        local stop = data:onClick(pnl) != nil

        if (stop) then return end
      end

      self:Close()
    end
  end

  return btn
end

function PANEL:CreateDivider(data)
  local divider = self:Add("DPanel")
  divider:SetTall(data.thickness or 1)
  divider.Color = data.color or Color(64, 64, 64)
  divider.Paint = function(pnl, w, h)
    surface.SetDrawColor(pnl.Color)
    surface.DrawRect(0, 0, w, h)
  end

  return divider
end

function PANEL:SetOptions(options)
  self.Options = options
  assert(options ~= nil, "cannot destructure nil value")
  local rows, BUTTON, DIVIDER = options.rows, options.BUTTON, options.DIVIDER

  for i, v in ipairs(rows) do
    local row
    if (v.rowType == BUTTON) then
      row = self:CreateButton(v)
    elseif (v.rowType == DIVIDER) then
      row = self:CreateDivider(v)
    end

    row:Dock(TOP)
    row:DockMargin(0, 0, 0, 8)
    row.RowType = v.rowType
  end

  local width, height = self:GetNewSize()
  self:SetWide(width)
  self:SetTall(0)
  self:LerpHeight(height, 0.3)
  self:MakePopup()
  self:UpdatePos()
end

function PANEL:Think()
  if (!self.Parent) then return end

  if (!IsValid(self.Parent)) then
    return self:Close()
  end

  if (!self.Parent:IsVisible()) then
    return self:Close()
  end
end

function PANEL:Paint(w, h)
  local aX, aY = self:LocalToScreen()

  BSHADOWS.BeginShadow()
  XeninUI:DrawRoundedBox(6, aX, aY, w, h, XeninUI.Theme.Background)
  BSHADOWS.EndShadow(1, 1, 1, 150 * (255 / self:GetAlpha()))

  XeninUI:MaskInverse(function()
    XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, XeninUI.Theme.Background)
  end, function()
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Primary, self:GetAlpha()))
  end)
end

vgui.Register("XeninUI.Options", PANEL, "EditablePanel")

do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Options",
    addButton = function(self, data)
      table.insert(self.rows, __laux_concat_0({
      rowType = self.BUTTON
      }, data))

      return self
    end,
    addDivider = function(self, data)
      if data == nil then data = {}
      end
      table.insert(self.rows, __laux_concat_0({
      rowType = self.DIVIDER
      }, data))

      return self
    end,
    create = function(self)
      self.panel = vgui.Create("XeninUI.Options")
      self.panel.Parent = self.parent
      self.panel:SetOptions(self)

      return self.panel
    end,
    __type = function(self)
      return "XeninUI.Options"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, parent)
      self.rows = {}
      self.DIVIDER = 1
      self.BUTTON = 0
      self.parent = parent
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Options = _class_0
end

--PATH lua/xeninui/elements/panel.lua:
return gluapack()()
--PATH lua/xeninui/elements/scrollpanel.lua:
return gluapack()()
--PATH lua/xeninui/elements/sidebar_animated.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Sidebar.Name", 22)

AccessorFunc(PANEL, "m_body", "Body")

function PANEL:Init()
	self:SetZPos(20)

	self.Width = 88
	self._Alpha = 0

	self.Buttons = {}
	self.Panels = {}
end

function PANEL:AddTab(name, icon, panelClass)
	local button = self:Add("DButton")
	button:SetText("")
	button.Color = color_white
	button.Desc = name
	button.Paint = function(pnl, w, h)
		surface.SetDrawColor(pnl.Color)
		surface.SetMaterial(icon)
		surface.DrawTexturedRect(27, 17, 30, 30)

		draw.SimpleText(pnl.Desc, "XeninUI.Sidebar.Name", 27 + 30 + 16, h / 2, ColorAlpha(pnl.Color, self._Alpha), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
	button.OnCursorEntered = function(pnl)
		self:OnCursorEntered()

		pnl:LerpColor("Color", XeninUI.Theme.Accent)
	end
	button.OnCursorExited = function(pnl)
		self:OnCursorExited()

		if (pnl.Id == self.Active) then return end

		pnl:LerpColor("Color", color_white)
	end
	button.DoClick = function(pnl)
		self:SetActive(pnl.Id)
	end

	local id = table.insert(self.Buttons, button)
	button.Id = id

	local pnl = self:GetBody():Add(panelClass or "DPanel")
	pnl:Dock(FILL)
	pnl:SetVisible(false)

	table.insert(self.Panels, pnl)
end

function PANEL:PerformLayout(w, h)
	local y = 0

	for i, v in pairs(self.Buttons) do
		v:SetSize(w, 68)
		v:SetPos(0, y)

		y = y + v:GetTall()
	end
end

function PANEL:Paint(w, h)
	draw.RoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Navbar, false, false, true, false)
end

function PANEL:Think()
	if self._InvalidateParent then
		self:InvalidateParent()
	end
end

function PANEL:SetActive(id)
	if (self.Active == id) then return end

	if self.Active then
		local btn = self.Buttons[self.Active]
		local pnl = self.Panels[self.Active]
		if IsValid(btn) then
			btn:LerpColor("Color", color_white)
		end
		if IsValid(pnl) then
			pnl.DrawAlpha = pnl.DrawAlpha or 0
			pnl.PaintOver = function(pnl, w, h)
				draw.RoundedBoxEx(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Background, pnl.DrawAlpha), false, false, true, true)
			end
			pnl:Lerp("DrawAlpha", 255, 0.15, function()
				pnl.PaintOver = nil
				pnl:SetVisible(false)
			end)
		end

		self.Active = id

		if self.OnActiveChanged then
			self:OnActiveChanged(id)
		end

		local btn = self.Buttons[id]
		local pnl = self.Panels[id]

		timer.Simple(0.15, function()
			if (!IsValid(self)) then return end

			btn:LerpColor("Color", XeninUI.Theme.Accent)
			pnl.DrawAlpha = pnl.DrawAlpha or 255
			pnl:SetVisible(true)
			if pnl.OnSwitchedTo then
				pnl:OnSwitchedTo(btn.Desc)
			end
			pnl.PaintOver = function(pnl, w, h)
				draw.RoundedBoxEx(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Background, pnl.DrawAlpha), false, false, true, true)
			end
			pnl:Lerp("DrawAlpha", 0, 0.15, function()
				pnl.PaintOver = nil
			end)
		end)
	else

		self.Active = id

		local btn = self.Buttons[id]
		local pnl = self.Panels[id]

		btn.Color = XeninUI.Theme.Accent
		pnl:SetVisible(true)
		if pnl.OnSwitchedTo then
			pnl:OnSwitchedTo(btn.Desc)
		end
	end
end

function PANEL:OnCursorEntered()
	self._InvalidateParent = true

	local width = 0
	surface.SetFont("XeninUI.Sidebar.Name")
	for i, v in pairs(self.Buttons) do
		local tw = surface.GetTextSize(v.Desc)
		tw = tw + 88

		if (tw > width) then
			width = tw
		end
	end
	self:Lerp("Width", width, nil, function()
		self._InvalidateParent = nil
	end)
	self:Lerp("_Alpha", 255)
end

function PANEL:OnCursorExited()
	self._InvalidateParent = true

	self:Lerp("Width", 88, nil, function()
		self._InvalidateParent = nil
	end)
	self:Lerp("_Alpha", 0)
end

vgui.Register("XeninUI.Sidebar.Animated", PANEL)

--PATH lua/xeninui/libs/units/classes/spec.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Units.Spec",
    getName = function(self)
      return self.name end,
    getFunc = function(self)
      return self.func end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, name, func)
      self.name = name
      self.func = func
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Units.Spec = _class_0
end

--PATH lua/xeninui/libs/units/classes/test.lua:
return gluapack()()
--PATH lua/xeninui/libs/units/classes/test.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Units.Test",
    addSpec = function(self, name, func, args)
      table.insert(self.specs, XeninUI.Units.Spec(name, func))

      return self
    end,
    runSpecFunc = function(self, spec)
      local p = XeninUI.Promises.new()

      local success, returnVal = xpcall(spec:getFunc(), debug.traceback, self)
      local result = XeninUI.Units.Result(spec:getName(), success, returnVal)

      if result:isSuccess() then
        if istable(result:getReturn()) then
          result:getReturn():next(function()
            p:resolve(result:getMessagePrint())
          end, function(err)
            result:setSuccess(false)
            result:setError(err or "Promise failedd")
            p:reject(result:getMessagePrint())
          end)
        else
          p:resolve(result:getMessagePrint())
        end
      else
        p:reject(result:getMessagePrint())
      end

      return p
    end,
    setBeforeAll = function(self, func)
      self.beforeAll = func return self end,
    setBeforeEach = function(self, func)
      self.beforeEach = func return self end,
    setAfterEach = function(self, func)
      self.afterEach = func return self end,
    setAfterAll = function(self, func)
      self.afterAll = func return self end,
    finishedTests = function(self, dontPrint)
      if (!dontPrint) then
        for i, v in ipairs(self.msgs) do
          table.insert(v, "\n")
          MsgC(unpack(v))
        end
      end
    end,
    run = function(self, dontPrint)
      self.msgs = {
      {
        Color(255, 255, 255),
        tostring(self.name) .. " should:"
      }
      }

      local p = XeninUI.Promises.new()

      local start = SysTime()
      local errors = 0
      local successes = 0
      local size = #self.specs
      local i = 1
      local function nextFunc()
        self:afterEach()
        i = i + 1
      end
      local function runTest()
        if (i > size) then
          self:afterAll()
          self:finishedTests()

          local ms = math.Round((SysTime() - start) * 1000, 2)
          p:resolve({
            msgs = self.msgs,
            executionTime = ms,
            size = size,
            errors = errors,
            successes = successes
          })
        end

        local tbl = self.specs[i]
        self:beforeEach()
        self:runSpecFunc(tbl):next(function(result)
          successes = successes + 1

          table.insert(self.msgs, result)

          nextFunc()
          runTest()
        end, function(err)
          errors = errors + 1

          table.insert(self.msgs, err)

          nextFunc()
          runTest()
        end)
      end

      local err = self:beforeAll()
      if istable(err) then

        err:next(function()
          runTest()
        end, function(err)
          p:reject(err)
        end)
      else
        if err then
          return p:reject(err)
        end
        runTest()
      end

      return p
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, name)
      self.specs = {}
      self.name = name
      self.beforeAll = function() end
      self.beforeEach = function() end
      self.afterEach = function() end
      self.afterAll = function() end
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Units.Test = _class_0
end

function XeninUI:Test(script, printOut, delay)
  if printOut == nil then printOut = true
  end
  local p = XeninUI.Promises.new()
  local tbl = XeninUI.Scripts:get(script)
  if (!tbl) then
    if printOut then MsgC(XeninUI.Theme.Red, "That script doesn't exist\n")end

    return p:reject("That script doesn't exist")
  end
  local tests = tbl.tests
  if (!istable(tests) or (istable(tests) and #tests == 0)) then
    if print then MsgC(XeninUI.Theme.Red, "There are no tests for this script\n")end

    return p:reject("There are no tests for this script")
  end

  XeninUI.IsTesting = script
  local i = 0
  local time = 0
  local passes = 0
  local fails = 0
  local size = 0
  local msgs = {}
  local function nextTest()
    i = i + 1

    local promise = tests[i]
    if (!promise) then
      local successRate = math.Round((passes / size) * 100, 2)
      if printOut then
        MsgC(XeninUI.Theme.Yellow, "Took " .. tostring(time) .. "ms to run " .. tostring(size) .. " specs with " .. tostring(passes) .. " passes, " .. tostring(fails) .. " fails, and a pass rate of " .. tostring(successRate) .. "%\n")
      end

      p:resolve({
        time = time,
        passes = passes,
        fails = fails,
        size = size,
        msgs = msgs
      })

      XeninUI.IsTesting = nil
    else
      promise:run():next(function(result)
        time = time + result.executionTime
        passes = passes + result.successes
        fails = fails + result.errors
        size = size + result.size

        table.insert(msgs, result.msgs)

        if delay then
          timer.Simple(delay, function()
            nextTest()end)
        else
          nextTest()
        end
      end, function(err)
        print("test error", err)
        p:reject(err)
      end)
    end
  end

  nextTest()

  return p
end

concommand.Add("xenin_test", function(ply, cmd, args)
  if (IsValid(ply) and !XeninUI.Permissions:canAccessFramework(ply)) then return end

  XeninUI:Test(args[1], !tobool(args[2]), tonumber(args[3])):next(function(result) end, function(err)
    ErrorNoHalt(err .. "\n")end)
end)

--PATH lua/autorun/zyg_slave_lord_addon.lua:
return gluapack()()
--PATH addons/[tfres] frest_levels/lua/autorun/client/3d2dlib.lua:
return gluapack()()
--PATH lua/advdupe2/sh_codec_legacy.lua:
return gluapack()()
--PATH lua/autorun/client/boss_health_hud.lua:

	surface.CreateFont('MainFont',{
		font='Death Star',
		size=32
	})

    surface.CreateFont('BossFont',{
		font='Prototype',
		size=30,
		weight = 500
	})
    local republic_color = Color (255,255,255,255)
    local damage_color = Color (226,177,40,255)
    local totalbar = 700/1920
	local bossmaterial = Material( "bossbar/bossbar.png" )

----LOCALIZATION-----------------
	local BossDataTable = {}
	local BossBarBody
	local BossBarImage
	local BossBarLoss
	local BossBarHP
	local BossBarName
	local BossBarLabel
------------------------------------

local function RemoveBossHealth() // Removes boss bar
	if !bossHealthSystem:IsValidBoss() then return end
	local pos = Vector(9999,99999,99999) // Banishes the skull sprite on bosses
	timer.Create ("Bossbar_closetimer", 0.5, 1, function ()
	bossHealthSystem:RemoveBoss()
	timer.Remove("HealthUpdate")
	end)
end

net.Receive("boss_data", function(len) 
	local ent = net.ReadEntity()
	local name = net.ReadString()
	local label = net.ReadString()
	local icon = net.ReadString()
	if icon == "" then
		icon = "bossbar/default.png"
	end
	BossDataTable = {}
	BossDataTable.Name = name
	BossDataTable.Label = label
	BossDataTable.Icon = icon
end)

hook.Add("HUDPaint", "BossHealthBar.Render", function()
	if !bossHealthSystem:IsValidBoss() then return end
	if BossDataTable.Name == nil then return end

	local boss = bossHealthSystem:GetBoss()
	local boss_health = boss:Health()
	local boss_max_health = boss:GetMaxHealth()

	local boss_health_percent = math.Clamp(boss_health / boss_max_health, 0, 1)

	local boss_health_bar_width = totalbar * boss_health_percent * ScrW()

	surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	surface.SetMaterial( bossmaterial ) -- Use our cached material
	surface.DrawTexturedRect( ScrW()/3.5, ScrH()/12, ScrW()/2.35,75 ) -- Actually draw the boss bar

	surface.SetDrawColor( republic_color ) -- Set the drawing color
	surface.DrawRect(ScrW()/3.16, ScrH()/8,boss_health_bar_width,17) -- Boss HP Rectangle

	surface.SetFont( "MainFont" ) // LABEL
	surface.SetTextColor( 255, 255, 255 )
	surface.SetTextPos( ScrW()/3.16, ScrH()/11 ) 
	surface.DrawText(BossDataTable.Label)

	draw.DrawText(BossDataTable.Name, "BossFont", ScrW() * 0.5, ScrH()/11, Color(255,255,255,255), TEXT_ALIGN_CENTER)

	local material = Material( BossDataTable.Icon )
	local pos = boss:GetPos()
	pos:Add(Vector(0,0,90))
	cam.Start3D() -- Start the 3D function so we can draw onto the screen.
		render.SetMaterial( material ) -- Tell render what material we want, in this case the flash from the gravgun
		render.DrawSprite( pos, 16, 16, color_white) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
	cam.End3D()
end)
--PATH lua/permaprops/cl_menu.lua:
return gluapack()()
--PATH lua/autorun/client/cl_republic_conquest.lua:
return gluapack()()
--PATH lua/autorun/client/cl_republic_conquest.lua:
surface.CreateFont( "RepublicConquestFont", {
    font = "geometos",
    size = 20,
    weight = 500,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false
} )

surface.CreateFont( "RepublicConquestContested", {
    font = "geometos",
    size = 24,
    weight = 500,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false
} )

local function DrawIcon(icon, x, y, w, h)
    local mat = Material(icon)

    if not mat then mat = Material("republic_conquest/border.png") end

    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(mat)
    surface.DrawTexturedRect(x, y, w, h)
end

// Drawing variables
local lerpProgress = 0

net.Receive("RepublicConquest_ControlPointCaptured", function()
    surface.PlaySound("republic_conquest/capture.wav")
end)

hook.Add("HUDPaint", "RepublicConquest_HUDPaint", function()
    if not RepublicConquest.Point then return end

    local numPoints = table.Count(RepublicConquest.Point)

    if numPoints == 0 then return end

    local size = ScrH()/18
    local padding = 10

    local visiblePoints = {}
    for point, index in pairs(RepublicConquest.Point) do
        if IsValid(point) then
            if not point:GetUseProximity() or point:GetPos():Distance(LocalPlayer():GetPos()) <= point:GetProximityDistance() then
                table.insert(visiblePoints, {point = point, index = index})
            end
        end
    end

    table.sort(visiblePoints, function(a, b) return a.index < b.index end)

    local visibleCount = #visiblePoints
    local width = (size + padding) * visibleCount - padding
    -- local width = (size + padding) * numPoints - padding

    for index, data in ipairs(visiblePoints) do
        local point = data.point
        if not IsValid(point) then continue end

        local x = (ScrW() / 2) - (width / 2) + ((size + padding) * (index - 1))
        local y = ScrH() / 8

        local progress = point:GetProgress()
        local progressHeight = size * progress

        // Draw owner color background
        surface.SetDrawColor(point:GetPointColor())
        surface.DrawRect(x, y, size, size)

        // Draw progression
        surface.SetDrawColor(point:GetProgressorColor())
        surface.DrawRect(x, y + (size - progressHeight), size, progressHeight)

        DrawIcon(point:GetPointIcon(), x, y, size, size)
    end

    local controlPointInside = LocalPlayer():GetNWEntity("Conquest_ControlPoint")

    if controlPointInside == LocalPlayer() or not IsValid(controlPointInside) then return end

    // Progression Bar
    local barWidth = ScrW() / 4
    local barHeight = 20
    local progress = controlPointInside:GetProgress()

    // Interpolate the progress bar
    lerpProgress = Lerp(FrameTime() * 5, lerpProgress, progress)

    local progressWidth = barWidth * lerpProgress

    local barX = (ScrW() / 2) - (barWidth / 2)
    local barY = ScrH() / 8 + size + padding

    local barColor = Color(255, 255, 255, 200)
    
    if controlPointInside:GetProgress() ~= 0 then
        // Fade in and out the bar but subtly, the alpha doesn't go below 150.
        local alpha = math.abs(math.sin(CurTime() * 3) * 105) + 150
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(barX, barY, barWidth, barHeight)

        // Progression Bar Progress
        // If full, just draw the full bar.
        surface.SetDrawColor(255, 255, 255, alpha)
        surface.DrawRect(barX, barY, progressWidth, barHeight)
    end

    if controlPointInside:GetContested() then
        local alpha = math.abs(math.sin(CurTime() * 2) * 255)
        surface.SetFont("RepublicConquestContested")
        surface.SetTextColor(0, 150, 255, alpha)
        local w, h = surface.GetTextSize("Contested")
        surface.SetTextPos(ScrW() / 2 - w / 2, ScrH() / 8 + size + padding)
        surface.DrawText("Contested")
    end
end)

hook.Add("InitPostEntity", "RepublicConquest_Setup_Client", function()
    timer.Create("RepublicConquest_FetchPoints", 15, 6, function()
        RepublicConquest:FetchPoints()
    end)
end)
--PATH lua/autorun/client/vj_menu_weapon.lua:
return gluapack()()
--PATH lua/autorun/client/vj_menu_weapon.lua:
/*--------------------------------------------------
	=============== Weapon Menu ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
include('autorun/client/vj_menu_plugins.lua') 
---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_WEAPON_CLIENTSETTINGS(Panel) -- Client Settings
	Panel:AddControl("Label", {Text = "#vjbase.menu.clweapon.notice"})
	Panel:AddControl("Button",{Text = "#vjbase.menu.general.reset.everything", Command = "vj_wep_nomuszzleflash 0\n vj_wep_nobulletshells 0\n vj_wep_nomuszzleflash_dynamiclight 0"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.clweapon.togglemuzzle", Command = "vj_wep_nomuszzleflash"})
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.clweapon.togglemuzzlelight", Command = "vj_wep_nomuszzleflash_dynamiclight"})
	Panel:ControlHelp("#vjbase.menu.clweapon.togglemuzzle.label")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.clweapon.togglemuzzlebulletshells", Command = "vj_wep_nobulletshells"})
end
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateToolMenu", "VJ_ADDTOMENU_WEAPON", function()
	spawnmenu.AddToolMenuOption("DrVrej", "Weapons", "Weapon Client Settings", "#vjbase.menu.clweapon", "", "", VJ_WEAPON_CLIENTSETTINGS, {})
end)
--PATH lua/vgui/bvgui/checkbox_crossable.lua:
local PANEL = {}

local checked_mat = Material("vgui/bvgui/checked.png", "smooth")
local crossed_mat = Material("vgui/bvgui/cross.png", "smooth")

function PANEL:Init()
	self.Checked = 0

	self.CheckedOpacity = bVGUI.Lerp(0,0,.5)
	self.CrossedOpacity = bVGUI.Lerp(0,0,.5)
end

function PANEL:OnMouseReleased()
	self.Checked = self.Checked + 1
	if (self.Checked > 2) then self.Checked = 0 end
	if (self.OnChange) then
		self:OnChange()
	end
	self:UpdateOpacities()
	if (GAS) then
		if (self.Checked == 1) then
			GAS:PlaySound("btn_on")
		elseif (self.Checked == 2) then
			GAS:PlaySound("delete")
		else
			GAS:PlaySound("btn_off")
		end
	end
end

function PANEL:SetChecked(checked)
	self.Checked = math.Clamp(checked, 0, 2)
	self:UpdateOpacities()
end

function PANEL:UpdateOpacities()
	if (self.Checked == 1) then
		self.CheckedOpacity:SetTo(255)
	elseif (self.CheckedOpacity.to ~= 0) then
		self.CheckedOpacity:SetTo(0)
	end
	if (self.Checked == 2) then
		self.CrossedOpacity:SetTo(255)
	elseif (self.CrossedOpacity.to ~= 0) then
		self.CrossedOpacity:SetTo(0)
	end
end

local checkbox_bg = Color(47,53,66)
local check_size = 12
function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, checkbox_bg)

	self.CheckedOpacity:DoLerp()
	self.CrossedOpacity:DoLerp()

	surface.SetMaterial(checked_mat)
	surface.SetDrawColor(255,255,255,self.CheckedOpacity:GetValue())
	surface.DrawTexturedRect(w / 2 - check_size / 2, h / 2 - check_size / 2, check_size, check_size)

	surface.SetMaterial(crossed_mat)
	surface.SetDrawColor(255,255,255,self.CrossedOpacity:GetValue())
	surface.DrawTexturedRect(w / 2 - check_size / 2, h / 2 - check_size / 2, check_size, check_size)
end

derma.DefineControl("bVGUI.Checkbox_Crossable", nil, PANEL, "bVGUI.Checkbox")
--PATH lua/vgui/bvgui/grid.lua:
return gluapack()()
--PATH lua/vgui/bvgui/httplogo.lua:
return gluapack()()
--PATH lua/vgui/bvgui/mouseinfo_tooltip.lua:
return gluapack()()
--PATH lua/vgui/bvgui/toolbarbutton.lua:
--/// bVGUI.ToolbarButton_IMG ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")
	self.bVGUI_IMG = vgui.Create("DImage", self)
	self.bVGUI_IMG:SetSize(16,16)
end

function PANEL:Paint()
	if (self:IsHovered()) then
		if (not self._IsHovered) then
			self._IsHovered = true
			self.bVGUI_IMG:SetMaterial(self.HoverMaterial)
		end
	else
		if (self._IsHovered) then
			self._IsHovered = nil
			self.bVGUI_IMG:SetMaterial(self.DefaultMaterial)
		end
	end
end

function PANEL:SetMaterial(mat)
	self.bVGUI_IMG:SetMaterial(mat)
	self.DefaultMaterial = mat
end
function PANEL:SetHoverMaterial(mat)
	self.HoverMaterial = mat
end

function PANEL:OnMouseReleased()
	self:DoClick()
end

function PANEL:PerformLayout()
	self.bVGUI_IMG:Center()
end

derma.DefineControl("bVGUI.ToolbarButton_IMG", nil, PANEL, "DPanel")

--/// bVGUI.ToolbarButton_IMGText ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")

	self.bVGUI_IMG = vgui.Create("DImage", self)
	self.bVGUI_IMG:SetSize(16,16)

	self.bVGUI_Text = vgui.Create("DLabel", self)
	self.bVGUI_Text:SetText("Menu")
	self.bVGUI_Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	self.bVGUI_Text:SetTextColor(bVGUI.COLOR_DARK_GREY)
end

function PANEL:Paint()
	if (self:IsHovered()) then
		if (not self._IsHovered) then
			self._IsHovered = true
			self.bVGUI_IMG:SetMaterial(self.HoverMaterial)
			self.bVGUI_Text:SetTextColor(bVGUI.COLOR_WHITE)
		end
	else
		if (self._IsHovered) then
			self._IsHovered = nil
			self.bVGUI_IMG:SetMaterial(self.DefaultMaterial)
			self.bVGUI_Text:SetTextColor(bVGUI.COLOR_DARK_GREY)
		end
	end
end

function PANEL:SetMaterial(mat)
	self.bVGUI_IMG:SetMaterial(mat)
	self.DefaultMaterial = mat
end
function PANEL:SetHoverMaterial(mat)
	self.HoverMaterial = mat
end

function PANEL:SetText(txt)
	self.bVGUI_Text:SetText(txt)
	self:PerformLayout()
end

function PANEL:PerformLayout()
	self.bVGUI_IMG:AlignLeft(5)
	self.bVGUI_IMG:CenterVertical()

	self.bVGUI_Text:SizeToContents()
	self.bVGUI_Text:AlignLeft(5 + 16 + 5)
	self.bVGUI_Text:CenterVertical()

	self:SetWide(5 + 16 + 5 + self.bVGUI_Text:GetWide() + 5 + 2)
end

function PANEL:OnMouseReleased()
	self:DoClick()
end

derma.DefineControl("bVGUI.ToolbarButton_IMGText", nil, PANEL, "DPanel")
--PATH lua/vgui/bvgui/tooltip.lua:
return gluapack()()
--PATH lua/vgui/bvgui/tooltip.lua:
local bg_color = Color(43,48,58,255)

local PANEL = {}

function PANEL:Init()
	self:SetDrawOnTop(true)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.Label:SetText("Tooltip")
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetContentAlignment(5)
	self.Label:SetWrap(true)

	self.Arrow = {
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0}
	}
end

function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, self.BackgroundColor or bg_color)
	surface.DisableClipping(true)

	surface.SetDrawColor(self.BackgroundColor or bg_color)
	draw.NoTexture()

	self.Arrow[1].x = w / 2 - 7
	self.Arrow[1].y = h

	self.Arrow[2].x = w / 2 + 7
	self.Arrow[2].y = h

	self.Arrow[3].x = w / 2
	self.Arrow[3].y = h + 7

	surface.DrawPoly(self.Arrow)

	surface.DisableClipping(false)
end

function PANEL:Think()
	local x,y = self.Label:GetSize()
	self:SetSize(x + 15, y + 7)
	self.Label:Center()

	local x,y = gui.MousePos()
	self.XPos = Lerp(FrameTime() * 15, self.XPos or x, x)
	self.YPos = Lerp(FrameTime() * 15, self.YPos or y, y)
	
	self:SetPos(self.XPos - self:GetWide() / 2, self.YPos - self:GetTall() - 14 - 5)

	if (not system.HasFocus()) then
		self:Remove()
	elseif (self.VGUI_Element) then
		if (not IsValid(self.VGUI_Element)) then
			self:Remove()
		elseif (vgui.GetHoveredPanel() ~= self.VGUI_Element) then
			if (self.HoverFrameNumber) then
				if (FrameNumber() > self.HoverFrameNumber) then
					self:Remove()
				end
			else
				self.HoverFrameNumber = FrameNumber() + 1
			end
		end
	end
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self.Label:SetWrap(false)
	self.Label:SizeToContentsX()
	if (self.Label:GetWide() >= 200) then
		self.Label:SetWide(200)
		self.Label:SetWrap(true)
		self.Label:SetAutoStretchVertical(true)
	end
end
function PANEL:GetText()
	return self.Label:GetText()
end

function PANEL:SetTextColor(col)
	self.Label:SetTextColor(col)
end
function PANEL:GetTextColor()
	return self.Label:GetTextColor()
end

function PANEL:SetBackgroundColor(col)
	self.BackgroundColor = col
end
function PANEL:GetBackgroundColor()
	return self.BackgroundColor
end

function PANEL:SetVGUIElement(elem)
	self.VGUI_Element = elem
end
function PANEL:GetVGUIElement()
	return self.VGUI_Element
end

derma.DefineControl("bVGUI.Tooltip", nil, PANEL, "DPanel")

bVGUI.CreateTooltip = function(options)
	bVGUI.DestroyTooltip()

	bVGUI.Tooltip = vgui.Create("bVGUI.Tooltip")
	bVGUI.Tooltip:SetVGUIElement(options.VGUI_Element)
	bVGUI.Tooltip:SetText(options.Text)
	bVGUI.Tooltip:SetTextColor(options.TextColor or bVGUI.COLOR_WHITE)
	bVGUI.Tooltip:SetBackgroundColor(options.BackgroundColor or bg_color)
end
bVGUI.DestroyTooltip = function()
	if (IsValid(bVGUI.Tooltip)) then
		if (bVGUI.Tooltip.Closing ~= true) then
			bVGUI.Tooltip:Remove()
		end
	end
end

bVGUI.AttachTooltip = function(pnl, options)
	pnl:SetMouseInputEnabled(true)
	options.VGUI_Element = pnl
	if (pnl.bVGUI_TooltipOptions) then
		pnl.bVGUI_TooltipOptions = options
		return
	else
		pnl.bVGUI_TooltipOptions = options
	end

	pnl.bVGUI_TOOLTIP_OLD_CURSOR_ENTER = pnl.bVGUI_TOOLTIP_OLD_CURSOR_ENTER or pnl.OnCursorEntered
	pnl.bVGUI_TOOLTIP_OLD_CURSOR_EXIT = pnl.bVGUI_TOOLTIP_OLD_CURSOR_EXIT or pnl.OnCursorExited
	function pnl:OnCursorEntered(...)
		bVGUI.CreateTooltip(self.bVGUI_TooltipOptions)
		if (self.bVGUI_TOOLTIP_OLD_CURSOR_ENTER) then self.bVGUI_TOOLTIP_OLD_CURSOR_ENTER(self, ...) end
	end
	function pnl:OnCursorExited(...)
		bVGUI.DestroyTooltip()
		if (self.bVGUI_TOOLTIP_OLD_CURSOR_EXIT) then self.bVGUI_TOOLTIP_OLD_CURSOR_EXIT(self, ...) end
	end
end

bVGUI.UnattachTooltip = function(pnl)
	pnl.bVGUI_TooltipOptions = nil
	pnl.OnCursorEntered = pnl.bVGUI_TOOLTIP_OLD_CURSOR_ENTER
	pnl.OnCursorExited = pnl.bVGUI_TOOLTIP_OLD_CURSOR_EXIT
end
--PATH lua/vgui/bvgui/vertical_option_selector.lua:
local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	self.Buttons = {}
	self.Color = bVGUI.BUTTON_COLOR_BLUE
	self.BorderColor = bVGUI.DarkenColor(self.Color, 0.4)

	self.SelectedButton = 1
end

function PANEL:SetColor(col)
	self.Color = col
	self.BorderColor = bVGUI.DarkenColor(self.Color, 0.4)
end

function PANEL:SelectButton(index)
	self.SelectedButton = index
end

function PANEL:AddButton(text, color)
	local label = vgui.Create("DLabel", self)
	label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	label:SetContentAlignment(5)
	label:SetTextColor(bVGUI.COLOR_WHITE)
	label:SetText(text)
	label.BtnColor = color
	label.BtnBorderColor = bVGUI.DarkenColor(color, 0.4)
	table.insert(self.Buttons, label)

	self:SizeButtons()
end

local grey_col = Color(150,150,150)
local dark_grey_col = bVGUI.DarkenColor(grey_col, 0.4)
function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, dark_grey_col)
	draw.RoundedBoxEx(4, 0, 0, w, h - 4, grey_col, true, true)

	for i,v in ipairs(self.Buttons) do
		draw.RoundedBox(4, 0, (i * (h / #self.Buttons)) - 4, w, 4, dark_grey_col)
	end

	if (IsValid(self.Buttons[self.SelectedButton])) then
		local btn = self.Buttons[self.SelectedButton]

		if (self.LerpY == nil) then
			self.LerpY = (self.SelectedButton - 1) * (h / #self.Buttons)
		else
			self.LerpY = Lerp(FrameTime() * 10, self.LerpY, (self.SelectedButton - 1) * (h / #self.Buttons))
		end

		if (self.LerpBorderColor == nil) then
			self.LerpBorderColor = Color(btn.BtnBorderColor.r, btn.BtnBorderColor.g, btn.BtnBorderColor.b)
		else
			self.LerpBorderColor.r = Lerp(FrameTime() * 10, self.LerpBorderColor.r, btn.BtnBorderColor.r)
			self.LerpBorderColor.g = Lerp(FrameTime() * 10, self.LerpBorderColor.g, btn.BtnBorderColor.g)
			self.LerpBorderColor.b = Lerp(FrameTime() * 10, self.LerpBorderColor.b, btn.BtnBorderColor.b)
		end

		if (self.LerpColor == nil) then
			self.LerpColor = Color(btn.BtnColor.r, btn.BtnColor.g, btn.BtnColor.b)
		else
			self.LerpColor.r = Lerp(FrameTime() * 10, self.LerpColor.r, btn.BtnColor.r)
			self.LerpColor.g = Lerp(FrameTime() * 10, self.LerpColor.g, btn.BtnColor.g)
			self.LerpColor.b = Lerp(FrameTime() * 10, self.LerpColor.b, btn.BtnColor.b)
		end

		draw.RoundedBoxEx(4, 0, self.LerpY, w, h / #self.Buttons, self.LerpBorderColor, true, true, self.SelectedButton == #self.Buttons, self.SelectedButton == #self.Buttons)
		draw.RoundedBoxEx(4, 0, self.LerpY, w, (h / #self.Buttons) - 4, self.LerpColor, self.SelectedButton == 1, self.SelectedButton == 1)
	end
end

function PANEL:SizeButtons()
	local w = 0
	for _,v in ipairs(self.Buttons) do
		v:SizeToContents()
		if (v:GetWide() > w) then
			w = v:GetWide()
		end
	end
	self:SetWide(w + 20)
	for i,v in ipairs(self.Buttons) do
		v:SetWide(w)
	end
end

function PANEL:PerformLayout(w,h)
	for i,v in ipairs(self.Buttons) do
		v:SetSize(w,h / #self.Buttons)
		v:AlignTop((i - 1) * (h / #self.Buttons) - 2)
	end
end

function PANEL:OnMousePressed(m)
	self.MousePressed = m
end
function PANEL:OnMouseReleased(m)
	if (self.MousePressed == m) then
		if (m == MOUSE_LEFT) then
			local x,y = self:ScreenToLocal(gui.MousePos())
			self.SelectedButton = 1 + math.floor((y / self:GetTall()) * #self.Buttons)
			local btn = self.Buttons[self.SelectedButton]
			if (IsValid(btn)) then
				if (self.OptionChanged) then
					self:OptionChanged(btn:GetText())
				end
			end
		end
	end
end

derma.DefineControl("bVGUI.VerticalOptionSelector", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/cl_fbutton.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/vgui/gas_logging_damagelog.lua:
return gluapack()()
--PATH lua/vgui/gas_workshop_item.lua:
return gluapack()()
--PATH lua/vgui/openpermissions_addon.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/matproxy/dlt23v_matproxy.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/matproxy/dlt23v_matproxy.lua:

if SERVER then return end

matproxy.Add({
	name = "dlt_heat",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if not IsValid(ent) then return end
		if not ent.GetHeat 
		and not (IsValid(ent:GetOwner()) and (ent:GetOwner().GetHeat
		or (ent:GetOwner().GetActiveWeapon and IsValid(ent:GetOwner():GetActiveWeapon()) and ent:GetOwner():GetActiveWeapon().GetHeat) ) )  then
			mat:SetFloat(self.ResultTo, "0")
			return
		end

		if IsValid(ent:GetOwner()) and ent:GetOwner().GetActiveWeapon and IsValid(ent:GetOwner():GetActiveWeapon()) and ent:GetOwner():GetActiveWeapon().GetHeat then
			ent = ent:GetOwner():GetActiveWeapon()
		end

		if not ent.GetHeat then
			mat:SetFloat(self.ResultTo, "0")
			return
		end

		mat:SetFloat(self.ResultTo, tostring(ent:GetHeat()))
	end
})
--PATH gamemodes/starwarsrp/gamemode/libraries/interfaceloader.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/hungermod/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/hud/cl_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/hitmenu/cl_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/f4menu/cl_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/doorsystem/sh_interface.lua:
DarkRP.ENTITY.getDoorData = DarkRP.stub{
    name = "getDoorData",
    description = "Internal function to get the door/vehicle data.",
    parameters = {
    },
    returns = {
        {
            name = "doordata",
            description = "All the DarkRP information on a door or vehicle.",
            type = "table"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.isKeysOwnable = DarkRP.stub{
    name = "isKeysOwnable",
    description = "Whether this door can be bought.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether the door can be bought.",
            type = "boolean"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.isDoor = DarkRP.stub{
    name = "isDoor",
    description = "Whether this entity is considered a door in DarkRP.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether it's a door.",
            type = "boolean"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.isKeysOwned = DarkRP.stub{
    name = "isKeysOwned",
    description = "Whether this door is owned by someone.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether it's owned.",
            type = "boolean"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.getDoorOwner = DarkRP.stub{
    name = "getDoorOwner",
    description = "Get the owner of a door.",
    parameters = {
    },
    returns = {
        {
            name = "owner",
            description = "The owner of the door.",
            type = "Player"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.isMasterOwner = DarkRP.stub{
    name = "isMasterOwner",
    description = "Whether the player is the main owner of the door (as opposed to a co-owner).",
    parameters = {
        {
            name = "ply",
            description = "The player to query.",
            type = "Player",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is the master owner.",
            type = "boolean"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.isKeysOwnedBy = DarkRP.stub{
    name = "isKeysOwnedBy",
    description = "Whether this door is owned or co-owned by this player",
    parameters = {
        {
            name = "ply",
            description = "The player to query.",
            type = "Player",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether this door is (co-)owned by the player.",
            type = "boolean"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.isKeysAllowedToOwn = DarkRP.stub{
    name = "isKeysAllowedToOwn",
    description = "Whether this player is allowed to co-own a door, as decided by the master door owner.",
    parameters = {
        {
            name = "ply",
            description = "The player to query.",
            type = "Player",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether this door is (co-)ownable by the player.",
            type = "boolean"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.getKeysNonOwnable = DarkRP.stub{
    name = "getKeysNonOwnable",
    description = "Whether ownability of this door/vehicle is disabled.",
    parameters = {
    },
    returns = {
        {
            name = "title",
            description = "The ownability status.",
            type = "boolean"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.getKeysTitle = DarkRP.stub{
    name = "getKeysTitle",
    description = "Get the title of this door or vehicle.",
    parameters = {
    },
    returns = {
        {
            name = "title",
            description = "The title of the door or vehicle.",
            type = "string"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.getKeysDoorGroup = DarkRP.stub{
    name = "getKeysDoorGroup",
    description = "The door group of a door if it exists.",
    parameters = {
    },
    returns = {
        {
            name = "group",
            description = "The door group.",
            type = "string"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.getKeysDoorTeams = DarkRP.stub{
    name = "getKeysDoorTeams",
    description = "The teams that are allowed to open this door.",
    parameters = {
    },
    returns = {
        {
            name = "teams",
            description = "The door teams.",
            type = "table"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.getKeysAllowedToOwn = DarkRP.stub{
    name = "getKeysAllowedToOwn",
    description = "The list of people of which the master door owner has added as allowed to own.",
    parameters = {
    },
    returns = {
        {
            name = "players",
            description = "The list of people allowed to own.",
            type = "table"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.ENTITY.getKeysCoOwners = DarkRP.stub{
    name = "getKeysCoOwners",
    description = "The list of people who co-own the door.",
    parameters = {
    },
    returns = {
        {
            name = "players",
            description = "The list of people allowed to own. The keys of this table are UserIDs, the values are booleans.",
            type = "table"
        }
    },
    metatable = DarkRP.ENTITY
}

DarkRP.PLAYER.canKeysLock = DarkRP.stub{
    name = "canKeysLock",
    description = "Whether the player can lock a given door.",
    parameters = {
        {
            name = "door",
            description = "The door",
            optional = false,
            type = "Entity"
        }
    },
    returns = {
        {
            name = "allowed",
            description = "Whether the player is allowed to lock the door.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.canKeysUnlock = DarkRP.stub{
    name = "canKeysUnlock",
    description = "Whether the player can unlock a given door.",
    parameters = {
        {
            name = "door",
            description = "The door",
            optional = false,
            type = "Entity"
        }
    },
    returns = {
        {
            name = "allowed",
            description = "Whether the player is allowed to unlock the door.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.registerDoorVar = DarkRP.stub{
    name = "registerDoorVar",
    description = "Register a door variable by name. You should definitely register door variables. Registering DarkRPVars will make networking much more efficient.",
    parameters = {
        {
            name = "name",
            description = "The name of the door var.",
            type = "string",
            optional = false
        },
        {
            name = "writeFn",
            description = "The function that writes a value for this door var. Examples: net.WriteString, function(val) net.WriteUInt(val, 8) end.",
            type = "function",
            optional = false
        },
        {
            name = "readFn",
            description = "The function that reads and returns a value for this door var. Examples: net.ReadString, function() return net.ReadUInt(8) end.",
            type = "function",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getDoorVars = DarkRP.stub{
    name = "getDoorVars",
    description = "Internal function, retrieves all the registered door variables.",
    parameters = {

    },
    returns = {
        {
            name = "doorvars",
            description = "The door variables, indexed by number",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getDoorVarsByName = DarkRP.stub{
    name = "getDoorVarsByName",
    description = "Internal function, retrieves all the registered door variables, indeded by their names.",
    parameters = {

    },
    returns = {
        {
            name = "doorvars",
            description = "The door variables, indexed by name",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "canKeysLock",
    description = "Whether the player can lock a given door. This hook is run when ply:canKeysLock is called.",
    parameters = {
        {
            name = "ply",
            description = "The player",
            type = "Player"
        },
        {
            name = "door",
            description = "The door",
            type = "Entity"
        }
    },
    returns = {
        {
            name = "allowed",
            description = "Whether the player is allowed to lock the door.",
            type = "boolean"
        }
    }
}

DarkRP.hookStub{
    name = "canKeysUnlock",
    description = "Whether the player can unlock a given door. This hook is run when ply:canKeysUnlock is called.",
    parameters = {
        {
            name = "ply",
            description = "The player",
            type = "Player"
        },
        {
            name = "door",
            description = "The door",
            type = "Entity"
        }
    },
    returns = {
        {
            name = "allowed",
            description = "Whether the player is allowed to unlock the door.",
            type = "boolean"
        }
    }
}

--PATH gamemodes/starwarsrp/gamemode/modules/doorsystem/cl_interface.lua:
DarkRP.readNetDoorVar = DarkRP.stub{
    name = "readNetDoorVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DoorVar net messages. This function reads the net data for a specific DoorVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DoorVar.",
            type = "string"
        },
        {
            name = "value",
            description = "The value of the DoorVar.",
            type = "any"
        }
    },
    metatable = DarkRP
}

DarkRP.ENTITY.drawOwnableInfo = DarkRP.stub{
    name = "drawOwnableInfo",
    description = "Draw the ownability information on a door or vehicle.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP.ENTITY
}

DarkRP.hookStub{
    name = "HUDDrawDoorData",
    description = "Called when DarkRP is about to draw the door ownability information of a door or vehicle. Override this hook to ",
    parameters = {
        {
            name = "ent",
            description = "The door or vehicle of which the ownability information is about to be drawn.",
            type = "Entity"
        }
    },
    returns = {
        {
            name = "override",
            description = "Return true in your hook to disable the default drawing and use your own.",
            type = "boolean"
        }
    }
}

--PATH gamemodes/starwarsrp/gamemode/modules/chatindicator/cl_interface.lua:
DarkRP.hookStub{
    name = "DrawChatIndicator",
    description = "Call when the Chat Indicator is drawn. Return to overwrite.",
    parameters = {
        {
            name = "ply",
            description = "The player the indicator should be drawn for.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "override",
            description = "Return true in your hook to disable the default drawing.",
            type = "boolean"
        }
    }
}

--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_interface.lua:
DarkRP.registerDarkRPVar = DarkRP.stub{
    name = "registerDarkRPVar",
    description = "Register a DarkRPVar by name. You should definitely register DarkRPVars. Registering DarkRPVars will make networking much more efficient.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        },
        {
            name = "writeFn",
            description = "The function that writes a value for this DarkRPVar. Examples: net.WriteString, function(val) net.WriteUInt(val, 8) end.",
            type = "function",
            optional = false
        },
        {
            name = "readFn",
            description = "The function that reads and returns a value for this DarkRPVar. Examples: net.ReadString, function() return net.ReadUInt(8) end.",
            type = "function",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.writeNetDarkRPVar = DarkRP.stub{
    name = "writeNetDarkRPVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when sending DarkRPVar net messages. This function writes the net data for a specific DarkRPVar.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        },
        {
            name = "value",
            description = "The value of the DarkRPVar.",
            type = "any",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.writeNetDarkRPVarRemoval = DarkRP.stub{
    name = "writeNetDarkRPVarRemoval",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when sending DarkRPVar net messages. This function sets a DarkRPVar to nil.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.readNetDarkRPVar = DarkRP.stub{
    name = "readNetDarkRPVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DarkRPVar net messages. This function reads the net data for a specific DarkRPVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string"
        },
        {
            name = "value",
            description = "The value of the DarkRPVar.",
            type = "any"
        }
    },
    metatable = DarkRP
}

DarkRP.readNetDarkRPVarRemoval = DarkRP.stub{
    name = "readNetDarkRPVarRemoval",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DarkRPVar net messages. This function the removal of a DarkRPVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.findPlayer = DarkRP.stub{
    name = "findPlayer",
    description = "Find a single player based on vague information.",
    parameters = {
        {
            name = "info",
            description = "The information of the player (UserID, SteamID, name).",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "found",
            description = "The player that matches the description.",
            type = "Player"
        }
    },
    metatable = DarkRP
}

DarkRP.findPlayers = DarkRP.stub{
    name = "findPlayers",
    description = "Find a list of players based on vague information.",
    parameters = {
        {
            name = "info",
            description = "The information of the player (UserID, SteamID, name).",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "found",
            description = "Table of players that match the description.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.nickSortedPlayers = DarkRP.stub{
    name = "nickSortedPlayers",
    description = "A table of players sorted by RP name.",
    parameters = {},
    returns = {
        {
            name = "players",
            description = "The list of players sorted by RP name.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.explodeArg = DarkRP.stub{
    name = "explodeArg",
    description = "String arguments exploded into a table. It accounts for substrings in quotes, which makes it more intelligent than string.Explode",
    parameters = {
        {
            name = "arg",
            description = "The full string of the argument",
            type = "string",
            optional = false
        },
    },
    returns = {
        {
            name = "args",
            description = "The table of arguments",
            type = "table"
        }
    },
    metatable = DarkRP
}


DarkRP.formatMoney = DarkRP.stub{
    name = "formatMoney",
    description = "Format a number as a money value. Includes currency symbol.",
    parameters = {
        {
            name = "amount",
            description = "The money to format, e.g. 100000.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "money",
            description = "The money as a nice string, e.g. \"$100,000\".",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.getJobByCommand = DarkRP.stub{
    name = "getJobByCommand",
    description = "Get the job table and number from the command of the job.",
    parameters = {
        {
            name = "command",
            description = "The command of the job, without preceding slash (e.g. 'medic' for medic)",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "tbl",
            description = "A table containing all information about the job.",
            type = "table"
        },
        {
            name = "jobindex",
            description = "The index of the job (for 'medic' it's the value of TEAM_MEDIC).",
            type = "number"
        }
    },
    metatable = DarkRP
}

DarkRP.simplerrRun = DarkRP.stub{
    name = "simplerrRun",
    description = "Run a function with the given parameters and send any runtime errors to admins.",
    parameters = {
        {
            name = "f",
            description = "The function to be called.",
            type = "function",
            optional = false
        },
        {
            name = "args",
            description = "The arguments to be given to f.",
            type = "vararg",
            optional = true
        },
    },
    returns = {
        {
            name = "retVals",
            description = "The return values of f.",
            type = "vararg"
        }
    },
    metatable = DarkRP
}

DarkRP.error = DarkRP.stub{
    name = "error",
    description = "Throw a simplerr formatted error. Also halts the stack, which means that statements after calling this function will not execute.",
    parameters = {
        {
            name = "message",
            description = "The message of the error.",
            type = "string",
            optional = false
        },
        {
            name = "stack",
            description = "From which point in the function call stack to report the error. 1 to include the function that called DarkRP.error, 2 to exclude it, etc. The default value is 1.",
            type = "number",
            optional = true
        },
        {
            name = "hints",
            description = "Table containing hint strings. Use these hints to explain the error, describe possible causes or provide help to solve the problem.",
            type = "table",
            optional = true
        },
        {
            name = "path",
            description = "Override the path of the error. Will be shown in the error message. By default this is determined by the stack level.",
            type = "string",
            optional = true
        },
        {
            name = "line",
            description = "Override the line number of the error. By default this is determined by the stack level.",
            type = "number",
            optional = true
        },

    },
    returns = {
        {
            name = "succeed",
            description = "Simplerr return value: whether the calculation succeeded. Always false. This return value will never be reached.",
            type = "boolean"
        },
        {
            name = "msg",
            description = "Simplerr return value: nicely formatted error message. This return value will never be reached.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.errorNoHalt = DarkRP.stub{
    name = "errorNoHalt",
    description = "Throw a simplerr formatted error. Unlike DarkRP.error, this does not halt the stack. This means that statements after calling this function will be executed like normal.",
    parameters = {
        {
            name = "message",
            description = "The message of the error.",
            type = "string",
            optional = false
        },
        {
            name = "stack",
            description = "From which point in the function call stack to report the error. 1 to include the function that called DarkRP.error, 2 to exclude it, etc. The default value is 1.",
            type = "number",
            optional = true
        },
        {
            name = "hints",
            description = "Table containing hint strings. Use these hints to explain the error, describe possible causes or provide help to solve the problem.",
            type = "table",
            optional = true
        },
        {
            name = "path",
            description = "Override the path of the error. Will be shown in the error message. By default this is determined by the stack level.",
            type = "string",
            optional = true
        },
        {
            name = "line",
            description = "Override the line number of the error. By default this is determined by the stack level.",
            type = "number",
            optional = true
        },

    },
    returns = {
        {
            name = "succeed",
            description = "Simplerr return value: whether the calculation succeeded. Always false.",
            type = "boolean"
        },
        {
            name = "msg",
            description = "Simplerr return value: nicely formatted error message.",
            type = "string"
        }
    },
    metatable = DarkRP
}

-- This function is one of the few that's already defined before the stub is created
DarkRP.stub{
    name = "SteamName",
    description = "Retrieve a player's real (steam) name.",
    parameters = {

    },
    returns = {
        {
            name = "name",
            description = "The player's steam name.",
            type = "string"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getJobTable = DarkRP.stub{
    name = "getJobTable",
    description = "Get the job table of a player.",
    parameters = {
    },
    returns = {
        {
            name = "job",
            description = "Table with the job information.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getDarkRPVar = DarkRP.stub{
    name = "getDarkRPVar",
    description = "Get the value of a DarkRPVar, which is shared between server and client.",
    parameters = {
        {
            name = "var",
            description = "The name of the variable.",
            type = "string",
            optional = false
        },
        {
            name = "fallback",
            description = "The value to return if the DarkRPVar doesn't exist.",
            type = "any",
            optional = true
        }
    },
    returns = {
        {
            name = "value",
            description = "The value of the DarkRP var.",
            type = "any"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getAgenda = DarkRP.stub{
    name = "getAgenda",
    description = "Get the agenda a player manages.",
    deprecated = "Use ply:getAgendaTable() instead.",
    parameters = {
    },
    returns = {
        {
            name = "agenda",
            description = "The agenda.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getAgendaTable = DarkRP.stub{
    name = "getAgendaTable",
    description = "Get the agenda a player can see. Note: when a player is not the manager of an agenda, it returns the agenda of the manager.",
    parameters = {
    },
    returns = {
        {
            name = "agenda",
            description = "The agenda.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.hasDarkRPPrivilege = DarkRP.stub{
    name = "hasDarkRPPrivilege",
    description = "Whether the player has a certain privilege.",
    parameters = {
        {
            name = "priv",
            description = "The name of the privilege.",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player has the privilege.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getEyeSightHitEntity = DarkRP.stub{
    name = "getEyeSightHitEntity",
    description = "Get the entity that is closest to a player's line of sight and its distance.",
    parameters = {
        {
            name = "searchDistance",
            description = "How far to look. You usually don't want this function to return an entity millions of units away. The default is 100 units.",
            type = "number",
            optional = true
        },
        {
            name = "hitDistance",
            description = "The maximum distance between the player's line of sight and the object. Basically how far the player can be 'looking away' from the object. The default is 15 units.",
            type = "number",
            optional = true
        },
        {
            name = "filter",
            description = "The filter for which entities to look for. By default it only looks for players.",
            type = "function",
            optional = true
        }
    },
    returns = {
        {
            name = "closestEnt",
            description = "The entity that is closest to the player's line of sight. Returns nil when not found.",
            type = "Entity"
        },
        {
            name = "distance",
            description = "The (minimum) distance between the player's line of sight and the object.",
            type = "number"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.VECTOR.isInSight = DarkRP.stub{
    name = "isInSight",
    description = "Decides whether the vector could be seen by the player if they were to look at it.",
    parameters = {
        {
            name = "filter",
            description = "Trace filter that decides what the player can see through.",
            type = "table",
            optional = false
        },
        {
            name = "ply",
            description = "The player for whom the vector may or may not be visible.",
            type = "Player",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player can see the position.",
            type = "boolean"
        },
        {
            name = "HitPos",
            description = "The position of the thing that blocks the player's sight.",
            type = "Vector"
        }
    },
    metatable = DarkRP.VECTOR
}

DarkRP.hookStub{
    name = "UpdatePlayerSpeed",
    description = "Change a player's walking and running speed.",
    deprecated = "Use GMod's SetupMove and Move hooks instead.",
    parameters = {
        {
            name = "ply",
            description = "The player for whom the speed changes.",
            type = "Player"
        }
    },
    returns = {
    }
}

--[[---------------------------------------------------------------------------
Creating custom items
---------------------------------------------------------------------------]]
DarkRP.createJob = DarkRP.stub{
    name = "createJob",
    description = "Create a job for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the job.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the job.",
            type = "table",
            optional = false
        }
    },
    returns = {
        {
            name = "team",
            description = "The team number of the job you've created.",
            type = "number"
        }
    },
    metatable = DarkRP
}
AddExtraTeam = DarkRP.createJob

DarkRP.removeJob = DarkRP.stub{
    name = "removeJob",
    description = "Remove a job from DarkRP.",
    parameters = {
        {
            name = "i",
            description = "The TEAM_ number of the job. Also the index of the job in RPExtraTeams.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeShipment = DarkRP.stub{
    name = "removeShipment",
    description = "Remove a shipment from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeVehicle = DarkRP.stub{
    name = "removeVehicle",
    description = "Remove a vehicle from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeEntity = DarkRP.stub{
    name = "removeEntity",
    description = "Remove an entity from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeGroupChat = DarkRP.stub{
    name = "removeGroupChat",
    description = "Remove a groupchat from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeAmmoType = DarkRP.stub{
    name = "removeAmmoType",
    description = "Remove an ammotype from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeEntityGroup = DarkRP.stub{
    name = "removeEntityGroup",
    description = "Remove an entitygroup from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeAgenda = DarkRP.stub{
    name = "removeAgenda",
    description = "Remove a agenda from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeDemoteGroup = DarkRP.stub{
    name = "removeDemoteGroup",
    description = "Remove an demotegroup from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.createEntityGroup = DarkRP.stub{
    name = "createEntityGroup",
    description = "Create a entity group for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the entity group.",
            type = "string",
            optional = false
        },
        {
            name = "teamNrs",
            description = "Vararg team numbers.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddDoorGroup = DarkRP.createEntityGroup

DarkRP.createShipment = DarkRP.stub{
    name = "createShipment",
    description = "Create a shipment for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the shipment.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the shipment.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomShipment = DarkRP.createShipment

DarkRP.createVehicle = DarkRP.stub{
    name = "createVehicle",
    description = "Create a vehicle for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the vehicle.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the vehicle.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomVehicle = DarkRP.createVehicle

DarkRP.createEntity = DarkRP.stub{
    name = "createEntity",
    description = "Create a entity for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the entity.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the entity.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomVehicle = DarkRP.createEntity

DarkRP.createAgenda = DarkRP.stub{
    name = "createAgenda",
    description = "Create an agenda for groups of jobs to communicate.",
    parameters = {
        {
            name = "title",
            description = "The name of the agenda.",
            type = "string",
            optional = false
        },
        {
            name = "manager",
            description = "The team numer of the manager of the agenda (the one who can set the agenda).",
            type = "number",
            optional = false
        },
        {
            name = "listeners",
            description = "The jobs that can see this agenda.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddAgenda = DarkRP.createAgenda

DarkRP.getAgendas = DarkRP.stub{
    name = "getAgendas",
    description = "Get all agendas. Note: teams that share an agenda use the exact same agenda table. E.g. when you change the agenda of the CP, the agenda of the Chief will automatically be updated as well. Make sure this property is maintained when modifying the agenda table. Not maintaining that property will lead to players not seeing the right agenda text.",
    parameters = {

    },
    returns = {
        {
            name = "agendas",
            description = "Table in which the keys are team numbers and the values agendas.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.createGroupChat = DarkRP.stub{
    name = "createGroupChat",
    description = "Create a group chat.",
    parameters = {
        {
            name = "functionOrJob",
            description = "A function that returns whether the person can see the group chat, or a team number.",
            type = "any",
            optional = false
        },
        {
            name = "teamNr",
            description = "VarArg team number.",
            type = "number",
            optional = true
        }
    },
    returns = {
    },
    metatable = DarkRP
}
GM.AddGroupChat = DarkRP.createGroupChat

DarkRP.createAmmoType = DarkRP.stub{
    name = "createAmmoType",
    description = "Create an ammo type.",
    parameters = {
        {
            name = "name",
            description = "The name of the ammo.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the ammo.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.createDemoteGroup = DarkRP.stub{
    name = "createDemoteGroup",
    description = "Create a demote group. When you get banned (demoted) from one of the jobs in this group, you will be banned from every job in this group.",
    parameters = {
        {
            name = "name",
            description = "The name of the demote group.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table consisting of a list of job.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getDemoteGroup = DarkRP.stub{
    name = "getDemoteGroup",
    description = "Get the demote group of a team. Every team in the same group will return the same object.",
    parameters = {
        {
            name = "teamNr",
            description = "Table consisting of a list of job.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "set",
            description = "The demote group identifier.",
            type = "Disjoint-Set"
        }
    },
    metatable = DarkRP
}

DarkRP.getGroupChats = DarkRP.stub{
    name = "getGroupChats",
    description = "Get all group chats.",
    parameters = {

    },
    returns = {
        {
            name = "set",
            description = "Table with functions that decide who can hear who.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getDemoteGroups = DarkRP.stub{
    name = "getDemoteGroups",
    description = "Get all demote groups Every team in the same group will return the same object.",
    parameters = {

    },
    returns = {
        {
            name = "set",
            description = "Table in which the keys are team numbers and the values Disjoint-Set.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.createCategory = DarkRP.stub{
    name = "createCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "tbl",
            description = "Table describing the category.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.addToCategory = DarkRP.stub{
    name = "addToCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "item",
            description = "Table of the custom entity/job/etc.",
            type = "table",
            optional = false
        },
        {
            name = "kind",
            description = "The kind of the category (e.g. 'jobs' for job stuff).",
            type = "string",
            optional = false
        },
        {
            name = "cat",
            description = "The name of the category. Note that the category must exist. Defaults to 'Other'.",
            type = "string",
            optional = true
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeFromCategory = DarkRP.stub{
    name = "removeFromCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "item",
            description = "Table of the custom entity/job/etc.",
            type = "table",
            optional = false
        },
        {
            name = "kind",
            description = "The kind of the category (e.g. 'jobs' for job stuff).",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getCategories = DarkRP.stub{
    name = "getCategories",
    description = "Get all categories for all F4 menu tabs.",
    parameters = {
    },
    returns = {
        {
            name = "tbl",
            description = "all categories.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.ValidatedPhysicsInit = DarkRP.stub{
    name = "ValidatedPhysicsInit",
    description = "Initialise the physics of an entity, throw a discriptive error when this fails.",
    parameters = {
        {
            name = "ent",
            description = "Entity for which to create the PhysObj.",
            type = "entity",
            optional = false
        },
        {
            name = "kind",
            description = "The SOLID_ enum type. By default this is SOLID_VPHYSICS",
            type = "number",
            optional = true
        },
        {
            name = "hint",
            description = "Optional hint for the error message.",
            type = "string",
            optional = true
        }
    },
    returns = {
        {
            name = "success",
            description = "Whether creating the PhysObj succeeded",
            type = "boolean"
        }
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "DarkRPVarChanged",
    description = "Called when a DarkRPVar was changed.",
    parameters = {
        {
            name = "ply",
            description = "The player for whom the DarkRPVar changed.",
            type = "Player"
        },
        {
            name = "varname",
            description = "The name of the variable that has changed.",
            type = "string"
        },
        {
            name = "oldValue",
            description = "The old value of the DarkRPVar.",
            type = "any"
        },
        {
            name = "newvalue",
            description = "The new value of the DarkRPVar.",
            type = "any"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "canBuyPistol",
    description = "Whether a player can buy a pistol.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "shipmentTable",
            description = "The table, as defined in the shipments file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyShipment",
    description = "Whether a player can buy a shipment.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "shipmentTable",
            description = "The table, as defined in the shipments file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyVehicle",
    description = "Whether a player can buy a vehicle.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "vehicleTable",
            description = "The table, as defined in the vehicles file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyAmmo",
    description = "Whether a player can buy ammo.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "ammoTable",
            description = "The table, as defined in the a ammo file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyCustomEntity",
    description = "Whether a player can a certain custom entity.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "entTable",
            description = "The table, as defined by the user.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "onJobRemoved",
    description = "Called when a job was removed.",
    parameters = {
        {
            name = "num",
            description = "The TEAM_ number of the job.",
            type = "number"
        },
        {
            name = "jobbtable",
            description = "The table containing all the job info.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onShipmentRemoved",
    description = "Called when a shipment was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onVehicleRemoved",
    description = "Called when a vehicle was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onEntityRemoved",
    description = "Called when a buyable entity was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onGroupChatRemoved",
    description = "Called when a groupchat was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onAmmoTypeRemoved",
    description = "Called when a ammotype was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onEntityGroupRemoved",
    description = "Called when an entity group was removed.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onAgendaRemoved",
    description = "Called when an agenda was removed.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onDemoteGroupRemoved",
    description = "Called when a job was demotegroup.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "loadCustomDarkRPItems",
    description = "Runs right after the scripts from the DarkRPMod are run. You can add custom jobs, entities, shipments and whatever in this hook.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "postLoadCustomDarkRPItems",
    description = "Runs right after loadCustomDarkRPItems. All custom DarkRP content will be loaded by this time.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "DarkRPStartedLoading",
    description = "Runs at the very start of loading DarkRP. Not even sandbox has loaded here yet.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "DarkRPFinishedLoading",
    description = "Runs right after DarkRP itself has loaded. All DarkRPMod stuff (except for disabled_defaults) is loaded during this hook. NOTE! NO CUSTOM STUFF WILL BE AVAILABLE DURING THIS HOOK. USE `loadCustomDarkRPItems` INSTEAD IF YOU WANT THAT!",
    parameters = {
    },
    returns = {
    }
}

--PATH gamemodes/starwarsrp/gamemode/modules/animations/sh_interface.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_config/disabled_defaults.lua:
--[[---------------------------------------------------------------------------
DarkRP disabled defaults
---------------------------------------------------------------------------

DarkRP comes with a bunch of default things:
    - a load of modules
    - default jobs
    - shipments and guns
    - entities (like the money printer)
    and many more

If you want to disable or replace the default things, you should disable them here

Note: if you want to have e.g. edit the official medic job, you MUST disable the default one in this file!
You can copy the medic from DarkRP and paste it in darkrp_config/jobs.lua
---------------------------------------------------------------------------]]


--[[---------------------------------------------------------------------------
The list of modules that are disabled. Set to true to disable, false to enable.
Modules that are not in this list are enabled by default.
In some cases some external addons may overwrite one of the modules below and will expect them to be enabled to work.
In these few cases it will be pretty obvious when you expect something to happen and nothing does.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["modules"] = {
    ["afk"]              = true,
    ["chatsounds"]       = false,
    ["events"]           = false,
    ["fpp"]              = true,
    ["f1menu"]           = true,
    ["f4menu"]           = true,
    ["hitmenu"]          = true,
    ["hud"]              = false,
    ["hungermod"]        = true,
    ["playerscale"]      = false,
    ["sleep"]            = true,
    ["fadmin"]           = true,
    ["animations"]       = false,
    ["chatindicator"]    = true,
	["doorsystem"]		 = true,
}

--[[---------------------------------------------------------------------------
The disabled default jobs. true to disable, false to enable.

NOTE: If you disable a job and remake it, expect things that rely on the job to stop working
e.g. you disable the gundealer and you make a new job as TEAM_GUN. If you want the shipments/door groups/etc. to
work for your custom job, remake them to include your job as well.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["jobs"] = {
    ["chief"]     = true,
    ["citizen"]   = true,
    ["cook"]      = true, --Hungermod only
    ["cp"]        = true,
    ["gangster"]  = true,
    ["gundealer"] = true,
    ["hobo"]      = true,
    ["mayor"]     = true,
    ["medic"]     = true,
    ["mobboss"]   = true,
}

--[[---------------------------------------------------------------------------
Shipments and pistols
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["shipments"] = {
    ["AK47"]         = true,
    ["Desert eagle"] = true,
    ["Fiveseven"]    = true,
    ["Glock"]        = true,
    ["M4"]           = true,
    ["Mac 10"]       = true,
    ["MP5"]          = true,
    ["P228"]         = true,
    ["Pump shotgun"] = true,
    ["Sniper rifle"] = true,
}

--[[---------------------------------------------------------------------------
Entities
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["entities"] = {
    ["Drug lab"]      = true,
    ["Gun lab"]       = true,
    ["Money printer"] = true,
    ["Microwave"]     = true, --Hungermod only
    ["Tip Jar"]       = true,
}

--[[---------------------------------------------------------------------------
Vehicles
(at the moment there are no default vehicles)
You could use this to disable vehicles you added in the vehicles.lua located in the darkrp_customthings folder.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["vehicles"] = {

}

--[[---------------------------------------------------------------------------
Food
Food is only enabled when hungermod is enabled (see disabled modules above).
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["food"] = {
    ["Banana"]           = false,
    ["Bunch of bananas"] = false,
    ["Melon"]            = false,
    ["Glass bottle"]     = false,
    ["Pop can"]          = false,
    ["Plastic bottle"]   = false,
    ["Milk"]             = false,
    ["Bottle 1"]         = false,
    ["Bottle 2"]         = false,
    ["Bottle 3"]         = false,
    ["Orange"]           = false,
}

--[[---------------------------------------------------------------------------
Door groups
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["doorgroups"] = {
    ["Cops and Mayor only"] = false,
    ["Gundealer only"]      = false,
}


--[[---------------------------------------------------------------------------
Ammo packets
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["ammo"] = {
    ["Pistol ammo"]  = true,
    ["Rifle ammo"]   = true,
    ["Shotgun ammo"] = true,
}

--[[---------------------------------------------------------------------------
Agendas
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["agendas"] = {
    ["Gangster's agenda"] = false,
    ["Police agenda"] = false,
}

--[[---------------------------------------------------------------------------
Chat groups (chat with /g)
Chat groups do not have names, so their index is used instead.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["groupchat"] = {
    [1] = false, -- Police group chat (mayor, cp, chief and/or your custom CP teams)
    [2] = false, -- Group chat between gangsters and the mobboss
    [3] = false, -- Group chat between people of the same team
}

--[[---------------------------------------------------------------------------
Jobs that are hitmen
set to true to disable
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["hitmen"] = {
    ["mobboss"] = false,
}

--[[---------------------------------------------------------------------------
Demote groups
When anyone is demoted from any job in this group, they will be temporarily banned
from every job in the group
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["demotegroups"] = {
    ["Cops"]      = false,
    ["Gangsters"] = false,
}

--[[---------------------------------------------------------------------------
Workarounds

DarkRP works around some bugs in GMod and other addons that aren't maintained
(properly). Disabling workarounds will cause those things to break again.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["workarounds"] = {
    ["os.date() Windows crash"]                      = false,
    ["SkidCheck"]                                    = false,
    ["nil SteamID64 and AccountID local server fix"] = false,
    ["Cam function descriptive errors"]              = false,
    ["Error on edict limit"]                         = false,
    ["Durgz witty sayings"]                          = false,
    ["ULX /me command"]                              = false,
    ["gm_save"]                                      = false,
    ["rp_downtown_v4c_v2 rooftop spawn"]             = false,
    ["White flashbang flashes"]                      = false,
    ["APAnti"]                                       = false,
    ["Wire field generator exploit fix"]             = false,
    ["Door tool class fix"]                          = false,
    ["Constraint crash exploit fix"]                 = false,
    ["Deprecated console commands"]                  = false,
    ["disable CAC"]                                  = false,
}

--PATH addons/!jobs/lua/darkrp_config/licenseweapons.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/money/sh_commands.lua:
DarkRP.declareChatCommand{
    command = "give",
    description = "Give money to the player you're looking at.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "dropmoney",
    description = "Drop money on the floor.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "moneydrop",
    description = "Drop money on the floor.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "cheque",
    description = "Write a cheque for a specific person.",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "check",
    description = "Write a cheque for a specific person.",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "setmoney",
    description = "Set a player's wallet value.",
    delay = 0.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "addmoney",
    description = "Add money to a player's wallet.",
    delay = 0.5,
    tableArgs = true
}

--PATH gamemodes/starwarsrp/gamemode/modules/hobo/cl_hobo.lua:
hook.Add("PlayerBindPress", "Hobo sound", function(ply, bind, pressed)
    if ply == LocalPlayer() and ply:GetActiveWeapon():IsValid() and string.find(string.lower(bind), "attack2") and ply:GetActiveWeapon():GetClass() == "weapon_bugbait" then
        LocalPlayer():ConCommand("_hobo_emitsound")
    end
end)

--PATH gamemodes/starwarsrp/gamemode/modules/events/sh_events.lua:
DarkRP.declareChatCommand{
    command = "enablestorm",
    description = "Enable meteor storms.",
    delay = 1.5,
    condition = hasCommandsPriv
}

DarkRP.declareChatCommand{
    command = "disablestorm",
    description = "Disable meteor storms.",
    delay = 1.5,
    condition = hasCommandsPriv
}

--PATH gamemodes/starwarsrp/gamemode/modules/deathpov/cl_init.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_modules/extraf4tab/cl_fancytab.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/darkrp_modules/cityworker/sh_cityworker.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_customthings/agendas.lua:
--[[---------------------------------------------------------------------------
DarkRP Agenda's
---------------------------------------------------------------------------
Agenda's can be set by the agenda manager and read by both the agenda manager and the other teams connected to it.


HOW TO MAKE AN AGENDA:
AddAgenda(Title of the agenda, Manager (who edits it), {Listeners (the ones who just see and follow the agenda)})
---------------------------------------------------------------------------]]
-- Example: AddAgenda("Gangster's agenda", TEAM_MOB, {TEAM_GANG})
-- Example: AddAgenda("Police agenda", TEAM_MAYOR, {TEAM_CHIEF, TEAM_POLICE})

--PATH lua/weapons/alydus_fortificationbuildertablet.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/shared.lua:
AddCSLuaFile()

SWEP.Spawnable = false
SWEP.Category = "ARC9"
SWEP.SubCategory = nil
SWEP.AdminOnly = false

-- IMPORTANT:
-- ARC9 uses a procedural stat system.
-- You can create a huge number of weapon stats with this system.
-- Simply chain a Base with an optional Modifier and then optionally a Condition.
-- Base stats are all laid out in this file.
-- Modifiers: Add, Mult, Override, Hook. If no modifier is specified, it will default to an override.
-- Conditions:
-- True (Enabled when TrueNames is active)
-- Silenced
-- UBGL (Enabled when UBGL is active)
-- MidAir
-- Crouch
-- Reload (While reloading)
-- FirstShot
-- Toss (While tossing)
-- Empty
-- EvenShot
-- OddShot
-- EvenReload
-- OddReload
-- BlindFire
-- Sights
-- HipFire
-- Hot (Scales with overheat)
-- Shooting (Enabled when constantly shooting)
-- Recoil (Scales with long bursts, you should also set RecoilModifierCap!)
-- Move (Scaled with move speed)

-- Example:
-- VisualRecoil (Base), Mult (Modifier), Sights (Condition)
-- Usage:
-- SWEP.VisualRecoilMultSights = 0.1
-- This stat will reduce the visual recoil when in sights by 90%.

-- Another example:
-- DamageMax (Base) FirstShot (Condition)
-- Usage:
-- SWEP.DamageMaxFirstShot = 100
-- This will give the gun a close-range damage of 100 for the first shot in a burst.

-- One more example:
-- DamageMin (Base) Mult (Modifier)
-- Usage:
-- SWEP.DamageMinMult = 0.9
-- This will reduce the long range damage of the gun by 10%.

-- The following are INCORRECT:
-- VisualRecoilMultSightsMult (VisualRecoil is the base, not VisualRecoilMult. Also, modifier always comes before condition.)
-- SpreadMoveMult (Modifier comes between base and condition)
-- MultSpeed (Base is always first)
-- SpeedSightsMult (Condition is always last)
-- ReloadTimeAddMult (One modifier max, per stat)

-- For more information, see README.md

-- Any string can be replaced with a localized string by using # in front of it.
-- Get the appropriate localized string for the weapon with #WEAPON_NAME_VARIABLE.
-- For example, #ARC9_BASE_PRINTNAME.
-- Otherwise, it'll just use the direct string.
-- If a localized string is unavailable in your language, English will be used. Otherwise, the default language will be used.

SWEP.PrintName = "ARC9 Base"
SWEP.TrueName = nil
-- PrintName could be a game's fictional name for a gun, while TrueName is its real name.
-- You could also have it be a generic name, like "Assault Rifle" vs. "AK-47".
-- TrueName should be something that improves the cross-compatibility of weapon naming.

SWEP.Class = "Unclassified Weapon"
SWEP.Trivia = {} -- Optional. Any stats you like can be added.  Number in end of title orders line in list (otherwise they will be in alphabet in menus). "_" will be replaced with space
-- SWEP.Trivia = {
--     Manufacturer1 = "Arctic Armament International",
--     Calibre2 = "9x21mm Jager",
--     Mechanism3 = "Roller-Delayed Blowback",
--     Country4 = "UK-Australia-China",
--     Year5 = 2022
-- }
SWEP.Credits = {}
-- SWEP.Credits = {   -- Number in end of title orders line in list (otherwise they will be in alphabet in menus). "_" will be replaced with space
--     Author1 = "Arctic",
--     Contact2 = "https://steamcommunity.com/id/ArcticWinterZzZ/",
-- }

SWEP.Description = [[Description Unavailable.]]
-- Multi-line strings are possible with the double square brackets.]]

SWEP.UseHands = true -- Same as weapon_base
SWEP.EntitySelectIcon = false -- Set to true to try and use the Entity image as select icon
SWEP.CustomSelectIcon = nil -- Set to use a non-autogenerated select icon

SWEP.ViewModel = ""
SWEP.WorldModel = "" -- If you are going to MirrorVMWM: Put here some optimized model with collisions. Css/hl2 weapon worldmodels that are included in gmod are great for it - like "models/weapons/w_rif_m4a1.mdl"

SWEP.MirrorVMWM = false -- Use this to use the viewmodel as a worldmodel.
-- Highly recommended to save effort!
SWEP.WorldModelMirror = nil -- Use this to set a lower-quality version of the viewmodel, with the same bone structure, as a worldmodel, to take advantage of MirrorVMWM without having to use the viewmodel.
SWEP.WorldModelOffset = nil
-- SWEP.WorldModelOffset = {
--     Pos = Vector(0, 0, 0), -- non tpik (while on ground, on npc etc)
--     Ang = Angle(0, 0, 0),
--     TPIKPos = Vector(0, 0, 0), -- arc9_tpik 1, you can make cool poses with it
--     TPIKAng = Angle(0, 0, 0),
--     Scale = 1
-- }
SWEP.NoTPIK = false
SWEP.MirrorVMWMHeldOnly = false -- If true, MirrorVMWM is not activated when weapon is on the ground.

SWEP.TPIKParentToSpine4 = nil -- TPIK makes VM origin on right hand (which is located different on each holdtype, crouch jump run etc). Set to true if you want vm origin on spine bone
SWEP.TPIKforcelefthand = nil -- TPIK does not do left hand when you have one of this holdtypes: slam magic pistol normal. Set to true to still do lhand tpik for those
SWEP.TPIKforcenoreload = false -- TPIK does not force activate during reload
SWEP.TPIKnolefthand = false -- Force no TPIK left hand
SWEP.TPIKNoSprintAnim = nil -- Makes weapon wm be in idle while sprinting (use when animated sprint looks too bad from outside)
SWEP.NoTPIKVMPos = false -- TPIK position is not affected by viewmodel position (Local player only)
SWEP.Material = ""

SWEP.Crosshair = false
SWEP.LauncherCrosshair = false -- Force the launcher crosshair
SWEP.MissileCrosshair = false -- Force the missile launcher crosshair
SWEP.ForceStandardCrosshair = nil -- Force default + or T crosshair no matter what!

SWEP.CustomCrosshair = false -- Enables custom crosshair use.
SWEP.CustomCrosshairSingle = false -- Enables a single image to be used as the custom crosshair.
SWEP.CustomCrosshairMaterial = nil -- Point towards a file to use as the custom crosshair. Must use Material(PATH) format.
SWEP.CustomCrosshairSize = 40 -- Changes the custom crosshair size. (Default 40)

SWEP.ViewModelFOVBase = nil -- Set to override viewmodel FOV

SWEP.NoDynamicKillIcon = false

SWEP.NotAWeapon = false -- Set to true to indicate that this is not a weapon.
-- Disables pretty much all base features except for controls and aesthetics, allowing for custom weapons to be implemented.

SWEP.ARC9WeaponCategory = nil -- See sh_common.lua

-------------------------- SAVING

SWEP.SaveBase = nil -- set to a weapon class to make this weapon share saves with it.

-------------------------- DEFAULT ELEMENTS

-- Using MirrorVMWM will use viewmodel parameters for the world model.

SWEP.DefaultBodygroups = ""
-- {
--     {
--         ind = 0,
--         bg = 0,
--     }
-- }

SWEP.DefaultWMBodygroups = ""

SWEP.DefaultSkin = 0

-------------------------- DAMAGE PROFILE

SWEP.DamageMax = 20 -- Damage done at point blank range
SWEP.DamageMin = 15 -- Damage done at maximum range

SWEP.ImpactForce = 8 -- Force that bullets apply on hit

SWEP.DamageRand = 0 -- Damage varies randomly per shot by this fraction. 0.1 = +- 10% damage per shot.

SWEP.RangeMin = 0 -- How far bullets retain their maximum damage for.
SWEP.RangeMax = 5000 -- In Hammer units, how far bullets can travel before dealing DamageMin.
SWEP.Distance = 33000 -- In Hammer units, how far bullets can travel, period.

SWEP.CurvedDamageScaling = true -- If true, damage will scale in a quadratic curve between RangeMin and RangeMax. If false, damage will scale linearly.

SWEP.SweetSpot = false -- Modifies damage if it's within a certain range, typically increasing it. Set this to enable
SWEP.SweetSpotDamage = nil -- Damage at peak sweet spot
SWEP.SweetSpotRange = nil -- Center of the sweet spot (should be larger than peak + width)
SWEP.SweetSpotPeak = nil -- Within this much distance, sweet spot damage is maxed out
SWEP.SweetSpotWidth = nil -- Sweet spot damage falls off over this much distance

SWEP.DamageLookupTable = nil --[[ Example: {
    {
        500, 100
    },
    {
        1000, 50
    },
    {
        2000, 10
    }
}
]]--

--[[
function SWEP:Hook_GetDamageAtRange(data)
    data.dmg = (math.sin(data.range / 250) + 1) * 10

    return data
end
]]--

SWEP.Num = 1 -- Number of bullets to shoot
SWEP.NumUBGL = 1 -- Fixes broken UBGLs firing multiple entities when not defined properly in their LUAs

SWEP.DistributeDamage = false -- If true, damage is distributed evenly across all bullets. If false, damage is dealt to the first bullet only.
SWEP.NormalizeNumDamage = false -- If true, total damage will not change if Num is modified. Does not work with DistributeDamage.

SWEP.Penetration = 5 -- Units of wood that can be penetrated by this gun.
SWEP.PenetrationDelta = 0.1 -- The damage multiplier after all penetration distance is spent.

SWEP.RicochetAngleMax = 45 -- Maximum angle at which a ricochet can occur. Between 1 and 90. Angle of 0 is impossible but would theoretically always ricochet.
SWEP.RicochetChance = 0.5 -- If the angle is right, what is the chance that a ricochet can occur?
SWEP.RicochetSeeking = false -- Whether ricochet bullets will seek living targets in a cone.
SWEP.RicochetSeekingAngle = 30
SWEP.RicochetSeekingRange = 1024

SWEP.DamageType = DMG_BULLET -- The damage type of the gun.
-- DMG_BLAST will create explosive effects and create AOE damage.
-- DMG_BURN will ignite the target.
-- DMG_AIRBOAT will damage Combine Hunter-Choppers.

SWEP.ArmorPiercing = 0 -- Between 0-1. A proportion of damage that is done as direct damage, ignoring protection.

-- Individual multipliers that can be used with modifiers
SWEP.HeadshotDamage = 1
SWEP.ChestDamage = 1
SWEP.StomachDamage = 1
SWEP.ArmDamage = 1
SWEP.LegDamage = 1

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.9,
    [HITGROUP_RIGHTLEG] = 0.9,
}

-- Set the multiplier for each part of the body.
-- If a limb is not set the damage multiplier will default to 1
-- That means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.ExplosionDamage = 0
SWEP.ExplosionRadius = 0
SWEP.ExplosionEffect = nil

-------------------------- ENTITY LAUNCHING

SWEP.ShootEnt = nil -- Set to an entity to launch it out of this weapon.
SWEP.ShootEntForce = 10000
SWEP.ShootEntInheritPlayerVelocity = false -- Set to true to inherit velocity
SWEP.ShootEntInheritPlayerVelocityLimit = 0 -- Upper limit of velocity to inherit. 0 - no limit.
SWEP.ShootEntData = {} -- Extra data that can be given to a projectile. Sets ENT.ShootEntData with this table.

SWEP.Throwable = false -- Set to true to give this weapon throwing capabilities.
SWEP.Tossable = true -- When grenade is enabled, right click will toss. Set to false to disable, allowing you to aim down sights.
SWEP.ThrowAnimSpeed = 1

SWEP.FuseTimer = -1 -- Length of time that the grenade will take to explode in your hands. -1 = Won't explode.

SWEP.ThrowForceMin = 3000 -- Minimum force that the grenade will be thrown with.
SWEP.ThrowForceMax = 5000 -- Maximum force that the grenade will be thrown with.
SWEP.TossForce = 500 -- Force that the grenade will be thrown with when right clicked.

SWEP.ThrowChargeTime = 1 -- How long it takes to charge the grenade to its maximum throw force.

SWEP.ThrowTumble = true -- Grenade tumbles when thrown.

SWEP.ThrowOnGround = false -- If set, entity's position and angles ignores vertical aim, and is lowered by up to 36 units onto the ground.

SWEP.NoHolsterOnPrimed = nil  -- disallow holstering if pin in pulled

SWEP.QuickSwapTo = nil -- Use on grenades, will make any arc9 holster 2 times faster to this swep

SWEP.Detonator = false -- Set to true to give this weapon a detonator. After throwing out a grenade, you enter detonator mode.

-------------------------- PHYS BULLET BALLISTICS

-- These settings override the player's physical bullet options.
SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false

SWEP.PhysBulletMuzzleVelocity = 150000 -- Physical bullet muzzle velocity in Hammer Units/second. 1 HU != 1 inch.
SWEP.PhysBulletDrag = 1 -- Drag multiplier
SWEP.PhysBulletGravity = 1 -- Gravity multiplier
SWEP.PhysBulletDontInheritPlayerVelocity = false -- Set to true to disable "Browning Effect"

SWEP.FancyBullets = false -- set to true to allow for multicolor mags and crap
-- Each bullet runs HookP_ModifyBullet, within which modifications can be made

-- if true, bullets follow the player's cursor
SWEP.BulletGuidance = false
SWEP.BulletGuidanceAmount = 15000 -- the amount of guidance to apply

-- Make the physical bullet use a model instead of the tracer effect.
-- You MUST register the model beforehand in a SHARED context (such as the SWEP file) like so: ARC9:RegisterPhysBulletModel("models/weapons/w_missile.mdl")
SWEP.PhysBulletModel = nil
SWEP.PhysBulletModelStick = nil -- The amount of time a physbullet model will stick on impact.

-------------------------- TRACERS

SWEP.TracerNum = 1 -- Tracer every X
SWEP.TracerFinalMag = 0 -- The last X bullets in a magazine are all tracers
SWEP.TracerEffect = "ARC9_tracer" -- The effect to use for hitscan tracers
SWEP.TracerColor = Color(255, 255, 190) -- Color of tracers. Only works if tracer effect supports it. For physical bullets, this is compressed down to 9-bit color.
SWEP.TracerSize = 1

-------------------------- SHOOTPOS

SWEP.ShootPosOffset = Vector(0, 0, 0)
SWEP.ShootAngOffset = Angle(0, 0, 0)

-------------------------- MAGAZINE

SWEP.Ammo = "pistol" -- What ammo type this gun uses.

SWEP.ChamberSize = 1 -- The amount of rounds this gun can chamber.
SWEP.ClipSize = 25 -- Self-explanatory.
SWEP.SupplyLimit = 5 -- Amount of magazines of ammo this gun can take from an ARC9 supply crate.
SWEP.SecondarySupplyLimit = 2 -- Amount of reserve UBGL magazines you can take.

SWEP.ForceDefaultClip = nil -- Set to force a default amount of ammo this gun can have. Otherwise, this is controlled by console variables.

SWEP.AmmoPerShot = 1 -- Ammo to use per shot
SWEP.InfiniteAmmo = false -- Weapon does not take from reserve ammo
SWEP.BottomlessClip = false -- Weapon never has to reload

SWEP.ShotgunReload = false -- Weapon reloads like shotgun. Uses insert_1, insert_2, etc animations instead.
SWEP.HybridReload = false -- Enable on top of Shotgun Reload. If the weapon is completely empty, use the normal reload animation.
-- Use SWEP.Hook_TranslateAnimation in order to do custom animation stuff.
SWEP.ShotgunReloadIncludesChamber = true -- Shotguns reload to full capacity, assuming that the chamber is loaded as part of the animation.
SWEP.ShotgunReloadNoChamber = false -- No chambering at all on shotgun reloading

SWEP.ManualActionChamber = 1 -- How many shots we go between needing to cycle again.
SWEP.ManualAction = false -- Pump/bolt action. Play the "cycle" animation after firing, when the trigger is released.
SWEP.ManualActionNoLastCycle = false -- Do not cycle on the last shot.
SWEP.ManualActionEjectAnyway = false -- Eject a shell when firing anyway.
SWEP.EjectDelay = 0 -- When eject shell on cycle (pretty dumb, better'd just use EjectAt)

SWEP.ReloadWhileSprint = true -- This weapon can reload while the user is sprinting.
SWEP.ReloadInSights = true -- This weapon can aim down sights while reloading.
SWEP.PartialReloadCountsTowardsNthReload = true -- If the gun is not empty, it counts towards the Nth reload. Useful for guns with spare magazine animations.

SWEP.CanReloadWhileUnCycled = false

SWEP.CanFireUnderwater = false -- This weapon can shoot while underwater.

SWEP.Disposable = false -- When all ammo is expended, this gun will remove itself from the inventory.

SWEP.AutoReload = false -- When the gun is drawn, it will automatically reload.

SWEP.ShouldDropMag = false
SWEP.ShouldDropMagEmpty = true

SWEP.DropMagazineModel = nil -- Set to a string or table to drop this magazine when reloading.
SWEP.DropMagazineSounds = {} -- Table of sounds a dropped magazine should play.
SWEP.DropMagazineAmount = 1 -- Amount of mags to drop.
SWEP.DropMagazineSkin = 0 -- Model skin of mag.
SWEP.DropMagazineTime = 0.25
SWEP.DropMagazineQCA = nil -- QC Attachment drop mag from, would drop from shell port if not defined
SWEP.DropMagazinePos = Vector(0, 0, 0) -- offsets
SWEP.DropMagazineAng = Angle(0, 0, 0)
SWEP.DropMagazineVelocity = Vector(0, 0, 0) -- Put something here if your anim throws the mag with force

SWEP.BarrelLength = 0 -- Distance for nearwalling

SWEP.DryFireDelay = false -- Set to set time, otherwise uses animation length

-------------------------- FIREMODES

SWEP.RPM = 750

SWEP.TriggerDelay = false -- Add a delay before the weapon fires.
SWEP.TriggerDelayTime = 0.2 -- Time until weapon fires.
SWEP.TriggerDelayRepeat = false -- Whether to do it for every shot on automatics.
SWEP.TriggerDelayCancellable = true -- Whether it is possible to cancel trigger delay by releasing the trigger before it is done.
SWEP.TriggerDelayReleaseToFire = false -- Release the trigger to fire instead of firing as soon as the delay is over.
SWEP.TriggerStartFireAnim = false -- Whether trigger begins the firing animation

-- Works different to ArcCW

-- -1: Automatic
-- 0: Safe. Don't use this for safety.
-- 1: Semi.
-- 2: Two-round burst.
-- 3: Three-round burst.
-- n: n-round burst.
SWEP.Firemodes = {
    {
        Mode = 1,
        -- add other attachment modifiers
    }
}

SWEP.NoFiremodeWhenEmpty = false -- Cannot switch firemode when empty
SWEP.CantSafety = nil -- No safety on this gun

SWEP.FiremodeAnimLock = false -- Firemode animation cannot be interrupted

SWEP.SlamFire = false -- Manual action weapons cycle themselves

SWEP.AutoBurst = false -- Hold fire to keep firing bursts
SWEP.PostBurstDelay = 0
SWEP.RunawayBurst = false -- Burst will keep firing until all of the burst has been expended.

SWEP.Akimbo = false -- Alternate shooting animation with "fire_left" and "fire_right"
SWEP.AkimboBoth = false -- Play effects twice and use "fire_both" for shooting animation. Does not actually affect ammo consumed or bullets fired.

-- Use this hook to modify features of a firemode.
-- SWEP.HookP_ModifyFiremode = function(self, firemode) return firemode end

-------------------------- RECOIL

SWEP.RecoilSeed = nil -- Leave blank to use weapon class name as recoil seed.
-- Should be a number.
SWEP.RecoilPatternDrift = 12 -- Higher values = more extreme recoil patterns.
SWEP.RecoilLookupTable = nil -- Use to set specific values for predictible recoil. If it runs out, it'll just use Recoil Seed.
-- SWEP.RecoilLookupTable = {
--     15,
--     3,
-- }
SWEP.RecoilLookupTableOverrun = nil -- Repeatedly take values from this table if we run out in the main table

-- General recoil multiplier
SWEP.Recoil = 1

-- These multipliers affect the predictible recoil by making the pattern taller, shorter, wider, or thinner.
SWEP.RecoilUp = 1 -- Multiplier for vertical recoil
SWEP.RecoilSide = 1 -- Multiplier for vertical recoil

-- These values determine how much extra movement is applied to the recoil entirely randomly, like in a circle.
-- This type of recoil CANNOT be predicted.
SWEP.RecoilRandomUp = 0.1
SWEP.RecoilRandomSide = 0.1

SWEP.RecoilDissipationRate = 10 -- How much recoil dissipates per second.
SWEP.RecoilResetTime = 0.1 -- How long the gun must go before the recoil pattern starts to reset.
SWEP.RecoilFullResetTime = 2 -- How long recoil must stay after last shoot

SWEP.RecoilAutoControl = 1 -- Multiplier for automatic recoil control.
SWEP.RecoilAutoControl_DontTryToReturnBack = nil -- If true will make recoil autocompensation not follow mouse   will make recoil be less sluggerish, but may cause crosshair to return in weird positions

SWEP.RecoilPerShot = 1
SWEP.RecoilMax = nil

SWEP.PushBackForce = 0 -- Push the player back when shooting.

-- SInput rumble configuration
-- Max of 65535
SWEP.RumbleHeavy = 30000
SWEP.RumbleLight = 30000
SWEP.RumbleDuration = 0.12

-------------------------- UBGL
-- Underbarrel weapons
-- Stats that BEGIN with UBGL are actual specific stats
SWEP.UBGL = false
SWEP.UBGLAmmo = "smg1_grenade"
SWEP.UBGLClipSize = 1
SWEP.UBGLFiremode = 1
SWEP.UBGLFiremodeName = "UBGL"
SWEP.UBGLChamberSize = 0
SWEP.UBGLInsteadOfSights = false -- Right clicking fires UBGL instead of going into irons.
SWEP.UBGLExclusiveSights = false -- Enable to allow only UBGLOnly sights to be used.
SWEP.UBGLToggleTime = nil -- In seconds, how long of a delay between being able to toggle the UBGL.

-- Otherwise, these are just stats that get overwritten when selecting a UBGL.
SWEP.AmmoPerShotUBGL = 1
SWEP.SpreadUBGL = 0.0
SWEP.RecoilUBGL = 1
SWEP.DoFireAnimationUBGL = true
SWEP.NoShellEjectUBGL = true
SWEP.ManualActionUBGL = false
SWEP.ShouldDropMagUBGL = false
SWEP.ShotgunReloadUBGL = false
SWEP.HybridReloadUBGL = false
SWEP.ShootEntUBGL = false
SWEP.TracerNumUBGL = 0
SWEP.TriggerDelayUBGL = false
SWEP.PhysBulletModelUBGL = false
SWEP.ShootEntForceUBGL = 10000
SWEP.SweetSpotUBGL = false
SWEP.RangeMinUBGL = 0
SWEP.RangeMaxUBGL = 5000
SWEP.DistanceUBGL = 33000
SWEP.PenetrationUBGL = 5
SWEP.DamageTypeUBGL = DMG_BULLET
SWEP.ExplosionDamageUBGL = 0
SWEP.ExplosionRadiusUBGL = 0
SWEP.ExplosionEffectUBGL = false 

-------------------------- VISUAL RECOIL

SWEP.UseVisualRecoil = false

SWEP.PhysicalVisualRecoil = true -- Visual recoil actually affects your aim point.

SWEP.VisualRecoilUp = 0.01 -- Vertical tilt for visual recoil.F
SWEP.VisualRecoilSide = 0.05 -- Horizontal tilt for visual recoil.
SWEP.VisualRecoilRoll = 0.23 -- Roll tilt for visual recoil.

SWEP.VisualRecoilCenter = Vector(2, 4, 2) -- The "axis" of visual recoil. Where your hand is.

SWEP.VisualRecoilPunch = 1.5 -- How far back visual recoil moves the gun.
SWEP.VisualRecoilPunchMultSights = 0.1

-- SWEP.VisualRecoilMult = 1
-- SWEP.VisualRecoilADSMult = 0.1
-- SWEP.VisualRecoilPunchADSMult = 0.1

SWEP.VisualRecoil = 1
SWEP.VisualRecoilMultSights = 0.1
SWEP.VisualRecoilPositionBump = 1.5
SWEP.VisualRecoilPositionBumpUp = 0.08 -- its a mult


SWEP.VisualRecoilDampingConst = nil -- How spring will be visual recoil, 120 is default
SWEP.VisualRecoilSpringMagnitude = 1
SWEP.VisualRecoilSpringPunchDamping = nil -- ehh another val for "eft" recoil, 6 is default

SWEP.VisualRecoilThinkFunc = nil -- wawa, override DampingConst, SpringMagnitude, SpringPunchDamping here 
-- function(springconstant, VisualRecoilSpringMagnitude, PUNCH_DAMPING, recamount)
--     if recamount > 3 then
--         return springconstant * 100, VisualRecoilSpringMagnitude * 1, PUNCH_DAMPING * 1
--     end
--     return springconstant, VisualRecoilSpringMagnitude, PUNCH_DAMPING
-- end

SWEP.VisualRecoilDoingFunc = nil -- wawa, override Up, Side, Roll here 
-- function(up, side, roll, punch, recamount)
--     if recamount > 2 then
--         return up * 5, side * 1.5, roll, punch * 0.9
--     end
--     return up, side, roll, punch
-- end

SWEP.RecoilKick = 1 -- Camera recoil
SWEP.RecoilKickDamping = 70.151 -- Camera recoil damping
SWEP.RecoilKickAffectPitch = nil -- thing for eft, set to true if you want camera go up (only visually) as recoil increases, SWEP.Recoil * SWEP.RecoilKick = effect of this

-------------------------- SPREAD

SWEP.Spread = 0

SWEP.UseDispersion = false -- Use this for shotguns - Additional random angle to spread, same for each pellet
SWEP.DispersionSpread = 0.2 -- SWEP.Spread will be clump spread, and this will be dispersion of clump

SWEP.SpreadAddMove = nil -- Applied when speed is equal to walking speed.
SWEP.SpreadAddMidAir = nil -- Applied when not touching the ground.
SWEP.SpreadAddHipFire = nil -- Applied when not sighted.
SWEP.SpreadAddSighted = nil -- Applied when sighted. Can be negative.
SWEP.SpreadAddBlindFire = nil -- Applied when blind firing.
SWEP.SpreadAddCrouch = nil -- Applied when crouching.

SWEP.SpreadAddRecoil = nil -- Applied per unit of recoil.

-- Limit the effect of recoil on modifiers to this much.
-- Because the per shot modifier used to be broken and effectively had a limit of 1, it is set to 1 by default. You should probably set it higher.
SWEP.RecoilModifierCap = 1

-------------------------- HANDLING

SWEP.FreeAimRadius = 10 -- In degrees, how much this gun can free aim in hip fire.
SWEP.Sway = 1 -- How much the gun sways.

SWEP.HoldBreathTime = 5 -- time that you can hold breath for, set to 0 to disable holding breath
SWEP.RestoreBreathTime = 10

SWEP.FreeAimRadiusMultSights = 0.25

SWEP.SwayMultSights = 0.5

SWEP.AimDownSightsTime = 0.25 -- How long it takes to go from hip fire to aiming down sights.
SWEP.SprintToFireTime = 0.25 -- How long it takes to go from sprinting to being able to fire.

SWEP.MagnificationZoomSpeed = 1 -- Multiply how quickly the FOV adjusts itself when entering or exiting the sights, or when toggling from one sight to another.

SWEP.NoSprintWhenLocked = false -- You cannot sprint while reloading with this gun

SWEP.ReloadTime = 1
SWEP.DeployTime = 1
SWEP.CycleTime = 1
SWEP.FixTime = 1
SWEP.OverheatTime = 1

SWEP.ShootWhileSprint = false

SWEP.Speed = 1

SWEP.SpeedMult = 1
SWEP.SpeedMultSights = 0.75
SWEP.SpeedMultShooting = 0.9
SWEP.SpeedMultMelee = 0.75
SWEP.SpeedMultCrouch = 1
SWEP.SpeedMultBlindFire = 1

SWEP.NoInspect = nil -- Set to true if there are inspect animation present, but you do not want the ability to trigger them.

-------------------------- MELEE

SWEP.Bash = false
SWEP.PrimaryBash = false

SWEP.BashDamage = 50
SWEP.BashLungeRange = 64
SWEP.BashRange = 64
SWEP.PreBashTime = 0.5
SWEP.PostBashTime = 0.5
SWEP.BashDamageType = DMG_CLUB
SWEP.BashDecal = "ManhackCut"
SWEP.BashImpact = true -- Creates a Impact effect that leaves a bullet hole.

SWEP.BashSpeed = 1

SWEP.BashWhileSprint = false -- Unlike ShootWhileSprint, this will not require transitioning out of sprint state (and waiting the sprinttofire delay)
SWEP.BashCancelsReload = nil -- If bashing should immediately cancel the reload

SWEP.BashThirdArmAnimation = {
        rig = "models/weapons/arc9/lhik/c_thirdarm_pdw.mdl",
        sequence = {"melee1", "melee2"},
        -- sequence = "melee1",
        gun_controller_attachment = 1,
        -- offsetang = Angle(90, 180, 90),
        mult = 1,
        invisible = false,
    }

SWEP.SecondaryBash = false

SWEP.Bash2Damage = 50
SWEP.Bash2LungeRange = 64
SWEP.Bash2Range = 64
SWEP.PreBash2Time = 0.5
SWEP.PostBash2Time = 0.5
SWEP.Bash2DamageType = DMG_CLUB
SWEP.Bash2Decal = "ManhackCut"
SWEP.Bash2Impact = true

SWEP.Bash2ThirdArmAnimation = {
    rig = "models/weapons/arc9/lhik/c_thirdarm_pdw.mdl",
    sequence = {"melee1", "melee2"},
    -- sequence = "melee1",
    gun_controller_attachment = 1,
    -- offsetang = Angle(90, 180, 90),
    mult = 1,
    invisible = false,
}

SWEP.Backstab = false
SWEP.BackstabDamage = 100
SWEP.BackstabRange = 64
SWEP.PreBackstabTime = 0.5
SWEP.PostBackstabTime = 0.5
SWEP.BackstabDamageType = DMG_CLUB
SWEP.BackstabDecal = "ManhackCut"
SWEP.BackstabImpact = true

-------------------------- LOCKON

SWEP.LockOn = false
-- SWEP.LockOnSights = false

-- Do not use LockOn and LockOnSights together
-- LockOn will provide targeting data in ENT.ShootEntData

SWEP.LockOnAutoaim = false -- Gun will shoot directly towards lockon target

SWEP.LocksLiving = false -- Locks on to any NPC or player
SWEP.LocksGround = false -- Will lock on to any entity deemed a ground target and not an air target
SWEP.LocksAir = false -- Will lock on to any entity deemed an air target, and not a ground target

SWEP.LockOnRange = 100000 -- How far away the lockon can be
SWEP.LockOnFOV = 10 -- How wide the lockon can be
SWEP.LockedOnFOV = 20 -- FOV needed to maintain a lock

SWEP.LockOnTime = 0.5 -- How long it takes to lock on, in seconds

SWEP.LockOnSound = nil -- Sound to play when locking on
SWEP.LockedOnSound = nil -- Sound to play when successfully locked target

SWEP.LockOnHUD = true -- Show a box around locked targets

-------------------------- MALFUNCTIONS

SWEP.Overheat = false -- Weapon will jam when it overheats, playing the "overheat" animation.
SWEP.HeatPerShot = 1
SWEP.HeatCapacity = 1 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 10 -- rounds' worth of heat lost per second
SWEP.HeatLockout = true -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5 -- Amount of time that passes before heat begins to dissipate.
SWEP.HeatFix = false -- when the "overheat" animation is played, all heat is restored.

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "fix" animation
-- if no "fix" or "cycle" animations exist, the weapon will reload instead
-- When the trigger is pressed, the gun will try to play the "jamfire" animation. Otherwise, it will try "dryfire". Otherwise, it will do nothing.
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.  -- are you sure? doesnt seem to work
SWEP.MalfunctionNeverLastShoot = true -- Last round will never cause malfunctions (so guns with empty animations wont be fucky)
SWEP.MalfunctionCycle = false -- ManualAction = true only: Roll malfunction roullete not after shoot but before every cycle anim
SWEP.MalfunctionWait = 0 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMeanShotsToFail = 1000 -- The mean number of shots between malfunctions, will be autocalculated if nil

-------------------------- HOOKS

-- SWEP.Hook_Draw = function(self, vm) end # Called when the weapon is drawn. Call functions here to modify the viewmodel, such as drawing RT screens onto the gun.
-- SWEP.Hook_HUDPaint = function(self) end
-- SWEP.Hook_HUDPaintBackground = function(self) end
-- SWEP.Hook_RTScopeReticle = function(self, {rtsize = num, rtmat = Material})
-- SWEP.Hook_ModifyRecoilDir = function(self, dir) return dir end # direction of recoil in degrees, 0 = up
-- SWEP.HookP_ModifyFiremode = function(self, firemode) return firemode end
-- SWEP.HookC_DrawBullet = function(self, bullet) return bool end -- called when a bullet gets drawn, return true to prevent drawing bullet
-- SWEP.HookP_ModifyBullet = function(self, bullet) return end # bullet = phys bullet table, modify in place, does not accept return
-- SWEP.HookP_ModifyNewBullet = function(self, bullet) return end # bullet = phys bullet table, modify in place, does not accept return
-- SWEP.HookP_BlockFire = function(self) return block end # return true to block firing
-- SWEP.Hook_ModifyBodygroups = function(self, data) return end # data = {model = Model, elements = {"table" = true, "of" = true, "elements" = true}}
-- SWEP.HookP_ModifyBulletPoseParam = function(self, pp) return pp end
-- SWEP.HookP_ModifyFiremodePoseParam = function(self, pp) return pp end
-- SWEP.Hook_DoRT = function(self) return end
-- SWEP.Hook_Think = function(self) return end
-- SWEP.Hook_Deploy = function(self) return end
-- SWEP.Hook_Holster = function(self) return end
-- SWEP.Hook_GetShootEntData = function(self, table) return end -- Each function should add an entry to the table for shoot ents
-- SWEP.HookP_NameChange = function(self, name) return name end
-- SWEP.HookP_DescriptionChange = function(self, desc) return desc end
-- SWEP.Hook_BlockAnimation = function(self, anim) return block end -- Return true to block animation from playing.
-- SWEP.Hook_PrimaryAttack = function(self) return end -- Called when the primary attack is fired.
-- SWEP.Hook_SwitchSight = function(self, newsight) return end -- Called when a sight is switched.
-- SWEP.Hook_ToggleAtts = function(self) return end -- Called when attachments are toggled with F.
-- SWEP.HookP_TranslateSound = function(self, data) return data end # data = {sound = "sound", name = "fire", volume = 1, pitch = 100, level = 100, channel = CHAN_AUTO, volume = 100, flags = SND_NOFLAGS, dsp = 0}
-- SWEP.Hook_BulletImpact = function(self, data) return end # data = {tr, dmg, range, penleft, alreadypenned, dmgv}
-- SWEP.Hook_LockOn = function(self, ent) return end -- Called when a lock on is made.
-- SWEP.HookC_CanLockOn = function(self, ent) return true end -- Return true to allow lock on.
-- SWEP.HookC_CannotLockOn = function(self, ent) return true end -- Return true to disallow lock on. Has priority over CanLockOn.
-- SWEP.HookS_GetLockOnScore = function(self, ent) return 0 end -- Return new score
-- SWEP.Hook_GetAttachmentPos = function(self, data) return data end -- {atttbl = {}, slottbl = {}, pos = Vector, ang = Angle}
-- SWEP.Hook_HideBones = function(self, bones) return bones end -- {"bone" = true, "bone" = true...}
-- SWEP.Hook_ModifyElements = function(self, eles) return eles end -- {"ele" = true, "ele" = true...}
-- SWEP.Hook_TranslateSource = function(self, source) return source end -- String, use this to modify source strings directly
-- SWEP.Hook_GetDamageAtRange(self, data) return data end -- {range = range, dmg = dmg, d = delta}
-- SWEP.Hook_OnKill(self, ent) return end
-- SWEP.Hook_BlockHasAnimation(self, anim) return false end -- Return false to claim the animation does not exist.
-- SWEP.Hook_BlockTPIK(self) return true end -- Return true to block TPIK.
-- SWEP.Hook_GrenadeThrown(self, data) return end -- Called when grenade is released and about to be thrown. {force = 0, delay = 0}
-- SWEP.Hook_GrenadeCreated(self, nades) return end -- Called when grenade entities are created. nades is a table of entities.
-- SWEP.Hook_Bash(self, tr) return end
-- SWEP.Hook_BashHit(self, data) return end -- {tr, dmg}
-- SWEP.Hook_PostReload(self) return end -- called after a reload successfully starts
-- SWEP.Hook_EndReload(self) return end -- called after a reload loads ammo (ammo went in magazine)
-- SWEP.Hook_SpecialHolsterLogic(self, data) return end -- { wep } return true to override holster logic, set a time, run funcs etc
-- Example of replica of base logic:
-- SWEP.Hook_SpecialHolsterLogic = function( wep, data )
--     local animation = wep:PlayAnimation("holster", wep:GetProcessedValue("DeployTime", true, 1), true, false, nil, nil, true) or 0
--     local aentry = wep:GetAnimationEntry(wep:TranslateAnimation("holster"))
--     local alength = aentry.MinProgress or animation
--     alength = alength * (aentry.Mult or 1)
--     wep:SetHolsterTime(CurTime() + alength)
--     return true
-- end

-- SWEP.CustomPoseParamsHandler = function(self, ent, iswm) end -- do stuff related to poseparams here (previously it was done in custom think but thanks to rubat think hook now runs in wrong order)

-- SOUND NAMES FOR TRANSLATESOUND:
-- install
-- uninstall
-- enterbipod
-- exitbipod
-- firemode
-- safety
-- jam
-- shootlooptailindoor
-- shootlooptail
-- meleeswing
-- meleehit
-- meleehitwall
-- dryfire
-- shootsound
-- shootlayer
-- shootdistant
-- shootsoundindoor
-- shootlayerindoor
-- shootdistantindoor
-- entersights
-- exitsights
-- zoom
-- breathrunout
-- breathin
-- breathout
-- soundtable_1, soundtable_2...
-- enterubgl
-- exitubgl
-- lockon
-- lockedon

-------------------------- LEAN

SWEP.CanLean = true

-------------------------- BLIND FIRE
-- This feature has been removed pending rework, and these functions do not work.

SWEP.CanBlindFire = true -- This weapon is capable of blind firing.
SWEP.BlindFireLHIK = true -- Hide the left hand while blind firing forward.

SWEP.BlindFireLeft = true
SWEP.BlindFireRight = false -- This weapon can blind fire towards the right. Generally keep this off.

SWEP.BlindFireOffset = Vector(0, 0, 32) -- The amount by which to offset the blind fire muzzle.
SWEP.BlindFirePos = Vector(-6, -4, 12)
SWEP.BlindFireAng = Angle(0, 0, -45)

SWEP.BlindFireRightOffset = Vector(0, 24, 0) -- The amount by which to offset the blind fire muzzle.
SWEP.BlindFireRightPos = Vector(-12, 12, 0)
SWEP.BlindFireRightAng = Angle(-90, 0, 0)

SWEP.BlindFireLeftOffset = Vector(0, 24, 0) -- The amount by which to offset the blind fire muzzle.
SWEP.BlindFireLeftPos = Vector(12, 10, 0)
SWEP.BlindFireLeftAng = Angle(90, 0, 0)

SWEP.BlindFireBoneMods = {
    ["ValveBiped.Bip01_R_UpperArm"] = {
        ang = Angle(45, -90, 0),
        pos = Vector(0, 0, 0)
    },
    ["ValveBiped.Bip01_R_Hand"] = {
        ang = Angle(-90, 0, 0),
        pos = Vector(0, 0, 0)
    }
}
SWEP.BlindFireLeftBoneMods = {
    ["ValveBiped.Bip01_R_UpperArm"] = {
        ang = Angle(45, 0, 0),
        pos = Vector(0, 0, 0)
    },
    ["ValveBiped.Bip01_R_Hand"] = {
        ang = Angle(0, -75, 0),
        pos = Vector(0, 0, 0)
    }
}

SWEP.BlindFireRightBoneMods = {
    ["ValveBiped.Bip01_R_UpperArm"] = {
        ang = Angle(-45, 0, 0),
        pos = Vector(0, 0, 0)
    },
    ["ValveBiped.Bip01_R_Hand"] = {
        ang = Angle(0, 75, 0),
        pos = Vector(0, 0, 0)
    }
}

-------------------------- NPC

SWEP.NotForNPCs = false -- Won't be given to NPCs.

-------------------------- BIPOD

SWEP.Bipod = false -- This weapon comes with a bipod.
SWEP.RecoilMultBipod = 0.25
SWEP.SwayMultBipod = 0.25
SWEP.FreeAimRadiusMultBipod = 0

-------------------------- SOUNDS

SWEP.ShootVolume = 125
SWEP.ShootVolumeActual = 1
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 5 -- Not multiplied, but actually just added/subtracted.

SWEP.FirstShootSound = nil                      -- First fire
SWEP.ShootSound = ""                            -- Fire
SWEP.ShootSoundIndoor = nil                     -- Fire indoors
SWEP.ShootSoundSilenced = ""                    -- Fire silenced
SWEP.ShootSoundSilencedIndoor = nil             -- Fire indoors silenced
SWEP.FirstShootSoundSilenced = nil              -- First fire silenced
SWEP.FirstDistantShootSound = nil               -- First distant fire
SWEP.DistantShootSound = ""                     -- Distant fire
SWEP.DistantShootSoundIndoor = nil              -- Distant fire indoors
SWEP.DistantShootSoundSilenced = nil            -- Distant fire silenced
SWEP.DistantShootSoundSilencedIndoor = nil      -- Distant fire indoors silenced
SWEP.FirstDistantShootSoundSilenced = nil       -- First distant fire silenced

SWEP.ShootSoundLooping = nil
SWEP.ShootSoundLoopingSilenced = nil
SWEP.ShootSoundLoopingIndoor = nil
SWEP.ShootSoundTail = nil -- played after the loop ends
SWEP.ShootSoundTailIndoor = nil

SWEP.IndoorSoundHardCutoff = false
SWEP.IndoorSoundHardCutoffRatio = 0.5

SWEP.Silencer = false -- Silencer installed or not?

SWEP.DistantShootSound = nil

SWEP.DryFireSound = ""
SWEP.DryFireSingleAction = false -- Play dryfire sound only once

SWEP.FiremodeSound = "arc9/firemode.ogg"
SWEP.ToggleAttSound = {
    "arc9/toggles/flashlight_laser_toggle_on_01.ogg",
    "arc9/toggles/flashlight_laser_toggle_on_02.ogg",
    "arc9/toggles/flashlight_laser_toggle_on_03.ogg",
}

SWEP.EnterSightsSound = ""
SWEP.ExitSightsSound = ""

SWEP.EnterBipodSound = "arc9/bipod_down.ogg"
SWEP.ExitBipodSound = "arc9/bipod_up.ogg"

SWEP.EnterUBGLSound = ""
SWEP.ExitUBGLSound = ""

SWEP.MalfunctionSound = ""

SWEP.MeleeHitSound = "arc9/melee_hitbody.ogg"
SWEP.MeleeHitWallSound = "arc9/melee_hitworld.ogg"
SWEP.MeleeSwingSound = "arc9/melee_miss.ogg"
SWEP.BackstabSound = "weapons/knife/knife_stab.wav"

SWEP.BreathInSound = "arc9/breath_inhale.ogg"
SWEP.BreathOutSound = "arc9/breath_exhale.ogg"
SWEP.BreathRunOutSound = "arc9/breath_runout.ogg"

SWEP.TriggerDownSound = ""
SWEP.TriggerUpSound = ""

-------------------------- EFFECTS

SWEP.NoMuzzleEffect = false -- Disable muzzle effect entirely
SWEP.NoFlash = false -- Disable light flash

SWEP.MuzzleParticle = nil -- Used for some muzzle effects.

SWEP.MuzzleEffect = "MuzzleFlash"
SWEP.FastMuzzleEffect = nil

SWEP.AfterShotEffect = "arc9_aftershoteffect"
SWEP.AfterShotParticle = nil -- Particle to spawn after shooting
SWEP.AfterShotParticleDelay = 0.01 -- Delay before spawning the particle

SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil
SWEP.ImpactSound = nil

SWEP.ShellEffect = nil -- Override the ARC9 shell eject effect for your own.
SWEP.ShellEffectCount = 1

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil -- string

SWEP.ExtraShellModels = nil -- For eventtable {{model = "", mat = "", scale = 1, physbox = Vector(1, 1, 1), pitch = 100, sounds = {}}}

SWEP.ShellSmoke = true

SWEP.NoShellEject = false -- Don't eject shell on fire
SWEP.NoShellEjectManualAction = false -- Don't eject shell while cycling
SWEP.ManualActionEjectAnyway = false -- Overrides standard behaviour to eject a shell when a shot is fired and manual action is on.

SWEP.ShellScale = 1
SWEP.ShellPhysBox = Vector(0.5, 0.5, 2)

SWEP.ShellPitch = 100 -- for shell sounds
SWEP.ShellSounds = ARC9.ShellSoundsTable

SWEP.RicochetSounds = ARC9.RicochetSounds

SWEP.ShellCorrectPos = Vector(0, 0, 0)
SWEP.ShellCorrectAng = Angle(0, 0, 0)
SWEP.ShellVelocity = nil -- nothing for random, otherwise keep this 0 - 2
SWEP.ShellTime = 0.5 -- Extra time these shells stay on the ground for.

SWEP.IgnoreMuzzleDevice = false -- Do not use the attachment muzzle device, use QCA muzzle instead.

SWEP.MuzzleEffectQCA = 1 -- QC Attachment that controls muzzle effect.
SWEP.AfterShotQCA = nil -- QC Attachment that controls after shot particle.
SWEP.CaseEffectQCA = 2 -- QC Attachment for shell ejection.
SWEP.CamQCA = nil -- QC Attachment for camera movement.
SWEP.CamQCA_Mult = nil -- Intensity for QC camera movement.
SWEP.CamQCA_Mult_ADS = nil -- Intensity for QC camera movement in ADS.
SWEP.CamCoolView = false -- Enable to use procedural camera movement. Set CamQCA to muzzle QCA or something.

SWEP.CamOffsetAng = Angle(0, 0, 0)

SWEP.DoFireAnimation = true

SWEP.NoViewBob = false

SWEP.BobSprintMult = 1 -- if your weapon have fancy sprint animation, layering procedural sprint on top of it may look bad,  so you might need to set this to 0.1
SWEP.BobWalkMult = 1 -- same but for all non sprint actions

-------------------------- VISUALS

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}
-- SWEP.BulletBonesSub1 = true -- if gun doesnt have chamber and all bulletsbones are in mag
SWEP.CaseBones = {}
-- Unlike BulletBones, these bones are determined by the missing bullet amount when reloading
SWEP.StripperClipBones = {}

-- The same as the bone versions but works via bodygroups.
-- Bodygroups work the same as in attachmentelements.
-- [0] = {ind = 0, bg = 1}
SWEP.BulletBGs = {}
SWEP.CaseBGs = {}
SWEP.StripperClipBGs = {}

SWEP.HideBones = {} -- bones to hide in third person and customize menu. {"list", "of", "bones"}
SWEP.ReloadHideBoneTables = { -- works only with TPIK
    -- [1] = {"list", "of", "bones"},
    -- [2] = {"list", "of", "bones"}
}
SWEP.ReloadHideBonesFirstPerson = false -- Set to true to enable HideBones even in first person.
-- Come on, fix your damn animations!

SWEP.ReloadPoseParameterTables = { -- Works very similarly to ReloadHideBoneTables
    -- [1] = {"pose" = 0, "parameter" = 1, "value" = 0},
    -- [2] = {"works" = 2, "like" = 3560, "this" = 0}
}

SWEP.PoseParameters = {} -- Poseparameters to manage. ["parameter"] = starting value.
-- This doesn't do anything, by the way.
-- Use animations to switch between different pose parameters.
-- When an animation is being played that switches between pose parameters, those parameters are all set to 0 for the animation.

-- The base manages these pose parameters:
-- firemode (Changes based on Fire Mode. Don't use this if you have animated firemode switching.)
-- sights (Changes based on sight delta)
-- sprint (Changes based on sprint delta)
-- empty (Changes based on whether a bullet is loaded)
-- ammo (Changes based on the ammo in the clip)


-------------------------- CAMO SYSTEM

SWEP.CustomCamoTexture = nil
SWEP.CustomCamoScale = 1
SWEP.CustomBlendFactor = nil

-------------------------- POSITIONS

SWEP.IronSights = {
    Pos = Vector(0, 0, 0),
    Ang = Angle(0, 0, 0),
    Magnification = 1,
    AssociatedSlot = 0, -- Attachment slot to associate the sights with. Causes RT scopes to render.
    CrosshairInSights = false,
    Blur = true, -- If arc9_fx_adsblur 1 then blur gun in that ironsights. Disable if your "ironsights" are not real ironsights
    ---- FLAT SCOPES
    -- These don't look very good; please use actual RT scopes if possible.
    FlatScope = false,
    FlatScopeOverlay = nil, -- Material()
    FlatScopeKeepVM = false,
    FlatScopeBlackBox = true,
    FlatScopeCC = nil -- Color correction table, see default.lua
}

SWEP.SightMidPoint = { -- Where the gun should be at the middle of it's irons
    Pos = Vector(-3, 15, -5),
    Ang = Angle(0, 0, -45),
}

SWEP.HasSights = true

-- Alternative "resting" position
SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

-- Position while walking/running (no sprint)
SWEP.MovingPos = nil -- Vector(0, 0, 0)
SWEP.MovingAng = nil -- Angle(0, 0, 0)

-- Position when crouching
SWEP.CrouchPos = Vector(-4, 1, -4)
SWEP.CrouchAng = Angle(0, 0, -30)

-- Position when sprinting or safe
SWEP.RestPos = Vector(0.532, -6, 0)
SWEP.RestAng = Angle(-4.633, 36.881, 0)

-- Overrides RestPos/Ang but only for sprinting
SWEP.SprintPos = nil
SWEP.SprintAng = nil
SWEP.SprintVerticalOffset = true -- Moves vm when looking up/down while sprinting (set to false if gun clips into camera)
SWEP.ReloadNoSprintPos = true -- No sprintpos during reloads

SWEP.NearWallPos = nil
SWEP.NearWallAng = nil

SWEP.HolsterPos = Vector(0, 0, -5)
SWEP.HolsterAng = Angle(0, -15, 25)

SWEP.VManipOffsetPos = Vector(2, 1, -0.3)
SWEP.VManipOffsetAng = Angle(0, 0, 10)

SWEP.MovingMidPoint = {
    Pos = Vector(0, 0, 0),
    Ang = Angle(0, 0, 0)
}

SWEP.SprintMidPoint = {
    Pos = Vector(4, 8, -4),
    Ang = Angle(0, 5, -25)
}

-- Position for customizing
SWEP.CustomizeAng = Angle(90, 0, 0)
SWEP.CustomizePos = Vector(20, 32, 4)
SWEP.CustomizeRotateAnchor = Vector(21.5, -4.27, -5.23)
-- To get this value:
-- 1. Line up your iron sights
-- 2. Take the X value of IronSights.Pos and put it in the Y value of anchor like this:
-- IronSights.Pos = Vector(-3.165, -5, 1.15)
-- CustomizeRotateAnchor = Vector(0, -3.165, 0)
-- 3. Set CustomizeRotateAnchor.x to around 15-30
-- 4. Set z to about -3
-- 5. Tweak x and z till it feels rights
-- Much more reliable and easy to do than Darsu difficult method
SWEP.CustomizeSnapshotFOV = 90
SWEP.CustomizeSnapshotPos = Vector(0, 0, 0)
SWEP.CustomizeSnapshotAng = Angle(0, 0, 0)
SWEP.CustomizeNoRotate = nil

SWEP.BipodPos = Vector(0, 0, 0)
SWEP.BipodAng = Angle(0, 0, 0)

SWEP.CantPeek = nil -- set to true if you dont want peeking on this gnu
SWEP.PeekPos = Vector(-1.5, 3, -4.5)
SWEP.PeekAng = Angle(0, 0.4, -35)
SWEP.NoPeekCrosshair = nil -- Not displays peek crosshair even if its enabled

SWEP.HeightOverBore = 1

-------------------------- HoldTypes

SWEP.HoldType = "shotgun"
SWEP.HoldTypeSprint = "passive"
SWEP.HoldTypeHolstered = nil
SWEP.HoldTypeSights = "smg"
SWEP.HoldTypeCustomize = "slam"
SWEP.HoldTypeBlindfire = "pistol"
SWEP.HoldTypeNPC = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.AnimReload = ACT_HL2MP_GESTURE_RELOAD_MAGIC -- While in TPIK only -- Tip: if you dont want any additional anim put ACT_HL2MP_GESTURE_RELOAD_MAGIC here instead!
SWEP.NonTPIKAnimReload = ACT_HL2MP_GESTURE_RELOAD_AR2 -- Non TPIK
SWEP.AnimDraw = false
SWEP.AnimMelee = ACT_FLINCH_PHYSICS
SWEP.NonTPIKAnimMelee = ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND

-------------------------- Shields

SWEP.ShieldModel = nil

SWEP.ShieldOffset = Vector(0, 0, 0)
SWEP.ShieldAngle = Angle(0, 0, 0)

SWEP.ShieldBone = "ValveBiped.Bip01_R_Hand"

SWEP.ShieldScale = 1

-------------------------- TTT

-- No free attachments when this gun is purchased
SWEP.TTTNoAttachmentsOnBuy = false

-- Automatically spawn in TTT
SWEP.TTTAutospawn = true

-- Specifically replace a certain weapon in TTT
SWEP.TTTWeaponType = nil

-- The chance this weapon will spawn in TTT
SWEP.TTTWeight = 100

-- Use a different ammo type in TTT
SWEP.TTTAmmoType = nil

-------------------------- Aim Assist

SWEP.NoAimAssist = nil -- Disable this weapon from utilizing aim assist.

-------------------------- ATTACHMENTS

SWEP.StandardPresets = nil -- A table of standard presets, that would be in every player preset menu, undeletable. Just put preset codes in ""
-- {
--     "[Compact]XQAA... regular preset code here",
--     "[Magpul kit]XQAA... regular preset code here",
-- }

SWEP.AttachmentBodygroups = {
    -- ["name"] = {
    --     VM = {
    --         {
    --             ind = 1,
    --             bg = 1
    --         }
    --     },
    --     WM = {
    --         {
    --             ind = 1,
    --             bg = 1
    --         }
    --     },
    -- }
}

-- Activate attachment elements by default.
SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    --[[]
    ["bg_name"] = {
        Bodygroups = {
            {1, 1}
        },
        AttPosMods = {
            [1] = { -- slot index
                Pos = Vector(),
                Ang = Angle(),
            }
        }
        Models = {
            Model = "",
            Pos = Vector(),
            Ang = Angle(),
            Bone = "",
            BoneMerge = false,
            Skin = 0,
            Bodygroups = "000",
            Scale = 1,
            ScaleVector = Vector(),
        }
        -- Other attachment parameters work here
    }
    ]]
}

-- Use to override attachment table entry data.
SWEP.AttachmentSlotMods = {
    -- ["name"] = {
    --     [1] = {
    --     }
    -- }
}

-- Adjust the stats of specific attachments when applied to this gun
SWEP.AttachmentTableOverrides = {
    -- ["att_name"] = {
    --     Mult_Recoil = 1
    -- }
}

-- The big one
SWEP.Attachments = {
    -- [1] = {
    --     PrintName = "",
    --     DefaultName = "No Attachment",
    --     DefaultIcon = Material(""),
    --     InstalledElements = {""}, -- list of elements to activate when something is installed here
    --     UnInstalledElements = {""},
    --     RequireElements = {}, -- {{a and b}, or {c and d and e}, or f}
    --     -- list of "strings" or {"lists", "of", "strings"}.
    --     -- one of these must all be enabled for this to be valid.
    --     ExcludeElements = {},
    --     -- same but for exclusion.
    --     RejectAttachments = { ["att_name"] = true }, -- Specifically refuse to allow certain attachments to be attached
    --     Integral = false, -- cannot be removed
    --     Category = "", -- single or {"list", "of", "values"}
    --     InstallSound = "",
    --     Bone = "",
    --     Pos = Vector(0, 0, 0),
    --     Ang = Angle(0, 0, 0),
    --     CorrectiveAng = Angle(0, 0, 0), -- sometimes, the autosolver needs a little help. Try (-1, -1, 0)
    --     Scale = 1,
    --     NoDraw = false, -- Do not draw the attachment's model. Might break some attachments.
    --     DuplicateModels = { -- For guns that require duplicating attachment models, e.g. akimbo or guns with 2 mags on model
    --          {
    --              Bone = "",
    --              Pos = Vector(0, 0, 0),
    --              Ang = Angle(0, 0, 0),
    --              Scale = 1,
    --              LaserCorrectionAngle = Angle(0, 0, 0),
    --          }
    --     },
    --     LaserCorrectionAngle = Angle(0, 0, 0), -- For lasers that are not perfectly aligned with the barrel
    --     Icon_Offset = Vector(0, 0, 0),
    --     KeepBaseIrons = false,
    --     ExtraSightDistance = 0,
    --     Installed = nil,
    --     MergeSlots = {}, -- merge this slot with another
    --     StickerModel = "", -- This is the model that will be used for the sticker
    --     StickerModelWorld = "", -- This is the model that will be used for the sticker on the world model. Good for mirror models
    --     CosmeticOnly = false, -- This attachment is cosmetic only, and will be placed in the Personalization tab.
    --     SubAttachments = {
    --         {
    --             Installed = "att_with_sub_atts",
    --             SubAttachments = {
    --                 {
    --                     Installed = "another_attachment",
    --                     SubAttachments = {
    --                         {
    --                             Installed = "even_more_nesting",
    --                             SubAttachments = {}
    --                         },
    --                         {
    --                             Installed = nil,
    --                         }
    --                     }
    --                 },
    --                 {
    --                     Installed = nil
    --                 },
    --                 {
    --                     Installed = "something_or_other",
    --                     SubAttachments = {}
    --                 }
    --             }
    --         },
    --         {
    --             Installed = nil,
    --             SubAttachments = {}
    --         }
    --     }
    -- }
}

-- draw
-- ready
-- holster
-- idle_1, idle_2, idle_3...
-- fire
-- fire_1, fire_2, fire_3...
-- dryfire
-- reload
-- reload_empty
-- trigger Trigger delay
-- untrigger Let go of trigger before fire
-- reload_ubgl
-- reload_start_1, reload_start_2, reload_start_3...: For reloads that require losing the spent shells. For example removing spent shells on a revolver or double barrel shotgun.
-- reload_insert_1, reload_insert_2, reload_insert_3...: Animation that reloads multiple rounds in at once, such as a stripper clip.
-- reload_insert_bullet_1, reload_insert_bullet_2, reload_insert_bullet_3...: Animation that reloads one by one at a time, such as a revolver or double barrel shotguns.
-- reload_finish, reload_finish_1, reload_finish_2...: Animation that finishes the reload based off of how much bullets you insert in your gun. _# prefix is bullets left to full after cancel reload.
-- enter_bipod, exit_bipod
-- enter_inspect, exit_inspect, idle_inspect
-- jam
-- fix
-- bash
-- impact
-- enter_sights, exit_sights, idle_sights
-- enter_sprint, exit_sprint, idle_sprint
-- toggle (F)
-- switchsights (alt+e)

-- pinpull (for grenades)
-- throw
-- toss
-- explodeinhands
-- touchoff (for C4)

-- Suffixes (Must be in this order):
-- _ubgl
-- _primed (Grenade primed)
-- _iron (When sighted)
-- _sights (Alternative to _iron)
-- _blindfire_left
-- _blindfire_right
-- _blindfire
-- _bipod
-- _sprint
-- _walk
-- _empty
-- _glempty
-- _ubgl (again)
-- _uncycled
-- _detonator

-- Randomization:

-- animname, 1_animname, 2_animname: will play one of these at random.
-- for example if you want 3 inspect animations you need
-- ["inspect"]
-- ["1_inspect"]
-- ["2_inspect"]

-- Not necessary; if your sequences are named the same as animations, they will be used automatically.

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Mult = 1.1,
    -- },
    -- ["draw"] = {
    --     Source = {"deploy", "deploy2"}, -- QC sequence source, can be {"table", "of", "strings"} or "string"
    --     RareSource = "magicdeploy", -- Has a small chance to play instead of normal source
    --     RareSourceChance = 0.01, -- chance that rare source will play
    --     Time = 0.5, -- overrides the duration of the sequence
    --     Mult = 1, -- multiplies time
    --     Reverse = false, -- Reverse the animation
    --     EjectAt = 0, -- Eject a shell at this time
    --     DropMagAt = 0, -- Drop magazine at this time
    --     InstantIdle = false, -- For firing animations, do not delay idle. Use only for guns with long shoot animations
    --     DelayedIdle = false, -- Idle immediately after playing this animation
    --     IKTimeLine = { -- t is in fraction of animation
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --             rhik = 0
    --         },
    --         {
    --             t = 0.9,
    --             lhik = 1
    --             rhik = 0
    --         }
    --     },
    --     EventTable = {
    --         {
    --             t = 1, -- in seconds
    --                 s = "", -- sound to play
    --                 c = CHAN_ITEM, -- sound channel
    --                 p = 1 -- sound pitch
    --                 v = 1 -- sound playback volume
    --                 l = 75 -- sound level in db
    --             shelleject = 1, -- eject a shell, true for regular eject, int for special ejection, can also be a table:
    --             shelleject = {
    --               index = 1, -- special index
    --               num = nil, -- amount to eject, can also be "clip" for the amount of remaining bullets
    --               upto = nil -- ejects num if clip is no less than this number, otherwise does nothing
    --             },
    --             e = "", -- effect to emit
    --             att = nil, -- on attachment point X
    --             mag = 100, -- with magnitude whatever this is
    --             ind = 0, -- change bodygroup,
    --             bg = 0, -- nil to reset
    --             ppi = 1, -- reloadposeparameters table, 0 for none, works just like reloadhidebones
    --             hide = 1, -- hide reloadhidebonetables table, 0 for none
    --             fl = 0, -- sound flags
    --             dsp = 0, -- dsp preset
    --         }
    --     },
    --     MagSwapTime = 0.5, -- in seconds, how long before the new magazine replaces the old one. For SWEP.BulletBones
    --     NoMagSwap = false, -- don't bother with above
    --     MinProgress = 0.9, -- seconds that must pass before the reload is considered done
    --     FireASAP = false, -- allowes to shoot right after clip anim was "done" with MinProgress; set to number if you want to control anim lock time while keeping minprogress same
    --     RestoreAmmo = 0, -- Restores ammunition to clip
    --     DumpAmmo = false, -- Dump clip on reload
    --     NoStatAffectors = false, -- do not adjust animation length based on stats (sprint to fire time, aim down sights time)
    -- }
}

SWEP.SuppressDefaultSuffixes = false -- Animations won't automatically play _iron, _empty, etc. versions of animations
SWEP.SuppressDefaultAnimations = false -- Animations won't automatically generated based on sequences defined in QC
SWEP.SuppressEmptySuffix = false -- _empty animations won't automatically trigger.
SWEP.SuppressSprintSuffix = false -- _sprint animations won't automatically trigger.
SWEP.SuppressDefaultEvents = false -- Animations will not trigger animation events.
SWEP.SuppressCumulativeShoot = false -- fire_1, fire_2, and fire_3 will not automatically trigger.

SWEP.InstantSprintIdle = false -- Instantly go to idle_sprint instead of playing enter_sprint.
SWEP.InstantSightIdle = false -- Instantly go to idle_sights instead of playing enter_sights.

SWEP.NoFireDuringSighting = false -- Makes enter_sights and exit_sights be important animations, no fire and other anims allowed. Slightly changes jam behaviour
SWEP.SightIsAlsoBipodAnims = false -- Weapons on bipod will use _sights suffix instead of _bipod
SWEP.UnbipodOnLockAnims = false -- Reloads/jams/draw/holsters/etc will unbipod weapon (but still call _bipod (or _sights ^) version of anim) without calling exit_bipod/exit_sights

SWEP.Primary.Automatic = true
SWEP.Primary.DefaultClip = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawCrosshair = true

SWEP.ARC9 = true

SWEP.m_bPlayPickupSound = false

SWEP.PCFs = {}
SWEP.MuzzPCFs = {}

SWEP.ActiveEffects = {}

local searchdir = "weapons/arc9_base"

local function autoinclude(dir)
    local files, dirs = file.Find(searchdir .. "/*.lua", "LUA")

    for _, filename in pairs(files) do
        if filename == "shared.lua" then continue end
        local luatype = string.sub(filename, 1, 2)

        if luatype == "sv" then
            if SERVER then
                include(dir .. "/" .. filename)
            end
        elseif luatype == "cl" then
            AddCSLuaFile(dir .. "/" .. filename)
            if CLIENT then
                include(dir .. "/" .. filename)
            end
        else
            AddCSLuaFile(dir .. "/" .. filename)
            include(dir .. "/" .. filename)
        end
    end

    for _, path in pairs(dirs) do
        autoinclude(dir .. "/" .. path)
    end
end

autoinclude(searchdir)

function SWEP:SetupDataTables()
    self:NetworkVar("Float", 0, "RecoilAmount")
    self:NetworkVar("Float", 1, "AnimLockTime")
    self:NetworkVar("Float", 2, "NextIdle")
    self:NetworkVar("Float", 3, "LastRecoilTime")
    self:NetworkVar("Float", 4, "RecoilUp")
    self:NetworkVar("Float", 5, "RecoilSide")
    self:NetworkVar("Float", 6, "SprintAmount")
    self:NetworkVar("Float", 7, "LastMeleeTime")
    self:NetworkVar("Float", 8, "TriggerDelay")
    self:NetworkVar("Float", 9, "ReloadTime")
    self:NetworkVar("Float", 10, "ReloadFinishTime")
    self:NetworkVar("Float", 11, "SightAmount")
    self:NetworkVar("Float", 12, "HeatAmount")
    self:NetworkVar("Float", 13, "MeleeAttackTime")
    self:NetworkVar("Float", 14, "FinishFiremodeAnimTime")
    self:NetworkVar("Float", 15, "IKTimeLineStart")
    self:NetworkVar("Float", 16, "IKTime")
    self:NetworkVar("Float", 17, "HolsterTime")
    self:NetworkVar("Float", 18, "CycleFinishTime")
    self:NetworkVar("Float", 19, "EnterBipodTime")
    self:NetworkVar("Float", 20, "Breath")
    self:NetworkVar("Float", 21, "SequenceCycle")
    self:NetworkVar("Float", 22, "SequenceSpeed")
    self:NetworkVar("Float", 23, "LastHolsterTime")
    self:NetworkVar("Float", 24, "GrenadePrimedTime")
    self:NetworkVar("Float", 25, "LockOnStartTime")
    self:NetworkVar("Float", 26, "LeanAmount")
    self:NetworkVar("Float", 27, "NearWallAmount")
    self:NetworkVar("Float", 28, "ReadyTime")

    self:NetworkVar("Int", 0, "BurstCount")
    self:NetworkVar("Int", 1, "NthShot")
    self:NetworkVar("Int", 2, "LoadedRounds")
    self:NetworkVar("Int", 3, "Firemode")
    self:NetworkVar("Int", 4, "NthReload")
    self:NetworkVar("Int", 5, "MultiSight")
    self:NetworkVar("Int", 6, "SequenceProxy")
    self:NetworkVar("Int", 7, "HideBoneIndex")
    self:NetworkVar("Int", 8, "SequenceIndex")
    self:NetworkVar("Int", 9, "LeanState")
    self:NetworkVar("Int", 10, "LastLoadedRounds")
    self:NetworkVar("Int", 11, "PoseParameterIndex")
    self:NetworkVar("Int", 12, "ReloadAmount")

    self:NetworkVar("Bool", 0, "Customize")
    self:NetworkVar("Bool", 1, "Reloading")
    self:NetworkVar("Bool", 2, "EndReload")
    self:NetworkVar("Bool", 3, "Safe")
    self:NetworkVar("Bool", 4, "Jammed")
    self:NetworkVar("Bool", 5, "Ready")
    self:NetworkVar("Bool", 6, "TriggerDown")
    self:NetworkVar("Bool", 7, "NeedTriggerPress")
    self:NetworkVar("Bool", 8, "UBGL")
    self:NetworkVar("Bool", 9, "EmptyReload")
    self:NetworkVar("Bool", 10, "InSights")
    self:NetworkVar("Bool", 11, "PrimedAttack")
    self:NetworkVar("Bool", 12, "Bash2")
    self:NetworkVar("Bool", 13, "NeedsCycle")
    self:NetworkVar("Bool", 14, "Bipod")
    self:NetworkVar("Bool", 15, "HeatLockout")
    self:NetworkVar("Bool", 16, "LastWasSprinting")
    self:NetworkVar("Bool", 17, "RequestReload")
    self:NetworkVar("Bool", 18, "InMeleeAttack")
    self:NetworkVar("Bool", 19, "OutOfBreath")
    self:NetworkVar("Bool", 20, "Inspecting")
    self:NetworkVar("Bool", 21, "AfterShot")
    self:NetworkVar("Bool", 22, "GrenadePrimed")
    self:NetworkVar("Bool", 23, "GrenadeTossing")
    self:NetworkVar("Bool", 24, "GrenadeRecovering")
    self:NetworkVar("Bool", 25, "LockedOn")
    self:NetworkVar("Bool", 26, "MidMeleeAttack")
    self:NetworkVar("Bool", 27, "DoAFastDraw")
    -- self:NetworkVar("Bool", 12, "BlindFire")
    -- self:NetworkVar("Bool", 15, "TraversalSprint")

    self:NetworkVar("Angle", 0, "FreeAimAngle")
    self:NetworkVar("Angle", 1, "LastAimAngle")
    self:NetworkVar("Angle", 2, "BipodAng")

    self:NetworkVar("Vector", 0, "VisualRecoilPos")
    self:NetworkVar("Vector", 1, "VisualRecoilPosVel")
    self:NetworkVar("Vector", 2, "VisualRecoilPosAcc")
    self:NetworkVar("Vector", 3, "BipodPos")
    self:NetworkVar("Vector", 4, "VisualRecoilAng")
    self:NetworkVar("Vector", 5, "VisualRecoilVel")
    self:NetworkVar("Vector", 6, "VisualRecoilAcc")

    self:NetworkVar("String", 0, "IKAnimation")

    self:NetworkVar("Entity", 0, "Holster_Entity")
    self:NetworkVar("Entity", 1, "LungeEntity")
    self:NetworkVar("Entity", 2, "ShieldEntity")
    self:NetworkVar("Entity", 3, "LockOnTarget")
    self:NetworkVar("Entity", 4, "DetonatorEntity")

    self:SetVisualRecoilAng(Vector(0, 0 ,0))
    self:SetVisualRecoilVel(Vector(0, 0, 0))
    self:SetVisualRecoilAcc(Vector(0, 0, 0))

    self:SetVisualRecoilPos(Vector(0, 0, 0))
    self:SetVisualRecoilPosVel(Vector(0, 0, 0))
    self:SetVisualRecoilPosAcc(Vector(0, 0, 0))

    self:SetMultiSight(1)
    self:SetLastWasSprinting(false)
    self:SetBreath(100)
    self:SetOutOfBreath(false)
    self:SetFiremode(1)
    self:SetAfterShot(false)
    self:SetGrenadePrimed(false)

    self:SetNextPrimaryFire(0)
    self:SetNextSecondaryFire(0)

    self:SetRecoilAmount(0)
    self:SetAnimLockTime(0)
    self:SetNextIdle(0)
    self:SetLastRecoilTime(0)
    self:SetRecoilUp(0)
    self:SetRecoilSide(0)
    self:SetSprintAmount(0)
    self:SetLastMeleeTime(0)
    self:SetTriggerDelay(0)
    self:SetReloadFinishTime(0)
    self:SetSightAmount(0)
    self:SetHeatAmount(0)
    self:SetMeleeAttackTime(0)
    self:SetFinishFiremodeAnimTime(0)
    self:SetIKTimeLineStart(0)
    self:SetIKTime(0)
    self:SetHolsterTime(0)
    -- self:SetBlindFireCornerAmount(0)
    self:SetEnterBipodTime(0)
    self:SetSequenceCycle(0)
    self:SetSequenceSpeed(0)
    self:SetLastHolsterTime(0)
    self:SetGrenadePrimedTime(0)
    self:SetLockOnStartTime(0)
    self:SetLeanAmount(0)
    self:SetNearWallAmount(0)
    self:SetReadyTime(0)
end

function SWEP:SecondaryAttack()
    if self:GetValue("UBGL") and self:GetProcessedValue("UBGLInsteadOfSights", true) then
        -- self:SetUBGL(true)
        self:ToggleUBGL(true)
        self:DoPrimaryAttack()
        -- self:SetUBGL(false)
    end
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_credits.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_credits.lua:
local function PaintScrollBar(panel, w, h)
    surface.SetDrawColor(ARC9.GetHUDColor("shadow"))
    surface.DrawRect(ScreenScale(3), 0 + ScreenScale(1), w - ScreenScale(3), h)

    surface.SetDrawColor(ARC9.GetHUDColor("fg"))
    surface.DrawRect(ScreenScale(2), 0, w - ScreenScale(3), h - ScreenScale(1))
end

function SWEP:CreateHUD_Credits()
    local bg = self.CustomizeHUD

    self:ClearTabPanel()

    local tp = vgui.Create("DScrollPanel", bg)
    tp:SetSize(ScreenScale(400), ScrH() - ScreenScale(76 + 4))
    tp:SetPos(ScrW() - ScreenScale(400 + 12), ScreenScale(76))
    tp.Paint = function(self2, w, h)
    end

    local scroll_preset = tp:GetVBar()
    scroll_preset.Paint = function() end
    scroll_preset.btnUp.Paint = function(span, w, h)
    end
    scroll_preset.btnDown.Paint = function(span, w, h)
    end
    scroll_preset.btnGrip.Paint = PaintScrollBar

    self.TabPanel = tp

    for title, trivia in pairs(self.Credits) do
        if title == "BaseClass" then continue end
        local newbtn2 = tp:Add("DPanel")
        newbtn2:SetSize(ScreenScale(200), ScreenScale(27))
        newbtn2:Dock(TOP)
        newbtn2.title = title
        newbtn2.trivia = trivia
        newbtn2.Paint = function(self2, w, h)
            if !IsValid(self) then return end
            -- title
            surface.SetFont("ARC9_8")
            local tw = surface.GetTextSize(self2.title)

            surface.SetFont("ARC9_8")
            surface.SetTextPos(w - tw - ScreenScale(1), ScreenScale(2 + 1))
            surface.SetTextColor(ARC9.GetHUDColor("shadow"))
            surface.DrawText(self2.title)

            surface.SetFont("ARC9_8")
            surface.SetTextPos(w - tw - ScreenScale(2), ScreenScale(2))
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.DrawText(self2.title)

            local major = self2.trivia

            surface.SetFont("ARC9_12")
            tw_p = surface.GetTextSize(major)

            surface.SetFont("ARC9_12")
            surface.SetTextPos(w - tw_p - ScreenScale(1), ScreenScale(12))
            surface.SetTextColor(ARC9.GetHUDColor("shadow"))
            ARC9.DrawTextRot(self2, major, 0, 0, math.max(w - tw_p - ScreenScale(1), ScreenScale(1)), ScreenScale(12 + 1), w)

            surface.SetFont("ARC9_12")
            surface.SetTextPos(w - tw_p - ScreenScale(2), ScreenScale(12))
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            ARC9.DrawTextRot(self2, major, 0, 0, math.max(w - tw_p - ScreenScale(2), 0), ScreenScale(12), w, true)
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_stats.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_holosight.lua:
local whitecolo = Color(255, 255, 255)

local colrcvar = GetConVar("arc9_reflex_r")
local colgcvar = GetConVar("arc9_reflex_g")
local colbcvar = GetConVar("arc9_reflex_b")

function SWEP:DoHolosight(mdl, atttbl)
    if self:GetSightAmount() <= 0 and !self:GetCustomize() and !atttbl.HoloSightAlwaysOn then return end
    if ARC9.OverDraw then return end
    if self:GetOwner() != LocalPlayer() then return end
    self.RenderingHolosight = true 
    
    local ref = 56

    -- render.ClearDepth()

    render.UpdateScreenEffectTexture()
    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_REPLACE)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)

    render.SetBlend(0)

    render.SetStencilReferenceValue(ref)

    -- render.OverrideDepthEnable(true, true)
    mdl:DrawModel()
    -- render.OverrideDepthEnable(false, false)
    -- cam.IgnoreZ(true)

    render.SetBlend(1)

    render.SetStencilPassOperation(STENCIL_KEEP)
    render.SetStencilCompareFunction(STENCIL_EQUAL)

    -- render.ClearBuffersObeyStencil(0, 0, 0, 0, true)
    -- render.ClearDepth()

    -- render.SetColorMaterial()
    -- render.DrawScreenQuad()

    -- cam.Start2D()

    -- surface.SetDrawColor(255, 255, 255)
    -- surface.DrawRect(0, 0, ScrW(), ScrH())

    -- render.SetColorMaterial()
    -- render.DrawScreenQuad()

    local reticle = self:GetSight().Reticle or atttbl.HoloSightReticle

    -- local eyedist = WorldToLocal(mdl:GetPos(), mdl:GetAngles(), EyePos(), EyeAngles()).x

    -- render.DepthRange(0, 0.0095 + (0.0003 * eyedist / 20))

    self:SetHoloSightRenderDepth(mdl, atttbl.HoloSightDepthAdjustment)

    -- render.DepthRange(0, 0.0098)

    if reticle then
        local pos = self:GetOwner():EyePos()
        
        if mdl.FakeHolosightAngleOffset then
            pos = pos + (mdl:GetAngles() + mdl.FakeHolosightAngleOffset):Forward() * 9000
        else
            pos = pos + mdl:GetAngles():Forward() * 9000
        end

        -- cam.Start3D()
        -- local dist = (mdl:GetPos() - self:GetOwner():EyePos()):Length()
        -- local s = atttbl.HoloSightSize / math.Clamp(dist / 7, 0.5, 3)
        local s = atttbl.HoloSightSize

        local col = atttbl.HoloSightColor or whitecolo

        if atttbl.HoloSightColorable then
            col = Color(0, 0, 0)
            col.r = colrcvar:GetFloat()
            col.g = colgcvar:GetFloat()
            col.b = colbcvar:GetFloat()
        end

        render.SetMaterial(reticle)

        local up = mdl:GetAngles():Up()
        local right = mdl:GetAngles():Right()

        local v1 = pos + (up * s / 2) - (right * s / 2)
        local v2 = pos + (up * s / 2) + (right * s / 2)
        local v3 = pos - (up * s / 2) + (right * s / 2)
        local v4 = pos - (up * s / 2) - (right * s / 2)


        -- render.DrawQuadEasy(pos, -mdl:GetAngles():Forward(), s, s, atttbl.HoloSightColor or Color(255, 255, 255))

        -- cam.Start3D(nil, nil, self.ViewModelFOV, nil, nil, nil, nil, 1, 10000 )
        render.DrawQuad(v1, v2, v3, v4, col or whitecolo)

        if atttbl.HoloSightFunc then
            atttbl.HoloSightFunc(self, pos, mdl)
        end
        -- cam.End3D()

        -- local toscreen = pos:ToScreen()

        -- local x = toscreen.x
        -- local y = toscreen.y

        -- local ss = ScreenScale(32)
        -- local sx = x - (ss / 2)
        -- local sy = y - (ss / 2)

        -- local shakey = math.min(cross * 35, 3)

        -- sx = sx + math.Round(math.Rand(-shakey, shakey))
        -- sy = sy + math.Round(math.Rand(-shakey, shakey))

        -- surface.SetMaterial(reticle)
        -- surface.SetDrawColor(255, 255, 255, 255)
        -- surface.DrawTexturedRect(sx, sy, ss, ss)

        -- surface.SetDrawColor(0, 0, 0)
        -- surface.DrawRect(0, 0, w, sy)
        -- surface.DrawRect(0, sy + ss, w, h - sy)

        -- surface.DrawRect(0, 0, sx, h)
        -- surface.DrawRect(sx + ss, 0, w - sx, h)
    end
    -- cam.End2D()


    render.DepthRange(0, 1)

    render.SetStencilEnable(false)

    -- mdl:DrawModel()
end

function SWEP:SetHoloSightRenderDepth(mdl, depthadj)
    local eyedist = WorldToLocal(mdl:GetPos(), mdl:GetAngles(), EyePos(), EyeAngles()).x

    render.DepthRange(0, (depthadj or 0.0093) + (0.0005 * eyedist / 20))
    -- render.DepthRange(0, (eyedist + 77.99) / 10000)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_model.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_vm.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_vmposition.lua:
SWEP.ViewModelPos = Vector(0, 0, 0)
SWEP.ViewModelAng = Angle(0, 0, 0)
SWEP.VMZOffsetForCamera = 0

SWEP.BenchGunViewModelPos = Vector(0, 0, 0)
SWEP.BenchGunViewModelAng = Angle(0, 0, 0)
local lht = 0
local sht = 0

-- local somevector = Vector(-1, 0, 1)
-- local somevector2 = Vector(0, 1, 0)
local somevector3 = Vector(-1, -1, 1)
-- local cangup = Vector(1, 0, 0)
-- local cangforward = Vector(0, 0, -1)
local oldpos = Vector(0, 0, 0)
local oldang = Angle(0, 0, 0)
local offsetpos = Vector(0, 0, 0)
local offsetang = Angle(0, 0, 0)
local extra_offsetpos = Vector(0, 0, 0)
local extra_offsetang = Angle(0, 0, 0)
local rotateAroundAngle = Angle(0, 0, 0)
local halfPi = math.pi / 2
local vmAddX = GetConVar("arc9_vm_addx")
local vmAddY = GetConVar("arc9_vm_addy")
local vmAddZ = GetConVar("arc9_vm_addz")
local arc9DevBenchGun = GetConVar("arc9_dev_benchgun")

local Lerp = function(a, v1, v2)
    local d = v2 - v1

    return v1 + (a * d)
end

local LerpVector = function(a, v1, v2)
    local d = v2 - v1

    return v1 + (a * d)
end

local LerpVectorEdit = function(a, v1, v2)
    local v11, v12, v13 = v1[1], v1[2], v1[3]
    local v21, v22, v23 = v2[1], v2[2], v2[3]
    v1[1] = Lerp(a, v11, v21)
    v1[2] = Lerp(a, v12, v22)
    v1[3] = Lerp(a, v13, v23)
end

local LerpAngle = function(a, v1, v2)
    -- angle aware lerp with Angles()
    local v11 = v1[1]
    local v12 = v1[2]
    local v13 = v1[3]
    local v21 = v2[1]
    local v22 = v2[2]
    local v23 = v2[3]
    local d1 = math.AngleDifference(v21, v11)
    local d2 = math.AngleDifference(v22, v12)
    local d3 = math.AngleDifference(v23, v13)
    local v3 = Angle(v11 + (a * d1), v12 + (a * d2), v13 + (a * d3))

    return v3
end

local LerpAngleEdit = function(a, v1, v2)
    local v11 = v1[1]
    local v12 = v1[2]
    local v13 = v1[3]
    local v21 = v2[1]
    local v22 = v2[2]
    local v23 = v2[3]
    local d1 = math.AngleDifference(v21, v11)
    local d2 = math.AngleDifference(v22, v12)
    local d3 = math.AngleDifference(v23, v13)
    v1[1] = v11 + (a * d1)
    v1[2] = v12 + (a * d2)
    v1[3] = v13 + (a * d3)
end

-- local ApproachVector = function(a1, a2, d)
--     a1[1] = math.Approach(a1[1], a2[1], d)
--     a1[2] = math.Approach(a1[2], a2[2], d)
--     a1[3] = math.Approach(a1[3], a2[3], d)
--     return a1
-- end
-- local Damp = function(a, v1, v2)
--     return Lerp(1 - math.pow(a, FrameTime()), v2, v1)
-- end
local DampVector = function(a, v1, v2)
    a = 1 - math.pow(a, FrameTime())

    return LerpVector(a, v2, v1)
end

local DampVectorEdit = function(a, v1, v2)
    a = math.pow(a, FrameTime())
    LerpVectorEdit(a, v1, v2)
end

local DampAngle = function(a, v1, v2)
    a = 1 - math.pow(a, FrameTime())

    return LerpAngle(a, v2, v1)
end

local DampAngleEdit = function(a, v1, v2)
    a = math.pow(a, FrameTime())
    LerpAngleEdit(a, v1, v2)
end

function SWEP:GetViewModelPosition(pos, ang)
    local owner = self:GetOwner()
    if !IsValid(owner) then return end
    -- if owner != LocalPlayer() then return end
    if CLIENT and owner ~= LocalPlayer() then return end

    local curTime = UnPredictedCurTime()

    pos, ang = self:DoCameraLean(pos, ang)
    oldpos:Set(pos)
    oldang:Set(ang)
    -- pos = Vector(0, 0, 0)
    -- ang = Angle(0, 0, 0)
    local cor_val = self:GetCorVal()
    extra_offsetpos:Zero()
    extra_offsetang:Zero()
    -- print(extra_offsetang)
    offsetpos:Set(self:GetProcessedValue("ActivePos", true))
    offsetang:Set(self:GetProcessedValue("ActiveAng", true))
    local maxspd, vel = owner:GetWalkSpeed() or 250, owner:OnGround() and owner:GetAbsVelocity():Length() or 0
    local movingpv = math.Clamp(math.Remap(vel, 0, maxspd, 0, 1), 0, 1)
    -- local movingpv = self.PV_Move
    local mvpos = self:GetProcessedValue("MovingPos", true)
    local mvang = self:GetProcessedValue("MovingAng", true)

    if (mvpos or mvang) and movingpv > 0.125 then
        -- local ts_movingpv = 0 -- self:GetTraversalSprintAmount()
        movingpv = math.ease.InOutQuad(movingpv)
        -- ts_movingpv = math.ease.InOutSine(ts_movingpv)
        -- movingpv = math.max(movingpv, ts_movingpv)
        if mvpos then
            offsetpos:Add(mvpos * movingpv)
        end
        if mvang then
            offsetang:Add(mvang * movingpv)
        end
        local wim = self:GetProcessedValue("MovingMidPoint", true)
        local mv_midpoint = movingpv * math.cos(movingpv * halfPi)
        local mv_joffset = (wim and wim.Pos or vector_origin) * mv_midpoint
        local mv_jaffset = (wim and wim.Ang or angle_zero) * mv_midpoint
        extra_offsetpos:Add(mv_joffset)
        extra_offsetang:Add(mv_jaffset) -- what does all this extra offset stuff do?
    end

    -- if self.PV_Move > 0.2 and self:GetSprintDelta() == 0 then
    --     offsetpos:Set(self:GetProcessedValue("MovingPos"))
    --     offsetang:Set(self:GetProcessedValue("MovingAng"))
    -- end
    local getbipod = self:GetBipod()
    local reloading = self:GetReloading()

    if getbipod then
        local bipodamount = self:GetBipodAmount()
        bipodamount = math.ease.InOutQuad(bipodamount)
        local sightpos, sightang = self:GetSightPositions()
        local bipodpos, bipodang = self:GetProcessedValue("BipodPos", true), self:GetProcessedValue("BipodAng", true)

        if bipodpos and bipodang then
            if !self:ShouldTPIK() then LerpVectorEdit(math.Clamp(bipodamount - self:GetSightAmount(), 0, 1), pos, self:GetBipodPos()) end
            LerpVectorEdit(bipodamount, offsetpos, bipodpos)
            LerpAngleEdit(bipodamount, offsetang, bipodang)
        else
            offsetpos:Add(sightpos * bipodamount)
            offsetang:Add(sightang * bipodamount)
        end
    else
        local crouchpos = self:GetProcessedValue("CrouchPos", true)
        local crouchang = self:GetProcessedValue("CrouchAng", true)
        local viewOffsetZ = owner:GetViewOffset().z
        local crouchdelta = math.Clamp(math.ease.InOutSine((viewOffsetZ - owner:GetCurrentViewOffset().z) / (viewOffsetZ - owner:GetViewOffsetDucked().z)), 0, 1)

        if crouchpos then
            offsetpos:Add(crouchpos * crouchdelta)
            -- LerpVectorEdit(crouchdelta, offsetpos, crouchpos)
        end

        if crouchang then
            offsetang:Add(crouchang * crouchdelta)
            -- LerpAngleEdit(crouchdelta, offsetang, crouchang)
        end
    end

    if VManip != nil and self:GetSightAmount() < 0.3 then
        local vmanipmult = ((VManip:IsActive() and (VManip.VMatrixlerp < 0.3 or VManip.Cycle < 0.3)) and 1 or 0)
        if owner.GetSliding then if owner:GetSliding() then vmanipmult = 0 end end -- vmanip quickslides ASS
        offsetpos:Add(self.VManipOffsetPos * vmanipmult)
        offsetang:Add(self.VManipOffsetAng * vmanipmult)
    end

    -- local blindfiredelta = self:GetBlindFireAmount()
    -- local blindfirecornerdelta = self:GetBlindFireCornerAmount()
    -- local curvedblindfiredelta = self:Curve(blindfiredelta)
    -- local curvedblindfirecornerdelta = self:Curve(math.abs(blindfirecornerdelta))
    -- if blindfiredelta > 0 then
    --     offsetpos = LerpVector(curvedblindfiredelta, offsetpos, self:GetValue("BlindFirePos"))
    --     offsetang = LerpAngle(curvedblindfiredelta, offsetang, self:GetValue("BlindFireAng"))
    --     if blindfirecornerdelta > 0 then
    --         offsetpos = LerpVector(curvedblindfirecornerdelta, offsetpos, self:GetValue("BlindFireRightPos"))
    --         offsetang = LerpAngle(curvedblindfirecornerdelta, offsetang, self:GetValue("BlindFireRightAng"))
    --     elseif blindfirecornerdelta < 0 then
    --         offsetpos = LerpVector(curvedblindfirecornerdelta, offsetpos, self:GetValue("BlindFireLeftPos"))
    --         offsetang = LerpAngle(curvedblindfirecornerdelta, offsetang, self:GetValue("BlindFireLeftAng"))
    --     end
    -- end
    if reloading then
        local reloadpos = self:GetProcessedValue("ReloadPos", true)
        local reloadang = self:GetProcessedValue("ReloadAng", true)
        local fuckingreloadprocess
        local fuckingreloadprocessinfluence = 1

        if reloadpos then
            if !self:GetProcessedValue("ShotgunReload", true) then
                fuckingreloadprocess = math.Clamp(1 - (self:GetReloadFinishTime() - curTime) / (self.ReloadTime * self:GetAnimationTime("reload")), 0, 1)
                if fuckingreloadprocess < 0.666 then
                    fuckingreloadprocessinfluence = fuckingreloadprocess * 1.333
                elseif fuckingreloadprocess > 0.8 then
                    fuckingreloadprocessinfluence = 1 - ((fuckingreloadprocess - 0.8) * 5)
                end
            end

            offsetpos:Sub(reloadpos * fuckingreloadprocessinfluence)
        end

        if reloadang then
            offsetang:Sub(reloadang * fuckingreloadprocessinfluence)
        end
    end

    do
        local offsetangRight = offsetang:Right()
        local offsetangForward = offsetang:Forward()
        local offsetangUp = offsetang:Up()
        offsetangRight:Mul(vmAddY:GetFloat())
        offsetangForward:Mul(vmAddX:GetFloat())
        offsetangUp:Mul(vmAddZ:GetFloat())
        offsetpos:Add(offsetangRight)
        offsetpos:Add(offsetangForward)
        offsetpos:Add(offsetangUp)
    end

    local sightdelta = self:GetSightDelta()
    -- cor_val = Lerp(sightdelta, cor_val, 1)
    self.SwayScale = 0

    if sightdelta > 0 then
        if self:GetInSights() then
            sightdelta = math.ease.OutQuart(sightdelta)
        else
            sightdelta = math.ease.InQuart(sightdelta)
        end

        -- sightdelta = math.ease.InOutQuad(sightdelta)
        local sightpos, sightang = self:GetSightPositions()
        local sight = self:GetSight()
        local eepos, eeang = self:GetExtraSightPositions()
		local peekp, peeka = "PeekPos", "PeekAng"
		local fuckingreloadprocess = math.Clamp(1 - (self:GetReloadFinishTime() - curTime) / (self.ReloadTime * self:GetAnimationTime("reload")), 0, 1)
		local reloadanim = self:GetAnimationEntry(self:TranslateAnimation("reload"))
		local shotgun = self:GetShouldShotgunReload()
		
		if (!shotgun and fuckingreloadprocess < (reloadanim.PeekProgress or reloadanim.MinProgress or 0.9)) or (shotgun and self:GetReloading()) then
			if self.PeekPosReloading then peekp = "PeekPosReloading" end
			if self.PeekAngReloading then peeka = "PeekAngReloading" end
		end

        -- if input.IsKeyDown(input.GetKeyCode(input.LookupBinding("menu_context"))) then
        if self.Peeking then
            eepos = eepos + self:GetProcessedValue(peekp, true)
            eeang = eeang + self:GetProcessedValue(peeka, true)
        end

        if sight.GeneratedSight then
            local t_sightpos = LerpVector(sightdelta, vector_origin, sightpos)
            local t_sightang = LerpAngle(sightdelta, angle_zero, sightang)
            ang:RotateAroundAxis(oldang:Up(), t_sightang[1])
            ang:RotateAroundAxis(oldang:Right(), t_sightang[2])
            ang:RotateAroundAxis(oldang:Forward(), t_sightang[3])
            local angRight = ang:Right()
            local angForward = ang:Forward()
            local angUp = ang:Up()
            angRight:Mul(t_sightpos[1])
            angForward:Mul(t_sightpos[2])
            angUp:Mul(t_sightpos[3])
            pos:Add(angRight)
            pos:Add(angForward)
            pos:Add(angUp)
            LerpVectorEdit(sightdelta, offsetpos, vector_origin)
            LerpAngleEdit(sightdelta, offsetang, angle_zero)
        else
            offsetpos = LerpVector(sightdelta, offsetpos or vector_origin, sightpos or vector_origin)
            offsetang = LerpAngle(sightdelta, offsetang or angle_zero, sightang or angle_zero)
        end

        -- local eepos, eeang = Vector(0, 0, 0), Angle(0, 0, 0)
        local im = self:GetProcessedValue("SightMidPoint", true)
        local midpoint = sightdelta * math.cos(sightdelta * halfPi)
        local joffset = (im and im.Pos or vector_origin) * midpoint
        local jaffset = (im and im.Ang or angle_zero) * midpoint
        LerpVectorEdit(sightdelta, extra_offsetpos, eepos + joffset)
        LerpAngleEdit(sightdelta, extra_offsetang, eeang + jaffset)
        -- self.BobScale = 0
        -- self.SwayScale = Lerp(sightdelta, 1, 0.1)
    end

    local fswayang

    if self.InertiaEnabled then
        fswayang = self:GetInertiaSwayAngles()

        local inertiaanchor
        if self.InertiaCustomAnchor then 
            inertiaanchor = self.InertiaCustomAnchor 
        else
            inertiaanchor = Vector(self.CustomizeRotateAnchor)
            inertiaanchor.x = inertiaanchor.x * ((self.RenderingHolosight or self.RenderingRTScope) and 0.75 or 0.4)
        end

        local rap_pos, rap_ang = self:RotateAroundPoint2(pos, ang, inertiaanchor, vector_origin, fswayang * -0.5)
        pos:Set(rap_pos)
        ang:Set(rap_ang)
    else
        fswayang = self:GetFreeSwayAngles()
        if fswayang then
            local getfreeswayang, getfreeswayoffset = fswayang, self:GetFreeAimOffset()
            extra_offsetang[2] = extra_offsetang[2] - (getfreeswayang[1] * cor_val)
            extra_offsetang[1] = extra_offsetang[1] + (getfreeswayang[2] * cor_val)
            extra_offsetang[2] = extra_offsetang[2] - (getfreeswayoffset[1] * cor_val)
            extra_offsetang[1] = extra_offsetang[1] + (getfreeswayoffset[2] * cor_val)
        end
    end

    -- self.CustomizeDelta is modified in ThinkCustomize now

    local curvedcustomizedelta = self:Curve(self.CustomizeDelta)
    -- local sprintdelta = self:Curve(self:GetSprintDelta())
    local sprintdelta = self:GetSprintDelta()

    if sprintdelta > 0 then
        -- local ts_sprintdelta = 0 -- self:GetTraversalSprintAmount()
        sprintdelta = math.ease.InOutQuad(sprintdelta) - curvedcustomizedelta
        -- ts_sprintdelta = math.ease.InOutSine(ts_sprintdelta)
        -- sprintdelta = math.max(sprintdelta, ts_sprintdelta)
        local sprpos = self:GetProcessedValue("SprintPos", true) or self:GetProcessedValue("RestPos", true)
        local sprang = self:GetProcessedValue("SprintAng", true) or self:GetProcessedValue("RestAng", true)
        -- sprpos = LerpVector(ts_sprintdelta, sprpos, self:GetProcessedValue("TraversalSprintPos"))
        -- sprang = LerpAngle(ts_sprintdelta, sprang, self:GetProcessedValue("TraversalSprintAng"))
        LerpVectorEdit(sprintdelta, offsetpos, sprpos)
        LerpAngleEdit(sprintdelta, offsetang, sprang)
        LerpAngleEdit(sprintdelta, extra_offsetang, angle_zero)
        local sim = self:GetProcessedValue("SprintMidPoint", true)
        local spr_midpoint = sprintdelta * math.cos(sprintdelta * halfPi)
        local spr_joffset = (sim and sim.Pos or vector_origin) * spr_midpoint
        local spr_jaffset = (sim and sim.Ang or angle_zero) * spr_midpoint
        extra_offsetpos:Add(spr_joffset)
        extra_offsetang:Add(spr_jaffset)
    end

    local nearwalldelta = self:GetNearWallAmount()

    if nearwalldelta > 0 then
        nearwalldelta = math.ease.InOutQuad(nearwalldelta) - curvedcustomizedelta
        -- sprintdelta = math.max(sprintdelta, ts_sprintdelta)
        local sprpos = self:GetProcessedValue("NearWallPos", true) or self:GetProcessedValue("SprintPos", true) or self:GetProcessedValue("RestPos", true)
        local sprang = self:GetProcessedValue("NearWallAng", true) or self:GetProcessedValue("SprintAng", true) or self:GetProcessedValue("RestAng", true)
        -- sprpos = LerpVector(ts_sprintdelta, sprpos, self:GetProcessedValue("TraversalSprintPos"))
        -- sprang = LerpAngle(ts_sprintdelta, sprang, self:GetProcessedValue("TraversalSprintAng"))
        LerpVectorEdit(nearwalldelta, offsetpos, sprpos)
        LerpAngleEdit(nearwalldelta, offsetang, sprang)
        LerpAngleEdit(nearwalldelta, extra_offsetang, angle_zero)
    end

    if curvedcustomizedelta > 0 then
        local cpos = Vector(self:GetProcessedValue("CustomizePos", true))
        local cang = self:GetProcessedValue("CustomizeAng", true)
        LerpVectorEdit(curvedcustomizedelta, extra_offsetpos, vector_origin)
        LerpAngleEdit(curvedcustomizedelta, extra_offsetang, angle_zero)

        if self.BottomBarMode == 1 then
            cpos[3] = cpos[3] + 2
        else
            cpos[3] = cpos[3] + 1.5
        end

        cpos[1] = cpos[1] + self.CustomizePanX
        cpos[3] = cpos[3] - self.CustomizePanY
        cpos[2] = cpos[2] + self.CustomizeZoom - 15
        LerpVectorEdit(curvedcustomizedelta, offsetpos, cpos)
        LerpAngleEdit(curvedcustomizedelta, offsetang, cang)
    end

    local ht = self:GetHolsterTime()

    if (ht + 0.1) > curTime then
        if ht > lht then
            sht = curTime
        end

        local hdelta = 1 - ((ht - curTime) / (ht - sht))

        if hdelta > 0 then
            hdelta = math.ease.InOutQuad(hdelta)
            LerpVectorEdit(hdelta, offsetpos, self:GetValue("HolsterPos"))
            LerpAngleEdit(hdelta, offsetang, self:GetValue("HolsterAng"))
        end
    end

    lht = ht
    local angup, angright, angforward = ang:Up(), ang:Right(), ang:Forward()
    local oldangup, oldangright, oldangforward = oldang:Up(), oldang:Right(), oldang:Forward()
    angright:Mul(offsetpos[1])
    angforward:Mul(offsetpos[2])
    angup:Mul(offsetpos[3])
    pos:Add(angright)
    pos:Add(angforward)
    pos:Add(angup)
    ang:RotateAroundAxis(oldangup, offsetang.p)
    ang:RotateAroundAxis(oldangright, offsetang.y)
    ang:RotateAroundAxis(oldangforward, offsetang.r)
    angup, angright, angforward = ang:Up(), ang:Right(), ang:Forward()
    ang:RotateAroundAxis(oldangup, extra_offsetang[1])
    ang:RotateAroundAxis(oldangright, extra_offsetang[2])
    ang:RotateAroundAxis(oldangforward, extra_offsetang[3])
    oldangright:Mul(extra_offsetpos[1])
    oldangforward:Mul(extra_offsetpos[2])
    oldangup:Mul(extra_offsetpos[3])
    pos:Add(oldangright)
    pos:Add(oldangforward)
    pos:Add(oldangup)

    -- idle breath
    if curvedcustomizedelta <= 0 then
        local sighted = Lerp(sightdelta, 1, 0.1)
        local ct = curTime * math.pi * Lerp(sightdelta, 1, 0.5)
        -- making parenthesis on (sightes * math.sin) cuz it creates number first and then multiplies vector to it
        -- if we won't do it, then vector would be multiplied by sighted,
        -- new vector will be created and there would be 3 additional vectors, which won't be used
        pos:Sub(angright * (sighted * math.sin(ct * 0.8) * 0.01)) -- X
        pos:Sub(angup * (sighted * math.cos(ct * 0.84) * 0.02)) -- Y
        pos:Sub(angforward * (sighted * math.cos(ct * 0.84) * 0.02)) -- Z
        ang:RotateAroundAxis(angright, sighted * math.sin(ct * 0.84) * -0.07) -- P
        ang:RotateAroundAxis(angup, sighted * math.cos(ct * -0.65) * -0.07) -- Y
        ang:RotateAroundAxis(angforward, sighted * math.sin(ct * 0.5) * 0.25) -- R
    end

    pos, ang = self:GetViewModelRecoil(pos, ang, cor_val)

    if !self:GetProcessedValue("NoViewBob", true) then
        pos, ang = self:GetViewModelBob(pos, ang)
        pos, ang = self:GetMidAirBob(pos, ang)
    end

    -- pos, ang = self:GetViewModelLeftRight(pos, ang)
    pos, ang = self:GetViewModelInertia(pos, ang)
    if !self.InertiaEnabled then pos, ang = self:GetViewModelSway(pos, ang) end
    pos, ang = self:GetViewModelSmooth(pos, ang)
    pos, ang = WorldToLocal(pos, ang, oldpos, oldang)

    -- No point checking IsFirstTimePredicted in a client function (this is not predicted!!)
    -- This was causing choppy viewmodel movement at lower tickrates in dedicated servers
    DampVectorEdit(0.0000005, pos, self.ViewModelPos)
    DampAngleEdit(0.00001, ang, self.ViewModelAng)
    self.ViewModelPos = pos
    self.ViewModelAng = ang

    pos, ang = LocalToWorld(pos, ang, oldpos, oldang)

    -- CUSTOMISATION ROTATION AFTER DAMPING
    if curvedcustomizedelta > 0 then
        if !self.CustomizeNoRotate then
            self.CustomizePitch = math.NormalizeAngle(self.CustomizePitch) * curvedcustomizedelta
            self.CustomizeYaw = math.NormalizeAngle(self.CustomizeYaw) * curvedcustomizedelta
            -- local CustomizeRotateAnchor = Vector(21.5, -4.27, -5.23)
            rotateAroundAngle[2] = self.CustomizePitch
            rotateAroundAngle[3] = self.CustomizeYaw
            local rap_pos, rap_ang = self:RotateAroundPoint2(pos, ang, self:GetProcessedValue("CustomizeRotateAnchor", true), vector_origin, rotateAroundAngle)
            pos:Set(rap_pos)
            ang:Set(rap_ang)
        end
    end

    pos, ang = self:GunControllerRHIK(pos, ang)
    pos, ang = self:GunControllerThirdArm(pos, ang)
    self.LastViewModelPos = pos
    self.LastViewModelAng = ang
    local wm = self:GetWM()

    if IsValid(wm) and curvedcustomizedelta == 0 then
        if !self:ShouldTPIK() then
            wm.slottbl.Pos = self.WorldModelOffset.Pos
            wm.slottbl.Ang = self.WorldModelOffset.Ang
        else
            if self.NoTPIKVMPos then
                wm.slottbl.Pos = self.WorldModelOffset.TPIKPos or self.WorldModelOffset.Pos
                wm.slottbl.Ang = self.WorldModelOffset.TPIKAng or self.WorldModelOffset.Ang
            elseif LocalPlayer() == owner then
                wm.slottbl.Pos = (self.WorldModelOffset.TPIKPos or self.WorldModelOffset.Pos) - self.ViewModelPos * somevector3
                wm.slottbl.Ang = (self.WorldModelOffset.TPIKAng or self.WorldModelOffset.Ang) + Angle(self.ViewModelAng.p, -self.ViewModelAng.y, self.ViewModelAng.r)
            end
        end
    end

    if arc9DevBenchGun:GetBool() then return self.BenchGunViewModelPos, self.BenchGunViewModelAng end
    self.BenchGunViewModelPos = pos
    self.BenchGunViewModelAng = ang

    -- shhh, thing for SWEP.RecoilKickAffectPitch
    ang.p = ang.p + self.VMZOffsetForCamera
    pos.z = pos.z + self.VMZOffsetForCamera * 0.05

    return pos, ang
end

-- local Damp = function(a, v1, v2) return Lerp(1 - math.pow(a, FrameTime()), v2, v1) end
SWEP.SmoothedViewModelFOV = nil
local arc9Fov = GetConVar("arc9_fov")

function SWEP:GetViewModelFOV()
    local owner = self:GetOwner()
    local ownerfov = owner:GetFOV()
    local convarfov = arc9Fov:GetInt()
    -- local curTime = UnPredictedCurTime()
    -- local target = owner:GetFOV() + convarfov
    local target = (self:GetProcessedValue("ViewModelFOVBase", true) or ownerfov) + (self:GetCustomize() and 0 or convarfov)

	local vmfov = (self.IronSights.ViewModelFOV or (self:GetProcessedValue("ViewModelFOVBase", true) or 70))
	local mag = self:GetMagnification()

    if self:GetInSights() then
		target = self:GetSight().ViewModelFOV or (75 + convarfov)
        if self.Peeking then target = math.max(target, self.PeekMaxFOV or 37) end -- low vm fov sights look weird in peek, ez fix
	end

    if self:GetCustomize() then
        target = self.CustomizeSnapshotFOV or 90
    end

    if arc9DevBenchGun:GetBool() then
        target = owner:GetFOV()
    end

    self.SmoothedViewModelFOV = self.SmoothedViewModelFOV or target
    local diff = math.abs(target - self.SmoothedViewModelFOV)
    self.SmoothedViewModelFOV = math.Approach(self.SmoothedViewModelFOV, target, math.max(diff / self:GetProcessedValue("AimDownSightsTime"), diff, 1) * FrameTime())
    -- note, setting adstime modifier to 0 results in nan and inf for obvious reasons, happened before and not fixing it for this
    -- return 60 * self:GetSmoothedFOVMag()
    -- return 150
    -- return owner:GetFOV() * (self:GetProcessedValue("DesiredViewModelFOV") / 90) * math.pow(self:GetSmoothedFOVMag(), 1/4)

    return self.SmoothedViewModelFOV
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_animtranslate.lua:
function SWEP:TranslateAnimation(seq)
    if self:GetOwner():IsNPC() then return seq end

    local sds = self:GetProcessedValue("SuppressDefaultSuffixes", true)

    if !sds then
        if self:GetUBGL() and self:HasAnimation(seq .. "_ubgl") then
            seq = seq .. "_ubgl"
        end

        if self:GetGrenadePrimed() and self:HasAnimation(seq .. "_primed") then
            seq = seq .. "_primed"
        end

        if self:GetGrenadeTossing() and self:HasAnimation(seq .. "_toss") then
            seq = seq .. "_toss"
        end

        if self:GetInSights() and self:HasAnimation(seq .. "_iron") then
            seq = seq .. "_iron"
        end

        if self:GetInSights() and self:HasAnimation(seq .. "_sights") then
            seq = seq .. "_sights"
        end

        -- if self:GetBlindFire() and self:GetBlindFireDirection() < 0 and self:HasAnimation(seq .. "_blindfire_left") then
        --     seq = seq .. "_blindfire_left"
        -- end

        -- if self:GetBlindFire() and self:GetBlindFireDirection() < 0 and self:HasAnimation(seq .. "_blindfire_right") then
        --     seq = seq .. "_blindfire_right"
        -- end

        -- if self:GetBlindFire() and self:HasAnimation(seq .. "_blindfire") then
        --     seq = seq .. "_blindfire"
        -- end

        if self:GetBipod() then
            if !self.SightIsAlsoBipodAnims and self:HasAnimation(seq .. "_bipod") then
                seq = seq .. "_bipod"
            end

            if self.SightIsAlsoBipodAnims and self:HasAnimation(seq .. "_sights") then
                seq = seq .. "_sights"
            end
        end

        if !self:GetProcessedValue("SuppressSprintSuffix", true) and self:GetIsSprinting() and self:HasAnimation(seq .. "_sprint") then
            seq = seq .. "_sprint"
        elseif self:GetIsWalking() and self:HasAnimation(seq .. "_walk") then
            seq = seq .. "_walk"
        end

        if !self:GetProcessedValue("SuppressEmptySuffix", true) and ((self:Clip1() == 0 and !self:GetReloading()) or self:GetEmptyReload()) and self:HasAnimation(seq .. "_empty") then
            seq = seq .. "_empty"
        end

        if !self:GetProcessedValue("SuppressEmptySuffix", true) and ((self:Clip2() == 0 and !self:GetReloading()) or self:GetEmptyReload()) and self:HasAnimation(seq .. "_glempty") then
            seq = seq .. "_glempty"
        end

        if self:GetUBGL() and self:HasAnimation(seq .. "_ubgl") then
            seq = seq .. "_ubgl"
        end

        if self:GetNeedsCycle() and self:HasAnimation(seq .. "_uncycled") then
            seq = seq .. "_uncycled"
        end

        if IsValid(self:GetDetonatorEntity()) and self:HasAnimation(seq .. "_detonator") then
            seq = seq .. "_detonator"
        end
    end

    local traq = self:RunHook("Hook_TranslateAnimation", seq) or seq

    if self:HasAnimation(traq) then
        seq = traq
    end

    if istable(seq) then
        seq["BaseClass"] = nil
        seq = seq[math.Round(util.SharedRandom("ARC9_animtr", 1, #seq))]
        local rando = {seq}

        local i = 1
        while self:HasAnimation(tostring(i) .. "_" .. seq, true) do
            table.insert(rando, tostring(i) .. "_" .. seq)
            i = i + 1
        end

        seq = rando[math.Round(util.SharedRandom("ARC9_animtr", 1, #rando))]
    end


    return seq
end

function SWEP:HasAnimation(seq, lq)
    local seqr = self:RunHook("Hook_BlockHasAnimation", seq)

    if !seqr then return false end

    if self.Animations[seq] or self.IKAnimationProxy[seq] then
        return true
    end

    if lq then return false end

    local vm = self:GetVM()

    if !IsValid(vm) then return true end
    seq = vm:LookupSequence(seq)

    return seq != -1
end

function SWEP:GetAnimationTime(anim)
    local entry = self:GetAnimationEntry(anim)

    if !entry then return 0 end

    if entry.Time then return entry.Time end

    local seq = entry.Source

    if istable(seq) then seq = seq[1] end

    return self:GetSequenceTime(seq)
end

function SWEP:GetSequenceTime(seq)
    local vm = self:GetVM()
    if !IsValid(vm) then return 1 end
    seq = vm:LookupSequence(seq or "")

    return vm:SequenceDuration(seq)
end

function SWEP:GetAnimationEntry(seq)
    if self:HasAnimation(seq) then
        if self.IKAnimationProxy[seq] then
            return self.IKAnimationProxy[seq]
        else
            if self.Animations[seq] then
                return self.Animations[seq]
            elseif !self:GetProcessedValue("SuppressDefaultAnimations", true) then
                return {
                    Source = seq,
                    Time = self:GetSequenceTime(seq)
                }
            end
        end
    else
        return {}
    end
end

SWEP.IKAnimationProxy = {}

function SWEP:AddProxyToAnimProxyTable(tbl, model, atttbl, address)
    for anim, animtable in pairs(tbl) do
        local newanimtable = table.Copy(animtable)
        if !self.IKAnimationProxy[anim] then
            self.IKAnimationProxy[anim] = newanimtable
        else
            if (tbl.Priority or 0) > self.IKAnimationProxy[anim].Priority then
                self.IKAnimationProxy[anim] = newanimtable
            else
                continue
            end
        end

        newanimtable.ProxyAnimation = true
        newanimtable.Model = model
        newanimtable.Priority = newanimtable.Priority or 0
        newanimtable.ModelName = atttbl.Model
        newanimtable.Address = address
        newanimtable.MotionAttachment = atttbl.IKGunMotionQCA
        newanimtable.AlsoPlayBase = atttbl.IKAnimationAlsoPlayBase
    end
end

function SWEP:SetupAnimProxy()
    self.IKAnimationProxy = {}

    for _, slottbl in ipairs(self:GetSubSlotList()) do
        local atttbl = self:GetFinalAttTable(slottbl)

        if atttbl.IKAnimationProxy then
            self:AddProxyToAnimProxyTable(atttbl.IKAnimationProxy, slottbl.GunDriverModel or slottbl.VModel or slottbl.WModel, atttbl, slottbl.Address)
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_cycle.lua:
function SWEP:ThinkCycle()
    if self:GetNeedsCycle() and self:GetCycleFinishTime() != 0 and self:GetCycleFinishTime() <= CurTime() then
        self:SetNeedsCycle(false)
        self:SetCycleFinishTime(0)
    end
    if self:StillWaiting() then return end
    local owner = self:GetOwner()

    local manual = self:ShouldManualCycle()

    local cycling = !owner:KeyDown(IN_ATTACK)

    if manual then
        cycling = owner:KeyDown(IN_RELOAD)
    end

    if self:GetNeedsCycle() and (cycling or self:GetProcessedValue("SlamFire", true)) then

        if self.MalfunctionCycle and (IsFirstTimePredicted() and self:RollJam()) then return end

        local ejectdelay = self:GetProcessedValue("EjectDelay", true)

        local t = self:PlayAnimation("cycle", self:GetProcessedValue("CycleTime", true), false)

        t = t * ((self:GetAnimationEntry(self:TranslateAnimation("cycle")) or {}).MinProgress or 1)

        self:SetCycleFinishTime(CurTime() + t)

        if IsFirstTimePredicted() and !self:GetProcessedValue("NoShellEjectManualAction", true) then
            if ejectdelay == 0 then
                self:DoEject()
            else
                self:SetTimer(ejectdelay, function()
                    self:DoEject()
                end)
            end
        end
    end
end

function SWEP:ShouldManualCycle()
    return self:GetOwner():GetInfoNum("arc9_manualbolt", 0) >= 1
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_effects.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_firemodes.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_freeaim.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_grenade.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_init.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_loopingsound.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_npc.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_shoot.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_stats.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_stats.lua:
local ENTITY = FindMetaTable("Entity")
SWEP.StatCache = {}
SWEP.HookCache = {}
SWEP.AffectorsCache = nil
SWEP.HasNoAffectors = {}

SWEP.ExcludeFromRawStats = {
    ["PrintName"] = true,
}

SWEP.DynamicConditions = { -- Never cache these conditions because they will always change
    ["Recoil"] = true,
}

local quickmodifiers = {
    ["DamageMin"] = GetConVar("arc9_mod_damage"),
    ["DamageMax"] = GetConVar("arc9_mod_damage"),
    ["Spread"] = GetConVar("arc9_mod_spread"),
    ["Recoil"] = GetConVar("arc9_mod_recoil"),
    ["VisualRecoil"] = GetConVar("arc9_mod_visualrecoil"),
    ["AimDownSightsTime"] = GetConVar("arc9_mod_adstime"),
    ["SprintToFireTime"] = GetConVar("arc9_mod_sprinttime"),
    ["DamageRand"] = GetConVar("arc9_mod_damagerand"),
    ["PhysBulletMuzzleVelocity"] = GetConVar("arc9_mod_muzzlevelocity"),
    ["RPM"] = GetConVar("arc9_mod_rpm"),
    ["HeadshotDamage"] = GetConVar("arc9_mod_headshotdamage"),
    ["MalfunctionMeanShotsToFail"] = GetConVar("arc9_mod_malfunction")
}

local singleplayer = game.SinglePlayer()
local ARC9HeatCapacityGPVOverflow = false

function SWEP:ClearLongCache()
    for _, v in pairs(self.PV_CacheLong) do v.time = 0 end
end

function SWEP:InvalidateCache()
    if singleplayer and self:GetOwner():IsPlayer() then
        self:CallOnClient("InvalidateCache")
    end

    self:ClearLongCache()

    self.StatCache = {}
    self.HookCache = {}
    self.AffectorsCache = nil
    self.ElementsCache = nil
    self.ElementTablesCache = nil
    self.RecoilPatternCache = {}
    self.ScrollLevels = {}
    self.HasNoAffectors = {}
    self:SetBaseSettings()
end

function SWEP:GetFinalAttTableFromAddress(address)
    return self:GetFinalAttTable(self:LocateSlotFromAddress(address))
end

function SWEP:GetFinalAttTable(slot)
    if !slot then return {} end
    if !slot.Installed then return {} end
    local atttbl = table.Copy(ARC9.GetAttTable(slot.Installed) or {})

    if self.AttachmentTableOverrides and self.AttachmentTableOverrides[slot.Installed] then
        atttbl = table.Merge(atttbl, self.AttachmentTableOverrides[slot.Installed])
    end

    if atttbl.ToggleStats then
        local toggletbl = atttbl.ToggleStats[slot.ToggleNum or 1] or {}
        table.Merge(atttbl, toggletbl)
    end

    return atttbl
end

do
    local entityGetTable = ENTITY.GetTable
    local swepGetCurrentFiremodeTable = SWEP.GetCurrentFiremodeTable
    local swepGetElements = SWEP.GetElements
    local swepGetFinalAttTable = SWEP.GetFinalAttTable
    local cvarArcModifiers = GetConVar("arc9_modifiers")
    local cvarGetString = FindMetaTable("ConVar").GetString

    function SWEP:GetAllAffectors()
        if self.AffectorsCache then return self.AffectorsCache end

        local aff = {table.Copy(entityGetTable(self))}

        local affLength = 1

        if not ARC9.OverrunSights then
            ARC9.OverrunSights = true
            local originalSightTable = self:GetSight().OriginalSightTable

            if originalSightTable then
                affLength = affLength + 1
                aff[affLength] = originalSightTable
            end

            ARC9.OverrunSights = false
        end

        local subSlotList = self:GetSubSlotList()
        local subSlotListLength = #subSlotList

        for i = 1, subSlotListLength do
            local atttbl = swepGetFinalAttTable(self, subSlotList[i])

            if atttbl then
                affLength = affLength + 1
                aff[affLength] = atttbl
            end
        end

        local config = string.Split(cvarGetString(cvarArcModifiers), "\\n")
        local configLength = #config
        local c4 = {}

        for i = 1, configLength do
            local swig = string.Split(config[i], "\\t")
            local swig1, swig2 = swig[1], swig[2]
            -- local c2 = c4[swig[1]]
            local swig2Num = tonumber(swig2)

            if swig2Num then
                c4[swig1] = swig2Num
            elseif swig2 == "true" or swig2 == "false" then
                c4[swig1] = swig2 == "true"
            else
                c4[swig1] = swig2
            end
        end

        affLength = affLength + 1
        aff[affLength] = c4

        if not ARC9.OverrunFiremodes then
            ARC9.OverrunFiremodes = true
            affLength = affLength + 1
            aff[affLength] = swepGetCurrentFiremodeTable(self)
            ARC9.OverrunFiremodes = false
        end

        if not ARC9.OverrunAttElements then
            ARC9.OverrunAttElements = true

            local eles = self:GetAttachmentElements()

            for _, eletable in ipairs(eles) do
                if eletable then
                    affLength = affLength + 1
                    aff[affLength] = eletable
                end
            end

            ARC9.OverrunAttElements = false
        end

        self.AffectorsCache = aff

        return aff
    end
end

do
    -- local CURRENT_AFFECTOR
    -- local CURRENT_DATA
    -- local CURRENT_SWEP
    local swepGetAllAffectors = SWEP.GetAllAffectors

    -- local function affectorCall()
    --     return CURRENT_AFFECTOR(CURRENT_SWEP, CURRENT_DATA)
    -- end

    function SWEP:RunHook(val, data)
        local any = false
        local hookCache = self.HookCache[val]

        if hookCache then
            for i = 1, #hookCache do
                local d = hookCache[i](self, data)

                if d ~= nil then
                    data = d
                end

                any = true
            end

            data = hook.Run("ARC9_" .. val, self, data) or data

            return data, any
        end

        -- CURRENT_SWEP = self

        local cacheLen = 0
        local newCache = {}
        local affectors = swepGetAllAffectors(self)
        local affectorsCount = #affectors

        for i = 1, affectorsCount do
            local tbl = affectors[i]
            local tblVal = tbl[val]
            if tblVal and isfunction(tblVal) then
                cacheLen = cacheLen + 1
                newCache[cacheLen] = tblVal

                -- CURRENT_AFFECTOR = tblVal
                -- CURRENT_DATA = data
                -- local succ, returnedData = CURRENT_AFFECTOR(CURRENT_SWEP, CURRENT_DATA) pcall(affectorCall)
                local d = tblVal(self, data)
                if d ~= nil then
                    data = d
                end
                -- if succ then
                --     data = returnedData ~= nil and returnedData or data
                --     any = true
                -- else
                --     print("!!! ARC9 ERROR - \"" .. (tbl["PrintName"] or "Unknown") .. "\" TRIED TO RUN INVALID HOOK ON " .. val .. "!")
                --     print(returnedData, '\n')
                -- end
            end
        end

        self.HookCache[val] = newCache
        data = hook.Run("ARC9_" .. val, self, data) or data

        return data, any
    end
end

local Lerp = function(a, v1, v2)
    local d = v2 - v1

    return v1 + (a * d)
end

-- local pvtick = 0
-- local pv_move = 0
-- local pv_shooting = 0
-- local pv_melee = 0
SWEP.PV_Tick = 0
SWEP.PV_Move = 0
SWEP.PV_Shooting = 0
SWEP.PV_Melee = 0
SWEP.PV_Cache = {}
SWEP.PV_CacheLong = {}

do
    local swepRunHook = SWEP.RunHook
    local swepGetAllAffectors = SWEP.GetAllAffectors

    -- Maybe we need to make a thug version of this function? with getmetatable fuckery
    local type = type

    function SWEP:GetValue(val, base, condition, amount)
        condition = condition or ""
        amount = amount or 1
        local stat = base

        if stat == nil then
            stat = self:GetTable()[val]
        end

        local valContCondition = val .. condition
        if self.HasNoAffectors[valContCondition] == true then
            return stat
        end
        local unaffected = true
        local baseStr = tostring(base)
        -- damn
        local baseContValContCondition = baseStr .. valContCondition

        if type(stat) == "table" then
            stat.BaseClass = nil
        end

        local statCache = self.StatCache
        local cacheAvailable = statCache[baseContValContCondition]

        if cacheAvailable ~= nil then
            -- stat = self.StatCache[tostring(base) .. valContCondition]
            stat = cacheAvailable
            local oldstat = stat
            stat = swepRunHook(self, val .. "Hook" .. condition, stat)

            if stat == nil then
                stat = oldstat
            end
            -- if istable(stat) then
            --     stat.BaseClass = nil
            -- end
            
            if quickmodifiers[val] and isnumber(stat) then
                local convarvalue = quickmodifiers[val]:GetFloat()

                if val == "MalfunctionMeanShotsToFail" then -- dont kill me for this pls
                    stat = stat / math.max(0.00000001, convarvalue)
                else
                    stat = stat * convarvalue
                end
            end

            return stat
        end

        local priority = 0
        local allAffectors = swepGetAllAffectors(self)
        local affectorsCount = #allAffectors

        if not self.ExcludeFromRawStats[val] then
            for i = 1, affectorsCount do
                local tbl = allAffectors[i]
                if !tbl then continue end
                
                local att_priority = tbl[valContCondition .. "_Priority"] or 1

                if att_priority >= priority and tbl[valContCondition] ~= nil then
                    stat = tbl[valContCondition]
                    priority = att_priority
                    unaffected = false
                end
            end
        end

        for i = 1, affectorsCount do
            local tbl = allAffectors[i]
            local att_priority = tbl[val .. "Override" .. condition .. "_Priority"] or 1
            local keyName = val .. "Override" .. condition

            if att_priority >= priority and tbl[keyName] ~= nil then
                stat = tbl[keyName]
                priority = att_priority
                unaffected = false
            end
        end

        if type(stat) == "number" then
            for i = 1, affectorsCount do
                local tbl = allAffectors[i]
                local keyName = val .. "Add" .. condition

                if tbl[keyName] ~= nil then
                    -- if !pcall(function() stat = stat + (tbl[val .. "Add" .. condition] * amount) end) then
                    --     print("!!! ARC9 ERROR - \"" .. (tbl["PrintName"] or "Unknown") .. "\" TRIED TO ADD INVALID VALUE: (" .. tbl[val .. "Add" .. condition] .. ") TO " .. val .. "!")
                    -- end
                    if type(tbl[keyName]) == type(stat) then
                        stat = stat + (tbl[keyName] * amount)
                    end

                    unaffected = false
                end
            end

            for i = 1, affectorsCount do
                local tbl = allAffectors[i]
                local keyName = val .. "Mult" .. condition

                if tbl[keyName] ~= nil then
                    -- if !pcall(function() stat = stat * math.pow(tbl[val .. "Mult" .. condition], amount) end) then
                    --     print("!!! ARC9 ERROR - \"" .. (tbl["PrintName"] or "Unknown") .. "\" TRIED TO MULTIPLY INVALID VALUE: (" .. tbl[val .. "Add" .. condition] .. ") TO " .. val .. "!")
                    -- end
                    if type(tbl[keyName]) == type(stat) then
                        if amount > 1 then
                            stat = stat * math.pow(tbl[keyName], amount)
                        else
                            stat = stat * tbl[keyName]
                        end
                    end

                    unaffected = false
                end
            end
        end

        if not self.DynamicConditions[condition] then
            statCache[baseContValContCondition] = stat
        end
        -- self.StatCache[tostring(base) .. valContCondition] = stat
        local newstat, any = swepRunHook(self, val .. "Hook" .. condition, stat)
        stat = newstat or stat

        if quickmodifiers[val] and isnumber(val) then
            local convarvalue = quickmodifiers[val]:GetFloat()
            
            if val == "MalfunctionMeanShotsToFail" then  -- dont kill me for this pls
                stat = stat / math.max(0.00000001, convarvalue)
            else
                stat = stat * convarvalue
            end

            unaffected = false
        end

        if any then
            unaffected = false
        end

        if not self.DynamicConditions[condition] then
            self.HasNoAffectors[valContCondition] = unaffected
        end

        -- if statType == 'table' then
        if type(stat) == 'table' then
            stat.BaseClass = nil
        end

        return stat
    end
end

do
    local PLAYER = FindMetaTable("Player")
    local playerCrouching = PLAYER.Crouching
    local playerGetWalkSpeed = PLAYER.GetWalkSpeed
	local playerSprinting = PLAYER.IsSprinting
    local entityOwner = ENTITY.GetOwner
    local entityOnGround = ENTITY.OnGround
    local entityIsValid = ENTITY.IsValid
    local entityGetMoveType = ENTITY.GetMoveType
    local entityIsPlayer = ENTITY.IsPlayer
    local entityGetAbsVelocity = ENTITY.GetAbsVelocity
    local WEAPON = FindMetaTable("Weapon")
    local weaponClip1 = WEAPON.Clip1
    local weaponClip2 = WEAPON.Clip2
    local weaponGetNextPrimaryFire = WEAPON.GetNextPrimaryFire
    local arcGetValue = SWEP.GetValue
    local cvarArc9Truenames = GetConVar("arc9_truenames")
    local cvarGetBool = FindMetaTable("ConVar").GetBool
    local vectorLength = FindMetaTable("Vector").Length

    local getmetatable = getmetatable
    local numberMeta = getmetatable(1)

    -- This should NOT break anything
    -- There are a few addons (such as SAM) that do the same
    if not numberMeta then
        numberMeta = {MetaName = "number"}
        debug.setmetatable(1, numberMeta)
    end

    local function isnumber(val)
        return getmetatable(val) == numberMeta
    end

    function SWEP:GetProcessedValue(val, cachedelay, base, cmd)
        local swepDt = self.dt
        -- From now on, we will not call `self:GetJammed()`, `self:GetHeatLockout()`
        -- and similar functions, because all they do is just return `self.dt[thing]`
        -- We can (and should, if we want "PERFORMANCE :tm:") do this manually
        if swepDt.Jammed and val == "Malfunction" then return true end
        if swepDt.HeatLockout and val == "Overheat" then return true end
        local ct = CurTime()
        local upct = UnPredictedCurTime()
        local processedValueName = tostring(val) .. tostring(base)

        -- if CLIENT then -- why cache was client only???
            if self.PV_Cache[processedValueName] ~= nil and self.PV_Tick == upct then
                return self.PV_Cache[processedValueName]
            end
            if self.PV_Tick ~= upct then
                self.PV_Cache = {}
            end
        -- end


        -- mega cool thing to not calculate mostly static values

        if cachedelay then
            if self.PV_CacheLong[processedValueName] then
                local cachetime = self.PV_CacheLong[processedValueName].time

                if cachetime then
                    if upct > cachetime then
                        -- print("Renewing cache for - ", processedValueName)
                        

                        self.PV_CacheLong[processedValueName].time = upct + 1 -- idk whats number here should be
                        self.PV_CacheLong[processedValueName].value = self:GetProcessedValue(val, base, cmd, false)
                        
                -- if istable(self.PV_CacheLong[processedValueName].value) then
                    -- print("Renewed value is a table!")
                    -- PrintTable(self.PV_CacheLong[processedValueName].value)
                    -- else print("Renewed value - ", self.PV_CacheLong[processedValueName].value) end
                        -- print(processedValueName, "working", upct)
                    end
                end
            else

                        -- print("Didn't found cache for - ", processedValueName, ", generating!")
                self.PV_CacheLong[processedValueName] = {}
                self.PV_CacheLong[processedValueName].time = upct
                self.PV_CacheLong[processedValueName].value = self:GetProcessedValue(val, base, cmd, false)
                -- if istable(self.PV_CacheLong[processedValueName].value) then
                    -- print("That generated value is a table!")
                    -- PrintTable(self.PV_CacheLong[processedValueName].value)
                    -- else print("Generated value - ", self.PV_CacheLong[processedValueName].value) end
            end

            return self.PV_CacheLong[processedValueName].value
        end


        local stat = arcGetValue(self, val, base)
        local ubgl = swepDt.UBGL
        local owner = entityOwner(self)
        -- if true then return stat end
        local ownerIsNPC = owner:IsNPC()

        if ownerIsNPC then
            stat = arcGetValue(self, val, stat, "NPC")
        end

        if cvarGetBool(cvarArc9Truenames) then
            stat = arcGetValue(self, val, stat, "True")
        end

        if not ownerIsNPC and entityIsValid(owner) then
            local ownerOnGround = entityOnGround(owner)

            if not ownerOnGround or entityGetMoveType(owner) == MOVETYPE_NOCLIP then
                stat = arcGetValue(self, val, stat, "MidAir")
            end

            if ownerOnGround and playerCrouching(owner) then
                stat = arcGetValue(self, val, stat, "Crouch")
            end
			
			if ownerOnGround and playerSprinting(owner) and !self:StillWaiting() then
                stat = arcGetValue(self, val, stat, "Sprint")
			end
        end

        if swepDt.Reloading then
            stat = arcGetValue(self, val, stat, "Reload")
        end

        if swepDt.BurstCount == 0 then
            stat = arcGetValue(self, val, stat, "FirstShot")
        end

        if swepDt.GrenadeTossing then
            stat = arcGetValue(self, val, stat, "Toss")
        end

        if weaponClip1(self) == 0 then
            stat = arcGetValue(self, val, stat, "Empty")
        end

        if not ubgl and arcGetValue(self, "Silencer") then
            stat = arcGetValue(self, val, stat, "Silenced")
        end

        if ubgl then
            stat = arcGetValue(self, val, stat, "UBGL")

            if weaponClip2(self) == 0 then
                stat = arcGetValue(self, val, stat, "EmptyUBGL")
            end
        end

        if swepDt.NthShot % 2 == 0 then
            stat = arcGetValue(self, val, stat, "EvenShot")
        else
            stat = arcGetValue(self, val, stat, "OddShot")
        end

        if swepDt.NthReload % 2 == 0 then
            stat = arcGetValue(self, val, stat, "EvenReload")
        else
            stat = arcGetValue(self, val, stat, "OddReload")
        end

        -- if self:GetBlindFire() then
        --     stat = arcGetValue(self, val, stat, "BlindFire")
        -- end
        if swepDt.Bipod then
            stat = arcGetValue(self, val, stat, "Bipod")
        end

        local hasNoAffectors = self.HasNoAffectors

        if not hasNoAffectors[val .. "Sights"] or not hasNoAffectors[val .. "HipFire"] or not hasNoAffectors[val .. "Sighted"] then
            local sightAmount = swepDt.SightAmount

            if isnumber(stat) then
                local hipfire = arcGetValue(self, val, stat, "HipFire")
                local sights = arcGetValue(self, val, stat, "Sights")
                local sighted = arcGetValue(self, val, stat, "Sighted")

                if sightAmount >= 1 and not hasNoAffectors[val .. "Sighted"] then
                    stat = sighted
                elseif isnumber(hipfire) and isnumber(sights) then
                    stat = Lerp(sightAmount, hipfire, sights)
                end
            else
                if sightAmount >= 1 then
                    if hasNoAffectors[val .. "Sighted"] then
                        stat = arcGetValue(self, val, stat, "Sights")
                    else
                        stat = arcGetValue(self, val, stat, "Sighted")
                    end
                else
                    stat = arcGetValue(self, val, stat, "HipFire")
                end
            end
        end

        if not ARC9HeatCapacityGPVOverflow then
            local heatAmount = swepDt.HeatAmount
            local hasHeat = heatAmount > 0

            if hasHeat and base ~= "HeatCapacity" and (not hasNoAffectors[val .. "Hot"] or not hasNoAffectors[val .. "Heated"]) then

                ARC9HeatCapacityGPVOverflow = true
                local cap = self:GetProcessedValue("HeatCapacity")
                ARC9HeatCapacityGPVOverflow = false

                if isnumber(stat) then
                    local hot = arcGetValue(self, val, stat, "Hot")

                    if not hasNoAffectors[val .. "Heated"] and heatAmount >= cap then
                        stat = arcGetValue(self, val, stat, "Heated")
                    elseif isnumber(hot) then
                        ARC9HeatCapacityGPVOverflow = true
                        stat = Lerp(heatAmount / cap, stat, hot)
                        ARC9HeatCapacityGPVOverflow = false
                    end
                else
                    if not hasNoAffectors[val .. "Heated"] and heatAmount >= cap then
                        stat = arcGetValue(self, val, stat, "Heated")
                    elseif hasHeat then
                        stat = arcGetValue(self, val, stat, "Hot")
                    end
                end
            end
        end

        local getlastmeleetime = swepDt.LastMeleeTime

        if not hasNoAffectors[val .. "Melee"] and getlastmeleetime < ct then
            local pft = ct - getlastmeleetime
            local d = pft / (arcGetValue(self, "PreBashTime") + arcGetValue(self, "PostBashTime"))
            d = 1 - math.Clamp(d, 0, 1)

            if isnumber(stat) then
                stat = Lerp(d, stat, arcGetValue(self, val, stat, "Melee"))
            else
                if d > 0 then
                    stat = arcGetValue(self, val, stat, "Melee")
                end
            end
        end

        if not hasNoAffectors[val .. "Shooting"] then
            local nextPrimaryFire = weaponGetNextPrimaryFire(self)

            if nextPrimaryFire + 0.1 > ct then
                local pft = (nextPrimaryFire + 0.1) - ct
                local d = math.Clamp(pft / 0.1, 0, 1)

                if isnumber(stat) then
                    stat = Lerp(d, stat, arcGetValue(self, val, stat, "Shooting"))
                else
                    if d > 0 then
                        stat = arcGetValue(self, val, stat, "Shooting")
                    end
                end
            end
        end

        if val ~= "RecoilModifierCap" and not hasNoAffectors[val .. "Recoil"] then
            local recoilAmount = math.min(self:GetProcessedValue("RecoilModifierCap", true), swepDt.RecoilAmount)

            if recoilAmount > 0 then
                stat = arcGetValue(self, val, stat, "Recoil", recoilAmount)
            end
        end

        if not hasNoAffectors[val .. "Move"] and IsValid(owner) then
            local spd = self.PV_Move
            local maxspd = entityIsPlayer(owner) and playerGetWalkSpeed(owner) or 250

            --if singleplayer or CLIENT or self.PV_Tick ~= upct then
                spd = math.min(vectorLength(entityGetAbsVelocity(owner)), maxspd) / maxspd
                self.PV_Move = spd
            --end

            if isnumber(stat) then
                stat = Lerp(spd, stat, arcGetValue(self, val, stat, "Move"))
            else
                if spd > 0 then
                    stat = arcGetValue(self, val, stat, "Move")
                end
            end
        end

        -- if CLIENT then
            self.PV_Tick = upct
            self.PV_Cache[processedValueName] = stat
        -- end

        return stat
    end
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base_nade.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base_nade.lua:
SWEP.Base = "arc9_base"
SWEP.PrintName = "ARC9 Base Grenade"
SWEP.Spawnable = false

SWEP.BottomlessClip = true

SWEP.ShootEnt = "arc9_proj_base"

SWEP.Throwable = true -- Set to true to give this weapon throwing capabilities.
SWEP.Tossable = true -- When grenade is enabled, right click will toss. Set to false to disable, allowing you to aim down sights.
SWEP.ThrowAnimSpeed = 1

SWEP.FuseTimer = -1 -- Length of time that the grenade will take to explode in your hands. -1 = Won't explode.

SWEP.ThrowForceMin = 500 -- Minimum force that the grenade will be thrown with.
SWEP.ThrowForceMax = 1000 -- Maximum force that the grenade will be thrown with.
SWEP.TossForce = 250 -- Force that the grenade will be thrown with when right clicked.

SWEP.ThrowChargeTime = 1 -- How long it takes to charge the grenade to its maximum throw force.

SWEP.ThrowTumble = true -- Grenade tumbles when thrown.

SWEP.Disposable = true
--PATH lua/weapons/arccw_base/cl_blur.lua:
local dofmat = Material("pp/dof")

function SWEP:BlurWeapon()
    if !ArcCW.ConVars["blur"]:GetBool() then return end
    local delta = self:GetSightDelta()
    if delta >= 1 then return end
    local vm = self:GetOwner():GetViewModel()
    render.UpdateScreenEffectTexture()
    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_REPLACE)
    render.SetStencilWriteMask(0xFF)
    render.SetStencilTestMask(0xFF)
    render.SetBlend(1)
    render.SetStencilReferenceValue(55)
    ArcCW.Overdraw = true
    vm:DrawModel()
    ArcCW.Overdraw = false
    render.SetBlend(0)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilCompareFunction(STENCIL_EQUAL)
    -- render.SetColorMaterial()
    dofmat:SetFloat("bluramount", 0.1 * (1 - delta))
    render.SetMaterial(dofmat)
    render.DrawScreenQuad()
    render.SetStencilEnable(false)
end

function SWEP:BlurNotWeapon()
    if !ArcCW.ConVars["blur"]:GetBool() then return end
    render.UpdateRefractTexture()
    DrawToyTown(3, ScrH())
end

function SWEP:DoToyTown()
    if !ArcCW.ConVars["blur_toytown"]:GetBool() then return end
    render.UpdateRefractTexture()
    DrawToyTown(3, ScrH() * 0.4 * (1 - self:GetSightDelta()))
end
--PATH lua/weapons/arccw_base/cl_crosshair.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_hud.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_viewmodel.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_bash.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_bipod.lua:
function SWEP:InBipod()
    local bip = self:GetInBipod()

    -- if !self:CanBipod() then
    --     self:ExitBipod()
    -- end

    if IsValid(self:GetOwner()) and self:GetBipodPos() != self:GetOwner():EyePos() then
        self:ExitBipod()
    end

    return bip
end

SWEP.CachedCanBipod = true
SWEP.CachedCanBipodTime = 0

local dist = 24
function SWEP:CanBipod()
    if !(self:GetBuff_Override("Bipod") or self.Bipod_Integral) then return false end

    if self:GetOwner():InVehicle() then return false end

    if self.CachedCanBipodTime >= CurTime() then return self.CachedCanBipod end

    local pos = self:GetOwner():EyePos()
    local angle = self:GetOwner():EyeAngles()
    if self:GetOwner():GetVelocity():Length() > 0 then
        return false
    end

    local rangemult = 2
    if self:IsProne() then
        rangemult = rangemult * 1.25
    end
    rangemult = rangemult * self:GetBuff_Mult("Mult_BipodRange")

    local tr = util.TraceLine({
        start = pos,
        endpos = pos + (angle:Forward() * dist * rangemult),
        filter = self:GetOwner(),
        mask = MASK_PLAYERSOLID
    })

    if tr.Hit then -- check for stuff in front of us
        return false
    end

    local maxs = Vector(8, 8, 16)
    local mins = Vector(-8, -8, 0)

    angle.p = angle.p + 45

    tr = util.TraceHull({
        start = pos,
        endpos = pos + (angle:Forward() * dist * rangemult),
        filter = self:GetOwner(),
        maxs = maxs,
        mins = mins,
        mask = MASK_PLAYERSOLID
    })

    self.CachedCanBipodTime = CurTime()

    if tr.Hit then
        local tr2 = util.TraceHull({
            start = tr.HitPos,
            endpos = tr.HitPos + Vector(0, 0, -24),
            filter = self:GetOwner(),
            maxs = maxs,
            mins = mins,
            mask = MASK_PLAYERSOLID
        })
        if tr2.Hit then
            self.CachedCanBipod = true
            return true, tr2
        end
    end

    self.CachedCanBipod = false
    return false
end

function SWEP:EnterBipod(sp)
    if !sp and self:GetInBipod() then return end
    local can, tr = self:CanBipod()
    if !sp and !can then return end

    if SERVER and game.SinglePlayer() then self:CallOnClient("EnterBipod", "true") end

    if self.Animations.enter_bipod then
        self:PlayAnimation("enter_bipod", nil, nil, 0, true)
    else
        -- Block actions for a tiny bit even if there is no animation
        self:SetNextPrimaryFire(CurTime() + 0.25)
    end

    if CLIENT and self:GetBuff_Override("LHIK") then
        self:DoLHIKAnimation("enter")
    end

    local bipodang = tr.HitNormal:Cross(self:GetOwner():EyeAngles():Right()):Angle()

    debugoverlay.Axis(tr.HitPos, tr.HitNormal:Angle(), 16, 5, true)
    debugoverlay.Line(tr.HitPos, tr.HitPos + bipodang:Forward() * 32, 5, color_white, true)
    debugoverlay.Line(tr.HitPos, tr.HitPos + self:GetOwner():EyeAngles():Forward() * 32, 5, Color(255, 255, 0), true)

    self:SetBipodPos(self:GetOwner():EyePos())
    self:SetBipodAngle(bipodang)
    self.BipodStartAngle = self:GetOwner():EyeAngles()

    if game.SinglePlayer() and CLIENT then return end

    self:MyEmitSound(self.EnterBipodSound)
    self:SetInBipod(true)
end

function SWEP:ExitBipod(sp)
    if !sp and !self:GetInBipod() then return end

    if SERVER and game.SinglePlayer() then self:CallOnClient("ExitBipod", "true") end

    if self.Animations.exit_bipod then
        self:PlayAnimation("exit_bipod", nil, nil, 0, true)
    else
        self:SetNextPrimaryFire(CurTime() + 0.25)
    end

    if CLIENT and self:GetBuff_Override("LHIK") then
        self:DoLHIKAnimation("exit")
    end

    if game.SinglePlayer() and CLIENT then return end

    self:MyEmitSound(self.ExitBipodSound)
    self:SetInBipod(false)
end

--PATH lua/weapons/arccw_base/sh_deploy.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_sights.lua:
return gluapack()()
--PATH lua/weapons/arccw_e5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "E-5"
SWEP.Trivia_Class = "CIS Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact CIS E-5 Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_e11.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_e5.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 41
SWEP.RangeMin = 150
SWEP.DamageMin = 24
SWEP.Range = 400
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 270
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.44 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(255, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-2.87, -8, .7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 65,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.9, -4, .5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)

SWEP.DefaultElements = {"e5", "muzzle"}

SWEP.AttachmentElements = {
    ["e5"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "v_e11_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-0.95, 0.899, -3.5),
                    ang = Angle(0, -90, 0)
                }
            }
        }
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "e11_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 4, 11),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(450, 60, 200),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2000, 0, -900),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.24, -1.5, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 55, -740),
            wang = Angle(-15, 0, 180)
        },
    },    
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 10),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 2.5, 10),
            vmax = Vector(-0, 2.5, 12),
            wmin = Vector(1000, 60, -450), 
            wmax = Vector(1000, 60, -450) -- how far this attachment can slide in both directions.
            },
    },
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1.5, 11),
            vang = Angle(90, 0, 0),
            wpos = Vector(1200, 130, -750),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.1, 0.6, 17),
            vang = Angle(90, 0, -90),
            wpos = Vector(1640, 60, -860),
            wang = Angle(-15, 0, -90)
        },
    },
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 2.1, -0.5),
            vang = Angle(0, 0, 0),
        },
    },        
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.9, 1, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 220, -500),
            wang = Angle(-10 , 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.2,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15s.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--PATH lua/weapons/arccw_e5s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "E-5s"
SWEP.Trivia_Class = "CIS Sniper Blaster Rifle"
SWEP.Trivia_Desc = "High tech CIS E-5s Sniper Blaster Rifle"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_t21.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_t21.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_e5s.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 105
SWEP.RangeMin = 400
SWEP.DamageMin = 44
SWEP.Range = 800
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 0.44
SWEP.RecoilSide = 0.25
SWEP.RecoilPunch = 0.8
SWEP.RecoilRise = 0.34

SWEP.Delay = 60 / 130
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.6 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50
SWEP.SightsDispersion = 0

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5s.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(250, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-1.558, -9, 0.95),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 55,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(5, -5, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)
SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)

SWEP.DefaultElements = {"e5s", "muzzle"}

SWEP.AttachmentElements = {
    ["e5s"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5s_c_blaster.mdl",
                Bone = "v_t21_reference001",
                Scale = Vector(1.4, 1.4, 1.4),
                Offset = {
                    pos = Vector(0.85, 1, -2.1),
                    ang = Angle(0,-90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "t21_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 2, 33 ),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5s_c_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(400, 50.5, 200),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4400, 0, -1300),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5s_c_blaster.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.86, -2, 12),
            vang = Angle(90, 0, -90),
            wpos = Vector(1400, 50, -800),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.5, 2.3, 16),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 2, 13),
            vmax = Vector(-0, 2, 15),
            wmin = Vector(2000, 50, -700), 
            wmax = Vector(2000, 50, -700)  -- how far this attachment can slide in both directions.
        },
    },        
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "v_t21_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 30, 4.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(2300, 50, -850),
            wang = Angle(-15, 0, 180)
        },
    },    
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        NoWM = true,
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.7, 23),
            vang = Angle(90, 0, -90),
        },
    },
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, 4),
            vang = Angle(0, 0, 0),
        },
    },        
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(2, 0.8, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 100, -300),
            wang = Angle(-10 , 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/overheat_manualcooling_resetfoley_generic_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a280su.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_bowcaster_ext.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cr2c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "CR-2c"
SWEP.Trivia_Class = "Heavy Pistol"
SWEP.Trivia_Desc = "The CR-2 heavy blaster pistol, also known more simply as a CR-2 blaster pistol, was a heavy blaster pistol manufactured by Corellian Arms that was utilized by the Royal Naboo Security Forces. Small and agile, it had an extreme rate of fire and shoot ionized bolts. It also could be configured with night vision scopes or have an extended stock for reduced recoil."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/cr2c.png"

-- Viewmodel & Entity Properties

SWEP.DefaultBodygroups = "001000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_cr2.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(1.2, 0.6, -3.3),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 27
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 750
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.60
SWEP.RecoilPunch = 0.75

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_CR2"
SWEP.ShootSound = "ArcCW_Kraken.SW_CR2"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(0, 250, 0)
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-1.99, 0, 1.2),
    Ang = Vector(0, 0.2, 2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(1, -0.0, 1.1),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(15, -0.0, -1.2),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10, 0.8, -1.1),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(10, 0, -1.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(6.5, -0.39, 0.85),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10.4, -0.7, -0.5),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		MinProgress = 0.925,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_up.ogg", t = 0.0},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
            {s = path .. "wfoly_sm_secho_reload_magout.ogg", t = 0.433},
			{s = path .. "wfoly_sm_secho_reload_maghit.ogg", t = 0.867},
			{s = path .. "wfoly_sm_secho_reload_magin.ogg", t = 1.233},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.23},
			{s = path .. "wfoly_sm_secho_reload_end.ogg", t = 1.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
		MinProgress = 0.925,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        LHIK = true,
        SoundTable = {
			{s = path .. "wfoly_sm_secho_reload_empty_up.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_reload_empty_magout.ogg", t = 0.467},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
			{s = path .. "wfoly_sm_secho_reload_empty_mvmnt.ogg", t = 1.133},
			{s = path .. "wfoly_sm_secho_reload_empty_maghit.ogg", t = 1.25},
			{s = path .. "wfoly_sm_secho_reload_empty_magin.ogg", t = 1.35},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.36},
			{s = path .. "wfoly_sm_secho_reload_empty_charge.ogg", t = 1.64},
			{s = path .. "wfoly_sm_secho_reload_empty_end.ogg", t = 1.867},
        },
    },
    ["ready"] = {
        Source = "draw",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise_first_up.ogg", t = 0.0},
            {s = path .. "wfoly_sm_secho_raise_first_charge.ogg", t = 0.5},
            {s = path .. "wfoly_sm_secho_raise_first_end.ogg", t = 0.667},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        LHIK = true,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
		FireASAP = true,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_inspect_magout.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_inspect_magin.ogg", t = 1.967},
			{s = path .. "wfoly_sm_secho_inspect_end.ogg", t = 3.4},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_selectsemi_on.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cycler.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15s_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15s Stun"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The DC-15S Blaster Carbine, produced by BlasTech Industries, is a semi-automatic and rapid fire blaster which also has a stun feature. As well as a unique fully-foldable stalk. The rifle was used by clone troopers throughout the Clone Wars and became the more favored weapon amongst its more powerful counterpart, the DC-15A Blaster Rifle, due to its compact size and usefulness in close quarter engagements."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15s_stun.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15s.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 18
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 44
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 230
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.816, -1.966, 1.894),
    Ang = Vector(0, 0, 1.513),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -1)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic",
        Bone = "DC15",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.02, -1.1, 4.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.02, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(-0.8, -0.5, 10.5),
            vang = Angle(90, 0, 180),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(-0.101, 0.15, 5),
            vang = Angle(90, 0, -90),
        },       
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo", "sw_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.95, 0.05, -3.55),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1, -0.2, -7),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37 / 30},
            {s = "ArcCW_Kraken.Grab", t = 37 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15s_train.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15s Training"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The DC-15S Blaster Carbine, produced by BlasTech Industries, is a semi-automatic and rapid fire blaster which also has a stun feature. As well as a unique fully-foldable stalk. The rifle was used by clone troopers throughout the Clone Wars and became the more favored weapon amongst its more powerful counterpart, the DC-15A Blaster Rifle, due to its compact size and usefulness in close quarter engagements."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15s_training.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15s.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 18
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 1
SWEP.DamageMin = 1
SWEP.RangeMin = 0
SWEP.Range = 230
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 120, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 120, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.816, -1.966, 1.894),
    Ang = Vector(0, 0, 1.513),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -1)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic",
        Bone = "DC15",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.02, -1.1, 4.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.02, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(-0.8, -0.5, 10.5),
            vang = Angle(90, 0, 180),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(-0.101, 0.15, 5),
            vang = Angle(90, 0, -90),
        },       
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.95, 0.05, -3.55),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1, -0.2, -7),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37 / 30},
            {s = "ArcCW_Kraken.Grab", t = 37 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc15sc.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15sc"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "Short-Range Carbine. Designed for the Galactic Republic during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dc15sc.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001100000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_dc15.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -6),
    ang = Angle(-5, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 37
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 35

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.40
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 1

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.78, -3, 2),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["grip_attach"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.3, -1.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -0.45, 10),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.8, -0.2, 5),
            vang = Angle(90, 0, 180),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "DC15",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(0, 0.25, 5),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "DC15",
        Offset = {
            vpos = Vector(1.1, 0.15, -4.1),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "DC15",
        Offset = {
            vpos = Vector(1.1, -0.1, -6),
            vang = Angle(90, 0, -90),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "fire",
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.925,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_up.ogg", t = 0.0},
            {s = path .. "wfoly_sm_secho_reload_magout.ogg", t = 0.433},
			{s = path .. "wfoly_sm_secho_reload_maghit.ogg", t = 0.867},
			{s = path .. "wfoly_sm_secho_reload_magin.ogg", t = 1.233},
        },
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.5,
        LHIK = true,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = false,
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc15se.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15se"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "Long-Range Carbine. Designed for the Galactic Republic during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dc15se.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "01111100000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_dc15.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -6),
    ang = Angle(-5, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 42
SWEP.DamageMin = 27
SWEP.RangeMin = 0
SWEP.Range = 900
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.40
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 1.6

SWEP.Delay = 60 / 330
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.78, -3, 2),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["grip_attach"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.3, -1.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -0.45, 17.3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.8, -0.2, 6),
            vang = Angle(90, 0, 180),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "DC15",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(0, 0.25, 5),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "DC15",
        Offset = {
            vpos = Vector(1.1, 0.15, -4.1),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "DC15",
        Offset = {
            vpos = Vector(1.1, -0.1, -6),
            vang = Angle(90, 0, -90),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "fire",
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.925,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_up.ogg", t = 0.0},
            {s = path .. "wfoly_sm_secho_reload_magout.ogg", t = 0.433},
			{s = path .. "wfoly_sm_secho_reload_maghit.ogg", t = 0.867},
			{s = path .. "wfoly_sm_secho_reload_magin.ogg", t = 1.233},
        },
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.5,
        LHIK = true,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = false,
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17m_shotgun_republic.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number


SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-17m Shotgun"
SWEP.Trivia_Class = "Modular Blaster Rifle"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17m_shotgun.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0100100000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17m.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-13, 7.2, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.Damage = 18
SWEP.DamageMin = 8
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 2.2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 180
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 75
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}

SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.ShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-6.498, -10.992, 0.6),
    Ang = Vector(-1.846, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-0, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -1)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "DC-17M",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(0, -22, 0),
                    ang = Angle(0, 90, 0)
                },
                IsMuzzleDevice = true
            },
        },
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 4, bg = 2}},
    },
}



SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "None", 
        Slot = "optic",
        Bone = "DC-17M",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.06, -2.75, -1.6),
            vang = Angle(0, 90, 180),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    }, 
    {
        PrintName = "Internal Compression",
        DefaultAttName = "DC-17m Rifle",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
    },      
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "DC-17M", 
        Offset = {
            vpos = Vector(-1.5, -13, -0.1),
            vang = Angle(0, 90, 90),
        },
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode"},
    },   
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-17M",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.94, 0.8, 2.6),
            vang = Angle(0, 90, 180),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17M",
        Offset = {
            vpos = Vector(1.48, 1.4, 1),
            vang = Angle(0, 90, 180),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "weapon_hand/reload_heavy/mag_eject/023d-00000080.mp3", t = 10 / 60},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000648.mp3", t = 90 / 60},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000668.mp3", t = 110 / 60},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17sa.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-17sa"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17sa.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17s.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-16, 5, -3.4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 180
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.9
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.79, -8, 0.13),
    Ang = Vector(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(0, -6, -9)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(0, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.AttachmentElements = {
    ["akimbo"] = {
        Override_ActivePos = Vector(2, -2, 0),
        Override_CrouchPos = Vector(0, -3, 0),	
        Override_CrouchAng = Angle(0, 0, 0),
        Override_HolsterPos = Vector(2,2,2),
        Override_HolsterAng = Angle(-20, 0, -5),		
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["dc17_powerpack"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["dc17_cooling"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
}

SWEP.Hook_SelectReloadAnimation = function(wep, anim)
    if wep.Attachments[4].Installed then
        return anim .. "_akimbo"
    end

    return anim
end

SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = "optic",
        Bone = "Slide",
        InstalledEles = {"scope_attach"},
        DefaultAttName = "DC-17 Holosight",
        Offset = {
            vpos = Vector(-2, 4.8, 0.13),
            vang = Angle(180,0,90),
        },
        VMScale = Vector(1.25, 1.25, 1.25),
    },
    {
        PrintName = "Tactical",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "frame",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-6, 1.56, 0.15),
            vang = Angle(180,0,90),
        },
        ExtraSightDist = 9,
        CorrectivePos = Vector(1, 0, -1),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "frame",
        Offset = {
            vpos = Vector(-9.3, 2.8, 0.11),
            vang = Angle(180,0,90),
        },
    },
    {
        PrintName = "Left Hand",
        Slot = {"gso_extra_pistol_akimbo", "mifl_fas2_akimbo", "akimbotest"},
        Bone = "Akimbo_Base",
        DefaultAttName = "None",
        Offset = {
            vpos = Vector(6, -2.8, 0.2),
            vang = Angle(0, 0, 0),
        },
        InstalledEles = {"akimbo"},
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Powerpack",
        DefaultAttName = "None",
        Slot = {"dc17_powerpack"},
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "Standard",
        Slot = {"dc17_cooling"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "frame",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Offset = {
            vpos = Vector(-7, 3.05, -0.5),
            vang = Angle(180,0,90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "frame",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.2, 2.18, -0.75),
            vang = Angle(180,0,90),
        },
    },     
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["ready"] = {
        Source = "draw",
    },
    ["fire"] = {
        Source = "fire1",
        ShellEjectAt = false,
    },
    ["fire_iron"] = {
        Source = "fire_scoped2",
        ShellEjectAt = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.8,
        LHIKEaseOut = 0.5,
        SoundTable = {
            {s = "arccw/kraken/republic/dc17/handling/magout.wav", t = 5 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin_partial.wav", t = 30 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin.wav", t = 40 / 30},
        },
    },
--------------------------------------------------------
    ["reload_akimbo"] = {
        Source = "reload_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_empty_akimbo"] = {
        Source = "reload_empty_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_akimbo"] = {
        Source = "reload_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_empty_akimbo"] = {
        Source = "reload_empty_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },

    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 75 / 30},
            {s = "ArcCW_Kraken.Grab", t = 78 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc40.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-40"
SWEP.Trivia_Class = "Outer Rim Submachine Gun"
SWEP.Trivia_Desc = "Old Weapon used by the Humans during the Old Republic wars. Now, it's a cheap and powerful option for Mercenaries or Military."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dc40.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_dc40.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 5, -6),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 30
SWEP.DamageMin = 15
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 0.5

SWEP.Delay = 60 / 680
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC40"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC40"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.381, 0, 1.884),
    Ang = Vector(0, 0.133, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(9.5, 0, 4),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(30.5, 0, 2.9),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(22, 0.1, 2.4),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(2, -1.3, 1.8),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(4.3, -0.9, 3.2),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = "fire_iron",
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		MinProgress = 0.925,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_up.ogg", t = 0.0},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
            {s = path .. "wfoly_sm_secho_reload_magout.ogg", t = 0.433},
			{s = path .. "wfoly_sm_secho_reload_maghit.ogg", t = 0.867},
			{s = path .. "wfoly_sm_secho_reload_magin.ogg", t = 1.233},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.23},
			{s = path .. "wfoly_sm_secho_reload_end.ogg", t = 1.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload empty",
		MinProgress = 0.925,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        LHIK = true,
        SoundTable = {
			{s = path .. "wfoly_sm_secho_reload_empty_up.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_reload_empty_magout.ogg", t = 0.467},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
			{s = path .. "wfoly_sm_secho_reload_empty_mvmnt.ogg", t = 1.133},
			{s = path .. "wfoly_sm_secho_reload_empty_maghit.ogg", t = 1.25},
			{s = path .. "wfoly_sm_secho_reload_empty_magin.ogg", t = 1.35},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.36},
			{s = path .. "wfoly_sm_secho_reload_empty_charge.ogg", t = 1.64},
			{s = path .. "wfoly_sm_secho_reload_empty_end.ogg", t = 1.867},
        },
    },
    ["ready"] = {
        Source = "first_draw",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.5,
        LHIK = true,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holdster",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc40c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-40c"
SWEP.Trivia_Class = "Outer Rim Submachine Gun"
SWEP.Trivia_Desc = "Old Weapon used by the Humans during the Old Republic wars. Now, it's a cheap and powerful option for Mercenaries or Military."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dc40c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_dc40.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 5, -6),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 42
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 0.5

SWEP.Delay = 60 / 450
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC40"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC40"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.381, 0, 1.884),
    Ang = Vector(0, 0.133, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(9.5, 0, 4),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(30.5, 0, 2.9),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(22, 0.1, 2.4),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(2, -1.3, 1.8),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "tag_weapon_right",
        Offset = {
            vpos = Vector(4.3, -0.9, 3.2),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = "fire_iron",
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		MinProgress = 0.925,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_up.ogg", t = 0.0},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
            {s = path .. "wfoly_sm_secho_reload_magout.ogg", t = 0.433},
			{s = path .. "wfoly_sm_secho_reload_maghit.ogg", t = 0.867},
			{s = path .. "wfoly_sm_secho_reload_magin.ogg", t = 1.233},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.23},
			{s = path .. "wfoly_sm_secho_reload_end.ogg", t = 1.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload empty",
		MinProgress = 0.925,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        LHIK = true,
        SoundTable = {
			{s = path .. "wfoly_sm_secho_reload_empty_up.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_reload_empty_magout.ogg", t = 0.467},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
			{s = path .. "wfoly_sm_secho_reload_empty_mvmnt.ogg", t = 1.133},
			{s = path .. "wfoly_sm_secho_reload_empty_maghit.ogg", t = 1.25},
			{s = path .. "wfoly_sm_secho_reload_empty_magin.ogg", t = 1.35},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.36},
			{s = path .. "wfoly_sm_secho_reload_empty_charge.ogg", t = 1.64},
			{s = path .. "wfoly_sm_secho_reload_empty_end.ogg", t = 1.867},
        },
    },
    ["ready"] = {
        Source = "first_draw",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.5,
        LHIK = true,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holdster",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_de18_akimbo.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dh17c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DH-17c"
SWEP.Trivia_Class = "Blaster Pistol-Carbine"
SWEP.Trivia_Desc = "The DH-17 blaster pistol was commonly used by soldiers of the Rebel Alliance for conflicts aboard starships, and sometimes the officers of the Galactic Empire carried it instead of the standard E-11 medium blaster rifles. The DH-17 blaster rifle was a rifle version that featured a shoulder stock, and a hand-calibrated macroscopes. The rifles were black and silver in color."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dh17c.png"

-- Base
SWEP.DefaultBodygroups = "011110000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dh17c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-11, 4, -6),
    ang = Angle(-5, 0, 180)
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 18
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 30
SWEP.DamageMin = 23
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 32

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 345
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.27, -7.361, 2.4),
    Ang = Vector(0, 0.128, -1),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-2, 0, 0)
SWEP.ActiveAng = Angle(0, -1, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 2}, {ind = 2, bg = 2}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "v_weapon.parent",
        Offset = {
            vpos = Vector(0.52, -6, 2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0,0,0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"stealth_muzzle", "muzzle"},
        InstalledEles = {"muzzle_attach"},
        Bone = "v_weapon.parent",
        VMScale = Vector(1.7, 1.7, 1.7),
        WMScale = Vector(1.7, 1.7, 1.7),
        Offset = {
            vpos = Vector(0.51, -5, 9.83),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "v_weapon.parent",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(-0.1, -5.55, 7),
            vang = Angle(90, 0, -220),
        },
    }, 
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "v_weapon.parent",
        Offset = {
            vpos = Vector(1.29, -3.9, -2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "v_weapon.parent",
        Offset = {
            vpos = Vector(1.6, -4.7, 1),
            vang = Angle(90, 0, -90),
        },
    }, 
}

-- Don't touch this unless you know what you're doing

-- Anims
local path = "arccw/kraken/sw_galactic/handling/pistol/"

SWEP.Animations = {
    ["fire"] = {
        Source = {"shoot1", "shoot2", "shoot3"},
    },
    ["fire_sights"] = {
        Source = "shoot1_ads",
    },
    ["reload"] = {
        Source = "reload_short",
		MinProgress = 0.725,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 11 / 50},
            {s = path .. "clipout.wav", t = 10/50},
            {s = path .. "clipin.wav", t = 62/50},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 63 / 50},
            {s = "wfoly_ar_scharlie_raise_movment.ogg", t = 39/50},
        },
    },
    ["ready"] = {
        Source = "draw_short",
    },
    ["draw"] = {
        Source = "draw_short",
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "wfoly_ar_scharlie_raise_movment.ogg", t = 0.1/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["enter_sights"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 1,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 1,
    },

    ["exit_inspect"] = {
        Source = "lookat01",
        MinProgress = 0.9,
        SoundTable = {
            {s = "wfoly_ar_scharlie_raise_movment.ogg", t = 7/40},
            {s = "wfoly_ar_scharlie_raise_movment.ogg", t = 59/40},
            {s = "wfoly_ar_scharlie_raise_movment.ogg", t = 135/40},
            {s = "wfoly_ar_scharlie_raise_movment.ogg", t = 166/40},
        },
    },
    ["bash"] = {
        Source = {"melee", "melee2"},
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl18.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt19h.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dp23.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DP-23"
SWEP.Trivia_Class = "Blaster Shotgun"
SWEP.Trivia_Desc = "The DP-23 was a type of blaster that could pierce through enemy defenses. It was used by the Grand Army of the Republic's clone troopers during the Clone Wars between the Galactic Republic and the Confederacy of Independent Systems. The DP-23 fired blue blaster bolts, and had a ridged barrel with a pointed muzzle, a black stock, and a small foregrip."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dp23.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000100000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dp23.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-8, 3.5, -4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 1
SWEP.HeatFix = true

SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 14
SWEP.DamageMin = 5
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 24

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 140
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 75
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.ShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.066, -2.68, 0.246),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "shotgun"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -2)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}, {ind = 3, bg = 2}, {ind = 4, bg = 0}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC_15X_Rifle",
               Scale = Vector(0, 0, 0),                
               Offset = {
                pos = Vector(0, 15, 0),
                ang = Angle(-90, -90, 0)
               },
               IsMuzzleDevice = true
           }
        }
    }
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "DC-15 Holosight",
        Slot = {"optic"},
        Bone = "DC_15X_Rifle",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.11, 0, 2.7),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-1, 10, 0.5),
            vang = Angle(0, -90, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-0.1, 17, 0.55),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-0.05, 5.6, -0.15),
            vang = Angle(90, -90, -90),   
        }, 
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC_15X_Rifle",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.11, -5.1, -0.1),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC_15X_Rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(1.1, -8, 0.25),
            vang = Angle(0, -90, 0),
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["idle_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "arccw/kraken/empire/dlt19/handling/magrelease.wav", t = 0.2 },
            {s = "arccw/kraken/empire/dlt19/handling/magout.wav", t = 0.4 },
            {s = "arccw/kraken/empire/dlt19/handling/mag_fetch.wav", t = 0.6 },   
            {s = "arccw/kraken/empire/dlt19/handling/magin.wav", t = 1.4 },   
            {s = "arccw/kraken/empire/dlt19/handling/boltback.wav", t = 1.6 },   
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dp9.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DP-9"
SWEP.Trivia_Class = "Blaster, Rifle"
SWEP.Trivia_Desc = "Before the E-10 and E-11, the E-9 existed as a prototype of the capabilities of the future weapons. It development started during the final months of the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.IconOverride = "entities/kraken/galactic/dp9.png"

-- Base
SWEP.DefaultBodygroups = "00000202000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_e11.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-15, 8, -9),
    ang = Angle(-30, 25, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 5
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = false
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 27
SWEP.DamageMin = 17
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 4000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 1.5
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.9
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 120
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "ArcCW_Kraken.SW_E9"
SWEP.ShootSound = "ArcCW_Kraken.SW_E9"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.379, -6.961, 2.5),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4.5, -2, 1.5)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11_GUN",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 13, -2),
                   ang = Angle(-90, -90, 0)
               },
               IsMuzzleDevice = true
           }
        }
    },
    ["e11_grip_standard"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "E11_GUN",
        Offset = {
            vpos = Vector(0.12, -4.5, 2.4),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "E11_GUN",
        Offset = {
            vpos = Vector(0.1, 9, 1),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "E11_GUN",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.5, 4, 1),
            vang = Angle(0, -90, -90),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "Standard E-11 Grip",
        Slot = {"foregrip", "sw_ubgl", "e11_grid"},
        Bone = "E11_GUN",
        InstalledEles = {"e11_grip_standard"},
        Offset = {
            vpos = Vector(-0, 0.2, 2.5),
            vang = Angle(90, -90, -90),   
        },
        SlideAmount = {
        vmin = Vector(0.2, 4, 0.4),
        vmax = Vector(0.2, 6, 0.5),
        },    
    },
    {
        PrintName = "Energization",
        DefaultAttName = "Red Tibanna",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11_GUN",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.13, -6.75, 1.11),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "E11_GUN",
        VMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0.9, -1.1, 0.9),
            vang = Angle(0, -90, 0),
        },
    },
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/e9/e11_reload.wav", t = 0.1 },
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_ee3e.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "EE-3e"
SWEP.Trivia_Class = "Blaster Long-Range Carabine"
SWEP.Trivia_Desc = "Blaster Long-Range Carabine designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/ee3e.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_ee3.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 16
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 33
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 31

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.ShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.027, 0, 1.503),
    Ang = Vector(0, 0, -2.878),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.06, 1, 1.65),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 8.5, 0.5),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 13, 0.4),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-0., 6, -0.6),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.5, -1.1, -1),
            vang = Angle(-20, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.2, 4, 0.4),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_el16c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_esb_ee3.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_esb_ee3.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "ESB-EE3"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "Blaster Carabine designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/esb_ee3.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_esb_ee3.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 36
SWEP.DamageMin = 24
SWEP.RangeMin = 0
SWEP.Range = 450
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 26

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.44
SWEP.RecoilRise = 0.64

SWEP.Delay = 60 / 450
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.ShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.027, 0, 1.45),
    Ang = Vector(0, 0, -4),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 11, 0),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.07, -1.9, 1.7),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.7, 8.5, 0.6),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0, 4.5, -0.1),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.08, -1.4, -0.45),
            vang = Angle(-20, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.05, 0.8, 0.6),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_f11.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "F-11"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The F-11D blaster rifle was a blaster rifle manufactured by Sonn-Blas Corporation. This ranged weapon was the successor of the older E-11 medium blaster rifle used by the Galactic Empire. It served as the standard issue weapon of First Order stormtroopers."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Calibre = "Sonn-Blas Corporation"
SWEP.IconOverride = "entities/kraken/galactic/f11.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00011000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_f11d.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 41
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 410
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.78
SWEP.RecoilSide = 0.54
SWEP.RecoilRise = 0.97
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 270
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_F10"
SWEP.ShootSound = "ArcCW_Kraken.SW_F10"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.9, 0, 1.3),
    Ang = Vector(2, -0.3, 1),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 2, 0)
SWEP.ActiveAng = Angle(0, -0.3, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 4, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 10, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.2, -3.2, 1.1),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.9, 4, 0.25),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.1, 1.1, 1.1),
        WMScale = Vector(1.1, 1.1, 1.1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, 9, 0.1),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.93, -1.5, -0.1),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -3.6, -0.25),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_fwmb10h.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_iqa11.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "IQA-11"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The IQA-11 Blaster Rifle was a model of sniper rifle with a sleek and inexpensive design that made it a weapon of choice for mercenaries and bounty hunters who sought reliability over longer ranges. The rifle could receive modifications, such as an extended barrel and a dual zoom scope. During the Clone Wars, the bounty hunter Rumi Paramita used an IQA-11 while defending Felucian farmers from the Ohnaka Gang. A Mon Calamari also utilized the weapon during the Imperial Era."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/iqa11.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_iqa11.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 5
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 104
SWEP.DamageMin = 76
SWEP.RangeMin = 0
SWEP.Range = 900
SWEP.Penetration = 11
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 133, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 1.5
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.9
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_IQA"
SWEP.ShootSound = "ArcCW_Kraken.SW_IQA"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 192, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.283, 0, 1.488),
    Ang = Vector(0, -0.143, 3.076),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -1, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "body",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.06, 0, 1.6),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "body",
        Offset = {
            vpos = Vector(0, 1.2, 20),
            vang = Angle(-90, 180, 90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        InstalledEles = {"muzzle_attach"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.9, 32.3),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "body",
        Offset = {
            vpos = Vector(0.4, 2.7, -2.4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "body",
        Offset = {
            vpos = Vector(0.6, 1.5, 2),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
local pathRZ = "uplp_rz/awp/"
-- urbna!
local pathUT = "arccw/kraken/sw_galactic/weapons/iqa11/handling/"
local pathUTC = "uplp_urban_temp/common/"

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["draw"] = {
        Source = "draw",
        MinProgress = 0.75,
        LHIK = true,
        SoundTable = {
            { s = pathUTC .. "raise.ogg", t = 0.1, v = 0.8 },
        },
    },
    ["holster"] = {
        Source = "holster",
        MinProgress = 0.5,
        LHIK = true,
        SoundTable = {
            { s = pathUTC .. "rattle2.ogg", t = 0, v = 0.8 },
        },
    },
    ["fire"] = {
        Source = {"fire"},
    },
    ["reload"] = {
        Source = "reload_ext",
        Mult = 1.1,
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,

        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 6 / 30},
            { s = pathUTC .. "cloth_2.ogg", t = 0.1 / 30, c = ca, v = 0.8 },
            { s = pathUT .. "magout.ogg", t = 5 / 30, c = ca, v = 0.8 },
            { s = pathUTC .. "magpouch.ogg", t = 13 / 30, v = 0.3 },
            {s = "ArcCW_Kraken.OverheatReplenished", t = 24 / 30},
            { s = pathUT .. "magin.ogg", t = 22.5 / 30, c = ca, v = 0.8 },
            { s = pathUTC .. "rattle2.ogg", t = 35 / 30, c = ca, v = 0.8 },

        },
    },
    -- Inspecc --
    ["exit_inspect"] = {
        Source = "inspect",
        LHIK = true,
        MinProgress = 0.925,
    },
    ["enter_bipod"] = {
        Source = "modeswitch",
    },
    ["enter_bipod_empty"] = {
        Source = "modeswitch_empty",
    },
    ["exit_bipod"] = {
        Source = "modeswitch",
    },
    ["exit_bipod_empty"] = {
        Source = "modeswitch_empty",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_iqa11c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "IQA-11c"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The IQA-11 Blaster Rifle was a model of sniper rifle with a sleek and inexpensive design that made it a weapon of choice for mercenaries and bounty hunters who sought reliability over longer ranges. The rifle could receive modifications, such as an extended barrel and a dual zoom scope. During the Clone Wars, the bounty hunter Rumi Paramita used an IQA-11 while defending Felucian farmers from the Ohnaka Gang. A Mon Calamari also utilized the weapon during the Imperial Era."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/iqa11c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00220000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_iqa11.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 13
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 87
SWEP.DamageMin = 65
SWEP.RangeMin = 0
SWEP.Range = 650
SWEP.Penetration = 11
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 1.7
SWEP.RecoilSide = 1.2
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.9
SWEP.RecoilVMShake = 1.5

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_IQA"
SWEP.ShootSound = "ArcCW_Kraken.SW_IQA"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.283, 0, 1.488),
    Ang = Vector(0, -0.143, 3.076),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -1, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "body",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.06, 0, 1.6),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "body",
        Offset = {
            vpos = Vector(0, 1.2, 19),
            vang = Angle(-90, 180, 90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        InstalledEles = {"muzzle_attach"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.9, 22),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "body",
        Offset = {
            vpos = Vector(0.4, 2.7, -2.4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "body",
        Offset = {
            vpos = Vector(0.6, 1.5, 2),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
local pathRZ = "uplp_rz/awp/"
-- urbna!
local pathUT = "arccw/kraken/sw_galactic/weapons/iqa11/handling/"
local pathUTC = "uplp_urban_temp/common/"

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["draw"] = {
        Source = "draw",
        MinProgress = 0.75,
        LHIK = true,
        SoundTable = {
            { s = pathUTC .. "raise.ogg", t = 0.1, v = 0.8 },
        },
    },
    ["holster"] = {
        Source = "holster",
        MinProgress = 0.5,
        LHIK = true,
        SoundTable = {
            { s = pathUTC .. "rattle2.ogg", t = 0, v = 0.8 },
        },
    },
    ["fire"] = {
        Source = {"fire"},
    },
    ["reload"] = {
        Source = "reload_ext",
        Mult = 1.1,
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,

        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 6 / 30},
            { s = pathUTC .. "cloth_2.ogg", t = 0.1 / 30, c = ca, v = 0.8 },
            { s = pathUT .. "magout.ogg", t = 5 / 30, c = ca, v = 0.8 },
            { s = pathUTC .. "magpouch.ogg", t = 13 / 30, v = 0.3 },
            {s = "ArcCW_Kraken.OverheatReplenished", t = 24 / 30},
            { s = pathUT .. "magin.ogg", t = 22.5 / 30, c = ca, v = 0.8 },
            { s = pathUTC .. "rattle2.ogg", t = 35 / 30, c = ca, v = 0.8 },

        },
    },
    -- Inspecc --
    ["exit_inspect"] = {
        Source = "inspect",
        LHIK = true,
        MinProgress = 0.925,
    },
    ["enter_bipod"] = {
        Source = "modeswitch",
    },
    ["enter_bipod_empty"] = {
        Source = "modeswitch_empty",
    },
    ["exit_bipod"] = {
        Source = "modeswitch",
    },
    ["exit_bipod_empty"] = {
        Source = "modeswitch_empty",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_j1.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "J1 Blaster"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Blaster Pistol designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/j1.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_j1pistol.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 27
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 29

SWEP.Recoil = 0.6
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 340
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_J1"
SWEP.ShootSound = "ArcCW_Kraken.SW_J1"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.045, -11.296, 1.22),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -1.95, -3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0.0, -1.4, -0.67),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.36, -1.35, -1.),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.34, -0.75, -5.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.3, -1.45, -6),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_e60r.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_rps6_empire.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Explosives - Rocket Launchers"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Empire RPS-6"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "The RPS-6 rocket launcher, also known as the Sienar shoulder-launched missile, was a model of missile launcher manufactured by Merr-Sonn Munitions, Inc. and Sienar Fleet Systems."
SWEP.Trivia_Manufacturer = "Sienar Fleet Systems, Merr-Sonn Munitions Inc"
SWEP.Trivia_Calibre = "Rocket"
SWEP.IconOverride = "entities/kraken/explosives/rps6_imperio.png"

-- Base
SWEP.DefaultBodygroups = "0000000000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_rps6_empire.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-15, 0, 49),
    ang = Angle(0, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.ShootEntity = "rocket_rps"
SWEP.MuzzleVelocity = 6000

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Recoil = 4.3
SWEP.RecoilSide = 0.550
SWEP.RecoilRise = 2
SWEP.RecoilPunch = 2.5
SWEP.RecoilVMShake = 1.5
SWEP.VisualRecoilMult = 0.7

SWEP.Delay = 60 / 60
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.725
SWEP.SightedSpeedMult = 0.70
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.70

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "RPG_Round"
SWEP.ShootVol = 120
SWEP.ShootPitch = 95
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"
SWEP.ShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "muzzleflash_m79"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 137, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.04, -5, 0.31),
    Ang = Vector(16, 0, -4),
     Magnification = 4,
     SwitchToSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_up.ogg",
     SwitchFromSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_down.ogg",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(16, 0, -5)

SWEP.SprintPos = Vector(4.019, -5.226, -2)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4.5, -7, -3)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_launcher_offset",
        Offset = {
            vpos = Vector(10, -1.4, 0.25),
            vang = Angle(0, 0, 90),
        },
    }, 
    {
        PrintName = "Ammunition",
        DefaultAttName = "Rocket",
        Slot = {"k_rocket_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_launcher_offset",
        Offset = {
            vpos = Vector(1.9, -0.42, -2),
            vang = Angle(0, 0, 0),
        },
    }, 
}


-- Animations!
local path = "kraken/launchers/rps/"

SWEP.BulletBones = {
    [1] = "j_mag1",
}

SWEP.Animations = {
	["enter_sights"] = {
		Source = "idle",
	},
    ["fire"] = {
        Source = "shoot1",
    },
    ["dryfire"] = {
        Source = "firemode",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.95,
        SoundTable = {
			{s = path .. "wfoly_la_rpapa7_reload_raise.ogg", t = 0.1},
			{s = path .. "wfoly_la_rpapa7_reload_load.ogg", t = 0.333},
			{s = path .. "wfoly_la_rpapa7_reload_lower.ogg", t = 1.033},
			{s = path .. "wfoly_la_rpapa7_reload_fast_hip_safetyclick.ogg", t = 1.7},
			{s = path .. "wfoly_la_rpapa7_reload_end.ogg", t = 1.9},
        },
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_raise_first.ogg", t = 9/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_drop_hip_rattle.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["enter_customize"] = {
        Source = "lookat01",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_inspect_01.ogg", t = 5/30},
			{s = path .. "wfoly_la_rpapa7_inspect_02.ogg", t = 88/30},
			{s = path .. "wfoly_la_rpapa7_inspect_03.ogg", t = 165/30},
        },
    },
    ["idle_customize"] = {
        Source = "lookat01",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_inspect_01.ogg", t = 5/30},
			{s = path .. "wfoly_la_rpapa7_inspect_02.ogg", t = 88/30},
			{s = path .. "wfoly_la_rpapa7_inspect_03.ogg", t = 165/30},
        },
    },
    ["exit_customize"] = {
        Source = "lookat01",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_inspect_01.ogg", t = 5/30},
			{s = path .. "wfoly_la_rpapa7_inspect_02.ogg", t = 88/30},
			{s = path .. "wfoly_la_rpapa7_inspect_03.ogg", t = 165/30},
        },
    },
    ["bash"] = {
        Source = "melee_01",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_m45x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "'Roba' M-45x"
SWEP.Trivia_Class = "Repeating Ion Blaster"
SWEP.Trivia_Desc = "The 'Roba' M-45 repeating ion blaster, manufactured by BlasTech Industries, was a heavy repeating ion blaster that saw use during the Galactic Civil War, typically pintel-mounted on UT-60D U-wing gunships."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/m45x.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000100011000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_m45.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -5),
    ang = Angle(-10, -90, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 30
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BLAST
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 1.25
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 0.5

SWEP.Delay = 60 / 750
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_M45"
SWEP.ShootSound = "ArcCW_Kraken.SW_M45"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.BulletBones = {
    [17] = "j_b_01",
    [16] = "j_b_02",
	[15] = "j_b_03",
	[14] = "j_b_04",
	[13] = "j_b_05",
	[12] = "j_b_06",
	[11] = "j_b_07",
	[10] = "j_b_08",
	[9] = "j_b_09",
	[8] = "j_b_10",
	[7] = "j_b_11",
	[6] = "j_b_12",
	[5] = "j_b_13",
	[4] = "j_b_14",
	[3] = "j_b_15",
	[2] = "j_b_16",
	[1] = "j_b_17",
}

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.07, -3, 0.7),
    Ang = Angle(-0.2, 0, -1.5),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["grip_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 8, bg = 0}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(8, 0, 2.5),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(51.2, 0, 0.6),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        InstalledEles = {"laser_attach"},
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(21.1, 0.6, -0.9),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(16, 0, -1.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(6.5, -0.39, 0.85),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10.4, -0.7, -0.5),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/m45/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["ready"] = {
        Source = "draw",
		MinProgress = 0.7,
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_raise_first_raise.ogg", t = 0.1/30},
            {s = path .. "wfoly_lm_kilo121_raise_first_raise_01.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_drop.ogg", t = 11/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_rattle.ogg", t = 22/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltopen_01.ogg", t = 30/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltclose_01.ogg", t = 43/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_cloth01.ogg", t = 51/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_end.ogg", t = 59/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_raise.ogg", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_reload_empty_end.ogg", t = 0.1/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Time = 1.25,
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
    },
    ["fix"] = {
        Source = "jam",
        Mult = 2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.1/30},
            {s = "ArcCW_Kraken.OverheatFix", t = 35/30},
            {s = "ArcCW_Kraken.Grab", t = 35 / 30},
        },
    },
    ["reload"] = {
        Source = "reload_short",
		MinProgress = 0.95,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_lm_kilo121_reload_raise.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltopen_01.ogg", t = 23/30},
            {s = "ArcCW_Kraken.Overheat", t = 23/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltclose_01.ogg", t = 37/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37/30},
			{s = path .. "wfoly_lm_kilo121_reload_lower.ogg", t = 44/30},
			{s = path .. "wfoly_lm_kilo121_reload_coveropen_01.ogg", t = 65/30},
			{s = path .. "wfoly_lm_kilo121_reload_magout_01.ogg", t = 86/30},
			{s = path .. "wfoly_lm_kilo121_reload_boxmag.ogg", t = 110/30},
			{s = path .. "wfoly_lm_kilo121_reload_magin_01.ogg", t = 128/30},
			{s = path .. "wfoly_lm_kilo121_reload_click_01.ogg", t = 151/30},
            {s = "ArcCW_Kraken.OverheatFix", t = 180/30},
			{s = path .. "wfoly_lm_kilo121_reload_coverclose_01.ogg", t = 174/30},
			{s = path .. "wfoly_lm_kilo121_reload_end.ogg", t = 201/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
		MinProgress = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_lm_kilo121_reload_empty_lift.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_boltopen_01.ogg", t = 23/30},
            {s = "ArcCW_Kraken.Overheat", t = 23/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_boltclose_01.ogg", t = 37/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_lower.ogg", t = 44/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_coveropen_01.ogg", t = 65/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_clean.ogg", t = 83/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_inspect.ogg", t = 106/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_magout_01.ogg", t = 114/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_raise_01.ogg", t = 126/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_boxmag.ogg", t = 142/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_magin_01.ogg", t = 155/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_beltmvmnt.ogg", t = 164/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_click_01.ogg", t = 176/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_mvmnt01.ogg", t = 193/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_coverclose_01.ogg", t = 201/30},
            {s = "ArcCW_Kraken.OverheatFix", t = 210/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_end.ogg", t = 223/30},
        },
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_inspect_01.ogg", t = 0/30},
			{s = path .. "wfoly_lm_kilo121_inspect_02.ogg", t = 55/30},
			{s = path .. "wfoly_lm_kilo121_inspect_03.ogg", t = 113/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_mk2paladin.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_bacta.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_c14.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "C-14 Anti-Vehicle Grenade"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "When thrown, anti-vehicle grenades begin a 3 second fuse, and bounce off any surfaces they contact. Anti-vehicle grenades can stick to vehicles and will do so to the first appropriate unit they contact, including to friendlies. Anti-vehicle grenades do not deal any additional damage if stuck to a target, as compared to exploding within range."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "High Explosive Anti-Vehicle"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Galactic Empire"
SWEP.IconOverride = "entities/kraken/explosives/c14.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_c14.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(2, 1, -7),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_c14"

SWEP.MuzzleVelocity = 1200
SWEP.MuzzleVelocityAlt = 900

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 6, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["quicknade"] = {
        Source = "quick_pullout",
        MinProgress = 0.3,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        MinProgress = 0.3,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["ready"] = {
        Source = "draw",
        MinProgress = 0.3,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
		Mult = 1.5,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.52
    },
    ["throw_alt"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.52
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		Mult = 3,
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Mult = 3,
    },
    ["bash"] = {
        Source = {"melee_hit01","melee_hit02","melee_hit03"},
    },
}

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_dioxis.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Dioxis Grenade"
SWEP.Trivia_Class = "Explosive, Dioxis"
SWEP.Trivia_Desc = "The dioxis grenade, dioxis mine, or dioxis charge was a grenade that upon being thrown, would release a toxic gas known as dioxis. The gas was only mild, however it would choke to death those who were in its range for an extended period of time. It was known to be used by the BX-series droid commandos of the Separatist Alliance, and later the Rebel Alliance, Galactic Empire, and the New Republic."
SWEP.Trivia_Manufacturer = "BlastTech Industries, Merr Sonn Munitions Inc."
SWEP.Trivia_Calibre = "Releasing dioxis"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/dioxis.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_grenade_dioxis.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-16, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_dioxis"

SWEP.MuzzleVelocity = 900
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_smoke.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_thermal.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_thermalimploder.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_thermite.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nn14.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "NN-14"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The NN-14 blaster pistol was a blaster pistol manufactured by LPA. The blaster featured a compact grip, enlarged power core, reinforced frame, a safety switch, armored body shell, and flash suppressing/stabilizing muzzle. Han Solo owned one and later gave it to the scavenger Rey, who went on to use the blaster against the First Order. When she went to find Luke Skywalker, she was seen with a holster for her NN-14"
SWEP.Trivia_Manufacturer = "LPA"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/nn14.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_nn14.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 7
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 45
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 430
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(225, 0, 255)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_purple"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 14

SWEP.Recoil = 1.3
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 170
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_NN14"
SWEP.ShootSound = "ArcCW_Kraken.SW_NN14"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_purple"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(225, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.043, -11.296, 1.05),
    Ang = Angle(0.5,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2.4, -1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        VMScale = Vector(1.3, 1.3, 1.3),
        WMScale = Vector(1.3, 1.3, 1.3),
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0.03, -1.8, 2),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.6, -1.35, 0),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.35, -1.48, -4.49),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.7, -1.2, -0.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nt240.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 -- Change this if you want to select the weapon with other number

SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "NT-240"
SWEP.Trivia_Class = "Sniper"
SWEP.Trivia_Desc = "Short barrel version of NT-242 family. The NT-242 was a type of sniper rifle. The NT-242 was considered a tank buster by many users and was one of the heaviest longblasters. The NT-242 was powerful at range, and could be modified to have a disruptor shot which could engage vehicles."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/nt240.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000200000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_nt242.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-1, 0.6, -3),
    ang = Angle(-5, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 105
SWEP.DamageMin = 95
SWEP.RangeMin = 0
SWEP.Range = 1000
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_purple"
SWEP.TracerCol = Color(150, 0, 250)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 2.1
SWEP.RecoilSide = 0.65
SWEP.RecoilRise = 0.85
SWEP.RecoilPunch = 2.5

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}


SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.85
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.FirstShootSound = "ArcCW_Kraken.SW_NT242"
SWEP.ShootSound = "ArcCW_Kraken.SW_NT242"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(150, 0, 250)
SWEP.MuzzleEffect = "blaster_muzzle_purple"
SWEP.GMMuzzleEffect = false

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.48, -0, 0.5),
    Ang = Vector(3, 0.5, -2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -2)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

SWEP.GuaranteeLaser = true

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
}


SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(8, -0.0, 2.6),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        Bone = "tag_attachments",
        VMScale = Vector(1.3, 1.3, 1.3),
        WMScale = Vector(1.3, 1.3, 1.3),
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(30, -0.0, 0.5),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(23, 1, 0.4),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(20, 0, -0.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(4.8, -0.5, -1.1),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(9, -1, 0.8),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Animations
local path = "arccw/kraken/sw_galactic/handling/nt242/"

SWEP.Animations = {
	["enter_sights"] = {
		Source = "ads_in",
	},
	["exit_sights"] = {
		Source = "ads_out",
	},
    ["fire"] = {
        Source = "shoot1",
        ShellEjectAt = false,
    },
    ["dryfire"] = {
        Source = "dryfire",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Source = "reload_short",
        LHIK = true,
		MinProgress = 0.975,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_reload_up.ogg", t = 0.0},
            {s = path .. "wfoly_sn_xmike109_reload_magrelease.ogg", t = 0.9},
			{s = path .. "wfoly_sn_xmike109_reload_magout.ogg", t = 1.4},
			{s = path .. "wfoly_sn_xmike109_reload_arm.ogg", t = 2.367},
			{s = path .. "wfoly_sn_xmike109_reload_magin_01.ogg", t = 2.867},
			{s = path .. "wfoly_sn_xmike109_reload_magin_02.ogg", t = 3.1},
			{s = path .. "wfoly_sn_xmike109_reload_end.ogg", t = 3.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
		MinProgress = 0.975,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_reload_empty_up.ogg", t = 0.033},
            {s = path .. "wfoly_sn_xmike109_reload_empty_magrelease.ogg", t = 1.05},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magout.ogg", t = 1.45},
			{s = path .. "wfoly_sn_xmike109_reload_empty_arm.ogg", t = 2.2},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magin_01.ogg", t = 2.78},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magin_02.ogg", t = 3.2},
			{s = path .. "wfoly_sn_xmike109_reload_empty_rotate.ogg", t = 3.667},
			{s = path .. "wfoly_sn_xmike109_reload_empty_boltpull.ogg", t = 4.267},
			{s = path .. "wfoly_sn_xmike109_reload_empty_boltrelease.ogg", t = 4.8},
			{s = path .. "wfoly_sn_xmike109_reload_empty_end.ogg", t = 5.1},
        },
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_up.ogg", t = 0.1},
            {s = path .. "wfoly_sn_xmike109_first_raise_bolt_pull.ogg", t = 0.6},
            {s = path .. "wfoly_sn_xmike109_first_raise_bolt_release.ogg", t = 1.0},
			{s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 36/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        MinProgress = 0.3,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_up.ogg", t = 0/30},
			{s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 10/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["exit_inspect"] = {
        Source = "lookat01",
        LHIK = true,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_inspect_up.ogg", t = 0.1},
			{s = path .. "wfoly_sn_xmike109_inspect_grabrotate.ogg", t = 1.7},
			{s = path .. "wfoly_sn_xmike109_inspect_move.ogg", t = 3.7},
			{s = path .. "wfoly_sn_xmike109_inspect_end.ogg", t = 111/30},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nt242x.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_republic_e9.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "E-9"
SWEP.Trivia_Class = "Blaster, Rifle"
SWEP.Trivia_Desc = "An experimental Blaster Rifle designed to be cheaper and better than the DC-15 series."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Laser Bolt"
SWEP.Trivia_Mechanism = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/e9.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_e9.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.MirrorWorldModel = nil
SWEP.ViewModelFOV = 60


SWEP.WorldModelOffset = {
    pos = Vector(-15, 8, -9.6),
    ang = Angle(-30, 25, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45

SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6
SWEP.Recoil = 0.7

SWEP.Delay = 60 / 330
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_E9"
SWEP.ShootSound = "ArcCW_Kraken.SW_E9"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.274, -9.336, 2.21),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4.5, -2, 1.5)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["e9_grip"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["e9_holosight"] = {
        VMBodygroups = {{ind = 6, bg = 1}, {ind = 5, bg = 1}, {ind = 4, bg = 1}, {ind = 2, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11_GUN",
               Scale = Vector(0, 0, 0),                
               Offset = {
                pos = Vector(0, 8, 0),
                ang = Angle(-90, -90, 0)
            },
               IsMuzzleDevice = true
           }
        }
    }
}

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "E-Series Holosight",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Slot = "optic",
        Bone = "E11_GUN",
        Offset = {
            vpos = Vector(0.22, -4, 2.2),
            vang = Angle(0, -90, 0),
        },
        InstalledEles = {"e9_holosight"},
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "E11_GUN",
        Offset = {
            vpos = Vector(0.17, 8.1, 1.2),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "E11_GUN",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.3, 4.1, 1.2),
            vang = Angle(0, -90, -90),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "E-9 Foregrip",
        Slot = {"foregrip", "sw_ubgl"},
        Bone = "E11_GUN",
        InstalledEles = {"e9_grip"},
        Offset = {
            vpos = Vector(-0, 4.3, 0.5),
            vang = Angle(90, -90, -90),   
        }, 
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11_GUN",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.75, -2.7, 0),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "E11_GUN",
        VMScale = Vector(0.9, 0.9, 0.9),
        wmScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0.95, -4, 1),
            vang = Angle(0, -90, 0),
        },
    },
}

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "arccw/kraken/empire/e-series/e11_reload.wav", t = 0.1 },
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_sg6.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Confederacy Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "SG-6"
SWEP.Trivia_Class = "Blaster, Scatter"
SWEP.Trivia_Desc = "Short and Medium Range blaster scatter used by the Confederacy of Independent Systems during the Clone Wars."
SWEP.Trivia_Manufacturer = "Baktoid Armor Workshop"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Confederacy of Independent Systems"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/cis_shotgun.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/cis/v_cis_shotgun.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.MirrorWorldModel = nil
SWEP.ViewModelFOV = 60


SWEP.WorldModelOffset = {
    pos = Vector(-8.6, 5.5, -5),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 1
SWEP.HeatFix = true

SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 14
SWEP.DamageMin = 5
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 24

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 140
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 75
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30
-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.ShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.858, 0, 1.768),
    Ang = Vector(0, -0.452, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "shotgun"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "dlt34",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-2, 2, 20),
                    ang = Angle(90, 0, 0),
                },
                IsMuzzleDevice = true,
            }
         }, 
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "None",
        Slot = "optic", 
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0., -4, 12),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.05, -1.75, 18.8),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34", 
        Offset = {
            vpos = Vector(-1.05, -1.5, 10),
            vang = Angle(90, 0, -180),
        },
    },  
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode"},
    },   
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.85, -0.3, 1.7),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.7, -1.4, 1.78),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 0.6,
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "overheat", 
        Mult = 2.2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_stw48.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_stw48c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "ST-W48c"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The ST-W48 blaster was a blaster used by the Sith troopers of the Sith Eternal army, including the trooper ST-I4191. The weapon could be used in a blaster rifle configuration or a blaster carbine configuration where the stock was removed for use in confined spaces. Each ST-W48 had a quarrel-bolt launcher installed below its barrel that used enhanced bowcaster technology for a powerful explosive attack. The rifle's power cell cartridge was located around the mid-point of the weapon's length, above the trigger. The weapon had an auto fire mode that provided a high rate of fire."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/stw48c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "01010000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_stw48.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin = 24
SWEP.RangeMin = 0
SWEP.Range = 450
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 31

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 500
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_STW48"
SWEP.ShootSound = "ArcCW_Kraken.SW_STW48"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.15, 0, -0.3),
    Ang = Vector(0, 0, -3.2),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 8, 0),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 0}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        InstalledEles = {"scope_attach"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.06, -1.8, 1.6),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.6, 4, 0.5),
            vang = Angle(-100, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        InstalledEles = {"muzzle_attach"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 6.5, 0.4),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-0., 3, -0.95),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.03, 0, -0.1),
            vang = Angle(5, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.05, -3.9, -0.2),
            vang = Angle(5, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_valken38.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_weapon_antimaterial.lua:
AddCSLuaFile()

SWEP.Base = "arccw_kraken_heavyproj_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Explosives - Weapons"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "K-43"
SWEP.Trivia_Class = "Rifle, Anti-Material Rifle"
SWEP.Trivia_Desc = "Developed by a weapons firm during the First Galactic Civil War, the K-43 is an anti-vehicle cannon that is based upon an early model of the Beam-tube laser rifle. As testing of the prototypes progressed, a tresle duopod, long range scope, and stabilizing brace were added. The K-43 is not for sentients with poor skill or strength. The weapon utilizes a complicated reloading mechanism which results in a long downtime between shots. This delay is compensated for by the powerful blast of the cannon, which can wound or even cripple military vehicles. Sentients with miserable accuracy will suffer even more, as each shot is bound to reveal the shooter to its target."
SWEP.Trivia_Calibre = "Shell"
SWEP.Trivia_Manufacturer = "Galactic Empire"
SWEP.IconOverride = "entities/kraken/explosives/antimaterial_rifle.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000000000"
SWEP.UseHands = true
SWEP.MirrorVMWM = true

SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_sw_antimaterial.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-9.5, 8, -6),
    ang = Angle(-5, 0, 180)
}

-- Damage & Tracer
SWEP.TriggerDelay = true
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.ShellModel = "models/misc/88mm_shell.mdl"
SWEP.ShellPitch = 55
SWEP.ShellScale = 0.6
SWEP.ShellTime = 1
SWEP.ShellRotateAngle = Angle(0, 0, 0)

SWEP.Damage = 205
SWEP.DamageMin = 98
SWEP.RangeMin = 0
SWEP.Range = 1300
SWEP.Penetration = 8
SWEP.DamageType = DMG_AIRBOAT
SWEP.MuzzleVelocity = 9000

SWEP.Tracer = "nio_tracer"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerNum = 1
SWEP.TracerWidth = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8

SWEP.Recoil = 5.3
SWEP.RecoilSide = 0.550
SWEP.RecoilRise = 0.5
SWEP.RecoilPunch = 2
SWEP.RecoilVMShake = 1.5
SWEP.VisualRecoilMult = 0.7

SWEP.ManualAction = true
SWEP.NoLastCycle = true

SWEP.Delay = 60 / 60
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.85
SWEP.SightedSpeedMult = 0.35
SWEP.ShootSpeedMult = 1

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 120
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "kraken/explosives/torpedo/close1.wav"
SWEP.ShootSound = "kraken/explosives/torpedo/close2.wav"
SWEP.ShootSoundSilenced = "warhammer/weapons/exitus_rifle/exitus_single.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "nio_charge"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0, -5, 0),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0,0,0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(0, 5, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)


-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "def_c_base",
        Offset = {
            vpos = Vector(0.8, -4.4, 35),
            vang = Angle(90, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "def_c_base",
        Offset = {
            vpos = Vector(1.15, -6.7, 21.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "def_c_base",
        Offset = {
            vpos = Vector(1.65, -4.6, -3),
            vang = Angle(90, 0, -90),
        },
    },
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["trigger"] = {
        Source = "idle",
        Mult = 0.12,
        SoundTable = {
            {p = 100, s = "kraken/explosives/torpedo/chargeup.wav", t = 0.01 },
        },
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 1},
    ["enter_sprint"] = {
        Source = "sprint_in",
        MinProgress = 0.1,
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        MinProgress = 0.1,
    },
    ["ready"] = {
        Source = "draw_first",
        SoundTable = {
            {p = 100, s = "kraken/weapons/antimaterial/mech_kraber_ads_in_2ch_v1_01.wav", t = 0 / 30},
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_boltback_2ch_v1_01.wav", t = 18 / 30},
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_boltforward_2ch_v1_01.wav", t = 27 / 30}
        },
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {p = 100, s = "kraken/weapons/antimaterial/mech_kraber_ads_in_2ch_v1_02.wav", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        Mult = 1,
        SoundTable = {
            {p = 100, s = "kraken/weapons/antimaterial/mech_kraber_ads_in_2ch_v1_03.wav", t = 0 / 30},
        },
    },
    ["idle_sight"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire",
        -- Time = 9 / 10,
        MinProgress = 0.8,
    },
    ["cycle"] = {
        Source = "rechamber",
        ShellEjectAt = 0.5,
        -- Time = 63 / 40,
        MinProgress = 1.5,
        SoundTable = {
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_boltback_2ch_v1_01.wav", t = 15 / 30},
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_boltforward_2ch_v1_01.wav", t = 24 / 30}
        },
    },
    ["enter_sight"] = {
        Source = false,
        MinProgress = 0.1,
    },
    ["fire_sight"] = {
        Source = "fire",
        -- Time = 9 / 10,
        MinProgress = 0.8,
    },
    ["cycle_sight"] = {
        Source = "rechamber",
        ShellEjectAt = 0.5,
        -- Time = 63 / 40,
        MinProgress = 1.5,
        SoundTable = {
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_boltback_2ch_v1_01.wav", t = 16 / 30},
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_boltforward_2ch_v1_01.wav", t = 22 / 30}
        },
    },
    ["exit_sight"] = {
        Source = "iron_out",
        MinProgress = 0.1,
    },
    ["bash"] = {
        Source = {"melee"},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.4,
        SoundTable = {
            {s = "ArcCW_APEX.Melee.Swing.Punch", t = 0 / 30},
    },
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
    },
    ["idle_inspect"] = {
        Source = "inspect",
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_magout_2ch_v1_01.wav", t = 15 / 30},
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_magin_2ch_v1_01.wav", t = 53 / 30}
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_magout_2ch_v1_01.wav", t = 15 / 30},
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_magin_2ch_v1_01.wav", t = 53 / 30},
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_boltback_2ch_v1_01.wav", t = 83 / 30},
            {p = 100, s = "kraken/weapons/antimaterial/wpn_krabersniper_1p_reload_boltforward_2ch_v1_01.wav", t = 96 / 30}
    },
},
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_westar35.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "WESTAR-35"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The WESTAR-35 blaster pistol, also known as the MandalTech Jai'galaar model blaster, was a blaster pistol model manufactured by Concordian Crescent Technologies. They were commonly used by the Mandalorians of Death Watch during the Clone Wars and continued to see use by Mandalorians into the Imperial Era and beyond."
SWEP.Trivia_Manufacturer = "Theed Arms"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/westar35.png"

-- Base
SWEP.DefaultBodygroups = "002000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_westar35.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 25
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 192, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_orange"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 24

SWEP.Recoil = 0.8
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.8

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_WESTAR"
SWEP.ShootSound = "ArcCW_Kraken.SW_WESTAR"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 192, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.045, -11.296, 1.5),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2, -4),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0, -1.6, 3.3),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.6, -1.35, 1),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.5, -1.45, -6.8),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.45, -1.4, -4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_kraken_heavyproj_base.lua:
return gluapack()()
--PATH lua/weapons/arccw_sg6.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "SG-6"
SWEP.Trivia_Class = "CIS Shotgun Blaster"
SWEP.Trivia_Desc = "High tech CIS Shotgun Blaster"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.MirrorVMWM = false -- Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = false
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_sg6.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 27
SWEP.RangeMin = 16
SWEP.DamageMin = 14
SWEP.Range = 50
SWEP.Penetration = 1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 6

SWEP.Recoil = 1.5
SWEP.RecoilSide = 0.6
SWEP.RecoilPunch = 0.8
SWEP.RecoilRise = 1

SWEP.Delay = 90 / 240
SWEP.Num = 6
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 450 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/sg6.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -6, -0.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 70,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2, .8, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(2, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"sg6", "muzzle"}

SWEP.AttachmentElements = {
    ["sg6"] = {
        VMElements = {
            {
                Model = "models/arccw/swbf3/weapons/cisshotgun.mdl",
                Bone = "v_dlt19_reference001",
                Scale = Vector(1.2, 1.1, 1.2),
                Offset = {
                    pos = Vector(0.8, 0, 1.5),
                    ang = Angle(0, 89.5, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt19_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 4, 14),
                   ang = Angle(90, 0, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/swbf3/weapons/cisshotgun.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(200, 100, -100),
                    ang = Angle(-15, 180, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2100, 0, -600),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/swbf3/weapons/cisshotgun.mdl"
--SWEP.Attachments
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.13, -1.5, -3),
            vang = Angle(90, 0, -90),
            wpos = Vector(500, 75, -600),
            wang = Angle(-15, 0, 180)
        },
    }, 
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 9),
            vang = Angle(90, 0, -90),
            wpos = Vector(2000, 90, -530),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.1, 3.4, 3.4),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0.2, 2.5, 6),
            vmax = Vector(-0.2, 2.5, 12),
            wmin = Vector(1700, 70, -590), 
            wmax = Vector(1700, 70, -590)
        }, 
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        NoWM = true,
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.3, 2.05, 12),
            vang = Angle(90, 0, -90),
        },
    },             
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 2.1, 0),
            vang = Angle(90, 0, -70),
            wpos = Vector(900, 200, -400),
            wang = Angle(0 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_e11x.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_deadmansrevenge.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_deathwatchblaster.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Deathwatch Blaster"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "This blaster carbine was a popular blaster carbine manufactured by the Mandalorian arms giant Concordian Crescent Technologies. It was named after the galaar, a common bird of prey that was native to the planet Mandalore. It was a sleek, short-barreled rifle constructed from high-quality materials and was covered in shock-resistant polycarbonate. And while relatively rare, this blaster was a frequent item that appeared on the black market. Due to its high-quality design, the rifle became a popular weapon among bounty hunters and other professional killers. Its popularity allowed arms dealers to charge a premium for this weapon, with even used weapons going above their standard value.."
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/deathwatchblaster.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_deathwatch_blaster.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 30
SWEP.DamageMin = 26
SWEP.RangeMin = 0
SWEP.Range = 270
SWEP.Penetration = 4
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 26

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "kraken/sops/deathwatch.wav"
SWEP.ShootSound = "kraken/sops/deathwatch.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.744, -2.648, 2.5),
    Ang = Vector(2, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, 1, 20),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.03, -2.98, 3.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5,1.5,1.5),
        WMScale = Vector(1.5,1.5,1.5),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -1.25, 19.7),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.7, -1.3, 17),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -0.8, 12),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.2, 0.11, 4.4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.87, -1.15, 5.3),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_iondisruptor.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_jawapistol.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_scatterpistol.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_t702.lua:
return gluapack()()
--PATH addons/[misc] szachy/lua/weapons/chess_admin_tool.lua:
--Easy placement and saving for Chess boards
if SERVER then AddCSLuaFile() end

SWEP.Base = "weapon_base"

SWEP.Category = "Game boards"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Left click to place a board, right click to remove a board, reload for menu"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.Slot = 4
SWEP.PrintName = "Chess Admin Tool"

SWEP.ViewModelFOV = 80
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ViewModel = "models/weapons/c_toolgun.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 1

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "pistol"

SWEP.GameEntities = {
	{"Chess", "ent_chess_board", {["board"] = Model("models/props_phx/games/chess/board.mdl"), ["table"] = Model("models/props/de_tides/restaurant_table.mdl")}},
	{"Draughts/Checkers", "ent_draughts_board", {["board"] = Model("models/props_phx/games/chess/board.mdl"), ["table"] = Model("models/props/de_tides/restaurant_table.mdl")}},
}
function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "EntID" )
end

function SWEP:Initialize()
	self:SetEntID( 1 ) --Chess by default
end
function SWEP:PrimaryAttack()
	if SERVER and IsValid( self.Owner ) then
		if not self.Owner:IsAdmin() then
			self.Owner:ChatPrint( "You are not allowed to use this tool!" )
			self:Remove()
			return
		end
		local tr = self.Owner:GetEyeTrace()
		if tr.Hit and tr.HitPos then
			local ent = ents.Create( self.GameEntities[self:GetEntID()][2] )
			ent:SetPos( tr.HitPos )
			ent:Spawn()
		end
	end
end
function SWEP:SecondaryAttack()
	if SERVER and IsValid( self.Owner ) then
		if not self.Owner:IsAdmin() then
			self.Owner:ChatPrint( "You are not allowed to use this tool!" )
			self:Remove()
			return
		end
		
		local tr = self.Owner:GetEyeTrace()
		if IsValid(tr.Entity) and tr.Entity.IsChessEntity then tr.Entity:Remove() end
	end
end
function SWEP:Reload()
	if CLIENT then self:OpenMenu() end
end

function SWEP:OpenMenu()
	if SERVER then return end
	if IsValid(self.Menu) then self.Menu:Remove() end
	
	self.Menu = vgui.Create( "DFrame" )
	self.Menu:SetTitle( "Chess Admin Tool" )
	self.Menu:SetSize( 300, 80 )
	self.Menu:SetPos( ScrW()/2-150, ScrH()/2-50 )
	self.Menu:MakePopup()
	
	local drop = vgui.Create( "DComboBox", self.Menu )
	drop:Dock( TOP )
	drop:SetValue( "Select Board" )
	for i=1,#self.GameEntities do
		drop:AddChoice( self.GameEntities[i][1], i )
	end
	drop.OnSelect = function( s, ind, val, data )
		RunConsoleCommand( "chess_admin_toolent", tostring(data) )
	end
	
	local btnpnl =  vgui.Create( "DPanel", self.Menu )
	btnpnl:Dock( BOTTOM )
	btnpnl:SetTall( 20 )
	btnpnl.Paint = function() end
	
	local close = vgui.Create( "DButton", btnpnl )
	close:SetWidth( 98 )
	close:Dock( RIGHT )
	close:SetText( "Close" )
	close.DoClick = function(s) if IsValid(self) and IsValid(self.Menu) then self.Menu:Remove() end end
	
	local rem = vgui.Create( "DButton", btnpnl )
	rem:SetWidth( 98 )
	rem:Dock( LEFT )
	rem:SetText( "Remove tool" )
	rem.DoClick = function(s)
		RunConsoleCommand( "chess_admin_toolremove" )
		if IsValid(self) and IsValid(self.Menu) then self.Menu:Remove() end
	end
	
	local sv = vgui.Create( "DButton", btnpnl )
	sv:SetWidth( 98 )
	sv:Dock( FILL )
	sv:SetText( "Save boards" )
	sv.DoClick = function(s)
		RunConsoleCommand( "chess_save" )
	end
end

function SWEP:OnRemove()
	if CLIENT and self.Ghosts then
		for _,v in pairs(self.Ghosts) do if IsValid(v) then v:Remove() end end
	end
end
function SWEP:Holster()
	if CLIENT then
		if self.Ghosts then
			for _,v in pairs(self.Ghosts) do if IsValid(v) then v:Remove() end end
		end
		return true
	end
	return true
end

if SERVER then
	local function SetToolEnt( tool, index )
		if tool.GameEntities[index] then tool:SetEntID( index ) end
	end
	concommand.Add( "chess_admin_toolent", function(p,c,a)
		if IsValid(p:GetActiveWeapon()) and p:GetActiveWeapon():GetClass()=="chess_admin_tool" then
			SetToolEnt( p:GetActiveWeapon(), tonumber(a[1]) )
		end
	end)
	concommand.Add( "chess_admin_toolremove", function(p,c,a)
		if IsValid(p:GetActiveWeapon()) and p:GetActiveWeapon():GetClass()=="chess_admin_tool" then p:GetActiveWeapon():Remove() end
	end)
end

if CLIENT then
	surface.CreateFont( "ChessAdmin", {
		font="Arial", size=40,
	})
	local ColBox = Color(0,0,0,150)
	local ColText = Color(255,255,255,255)
	local ColGhost = Color(0,255,0,150)
	function SWEP:DrawHUD()
		local w,h = ScrW(), ScrH()
		local txt = "Board: ".. tostring( self.GameEntities[self:GetEntID()][1] )
		
		surface.SetFont( "ChessAdmin" )
		local tw, th = surface.GetTextSize( txt )
		
		surface.SetDrawColor( ColBox )
		surface.DrawRect( (w/2) - ((tw/2)+3), h - (th+6), tw+6, th+6 )
		
		draw.DrawText( txt, "ChessAdmin", w/2, h-(th)-3, ColText, TEXT_ALIGN_CENTER )
	end
	
	function SWEP:DoGhosts()
		local tr = self.Owner:GetEyeTrace()
		if (not tr.Hit) then return end
		
		self.Ghosts = self.Ghosts or {}
		local mdltbl = self.GameEntities[self:GetEntID()][3]
		if not mdltbl then return end
		
		self.Ghosts[1] = IsValid(self.Ghosts[1]) and self.Ghosts[1] or ClientsideModel( mdltbl.table, RENDERGROUP_BOTH )
		self.Ghosts[1]:SetPos( tr.HitPos )
		self.Ghosts[1]:SetRenderMode( RENDERMODE_TRANSALPHA )
		self.Ghosts[1]:SetColor( ColGhost )
		
		local h = 30 --(self.Ghosts[1]:OBBMaxs()[3] - self.Ghosts[1]:OBBMins()[3])
		self.Ghosts[2] = IsValid(self.Ghosts[2]) and self.Ghosts[2] or ClientsideModel( mdltbl.board, RENDERGROUP_BOTH )
		self.Ghosts[2]:SetPos( tr.HitPos+Vector(0,0,h or 50) )
		self.Ghosts[2]:SetAngles( Angle(-90,0,0) )
		self.Ghosts[2]:SetModelScale( 0.35, 0 )
		self.Ghosts[2]:SetRenderMode( RENDERMODE_TRANSALPHA )
		self.Ghosts[2]:SetColor( ColGhost )
		
		self.Ghosts[3] = IsValid(self.Ghosts[3]) and self.Ghosts[3] or ClientsideModel( "models/nova/chair_plastic01.mdl", RENDERGROUP_BOTH )
		self.Ghosts[3]:SetPos( tr.HitPos+ (self.Ghosts[2]:GetRight()*40) )
		self.Ghosts[3]:SetRenderMode( RENDERMODE_TRANSALPHA )
		self.Ghosts[3]:SetColor( ColGhost )
		
		self.Ghosts[4] = IsValid(self.Ghosts[4]) and self.Ghosts[4] or ClientsideModel( "models/nova/chair_plastic01.mdl", RENDERGROUP_BOTH )
		self.Ghosts[4]:SetPos( tr.HitPos+ (self.Ghosts[2]:GetRight()*-40) )
		self.Ghosts[4]:SetAngles( Angle(0,180,0) )
		self.Ghosts[4]:SetRenderMode( RENDERMODE_TRANSALPHA )
		self.Ghosts[4]:SetColor( ColGhost )
	end
	function SWEP:PostDrawViewModel()
		if LocalPlayer()~=self.Owner then return self.BaseClass.PostDrawViewModel( self ) end
		self:DoGhosts()
	end
	function SWEP:DrawWorldModel()
		if LocalPlayer()~=self.Owner then return self.BaseClass.DrawWorldModel( self ) end
		self:DrawModel()
		self:DoGhosts()
	end
end
--PATH lua/weapons/ce_bcr_config.lua:
return gluapack()()
--PATH lua/weapons/ce_bcr_config.lua:
AddCSLuaFile()


-- Per Person Setting

CreateClientConVar("bc2_ShowCloakCharge", 1, false, false, "")

-- Visual

CreateConVar("bc2_CloakType", "Transparent", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMode", "Timer", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakUntilVel", 75, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumVisibility", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMaterial", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeGainMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeLossMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge1", 10, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge2", 20, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge3", 30, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumNPCVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_UncloakInVehicle", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakOverlay", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumIDVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakFireMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountFire", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeFire", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakDamageMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountHurt", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeHurt", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOn", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOff", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleTime", 3, FCVAR_ARCHIVE, "")

-- Audio

CreateConVar("bc2_DistortSound", 14, FCVAR_ARCHIVE, "")
CreateConVar("bc2_EnableSound", "npc/sniper/reload1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_DisableSound", "AlyxEMP.Discharge", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ForceDisableSound", "npc/roller/mine/combine_mine_deactivate1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleFailureSound", "npc/roller/mine/combine_mine_deploy1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_FootstepVolume", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntSound", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntVolume", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntDelay", 4, FCVAR_ARCHIVE, "")

hook.Add( "PopulateToolMenu", "ce_bc2_configmenu", function()
	spawnmenu.AddToolMenuOption( "Utilities", "JustCrimson", "ce_bc2_config", "Better Cloaking Config", "", "", function( panel )
		panel:ClearControls()
		local CloakTypeBox = panel:ComboBox("Cloak Type", "bc2_CloakType")
		
		CloakTypeBox:AddChoice("Transparent")
		CloakTypeBox:AddChoice("Material")
		
		local CloakModeBox = panel:ComboBox("Cloak Mode", "bc2_CloakMode")
		CloakModeBox:AddChoice("Timer")
		CloakModeBox:AddChoice("Charge")

		panel:TextEntry("Movement Sensitivity", "bc2_CloakUntilVel"):SetNumeric(true)

		panel:TextEntry("Toggle Time", "bc2_ToggleTime"):SetNumeric(true)

		panel:NumSlider("Minimum Visibility", "bc2_MinimumVisibility", 0, 255, 0)

		panel:TextEntry("Cloak Material", "bc2_CloakMaterial")

		local SoundDistortBox = panel:ComboBox("Sound Distortion", "bc2_DistortSound")
		SoundDistortBox:AddChoice("None", 0)
		SoundDistortBox:AddChoice("Light", 14)
		SoundDistortBox:AddChoice("Medium", 15)
		SoundDistortBox:AddChoice("Heavy", 16)

		panel:TextEntry("Enable Sound", "bc2_EnableSound")
		panel:TextEntry("Disable Sound", "bc2_DisableSound")
		panel:TextEntry("Toggle Fail Sound", "bc2_ToggleFailureSound")
		panel:TextEntry("Force Disable Sound", "bc2_ForceDisableSound")


		panel:NumSlider("Visibility For NPC Target", "bc2_MinimumNPCVisibility", 0, 255, 0)
		panel:NumSlider("Visibility To Show ID", "bc2_MinimumIDVisibility", 0, 255, 0)

		panel:NumSlider("Footstep Volume", "bc2_FootstepVolume", 0, 1, 2)

		panel:CheckBox("Uncloak In Vehicle", "bc2_UncloakInVehicle")

		panel:TextEntry("Cloak Overlay", "bc2_CloakOverlay")

		local CloakShootMode = panel:ComboBox("Shooting While Cloaked Mode", "bc2_CloakFireMode")
		CloakShootMode:AddChoice("Disable Cloak", 1)
		CloakShootMode:AddChoice("Lose Charge", 2)
		CloakShootMode:AddChoice("Temp Disable", 3)
		CloakShootMode:AddChoice("Nothing", 4)

		panel:TextEntry("Shooting Lose Charge Amount", "bc2_LoseChargeAmountFire"):SetNumeric(true)
		panel:TextEntry("Shooting Temp Disable Time", "bc2_TempDisableTimeFire"):SetNumeric(true)

		panel:TextEntry("Cloak 1 Max Charge", "bc2_MaxCharge1"):SetNumeric(true)
		panel:TextEntry("Cloak 2 Max Charge", "bc2_MaxCharge2"):SetNumeric(true)
		panel:TextEntry("Cloak 3 Max Charge", "bc2_MaxCharge3"):SetNumeric(true)

		panel:TextEntry("Charge Gain Multiplier", "bc2_ChargeGainMultiplier"):SetNumeric(true)
		panel:TextEntry("Charge Loss Multiplier", "bc2_ChargeLossMultiplier"):SetNumeric(true)

		local CloakDamageMode = panel:ComboBox("Damaged While Cloaked Mode", "bc2_CloakDamageMode")
		CloakDamageMode:AddChoice("Disable Cloak", 1)
		CloakDamageMode:AddChoice("Lose Charge", 2)
		CloakDamageMode:AddChoice("Temp Disable", 3)
		CloakDamageMode:AddChoice("Nothing", 4)
		
		panel:TextEntry("Damaged Lose Charge Amount", "bc2_LoseChargeAmountHurt"):SetNumeric(true)
		panel:TextEntry("Damaged Temp Disable Time", "bc2_TempDisableTimeHurt"):SetNumeric(true)

		panel:TextEntry("Cloak Enable Effect", "bc2_CloakEffectOn")
		panel:TextEntry("Cloak Disable Effect", "bc2_CloakEffectOff")

		panel:TextEntry("Taunt Sound", "bc2_TauntSound")
		panel:NumSlider("Taunt Volume", "bc2_TauntVolume", 0, 1, 2)
		panel:TextEntry("Taunt Delay", "bc2_TauntDelay"):SetNumeric(true)

	end )
end )

cloakconfig = {}

-- Visual
cloakconfig["CloakType"] = GetConVar("bc2_CloakType"):GetString()
cloakconfig["CloakMode"] = GetConVar("bc2_CloakMode"):GetString()
cloakconfig["CloakUntilVel"] = GetConVar("bc2_CloakUntilVel"):GetInt()
cloakconfig["MinimumVisibility"] = GetConVar("bc2_MinimumVisibility"):GetInt()
cloakconfig["CloakMaterial"] = GetConVar("bc2_CloakMaterial"):GetString()
cloakconfig["ChargeGainMultiplier"] = GetConVar("bc2_ChargeGainMultiplier"):GetFloat()
cloakconfig["ChargeLossMultiplier"] = GetConVar("bc2_ChargeLossMultiplier"):GetFloat()
cloakconfig["MaxCharge0"] = 0
cloakconfig["MaxCharge1"] = GetConVar("bc2_MaxCharge1"):GetInt()
cloakconfig["MaxCharge2"] = GetConVar("bc2_MaxCharge2"):GetInt()
cloakconfig["MaxCharge3"] = GetConVar("bc2_MaxCharge3"):GetInt()
cloakconfig["MinimumNPCVisibility"] = GetConVar("bc2_MinimumNPCVisibility"):GetInt()
cloakconfig["UncloakInVehicle"] = GetConVar("bc2_UncloakInVehicle"):GetBool()
cloakconfig["CloakOverlay"] = GetConVar("bc2_CloakOverlay"):GetString()
cloakconfig["MinimumIDVisibility"] = GetConVar("bc2_MinimumIDVisibility"):GetInt()
cloakconfig["CloakFireMode"] = GetConVar("bc2_CloakFireMode"):GetInt()
cloakconfig["LoseChargeAmountFire"] = GetConVar("bc2_LoseChargeAmountFire"):GetFloat()
cloakconfig["TempDisableTimeFire"] = GetConVar("bc2_TempDisableTimeFire"):GetFloat()
cloakconfig["CloakDamageMode"] = GetConVar("bc2_CloakDamageMode"):GetInt()
cloakconfig["LoseChargeAmountHurt"] = GetConVar("bc2_LoseChargeAmountHurt"):GetFloat()
cloakconfig["TempDisableTimeHurt"] = GetConVar("bc2_TempDisableTimeHurt"):GetFloat()
cloakconfig["CloakEffectOn"] = GetConVar("bc2_CloakEffectOn"):GetString()
cloakconfig["CloakEffectOff"] = GetConVar("bc2_CloakEffectOff"):GetString()
cloakconfig["ToggleTime"] = GetConVar("bc2_ToggleTime"):GetFloat()
-- Audio
cloakconfig["DistortSound"] = GetConVar("bc2_DistortSound"):GetInt()
cloakconfig["EnableSound"] = GetConVar("bc2_EnableSound"):GetString()
cloakconfig["DisableSound"] = GetConVar("bc2_DisableSound"):GetString()
cloakconfig["ForceDisableSound"] = GetConVar("bc2_ForceDisableSound"):GetString()
cloakconfig["ToggleFailureSound"] = GetConVar("bc2_ToggleFailureSound"):GetString()
cloakconfig["FootstepVolume"] = GetConVar("bc2_FootstepVolume"):GetFloat()
cloakconfig["TauntSound"] = GetConVar("bc2_TauntSound"):GetString()
cloakconfig["TauntVolume"] = GetConVar("bc2_TauntVolume"):GetFloat()
cloakconfig["TauntDelay"] = GetConVar("bc2_TauntDelay"):GetFloat()




for k,v in pairs(cloakconfig) do
    cvars.AddChangeCallback(k, function(convarName, oldValue, newValue) 

            tableCV[convarName] = newValue


    end)
end
--PATH lua/weapons/cloaking-3/shared.lua:
AddCSLuaFile()
include("weapons/ce_bcr_config.lua")



//----------------------------------
// SWEP Info
//----------------------------------
SWEP.Author                 =   "Temporary Solutions"
SWEP.PrintName              =   "Cloaking - " .. cloakconfig.MaxCharge3 .. " Seconds"
SWEP.Base                   =   "weapon_base"
SWEP.Instructions           =   [[Left-Click: Toggle Cloak
Right-Click: N/A]]
SWEP.Spawnable              =   true
SWEP.AdminSpawnable         =   true
SWEP.AdminOnly 				= 	false
//----------------------------------
// SWEP Models
//----------------------------------
SWEP.ViewModelFlip          =   false
SWEP.UseHands               =   false
SWEP.ViewModel              =   "models/weapons/v_hands.mdl"
SWEP.WorldModel             =   ""
SWEP.HoldType               =   "normal"
//----------------------------------
// SWEP Slot Properties
//----------------------------------
SWEP.AutoSwitchTo           =   true
SWEP.AutoSwithFrom          =   true
SWEP.Slot                   =   5
SWEP.SlotPos                =   123
//----------------------------------
// SWEP Weapon Properties
//----------------------------------
SWEP.DrawAmmo               =   false
SWEP.DrawCrosshair          =   false
SWEP.m_WeaponDeploySpeed 	= 	100
SWEP.OnRemove = onDeathDropRemove
SWEP.OnDrop = onDeathDropRemove

SWEP.Primary.ClipSize       =   0
SWEP.Primary.DefaultClip    =   0
SWEP.Primary.Ammo           =   "none"
SWEP.Primary.Automatic      =   false
 
SWEP.Secondary.ClipSize     =   -1
SWEP.Secondary.DefaultClip  =   -1
SWEP.Secondary.Ammo         =   "none"
SWEP.Secondary.Automatic    =   false

--[[
	Hey me, don't forget if you're going to copy paste this for the other 3 sweps you need to:
	Change cloakconfig.MaxCharge3
	Edit SWEP:Equip, The Timers, and HudDraw
	And change ce_bc2_3
]]--

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)

    sound.Add({
	name = "CloakTauntSound",
	channel = CHAN_STATIC,
	volume = cloakconfig.TauntVolume,
	level = 70,
	pitch = { 95, 100 },
	sound = cloakconfig.TauntSound})
end


local function Cloak(ply)
	local plyVelocity = ply:GetVelocity()
    local plyWeapon = ply:GetActiveWeapon()
    local col = ply:GetColor()
    ply:SetNWBool("HideHUD", true)

    local untilVelAlpha = math.max(0, plyVelocity:Length() - cloakconfig.CloakUntilVel) 	-- Keeps player completly cloaked until they meet a set velocity.
    local approachAlpha = math.Approach(col.a, untilVelAlpha, 500 * FrameTime()) 	-- Gradually get to the alpha (Instead of snapping to it).
    approachAlpha = math.max(approachAlpha, cloakconfig.MinimumVisibility) 	-- If the alpha is being set below the set minimum, just use the minimum.

    --[[
    	This is a fix for most weapons not going invisible unless the
    	alpha is 0. I don't think I can fix this as
    	it probably has to do with the weapon's models or textures.
    --]]
    local wepAlpha = 0
    
    if untilVelAlpha >= 70 then
    	wepAlpha = untilVelAlpha
   	else
   		wepAlpha = 0
   	end

   	if cloakconfig.CloakEffectOn ~= "" then
   		local effectpos = ply:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin(effectpos)
		effectdata:SetNormal(Vector(0, 0, 0))
		util.Effect(cloakconfig.CloakEffectOn, effectdata)
	end


	ply:RemoveAllDecals()
	ply:DrawShadow(false)
	ply:SetDSP(cloakconfig.DistortSound)

	if cloakconfig.CloakType == "Transparent" then
		ply:SetRenderMode(RENDERMODE_TRANSALPHA)
		ply:SetColor(Color(255, 255, 255, approachAlpha))
		plyWeapon:SetRenderMode(RENDERMODE_TRANSALPHA)
		plyWeapon:SetColor(Color(255, 255, 255, wepAlpha))
	elseif cloakconfig.CloakType == "Material" then
		ply:SetMaterial(cloakconfig.CloakMaterial, true)
		plyWeapon:SetMaterial(cloakconfig.CloakMaterial, true)
	end

	if SERVER then
		if approachAlpha < cloakconfig.MinimumNPCVisibility then
			ply:SetNoTarget(true)
		else
			ply:SetNoTarget(false)
		end
	end
end



local function Uncloak(ply, forced, debug, holdcharge)
	--print(debug)
	if forced and cloakconfig.ForceDisableSound ~= "" and ply.CloakActive then
		ply:EmitSound(cloakconfig.ForceDisableSound)
		--print("3 1")
	elseif cloakconfig.DisableSound ~= ""  and debug ~= "Equip" and ply.CloakActive then
		ply:EmitSound(cloakconfig.DisableSound)
		--print("3 2")
	end
	ply:SetNWBool("HideHUD", false)
	ply.CloakActive = false
	ply:SetDSP(0)
    ply:DrawShadow(true)
    ply:SetRenderMode(RENDERMODE_NORMAL)
    ply:SetColor(Color(255, 255, 255, 255))
    ply:SetMaterial("")

    if SERVER then
    	ply:SetNoTarget(false)
    end

    if not holdcharge then
   		ply:SetNWFloat("CloakCharge", cloakconfig.MaxCharge3)
   	end

    timer.Simple(cloakconfig.ToggleTime, function()
		ply.AllowedToggle = true
	end)

    if cloakconfig.CloakEffectOff != "" then
   		local effectpos = ply:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin(effectpos)
		effectdata:SetNormal(Vector(0, 0, 0))
		util.Effect(cloakconfig.CloakEffectOff, effectdata)
	end

    for k, v in pairs(ply:GetWeapons()) do 	-- Uncloaks previously cloaked weapons
    	if IsValid(v) then
    		v:SetRenderMode(RENDERMODE_NORMAL)
   	 		v:SetColor(Color(255, 255, 255, 255))
   	 	end
   	end
end



local DontSpam = 0
function SWEP:PrimaryAttack()
	local ply = self:GetOwner()

	if ply.CloakActive == nil then
		ply.CloakActive = false
	elseif ply.AllowedToggle == nil then
		ply.AllowedToggle = true
	end

	if DontSpam < CurTime() then
		if SERVER then
			if not ply.CloakActive and ply.AllowedToggle then
				ply.CloakActive = true
				ply.AllowedToggle = false
				if cloakconfig.EnableSound != "" then
   					ply:EmitSound(cloakconfig.EnableSound)
   				end
			elseif ply.CloakActive then
				if cloakconfig.CloakMode == "Charge" then
					Uncloak(ply, false, "Primary", true)
				else
					Uncloak(ply, false, "Primary")
				end
			else
				if cloakconfig.ToggleFailureSound != "" then
				ply:EmitSound(cloakconfig.ToggleFailureSound)
				end
			end
		end
		DontSpam = CurTime() + 0.5
	end
end



function SWEP:CanSecondaryAttack()	
	return false
end



function SWEP:Reload()
	ply = self:GetOwner()
	if (self.nextreload or 0) <= CurTime() and cloakconfig.TauntSound != "" then
    	self.nextreload = CurTime() + cloakconfig.TauntDelay
		ply:EmitSound("CloakTauntSound")
	end
end



function SWEP:Deploy()
	self.Owner:DrawViewModel(false)
end



function SWEP:Equip()
	local ply = self.Owner

	--(Removes Other Cloaks)--
	if ply:HasWeapon("cloaking-1") then
		ply:StripWeapon("cloaking-1")
	elseif ply:HasWeapon("cloaking-2") then
		ply:StripWeapon("cloaking-2")
	elseif ply:HasWeapon("cloaking-infinite") then
		ply:StripWeapon("cloaking-infinite")
	end

	Uncloak(ply, false, "Equip")

	if cloakconfig.CloakMode == "Rechage" then
		self.Owner.CloakCharge = cloakconfig.MaxCharge3
	end
end



hook.Add("PlayerPostThink", "ce_bc2_3_ThinkHook", function(ply)
	if ply.CloakActive then
		Cloak(ply)
	end

	if not ply.LastCharge then
		ply.LastCharge = CurTime()
	end

	if SERVER and ply:HasWeapon("cloaking-3") then
		if cloakconfig.CloakMode == "Charge" and cloakconfig.MaxCharge3 != 0 then
			if ply.LastCharge + (1 * cloakconfig.ChargeLossMultiplier) <= CurTime() and ply:GetNWFloat("CloakCharge") > 0 and ply.CloakActive then 	-- Depletes Charge
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") - 1)
				ply.LastCharge = CurTime()
			elseif ply.LastCharge + (1 * cloakconfig.ChargeGainMultiplier) <= CurTime() and ply:GetNWFloat("CloakCharge") < cloakconfig.MaxCharge3 and !ply.CloakActive and !ply.CloakPause then 	-- Adds Charge
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") + 1)
				ply.LastCharge = CurTime()
			elseif ply.CloakActive and ply:GetNWFloat("CloakCharge") == 0 then	-- Uncloaks when out of charge
				Uncloak(ply, true, "Charge", true)
			end
		end
	end

	-- Its like charge, without the recharge
	if ply:HasWeapon("cloaking-3") then
		if cloakconfig.CloakMode == "Timer" and cloakconfig.MaxCharge3 != 0 then
			if ply.LastCharge + 1 <= CurTime() and ply:GetNWFloat("CloakCharge") > 0 and ply.CloakActive then
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") - 1)
				ply.LastCharge = CurTime()
			elseif ply.CloakActive and ply:GetNWFloat("CloakCharge") == 0 then
				Uncloak(ply, true, "Timer")
				ply:SetNWFloat("CloakCharge", cloakconfig.MaxCharge3)
			end
		end
	end
		-- Copy pasted as an attempted bugfix for some weapons being a pain in the ass
	local plyVelocity = ply:GetVelocity()
    local plyWeapon = ply:GetActiveWeapon()
    local col = ply:GetColor()

    local untilVelAlpha = math.max(0, plyVelocity:Length() - cloakconfig.CloakUntilVel) 	-- Keeps player completly cloaked until they meet a set velocity.
    local approachAlpha = math.Approach(col.a, untilVelAlpha, 500 * FrameTime()) 	-- Gradually get to the alpha (Instead of snapping to it).
    approachAlpha = math.max(approachAlpha, cloakconfig.MinimumVisibility) 	-- If the alpha is being set below the set minimum, just use the minimum.

    --[[
    	This is a fix for most weapons not going invisible unless the
    	alpha is 0. I don't think I can fix this as
    	it probably has to do with the weapon's models or textures.
    --]]
    local wepAlpha = 0
    
    if untilVelAlpha >= 70 then
    	wepAlpha = untilVelAlpha
   	else
   		wepAlpha = 0
   	end

   	if cloakconfig.CloakType == "Transparent" and ply.CloakActive then
		plyWeapon:SetRenderMode(RENDERMODE_TRANSALPHA)
		plyWeapon:SetColor(Color(255, 255, 255, wepAlpha))
	elseif cloakconfig.CloakType == "Material" and ply.CloakActive then
		plyWeapon:SetMaterial(cloakconfig.CloakMaterial, true)
	end
end)



hook.Add("EntityFireBullets", "ce_bc2_3_UncloakOnFire", function(ent, bullet)
	if IsValid(ent) and ent:IsPlayer() and ent.CloakActive then
		if cloakconfig.CloakFireMode == 1 then
			Uncloak(ent, true, "Fired")
		elseif cloakconfig.CloakFireMode == 2 then
			if cloakconfig.CloakMode == "Charge" then
				ent:SetNWFloat("CloakCharge", ent:GetNWFloat("CloakCharge") - cloakconfig.LoseChargeAmountFire)
			elseif cloakconfig.CloakMode == "Timer" then
				print("Yeah you probably shouldn't set a charge option if you're using the timer mode.\nDefaulting to Option 1")
				GetConVar("bc2_CloakFireMode"):SetInt(1)
				Uncloak(ent, true, "Fired2")
			end
		elseif cloakconfig.CloakFireMode == 3 and ent:Alive() then
			Uncloak(ent, true, "Fired3", true)
			ent.AllowedToggle = false
			ent.CloakPause = true
			timer.Simple(cloakconfig.TempDisableTimeFire, function()
				if IsValid(ent) and not ent.DidSomethingStupid then
					ent.CloakActive = true
				end
			ent.AllowedToggle = true
			ent.DidSomethingStupid = false
			ent.CloakPause = false
			end)
		end
	end
end)



hook.Add("EntityTakeDamage", "ce_bc2_3_UncloakOnDamage", function(ent, dmginfo)
	if IsValid(ent) and ent:IsPlayer() and ent.CloakActive then
		if cloakconfig.CloakDamageMode == 1 then
			Uncloak(ent, true, "Damage")
		elseif cloakconfig.CloakDamageMode == 2 then
			if cloakconfig.CloakMode == "Charge" then
				ent:SetNWFloat("CloakCharge", ent:GetNWFloat("CloakCharge") - cloakconfig.LoseChargeAmountHurt)
			elseif cloakconfig.CloakMode == "Timer" then
				print("Yeah you probably shouldn't set a charge option if you're using the timer mode.\nDefaulting to Option 1")
				GetConVar("bc2_CloakDamageMode"):SetInt(1)
				Uncloak(ent, true, "Damage2")
			end
		elseif cloakconfig.CloakDamageMode == 3 and ent:Alive() then
			Uncloak(ent, true, "Damage3", true)
			ent.AllowedToggle = false
			ent.CloakPause = true
			timer.Simple(cloakconfig.TempDisableTimeHurt, function()
				if IsValid(ent) and not ent.DidSomethingStupid then
					ent.CloakActive = true
				end
			ent.AllowedToggle = true
			ent.DidSomethingStupid = false
			ent.CloakPause = false
			end)
		end
	end
end)



hook.Add("PlayerFootstep", "ce_bc2_3_SilentSteps", function(ply, pos, foot, sound, volume, rf)
    if ply.CloakActive then
    	ply:EmitSound(sound, 20, nil, cloakconfig.FootstepVolume, 4)
   		return true
	else
    	return false
 	end
end)



hook.Add("HUDDrawTargetID", "ce_bc2_3_HidePlayerID", function()
	if CLIENT then
    	local gplytr = util.GetPlayerTrace(LocalPlayer())
    	local ent = util.TraceLine(gplytr).Entity
    	local col = 255
    	if IsValid(ent) then
    		col = ent:GetColor()
    	end

    	if ent:IsPlayer() and IsValid(ent) then
    		if cloakconfig.CloakType == "Transparent" and ent.CloakActive and col.a < cloakconfig.MinimumIDVisibility then
        		return false
        	elseif cloakconfig.CloakType == "Material" and ent.CloakActive then
           		return false
           	else
           		return
        	end
        end
	end
end)



hook.Add("HUDPaint", "ce_bc2_1_DrawThings", function()
	local ply = LocalPlayer()
	if IsValid(ply) and ply:Alive() and IsValid(ply:GetActiveWeapon()) then

		local activeweapon = ply:GetActiveWeapon():GetClass()

		if ply.CloakActive and cloakconfig.CloakOverlay ~= "" then
			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetMaterial(Material(cloakconfig.CloakOverlay))
			surface.DrawTexturedRect( 0, 0, ScrW(), ScrH())
		end

		if ply:HasWeapon("cloaking-3") and GetConVar("bc2_ShowCloakCharge"):GetBool() and (activeweapon == "cloaking-3" or ply:GetNWFloat("CloakCharge") != cloakconfig.MaxCharge3) and cloakconfig.MaxCharge3 != 0 then
			draw.SimpleText(ply:GetNWFloat("CloakCharge"), "DermaLarge", ScrW()/2 - 25, 900, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
	end
end)




hook.Add("HUDShouldDraw", "DarkRP_HideDarkPlayerID", function(hudName)
    if hudName ~= "DarkRP_EntityDisplay" then return end

    local playersToDraw = {}
    for _,ply in pairs(player.GetAll()) do
        if IsValid(ply) and not ply:GetNWBool("HideHUD") then
            table.insert(playersToDraw, ply)
        end
    end
    return true, playersToDraw
end)



hook.Add("PlayerEnteredVehicle", "ce_bc2_3_UncloakEnteringVehicle", function(ply, veh, seat)
	if ply.CloakActive and cloakconfig.UncloakInVehicle then
		Uncloak(ply, false, "Vehicle")
	end
end)


-- Accidents
local function onDemote(source, demoted, reason)
	if demoted.CloakActive then
	Uncloak(demoted, false, "Demoted")
	demoted.DidSomethingStupid = true
	end
end

local function UncloakOnAccident(ply)
	Uncloak(ply, false, "Accident")
	ply.DidSomethingStupid = true
end

hook.Add("PlayerDeath", "ce_bc2_3_Death" , UncloakOnAccident)
hook.Add("playerAFKDemoted", "ce_bc2_3_AFK" , UncloakOnAccident)
hook.Add("onPlayerDemoted", "ce_bc2_3_Demoted" , onDemote)
hook.Add("playerArrested", "ce_bc2_3_Arrested" , UncloakOnAccident)
hook.Add("playerStarved", "ce_bc2_3_Starved" , UncloakOnAccident)
hook.Add("OnPlayerChangedTeam", "ce_bc2_3_ChangedTeam" , UncloakOnAccident)
--PATH lua/weapons/gmod_tool/stools/heart_turbolaser_tool.lua:
TOOL.Category = "Heart";
TOOL.Name = "Heart Turbolaser Tool";
TOOL.Command = nil;
TOOL.ConfigName	= "";
TOOL.AdminOnly = true;

if CLIENT then
	language.Add( "tool.heart_turbolaser_tool.name", "Heart Turbolaser Tool" );
	language.Add( "Tool.heart_turbolaser_tool.desc", "Shoot turbolasers." );
	language.Add( "Tool.heart_turbolaser_tool.left", "Shoot a turbolaser from the sky to where you are aiming.");
	language.Add( "Tool.heart_turbolaser_tool.right", "Shoot a turbolaser from the toolgun.");
	language.Add( "Tool.heart_turbolaser_tool.reload", "Creates a turbolaser spawner at your location.");
end

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload"}
}

// turbolaser options
TOOL.ClientConVar["speed"] = 1000;
TOOL.ClientConVar["damage"] = 1000;
TOOL.ClientConVar["radius"] = 150;
TOOL.ClientConVar["scale"] = 1.0;

TOOL.ClientConVar["r"] = 255;
TOOL.ClientConVar["g"] = 0;
TOOL.ClientConVar["b"] = 0;

// spawner options
TOOL.ClientConVar["shots"] = 3;
TOOL.ClientConVar["delay"] = 0.5;
TOOL.ClientConVar["spread"] = 0;

local defaultCV = TOOL:BuildConVarList();

function TOOL:VerifyValues()
	local speed = self:GetClientNumber("speed");
	local damage = self:GetClientNumber("damage");
	local radius = self:GetClientNumber("radius");
	local scale = self:GetClientNumber("scale");

	local shots = self:GetClientNumber("shots");
	local delay = self:GetClientNumber("delay");
	local spread = self:GetClientNumber("spread");

	local r = self:GetClientNumber("r");
	local g = self:GetClientNumber("g");
	local b = self:GetClientNumber("b");

	if speed <= 0 then return false end
	if damage < 0 then return false end
	if radius < 0 then return false end
	if scale < 0 then return false end

	if shots <= 0 then return false end
	if delay < 0 then return false end
	if spread < 0 then return false end

	if r < 0 || r > 255 then return false end
	if g < 0 || g > 255 then return false end
	if b < 0 || b > 255 then return false end

	return true;
end

// summon turbolaser function
function TOOL:Turbolaser()
	if CLIENT then return end

	if not self:VerifyValues() then return end

	local speed = self:GetClientNumber("speed");
	local damage = self:GetClientNumber("damage");
	local radius = self:GetClientNumber("radius");
	local scale = self:GetClientNumber("scale");

	local r = self:GetClientNumber("r");
	local g = self:GetClientNumber("g");
	local b = self:GetClientNumber("b");

	local laser = ents.Create("heart_turbolaser");
	laser:SetVar("speed", speed);
	laser:SetVar("damage", damage);
	laser:SetVar("radius", radius);

	laser:SetVar("scale", scale);
	laser:SetVar("r", r);
	laser:SetVar("g", g);
	laser:SetVar("b", b);

	return true, laser;
end

// shoot from sky
function TOOL:LeftClick(trace)
	if CLIENT then return end

	local spawned, laser = self:Turbolaser();

	if not spawned then return end

	local ply = self:GetOwner();

	laser:SetOwner(ply);
	laser:SetPos(trace.HitPos + Vector(0,0,5000));
	laser:SetAngles(Angle(90,0,0));

	laser:Spawn();
	laser:Activate();

	undo.Create("Turbolaser");
	undo.AddEntity(laser);
	undo.SetPlayer(ply);
	undo.SetCustomUndoText("Undone Turbolaser");
	undo.Finish();

	return false;
end

// shoot from face
function TOOL:RightClick()
	if CLIENT then return end

	local spawned, laser = self:Turbolaser();

	if not spawned then return end

	local ply = self:GetOwner();

	laser:SetOwner(ply);
	laser:SetPos(ply:GetShootPos());
	laser:SetAngles(ply:GetAngles());

	laser:Spawn();
	laser:Activate();

	undo.Create("Turbolaser");
	undo.AddEntity(laser);
	undo.SetPlayer(ply);
	undo.SetCustomUndoText("Undone Turbolaser");
	undo.Finish();

	return false;
end

// spawner from face
function TOOL:Reload()
	if CLIENT then return end;

	if not self:VerifyValues() then return end

	local ply = self:GetOwner();

	local speed = self:GetClientNumber("speed");
	local damage = self:GetClientNumber("damage");
	local radius = self:GetClientNumber("radius");
	local scale = self:GetClientNumber("scale");

	local shots = self:GetClientNumber("shots");
	local delay = self:GetClientNumber("delay");
	local spread = self:GetClientNumber("spread");

	local r = self:GetClientNumber("r");
	local g = self:GetClientNumber("g");
	local b = self:GetClientNumber("b");

	local spawner = ents.Create("heart_turbolaser_spawner");

	spawner:SetOwner(ply);
	spawner:SetPos(self:GetOwner():GetShootPos());
	spawner:SetAngles(self:GetOwner():GetAngles());

	spawner:SetVar("speed", speed);
	spawner:SetVar("damage", damage);
	spawner:SetVar("radius", radius);

	spawner:SetVar("shots", shots);
	spawner:SetVar("delay", delay);
	spawner:SetVar("spread", spread);

	spawner:SetVar("scale", scale);
	spawner:SetVar("r", r);
	spawner:SetVar("g", g);
	spawner:SetVar("b", b);

	spawner:Spawn();
	spawner:Activate();

	undo.Create("Spawner");
	undo.AddEntity(spawner);
	undo.SetPlayer(ply);
	undo.SetCustomUndoText("Undone Turbolaser Spawner");
	undo.Finish();

	print("undo ready")
end

function TOOL.BuildCPanel(panel)
	panel:SetName("Heart Turbolaser Tool")

	local header = vgui.Create("DImage");
	header:SetImage("materials/heart/turbolaser_header.png");
	header:SetSize(305, 140);
	panel:AddItem(header);

	panel:Help("Version 1.0")

	panel:AddControl( "ComboBox", { MenuButton = 1, Folder = "heart_turbolaser", Options = { [ "#preset.default" ] = defaultCV }, CVars = table.GetKeys( defaultCV ) } );

	panel:ControlHelp("");

	local divider1 = vgui.Create("DImage");
	divider1:SetImage("materials/heart/turbolaser_divider1.png");
	divider1:SetSize(305, 16);
	panel:AddItem(divider1);

	panel:NumSlider("Speed","heart_turbolaser_tool_speed","1","10000","0");
	panel:ControlHelp("Sets the speed of the turbolaser.");

	panel:NumSlider("Damage","heart_turbolaser_tool_damage","0","10000","0");
	panel:ControlHelp("Sets the damage of the turbolaser explosion.");

	panel:NumSlider("Explosion Radius","heart_turbolaser_tool_radius","10","1000","0");
	panel:ControlHelp("Sets the radius of the turbolasers explosion.");

	panel:NumSlider("Scale","heart_turbolaser_tool_scale","0.1","2","2");
	panel:ControlHelp("Sets the scale of the turbolaser model.");

	local colourLabel = vgui.Create("DLabel");
	colourLabel:SetText("Colour");
	colourLabel:SetColor(Color(0,0,0));
	panel:AddItem(colourLabel);

	panel:ColorPicker("", "heart_turbolaser_tool_r", "heart_turbolaser_tool_g", "heart_turbolaser_tool_b");

	panel:ControlHelp("");
	panel:ControlHelp("Sets the colour of the turbolaser.");

	panel:ControlHelp("");

	local divider2 = vgui.Create("DImage");
	divider2:SetImage("materials/heart/turbolaser_divider2.png");
	divider2:SetSize(305, 16);
	panel:AddItem(divider2);

	panel:NumSlider("Number of Shots","heart_turbolaser_tool_shots","1","10000","0");
	panel:ControlHelp("Sets the number of shots for the turbolaser spawner.");

	panel:NumSlider("Delay between Shots","heart_turbolaser_tool_delay","0.1","5","1");
	panel:ControlHelp("Sets the delay between shots for the turbolaser spawner. (In seconds)");

	panel:NumSlider("Spread","heart_turbolaser_tool_spread","0","10","1");
	panel:ControlHelp("Sets the spread of the turbolasers spawned from the turbolaser spawner.");

	panel:ControlHelp("");
end
--PATH lua/weapons/gmod_tool/stools/imagetool.lua:
--[[
         AsterionStaff 2022.
        This script was created from the developers of the AsterionTeam.
        You can get more information from one of the links below:
            Site - https://asterion.games
            Discord - https://discord.gg/CtfS8r5W3M
        
        developer(s):
            Selenter - https://steamcommunity.com/id/selenter

         Chop your own wood and it will warm you twice.
]]--


AddCSLuaFile()

TOOL.Name = "Image Tool" -- 
TOOL.Category = "Asterion Tools" -- 
TOOL.Information = { --  
    {name = "left", stage = 0},
    {name = "right", stage = 0},
}

--  
TOOL.ClientConVar.url = "https://i.imgur.com/4vyQ6Hl.png"
TOOL.ClientConVar.width = 100
TOOL.ClientConVar.height = 100
TOOL.ClientConVar.scale = 40
TOOL.ClientConVar.brightness = 255
TOOL.ClientConVar.alpha = 255

--  
if CLIENT then
    language.Add("tool.imagetool.name", "Image Tool")
    language.Add("tool.imagetool.desc", "Allows you to create pictures in the world")
    language.Add("tool.imagetool.left", "With the left mouse button you can create a picture.")
    language.Add("tool.imagetool.right", "With the right mouse button you can delete the picture next to.")
end

--   
function TOOL:LeftClick()
    if CLIENT then return true end

    local client = self:GetOwner()

    --     
    local data = ImageTool:GetToolData(client)
    if !data then return end

    ImageTool:AddImage(data)
    
    --   predicted !!! (   net-, ..        )
    net.Start("image.SaveImage")
        net.WriteString(data.url)
    net.Send(client)

    return true
end

--   
function TOOL:RightClick(trace)
    if CLIENT then return true end

    local client = self:GetOwner()

    --     
    local data = ImageTool:GetToolData(client)
    if !data then return end

    ImageTool:RemoveImage(data)

    return true
end

-- C 
function TOOL.BuildCPanel(CPanel)
    CPanel:AddControl("Header",{
        Description = "This Tool will help you put the pictures you need on your map. In the field with the URL, indicate the link to the picture, then you can put it in the world."
    })

    CPanel:AddControl("TextBox", {
        Label = " URL Link to picture",
        Command = "imagetool_url"
    })

    local URLDesc = vgui.Create("DLabel")
    URLDesc:SetText("In this field you must specify the URL of the image you want to put in the world.")
    URLDesc:SetWrap(true)
    URLDesc:SetAutoStretchVertical(true)
    URLDesc:SetTextColor(Color(10,149,255))
    CPanel:AddPanel(URLDesc)

    local NoticePanel = vgui.Create("DLabel")
    NoticePanel:SetText("If your picture is not loaded, then we recommend using IMGUR to publish pictures.")
    NoticePanel:SetWrap(true)
    NoticePanel:SetAutoStretchVertical(true)
    NoticePanel:SetTextColor(Color(255,10,10,255))
    CPanel:AddPanel(NoticePanel)

    CPanel:AddControl("Slider", {
        Label = "Image Width:",
        Command = "imagetool_width",
        Min = 0,
        Max = 10000
    })

    local WidthDesc = vgui.Create("DLabel")
    WidthDesc:SetText("In this slider, you can specify the size of the picture you need in width.")
    WidthDesc:SetWrap(true)
    WidthDesc:SetAutoStretchVertical(true)
    WidthDesc:SetTextColor(Color(10,149,255))
    CPanel:AddPanel(WidthDesc)

    CPanel:AddControl("Slider", {
        Label = "Image Height:",
        Command = "imagetool_height",
        Min = 0,
        Max = 10000
    })

    local HeightDesc = vgui.Create("DLabel")
    HeightDesc:SetText("In this slider, you can specify the size of the picture you need in height.")
    HeightDesc:SetWrap(true)
    HeightDesc:SetAutoStretchVertical(true)
    HeightDesc:SetTextColor(Color(10,149,255))
    CPanel:AddPanel(HeightDesc)

    CPanel:AddControl("Slider", {
        Label = "Image Scale:",
        Command = "imagetool_scale",
        Min = 0,
        Max = 100
    })

    local ScaleDesc = vgui.Create("DLabel")
    ScaleDesc:SetText("In this slider, you can resize the picture in height and width at the same time.")
    ScaleDesc:SetWrap(true)
    ScaleDesc:SetAutoStretchVertical(true)
    ScaleDesc:SetTextColor(Color(10,149,255))
    CPanel:AddPanel(ScaleDesc)

    CPanel:AddControl("Slider", {
        Label = "Image Brightness:",
        Command = "imagetool_brightness",
        Min = 0,
        Max = 255
    })

    local BrightnessDesc = vgui.Create("DLabel")
    BrightnessDesc:SetText("In this slider, you can change the brightness of the picture, it is very suitable if you need to place the picture in a dark place.")
    BrightnessDesc:SetWrap(true)
    BrightnessDesc:SetAutoStretchVertical(true)
    BrightnessDesc:SetTextColor(Color(10,149,255))
    CPanel:AddPanel(BrightnessDesc)

    CPanel:AddControl("Slider", {
        Label = "Image Alpha:",
        Command = "imagetool_alpha",
        Min = 0,
        Max = 255
    })

    local AlphaDesc = vgui.Create("DLabel")
    AlphaDesc:SetText("This slider allows you to change the transparency of your images.")
    AlphaDesc:SetWrap(true)
    AlphaDesc:SetAutoStretchVertical(true)
    AlphaDesc:SetTextColor(Color(10,149,255))
    CPanel:AddPanel(AlphaDesc)

    local ImageSize = vgui.Create("DButton")
    ImageSize:SetText("Set the size settings as in the picture")
    ImageSize.DoClick = function()
        local l = "imagetool_"

        local data = ImageTool:GetToolData(LocalPlayer())
        if !data then return end

        local uniqueID = util.CRC(data.url)

        local material = ImageTool.cacheMaterials[uniqueID]
        if material then
            local width = material:Width()
            local height = material:Height()

            RunConsoleCommand(l .. "width", width)
            RunConsoleCommand(l .. "height", height)
        end
    end
    CPanel:AddPanel(ImageSize)

    local ResetButton = vgui.Create("DButton")
    ResetButton:SetText("Restore default settings")
    ResetButton.DoClick = function()
        local l = "imagetool_"

        RunConsoleCommand(l .. "url", "https://i.imgur.com/4vyQ6Hl.png")
        RunConsoleCommand(l .. "width", 100)
        RunConsoleCommand(l .. "height", 100)
        RunConsoleCommand(l .. "scale", 40)
        RunConsoleCommand(l .. "brightness", 255)
    end
    CPanel:AddPanel(ResetButton)

    CPanel:AddControl("Header",{
        Description = "Your image history:"
    })

    local historyPanel = vgui.Create("DScrollPanel")
    historyPanel:SetTall(300)
    historyPanel.Paint = function(_, w, h)
        surface.SetDrawColor(0, 0, 0)
        surface.DrawOutlinedRect(0, 0, w, h)
    end
    CPanel:AddPanel(historyPanel)

    ImageTool.historyPanel = historyPanel
    ImageTool:LoadingHistory()
end
--PATH gamemodes/sandbox/entities/weapons/gmod_tool/stools/lvsaienabler.lua:
return gluapack()()
--PATH gamemodes/sandbox/entities/weapons/gmod_tool/stools/lvsturret.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/republic_conquest.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/gmod_tool/stools/shareprops.lua:
TOOL.Category           = "Falco Prop Protection"
TOOL.Name               = "Share props"
TOOL.Command            = nil
TOOL.ConfigName         = ""

function TOOL:RightClick(trace)
    local ent = trace.Entity
    if not IsValid(ent) or CLIENT then return true end

    ent.SharePhysgun1 = nil
    ent.ShareGravgun1 = nil
    ent.SharePlayerUse1 = nil
    ent.ShareEntityDamage1 = nil
    ent.ShareToolgun1 = nil

    ent.AllowedPlayers = nil
    return true
end

function TOOL:LeftClick(trace)
    local ent = trace.Entity
    if not IsValid(ent) or CLIENT then return true end

    local ply = self:GetOwner()

    local Physgun = ent.SharePhysgun1 or false
    local GravGun = ent.ShareGravgun1 or false
    local PlayerUse = ent.SharePlayerUse1 or false
    local Damage = ent.ShareEntityDamage1 or false
    local Toolgun = ent.ShareToolgun1 or false

    -- This big usermessage will be too big if you select 63 players, since that will not happen I can't be arsed to solve it
    umsg.Start("FPP_ShareSettings", ply)
        umsg.Entity(ent)
        umsg.Bool(Physgun)
        umsg.Bool(GravGun)
        umsg.Bool(PlayerUse)
        umsg.Bool(Damage)
        umsg.Bool(Toolgun)
        if ent.AllowedPlayers then
            umsg.Long(#ent.AllowedPlayers)
            for k,v in pairs(ent.AllowedPlayers) do
                umsg.Entity(v)
            end
        end
    umsg.End()
    return true
end

if CLIENT then
    language.Add("Tool.shareprops.name", "Share tool")
    language.Add("Tool.shareprops.desc", "Change sharing settings per prop")
    language.Add("Tool.shareprops.0", "Left click: shares a prop. Right click unshares a prop")
end

--PATH lua/weapons/gmod_tool/stools/vjstool_npcequipment.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/vjstool_npcfollower.lua:
return gluapack()()
--PATH lua/weapons/jet_mk5.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Model Jetpack"
SWEP.Category	= "Star Wars Jetpacks"
SWEP.Purpose    = "LMB - Equip/Unequip\n\nSPACE - Fly up\n\nCTRL - Fly down\n\nSHIFT - Hover"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Fuel" )
	if ( SERVER ) then
		self:SetFuel(100)
	end
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end



function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if IsValid(ex) then
		ex:Remove()
		ply:SetNWEntity('Jetted',NULL)
		ply.LastJetExecuted = CurTime()
	else
		if !ply:IsOnGround() then return end
		if (ply.LastJetExecuted or 0)+1 >= CurTime() then return end
		local jp = ents.Create('mk5')
		jp:SetSlotName('mk5')
		jp:Spawn()
		jp:Attach(ply)
		ply.Jetted = jp
		ply:SetNWEntity('Jetted',jp)
	end
	ply:EmitSound('buttons/button14.wav')
end

local skinint = 1

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if !IsValid(ex) then return end
	skinint = (skinint + 1)%3
	ex:SetSkin(skinint)
	ply:EmitSound('buttons/button16.wav')
end

function SWEP:Deploy()
	return true
end

function SWEP:Equip()

end

function SWEP:ShouldDropOnDie() return false end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_cgshield.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_cr2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "CR-2"
SWEP.Trivia_Class = "Heavy-Blaster Pistol"
SWEP.Trivia_Desc = "The CR-2 heavy blaster pistol was a heavy blaster pistol manufactured by Corellian Arms that was utilized by the Royal Naboo Security Forces. Small and agile, it had an extreme rate of fire and shoot ionized bolts. It also could be configured with night vision scopes or have an extended stock for reduced recoil."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/cr2.png"

-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_cr2.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_cr2.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-11.4, 5, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.2,
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.NoHideLeftHandInCustomization = true

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.8,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 1.1,
    [HITGROUP_RIGHTARM] = 1.1,
}

SWEP.Damage = 37
SWEP.RangeMin = 197
SWEP.DamageMin = 24
SWEP.Range = 480
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 413
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55
SWEP.Recoil = 0.23
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.11
SWEP.Delay = 60 / 427
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}
SWEP.AccuracyMOA = 0.59
SWEP.HipDispersion = 447
SWEP.MoveDispersion = 54

-- Speed Mult
SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.FirstShootSound = "armas/disparos/cr-2/blasters_cr2_laser_close_var_07.mp3"
SWEP.ShootSound = "armas/disparos/cr-2/blasters_cr2_laser_close_var_08.mp3"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_green"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.152, -5.928, 2.367),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods
-- Attachments
SWEP.AttachmentElements = {
    ["cr2_barrel_extended"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(-0.45, 0.7, 13.4),
            },
        }
    },
    ["cr2_stock"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
}

SWEP.Attachments = {
    [1] = {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        Bone = "cr2",
        Offset = {
            vpos = Vector(-0.45, -1.7, -1),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },     
    [2] = {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "cr2",
        Offset = {
            vpos = Vector(-0.45, 0.7, 11.4),
            vang = Angle(90, 0, -90),

        },
    },       
    [3] = {
        PrintName = "Barrel",
        DefaultAttName = "None",
        Slot = "cr2_barrel",
    },   
    [4] = {
        PrintName = "Stock",
        DefaultAttName = "None",
        Slot = "cr2_stock",
    },  
    [5] = {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    [6] = {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms",
        DefaultAttName = "None",
        VMScale = Vector(0.7, 0.7, 0.7),
        Slot = {"charm"},
        Bone = "cr2",
        Offset = {
            vpos = Vector(0, -1.4, 3.3),
            vang = Angle(90, 0, -90),
        },
    },    
    [9] = {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "cr2",
        Offset = {
            vpos = Vector(0.7, -0.7, -1),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "Fire"
    },
    ["fire_iron"] = {
        Source = "Neutral"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a_modular.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a_train.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15le.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15le"
SWEP.Trivia_Class = "Heavy Long Range Battle-Rifle"
SWEP.Trivia_Desc = "The DC-15le blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15le.png"


-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc15a.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-13, 6, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.NoHideLeftHandInCustomization = true
SWEP.DefaultBodygroups = "000000011"

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.3,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 221
SWEP.DamageMin = 27
SWEP.Range = 573
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 427
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55
SWEP.Recoil = 0.23
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.11
SWEP.Delay = 60 / 327
SWEP.Num = 1

SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.59
SWEP.HipDispersion = 447
SWEP.MoveDispersion = 54

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/dc15le.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.987, -9.924, 0.939),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true
SWEP.BipodDispersion = 1 
SWEP.BipodRecoil = 1

-- Attachments
SWEP.Attachments = {         
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Bone = "dc-15a",
        Slot = {"dc15a_magazine_75"},
        Offset = {
            vpos = Vector(-0.7, -0.6, 2.5),
            vang = Angle(0, 0, 0),
        },
    },         
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    }, 
    {
        PrintName = "Grenade Launcher",
        DefaultAttName = "None",
        Slot = {"rep_ubgl"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.675),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.7),
            vang = Angle(90, 0, 0),
        },
    },      
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 30.675),
            vang = Angle(90, 0, 0),
        },
    },  
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.83, 10.273),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s_grenadier.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s_modular.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Modular DC-15s"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s_modular.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/c_dc15s_modular.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dc15s_modular.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-11, 4.3, -3.4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 198
SWEP.DamageMin = 21
SWEP.Range = 399
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 255

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.2 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.157, -6.7, 1.56),
    Ang = Angle(0, 0, 0),
     Magnification = 1.6,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.AttachmentElements = {
    ["15s_barrel"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        NameChange = "Sniper DC-15s",
        AttPosMods = {
            [6] = {
                vpos = Vector(-.1, 0.1, 24.6),
            },
        }
    },
    ["15s_mag_ext"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["15s_mag_a280"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["15s_mag_drum"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
    ["15s_stock_extended"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },
    ["15s_stock_skeleton"] = {
        VMBodygroups = {{ind = 6, bg = 2}},
    },
    ["15s_ironsight"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
}
SWEP.Attachments = {
    [1] = {   
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15s",
        InstalledEles = {"15s_ironsight"},
        Offset = {
            vpos = Vector(-0.2, -0.7, 2.4),
            vang = Angle(90, 0, -90),
        },
    },    
    [2] = {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15s",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.1, 0, 7),
        vmax = Vector(-0.1, 0, 10),
        },          
    },
    [3] = {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15s",
        Slot = {"stock", "15s_stock"},
        Offset = {
            vpos = Vector(-0.2, 1.3, -6.6),
            vang = Angle(0, 0, -90),
        },
    }, 
    [4] = {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15s", 
        Offset = {
            vpos = Vector(0.4, 0, 11),
            vang = Angle(90, 0, 0),
        },
    },
    [5] = {
        PrintName = "Barrel",
        DefaultAttName = "None",
        Slot = {"15s_barrel"},
        Bone = "DC15s",
    },   
    [6] = {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"15s_barrel", "muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15s",
        Offset = {
            vpos = Vector(-.1, 0.1, 13.7),
            vang = Angle(90, 0, -90),
        },
    },    
    [7] = {
        PrintName = "Magazine",
        DefaultAttName = "Standard",
        Slot = {"15s_mag"},
    },
    [8] = {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    [9] = {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    [10] = {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    [11] = {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15s",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.55, 1.5, 2.6),
            vang = Angle(90, 0, -90),
        },
    },     
    [12] = {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15s",
        Offset = {
            vpos = Vector(0.65, 0.35, -3),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17m.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17m"
SWEP.Trivia_Class = "Modular Blaster Rifle"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17m_new.png"

SWEP.Slot = 3

SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/c_dc17m.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dc17m.mdl"
SWEP.ViewModelFOV = 53
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-5, 9, -6),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Damage = 39
SWEP.RangeMin = 276
SWEP.DamageMin = 23
SWEP.Range = 523
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 900

SWEP.BodyDamageMults =  {
     [HITGROUP_HEAD] = 2.3,
     [HITGROUP_CHEST] = 1.2,
     [HITGROUP_LEFTARM] = 1,
     [HITGROUP_RIGHTARM] = 1,
}

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 10
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 75
SWEP.ExtendedClipSize = 150
SWEP.ReducedClipSize = 25

SWEP.MaxRecoilBlowback = 1
SWEP.VisualRecoilMult = 1
SWEP.Recoil = 0.98
SWEP.RecoilSide = 0.13
SWEP.RecoilRise = 0.67
SWEP.RecoilPunch = 1

SWEP.Delay = 60 / 426
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
        PrintName = "FULLAUTO-PLASMA",
    },
    {
		Mode = 1,
        PrintName = "SINGLE-PLASMA",
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 125 
SWEP.SightsDispersion = 0 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 1.1
SWEP.SightedSpeedMult = 0.77
SWEP.ShootSpeedMult = 1

-- Ironsight & Properties
SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 150
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc17m/dc17m_fire0.wav"
SWEP.FirstShootSound = "armas/disparos/dc17m/dc17m_fire3.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc17m/dc17m_fire_silenced.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-8.389, 0, 0.689),
    Ang = Angle(1.332, -1.168, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-3, 3, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(0, 3, -4)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(3.5, -0.1, 4.8),
            vang = Angle(0, 0, 0),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(9, -1.5, 2.7),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(14.5, 0, 3.5),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0, -1.4, 2.4),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-2, -1.3, 3.4),
            vang = Angle(0, 0, 20),
        },
    },
}

SWEP.Animations = {
    ["enter_inspect"]= {
        Source = "pose",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_pose.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "melee", 
        SoundTable = {
            {s = "armas/disparos/dc17m/melee0.wav", t = 0.1 },
        },
    },
    ["fire"] = {
        Source = "fire"
    },
    ["idle_iron"] = {
        Source = false
    },
    ["idle_sight"] = {
        Source = false
    },
    ["fire_iron"] = {
        Source = false
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_unholster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_sniper_unholster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "armas/disparos/dc17m/dc17m_reload.wav", t = 0.1 }, --s sound file
        },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17m_launcher.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/med_kit/shared.lua:
return gluapack()()
--PATH lua/weapons/mortar_range_finder/shared.lua:
return gluapack()()
--PATH lua/weapons/mortar_range_finder/shared.lua:
AddCSLuaFile()

SWEP.PrintName = "Rangefinder"
SWEP.Base = "weapon_base"

SWEP.Author = "DolUnity"
SWEP.Purpose = "Get the Target Distance"
SWEP.Category = "DolUnity"
SWEP.Spawnable = true
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.WorldModel = "models/maxofs2d/camera.mdl"
SWEP.HoldType = "camera"
SWEP.UseHands = true
SWEP.DrawAmmo = false

SWEP.Slot = 4

SWEP.Primary.ClipSize = 0
SWEP.Primary.DefaultClipSize = 0

SWEP.Secondary.ClipSize = 0
SWEP.Secondary.DefaultClipSize = 0

if (CLIENT) then
    SWEP.PreviewModel = ClientsideModel("models/dolunity/starwars/mortar.mdl")
    SWEP.PreviewModel:SetNoDraw(true)
    SWEP.PreviewModel:SetMaterial("models/wireframe")
end

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)
end

function SWEP:PrimaryAttack() end

function SWEP:SecondaryAttack()
    if (not IsFirstTimePredicted()) then return end

    if (self.Zoom) then
        self.Owner:SetFOV(self.OldFOV, 0.5)
        self.Zoom = false
    else
        self.Zoom = true
        self.OldFOV = self.Owner:GetFOV()
        self.Owner:SetFOV(20, 0.5)
    end
end

function SWEP:ShouldDrawViewModel()
    return false
end

function SWEP:AdjustMouseSensitivity()
    if (self.Owner:GetFOV() == 20) then
        return 0.05
    end
    return 1
end

function SWEP:Deploy()
    self:SetHoldType(self.HoldType)
end

local laserPointer = Material("Sprites/light_glow02_add_noz")
hook.Add("PostDrawTranslucentRenderables", "swmRangeFinderLaser", function()
    if (LocalPlayer():Alive() and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "mortar_range_finder" and not LocalPlayer():InVehicle()) then
        local trace = LocalPlayer():GetEyeTrace()
        render.SetMaterial(laserPointer)
        render.DrawQuadEasy(trace.HitPos + trace.HitNormal, trace.HitNormal, 32, 32, Color(255,0,0),0)
    end
end)

local rangeTable = Material("models/dolunity/starwars/mortar_scale.png")
hook.Add("HUDPaint", "swmRangeFinderDistanceHUD", function ()
    if (LocalPlayer():Alive() and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "mortar_range_finder" and not LocalPlayer():InVehicle()) then
        local trace = LocalPlayer():GetEyeTrace()
        local dist = LocalPlayer():GetPos():Distance(trace.HitPos)

        surface.SetFont("swmFont")
        surface.SetTextColor(75, 255, 255)
        local mText = math.Round(dist / 40, 1) .. "m"
        local mWidth, mHeight = surface.GetTextSize(mText)
        surface.SetTextPos((ScrW() - mWidth) / 2, ScrH() / 2 + ScrH() * 0.03)
        surface.DrawText(mText)

        local rText = math.Round(math.abs((LocalPlayer():GetAngles().y + 360) % 360 - 360),2)
        local rWidth, rHeight = surface.GetTextSize(rText)
        surface.SetTextPos((ScrW() - rWidth) / 2, ScrH() / 2 + ScrH() * 0.03 + rHeight * 1.1)
        surface.DrawText(rText .. "")

        surface.SetDrawColor(255,255,255)
        surface.SetMaterial(rangeTable)
        local height = ScrH() * 0.462
        local width = height * 0.6
        surface.DrawTexturedRect(ScrW() * 0.02, (ScrH() - height) / 2, width, height)
    end
end)
--PATH addons/[bronie] perfect-hands/lua/weapons/mvp_perfecthands.lua:
local P = mvp.package.Get("perfecthands")

if (SERVER) then
    AddCSLuaFile()
end

SWEP.PrintName = "Perfect Hands"
SWEP.Author = "Kot @ Multiverse Project"
SWEP.Purpose = "Hands for players who want to look good while playing."
SWEP.Spawnable = true

SWEP.Category = "MVP - Perfect Hands"

SWEP.ViewModel = "models/weapons/c_arms_citizen.mdl"
SWEP.WorldModel = ""

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawCrosshair = false

function SWEP:Initialize()
    self.PrintName = mvp.q.Lang("phands.name")
    self:SetHoldType("normal")

    self.interactionRange = mvp.config.Get("phands.interactionRange", 100)
end

function SWEP:Think()
    if (self.dragging and not self:GetOwner():KeyDown(IN_ATTACK)) then
        self.dragging = nil
    end

    self.ownerPos = self:GetOwner():GetShootPos()
    self.ownerAng = self:GetOwner():GetAimVector()
end

function SWEP:TraceEntity()
    if (not self.ownerPos or not self.ownerAng) then
        return {}
    end

    local tr = util.TraceLine({
        start = self.ownerPos,
        endpos = self.ownerPos + self.ownerAng * self.interactionRange,
        filter = self:GetOwner()
    })

    return tr
end

function SWEP:CanDragEntity(ent)

    return  (IsValid(ent)) and
            (not ent:IsPlayer()) and
            (not ent:IsNPC()) and
            (not ent:IsWeapon()) and
            (not ent:IsVehicle()) and
            (ent.CanDrag ~= false) and
            (ent:GetMoveType() == MOVETYPE_VPHYSICS)
end

function SWEP:IsEntRagdoll(ent)
    return ent:GetClass() == "prop_ragdoll" or scripted_ents.IsBasedOn(ent:GetClass(), "prop_ragdoll")
end

local maxVolume = math.pow(10, 5.85)
function SWEP:DragEntity()
    if (not self.dragging) then
        return
    end

    if (not IsValid(self.dragging.ent)) then
        self.dragging = nil

        return
    end

    local physObject = self.dragging.ent:GetPhysicsObject()
    if (not IsValid(physObject)) then
        self.dragging = nil

        return
    end

    if (physObject:GetVolume() > maxVolume) then
        self.dragging = nil

        return
    end

    local pos = self.ownerPos + self.ownerAng * self.dragging.fraction * self.interactionRange
    local offset = self.dragging.ent:LocalToWorld(self.dragging.offset)

    local applyPos = pos - offset
    local applyForce = (applyPos:GetNormal() * math.min(1, applyPos:Length() / 100) * 500 - physObject:GetVelocity()) * (physObject:GetMass() / mvp.config.Get("phands.interactionWeightMultiplier"))

    if (self:IsEntRagdoll(self.dragging.ent)) then
        physObject:ApplyForceCenter(applyForce)
        -- physObject:AddAngleVelocity( -physObject:GetAngleVelocity() * 0.25)
    else
        physObject:ApplyForceOffset(applyForce, offset)
        physObject:AddAngleVelocity( -physObject:GetAngleVelocity() * 0.25)
    end
end

function SWEP:PrimaryAttack()
    if (not mvp.config.Get("phands.useInteractions", true)) then
        return
    end

    if (not self.dragging) then
        local tr = self:TraceEntity()

        if (IsValid(tr.Entity) and self:CanDragEntity(tr.Entity)) then
            self.dragging = {
                ent = tr.Entity,
                offset = self:IsEntRagdoll(tr.Entity) and tr.Entity:OBBCenter() or tr.Entity:WorldToLocal(tr.HitPos),
                fraction = tr.Fraction
            }
        end
    end

    if (CLIENT) then
        return
    end

    if (self.dragging) then
        self:DragEntity()
    end
end

function SWEP:SecondaryAttack()
    if (SERVER) then
        if (self:GetOwner().mvp_phands_animation_playing) then
            net.Start("mvp.phands.stopAnimation")
                net.WriteEntity(self:GetOwner())
            net.Broadcast()
            self:GetOwner().mvp_phands_animation_playing = false
        end

        return
    end

    if (not mvp.config.Get("phands.useAnimations", true)) then
        return
    end

    if (not IsFirstTimePredicted()) then
        return
    end

    if (self:GetOwner().mvp_phands_animation_playing) then
        return 
    end

    local animationsList = P.animations.listSeq
    local animationMenu = mvp.meta.radialMenu:New()

    local shouldUseIcons = mvp.config.Get("phands.useIcons", false)
    local shouldUseModels = mvp.config.Get("phands.useModels", true)
    local theme = P.themes.Get(mvp.config.Get("phands.iconsTheme"))

    for k, v in ipairs(animationsList) do
        local canUse, _, overlayIcon = hook.Run("mvp.phands.CanUseAnimation", self:GetOwner(), v)
        if (canUse == nil) then
            canUse = true
        end

        local animationBonesData = P.animations.Get(v)

        local icon = (shouldUseIcons and theme) and {
            [1] = theme[v] or nil, -- icon
            [3] = false -- isModel
        } or nil

        if (shouldUseModels) then
            icon = {
                [1] = LocalPlayer():GetModel(), -- model
                [2] = nil, -- overlayIcon
                [3] = true, -- isModel
                [4] = function(ent) -- entityLayoutFunc
                    ent:SetModel(LocalPlayer():GetModel())
                    ent:SetSkin(LocalPlayer():GetSkin())
                    ent:SetMaterial(LocalPlayer():GetMaterial())

                    for i = 0, LocalPlayer():GetNumBodyGroups() - 1 do
                        ent:SetBodygroup(i, LocalPlayer():GetBodygroup(i))
                    end

                    for bone, angle in pairs(animationBonesData) do
                        local boneIndex = ent:LookupBone(bone)
                        if (boneIndex) then
                            ent:ManipulateBoneAngles(boneIndex, angle)
                        end
                    end
                end
            }
        end

        if (not canUse) then
            icon = icon or {}
            icon[2] = overlayIcon or Material("mvp/perfecthands/lock.png", "smooth")
        end
        
        animationMenu:AddOption(mvp.q.Lang("phands.animation." .. v), mvp.q.Lang("phands.animation." .. v .. ".description"), icon, canUse and mvp.colors.Accent or mvp.colors.Red, function()
            net.Start("mvp.phands.requestAnimation")
                net.WriteString(v)
            net.SendToServer()
        end)
    end

    animationMenu:Open()
end

if (CLIENT) then
    local w, h = ScrW, ScrH
    local dragIcon = Material("mvp/perfecthands/drag.png", "smooth")

    function SWEP:DrawHUD()
        if (IsValid(self:GetOwner():GetVehicle())) then
            return
        end

        if (mvp.config.Get("phands.useAnimations", true)) then
            local hintPosX = w() * .5
            local hintPosY = h() - mvp.config.Get("phands.hintMargin", 100)

            local pulseFactor = math.abs(math.sin(CurTime() * 0.5))
            local textColor = ColorAlpha(mvp.colors.Text, 255 * pulseFactor)
            
            local rmbMouse = string.upper(input.LookupBinding("+attack2") or "RMB")
            local rmbMouseTranslation = mvp.q.LangFallback("phands.mouse_buttons." .. rmbMouse, rmbMouse)
            local text = mvp.q.Lang("phands.hint.rmb", rmbMouseTranslation)

            if (self:GetOwner().mvp_phands_animation_playing) then
                local useButton = string.upper(input.LookupBinding("+use") or "E")
                text = mvp.q.Lang("phands.hint.rmb.stop", rmbMouseTranslation, useButton)
            end

            local _, th = mvp.utils.DrawTextWithButtons(text, mvp.q.Font(24, 500), hintPosX, hintPosY, textColor, TEXT_ALIGN_CENTER)

            if (self:GetOwner().mvp_phands_animation_playing and mvp.config.Get("phands.animationAllowFreelook", true)) then
                local reloadButton = string.upper(input.LookupBinding("+reload") or "R")
                
                mvp.utils.DrawTextWithButtons(mvp.q.Lang("phands.hint.freelook", reloadButton), mvp.q.Font(24, 500), hintPosX, hintPosY + th + 2, textColor, TEXT_ALIGN_CENTER)
            end
        end

        if (mvp.config.Get("phands.useInteractions", true)) then
            local tr = self:TraceEntity()

            if ((IsValid(tr.Entity) and self:CanDragEntity(tr.Entity)) or (istable(self.dragging) and IsValid(self.dragging.ent))) then
                local originW, originH = w() * .5, h() * .5
                local iconSize = mvp.ui.Scale(48)

                surface.SetDrawColor(mvp.colors.Text)
                -- surface.DrawRect(originW - iconSize * .5, originH - iconSize * .5, iconSize, iconSize)
                surface.SetMaterial(dragIcon)
                surface.DrawTexturedRect(originW - iconSize * .5, originH - iconSize * .5, iconSize, iconSize)

                originH = originH + iconSize * .5 + 15

                local lmbMouse = string.upper(input.LookupBinding("+attack") or "LMB")
                local lmbMouseTranslation = mvp.q.LangFallback("phands.mouse_buttons." .. lmbMouse, lmbMouse)
                local text = mvp.q.Lang("phands.hint.drag", lmbMouseTranslation)

                mvp.utils.DrawTextWithButtons(text, mvp.q.Font(24, 500), originW, originH, mvp.colors.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            if (istable(self.dragging) and IsValid(self.dragging.ent)) then
                local offset = self.dragging.ent:LocalToWorld(self.dragging.offset):ToScreen()

                surface.SetDrawColor(mvp.colors.Text)
                surface.DrawLine(offset.x, offset.y, w() * .5, h() * .5)

                draw.RoundedBox(4, offset.x - 4, offset.y - 4, 8, 8, mvp.colors.Text)
            end
        end
    end
end


--PATH lua/weapons/tfa_bash_base.lua:
if SERVER then
	AddCSLuaFile()
end

DEFINE_BASECLASS("tfa_gun_base")
SWEP.Secondary.BashDamage = 25
SWEP.Secondary.BashSound = Sound("TFA.Bash")
SWEP.Secondary.BashHitSound = Sound("TFA.BashWall")
SWEP.Secondary.BashHitSound_Flesh = Sound("TFA.BashFlesh")
SWEP.Secondary.BashLength = 54
SWEP.Secondary.BashDelay = 0.2
SWEP.Secondary.BashDamageType = DMG_SLASH
SWEP.Secondary.BashEnd = nil --Override bash sequence length easier
SWEP.Secondary.BashInterrupt = false --Do you need to be in a "ready" status to bash?
SWEP.BashBase = true

function SWEP:BashForce(ent, force, pos, now)
	if not IsValid(ent) or not ent.GetPhysicsObjectNum then return end

	if now then
		if ent.GetRagdollEntity then
			ent = ent:GetRagdollEntity() or ent
		end

		local phys = ent:GetPhysicsObjectNum(0)

		if IsValid(phys) then
			if ent:IsPlayer() or ent:IsNPC() then
				ent:SetVelocity( force * 0.1)
				phys:SetVelocity(phys:GetVelocity() + force * 0.1)
			else
				phys:ApplyForceOffset(force, pos)
			end
		end
	else
		timer.Simple(0, function()
			if IsValid(self) and self:OwnerIsValid() and IsValid(ent) then
				self:BashForce(ent, force, pos, true)
			end
		end)
	end
end

local cv_doordestruction = GetConVar("sv_tfa_melee_doordestruction")

function SWEP:HandleDoor(slashtrace)
	if CLIENT or not IsValid(slashtrace.Entity) then return end

	if not cv_doordestruction:GetBool() then return end

	if slashtrace.Entity:GetClass() == "func_door_rotating" or slashtrace.Entity:GetClass() == "prop_door_rotating" then
		slashtrace.Entity:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(80, 120))

		local newname = "TFABash" .. self:EntIndex()
		self.PreBashName = self:GetName()
		self:SetName(newname)

		slashtrace.Entity:SetKeyValue("Speed", "500")
		slashtrace.Entity:SetKeyValue("Open Direction", "Both directions")
		slashtrace.Entity:SetKeyValue("opendir", "0")
		slashtrace.Entity:Fire("unlock", "", .01)
		slashtrace.Entity:Fire("openawayfrom", newname, .01)

		timer.Simple(0.02, function()
			if not IsValid(self) or self:GetName() ~= newname then return end

			self:SetName(self.PreBashName)
		end)

		timer.Simple(0.3, function()
			if IsValid(slashtrace.Entity) then
				slashtrace.Entity:SetKeyValue("Speed", "100")
			end
		end)
	end
end

local l_CT = CurTime
local sp = game.SinglePlayer()

function SWEP:AltAttack()
	local time = l_CT()

	if
		self:GetStatL("Secondary.CanBash") == false or
		not self:OwnerIsValid() or
		time < self:GetNextSecondaryFire()
	then return end

	local stat = self:GetStatus()
	if not TFA.Enum.ReadyStatus[stat] and not self:GetStatL("Secondary.BashInterrupt") or
		stat == TFA.Enum.STATUS_BASHING and self:GetStatL("Secondary.BashInterrupt") then return end

	if self:IsSafety() or self:GetHolding() then return end

	local retVal = hook.Run("TFA_CanBash", self)
	if retVal == false then return end

	local enabled, tanim, ttype = self:ChooseBashAnim()
	if not enabled then return end

	hook.Run("TFA_Bash", self)

	if self:GetOwner().Vox and IsFirstTimePredicted() then
		self:GetOwner():Vox("bash", 0)
	end

	self:BashAnim()
	if sp and SERVER then self:CallOnClient("BashAnim", "") end

	local bashend = self:GetStatL("Secondary.BashEnd")
	local nextTime = time + (bashend or self:GetActivityLength(tanim, false, ttype))

	self:SetNextPrimaryFire(nextTime)
	self:SetNextSecondaryFire(nextTime)

	self:EmitSoundNet(self:GetStatL("Secondary.BashSound"))

	self:ScheduleStatus(TFA.Enum.STATUS_BASHING, self:GetStatL("Secondary.BashDelay"))

	hook.Run("TFA_PostBash", self)
end

function SWEP:BashAnim()
	if not IsFirstTimePredicted() then return end
	local ht = self.DefaultHoldType or self.HoldType
	local altanim = false

	if ht == "ar2" or ht == "shotgun" or ht == "crossbow" or ht == "physgun" then
		altanim = true
	end

	self:GetOwner():AnimRestartGesture(0, altanim and ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND or ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE2, true)
end

local ttime = -1

function SWEP:HandleBashAttack()
	local ply = self:GetOwner()
	local pos = ply:GetShootPos()
	local av = ply:GetAimVector()

	local slash = {}
	slash.start = pos
	slash.endpos = pos + (av * self:GetStatL("Secondary.BashLength"))
	slash.filter = ply
	slash.mins = Vector(-10, -5, 0)
	slash.maxs = Vector(10, 5, 5)
	local slashtrace = util.TraceHull(slash)

	local pain = self:GetStatL("Secondary.BashDamage")

	if not slashtrace.Hit then return end
	self:HandleDoor(slashtrace)

	if not (sp and CLIENT) then
		self:EmitSound(
			(slashtrace.MatType == MAT_FLESH or slashtrace.MatType == MAT_ALIENFLESH) and
			self:GetStatL("Secondary.BashHitSound_Flesh") or
			self:GetStatL("Secondary.BashHitSound"))
	end

	if CLIENT then return end

	local dmg = DamageInfo()
	dmg:SetAttacker(ply)
	dmg:SetInflictor(self)
	dmg:SetDamagePosition(pos)
	dmg:SetDamageForce(av * pain)
	dmg:SetDamage(pain)
	dmg:SetDamageType(self:GetStatL("Secondary.BashDamageType"))

	if IsValid(slashtrace.Entity) and slashtrace.Entity.TakeDamageInfo then
		slashtrace.Entity:TakeDamageInfo(dmg)
	end

	local ent = slashtrace.Entity
	if not IsValid(ent) or not ent.GetPhysicsObject then return end

	local phys

	if ent:IsRagdoll() then
		phys = ent:GetPhysicsObjectNum(slashtrace.PhysicsBone or 0)
	else
		phys = ent:GetPhysicsObject()
	end

	if IsValid(phys) then
		if ent:IsPlayer() or ent:IsNPC() then
			ent:SetVelocity(av * self:GetStatL("Secondary.BashDamage") * 0.5)
			phys:SetVelocity(phys:GetVelocity() + av * self:GetStatL("Secondary.BashDamage") * 0.5)
		else
			phys:ApplyForceOffset(av * self:GetStatL("Secondary.BashDamage") * 0.5, slashtrace.HitPos)
		end
	end
end

function SWEP:Think2(...)
	if self:GetStatus() == TFA.Enum.STATUS_BASHING and self:GetStatusEnd() < l_CT() then
		self:SetStatus(TFA.Enum.STATUS_BASHING_WAIT, self:GetNextSecondaryFire())

		if IsFirstTimePredicted() then
			self:HandleBashAttack()
		end
	end

	BaseClass.Think2(self, ...)
end

function SWEP:SecondaryAttack()
	if not self:GetStatL("Secondary.IronSightsEnabled", false) then
		self:AltAttack()
		return
	end

	BaseClass.SecondaryAttack(self)
end

function SWEP:GetBashing()
	local stat = self:GetStatus()

	if not self:VMIV() then
		return stat == TFA.Enum.STATUS_BASHING or stat == TFA.Enum.STATUS_BASHING_WAIT
	end

	return (stat == TFA.Enum.STATUS_BASHING or stat == TFA.Enum.STATUS_BASHING_WAIT) and self.OwnerViewModel:GetCycle() > 0 and self.OwnerViewModel:GetCycle() < 0.65
end

function SWEP:GetBashingStrict()
	local stat = self:GetStatus()
	return stat == TFA.Enum.STATUS_BASHING or stat == TFA.Enum.STATUS_BASHING_WAIT
end

TFA.FillMissingMetaValues(SWEP)

--PATH lua/weapons/tfa_grapple_base/shared.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/shared.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/ai_translations.lua:
local HoldTypeTable = {
	["melee"] = {
		[ACT_IDLE] = ACT_IDLE_MELEE,
		[ACT_IDLE_ANGRY] = ACT_IDLE_MELEE,
		[ACT_IDLE_RELAXED] = ACT_IDLE_MELEE,
		[ACT_IDLE_STIMULATED] = ACT_IDLE_MELEE,
		[ACT_IDLE_AGITATED] = ACT_IDLE_MELEE,
		[ACT_IDLE_AIM_RELAXED] = ACT_IDLE_MELEE,
		[ACT_IDLE_AIM_STIMULATED] = ACT_IDLE_MELEE,
		[ACT_IDLE_AIM_AGITATED] = ACT_IDLE_MELEE,
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_THROW,
		[ACT_RANGE_ATTACK1_LOW] = ACT_MELEE_ATTACK_SWING,
		[ACT_MELEE_ATTACK1] = ACT_MELEE_ATTACK_SWING,
		[ACT_MELEE_ATTACK2] = ACT_MELEE_ATTACK_SWING,
		[ACT_SPECIAL_ATTACK1] = ACT_RANGE_ATTACK_THROW,
		[ACT_RANGE_AIM_LOW] = ACT_IDLE_MELEE,
		[ACT_COVER_LOW] = ACT_IDLE_MELEE,
		[ACT_WALK] = ACT_WALK_SUITCASE,
		[ACT_WALK_RELAXED] = ACT_WALK_SUITCASE,
		[ACT_WALK_STIMULATED] = ACT_WALK_SUITCASE,
		[ACT_WALK_AGITATED] = ACT_WALK_SUITCASE,
		[ACT_RUN_CROUCH] = ACT_RUN_CROUCH,
		[ACT_RUN_CROUCH_AIM] = ACT_RUN_CROUCH,
		[ACT_RUN] = ACT_RUN,
		[ACT_RUN_AIM_RELAXED] = ACT_RUN,
		[ACT_RUN_AIM_STIMULATED] = ACT_RUN,
		[ACT_RUN_AIM_AGITATED] = ACT_RUN,
		[ACT_RUN_AIM] = ACT_RUN,
		[ACT_SMALL_FLINCH] = ACT_RANGE_ATTACK_PISTOL,
		[ACT_BIG_FLINCH] = ACT_RANGE_ATTACK_PISTOL
	},
	["melee2"] = {
		[ACT_IDLE] = ACT_IDLE_ANGRY_MELEE,
		[ACT_IDLE_ANGRY] = ACT_IDLE_ANGRY_MELEE,
		[ACT_IDLE_RELAXED] = ACT_IDLE,
		[ACT_IDLE_STIMULATED] = ACT_IDLE,
		[ACT_IDLE_AGITATED] = ACT_IDLE_ANGRY_MELEE,
		[ACT_MP_RUN] = ACT_HL2MP_RUN_SUITCASE,
		[ACT_RUN] = ACT_RUN,
		[ACT_RUN_AIM_RELAXED] = ACT_RUN,
		[ACT_RUN_AIM_STIMULATED] = ACT_RUN,
		[ACT_RUN_AIM_AGITATED] = ACT_RUN,
		[ACT_RUN_AIM] = ACT_RUN,
		[ACT_WALK] = ACT_WALK_SUITCASE,
		[ACT_MELEE_ATTACK1] = ACT_MELEE_ATTACK_SWING,
		[ACT_RANGE_ATTACK1] = ACT_MELEE_ATTACK_SWING,
		[ACT_MELEE_ATTACK2] = ACT_MELEE_ATTACK_SWING,
		[ACT_RANGE_ATTACK2] = ACT_MELEE_ATTACK_SWING,
		[ACT_SPECIAL_ATTACK1] = ACT_RANGE_ATTACK_THROW,
		[ACT_SMALL_FLINCH] = ACT_RANGE_ATTACK_PISTOL,
		[ACT_BIG_FLINCH] = ACT_RANGE_ATTACK_PISTOL
	},
	["pistol"] = {
		[ACT_IDLE] = ACT_IDLE_PISTOL,
		[ACT_IDLE_ANGRY] = ACT_IDLE_ANGRY_PISTOL,
		[ACT_IDLE_AGITATED] = ACT_IDLE_ANGRY_PISTOL,
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_PISTOL,
		[ACT_RELOAD] = ACT_RELOAD_PISTOL,
		[ACT_WALK] = ACT_WALK_PISTOL,
		[ACT_WALK_AIM] = ACT_WALK_AIM_PISTOL,
		[ACT_RUN] = ACT_RUN_PISTOL,
		[ACT_RUN_AIM] = ACT_RUN_AIM_PISTOL,
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_PISTOL,
		[ACT_GESTURE_RANGE_ATTACK1] = ACT_GESTURE_RANGE_ATTACK_PISTOL,
		[ACT_RELOAD_LOW] = ACT_RELOAD_PISTOL_LOW,
		[ACT_RANGE_ATTACK1_LOW] = ACT_RANGE_ATTACK_PISTOL_LOW,
		[ACT_COVER_LOW] = ACT_COVER_PISTOL_LOW,
		[ACT_RANGE_AIM_LOW] = ACT_RANGE_AIM_PISTOL_LOW,
		[ACT_GESTURE_RELOAD] = ACT_GESTURE_RELOAD_PISTOL
	},
	["ar2"] = {
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_AR2,
		[ACT_RELOAD] = ACT_RELOAD_SMG1,
		[ACT_IDLE] = ACT_IDLE_SMG1,
		[ACT_IDLE_ANGRY] = ACT_IDLE_ANGRY_SMG1,
		[ACT_WALK] = ACT_WALK_RIFLE,
		[ACT_IDLE_RELAXED] = ACT_IDLE_SMG1_RELAXED,
		[ACT_IDLE_STIMULATED] = ACT_IDLE_SMG1_STIMULATED,
		[ACT_IDLE_AGITATED] = ACT_IDLE_ANGRY_SMG1,
		[ACT_WALK_RELAXED] = ACT_WALK_RIFLE_RELAXED,
		[ACT_WALK_STIMULATED] = ACT_WALK_RIFLE_STIMULATED,
		[ACT_WALK_AGITATED] = ACT_WALK_AIM_RIFLE,
		[ACT_RUN_RELAXED] = ACT_RUN_RIFLE_RELAXED,
		[ACT_RUN_STIMULATED] = ACT_RUN_RIFLE_STIMULATED,
		[ACT_RUN_AGITATED] = ACT_RUN_AIM_RIFLE,
		[ACT_IDLE_AIM_RELAXED] = ACT_IDLE_SMG1_RELAXED,
		[ACT_IDLE_AIM_STIMULATED] = ACT_IDLE_AIM_RIFLE_STIMULATED,
		[ACT_IDLE_AIM_AGITATED] = ACT_IDLE_ANGRY_SMG1,
		[ACT_WALK_AIM_RELAXED] = ACT_WALK_RIFLE_RELAXED,
		[ACT_WALK_AIM_STIMULATED] = ACT_WALK_AIM_RIFLE_STIMULATED,
		[ACT_WALK_AIM_AGITATED] = ACT_WALK_AIM_RIFLE,
		[ACT_RUN_AIM_RELAXED] = ACT_RUN_RIFLE_RELAXED,
		[ACT_RUN_AIM_STIMULATED] = ACT_RUN_AIM_RIFLE_STIMULATED,
		[ACT_RUN_AIM_AGITATED] = ACT_RUN_AIM_RIFLE,
		[ACT_WALK_AIM] = ACT_WALK_AIM_RIFLE,
		[ACT_WALK_CROUCH] = ACT_WALK_CROUCH_RIFLE,
		[ACT_WALK_CROUCH_AIM] = ACT_WALK_CROUCH_AIM_RIFLE,
		[ACT_RUN] = ACT_RUN_RIFLE,
		[ACT_RUN_AIM] = ACT_RUN_AIM_RIFLE,
		[ACT_RUN_CROUCH] = ACT_RUN_CROUCH_RIFLE,
		[ACT_RUN_CROUCH_AIM] = ACT_RUN_CROUCH_AIM_RIFLE,
		[ACT_GESTURE_RANGE_ATTACK1] = ACT_GESTURE_RANGE_ATTACK_AR2,
		[ACT_COVER_LOW] = ACT_COVER_SMG1_LOW,
		[ACT_RANGE_AIM_LOW] = ACT_RANGE_AIM_AR2_LOW,
		[ACT_RANGE_ATTACK1_LOW] = ACT_RANGE_ATTACK_SMG1_LOW,
		[ACT_RELOAD_LOW] = ACT_RELOAD_SMG1_LOW,
		[ACT_GESTURE_RELOAD] = ACT_GESTURE_RELOAD_SMG1
	},
	["smg"] = {
		[ACT_IDLE] = ACT_IDLE_SMG1,
		[ACT_IDLE_ANGRY] = ACT_IDLE_ANGRY_SMG1,
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_SMG1,
		[ACT_RELOAD] = ACT_RELOAD_SMG1,
		[ACT_WALK_AIM] = ACT_WALK_AIM_RIFLE,
		[ACT_RUN_AIM] = ACT_RUN_AIM_RIFLE,
		[ACT_GESTURE_RANGE_ATTACK1] = ACT_GESTURE_RANGE_ATTACK_SMG1,
		[ACT_RELOAD_LOW] = ACT_RELOAD_SMG1_LOW,
		[ACT_RANGE_ATTACK1_LOW] = ACT_RANGE_ATTACK_SMG1_LOW,
		[ACT_COVER_LOW] = ACT_COVER_SMG1_LOW,
		[ACT_RANGE_AIM_LOW] = ACT_RANGE_AIM_SMG1_LOW,
		[ACT_GESTURE_RELOAD] = ACT_GESTURE_RELOAD_SMG1
	}
}

function SWEP:SetupWeaponHoldTypeForAI(t)
	local usedT = HoldTypeTable[t or "ar2"] or HoldTypeTable["ar2"]
	self.ActivityTranslateAI = table.Copy(usedT)
end

function SWEP:TranslateActivity(act)
	if (self:GetOwner():IsNPC()) then
		if (self.ActivityTranslateAI[act]) then return self.ActivityTranslateAI[act] end

		return -1
	end

	if (self.ActivityTranslate[act] ~= nil) then return self.ActivityTranslate[act] end

	return -1
end

function SWEP:GetCapabilities()
	local ht = self.DefaultHoldType or self.HoldType or "pistol"

	if ht == "melee" or ht == "melee2" or ht == "knife" or self.IsKnife then
		return CAP_WEAPON_MELEE_ATTACK1
	else
		return bit.bor(CAP_WEAPON_RANGE_ATTACK1, CAP_INNATE_RANGE_ATTACK1)
	end
end

--PATH lua/weapons/tfa_gun_base/common/anims.lua:
local sp = game.SinglePlayer()

SWEP.Locomotion_Data_Queued = nil

local ServersideLooped = {
	[ACT_VM_FIDGET] = true,
	[ACT_VM_FIDGET_EMPTY] = true
}

--[ACT_VM_IDLE] = true,
--[ACT_VM_IDLE_EMPTY] = true,
--[ACT_VM_IDLE_SILENCED] = true
local d, pbr

-- Override this after SWEP:Initialize, for example, in attachments
SWEP.BaseAnimations = {
	["draw_first"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRAW_DEPLOYED,
		["enabled"] = nil --Manually force a sequence to be enabled
	},
	["draw"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRAW
	},
	["draw_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRAW_EMPTY
	},
	["draw_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRAW_SILENCED
	},
	["shoot1"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_PRIMARYATTACK
	},
	["shoot1_last"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_PRIMARYATTACK_EMPTY
	},
	["shoot1_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRYFIRE
	},
	["shoot1_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_PRIMARYATTACK_SILENCED
	},
	["shoot1_silenced_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRYFIRE_SILENCED or 0
	},
	["shoot1_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_PRIMARYATTACK_1
	},
	["shoot2"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_SECONDARYATTACK
	},
	["shoot2_last"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot2_last"
	},
	["shoot2_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRYFIRE
	},
	["shoot2_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot2_silenced"
	},
	["shoot2_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_ISHOOT_M203
	},
	["idle"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IDLE
	},
	["idle_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IDLE_EMPTY
	},
	["idle_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IDLE_SILENCED
	},
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_SILENCED
	},
	["reload_shotgun_start"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_SHOTGUN_RELOAD_START
	},
	["reload_shotgun_finish"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_SHOTGUN_RELOAD_FINISH
	},
	["reload_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_VM_RELOAD_ADS
	},
	["reload_empty_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_VM_RELOAD_EMPTY_ADS
	},
	["reload_silenced_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_VM_RELOAD_SILENCED_ADS
	},
	["reload_shotgun_start_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_SHOTGUN_RELOAD_START_ADS
	},
	["reload_shotgun_finish_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_SHOTGUN_RELOAD_FINISH_ADS
	},
	["holster"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HOLSTER
	},
	["holster_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HOLSTER_EMPTY
	},
	["holster_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HOLSTER_SILENCED
	},
	["silencer_attach"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_ATTACH_SILENCER
	},
	["silencer_detach"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DETACH_SILENCER
	},
	["rof"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_FIREMODE
	},
	["rof_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IFIREMODE
	},
	["bash"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HITCENTER
	},
	["bash_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HITCENTER2
	},
	["bash_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_MISSCENTER
	},
	["bash_empty_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_MISSCENTER2
	},
	["inspect"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_FIDGET
	},
	["inspect_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_FIDGET_EMPTY
	},
	["inspect_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_FIDGET_SILENCED
	}
}

SWEP.Animations = {}

function SWEP:InitializeAnims()
	local self2 = self:GetTable()

	setmetatable(self2.Animations, {
		__index = function(t, k) return self2.BaseAnimations[k] end
	})
end

function SWEP:BuildAnimActivities()
	local self2 = self:GetTable()
	self2.AnimationActivities = self2.AnimationActivities or {}

	for k, v in pairs(self2.BaseAnimations) do
		if v.value then
			self2.AnimationActivities[v.value] = k
		end

		local kvt = self2.GetStatL(self, "Animations." .. k)

		if kvt.value then
			self2.AnimationActivities[kvt.value] = k
		end
	end

	for k, _ in pairs(self2.Animations) do
		local kvt = self2.GetStatL(self, "Animations." .. k)

		if kvt.value then
			self2.AnimationActivities[kvt.value] = k
		end
	end
end

function SWEP:GetActivityEnabled(act)
	local self2 = self:GetTable()
	local stat = self2.GetStatL(self, "SequenceEnabled." .. act)
	if stat then return stat end

	if not self2.AnimationActivities then
		self:BuildAnimActivities()
	end

	local keysel = self2.AnimationActivities[act] or ""
	local kv = self2.GetStatL(self, "Animations." .. keysel)
	if not kv then return false end

	if kv["enabled"] then
		return kv["enabled"]
	else
		return false
	end
end

function SWEP:ChooseAnimation(keyOrData)
	local self2 = self:GetTable()

	local data

	if isstring(keyOrData) then
		data = self2.GetStatL(self, "Animations." .. keyOrData)
	elseif istable(keyOrData) then
		data = keyOrData
	else
		error("Unknown value type " .. type(keyOrData) .. " passed!")
	end

	if not data then return 0, 0 end
	if not data["type"] then return 0, 0 end
	if not data["value"] then return 0, 0 end

	local retType, retValue = data["type"], data["value"]

	if self:Clip1() <= 0 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
		if data.value_empty then
			retValue = data.value_empty
			retType = data.type_empty or retType
		end
	end

	if self:Clip1() == 1 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
		if data.value_last then
			retValue = data.value_last
			retType = data.type_last or retType
		end
	end

	if self2.GetSilenced(self) then
		local previousRetType = retType

		if data.value_sil then
			retValue = data.value_sil
			retType = data.type_sil or previousRetType
		end

		if self:Clip1() <= 0 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
			if data.value_sil_empty then
				retValue = data.value_sil_empty
				retType = data.type_sil_empty or previousRetType
			end
		end
	end

	if self:GetIronSights() then
		local previousRetType = retType

		if data.value_is then
			retValue = data.value_is
			retType = data.type_is or previousRetType
		end

		if self:Clip1() <= 0 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
			if data.value_is_empty then
				retValue = data.value_is_empty
				retType = data.type_is_empty or previousRetType
			end
		end

		if self:Clip1() == 1 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
			if data.value_is_last then
				retValue = data.value_is_last
				retType = data.type_is_last or previousRetType
			end
		end

		if self2.GetSilenced(self) then
			if data.value_is_sil then
				retValue = data.value_is_sil
				retType = data.type_is_sil or previousRetType
			end

			if self:Clip1() <= 0 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
				if data.value_is_sil_empty then
					retValue = data.value_is_sil_empty
					retType = data.type_is_sil_empty or previousRetType
				end
			end

			if self:Clip1() == 1 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
				if data.value_is_sil_last then
					retValue = data.value_is_sil_last
					retType = data.type_is_sil_last or previousRetType
				end
			end
		end
	end

	if retType == TFA.Enum.ANIMATION_ACT and isstring(retValue) then
		retValue = tonumber(retValue) or -1
	elseif retType == TFA.Enum.ANIMATION_SEQ and isstring(retValue) then
		retValue = self2.OwnerViewModel:LookupSequence(retValue)
	end

	return retType, retValue
end

function SWEP:GetAnimationRate(ani, animationType)
	local self2 = self:GetTable()
	local rate = 1
	if not ani or ani < 0 or not self2.VMIV(self) then return rate end

	local nm

	if animationType == TFA.Enum.ANIMATION_ACT or animationType == nil then
		nm = self2.OwnerViewModel:GetSequenceName(self2.OwnerViewModel:SelectWeightedSequence(ani))
	elseif isnumber(ani) then
		nm = self2.OwnerViewModel:GetSequenceName(ani)
	elseif isstring(ani) then
		nm = ani
	else
		error("ani argument is typeof " .. type(ani))
	end

	local sqto = self2.GetStatL(self, "SequenceTimeOverride." .. nm) or self2.GetStatL(self, "SequenceTimeOverride." .. (ani or "0"))
	local sqro = self2.GetStatL(self, "SequenceRateOverride." .. nm) or self2.GetStatL(self, "SequenceRateOverride." .. (ani or "0"))

	if sqro then
		rate = rate * sqro
	elseif sqto then
		local t = self:GetActivityLengthRaw(ani, false)

		if t then
			rate = rate * t / sqto
		end
	end

	rate = hook.Run("TFA_AnimationRate", self, ani, rate) or rate

	return rate
end

function SWEP:SendViewModelAnim(act, rate, targ, blend)
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, act end
	local vm = self2.OwnerViewModel

	if rate and not targ then
		rate = math.max(rate, 0.0001)
	end

	if not rate then
		rate = 1
	end

	if targ then
		rate = rate / self:GetAnimationRate(act)
	else
		rate = rate * self:GetAnimationRate(act)
	end

	if act < 0 then return false, act end
	local seq = vm:SelectWeightedSequenceSeeded(act, self:GetSeedIrradical())

	if seq < 0 then
		if act == ACT_VM_IDLE_EMPTY then
			seq = vm:SelectWeightedSequenceSeeded(ACT_VM_IDLE, self:GetSeedIrradical())
		elseif act == ACT_VM_PRIMARYATTACK_EMPTY then
			seq = vm:SelectWeightedSequenceSeeded(ACT_VM_PRIMARYATTACK, self:GetSeedIrradical())
		else
			return false, 0
		end

		if seq < 0 then return false, act end
	end

	local preLastActivity = self:GetLastActivity()
	--local preLastSequence = self:GetLastActivity()
	self:SetLastActivity(act)
	self:SetLastSequence(seq)
	self:ResetEvents()

	if preLastActivity == act and ServersideLooped[act] then
		self:ChooseIdleAnim()
		d = vm:SequenceDuration(seq)
		pbr = targ and (d / (rate or 1)) or (rate or 1)

		if IsValid(self) then
			if blend == nil then
				blend = self2.Idle_Smooth
			end

			self:SetNextIdleAnim(CurTime() + d / pbr - blend)
		end

		if IsFirstTimePredicted() then
			timer.Simple(0, function()
				vm:SendViewModelMatchingSequence(seq)
				d = vm:SequenceDuration()
				pbr = targ and (d / (rate or 1)) or (rate or 1)
				vm:SetPlaybackRate(pbr)

				if IsValid(self) then
					if blend == nil then
						blend = self2.Idle_Smooth
					end

					self:SetNextIdleAnim(CurTime() + d / pbr - blend)
					self:SetLastActivity(act)
				end
			end)
		end
	else
		if seq >= 0 then
			vm:SendViewModelMatchingSequence(seq)
		end

		d = vm:SequenceDuration()
		pbr = targ and (d / (rate or 1)) or (rate or 1)
		vm:SetPlaybackRate(pbr)

		if blend == nil then
			blend = self2.Idle_Smooth
		end

		self:SetNextIdleAnim(CurTime() + math.max(d / pbr - blend, self2.Idle_Smooth))
	end

	return true, act
end

function SWEP:SendViewModelSeq(seq, rate, targ, blend)
	local self2 = self:GetTable()
	local seqold = seq

	if not self2.VMIV(self) then return false, 0 end
	local vm = self2.OwnerViewModel

	if isstring(seq) then
		seq = vm:LookupSequence(seq) or 0
	end

	local act = vm:GetSequenceActivity(seq)

	if self2.SequenceRateOverride[seqold] then
		rate = self2.SequenceRateOverride[seqold]
		targ = false
	elseif self2.SequenceRateOverride[act] then
		rate = self2.SequenceRateOverride[act]
		targ = false
	elseif self2.SequenceTimeOverride[seqold] then
		rate = self2.SequenceTimeOverride[seqold]
		targ = true
	elseif self2.SequenceTimeOverride[act] then
		rate = self2.SequenceTimeOverride[act]
		targ = true
	end

	if not rate then
		rate = 1
	end

	if targ then
		rate = rate / self:GetAnimationRate(seq, TFA.Enum.ANIMATION_SEQ)
	else
		rate = rate * self:GetAnimationRate(seq, TFA.Enum.ANIMATION_SEQ)
	end

	if seq < 0 then return false, seq end

	local preLastActivity = self:GetLastActivity()
	--local preLastSequence = self:GetLastSequence()
	self:SetLastActivity(act)
	self:SetLastSequence(seq)
	self:ResetEvents()

	if preLastActivity == act and ServersideLooped[act] then
		vm:SendViewModelMatchingSequence(act == 0 and 1 or 0)
		vm:SetPlaybackRate(0)
		vm:SetCycle(0)
		self:SetNextIdleAnim(CurTime() + 0.03)

		if IsFirstTimePredicted() then
			timer.Simple(0, function()
				vm:SendViewModelMatchingSequence(seq)
				d = vm:SequenceDuration()
				pbr = targ and (d / (rate or 1)) or (rate or 1)
				vm:SetPlaybackRate(pbr)

				if IsValid(self) then
					if blend == nil then
						blend = self2.Idle_Smooth
					end

					self:SetNextIdleAnim(CurTime() + d / pbr - blend)
					self:SetLastActivity(act)
				end
			end)
		end
	else
		if seq >= 0 then
			vm:SendViewModelMatchingSequence(seq)
		end

		d = vm:SequenceDuration()
		pbr = targ and (d / (rate or 1)) or (rate or 1)
		vm:SetPlaybackRate(pbr)

		if IsValid(self) then
			if blend == nil then
				blend = self2.Idle_Smooth
			end

			self:SetNextIdleAnim(CurTime() + d / pbr - blend)
		end
	end

	return true, seq
end

function SWEP:PlayAnimation(data, fade, rate, targ)
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, -1 end
	if not data then return false, -1 end

	local ttype, tval = self:ChooseAnimation(data)

	if ttype == TFA.Enum.ANIMATION_SEQ then
		local success, activityID = self:SendViewModelSeq(tval, rate or 1, targ, fade or (data.transition and self2.Idle_Blend or self2.Idle_Smooth))
		return success, activityID, TFA.Enum.ANIMATION_SEQ
	end

	local success, activityID = self:SendViewModelAnim(tval, rate or 1, targ, fade or (data.transition and self2.Idle_Blend or self2.Idle_Smooth))
	return success, activityID, TFA.Enum.ANIMATION_ACT
end

--[[
Function Name:  Locomote
Syntax: self:Locomote( flip ironsights, new is, flip sprint, new sprint, flip walk, new walk).
Returns:
Notes:
Purpose:  Animation / Utility
]]
local tldata

function SWEP:Locomote(flipis, is, flipsp, spr, flipwalk, walk, flipcust, cust)
	local self2 = self:GetTable()
	if not (flipis or flipsp or flipwalk or flipcust) then return end
	if not (self:GetStatus() == TFA.Enum.STATUS_IDLE or (self:GetStatus() == TFA.Enum.STATUS_SHOOTING and self:CanInterruptShooting())) then return end
	tldata = nil

	if flipis then
		if is and self2.GetStatL(self, "IronAnimation.in") then
			tldata = self2.GetStatL(self, "IronAnimation.in", tldata)
		elseif self2.GetStatL(self, "IronAnimation.out") and not flipsp then
			tldata = self2.GetStatL(self, "IronAnimation.out", tldata)
		end
	end

	if flipsp then
		if spr and self2.GetStatL(self, "SprintAnimation.in") then
			tldata = self2.GetStatL(self, "SprintAnimation.in", tldata)
		elseif self2.GetStatL(self, "SprintAnimation.out") and not flipis and not spr then
			tldata = self2.GetStatL(self, "SprintAnimation.out", tldata)
		end
	end

	if flipwalk and not is then
		if walk and self2.GetStatL(self, "WalkAnimation.in") then
			tldata = self2.GetStatL(self, "WalkAnimation.in", tldata)
		elseif self2.GetStatL(self, "WalkAnimation.out") and (not flipis and not flipsp and not flipcust) and not walk then
			tldata = self2.GetStatL(self, "WalkAnimation.out", tldata)
		end
	end

	if flipcust then
		if cust and self2.GetStatL(self, "CustomizeAnimation.in") then
			tldata = self2.GetStatL(self, "CustomizeAnimation.in", tldata)
		elseif self2.GetStatL(self, "CustomizeAnimation.out") and (not flipis and not flipsp and not flipwalk) and not cust then
			tldata = self2.GetStatL(self, "CustomizeAnimation.out", tldata)
		end
	end

	if tldata then
		return self:PlayAnimation(tldata)
	end

	return false, -1, TFA.Enum.ANIMATION_SEQ
end

function SWEP:LocomoteOrIdle(...)
	local success, animID, animType = self:Locomote(...)

	if not success then
		return self:SetNextIdleAnim(-1)
	end

	return success, animID, animType
end

--[[
Function Name:  ChooseDrawAnim
Syntax: self:ChooseDrawAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
SWEP.IsFirstDeploy = true

local function PlayChosenAnimation(self, typev, tanim, ...)
	local fnName = typev == TFA.Enum.ANIMATION_SEQ and "SendViewModelSeq" or "SendViewModelAnim"
	local a, b = self[fnName](self, tanim, ...)
	return a, b, typev
end

SWEP.PlayChosenAnimation = PlayChosenAnimation

local success, tanim, typev

local cv_firstdeploy = GetConVar("sv_tfa_first_draw_anim_enabled")

function SWEP:ChooseDrawAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	--self:ResetEvents()
	tanim = ACT_VM_DRAW
	success = true

	local ct = CurTime()

	if self:GetIsFirstDeploy() and self:GetLastDeployAnim() >= 0 and ct > (self:GetLastDeployAnim() or ct) + 0.1 then
		self:SetIsFirstDeploy(false)
		self2.IsFirstDeploy = false
	end

	if self:GetActivityEnabled(ACT_VM_DRAW_EMPTY) and self:IsEmpty1() then
		typev, tanim = self:ChooseAnimation("draw_empty")
	elseif (self:GetActivityEnabled(ACT_VM_DRAW_DEPLOYED) or self2.GetStat(self, "FirstDeployEnabled", false)) and self:GetIsFirstDeploy() and cv_firstdeploy:GetBool() then
		typev, tanim = self:ChooseAnimation("draw_first")
	elseif self:GetActivityEnabled(ACT_VM_DRAW_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("draw_silenced")
	else
		typev, tanim = self:ChooseAnimation("draw")
	end

	self:SetLastDeployAnim(ct)
	self2.LastDeployAnim = ct

	return PlayChosenAnimation(self, typev, tanim)
end

function SWEP:ResetFirstDeploy()
	self.IsFirstDeploy = true
	self:SetIsFirstDeploy(true)

	self.LastDeployAnim = -1
	self:SetLastDeployAnim(-1)
end

--[[
Function Name:  ChooseInspectAnim
Syntax: self:ChooseInspectAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--

function SWEP:ChooseInspectAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	if self:GetActivityEnabled(ACT_VM_FIDGET_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("inspect_silenced")
	elseif self:GetActivityEnabled(ACT_VM_FIDGET_EMPTY) and self:IsEmpty1() then
		typev, tanim = self:ChooseAnimation("inspect_empty")
	elseif self2.InspectionActions then
		tanim = self2.InspectionActions[self:SharedRandom(1, #self2.InspectionActions, "Inspect")]
	elseif self:GetActivityEnabled(ACT_VM_FIDGET) then
		typev, tanim = self:ChooseAnimation("inspect")
	else
		typev, tanim = self:ChooseAnimation("idle")
		success = false
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseHolsterAnim
Syntax: self:ChooseHolsterAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseHolsterAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	if self:GetActivityEnabled(ACT_VM_HOLSTER_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("holster_silenced")
	elseif self:GetActivityEnabled(ACT_VM_HOLSTER_EMPTY) and self:IsEmpty1() then
		typev, tanim = self:ChooseAnimation("holster_empty")
	elseif self:GetActivityEnabled(ACT_VM_HOLSTER) then
		typev, tanim = self:ChooseAnimation("holster")
	else
		return false, select(2, self:ChooseIdleAnim())
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseProceduralReloadAnim
Syntax: self:ChooseProceduralReloadAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Uses some holster code
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseProceduralReloadAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	if not self2.DisableIdleAnimations then
		self:SendViewModelAnim(ACT_VM_IDLE)
	end

	return true, ACT_VM_IDLE
end

--[[
Function Name:  ChooseReloadAnim
Syntax: self:ChooseReloadAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseReloadAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	if self2.GetStatL(self, "IsProceduralReloadBased") then return false, 0 end

	local ads = self:GetStatL("IronSightsReloadEnabled") and self:GetIronSightsDirect()

	if self:GetActivityEnabled(ACT_VM_RELOAD_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_SILENCED_ADS)) and "reload_silenced_is" or "reload_silenced")
	elseif self:GetActivityEnabled(ACT_VM_RELOAD_EMPTY) and (self:Clip1() == 0 or self:IsJammed()) and not self:GetStatL("LoopedReload") then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_EMPTY_ADS)) and "reload_empty_is" or "reload_empty")
	else
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_ADS)) and "reload_is" or "reload")
	end

	local fac = 1

	if self:GetStatL("LoopedReload") and self:GetStatL("LoopedReloadInsertTime") then
		fac = self:GetStatL("LoopedReloadInsertTime")
	end

	return PlayChosenAnimation(self, typev, tanim, fac, fac ~= 1)
end

--[[
Function Name:  ChooseReloadAnim
Syntax: self:ChooseReloadAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseShotgunReloadAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	local ads = self:GetStatL("IronSightsReloadEnabled") and self:GetIronSightsDirect()

	if self:GetActivityEnabled(ACT_VM_RELOAD_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_SILENCED_ADS)) and "reload_silenced_is" or "reload_silenced")
	elseif self:GetActivityEnabled(ACT_VM_RELOAD_EMPTY) and self2.ShotgunEmptyAnim and (self:Clip1() == 0 or self:IsJammed()) then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_EMPTY_ADS)) and "reload_empty_is" or "reload_empty")
	elseif self:GetActivityEnabled(ACT_SHOTGUN_RELOAD_START) then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_SHOTGUN_RELOAD_START_ADS)) and "reload_shotgun_start_is" or "reload_shotgun_start")
	else
		return false, select(2, self:ChooseIdleAnim())
	end

	return PlayChosenAnimation(self, typev, tanim)
end

function SWEP:ChooseShotgunPumpAnim()
	if not self:VMIV() then return false, 0 end

	typev, tanim = self:ChooseAnimation(
		(self:GetStatL("IronSightsReloadEnabled") and
		self:GetIronSightsDirect() and
		self:GetActivityEnabled(ACT_SHOTGUN_RELOAD_START_ADS)) and "reload_shotgun_finish_is" or "reload_shotgun_finish")

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseIdleAnim
Syntax: self:ChooseIdleAnim().
Returns:  True,  Which action?
Notes:  Requires autodetection for full features.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseIdleAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	--if self2.Idle_WithHeld then
	--  self2.Idle_WithHeld = nil
	--  return
	--end

	if TFA.Enum.ShootLoopingStatus[self:GetShootStatus()] and self:ShouldPlayLoopShootAnim() then
		return self:ChooseLoopShootAnim()
	end

	local idleMode = self2.GetStatL(self, "Idle_Mode")

	if idleMode ~= TFA.Enum.IDLE_BOTH and idleMode ~= TFA.Enum.IDLE_ANI then return end

	--self:ResetEvents()
	if self:GetIronSights() then
		local sightsMode = self2.GetStatL(self, "Sights_Mode")

		if sightsMode == TFA.Enum.LOCOMOTION_LUA then
			return self:ChooseFlatAnim()
		else
			return self:ChooseADSAnim()
		end
	elseif self:GetSprinting() and self2.GetStatL(self, "Sprint_Mode") ~= TFA.Enum.LOCOMOTION_LUA then
		return self:ChooseSprintAnim()
	elseif self:GetWalking() and self2.GetStatL(self, "Walk_Mode") ~= TFA.Enum.LOCOMOTION_LUA then
		return self:ChooseWalkAnim()
	elseif self:GetCustomizing() and self2.GetStatL(self, "Customize_Mode") ~= TFA.Enum.LOCOMOTION_LUA then
		return self:ChooseCustomizeAnim()
	end

	if self:GetActivityEnabled(ACT_VM_IDLE_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("idle_silenced")
	elseif self:IsEmpty1() then
		--self:GetActivityEnabled( ACT_VM_IDLE_EMPTY ) and (self:Clip1() == 0) then
		if self:GetActivityEnabled(ACT_VM_IDLE_EMPTY) then
			typev, tanim = self:ChooseAnimation("idle_empty")
		else --if not self:GetActivityEnabled( ACT_VM_PRIMARYATTACK_EMPTY ) then
			typev, tanim = self:ChooseAnimation("idle")
		end
	else
		typev, tanim = self:ChooseAnimation("idle")
	end

	--else
	--  return
	--end
	return PlayChosenAnimation(self, typev, tanim)
end

function SWEP:ChooseFlatAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	--self:ResetEvents()
	typev, tanim = self:ChooseAnimation("idle")

	if self:GetActivityEnabled(ACT_VM_IDLE_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("idle_silenced")
	elseif self:GetActivityEnabled(ACT_VM_IDLE_EMPTY) and self:IsEmpty1() then
		typev, tanim = self:ChooseAnimation("idle_empty")
	end

	return PlayChosenAnimation(self, typev, tanim, 0.000001)
end

function SWEP:ChooseADSAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	local a, b, c = self:PlayAnimation(self2.GetStatL(self, "IronAnimation.loop"))

	--self:SetNextIdleAnim(CurTime() + 1)
	if not a then
		local _
		_, b, c = self:ChooseFlatAnim()
		a = false
	end

	return a, b, c
end

function SWEP:ChooseSprintAnim()
	return self:PlayAnimation(self:GetStatL("SprintAnimation.loop"))
end

function SWEP:ChooseWalkAnim()
	return self:PlayAnimation(self:GetStatL("WalkAnimation.loop"))
end

function SWEP:ChooseLoopShootAnim()
	return self:PlayAnimation(self:GetStatL("ShootAnimation.loop"))
end

function SWEP:ChooseCustomizeAnim()
	return self:PlayAnimation(self:GetStatL("CustomizeAnimation.loop"))
end

--[[
Function Name:  ChooseShootAnim
Syntax: self:ChooseShootAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--
local shouldAnim, shouldBlowback
function SWEP:ChooseShootAnim(ifp)
	local self2 = self:GetTable()
	if ifp == nil then ifp = IsFirstTimePredicted() end
	if not self2.VMIV(self) then return false, 0 end

	if self2.GetStatL(self, "ShootAnimation.loop") and self2.ShouldPlayLoopShootAnim(self) then
		if self2.LuaShellEject and ifp then
			self:EventShell()
		end

		if TFA.Enum.ShootReadyStatus[self:GetShootStatus()] then
			self:SetShootStatus(TFA.Enum.SHOOT_START)

			local inan = self2.GetStatL(self, "ShootAnimation.in")

			if not inan then
				inan = self2.GetStatL(self, "ShootAnimation.loop")
			end

			return self:PlayAnimation(inan)
		end

		return
	end

	local sightsMode = self2.GetStatL(self, "Sights_Mode")

	if self:GetIronSights() and (sightsMode == TFA.Enum.LOCOMOTION_ANI or sightsMode == TFA.Enum.LOCOMOTION_HYBRID) and self2.GetStatL(self, "IronAnimation.shoot") then
		if self2.LuaShellEject and ifp then
			self:EventShell()
		end

		return self:PlayAnimation(self2.GetStatL(self, "IronAnimation.shoot"))
	end

	shouldBlowback = self2.GetStatL(self, "BlowbackEnabled") and (not self2.GetStatL(self, "Blowback_Only_Iron") or self:GetIronSights())
	shouldAnim = not shouldBlowback or self2.GetStatL(self, "BlowbackAllowAnimation")

	if shouldBlowback then
		if sp and SERVER then
			self:CallOnClient("BlowbackFull", "")
		end

		if ifp then
			self:BlowbackFull(ifp)
		end

		if self2.GetStatL(self, "Blowback_Shell_Enabled") and (ifp or sp) then
			self:EventShell()
		end
	end

	if shouldAnim then
		success = true

		if self2.LuaShellEject and (ifp or sp) then
			self:EventShell()
		end

		if self:GetActivityEnabled(ACT_VM_PRIMARYATTACK_SILENCED) and self2.GetSilenced(self) then
			typev, tanim = self:ChooseAnimation("shoot1_silenced")
		elseif self:Clip1() <= self2.Primary_TFA.AmmoConsumption and self:GetActivityEnabled(ACT_VM_PRIMARYATTACK_EMPTY) and self2.Primary_TFA.ClipSize >= 1 and not self2.ForceEmptyFireOff then
			typev, tanim = self:ChooseAnimation("shoot1_last")
		elseif self:Ammo1() <= self2.Primary_TFA.AmmoConsumption and self:GetActivityEnabled(ACT_VM_PRIMARYATTACK_EMPTY) and self2.Primary_TFA.ClipSize < 1 and not self2.ForceEmptyFireOff then
			typev, tanim = self:ChooseAnimation("shoot1_last")
		elseif self:Clip1() == 0 and self:GetActivityEnabled(ACT_VM_DRYFIRE) and not self2.ForceDryFireOff then
			typev, tanim = self:ChooseAnimation("shoot1_empty")
		elseif self2.GetStatL(self, "IsAkimbo") and self:GetActivityEnabled(ACT_VM_SECONDARYATTACK) and ((self:GetAnimCycle() == 0 and not self2.Akimbo_Inverted) or (self:GetAnimCycle() == 1 and self2.Akimbo_Inverted)) then
			typev, tanim = self:ChooseAnimation((self:GetIronSights() and self:GetActivityEnabled(ACT_VM_ISHOOT_M203)) and "shoot2_is" or "shoot2")
		elseif self:GetIronSights() and self:GetActivityEnabled(ACT_VM_PRIMARYATTACK_1) then
			typev, tanim = self:ChooseAnimation("shoot1_is")
		else
			typev, tanim = self:ChooseAnimation("shoot1")
		end

		return PlayChosenAnimation(self, typev, tanim)
	end

	self:SendViewModelAnim(ACT_VM_BLOWBACK)

	return true, ACT_VM_IDLE
end

SWEP.BlowbackRandomAngle = Angle(0, 0, 0) -- not cached, overwritten with each shot

SWEP.BlowbackRandomAngleMin = Angle(.1, -.5, -1)
SWEP.BlowbackRandomAngleMax = Angle(.2, .5, 1)

local minang, maxang

function SWEP:BlowbackFull()
	local self2 = self:GetTable()

	if IsValid(self) then
		self2.BlowbackCurrent = 1
		self2.BlowbackCurrentRoot = 1

		if CLIENT then
			minang, maxang = self2.GetStatL(self, "BlowbackRandomAngleMin"), self2.GetStatL(self, "BlowbackRandomAngleMax")

			self2.BlowbackRandomAngle = Angle(math.Rand(minang.p, maxang.p), math.Rand(minang.y, maxang.y), math.Rand(minang.r, maxang.r))
		end
	end
end

--[[
Function Name:  ChooseSilenceAnim
Syntax: self:ChooseSilenceAnim( true if we're silencing, false for detaching the silencer).
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.  This is played when you silence or unsilence a gun.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseSilenceAnim(val)
	if not self:VMIV() then return false, 0 end
	--self:ResetEvents()
	typev, tanim = self:ChooseAnimation("idle_silenced")
	success = false

	if val then
		if self:GetActivityEnabled(ACT_VM_ATTACH_SILENCER) then
			typev, tanim = self:ChooseAnimation("silencer_attach")
			success = true
		end
	elseif self:GetActivityEnabled(ACT_VM_DETACH_SILENCER) then
		typev, tanim = self:ChooseAnimation("silencer_detach")
		success = true
	end

	if not success then
		return false, select(2, self:ChooseIdleAnim())
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseDryFireAnim
Syntax: self:ChooseDryFireAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.  set SWEP.ForceDryFireOff to false to properly use.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseDryFireAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	--self:ResetEvents()
	typev, tanim = self:ChooseAnimation("shoot1_empty")
	success = true

	if self:GetActivityEnabled(ACT_VM_DRYFIRE_SILENCED) and self2.GetSilenced(self) and not self2.ForceDryFireOff then
		typev, tanim = self:ChooseAnimation("shoot1_silenced_empty")
		--self:ChooseIdleAnim()
	else
		if self:GetActivityEnabled(ACT_VM_DRYFIRE) and not self2.ForceDryFireOff then
			typev, tanim = self:ChooseAnimation("shoot1_empty")
		else
			success = false
			local _
			_, tanim = nil, nil

			return success, tanim -- ???
		end
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseROFAnim
Syntax: self:ChooseROFAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.  Called when we change the firemode.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseROFAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	--self:ResetEvents()
	if self:GetIronSights() and self:GetActivityEnabled(ACT_VM_IFIREMODE) then
		typev, tanim = self2.ChooseAnimation(self, "rof_is")
		success = true
	elseif self:GetActivityEnabled(ACT_VM_FIREMODE) then
		typev, tanim = self2.ChooseAnimation(self, "rof")
		success = true
	else
		success = false
		local _
		_, tanim = nil, nil

		return success, tanim -- ???
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseBashAnim
Syntax: self:ChooseBashAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.  Called when we bash.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseBashAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	typev, tanim = nil, nil
	success = false

	local isempty = self2.GetStatL(self, "Primary.ClipSize") > 0 and self:Clip1() == 0

	if self2.GetSilenced(self) and self:GetActivityEnabled(ACT_VM_HITCENTER2) then
		if self:GetActivityEnabled(ACT_VM_MISSCENTER2) and isempty then
			typev, tanim = self:ChooseAnimation("bash_empty_silenced")
			success = true
		else
			typev, tanim = self:ChooseAnimation("bash_silenced")
			success = true
		end
	elseif self:GetActivityEnabled(ACT_VM_MISSCENTER) and isempty then
		typev, tanim = self:ChooseAnimation("bash_empty")
		success = true
	elseif self:GetActivityEnabled(ACT_VM_HITCENTER) then
		typev, tanim = self:ChooseAnimation("bash")
		success = true
	end

	if not success then
		return success, tanim
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[THIRDPERSON]]
--These holdtypes are used in ironsights.  Syntax:  DefaultHoldType=NewHoldType
SWEP.IronSightHoldTypes = {
	pistol = "revolver",
	smg = "rpg",
	grenade = "melee",
	ar2 = "rpg",
	shotgun = "ar2",
	rpg = "rpg",
	physgun = "physgun",
	crossbow = "ar2",
	melee = "melee2",
	slam = "camera",
	normal = "fist",
	melee2 = "magic",
	knife = "fist",
	duel = "duel",
	camera = "camera",
	magic = "magic",
	revolver = "revolver"
}

--These holdtypes are used while sprinting.  Syntax:  DefaultHoldType=NewHoldType
SWEP.SprintHoldTypes = {
	pistol = "normal",
	smg = "passive",
	grenade = "normal",
	ar2 = "passive",
	shotgun = "passive",
	rpg = "passive",
	physgun = "normal",
	crossbow = "passive",
	melee = "normal",
	slam = "normal",
	normal = "normal",
	melee2 = "melee",
	knife = "fist",
	duel = "normal",
	camera = "slam",
	magic = "normal",
	revolver = "normal"
}

--These holdtypes are used in reloading.  Syntax:  DefaultHoldType=NewHoldType
SWEP.ReloadHoldTypes = {
	pistol = "pistol",
	smg = "smg",
	grenade = "melee",
	ar2 = "ar2",
	shotgun = "shotgun",
	rpg = "ar2",
	physgun = "physgun",
	crossbow = "crossbow",
	melee = "pistol",
	slam = "smg",
	normal = "pistol",
	melee2 = "pistol",
	knife = "pistol",
	duel = "duel",
	camera = "pistol",
	magic = "pistol",
	revolver = "revolver"
}

--These holdtypes are used in reloading.  Syntax:  DefaultHoldType=NewHoldType
SWEP.CrouchHoldTypes = {
	ar2 = "ar2",
	smg = "smg",
	rpg = "ar2"
}

SWEP.IronSightHoldTypeOverride = "" --This variable overrides the ironsights holdtype, choosing it instead of something from the above tables.  Change it to "" to disable.
SWEP.SprintHoldTypeOverride = "" --This variable overrides the sprint holdtype, choosing it instead of something from the above tables.  Change it to "" to disable.
SWEP.ReloadHoldTypeOverride = "" --This variable overrides the reload holdtype, choosing it instead of something from the above tables.  Change it to "" to disable.
local dynholdtypecvar = GetConVar("sv_tfa_holdtype_dynamic")
SWEP.mht_old = ""
local mht

function SWEP:IsOwnerCrouching()
	local ply = self:GetOwner()

	if not ply:IsPlayer() then return false end

	return (ply:Crouching() or self:KeyDown(IN_DUCK)) and ply:OnGround() and not ply:InVehicle()
end

function SWEP:ProcessHoldType()
	local self2 = self:GetTable()
	mht = self2.GetStatL(self, "HoldType", "ar2")

	if mht ~= self2.mht_old or not self2.DefaultHoldType then
		self2.DefaultHoldType = mht
		self2.SprintHoldType = nil
		self2.IronHoldType = nil
		self2.ReloadHoldType = nil
		self2.CrouchHoldType = nil
	end

	self2.mht_old = mht

	if not self2.SprintHoldType then
		self2.SprintHoldType = self2.SprintHoldTypes[self2.DefaultHoldType] or "passive"

		if self2.SprintHoldTypeOverride and self2.SprintHoldTypeOverride ~= "" then
			self2.SprintHoldType = self2.SprintHoldTypeOverride
		end
	end

	if not self2.IronHoldType then
		self2.IronHoldType = self2.IronSightHoldTypes[self2.DefaultHoldType] or "rpg"

		if self2.IronSightHoldTypeOverride and self2.IronSightHoldTypeOverride ~= "" then
			self2.IronHoldType = self2.IronSightHoldTypeOverride
		end
	end

	if not self2.ReloadHoldType then
		self2.ReloadHoldType = self2.ReloadHoldTypes[self2.DefaultHoldType] or "ar2"

		if self2.ReloadHoldTypeOverride and self2.ReloadHoldTypeOverride ~= "" then
			self2.ReloadHoldType = self2.ReloadHoldTypeOverride
		end
	end

	if not self2.SetCrouchHoldType then
		self2.SetCrouchHoldType = true
		self2.CrouchHoldType = self2.CrouchHoldTypes[self2.DefaultHoldType]

		if self2.CrouchHoldTypeOverride and self2.CrouchHoldTypeOverride ~= "" then
			self2.CrouchHoldType = self2.CrouchHoldTypeOverride
		end
	end

	local curhold, targhold, stat
	curhold = self:GetHoldType()
	targhold = self2.DefaultHoldType
	stat = self:GetStatus()

	if dynholdtypecvar:GetBool() then
		if self:OwnerIsValid() and self:IsOwnerCrouching() and self2.CrouchHoldType then
			targhold = self2.CrouchHoldType
		else
			if self:GetIronSights() then
				targhold = self2.IronHoldType
			end

			if TFA.Enum.ReloadStatus[stat] then
				targhold = self2.ReloadHoldType
			end
		end
	end

	if self:GetSprinting() or TFA.Enum.HolsterStatus[stat] or self:IsSafety() then
		targhold = self2.SprintHoldType
	end

	if targhold ~= curhold then
		self:SetHoldType(targhold)
	end
end
--PATH lua/weapons/tfa_gun_base/common/calc.lua:
TFA.GUESS_NPC_WALKSPEED = 160

local function l_Lerp(t, a, b) return a + (b - a) * t end
local function l_mathMin(a, b) return (a < b) and a or b end
local function l_mathMax(a, b) return (a > b) and a or b end
local function l_ABS(a) return (a < 0) and -a or a end
local function l_mathClamp(t, a, b)
	if a > b then return b end

	if t > b then
		return b
	end

	if t < a then
		return a
	end

	return t
end

local function l_mathApproach(a, b, delta)
	if a < b then
		return l_mathMin(a + l_ABS(delta), b)
	else
		return l_mathMax(a - l_ABS(delta), b)
	end
end

local sprint_cv = GetConVar("sv_tfa_sprint_enabled")
local sv_tfa_weapon_weight = GetConVar("sv_tfa_weapon_weight")

function SWEP:TFAFinishMove(ply, velocity, movedata)
	local ft = FrameTime()
	local self2 = self:GetTable()
	local isply = ply:IsPlayer()

	if CLIENT then
		self2.LastUnpredictedVelocity = velocity
	end

	local speedmult = Lerp(self:GetIronSightsProgress(), sv_tfa_weapon_weight:GetBool() and self:GetStatL("RegularMoveSpeedMultiplier") or 1, self:GetStatL("AimingDownSightsSpeedMultiplier"))

	local jr_targ = math.min(math.abs(velocity.z) / 500, 1)
	self:SetJumpRatio(l_mathApproach(self:GetJumpRatio(), jr_targ, (jr_targ - self:GetJumpRatio()) * ft * 20))
	self2.JumpRatio = self:GetJumpRatio()
	self:SetCrouchingRatio(l_mathApproach(self:GetCrouchingRatio(), (self:IsOwnerCrouching()) and 1 or 0, ft / self2.ToCrouchTime))
	self2.CrouchingRatio = self:GetCrouchingRatio()

	local status = self2.GetStatus(self)
	local oldsprinting, oldwalking = self:GetSprinting(), self:GetWalking()
	local vellen = velocity:Length2D()

	--if TFA.Enum.ReloadStatus[status] then
	--  self:SetSprinting(false)
	--elseif sprint_cv:GetBool() and not self:GetStatL("AllowSprintAttack", false) and movedata then
	if sprint_cv:GetBool() and not self:GetStatL("AllowSprintAttack", false) and movedata then
		self:SetSprinting(vellen > ply:GetRunSpeed() * 0.6 * speedmult and movedata:KeyDown(IN_SPEED) and ply:OnGround())
	else
		self:SetSprinting(false)
	end

	self:SetWalking(vellen > ((isply and ply:GetWalkSpeed() or TFA.GUESS_NPC_WALKSPEED) * (sv_tfa_weapon_weight:GetBool() and self:GetStatL("RegularMoveSpeedMultiplier", 1) or 1) * .75) and ply:GetNW2Bool("TFA_IsWalking") and ply:OnGround() and not self:GetSprinting() and not self:GetCustomizing())

	self2.walking_updated = oldwalking ~= self:GetWalking()
	self2.sprinting_updated = oldsprinting ~= self:GetSprinting()

	if self:GetCustomizing() and (self2.GetIronSights(self) or self:GetSprinting() or not TFA.Enum.ReadyStatus[status]) then
		self:ToggleCustomize()
	end

	local spr = self:GetSprinting()
	local walk = self:GetWalking()

	local sprt = spr and 1 or 0
	local walkt = walk and 1 or 0
	local adstransitionspeed = (spr or walk) and 7.5 or 12.5

	self:SetSprintProgress(l_mathApproach(self:GetSprintProgress(), sprt, (sprt - self:GetSprintProgress()) * ft * adstransitionspeed))
	self:SetWalkProgress(l_mathApproach(self:GetWalkProgress(), walkt, (walkt - self:GetWalkProgress()) * ft * adstransitionspeed))

	self:SetLastVelocity(vellen)
end

local sp = game.SinglePlayer()
local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")

function SWEP:CalculateRatios()
	local owent = self:GetOwner()
	--if not IsValid(owent) or not owent:IsPlayer() then return end
	if not IsValid(owent) then return end

	local self2 = self:GetTable()

	if self2.ratios_calc == nil then
		self2.ratios_calc = true
	end

	local ft = FrameTime()
	local time = CurTime()

	if ft <= 0 then return end

	local is = self2.GetIronSights(self)
	local spr = self2.GetSprinting(self)
	local walk = self2.GetWalking(self)

	local ist = is and 1 or 0
	local sprt = spr and 1 or 0

	local adstransitionspeed
	if is then
		adstransitionspeed = 12.5 / (self:GetStatL("IronSightTime") / 0.3)
	elseif spr or walk then
		adstransitionspeed = 7.5
	else
		adstransitionspeed = 12.5
	end
	adstransitionspeed = math.min(adstransitionspeed, 1000)

	if not owent:IsPlayer() then
		self:TFAFinishMove(owent, owent:GetVelocity())
	end

	local lastshoottime = self2.GetLastGunFire(self, -1)

	if lastshoottime < 0 or time >= (lastshoottime + self2.GetStatL(self, "Primary.SpreadRecoveryDelay")) then
		self:SetSpreadRatio(l_mathClamp(self:GetSpreadRatio() - self2.GetStatL(self, "Primary.SpreadRecovery") * ft, 1, self2.GetStatL(self, "Primary.SpreadMultiplierMax")))
	end

	self:SetIronSightsProgress(l_mathApproach(self:GetIronSightsProgress(), ist, (ist - self:GetIronSightsProgress()) * ft * adstransitionspeed))
	self:SetProceduralHolsterProgress(l_mathApproach(self:GetProceduralHolsterProgress(), sprt, (sprt - self:GetSprintProgress()) * ft * self2.ProceduralHolsterTime * 15))
	self:SetInspectingProgress(l_mathApproach(self:GetInspectingProgress(), self:GetCustomizing() and 1 or 0, ((self:GetCustomizing() and 1 or 0) - self:GetInspectingProgress()) * ft * 10))

	if self:GetRecoilThink() then
		if self:GetRecoilLoop() then
			-- loop or after loop

			if self:GetRecoilLoopWait() < time then
				self:SetRecoilOutProgress(l_mathMin(1, self:GetRecoilOutProgress() + ft / self2.Primary_TFA.RecoilLUT["out"].cooldown_speed))

				if self:GetRecoilOutProgress() == 1 then
					self:SetRecoilThink(false)
					self:SetRecoilLoop(false)
					self:SetRecoilLoopProgress(0)
					self:SetRecoilInProgress(0)
					self:SetRecoilOutProgress(0)
				end
			end
		else
			-- IN only

			if self:GetRecoilInWait() < time then
				self:SetRecoilInProgress(l_mathMax(0, self:GetRecoilInProgress() - ft / self2.Primary_TFA.RecoilLUT["in"].cooldown_speed))

				if self:GetRecoilInProgress() == 0 then
					self:SetRecoilThink(false)
				end
			end
		end
	end

	if not sv_tfa_recoil_legacy:GetBool() then
		ft = l_mathClamp(ft, 0, 1)
		self:SetViewPunchBuild(l_mathMax(0, self:GetViewPunchBuild() - self:GetViewPunchBuild() * ft))
		local build = l_mathMax(0, 4.5 - self:GetViewPunchBuild())
		ft = ft * build * build
		self:SetViewPunchP(self:GetViewPunchP() - self:GetViewPunchP() * ft)
		self:SetViewPunchY(self:GetViewPunchY() - self:GetViewPunchY() * ft)
	end

	self2.SpreadRatio = self:GetSpreadRatio()
	self2.IronSightsProgress = self:GetIronSightsProgress()
	self2.SprintProgress = self:GetSprintProgress()
	self2.WalkProgress = self:GetWalkProgress()
	self2.ProceduralHolsterProgress = self:GetProceduralHolsterProgress()
	self2.InspectingProgress = self:GetInspectingProgress()

	if sp and CLIENT then
		self2.Inspecting = self:GetCustomizing() --compatibility
	end

	self2.CLIronSightsProgress = self:GetIronSightsProgress() --compatibility
end

SWEP.Primary.IronRecoilMultiplier = 0.5 --Multiply recoil by this factor when we're in ironsights.  This is proportional, not inversely.
SWEP.CrouchRecoilMultiplier = 0.65 --Multiply recoil by this factor when we're crouching.  This is proportional, not inversely.
SWEP.JumpRecoilMultiplier = 1.3 --Multiply recoil by this factor when we're crouching.  This is proportional, not inversely.
SWEP.WallRecoilMultiplier = 1.1 --Multiply recoil by this factor when we're changing state e.g. not completely ironsighted.  This is proportional, not inversely.
SWEP.ChangeStateRecoilMultiplier = 1.3 --Multiply recoil by this factor when we're crouching.  This is proportional, not inversely.
SWEP.CrouchAccuracyMultiplier = 0.5 --Less is more.  Accuracy * 0.5 = Twice as accurate, Accuracy * 0.1 = Ten times as accurate
SWEP.ChangeStateAccuracyMultiplier = 1.5 --Less is more.  A change of state is when we're in the progress of doing something, like crouching or ironsighting.  Accuracy * 2 = Half as accurate.  Accuracy * 5 = 1/5 as accurate
SWEP.JumpAccuracyMultiplier = 2 --Less is more.  Accuracy * 2 = Half as accurate.  Accuracy * 5 = 1/5 as accurate
SWEP.WalkAccuracyMultiplier = 1.35 --Less is more.  Accuracy * 2 = Half as accurate.  Accuracy * 5 = 1/5 as accurate
SWEP.ToCrouchTime = 0.25

local mult_cvar = GetConVar("sv_tfa_spread_multiplier")
local rec_cvar = GetConVar("sv_tfa_recoil_multiplier")
local dynacc_cvar = GetConVar("sv_tfa_dynamicaccuracy")
local ccon, crec

SWEP.JumpRatio = 0

function SWEP:CalculateConeRecoil()
	local dynacc = false
	local self2 = self:GetTable()
	local isr = self:GetIronSightsProgress()

	if dynacc_cvar:GetBool() and (self2.GetStatL(self, "Primary.NumShots") <= 1) then
		dynacc = true
	end

	local isr_1 = l_mathClamp(isr * 2, 0, 1)
	local isr_2 = l_mathClamp((isr - 0.5) * 2, 0, 1)
	local acv = self2.GetStatL(self, "Primary.Spread") or self2.GetStatL(self, "Primary.Accuracy")
	local recv = self2.GetStatL(self, "Primary.Recoil") * 5

	if dynacc then
		ccon = l_Lerp(isr_2, l_Lerp(isr_1, acv, acv * self2.GetStatL(self, "ChangeStateAccuracyMultiplier")), self2.GetStatL(self, "Primary.IronAccuracy"))
		crec = l_Lerp(isr_2, l_Lerp(isr_1, recv, recv * self2.GetStatL(self, "ChangeStateRecoilMultiplier")), recv * self2.GetStatL(self, "Primary.IronRecoilMultiplier"))
	else
		ccon = l_Lerp(isr, acv, self2.GetStatL(self, "Primary.IronAccuracy"))
		crec = l_Lerp(isr, recv, recv * self2.GetStatL(self, "Primary.IronRecoilMultiplier"))
	end

	local crc_1 = l_mathClamp(self:GetCrouchingRatio() * 2, 0, 1)
	local crc_2 = l_mathClamp((self:GetCrouchingRatio() - 0.5) * 2, 0, 1)

	if dynacc then
		ccon = l_Lerp(crc_2, l_Lerp(crc_1, ccon, ccon * self2.GetStatL(self, "ChangeStateAccuracyMultiplier")), ccon * self2.GetStatL(self, "CrouchAccuracyMultiplier"))
		crec = l_Lerp(crc_2, l_Lerp(crc_1, crec, self2.GetStatL(self, "Primary.Recoil") * self2.GetStatL(self, "ChangeStateRecoilMultiplier")), crec * self2.GetStatL(self, "CrouchRecoilMultiplier"))
	end

	local owner = self:GetOwner()
	local isply = owner:IsPlayer()
	local ovel

	if IsValid(owner) then
		if owner:IsPlayer() then
			ovel = self:GetLastVelocity()
		else
			ovel = owner:GetVelocity():Length2D()
		end
	else
		ovel = 0
	end

	local vfc_1 = l_mathClamp(ovel / (isply and owner:GetWalkSpeed() or TFA.GUESS_NPC_WALKSPEED), 0, 2)

	if dynacc then
		ccon = l_Lerp(vfc_1, ccon, ccon * self2.GetStatL(self, "WalkAccuracyMultiplier"))
		crec = l_Lerp(vfc_1, crec, crec * self2.GetStatL(self, "WallRecoilMultiplier"))
	end

	local jr = self:GetJumpRatio()

	if dynacc then
		ccon = l_Lerp(jr, ccon, ccon * self2.GetStatL(self, "JumpAccuracyMultiplier"))
		crec = l_Lerp(jr, crec, crec * self2.GetStatL(self, "JumpRecoilMultiplier"))
	end

	ccon = ccon * self:GetSpreadRatio()

	ccon = ccon * mult_cvar:GetFloat()
	crec = crec * rec_cvar:GetFloat()

	if not isply and IsValid(owner) then
		local prof = owner:GetCurrentWeaponProficiency()

		if prof == WEAPON_PROFICIENCY_POOR then
			ccon = ccon * 8
		elseif prof == WEAPON_PROFICIENCY_AVERAGE then
			ccon = ccon * 5
		elseif prof == WEAPON_PROFICIENCY_GOOD then
			ccon = ccon * 3
		elseif prof == WEAPON_PROFICIENCY_VERY_GOOD then
			ccon = ccon * 2
		elseif prof == WEAPON_PROFICIENCY_PERFECT then
			ccon = ccon * 1.5
		end
	end

	return ccon, crec
end

--PATH lua/weapons/tfa_gun_base/common/events.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/client/viewmodel.lua:
return gluapack()()
--PATH lua/weapons/tfa_sword_advanced_base.lua:
return gluapack()()
--PATH addons/!jobs/lua/weapons/weapon_ak47custom/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_bactainjector.lua:
return gluapack()()
--PATH lua/weapons/weapon_bactainjector.lua:
AddCSLuaFile()

SWEP.VElements = {
	["element_name++++"] = { type = "Model", model = "models/starwars/items/bacta_small.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(0, 0.002, -4.908), angle = Angle(0, 0, 0), size = Vector(0.559, 0.559, 0.559), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["Ammo"] = { type = "Model", model = "models/starwars/items/energy_cell.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(4.984, 2.936, 0), angle = Angle(0, 45.988, -4.062), size = Vector(0.367, 0.367, 0.367), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["element_name"] = { type = "Model", model = "models/props_phx/construct/glass/glass_curve360x1.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(0, 0, -4.4), angle = Angle(0, 0, 0), size = Vector(0.035, 0.035, 0.114), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/props_combine/cit_beacon", skin = 0, bodygroup = {} },
	["element_name+++"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(0, 0, 9.295), angle = Angle(0, 0, -90), size = Vector(0.224, 1.134, 0.224), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["element_name+"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(0, 0, 0.737), angle = Angle(0, 0, -90), size = Vector(0.703, 1.223, 0.703), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["element_name++"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(0, 0, -3.62), angle = Angle(0, 0, -90), size = Vector(1.582, 0.586, 1.195), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/props_wasteland/lighthouse_stairs", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["element_name++"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.675, 1.557, -2.597), angle = Angle(0, 0, -90), size = Vector(1, 1, 1), color = Color(0, 255, 255, 255), surpresslightning = false, material = "models/props_wasteland/lighthouse_stairs", skin = 0, bodygroup = {} },
	["element_name+"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.675, 1.557, 2.596), angle = Angle(0, 0, -90), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["element_name"] = { type = "Model", model = "models/starwars/items/bacta_small.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.675, 1.557, -6.753), angle = Angle(0, 0, 0), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.HoldType = "slam"

SWEP.ViewModelFlip = false 

SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/starwars/items/bacta_small.mdl"
--SWEP.WorldModel = ""
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0.071, 0, 0) },
	["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-0.673, -1.879, 0) },
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1.003, 1.003, 1.003), pos = Vector(0, 0, 0), angle = Angle(-37.258, 52.847, 4.78) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(-3.245, 2.427, 0), angle = Angle(14.444, -16.667, 50) }
}

SWEP.PrintName				= "Bacta Injector"
SWEP.Author					= "robotboy655 & Riddick"
SWEP.Purpose			= "Heal people with your primary attack, or yourself with the secondary. Provide ammo with Reload"

SWEP.Slot					= 5
SWEP.SlotPos				= 4

SWEP.Spawnable				= true

--SWEP.ViewModel				= Model( "models/weapons/c_medkit.mdl" )
--SWEP.WorldModel				= Model( "models/weapons/w_medkit.mdl" )
SWEP.ViewModelFOV			= 65
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= 200
SWEP.Primary.DefaultClip	= 200
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"


SWEP.HealAmount				= 100	-- Maximum heal amount per use
SWEP.MaxAmmo				= 200	-- Maxumum ammo


local HealSound = Sound( "HealthKit.Touch" )
local DenySound = Sound( "WallHealth.Deny" )

function SWEP:Initialize()
	
	self:SetHoldType( "slam" )
	--self.Owner:GetViewModel( ):SetMaterial( "materials/reskin/healthkit01.vtf" )
	if ( CLIENT ) then 
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		end 

	timer.Create( "medkit_ammo" .. self:EntIndex(), .2, 0, function()
		if ( self:Clip1() < self.MaxAmmo ) then self:SetClip1( math.min( self:Clip1() + 100, self.MaxAmmo ) ) end
	end )

end

function SWEP:PrimaryAttack()

	if ( CLIENT ) then return end

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 128,
		filter = self.Owner
	} )

	local ent = tr.Entity
	
	local need
	if ( IsValid( ent ) ) then need = math.min( ent.var - ent:Health(), ent.var * .25 ) end

	if ( IsValid( ent ) && self:Clip1() >= 50 && ( ent:IsPlayer() || ent:IsNPC() ) && ent:Health() < ent.var ) then

		self:TakePrimaryAmmo( 50 )

		ent:SetHealth( math.min( ent.var, ent:Health() + need ) )
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() + 0 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		-- Even though the viewmodel has looping IDLE anim at all times, we need this to make fire animation work in multiplayer
		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )

	else

		self.Owner:EmitSound( DenySound )
		self:SetNextPrimaryFire( CurTime() + .1 )

	end

end

function SWEP:Reload()

	if ( CLIENT ) then return end

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 128,
		filter = self.Owner
	} )

	local ent = tr.Entity
	local me = self.Owner
	
	local need = self.HealAmount
	

	if ( IsValid( ent ) && self:Clip1() >= 100 && ( ent:IsPlayer()))  then

		self:TakePrimaryAmmo( 100 )

		ent:GiveAmmo(1000, 1, false)
		me:GiveAmmo(1000, 1, false)
		//ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() + 0 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		-- Even though the viewmodel has looping IDLE anim at all times, we need this to make fire animation work in multiplayer
		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )
--[[
	elseif( ( IsValid( ent ) && self:Clip1() >= 100)) then 
	self.Owner:GiveAmmo(2000, 1, false)
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() + 0 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		-- Even though the viewmodel has looping IDLE anim at all times, we need this to make fire animation work in multiplayer
		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )
	]]--
	else

		
		self:SetNextPrimaryFire( CurTime() + 1 )

	end

end

function SWEP:SecondaryAttack()

	if ( CLIENT ) then return end

	local ent = self.Owner
	--print (ent.var)
	local need
	
	if ( IsValid( ent ) ) then need = ent.var * .1 end
	
	if ( IsValid( ent ) && self:Clip1() >= need && ent:Health() < ent.var ) then

		self:TakePrimaryAmmo( need )

		ent:SetHealth( math.min( ent.var, ent:Health() + need ) )
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		--self:SetNextSecondaryFire( CurTime() + self:SequenceDuration() + 1 )
		self:SetNextSecondaryFire( CurTime() + 1 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )

	else

		ent:EmitSound( DenySound )
		self:SetNextSecondaryFire( CurTime() + 1 )

	end

	end


function SWEP:OnRemove()

	timer.Stop( "medkit_ammo" .. self:EntIndex() )
	timer.Stop( "weapon_idle" .. self:EntIndex() )
	self:Holster()

end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	

	timer.Stop( "weapon_idle" .. self:EntIndex() )
	
	return true

end

function SWEP:CustomAmmoDisplay()

	self.AmmoDisplay = self.AmmoDisplay or {} 
	self.AmmoDisplay.Draw = true
	self.AmmoDisplay.PrimaryClip = self:Clip1()

	return self.AmmoDisplay

end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)
		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end
		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
			
		end
		
	end
	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )
		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then
			self.wRenderOrder = {}
			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
			
		end
		
	end
	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)
			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end
	function SWEP:CreateModels( tab )
		if (!tab) then return end
		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

--PATH addons/[fix] wiltos_animation_fix/lua/weapons/weapon_base/sh_anim.lua:
-- "addons\\wosanim_fixes\\lua\\weapons\\weapon_base\\sh_anim.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
local ActIndex = {
	[ "pistol" ] 		= ACT_HL2MP_IDLE_PISTOL,
	[ "smg" ] 			= ACT_HL2MP_IDLE_SMG1,
	[ "grenade" ] 		= ACT_HL2MP_IDLE_GRENADE,
	[ "ar2" ] 			= ACT_HL2MP_IDLE_AR2,
	[ "shotgun" ] 		= ACT_HL2MP_IDLE_SHOTGUN,
	[ "rpg" ]	 		= ACT_HL2MP_IDLE_RPG,
	[ "physgun" ] 		= ACT_HL2MP_IDLE_PHYSGUN,
	[ "crossbow" ] 		= ACT_HL2MP_IDLE_CROSSBOW,
	[ "melee" ] 		= ACT_HL2MP_IDLE_MELEE,
	[ "slam" ] 			= ACT_HL2MP_IDLE_SLAM,
	[ "normal" ]		= ACT_HL2MP_IDLE,
	[ "fist" ]			= ACT_HL2MP_IDLE_FIST,
	[ "melee2" ]		= ACT_HL2MP_IDLE_MELEE2,
	[ "passive" ]		= ACT_HL2MP_IDLE_PASSIVE,
	[ "knife" ]			= ACT_HL2MP_IDLE_KNIFE,
	[ "duel" ]			= ACT_HL2MP_IDLE_DUEL,
	[ "camera" ]		= ACT_HL2MP_IDLE_CAMERA,
	[ "magic" ]			= ACT_HL2MP_IDLE_MAGIC,
	[ "revolver" ]		= ACT_HL2MP_IDLE_REVOLVER
}

--[[---------------------------------------------------------
   Name: SetWeaponHoldType
   Desc: Sets up the translation table, to translate from normal 
			standing idle pose, to holding weapon pose.
-----------------------------------------------------------]]
function SWEP:SetWeaponHoldType( t )

	t = string.lower( t )
	local index = ActIndex[ t ]
	
	if ( index == nil ) and !wOS.AnimExtension.TranslateHoldType[ t ] then
		Msg( "SWEP:SetWeaponHoldType - ActIndex[ \""..t.."\" ] isn't set! (defaulting to normal)\n" )
		t = "normal"
		index = ActIndex[ t ]		
	end
	
	if wOS.AnimExtension.TranslateHoldType[ t ] then 
		self.ActivityTranslate = table.Copy( wOS.AnimExtension.TranslateHoldType[ t ]:GetActivityList() )
	else
		self.ActivityTranslate = {}
		self.ActivityTranslate [ ACT_MP_STAND_IDLE ] 				= index
		self.ActivityTranslate [ ACT_MP_WALK ] 						= index+1
		self.ActivityTranslate [ ACT_MP_RUN ] 						= index+2
		self.ActivityTranslate [ ACT_MP_CROUCH_IDLE ] 				= index+3
		self.ActivityTranslate [ ACT_MP_CROUCHWALK ] 				= index+4
		self.ActivityTranslate [ ACT_MP_ATTACK_STAND_PRIMARYFIRE ] 	= index+5
		self.ActivityTranslate [ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ] = index+5
		self.ActivityTranslate [ ACT_MP_RELOAD_STAND ]		 		= index+6
		self.ActivityTranslate [ ACT_MP_RELOAD_CROUCH ]		 		= index+6
		self.ActivityTranslate [ ACT_MP_JUMP ] 						= index+7
		self.ActivityTranslate [ ACT_RANGE_ATTACK1 ] 				= index+8
		self.ActivityTranslate [ ACT_MP_SWIM ] 						= index+9	
	end
	
	-- "normal" jump animation doesn't exist
	if t == "normal" then
		self.ActivityTranslate [ ACT_MP_JUMP ] = ACT_HL2MP_JUMP_SLAM
	end

	self:SetupWeaponHoldTypeForAI( t )

end

-- Default hold pos is the pistol
SWEP:SetWeaponHoldType( "pistol" )

--[[---------------------------------------------------------
   Name: weapon:TranslateActivity( )
   Desc: Translate a player's Activity into a weapon's activity
		 So for example, ACT_HL2MP_RUN becomes ACT_HL2MP_RUN_PISTOL
		 Depending on how you want the player to be holding the weapon
-----------------------------------------------------------]]
function SWEP:TranslateActivity( act )

	if ( self.Owner:IsNPC() ) then
		if ( self.ActivityTranslateAI[ act ] ) then
			return self.ActivityTranslateAI[ act ]
		end
		return -1
	end

	if ( self.ActivityTranslate[ act ] != nil ) then
		return self.ActivityTranslate[ act ]
	end

	return -1

end
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_base.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2pipe/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Pipe"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pipe.mdl" )
SWEP.WorldModel				= Model( "models/props_canal/mattpipe.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 40
SWEP.HitInclination		= 0.2
SWEP.HitPushback		= 400
SWEP.HitRate			= 1.10
SWEP.MinDamage			= 20
SWEP.MaxDamage			= 27

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()
	
	return true
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 34, 50 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	return true
end
--PATH lua/weapons/weapon_hl2pot/shared.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/cl_init.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/sh_blockpoints.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrohammer.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_forcepike.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Force Pike"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("forcepike") 
		self:SetBladeR("forcepikecrys") 
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_mandostaff.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_skreejipike.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Skreeji Pike"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("skreejipike") 
		self:SetBladeR("skreejipikecrys") 
	end
end
--PATH addons/[medic] defib/lua/weapons/weapon_ncs_defib/shared.lua:
if (SERVER) then
    AddCSLuaFile()
end

SWEP.PrintName = "Defibrillator"
SWEP.Author = ""
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.AdminSpawnable = true
SWEP.Spawnable = true
SWEP.WorldModel         = Model("models/weapons/custom/w_defib.mdl")
SWEP.ViewModel          = Model("models/weapons/custom/v_defib.mdl")
SWEP.UseHands = true

if (CLIENT) then
    SWEP.Category				= "[NCS] Defibrillator"
    SWEP.Slot = 4
    SWEP.SlotPos = 2
    SWEP.ViewModelFOV = 69
    SWEP.DrawCrosshair = true
    SWEP.DrawAmmo = true
end

SWEP.Primary.Ammo = "None"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Delay = 2
SWEP.Primary.Automatic = false
SWEP.Secondary.Ammo = "None"
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.ClipSize = -1

function SWEP:Initialize()
    self.lastPrimaryFire = CurTime()
end

function SWEP:Deploy()
	self.Weapon:SendWeaponAnim( ACT_VM_DEPLOY )
	self.Weapon:SetNoDraw(true)
end

function SWEP:PrimaryAttack()
    local eyeTrace = self:GetOwner():GetEyeTrace()

    if eyeTrace and IsValid(eyeTrace.Entity) and eyeTrace.Entity:GetClass() == "prop_ragdoll" then
        local E = eyeTrace.Entity

        if E:GetPos():DistToSqr(self:GetOwner():GetPos()) > 2000 then return end

        self:GetOwner():SetAnimation(PLAYER_ATTACK1)
        self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)

        if E.playerOwner then
            local canRevive = hook.Run("NCS_DEFIB_PrePlayerRevive", E.playerOwner, self:GetOwner(), E)
            if ( canRevive == false ) then return end

            NCS_DEFIBRILLATOR.PlayerRevive(E.playerOwner)
            
            hook.Run("NCS_DEFIB_PostPlayerRevive", E.playerOwner, self:GetOwner())

            self:SetNextSecondaryFire(CurTime() + 5)

            self:GetOwner():EmitSound("ncs_defib/defib_shock.wav")

            timer.Simple(5, function()
                if !IsValid(self) or !IsValid(self:GetOwner()) then return end
                if self:GetOwner():GetActiveWeapon() ~= self then return end

                self:GetOwner():EmitSound("ncs_defib/defib_recharge.wav")
            end )

            if NCS_DEFIBRILLATOR.CONFIG.defibUsage then
                self.reviveCount = self.reviveCount or 0
                self.reviveCount = self.reviveCount + 1

                if self.reviveCount >= NCS_DEFIBRILLATOR.CONFIG.defibUsage then
                    self:GetOwner():EmitSound("ncs_defib/defib_break.wav")

                    self:GetOwner():StripWeapon(self:GetClass())
                end
            end
        end
    end
end

function SWEP:Initialize()
	self:SetHoldType("knife")
end
--PATH lua/weapons/weapon_policebaton/shared.lua:
AddCSLuaFile()
if SERVER then
    AddCSLuaFile("cl_init.lua")
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Downloading content from workshop
---------------------------------------------------------------------------------------------------------------------------------------------
*/	

if SERVER then resource.AddWorkshop("2441210098"); end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Config
---------------------------------------------------------------------------------------------------------------------------------------------
*/

SWEP.hitRequireForStun = 2;
SWEP.stunTime = 5;
SWEP.primaryFireDamage = 0;

SWEP.primaryFireDelay = 0.5;
SWEP.secondaryFireDelay = 2;
/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Default SWEP config
---------------------------------------------------------------------------------------------------------------------------------------------
*/

SWEP.reloadCooldown = CurTime();
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.Author = "Drover | Edit by Mickerd"
SWEP.Contact = "Discord: Mickerd#1593"
SWEP.Purpose = ""
SWEP.IconLetter = ""
SWEP.PrintName = "Police Baton"
SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "physgun"
SWEP.HoldType ="physgun"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Police Baton" 


SWEP.UseHands = true;
SWEP.ViewModel = Model("models/drover/baton.mdl");
SWEP.WorldModel = Model("models/drover/w_baton.mdl");

local SwingSound = Sound( "WeaponFrag.Throw" );
local HitSound = Sound( "Flesh.ImpactHard" );



SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Initialize
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:Initialize()
    self:SetHoldType("melee");
end



function SWEP:SetupShield()

end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Hook Can Drop Weapon
---------------------------------------------------------------------------------------------------------------------------------------------
*/

hook.Add("canDropWeapon", "NoDropPoliceBaton",function(ply, ent)
	if ent:GetClass() == "weapon_policebaton" then
		return false;
	end
end)

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Some functions
---------------------------------------------------------------------------------------------------------------------------------------------
*/


SWEP.menuButtons = {};
SWEP.menuButtons[1] = {}
SWEP.menuButtons[1].buttonText = "Unarrest";
SWEP.menuButtons[1].left = true;
SWEP.menuButtons[1].func = function(owner,ent)
	if owner:GetPos():Distance(ent:GetPos()) > 150 then return end;
--	if not ent.stunnedBaton then return end;
	if not ent:isArrested() then return end;
	ent:unArrest(owner);
end


SWEP.menuButtons[3] = {}
SWEP.menuButtons[3].buttonText = "Arrest";
SWEP.menuButtons[3].left = true;
SWEP.menuButtons[3].func = function(owner,ent)
	if owner:GetPos():Distance(ent:GetPos()) > 150 then return end;
	if not ent.stunnedBaton then DarkRP.notify(owner, 1, 4, "Target needs to be stunned!") return end;
	if ent:isArrested() then  ent:arrest(nil, owner) return end;
	if ent:isCP() and not GAMEMODE.Config.cpcanarrestcp then return end;
	local jpc = DarkRP.jailPosCount()
    if not jpc or jpc == 0 then
        DarkRP.notify(owner, 1, 4, DarkRP.getPhrase("cant_arrest_no_jail_pos"))
    else
        if not ent.Babygod then
            ent:arrest(nil, owner)
            DarkRP.notify(ent, 0, 20, DarkRP.getPhrase("youre_arrested_by", owner:Nick()))
            if owner.SteamName then
                DarkRP.log(owner:Nick() .. " (" .. owner:SteamID() .. ") arrested " .. ent:Nick(), Color(0, 255, 255))
            end
        else
            DarkRP.notify(owner, 1, 4, DarkRP.getPhrase("cant_arrest_spawning_players"))
        end
    end
end


SWEP.menuButtons[2] = {}
SWEP.menuButtons[2].buttonText = "Wanted";
SWEP.menuButtons[2].left = false;
SWEP.menuButtons[2].func = function(owner,ent)

end



SWEP.menuButtons[4] = {}
SWEP.menuButtons[4].buttonText = "Warrant";
SWEP.menuButtons[4].left = false;
SWEP.menuButtons[4].func = function(owner,ent)

end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Reload
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:Reload()
	if self.reloadCooldown + 2 > CurTime() then return end;
	self.reloadCooldown = CurTime();
	if CLIENT then return end
	self.Weapon:SendWeaponAnim( ACT_VM_RELOAD);
end	


function SWEP:Draw()
	self:SendWeaponAnim(ACT_VM_DRAW);
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
end	

local drawMenu = false;
if CLIENT then
	hook.Add("PlayerBindPress","test1", function(ply,bind,pressed)
		local weap = ply:GetActiveWeapon();
		if weap == nil or weap == NULL or not IsValid(weap) or weap:GetClass() !="weapon_policebaton" then return end;
		if string.find(bind,"+reload") then 
			gui.EnableScreenClicker(true);
			weap.drawMenu = true;			
		end
	end)
	
	hook.Add("KeyRelease","test2",function(ply,key)
		local weap = ply:GetActiveWeapon();
		if weap == nil or weap == NULL or not IsValid(weap) or weap:GetClass() !="weapon_policebaton" then return end;
		if key == IN_RELOAD then
			gui.EnableScreenClicker(false);
			weap.drawMenu = false;
			net.Start("batondrawbut") net.SendToServer();
			
		end
	end)
	



end



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Baton Stun / Unstun
---------------------------------------------------------------------------------------------------------------------------------------------
*/
function SWEP:Stun(ply)
	local ang = ply:GetAngles();
	ply:SetEyeAngles(Angle(60,ang.y,ang.r));
	ply:Freeze(true);
	ply.stunnedBaton = true;
	ply:SetNWInt('batonstuntime',CurTime());
	net.Start("batonstunanim") net.WriteEntity(ply) net.WriteBool(true) net.Broadcast();
	timer.Create("unstunbatonstun"..tostring(ply:EntIndex()),self.stunTime,1,function()
		if IsValid(ply) then 
			ply:Freeze(false);
			ply.stunnedBaton = false;
			net.Start("batonstunanim") net.WriteEntity(ply) net.WriteBool(false) net.Broadcast();
		end
	end)
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Attack Player
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:AttackPlayer(ply)
	if not IsValid(ply) or not ply:IsPlayer() then return end;
	self.Owner:EmitSound(Sound("Flesh.ImpactHard"));
	ply:SetVelocity((ply:GetPos() - self:GetOwner():GetPos()) * 2);
	if ply.stunnedBaton == true then return end;
	local hits = ply.hitByBaton or 0;
	local lTime = ply.lastBatonHit or CurTime();
	if CurTime() > lTime + 3 then 
		hits = 0; 
	end
	local numb = 1;
	if ply:isArrested() then numb = 1000 end;
	ply.hitByBaton = hits + numb;
	ply.lastBatonHit = CurTime();
	if hits + numb >= self.hitRequireForStun then
		self:Stun(ply);
	end
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Attack Entity
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:AttackEnt(ent,dmg)
		self.Owner:EmitSound(Sound("physics/wood/wood_box_impact_hard3.wav"));
        if FPP and FPP.plyCanTouchEnt(self:GetOwner(), ent, "EntityDamage") then
			if ent.SeizeReward and not ent.beenSeized and not ent.burningup and self:GetOwner():isCP() and ent.Getowning_ent and self:GetOwner() ~= ent:Getowning_ent() then
				 self:GetOwner():addMoney(ent.SeizeReward);
				 DarkRP.notify(self:GetOwner(), 1, 4, DarkRP.getPhrase("you_received_x", DarkRP.formatMoney(ent.SeizeReward), DarkRP.getPhrase("bonus_destroying_entity")));
				ent.beenSeized = true;
			 end
         ent:TakeDamage(dmg, self:GetOwner(), self);
		end
end
/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Make Hit
---------------------------------------------------------------------------------------------------------------------------------------------
*/
local entMeta = FindMetaTable("Entity");
function SWEP:MakeHit(dmg)
	self:GetOwner():SetAnimation(PLAYER_ATTACK1);
    if CLIENT then return end;
    local trace = util.QuickTrace(self:GetOwner():EyePos(), self:GetOwner():GetAimVector() * 90, {self:GetOwner()});
    
    if IsValid(trace.Entity) and trace.Entity:GetClass() == "func_breakable_surf" then
        trace.Entity:Fire("Shatter"); 
        return;
    end

	local ent = self:GetOwner():getEyeSightHitEntity(100, 15, fn.FAnd{fp{fn.Neq, self:GetOwner()}, fc{IsValid, entMeta.GetPhysicsObject}});
    if not IsValid(ent) then return end;
    if ent:IsPlayer() and not ent:Alive() then return end;

    

    if ent:IsPlayer() 	then
		self:AttackPlayer(ent);
		if dmg > 0 then
			ent:TakeDamage(dmg, self:GetOwner(), self);
		end
    elseif !ent:IsNPC() or !ent:IsVehicle() then
        self:AttackEnt(ent,dmg);
    end
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Primary attack
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:PrimaryAttack()
	self:SetHoldType("melee");
	self:SetNextPrimaryFire(CurTime() + self.primaryFireDelay);
	self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK );
	self:GetOwner():EmitSound(SwingSound);
	self:MakeHit(0);
	
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Secondary attack / Deploy static shield
---------------------------------------------------------------------------------------------------------------------------------------------
*/
function SWEP:SecondaryAttack()
	self:SetNextSecondaryFire(CurTime() + self.secondaryFireDelay);
	self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK );
	self:GetOwner():EmitSound(SwingSound);
	self:MakeHit(self.primaryFireDamage)
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Network initialize && Client Receive
---------------------------------------------------------------------------------------------------------------------------------------------
*/

if SERVER then
	util.AddNetworkString("batonstunanim");
	util.AddNetworkString("batonsendfunc");
	util.AddNetworkString("batondrawbut");
	
	
	net.Receive("batonsendfunc",function(leng,ply)
		local id = net.ReadInt(3);
		local enemy = net.ReadEntity();
		if not IsValid(enemy) or not enemy:IsPlayer() or not enemy:Alive() then return end;
		if ply:GetActiveWeapon():GetClass() != "weapon_policebaton" then return end;
		ply:GetActiveWeapon().menuButtons[id].func(ply,enemy);
	end)
	
	net.Receive("batondrawbut",function(leng,ply)
		local enemy = net.ReadEntity();
		if ply:GetActiveWeapon():GetClass() != "weapon_policebaton" then return end;
		ply:GetActiveWeapon():Draw();
	end)
end

if CLIENT then
	net.Receive("batonstunanim",function()
		local ply = net.ReadEntity();
		local enable = net.ReadBool();
		if IsValid(ply) and ply:IsPlayer() and ply:Alive() then
			if enable then
				ply:AnimRestartGesture( GESTURE_SLOT_CUSTOM,ACT_HL2MP_IDLE_SLAM, false);   
			else
				ply:AnimResetGestureSlot(GESTURE_SLOT_CUSTOM );
			end
		end	
	end)	
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Deploy && Holster && Drop && Remove
---------------------------------------------------------------------------------------------------------------------------------------------
*/




function SWEP:Deploy()
	return true
end

function SWEP:Holster()
	return true;
end


function SWEP:OnDrop()
	return true;
end

function SWEP:OnRemove()
	return true;
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Draw circles
---------------------------------------------------------------------------------------------------------------------------------------------
*/


--PATH lua/weapons/weapon_vj_357/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_base/ai_translations.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_crowbar/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base = "weapon_vj_base"
SWEP.PrintName = "Crowbar"
SWEP.Author = "DrVrej"
SWEP.Contact = "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose = "This weapon is made for Players and NPCs"
SWEP.Instructions = "Controls are like a regular weapon."
SWEP.Category = "VJ Base"
SWEP.MadeForNPCsOnly = true -- Is this weapon meant to be for NPCs only?
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_NextPrimaryFire = 1 -- Next time it can use primary fire
SWEP.NPC_TimeUntilFire = 0.5 -- How much time until the bullet/projectile is fired?
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.WorldModel = "models/weapons/w_crowbar.mdl"
SWEP.HoldType = "melee"
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage = 20 -- Damage
SWEP.IsMeleeWeapon = true -- Should this weapon be a melee weapon?
--PATH lua/weapons/weapon_vj_k3/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_m16a1/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "M4A1"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 2 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 4 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.SwayScale 					= 1 -- Default is 1, The scale of the viewmodel sway
SWEP.UseHands					= true
end
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/weapons/cstrike/c_rif_m4a1.mdl"
SWEP.WorldModel					= "models/vj_weapons/w_csgo_m4a1_s.mdl"
SWEP.WorldModel_UseCustomPosition = true -- Should the gun use custom position? This can be used to fix guns that are in the crotch
SWEP.WorldModel_CustomPositionAngle = Vector(0, 90, 180)
SWEP.WorldModel_CustomPositionOrigin = Vector(-3.4, -1, 0)
SWEP.HoldType 					= "ar2"
SWEP.ViewModelFlip				= false -- Flip the model? Usally used for CS:S models
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage				= 5 -- Damage
SWEP.Primary.PlayerDamage		= "Double" -- Only applies for players | "Same" = Same as self.Primary.Damage, "Double" = Double the self.Primary.Damage OR put a number to be different from self.Primary.Damage
SWEP.Primary.Force				= 5 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize			= 30 -- Max amount of bullets per clip
SWEP.Primary.Recoil				= 0.3 -- How much recoil does the player get?
SWEP.Primary.Delay				= 0.1 -- Time until it can shoot again
SWEP.Primary.Automatic			= true -- Is it automatic?
SWEP.Primary.Ammo				= "SMG1" -- Ammo type
SWEP.Primary.Sound				= {"vj_weapons/m16a1/m16a1_single.wav"}
SWEP.Primary.DistantSound		= {"vj_weapons/m16a1/m16a1_single_dist.wav"}
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_ShellAttachment = 2
SWEP.PrimaryEffects_ShellType = "VJ_Weapon_RifleShell1"
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Reload_TimeUntilAmmoIsSet	= 1.8 -- Time until ammo is set to the weapon
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnFireAnimationEvent(pos, ang, event, options)
	if event == 5001 then return true end  -- Asiga hose vor shtke gedervadz flash-e
end
--PATH lua/entities/aat.lua:

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "speeder_base"
ENT.Type = "vehicle"

ENT.PrintName = "AAT"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: CIS"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.Vehicle = "AAT";
ENT.EntModel = "models/aat/aat_hull1.mdl";
ENT.StartHealth = 4000;
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.NextUse = {Use = CurTime(),Fire = CurTime()};
ENT.FireSound = Sound("weapons/aat_shoot.wav");


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("aat");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw+180,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self.BaseClass.Initialize(self);
	local driverPos = self:GetPos()+self:GetUp()*40+self:GetForward()*42;
	local driverAng = self:GetAngles()+Angle(0,90,0);
	local passPos = self:GetPos()+self:GetUp()*20+self:GetForward()*25+self:GetRight()*15
	self:SpawnChairs(driverPos,driverAng,false);
	
	self.ForwardSpeed = -250;
	self.BoostSpeed = -400
	self.AccelSpeed = 6;
	self.HoverMod = 0.5;
	self.SpeederClass = 2;
	self.NoWobble = true;
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetUp()*30+self:GetRight()*46+self:GetForward()*-85,
		Right = self:GetPos()+self:GetUp()*30+self:GetRight()*-46+self:GetForward()*-85,
	}
	self.WeaponDir = self:GetAngles():Forward()*-1;
	self:SpawnWeapons();
	self.CannonLocation = self:GetPos()+self:GetUp()*60+self:GetForward()*-10;
	
	self.CanBack = true;
	self.StartHover = 30;
	
	
	self:SpawnTurretGuard();
	self:SpawnTurret();
	self:SpawnCannons();
	
	self.Bullet = CreateBulletStructure(150,"red");
	
	self.ExitModifier = {x=250,y=0,z=0};
	
end


function ENT:SpawnTurret()
	
	local e = ents.Create("prop_physics");
	e:SetPos(self:GetPos()+self:GetUp()*150+self:GetForward()*50);
	e:SetAngles(self:GetAngles());
	e:SetModel("models/aat/aat_gun1.mdl");
	e:SetParent(self.TurretGuard);
	e:Spawn();
	e:Activate();
	e:GetPhysicsObject():EnableCollisions(false);
	e:GetPhysicsObject():EnableMotion(false);
	self.Turret = e;
	self:SetNWEntity("Turret",e);
end

function ENT:SpawnTurretGuard()
	
	local e = ents.Create("prop_physics");
	e:SetPos(self:GetPos()+self:GetUp()*105+self:GetForward()*130);
	e:SetAngles(self:GetAngles());
	e:SetModel("models/aat/aat_turret1.mdl");
	e:SetParent(self);
	e:Spawn();
	e:Activate();
	e:GetPhysicsObject():EnableCollisions(false);
	e:GetPhysicsObject():EnableMotion(false);
	self.TurretGuard = e;

end

function ENT:SpawnCannons()
	
	local e = ents.Create("prop_physics");
	e:SetModel("models/aat/aat_arms1.mdl");
	e:SetPos(self:GetPos()+self:GetUp()*107.5+self:GetForward()*11.5);
	e:SetAngles(self:GetAngles());
	e:SetParent(self);
	e:Spawn();
	e:Activate();
	e:GetPhysicsObject():EnableCollisions(false);
	e:GetPhysicsObject():EnableMotion(false);
	self.Cannon = e;
	self:SetNWEntity("Cannon",e);

end

function ENT:Think()
	self.BaseClass.Think(self);
	if(self.Inflight) then
		if(IsValid(self.Pilot)) then
		
			self.Turret.LastAng = self.Turret:GetAngles();
			self.TurretGuard.LastAng = self.TurretGuard:GetAngles();
			self.Cannon.LastAng = self.Cannon:GetAngles();
		
			local aim = self.Pilot:GetAimVector():Angle();
			local p = aim.p*-1;
			if(p <= -0 and p >= -40) then
				p = -0;
			elseif(p >= -300 and p <= 280) then
				p = -300;
			end
			self.Turret:SetAngles(Angle(p,aim.y+180,0));
			self.TurretGuard:SetAngles(Angle(self:GetAngles().p,self.Turret:GetAngles().y,self:GetAngles().r));
			self.Cannon:SetAngles(Angle(p,self:GetAngles().y,self:GetAngles().r));
			if(self.Pilot:KeyDown(IN_ATTACK2)) then
				self:FireBlast(self.Turret:GetPos()+self.Turret:GetForward()*-225,true,-3,self.Turret:GetAngles():Forward());
			elseif(self.Pilot:KeyDown(IN_ATTACK)) then
				self:FireWeapons();
			end
			
			self:NextThink(CurTime());
			return true;
		end
	end
	
end

function ENT:Exit(driver,kill)
	
	self.BaseClass.Exit(self,driver,kill);
	if(IsValid(self.Turret)) then
		self.Turret:SetAngles(self.Turret.LastAng);
	end
	if(IsValid(self.TurretGuard)) then
		self.TurretGuard:SetAngles(self.TurretGuard.LastAng);
	end
	if(IsValid(self.Cannon)) then
		self.Cannon:SetAngles(self.Cannon.LastAng);
	end
	
end

function ENT:FireWeapons()

	if(self.NextUse.Fire < CurTime()) then
		local e = self.Cannon;
		local WeaponPos = {
			e:GetPos()+e:GetForward()*-105+self:GetRight()*105+self:GetUp()*5,
			e:GetPos()+e:GetForward()*-105+self:GetRight()*-105+self:GetUp()*5,
		}
		for k,v in pairs(WeaponPos) do
			local tr = util.TraceLine({
				start = self:GetPos(),
				endpos = self:GetPos() + self.Cannon:GetForward()*-10000,
				filter = {self,self.Cannon,self.Turret,self.TurretGuard},
			})
		
			self.Bullet.Src		= v;
			self.Bullet.Attacker = self.Pilot or self;	
			self.Bullet.Dir = (tr.HitPos - v);

			self:FireBullets(self.Bullet)
		end
		self:EmitSound(self.FireSound, 120, math.random(90,110));
		self.NextUse.Fire = CurTime() + 0.8;
	end
end

local ZAxis = Vector(0,0,1);

function ENT:PhysicsSimulate( phys, deltatime )
	self.BackPos = self:GetPos()+self:GetForward()*100;
	self.FrontPos = self:GetPos()+self:GetForward()*-145;
	self.MiddlePos = self:GetPos();
	if(self.Inflight) then
		local UP = ZAxis;
		self.RightDir = self.Entity:GetForward():Cross(UP):GetNormalized();
		self.FWDDir = self.Entity:GetForward();


		if(self.Pilot:KeyDown(IN_JUMP)) then
			self.Right = -500;
		elseif(self.Pilot:KeyDown(IN_WALK)) then
			self.Right = 500;
		else
			self.Right = 0;
		end
		self.Accel.RIGHT = math.Approach(self.Accel.RIGHT,self.Right,5);
		

		
		self:RunTraces();

		self.ExtraRoll = Angle(0,0,self.YawAccel / 4);
		if(!self.WaterTrace.Hit) then
			if(self.FrontTrace.HitPos.z >= self.BackTrace.HitPos.z) then
				self.PitchMod = Angle(math.Clamp((self.BackTrace.HitPos.z - self.FrontTrace.HitPos.z),-45,45)/3*-1,0,0)
			else
				self.PitchMod = Angle(math.Clamp(-(self.FrontTrace.HitPos.z - self.BackTrace.HitPos.z),-45,45)/3*-1,0,0)
			end
		end
	end

	self.BaseClass.PhysicsSimulate(self,phys,deltatime);
	

end

end

if CLIENT then
	ENT.Sounds={
		Engine=Sound("vehicles/stap/stap_engine.wav"),
	}
	
	local Health = 0;
	local Target;
	local Turret;
	local Cannon;
	function ENT:Think()
		self.BaseClass.Think(self);
		local p = LocalPlayer();
		local Flying = p:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then
			Health = self:GetNWInt("Health");
			Target = self:GetNWVector("Target");
			Turret = self:GetNWEntity("Turret");
			Cannon = self:GetNWEntity("Cannon");
		end
		
	end
    
    ENT.HasCustomCalcView = true;
	local View = {}
	function CalcView()
		
		local p = LocalPlayer();
		local self = p:GetNWEntity("AAT", NULL)
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);

		if(IsValid(self) and IsValid(Turret)) then

			if(IsValid(DriverSeat)) then
				local pos = Turret:GetPos()+Turret:GetForward()*400+Turret:GetUp()*100;
				//local face = self:GetAngles() + Angle(0,180,0);
				local face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
					View.origin = pos;
					View.angles = face;
				return View;
			end
			
		end
	end
	hook.Add("CalcView", "AATView", CalcView)


	
	function AATReticle()
	
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingAAT");
		local self = p:GetNWEntity("AAT");
		if(Flying and IsValid(self)) then
			surface.SetDrawColor( color_white )	
			local TurretPos = Turret:GetPos()+Turret:GetForward()*-40;
			local tr = util.TraceLine({
				start = TurretPos,
				endpos = TurretPos + Turret:GetForward()*-10000,
				filter = {self,Turret},
			});
			
			local vpos = tr.HitPos;
			local screen = vpos:ToScreen();
			local x,y;
			for k,v in pairs(screen) do
				if(k == "x") then
					x = v;
				elseif(k == "y") then
					y = v;
				end
			end
			
			local w = ScrW()/100*2;
			local h = w;
			x = x - w/2;
			y = y - h/2;
			surface.SetMaterial( Material( "hud/missile_reticle.png", "noclamp" ) )
			surface.DrawTexturedRectUV( x , y, w, h, 0, 0, 1, 1 )
			
			local WeaponPos = {
				Cannon:GetPos()+Cannon:GetForward()*-105+Cannon:GetRight()*105+Cannon:GetUp()*5,
				Cannon:GetPos()+Cannon:GetForward()*-105+Cannon:GetRight()*-105+Cannon:GetUp()*5,
			}
			
		
			tr = util.TraceLine({
				start = self:GetPos(),
				endpos = self:GetPos() + Cannon:GetForward()*-10000,
				filter = {self,Cannon,Turret},
			})
			
			vpos = tr.HitPos;
			screen = vpos:ToScreen();
			x = 0;
			y = 0;
			for k,v in pairs(screen) do
				if(k == "x") then
					x = v;
				elseif(k == "y") then
					y = v;
				end
			end
			
			
			x = x - w/2;
			y = y - h/2;
			
			surface.SetMaterial( Material( "hud/reticle.png", "noclamp" ) )
			surface.DrawTexturedRectUV( x , y, w, h, 0, 0, 1, 1 )
	
			SW_Speeder_DrawHull(4000)
			SW_Speeder_DrawSpeedometer()
	

		end
	end
	hook.Add("HUDPaint", "AATReticle", AATReticle)
	
	
end
--PATH lua/entities/ammo_chargepack.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_ar2_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Rifle Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/rifle_ammo.mdl"
ENT.Scale = 1.5

ENT.AmmoType = "ar2"
ENT.AmmoCount = 150

ENT.DetonationDamage = 50
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/ar1/ar1_dist2.wav"
--PATH lua/entities/arccw_att_base/shared.lua:
ENT.Type                  = "anim"
ENT.Base                  = "base_entity"
ENT.PrintName             = "Base Dropped Attachment"
ENT.Author                = ""
ENT.Information           = ""

ENT.Spawnable             = false

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

ENT.Category              = "ArcCW - Attachments"

AddCSLuaFile()

ENT.GiveAttachments = nil -- table of all the attachments to give, and in what quantity. {{["id"] = int quantity}}

ENT.SoundImpact = "weapon.ImpactSoft"
ENT.Model = ""

if SERVER then

function ENT:Initialize()
    if !self.Model then
        self:Remove()
        return
    end

    self:SetModel(self.Model)
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
    self:SetTrigger( true )
    self:SetPos(self:GetPos() + Vector(0, 0, 4))
    local phys = self:GetPhysicsObject()
    if phys:IsValid() then
        phys:Wake()
        phys:SetBuoyancyRatio(0)
    end
end

function ENT:PhysicsCollide(colData, collider)
    if colData.DeltaTime < 0.25 then return end

    self:EmitSound(self.SoundImpact)
end

function ENT:Use(activator, caller)
    if !caller:IsPlayer() then return end

    if ArcCW.ConVars["attinv_free"]:GetBool() then return end

    local take = false

    for i, k in pairs(self.GiveAttachments) do
        if i == "BaseClass" then continue end

        if ArcCW.ConVars["attinv_lockmode"]:GetBool() then
            if ArcCW:PlayerGetAtts(caller, i) > 0 then
                continue
            end
        end

        if hook.Run("ArcCW_PickupAttEnt", caller, i, k) then continue end

        ArcCW:PlayerGiveAtt(caller, i, k)

        take = true
    end

    if take then
        ArcCW:PlayerSendAttInv(caller)

        self:EmitSound("weapons/arccw/useatt.wav")
        self:Remove()
    end
end

else

local defaulticon = Material("arccw/hud/atts/default.png")
local iw = 64

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()

    local cvar2d3d = ArcCW.ConVars["2d3d"]:GetInt()
    if cvar2d3d == 0 or (cvar2d3d == 1 and LocalPlayer():GetEyeTrace().Entity != self) then return end

    if self.PrintName == "Base Dropped Attachment" and self:GetNWInt("attid", -1) != -1 then
        local att = ArcCW.AttachmentIDTable[self:GetNWInt("attid", -1)]

        if !att then return end

        local atttbl = ArcCW.AttachmentTable[att]

        if !atttbl then return end

        self.PrintName = atttbl.PrintName or att
        self.Icon = atttbl.Icon or defaulticon
    end

    if (EyePos() - self:WorldSpaceCenter()):LengthSqr() <= 262144 then -- 512^2
        local ang = LocalPlayer():EyeAngles()

        ang:RotateAroundAxis(ang:Forward(), 180)
        ang:RotateAroundAxis(ang:Right(), 90)
        ang:RotateAroundAxis(ang:Up(), 90)

        cam.Start3D2D(self:WorldSpaceCenter() + Vector(0, 0, 16), ang, 0.1)
            surface.SetFont("ArcCW_32_Unscaled")

            local w = surface.GetTextSize(self.PrintName)
            surface.SetTextPos(-w / 2 + 2, 2)
            surface.SetTextColor(0, 0, 0, 150)
            surface.DrawText(self.PrintName)
            surface.SetTextPos(-w / 2, 0)
            surface.SetTextColor(255, 255, 255, 255)
            surface.DrawText(self.PrintName)

            surface.SetDrawColor(255, 255, 255)
            surface.SetMaterial(self.Icon or defaulticon)
            surface.DrawTexturedRect(-iw / 2, iw / 2, iw, iw)
        cam.End3D2D()
    end
end

end
--PATH lua/entities/aura_hangar_console/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_capital_ship_base_mk2/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_captor/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_captor/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo2/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_consular/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cr25/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_dh_omni/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_display_panel/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "LVS Display Panel"
ENT.Category = "Aura's Custom Entities"
ENT.Spawnable = true

ENT.Editable = true

function ENT:SetupDataTables()
	self:NetworkVar("Int",0, "AITEAM", { KeyName = "aiteam", Edit = { type = "Int", order = 2,min = 0, max = 2, category = "AI"} } )

	self:NetworkVar("Bool",1, "Powered", { KeyName = "Powered", Edit = { type = "Boolean", order = 0, category = "Controls"} } )

	if (CLIENT) then
		self:NetworkVarNotify( "AITEAM", self.SetNewAITeam )
		self:NetworkVarNotify( "Powered", self.SetNewEnabled )
	end

	self:SetAITEAM(2)
	self:SetPowered(true)
end

function ENT:SetNewAITeam(name, old, new)
	self.AITEAM = new
end

function ENT:SetNewEnabled(name, old, new)
	self.ENABLED = new
end
--PATH lua/entities/aura_lvs_geo_cruiser/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_lucrehulk/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_lucrehulk/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_pelta/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_pelta/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | Pelta"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/sweaw/ships/rep_pelta_servius.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 50000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(-450,290,100),
	[2] = Vector(-450,-290,100),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
	[2] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_rtt04/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_rtt04/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_csi_1/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_satellite_neu_1/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_rep_1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | Defense Satellite"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/fyu/cedi/misc/v4/satellite.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 10000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 1
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(0,0,332),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_venator_mk2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | Venator"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/venator-class-cruiser.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 3500, right = 0, up = 1100}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/big_canon.wav")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(1100,0,1725),
	[2] = Vector(4950,-1200,670),
	[3] = Vector(4950,1200,670),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(-15,180,0),
	[2] = Angle(90,-80,0),
	[3] = Angle(90,80,0)
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 1800},
	{forward = 1000, right = 0, up = 1600},
	{forward = 2000, right = 0, up = 1400},
	{forward = 0, right = 2000, up = 1400},
	{forward = 0, right = -2000, up = 1200},
	{forward = 3000, right = 0, up = 1500},
	{forward = 5000, right = 0, up = 800},
	{forward = 7000, right = 0, up = 800},
	{forward = -1000, right = 0, up = 600},
	{forward = -2500, right = 0, up = 800},
}
--PATH lua/entities/b-wing.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "B-Wing"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Rebels"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/bwing/bwing.mdl"
ENT.Vehicle = "BWing"
ENT.StartHealth = 2500;
ENT.Allegiance = "Rebels";

util.PrecacheModel("models/bwing/bwingopen.mdl");

ENT.Open = "models/bwing/bwingopen.mdl";
ENT.Closed = "models/bwing/bwing.mdl";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("b-wing");
	e:SetPos(tr.HitPos + Vector(0,0,-20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()


	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {
		MainTop = self:GetPos()+self:GetRight()*890+self:GetUp()*205+self:GetForward()*175,
		MainBottom = self:GetPos()+self:GetRight()*890+self:GetUp()*150+self:GetForward()*175,
		
		CockpitLeft = self:GetPos()+self:GetUp()*158+self:GetForward()*140+self:GetRight()*-22.5,
		CockpitRight = self:GetPos()+self:GetUp()*158+self:GetForward()*140+self:GetRight()*-9,
		
		
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2500;
	self.ForwardSpeed = 1250;
	self.UpSpeed = 700;
	self.AccelSpeed = 8;
	self.CanStandby = true;
	self.CanBack = false;
	self.CanRoll = true;
	self.CanStrafe = false;
	self.Cooldown = 2;
	self.HasWings = false;
	self.CanShoot = true;
	self.Bullet = CreateBulletStructure(25,"red");
	self.FireDelay = 0.15;
	self.AlternateFire = true;
	self.FireGroup = {"MainTop","MainBottom","CockpitLeft","CockpitRight"};
	//self.ExitModifier = {x=0,y=225,z=100};
	self.Wings = false;
	self.HasLookaround = true;
	
	self.BaseClass.Initialize(self);

end

function ENT:ToggleWings()
	if(self.NextUse.Wings < CurTime()) then
		self:RemoveWeapons();

		if(self.Wings) then
			self:SetModel(self.Closed);
			self:SetPos(self:GetPos()+self:GetUp()*-215+self:GetRight()*-289.5+self:GetForward()*-16.5)
			self.Wings = false;
			for k,v in pairs(self.WeaponLocations) do
				if(k == "MainTop") then
					self.WeaponLocations[k] = self:GetPos()+self:GetRight()*890+self:GetUp()*205+self:GetForward()*175;
				elseif(k == "MainBottom") then
					self.WeaponLocations[k] = self:GetPos()+self:GetRight()*890+self:GetUp()*150+self:GetForward()*175;
				elseif(k == "CockpitRight") then
					self.WeaponLocations[k] = self:GetPos()+self:GetUp()*158+self:GetForward()*140+self:GetRight()*-22.5;
				elseif(k == "CockpitLeft") then
					self.WeaponLocations[k] = self:GetPos()+self:GetUp()*158+self:GetForward()*140+self:GetRight()*-9;
				end
			end
			self.FireDelay = 0.15;
			self.FireGroup = {"MainTop","MainBottom","CockpitLeft","CockpitRight"};
			self:SpawnWeapons();
		else
			self:SetModel(self.Open);
			self:SetPos(self:GetPos()+self:GetUp()*215+self:GetRight()*289.5+self:GetForward()*16.5)
			self.Wings = true;
			for k,v in pairs(self.WeaponLocations) do
				if(k == "MainTop") then
					self.WeaponLocations[k] = self:GetPos()+self:GetRight()*15+self:GetUp()*267.5+self:GetForward()*140;
				elseif(k == "MainBottom") then
					self.WeaponLocations[k] = self:GetPos()+self:GetRight()*15+self:GetUp()*-340+self:GetForward()*140;
				end				
			end
			self.FireGroup = {"MainTop","MainBottom"};
			self.Bullet = CreateBulletStructure(100,"red");
			self.FireDelay = 0.25;
			self:SpawnWeapons();
		end
		self.NextUse.Wings = CurTime() + 1;
		self:SetNWBool("Wings",self.Wings);
	end
end

function ENT:RemoveWeapons()
	for k,v in pairs(self.Weapons) do
		v:Remove();
	end

end

function ENT:Think()

	if(self.Inflight) then
		if(IsValid(self.Pilot)) then
			if(!self.TakeOff and !self.Land) then
				if(self.Pilot:KeyDown(IN_SPEED)) then
					self:ToggleWings();
				end
			end
		end
	end
	self.BaseClass.Think(self);
end

end

if CLIENT then
	
	ENT.CanFPV = true;
	ENT.Sounds={
		Engine=Sound("ambient/atmosphere/ambience_base.wav"),
	}
	
	function ENT:Initialize()
		self.Emitter = ParticleEmitter(self:GetPos());
		self.BaseClass.Initialize(self);
	end
	
    ENT.HasCustomCalcView = true;
	local View = {}
	local function CalcView()
		
		local p = LocalPlayer();
		local self = p:GetNetworkedEntity("BWing", NULL)
		
		if(IsValid(self)) then
			local Wings = self:GetNWBool("Wings");
			local fpvPos = self:GetPos()+self:GetRight()*-17+self:GetUp()*205+self:GetForward()*55;
			if(Wings) then
				fpvPos = fpvPos + self:GetUp()*-215 + self:GetRight()*-289.5+self:GetForward()*-16.5;
			end
			View = SWVehicleView(self,850,200,fpvPos,true);		
			return View;
		end
	end
	hook.Add("CalcView", "BWingView", CalcView)
	
	function ENT:Effects()
		self.ThrusterLocations = {
			self:GetPos()+self:GetRight()*188+self:GetUp()*205+self:GetForward()*-150,
			self:GetPos()+self:GetRight()*243+self:GetUp()*205+self:GetForward()*-150,	
			self:GetPos()+self:GetRight()*188+self:GetUp()*150+self:GetForward()*-150,
			self:GetPos()+self:GetRight()*243+self:GetUp()*150+self:GetForward()*-150,
		}
		local p = LocalPlayer();
		local roll = math.Rand(-45,45);
		local normal = (self.Entity:GetForward() * -1):GetNormalized();
		local id = self:EntIndex();
		local Wings = self:GetNWBool("Wings");
		for k,v in pairs(self.ThrusterLocations) do
			
			if(Wings) then
				v = v + self:GetUp()*-215+self:GetRight()*-289.5+self:GetForward()*-16.5;
			end
			
			local heatwv = self.Emitter:Add("sprites/heatwave",v);
			heatwv:SetVelocity(normal*2);
			heatwv:SetDieTime(0.1);
			heatwv:SetStartAlpha(255);
			heatwv:SetEndAlpha(255);
			heatwv:SetStartSize(40);
			heatwv:SetEndSize(10);
			heatwv:SetColor(255,255,255);
			heatwv:SetRoll(roll);
			
			local red = self.FXEmitter:Add("sprites/orangecore1",v)
			red:SetVelocity(normal)
			red:SetDieTime(0.03)
			red:SetStartAlpha(255)
			red:SetEndAlpha(255)
			red:SetStartSize(50)
			red:SetEndSize(10)
			red:SetRoll(roll)
			red:SetColor(255,100,100)
		
			local dynlight = DynamicLight(id + 4096 * k);
			dynlight.Pos = v;
			dynlight.Brightness = 5;
			dynlight.Size = 150;
			dynlight.Decay = 1024;
			dynlight.R = 255;
			dynlight.G = 100;
			dynlight.B = 100;
			dynlight.DieTime = CurTime()+1;

		end
	end

	function ENT:Think()
	
		self.BaseClass.Think(self)
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			if(!TakeOff and !Land) then
				self:Effects();
			end
		end
		
	end
	
	function BWingReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingBWing");
		local self = p:GetNWEntity("BWing");
		if(Flying and IsValid(self)) then
			if(self:GetFPV()) then
				SW_HUD_WingsIndicator("bwing",x,y);
			end
			SW_HUD_DrawHull(2500);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			
			local pos = self:GetPos()+self:GetRight()*-22+self:GetUp()*200+self:GetForward()*65;
			local Wings = self:GetNWBool("Wings") or p:GetNWBool("SW_Wings");
			if(Wings) then
				pos = pos + self:GetUp()*-215 + self:GetRight()*-289.5+self:GetForward()*-16.5;
			end
			
			local x,y = SW_XYIn3D(pos)
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
			
		end
	end
	hook.Add("HUDPaint", "BWingReticle", BWingReticle)

end
--PATH lua/entities/base_streamradio.lua:
return gluapack()()
--PATH lua/entities/cannon_blast.lua:

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Cannon Blast"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars"
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

if SERVER then
	AddCSLuaFile()
	function ENT:Initialize()
	
		self:SetModel("models/props_junk/PopCan01a.mdl");
		self:SetSolid(SOLID_VPHYSICS);
		self:SetMoveType(MOVETYPE_VPHYSICS);
		self:PhysicsInit(SOLID_VPHYSICS);
		self:StartMotionController();
		self:SetUseType(SIMPLE_USE);
		self:SetRenderMode(RENDERMODE_TRANSALPHA);
		self:SetColor(Color(255,255,255,1));
		
		self:SetNWBool("White",self.IsWhite);
		self:SetNWInt("StartSize",self.StartSize or 20);
		self:SetNWInt("EndSize",self.EndSize or 15);
		
		self.Damage = self.Damage or 500;

	end
	
	function ENT:Prepare(e,s,gravity,vel,ang)
		e:EmitSound(s)
		local phys = self:GetPhysicsObject();
		phys:SetMass(100);
		phys:EnableGravity(gravity);
		if(!ang) then
			ang = e:GetForward();
		end
		phys:SetVelocity(ang*(2000*vel))
	end
	
    function ENT:PhysicsCollide(data, physobj)
        for i = 1, math.Round(self.Damage / 100) do
            local pos = self:GetPos() + self:GetForward() * math.random(-self.Damage / 2, self.Damage / 2) + self:GetRight() * math.random(-self.Damage / 2, self.Damage / 2)
            local fx = EffectData()
            fx:SetOrigin(pos)
            util.Effect("Explosion", fx, true, true)
        end

        for k, v in pairs(ents.FindInSphere(self:GetPos(), self.Damage)) do
            local dist = (self:GetPos() - v:GetPos()):Length()
            local dmg = math.Clamp((self.Damage or 600) - dist, 0, (self.Damage or 600))
            v:TakeDamage(dmg)
        end

        timer.Simple(0, function()
            if (IsValid(self)) then
                self:Remove()
            end
        end)
        --Remove the next frame..
    end
	
end

if CLIENT then

	function ENT:Initialize()	
		self.FXEmitter = ParticleEmitter(self:GetPos())
	end
	
	function ENT:Draw()
		
		self:DrawModel();
		
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		
		local StartSize = self:GetNWInt("StartSize");
		local EndSize = self:GetNWInt("EndSize");
		
		local sprite;
		local IsWhite = self:GetNWBool("White");
		if(IsWhite) then
			sprite = "sprites/white_blast";
		else
			sprite = "sprites/bluecore";
		end

		local blue = self.FXEmitter:Add(sprite,self:GetPos())
		blue:SetVelocity(normal)
		blue:SetDieTime(0.05)
		blue:SetStartAlpha(255)
		blue:SetEndAlpha(255)
		blue:SetStartSize(StartSize)
		blue:SetEndSize(EndSize)
		blue:SetRoll(roll)
		blue:SetColor(255,255,255)
		
	end
end
--PATH lua/entities/claimboard/shared.lua:
ENT.Base = "gmod_base"
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Claim Board"
ENT.AuthorName = ""
ENT.Category = "[RDV] Claimboards"
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:SetupDataTables()

    self:NetworkVar("String", 0, "ClaimBoardTitle")
    self:NetworkVar("String", 1, "ClaimBoardBat")
    self:NetworkVar("Bool", 0, "ClaimBoardOpen")
    self:NetworkVar("Bool", 1, "ClaimBoardClaimed")
    self:NetworkVar("Entity", 1, "ClaimBoardClaimer")

    self:SetClaimBoardClaimed( false )
    self:SetClaimBoardOpen( true )
    self:SetClaimBoardBat( "N/A" )
    self:SetClaimBoardTitle( "N/A" )
end
--PATH gamemodes/starwarsrp/entities/entities/darkrp_billboard/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "DarkRP billboard"
ENT.Instructions = "Shows advertisements."
ENT.Author = "FPtje"

ENT.Spawnable = false
ENT.Editable = true
ENT.IsDarkRPBillboard = true

cleanup.Register("advert_billboards")

function ENT:SetupDataTables()
    self:NetworkVar("String", 0, "TopText", {
        KeyName = "toptext",
        Edit = {
            type = "Generic",
            title = "Top text",
            category = "Text",
            order = 0
        }
    })

    self:NetworkVar("String", 1, "BottomText", {
        KeyName = "bottomtext",
        Edit = {
            type = "Generic",
            title = "Bottom text",
            category = "Text",
            order = 1
        }
    })

    self:NetworkVar("Vector", 0, "BackgroundColor", {
        KeyName = "backgroundcolor",
        Edit = {
            type = "VectorColor",
            title = "Background color",
            category = "Color",
            order = 0
        }
    })

    self:NetworkVar("Vector", 1, "BarColor", {
        KeyName = "barcolor",
        Edit = {
            type = "VectorColor",
            title = "Top bar color",
            category = "Color",
            order = 1
        }
    })
end

DarkRP.declareChatCommand{
    command = "advert",
    description = "Create a billboard holding an advertisement.",
    delay = 1.5
}

DarkRP.hookStub{
    name = "canAdvert",
    description = "Whether someone can place an advertisement billboard.",
    parameters = {
        {
            name = "player",
            description = "The player trying to advertise.",
            type = "Player"
        },
        {
            name = "arguments",
            description = "The advertisement itself.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canAdvert",
            description = "A yes or no as to whether the player can place the billboard.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't place the billboard.",
            type = "string"
        }
    },
    realm = "Server"
}

DarkRP.hookStub{
    name = "playerAdverted",
    description = "Called when a player placed an advertisement billboard.",
    parameters = {
        {
            name = "player",
            description = "The player.",
            type = "Player"
        },
        {
            name = "arguments",
            description = "The advertisement itself.",
            type = "string"
        },
        {
            name = "entity",
            description = "The placed advertisement billboard.",
            type = "Entity"
        }
    },
    returns = {},
    realm = "Server"
}

--PATH gamemodes/starwarsrp/entities/entities/darkrp_tip_jar/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
    self:initVars()
    self:initVarsClient()
end

function ENT:initVarsClient()
    self.colorBackground = Color(140, 0, 0, 100)
    self.colorText = color_white
    self.donateAnimColor = Color(20, 100, 20)

    self.rotationSpeed = 130
    self.rotationOffset = 0
    self:InitCsModel()

    self.firstDonateAnimation = nil
    self.lastDonateAnimation = nil
    self.donateAnimSpeed = 0.3
end

function ENT:InitCsModel()
    self.csModel = ClientsideModel(self.model)
    self.csModel:SetPos(self:GetPos())
    self.csModel:SetParent(self)
    self.csModel:SetModelScale(1.5, 0)
    self.csModel:SetNoDraw(true)
    self:CallOnRemove("csModel", fp{SafeRemoveEntity, self.csModel})
end

function ENT:Draw()
    local Pos = self:GetPos()
    local Ang = self:GetAngles()
    local sysTime = SysTime()
    local eyepos = EyePos()
    local planeNormal = Ang:Up()

    local rotAng = Angle(Ang)
    self.rotationOffset = sysTime % 360 * self.rotationSpeed
    rotAng:RotateAroundAxis(planeNormal, self.rotationOffset)

    -- Something about cs models getting removed on their own...
    if not IsValid(self.csModel) then
        self:InitCsModel()
    end
    self.csModel:SetPos(Pos)
    self.csModel:SetAngles(rotAng)
    if not self:IsDormant() then
        self.csModel:DrawModel()
    end


    local owner = self:Getowning_ent()
    owner = (IsValid(owner) and owner:Nick()) or DarkRP.getPhrase("unknown")
    local title = DarkRP.getPhrase("tip_jar")

    surface.SetFont("HUDNumber5")
    local titleTextWidth, titleTextHeight = surface.GetTextSize(title)
    local ownerTextWidth = surface.GetTextSize(owner)

    Ang:RotateAroundAxis(Ang:Forward(), 90)

    -- The text can be considered to be "standing" on a plane with normal =
    -- Ang:Up(). The vector towards the player's EyePos is projected onto that
    -- plane, normalised and rotated to have the text face the user.
    local relativeEye = eyepos - Pos
    local relativeEyeOnPlane = relativeEye - planeNormal * relativeEye:Dot(planeNormal)
    local textAng = relativeEyeOnPlane:AngleEx(planeNormal)

    textAng:RotateAroundAxis(textAng:Up(), 90)
    textAng:RotateAroundAxis(textAng:Forward(), 90)


    cam.Start3D2D(Pos - Ang:Right() * 11.5 , textAng, 0.2)
        draw.WordBox(2, -titleTextWidth * 0.5, -72                      , title, "HUDNumber5", self.colorBackground, self.colorText)
        draw.WordBox(2, -ownerTextWidth * 0.5, -72 + titleTextHeight + 4, owner, "HUDNumber5", self.colorBackground, self.colorText)

        self:DrawAnims(sysTime)
    cam.End3D2D()
end

function ENT:DrawAnims(sysTime)
    local anim = self.firstDonateAnimation

    while anim do
        if anim.progress > 1 then
            anim = anim.nextDonateAnimation
            self.firstDonateAnimation = anim

            continue
        end

        draw.SimpleText(
            anim.amount,
            "DarkRP_tipjar",
            -anim.textWidth / 2,
            -100 - anim.progress * 200,
            ColorAlpha(self.donateAnimColor, Lerp(anim.progress, 1024, 0)),
            0
        )

        anim.progress = (sysTime - anim.start) * self.donateAnimSpeed

        anim = anim.nextDonateAnimation
    end

    if not self.firstDonateAnimation then
        self.lastDonateAnimation = nil
    end
end

function ENT:Donated(ply, amount)
    local txtAmount = DarkRP.formatMoney(amount)

    surface.SetFont("DarkRP_tipjar")

    local anim = {
        amount = txtAmount,
        start = SysTime(),
        textWidth = surface.GetTextSize(txtAmount),
        progress = 0,
        nextDonateAnimation = nil,
    }

    if self.lastDonateAnimation then
        self.lastDonateAnimation.nextDonateAnimation = anim
    else
        self.firstDonateAnimation = anim
    end

    self.lastDonateAnimation = anim

    self:AddDonation(ply:Nick(), amount)
end

-- Disable halos
function ENT:Think() end

--PATH gamemodes/starwarsrp/entities/entities/darkrp_tip_jar/shared.lua:
return gluapack()()
--PATH lua/entities/dc17m_at_rocket2/shared.lua:
 ENT.Type 			= "anim"  
 ENT.PrintName			= "High Explosive Anti-Tank RPG"  
 ENT.Author			= "Generic Default"  
 ENT.Contact			= "AIDS"  
 ENT.Purpose			= "SPLODE"  
 ENT.Instructions			= "LAUNCH"  
 
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


--PATH gamemodes/starwarsrp/entities/entities/drug_lab/shared.lua:
ENT.Base = "lab_base"
ENT.PrintName = "Drug Lab"

function ENT:initVars()
    self.model = "models/props_lab/crematorcase.mdl"
    self.initialPrice = GAMEMODE.Config.druglabdrugcost
    self.labPhrase = DarkRP.getPhrase("drug_lab")
    self.itemPhrase = DarkRP.getPhrase("drugs")
    self.noIncome = true
    self.camMul = -39
end

--PATH lua/entities/ent_fballoon/cl_init.lua:
include('shared.lua')

/*---------------------------------------------------------
Draw
---------------------------------------------------------*/
function ENT:Draw()
	self.Entity:DrawModel()
end


/*---------------------------------------------------------
IsTranslucent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end



--PATH lua/entities/ent_fballoon/shared.lua:
return gluapack()()
--PATH lua/entities/fly_base.lua:
AddCSLuaFile()

--[[
	An entity base that allows you to create entity that can be equipped by the player as if they were weapons or powerups, but that can still
	function when not picked up by a player

	For instance you could make a jetpack that flies off when the equipping player dies, or you can make a controllable plane but still allow
	full movement on the player

	This file is licensed under the MIT license, so go nuts.
]]

DEFINE_BASECLASS( "base_entity" )

ENT.UseNWVars = false

ENT.Spawnable = false
ENT.IsPredictedEnt = true
ENT.AttachesToPlayer = true	--whether this entity attaches to the player or not, when true this removes physics and draws the entity on the player

ENT.SaveButtonToCvar = false

if SERVER then
	ENT.DropOnDeath = false
	ENT.ShowPickupNotice = true	--plays the pickup sound and shows the pickup message on the hud
	ENT.DontTransmitToOthers = false --when true, don't transmit to anyone except the owner, this MIGHT conflict with addons that make use of SetPreventTransmit, so mind that!
	ENT.ShouldLagCompensate = true 	--automatically enables/disables lag compensation when physics are created and destroyed, might be annoying for some so disable this if you want
else
	ENT.RenderGroup = RENDERGROUP_OPAQUE
end

ENT.Editable = false

ENT.KeyAllowedKeyboard = 2 ^ 0
ENT.KeyAllowedMouse = 2 ^ 1
ENT.KeyAllowedJoystick = 2 ^ 2

ENT.KeyAllowedAll = bit.bor( ENT.KeyAllowedKeyboard , ENT.KeyAllowedMouse , ENT.KeyAllowedJoystick )

ENT.KeyAllowedFlags = ENT.KeyAllowedAll	--bitflag of the key types you want to use

ENT.HookAlways = 1 --hooks in here always run
ENT.HookEquipped = 2 --hooks in here are only added when the entity is equipped by user, and removed when unequipped
ENT.HookEquippedPrediction = 3 --like above, but on the client, only for the LocalPlayer() equipping this
ENT.HookCallback = 4 --these are callbacks handled with AddCallback, unfortunately we have no way to fully handle these

--example attachment info table, only used if AttachesToPlayer is true
--[[
ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( -90 , -5.6 , 0 ),
	OffsetAng = Angle( 180 , 90 , -90 ),
}
]]

--[[
	This is a wrapper for NetworkVars/DTVars (same thing) so we can handle their slots properly for child classes instead
	of having to modify them manually everytime something changes in order

	This could be switched to NWVars2 (vinh vars) but then I would have to hack in support for right-click editing, since that's
	based on NetworkVars and some other getters
]]
function ENT:DefineNWVar( dttype , dtname , editable , beautifulname , minval , maxval , customelement , filt )

	if not self.DefinedDTVars[dttype] then
		Error( "Wrong NWVar type " .. ( dttype or "nil" ) )
		return
	end

	local index = -1

	--only do this check for limited dtvars, once we switch to NWVars in :NetworkVar this check will go away
	if not self.UseNWVars then
		local maxindex = self.DefinedDTVars[dttype].Max

		for i = 0 , maxindex - 1 do
			--we either didn't find anything in this slot or we found the requested one again
			--in which case just override it again, someone might want to inherit and add an edit table or something
			if not self.DefinedDTVars[dttype][i] or self.DefinedDTVars[dttype][i] == dtname then
				index = i
				break
			end
		end

		if index == -1 then
			Error( "Not enough slots on "..dttype .. ",	could not add ".. dtname )
			return
		end
	else
		index = dtname:lower()
	end

	self.DefinedDTVars[dttype][index] = dtname

	local edit = nil

	--this used to check if we could actually add the edit table, so we default it to nil to override it again
	--in case of a child class

	if editable then
		edit = {
			KeyName = dtname:lower(),
			Edit = {
				title = beautifulname or dtname,	--doesn't it do this internally already?
				min = minval,
				max = maxval,
				type = customelement or self.DefinedDTVars[dttype].EditableElement,
			}
		}
	end

	self:NetworkVar( dttype , index , dtname , edit )
end

function ENT:SetupDataTables()

	--if the user is in the branch that has the NWVars change then automatically switch to this
	if self.CallNetworkProxies then
		self.UseNWVars = true
	end

	--eventually I'll create more editable elements based on garry's system

	self.DefinedDTVars = {
		Entity = {
			Max = GMOD_MAXDTVARS,
		},
		Float = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Float",
		},
		Int = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Int",
		},
		Bool = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Boolean",
		},
		Vector = {
			Max = GMOD_MAXDTVARS,
		},
		Angle = {
			Max = GMOD_MAXDTVARS,
		},
		String = {
			Max = 4,
			EditableElement = "Generic",
		},
	}

	self:DefineNWVar( "Entity" , "ControllingPlayer" )
	self:DefineNWVar( "Bool" , "BeingHeld" )
	self:DefineNWVar( "String" , "SlotName" )
	self:DefineNWVar( "Float" , "NextFire" ) --similar to primaryattack on a weapon

	--only allow the user to modify the button if the coder wants this entity to have an usable key

	self:DefineNWVar( "Int" , "Key" , true , "Button" , BUTTON_CODE_NONE + 1 , BUTTON_CODE_LAST , "EditKey" )
	self:DefineNWVar( "Bool" , "KeyPressed" )
end

function ENT:Initialize()

	self.HandledHooks = {
		[self.HookAlways] = {},
		[self.HookEquipped] = {},
		[self.HookEquippedPrediction] = {},
		[self.HookCallback] = {}
	}

	self.HookConditions = {
		[self.HookAlways] = function( ent )
			return true
		end,
		[self.HookEquipped] = function( ent )
			return ent:IsCarried()
		end,
		[self.HookEquippedPrediction] = function( ent )
			if SERVER then
				return ent:IsCarried() --self.HookConditions[self.HookEquipped]( self )
			else
				return ent:IsCarriedByLocalPlayer()
			end
		end,
		[self.HookCallback] = function( self )
			return nil --nil means don't handle me
		end,
	}

	--predicted hooks hooking with hookers and futurama memes
	self:InstallHook( "StartCommand" , self.HandlePredictedStartCommand , self.HookEquippedPrediction )
	self:InstallHook( "SetupMove" , self.HandlePredictedSetupMove , self.HookEquippedPrediction )
	self:InstallHook( "Move" , self.HandlePredictedMove , self.HookEquippedPrediction )
	self:InstallHook( "PlayerTick" , self.HandlePredictedThink , self.HookEquippedPrediction )
	self:InstallHook( "FinishMove" , self.HandlePredictedFinishMove , self.HookEquippedPrediction )
	self:InstallHook( "OnPlayerHitGround" , self.HandlePredictedHitGround , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonDown" , self.HandlePlayerButtonDown , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonUp" , self.HandlePlayerButtonUp , self.HookEquippedPrediction )


	self:InstallHook( "CalcMainActivity" , self.HandleCalcMainActivity , self.HookEquipped )
	self:InstallHook( "UpdateAnimation" , self.HandleUpdateAnimation , self.HookEquipped )
	self:InstallHook( "DoAnimationEvent" , self.HandleAnimationEvent , self.HookEquipped )


	if SERVER then
		self:InstallHook( "SetupPlayerVisibility" , self.HandleEntityVisibility , self.HookAlways )
		self:InstallHook( "EntityRemoved" , self.OnControllerRemoved , self.HookAlways )
		self:InstallHook( "PostPlayerDeath" , self.OnControllerDeath , self.HookAlways )	--using PostPlayerDeath as it's called on all kind of player deaths, even :KillSilent()
		self:InstallHook( "CanEditVariable" , self.HandleCanEditVariable , self.HookAlways )

		--just in case it has been spawned manually and the coder forgot
		if self:GetSlotName() == "" then
			ErrorNoHalt( self:GetClass() .. " was spawned without a slotname!!!!. Defaulting to classname\n" )
			self:SetSlotName( self:GetClass() )
		end

		self:SetUseType( SIMPLE_USE )
		self:SetKey( BUTTON_CODE_NONE )
	else
		self:InstallHook( "PreDrawEffects" , self.DrawFirstPersonInternal , self.HookEquipped )
		self:InstallHook( "PostDrawViewModel" , self.DrawViewModelInternal , self.HookEquipped )
		self:InstallHook( "PostPlayerDraw" , self.DrawOnPlayer , self.HookEquipped )

		self:InstallHook( "NotifyShouldTransmit" , self.HandleFullPacketUpdate , self.HookAlways )

		language.Add( self:GetClass() , self.PrintName )
		language.Add( "dropped_"..self:GetClass() , "Dropped "..self.PrintName )
	end
end

--This is needed mostly for clientside hooks, since IsValid might return false when we're out of PVS with some bad lag
--and when hook.Call tries to call on an invalid entity it removes the hook, so we need to reinstall them when that happens and the entity gets back in the PVS
--prediction and other shit like drawing on a player might fuck up since the hooks got removed
--Now this also works for adding a callback

function ENT:InstallHook( hookname , handler , hooktype )

	if self.HandledHooks[hooktype] == nil then
		hooktype = self.HookAlways
	end

	self.HandledHooks[hooktype][hookname] = handler

	if hooktype == self.HookCallback then
		self:AddCallback( hookname , handler )
	end

end

function ENT:HandleHooks( cleanup )

	--this is direct access to the hook table, but it's not slow at all
	--or at least, it shouldn't be as long as you don't have any ulib shit or some other hook overrides
	local hooktable = hook.GetTable()



	for hookindex , handledshooktab in pairs( self.HandledHooks ) do
		local condition = self.HookConditions[hookindex]( self )

		if condition ~= nil then
			for i , v in pairs( handledshooktab ) do
				if condition and not cleanup then
					if not hooktable[i] or not hooktable[i][self] then
						hook.Add( i , self , v )
					end
				else
					if hooktable[i] and hooktable[i][self] then
						hook.Remove( i , self )
					end
				end
			end
		end
	end

end

function ENT:Think()

	self:HandleHooks()

	if SERVER then

		--check if this guy is still my parent and owner, maybe something is forcibly unparenting us from him, if so, drop
		if self.AttachesToPlayer and self:IsCarried() then
			if not self:IsAttached() then
				self:Remove( true )
			end
		end

		--we have to network this ourselves since it's based on the physics object ( which is mainly serverside )
		--the reason I'm networking this is that due to the gravity gun enabling prediction, it would screw with the manual
		--predictable logic of this entity, so when we try to activate prediction, we check if we're being carried by the gravity gun
		--to prevent disabling it

		--NOTE: this is not as expensive as it looks, it just checks for the FVPHYSICS_PLAYER_HELD flag on our physobj
		self:SetBeingHeld( self:IsPlayerHolding() )
	else
		--calling this in a non-predicted hook is perfectly fine, since we need the entity to enable prediction on its own
		--even when controlling players change

		--Ideally this would be handled on the callback of SetControllingPlayer clientside, but we don't have that yet
		self:HandlePrediction()
		self:HandleButtonBind()
		self:HandleContextMenuButton()
		self:InternalHandleLoopingSounds()
	end

	--set our think rate to be in line with the server tickrate
	--this may also affect animations clientside if they're ran in this hook, considering that also happens in normal source
	--I'd say that's an accurate replication of the issue

	--default behaviour for scripted entities is to think every 200 milliseconds
	--I suppose this should be configurable by child entities

	self:NextThink( CurTime() + engine.TickInterval() )
	return true
end

if SERVER then

	--for map inputs mostly, but other addons may also be using these inputs trough ent:Input or ent:Fire
	--more inputs might come in the future
	--of course child entities are free to call the baseclass function after their own to chain stuff

	function ENT:AcceptInput( inputName, activator, called, data )

		if inputName == "Drop" then
			self:Drop( true )
			return true
		end

		if inputName == "SetSlotName" then
			if self:IsCarried() or not data or #data <= 1 or data == self:GetSlotName() then
				return false
			end

			self:SetSlotName( data )
			return true
		end

	end

	--although we should probably do validity checks on them first, but considering this would *probably* be called from maps it should be ok
	--copied from env_skypaint, allows to have the DT vars set as if they were key values

	function ENT:KeyValue( key, value )

		if self:SetNetworkKeyValue( key, value ) then
			return
		end

	end

	function ENT:ChangeSlot( newslotname )
		local oldslotname = self:GetSlotName()

		if newslotname == oldslotname then
			return false
		end

		local ply = self:GetControllingPlayer()

		--if we have a controlling player and he has an entity in the new slot, abort
		if IsValid( ply ) and IsValid( self.GetOnPlayer( ply , newslotname ) ) then
			--this slot is already occupied!!!
			return false
		end

		if IsValid( ply ) then
			self.SetOnPlayer( ply , oldslotname , NULL )
			self.SetOnPlayer( ply , newslotname , self )
		end

		self:SetSlotName( newslotname )

		return true
	end

	--useful for swapping out two slots at the same time and knowing the other entity,
	--usually in an inventory system
	function ENT:SwapSlotWith( predent )
		local ply = self:GetControllingPlayer()

		if not self:IsCarriedBy( ply ) or not IsValid( predent ) or not predent.IsPredictedEnt
		or not predent:IsCarriedBy( ply ) then
			return false
		end

		local myslot = self:GetSlotName()
		local otherslot = predent:GetSlotName()

		self.SetOnPlayer( ply , otherslot , self )
		self.SetOnPlayer( ply , myslot , predent )

		self:SetSlotName( otherslot )
		predent:SetSlotName( myslot )

		return true
	end

	--override this if you want your equip logic to be different
	function ENT:Use( activator, caller, useType, value )
		if not self:Attach( activator ) then
			self:EmitPESound( "HL2Player.UseDeny" , 150 , nil , 1 , nil , nil , activator )
		end
	end

	function ENT:InitPhysics()
		--don't actually initialize the physics if we're getting removed anyway
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end


		if self.ShouldLagCompensate then
			self:SetLagCompensated( true )
		end

		self:DoInitPhysics()
		self:OnInitPhysics( self:GetPhysicsObject() )
	end

	function ENT:DoInitPhysics()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:RemovePhysics()

		if self.AttachesToPlayer and self.ShouldLagCompensate then
			self:SetLagCompensated( false )	--entities that are attached to players will be moved back when the player is, so don't make them lag compensate on their own
		end

		self:OnRemovePhysics( self:GetPhysicsObject() )
		self:DoRemovePhysics()
	end

	function ENT:DoRemovePhysics()
		self:PhysicsDestroy()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:OnAttach( ply , forced )
		--override me
	end

	function ENT:CanAttach( ply )
		--override me
	end

	function ENT:OnDrop( ply , forced )
		--override me
	end

	function ENT:CanDrop( ply )
		--override me
	end

	--these two are not necessarely duplicates of the functions above because we may want to modify the mass
	--as soon as the physobj gets created, and that also happens in initialize

	function ENT:OnInitPhysics( physobj )
		--override me
	end

	function ENT:OnRemovePhysics( physobj )
		--override me
	end

	--being attached forcibly is usually something that happens when you want to spawn the player with this item, and you
	--don't want gamemode logic to interfere with it
	function ENT:Attach( activator , forced )

		--we were forced to attach to this player, so drop first to clear out some values
		if forced then
			self:Remove( forced )
		end

		if not IsValid( activator ) or not activator:IsPlayer() then
			return false
		end

		--we're carried in general OR that guy's using that slot already
		if self:IsCarried() or IsValid( self.GetOnPlayer( activator , self:GetSlotName() ) ) then
			return false
		end

		--we can allow the coder or gamemode to only stop the pickup if it's not forced
		if not forced then
			--simulate ourselves being a normal item pickup
			--the reason we're asking this first, is that first we want to make sure the gamemode is OK with us being able to pickup this entity
			local canattach = hook.Run( "PlayerCanPickupItem" , activator , self )

			--THEN we ask the coder if he really wants us to pickup his entity, in case it's out of "ammo", or some other restrictions
			local mycanattach = self:CanAttach( activator )
			if mycanattach == false then
				canattach = mycanattach
			end

			if canattach == false then
				return canattach
			end
		end

		if self.AttachesToPlayer then
			self:RemovePhysics()
			self:SetParent( activator )
			self:SetOwner( activator )
			self:SetTransmitWithParent( true )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck of the transmission, so UpdateTransmitState() is called right away
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( true )
			end
			]]

			self:SetNoDraw( true )
			self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		self:SendItemMessage( activator , false )

		self.SetOnPlayer( activator , self:GetSlotName() , self )
		self:SetControllingPlayer( activator )

		--if the player has a customized key for this entity, use that instead
		--we do this here so that OnAttach can make use of it

		--this also allows us to prevent the key from another user to be written clientside and override ours
		if self.SaveButtonToCvar then
			local plykey = self:GetControllingPlayerConVarKey()

			if self:IsKeyAllowed( plykey ) and plykey ~= self:GetKey() then
				self:SetKey( plykey )
			end
		end

		--THIS IS VERY SUBJECTIVE
		self:SetKeyPressed( false ) --only reset the button press state when equipped

		self:OnAttach( activator , forced )
		return true
	end

	function ENT:Drop( forced )

		--we can allow the coder to only stop the drop if it's not forced
		if not forced then
			local candrop = self:CanDrop( self:GetControllingPlayer() )

			if candrop == false then
				return candrop
			end
		end

		if self.AttachesToPlayer then
			self:SetParent( NULL )
			self:SetOwner( NULL )
			self:InitPhysics()
			self:SetTransmitWithParent( false )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck during a drop
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( false )
			end
			]]

			self:SetNoDraw( false )
			self:RemoveEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		if not forced and self:IsCarried() then
			self:SendItemMessage( self:GetControllingPlayer() , true )
		end

		--only call OnDrop if we had a player controlling us, don't do it if we were just sweeping up some unclean values
		if self:IsCarried() then
			self:OnDrop( self:GetControllingPlayer() , forced )
			self.SetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() , NULL )
		end

		self:SetControllingPlayer( NULL )
		return true
	end

	function ENT:SendItemMessage( activator , dropped )
		if dropped == nil then
			dropped = false
		end
		--GetShouldPlayPickupSound is actually a Lua table value that is then checked in c++, so it starts out as nil, wow garry
		if self.ShowPickupNotice and ( self:GetShouldPlayPickupSound() == nil or self:GetShouldPlayPickupSound() ) then

			if not dropped then
				self:EmitSound( "HL2Player.PickupWeapon" )
			else
				self:EmitSound( "Weapon_Crowbar.Single" )
			end

			if not activator:IsPlayer() or not activator:IsBot() then
				net.Start( "pe_pickup" )
					net.WriteString( self:GetClass() )
					net.WriteBit( dropped )
				net.Send( activator )
			end
		end
	end

	--we want to get properly dropped when the player entity gets removed ( aka after a disconnect )
	--why not use the disconnect hook? no.

	function ENT:OnControllerRemoved( ent )
		if self:IsCarriedBy( ent ) then
			self:Remove( true )
		end
	end

	function ENT:OnControllerDeath( ply )
		if self.DropOnDeath and self:IsCarriedBy( ply ) then
			self:Remove( true )
		end
	end

	--we're redoing this even though it's hooked up in sandbox because someone might want to use this in another gamemode ( such as ttt or whatever )
	function ENT:HandleCanEditVariable( ent , ply , key , val , editor )
		if ent == self then
			local allow = self:CanPlayerEditVariable( ply , key , val , editor )

			if key == "Key" then
				local btn = tonumber( val )
				if btn and not self:IsKeyAllowed( btn ) then
					allow = false
				end
			end

			--call the editkey hook only if the other one didn't say anything in the matter for this
			if key == "Key" and allow == nil then
				allow = self:CanEditKey( ply , val , editor )
			end

			--we'll only override all the hooks if the answer is yes or no, nil keeps the default behaviour
			if allow ~= nil then
				return allow
			end
		end
	end

	--our key can only be modified by the carrying player or by anyone if it's not carried at all
	function ENT:CanEditKey( ply , val , editor )
		--you could override me if you want to, you could leave your friends behind
		return self:IsCarriedBy( ply ) or not self:IsCarried()
	end

	function ENT:CanPlayerEditVariable( ply , key , val , editor )
		--override me
	end

	--we add this entity's position to the visibility position, but only if it doesn't attach to the player
	function ENT:HandleEntityVisibility( ply , viewent )
		if self:IsCarriedBy( ply ) and not self.AttachesToPlayer and self ~= viewent then --viewents already add themselves to the pvs
			AddOriginToPVS( self:GetPos() )
		end

		--HOW CONVENIENT!!! this hook is called before the client computes what he can see
		--so we can simply use this before this entity gets recomputed for transmission

		--TODO: This will be removed and the ENT:UpdateTransmitState() below will be enabled once Willox is done with TRANSMIT_OWNERONLY
		if self.DontTransmitToOthers and not game.SinglePlayer() then

			local shouldpreventtransmit = false

			if self:IsCarried() then
				shouldpreventtransmit = not self:IsCarriedBy( ply , true )
			end

			self:SetPreventTransmit( ply , shouldpreventtransmit )
		end
	end

	--[[
	function ENT:UpdateTransmitState()


		if self.DontTransmitToOthers and self:IsCarried() then
			return TRANSMIT_OWNERONLY
		end


		--don't return anything, default behaviour
	end
	]]

else

	function ENT:GetConVar()

		--the slotname changed, so we forget this cvar to let another one with the same slot use it
		--and we let the code below create/get one with our slotname
		if self.ConfigurableConVar and self.ConfigurableConVar:GetName() ~= self:GetConVarName() then
			self.ConfigurableConVar = nil
		end

		if not self.ConfigurableConVar then
			--internally this returns the original convar if it was already created, so it's not that big of a deal, this could be done in a better way however
			self.ConfigurableConVar = CreateConVar( self:GetConVarName() , self:GetKey() , FCVAR_ARCHIVE + FCVAR_USERINFO , "Configures the key for "..self:GetSlotName().. " , created by "..self:GetClass() )
		end

		return self.ConfigurableConVar
	end

	function ENT:InternalHandleLoopingSounds( calledinprediction )
		--the calledinprediction variable makes it so HandleLoopingSounds is called from ENT:Think instead
		--and yes, this will never be set at all during singleplayer because there's no prediction

		--if this is set then there's no need to call iscarried checks below, we're always called when that happens
		if calledinprediction and not IsFirstTimePredicted() then
			return
		end

		if game.SinglePlayer() or not self:IsCarried() or not self:IsCarriedByLocalPlayer() or ( self:IsCarriedByLocalPlayer() and calledinprediction ) then
			self:HandleLoopingSounds()
		end
	end

	function ENT:HandleLoopingSounds()
		--override me
	end

	function ENT:IsCarriedByLocalPlayer( checkspectator )
		return self:IsCarriedBy( LocalPlayer() , checkspectator )
	end

	function ENT:ShouldDrawLocalPlayer( checkspectator )
		if checkspectator then
			if LocalPlayer():GetObserverMode() == OBS_MODE_IN_EYE and IsValid( LocalPlayer():GetObserverTarget() ) then
				if LocalPlayer():GetObserverTarget():IsPlayer() then
					return LocalPlayer():GetObserverTarget():ShouldDrawLocalPlayer() --assuming this even works, otherwise just return false
				end
				return false
			end
		end
		return LocalPlayer():ShouldDrawLocalPlayer()
	end

	--immediately make this entity predicted again, if it's equipped by this localplayer
	function ENT:HandleFullPacketUpdate( ent , shouldtransmit )
		if ent == self and shouldtransmit then
			self:HandlePrediction()
		end
	end

	function ENT:HandlePrediction()

		local carried = self:IsCarriedByLocalPlayer()

		--either the gravity gun or some other stuff is carrying me, don't do anything on prediction
		--because they might enable it to carry us around smoothly
		--also don't enable prediction in singleplayer

		if self:GetBeingHeld() or game.SinglePlayer() then
			return
		end

		if self:GetPredictable() ~= carried then
			self:SetPredictable( carried )
		end
	end

	function ENT:HandleButtonBind()
		--did not disable the function call from Think as someone might want to override this

		if self.SaveButtonToCvar then
			--this is a one way server to client saving, the reason I do this is because the user should usually change the value from
			--client to server with the edit system, it still goes to the server, but not to the cvar first, so we save it from the client to the cvar

			--basically we just use the cvar as a way to save the button, but it does come at the cost of not being able to update the cvar and have it update on the
			--entity, this will probably change in the future
			local mykey = self:GetKey()

			--can't use GetControllingPlayerConVarKey as I also need to SetInt on it
			local cv = self:GetConVar()

			if cv then
				if ( mykey ~= cv:GetInt() and self:IsKeyAllowed( mykey ) ) --[[or not self:IsKeyAllowed( cv:GetInt() )]] then
					cv:SetInt( mykey )
				end
			end
		end
	end



	function ENT:CreateContextMenuButton( iconlayout )
		local button = iconlayout:Add( "DPredEnt" )
		button:SetSize( 80 , 80 )
		button:SetClassName( self.PrintName , self:GetSlotName() )
		button:SetMaterial( self.Folder .. ".png" )
		button:SetPredEnt( self )
		--SetClassName
	end

	function ENT:GetContextMenuButton( iconlayout )
		local contextbutton = nil

		for i = 0 , iconlayout:ChildCount() do

			local child = iconlayout:GetChild( i )

			if IsValid( child ) and child:GetName() == "DPredEnt" and child:GetSpawnName() == self:GetSlotName() and child:GetPredEnt() == self then
				contextbutton = child
				break
			end

		end

		return contextbutton
	end

	--forcefully removes it in case it fucks up
	function ENT:RemoveContextMenuButton( iconlayout , buttonpanel )
		if IsValid( buttonpanel ) then
			buttonpanel:Remove()
		end
	end

	function ENT:GetContextMenuLayout()
		if not IsValid( g_ContextMenu ) then
			return
		end

		local iconlayout = nil

		for i = 0 , g_ContextMenu:ChildCount() do

			local child = g_ContextMenu:GetChild( i )

			if IsValid( child ) and child:GetName() == "DIconLayout" then
				iconlayout = child
				break
			end

		end

		return iconlayout
	end

	function ENT:HandleContextMenuButton( docleanup )

		local iconlayout = self:GetContextMenuLayout()

		if not IsValid( iconlayout ) then
			return
		end

		local buttonpanel = self:GetContextMenuButton( iconlayout )

		if IsValid( buttonpanel ) and ( not self:IsCarriedByLocalPlayer() or docleanup )then
			self:RemoveContextMenuButton( iconlayout , buttonpanel )
			iconlayout:InvalidateLayout()
		end

		if not IsValid( buttonpanel ) and self:IsCarriedByLocalPlayer() then
			self:CreateContextMenuButton( iconlayout )
			iconlayout:InvalidateLayout()
		end

	end



	function ENT:DrawFirstPersonInternal()
		if self.AttachesToPlayer and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
			local fov = nil	--TODO: allow changing the FOV
			cam.Start3D( nil , nil , fov , nil , nil , nil , nil , 1 , -1 )	--znear is 1 and zfar is -1
				render.DepthRange( 0 , 0.1 )	--same depth hack valve uses in source!
					self:DrawFirstPerson( self:GetControllingPlayer() )
				render.DepthRange( 0 , 1 )		--they don't even set these back to the original values
			cam.End3D()
		end
	end

	--viewmodels don't draw without an associated weapon ( this is due to garryness, they always do in source )
	function ENT:DrawViewModelInternal( vm , ply , wpn )
		if self.AttachesToPlayer and self:IsCarriedBy( ply , true ) then
			self:DrawOnViewModel( ply , vm , ply:GetHands() ) --this will stay here
		end
	end

	function ENT:DrawFirstPerson( ply )
		--override me
	end

	--mainly used to draw stuff like shields, gloves or whatever on the viewmodel hands

	function ENT:DrawOnViewModel( ply , vm , hands )
		--override me
	end

	--the flags aren't passed yet, maybe in a future update

	function ENT:DrawOnPlayer( ply , flags )
		self:DrawModel( flags )

	end

	function ENT:Draw( flags )
		local pos , ang = self:GetCustomParentOrigin()
		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )
	end

end

--these are here to "unify" our two calls to SetNWEntity and GetNWEntity
--these might be called from pe_drop and some other stuff, so we can't rely on the entity itself being present, as lame as that is
--the alternative would be to have these as global, which would be lamer
function ENT.SetOnPlayer( ply , slot , ent )
	ply:SetNW2Entity( slot , ent )
end

function ENT.GetOnPlayer( ply , slot )
	return ply:GetNW2Entity( slot )
end

function ENT:IsAttached()
	local ply = self:GetControllingPlayer()
	return self:GetOwner() == ply and self:GetParent() == ply
end

--LOOK I DON'T CARE, this check is lame as shit but I can't be arsed to add duplicated code
function ENT:IsCarried()
	return self:IsCarriedBy( self:GetControllingPlayer() )
end

function ENT:IsCarriedBy( ply , checkspectator )

	if checkspectator and ply:GetObserverMode() ~= OBS_MODE_NONE then
		return self:IsCarriedBy( ply:GetObserverTarget() )
	end

	return IsValid( ply ) and ply == self:GetControllingPlayer() and self.GetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() ) == self
end

function ENT:IsKeyDown()
	return self:GetKeyPressed()
end

--these functions should totally not be tied to this SENT, but I don't want to go out of my way to add them to an util file
function ENT:IsValidButton( btn )
	return btn > BUTTON_CODE_NONE and btn < BUTTON_CODE_COUNT
end

function ENT:IsKeyboardButton( btn )
	return btn > KEY_FIRST and btn < KEY_COUNT
end

function ENT:IsMouseButton( btn )
	return btn >= MOUSE_FIRST and btn < MOUSE_LAST
end

function ENT:IsJoystickButton( btn )
	return btn >= JOYSTICK_FIRST and btn < JOYSTICK_LAST
end

function ENT:IsKeyAllowed( btn )
	if bit.band( self.KeyAllowedFlags , self.KeyAllowedKeyboard ) == 0 and self:IsKeyboardButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedMouse ) == 0 and self:IsMouseButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedJoystick ) == 0 and self:IsJoystickButton( btn ) then
		return false
	end

	return self:IsValidButton( btn )
end

function ENT:GetConVarName()
	return "prdent_key_"..self:GetSlotName()
end

function ENT:GetControllingPlayerConVarKey()
	local defaultkey = BUTTON_CODE_NONE

	if self:IsCarried() then
		if SERVER then
			return self:GetControllingPlayer():GetInfoNum( self:GetConVarName() , defaultkey )
		else
			--the clientside implementation of GetInfoNum makes a GetConVar lookup everytime, so use the cached one instead
			local cv = self:GetConVar()

			if cv then
				return cv:GetInt()
			end
		end
	end

	return defaultkey
end

function ENT:HandleCalcMainActivity( ply , velocity )
	if self:IsCarriedBy( ply ) then
		local calcideal , calcseqovr = self:HandleMainActivityOverride( ply , velocity )
		if calcideal and calcseqovr then
			return calcideal , calcseqovr
		end
	end
end

function ENT:HandleUpdateAnimation( ply, velocity, maxseqgroundspeed )
	if self:IsCarriedBy( ply ) then
		if self:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed ) then
			return true
		end
	end
end

function ENT:HandleAnimationEvent( ply, event, data )
	if self:IsCarriedBy( ply ) then
		if self:HandleAnimationEventOverride( ply , event , data ) then
			return ACT_INVALID
		end
	end
end

function ENT:HandleMainActivityOverride( ply , velocity )
	--override me
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	--override me
end

function ENT:HandleAnimationEventOverride( ply , event , data )
	--override me
end

function ENT:HandlePredictedStartCommand( ply , cmd )
	if self:IsCarriedBy( ply ) then
		self:PredictedStartCommand( ply , cmd )
	end
end

function ENT:HandlePlayerButtonDown( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , true )
	end
end

function ENT:HandlePlayerButtonUp( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , false )
	end
end

function ENT:HandlePlayerButtonInternal( ply , btn , pressed )
	local mykey = self:GetKey()
	if self:IsKeyAllowed( mykey ) and btn == mykey then
		self:SetKeyPressed( pressed )
	end

	self:PredictedPlayerButtonPress( ply , btn , pressed )
end

function ENT:HandlePredictedSetupMove( ply , mv , cmd )
	if self:IsCarriedBy( ply ) then
		if self:PredictedSetupMove( ply , mv , cmd ) then
			return true
		end
	end
end

function ENT:HandlePredictedMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedThink( ply , mv )
	if self:IsCarriedBy( ply ) then
		if CLIENT then
			self:InternalHandleLoopingSounds( true )
		end
		self:PredictedThink( ply , mv )
	end
end

function ENT:HandlePredictedFinishMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedFinishMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedHitGround( ply , inwater , onfloater , speed )
	if self:IsCarriedBy( ply ) then
		if self:PredictedHitGround( ply , inwater , onfloater , speed ) then
			return true
		end
	end
end

function ENT:PredictedStartCommand( ply , cmd )
	--override me
end

function ENT:PredictedPlayerButtonPress( ply , btn , pressed )
	--override me
end

function ENT:PredictedSetupMove( ply , mv , cmd )
	--override me
end

function ENT:PredictedMove( ply , mv )
	--override me
end

function ENT:PredictedThink( ply , mv )
	--override me
end

function ENT:PredictedFinishMove( ply , mv )
	--override me
end

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )
	--override me
end

--Allows for predicted movement simulation on non player entities, without disrupting the player movement itself
--FinishMove should be the best place for this, since even in case of fuckups, the rest of the movement should be fine

--[[
	function ENT:PredictedFinishMove( ply , mv )

		local sv = self:BackupMoveData( mv )

		--set the data you want on the movedata, such as the entity origin, speed, angles and stuff

		--run the entity traces

		--set the final position of the entity here with the same way garry does ( see drive.End or whatever it's called )

		--restore the movedata on the player as if nothing happened

		self:RestoreMoveData( mv , sv )


	end
]]


local movedatameta = FindMetaTable( "CMoveData" )

local emptyvalues = {
	[TYPE_VECTOR] = vector_origin * 1,
	[TYPE_ANGLE] = angle_zero * 1,
	[TYPE_NUMBER] = 0,
	[TYPE_ENTITY] = NULL,
}

local methods = {}

--cache the methods we can actually use
for i , v in pairs( movedatameta ) do
	--see if this function has a pattern like "Get*" or whatever
	--then strip out "Get" and add it here
	local functionname = i
	if functionname:find( "^Get" ) then
		local functionnamestripped = functionname:gsub( "^Get" , "" )

		local setter = movedatameta["Set"..functionnamestripped]

		if setter then
			--add the stripped method to the table to reuse later
			methods[#methods + 1] = functionnamestripped
		end
	end
end

function ENT:BackupMoveData( mv )

	if not mv or not movedatameta then
		return
	end

	local sv = {}
	--save the movedata by name on the table, then go trough the metatable to get the setters and set values to empty ones

	for i , v in pairs( methods ) do
		--see if this function has a pattern like "Get*" or whatever
		--then strip out "Get" and add it here

		--we could've cached the functions as well, but just in case someone wants us to use the modified ones
		local getter = movedata["Get"..v]
		local setter = movedata["Set"..v]

		local backupvalue = getter( mv )

		sv[v] = backupvalue

		if emptyvalues[TypeID( backupvalue )] ~= nil then
			setter( mv , emptyvalues[TypeID( backupvalue )] )
		end
	end

	return sv
end

function ENT:RestoreMoveData( mv , sv )
	if not mv or not sv or not movedatameta then
		return
	end

	--restore the values from the table, prevents duplicated code by using the setters from the metatable directly
	for i , v in pairs( sv ) do
		local setter = movedatameta["Set"..i]
		if setter then
			setter( mv , v )
		end
	end
end

--attaches the entity to the player depending on the attachmentinfo table
--you can override this safely as long as you keep the part with ply:SetupBones()
--although you generally should just use the attachment info table instead

function ENT:GetCustomParentOrigin()

	if not self.AttachmentInfo then
		return
	end

	local ply = self:GetControllingPlayer()

	--duplicated check, but people might call this manually in the entity draw hook, so gotta do this
	if not self:IsCarriedBy( ply ) then
		return
	end

	--I put this here because since the entity moves to the player bone matrix, it'll only be updated on the client
	--when the player is actally drawn, or his bones are setup again ( which happens before a draw anyway )
	--this also fixes sounds on the client playing at the last location the LocalPlayer() was drawn

	if CLIENT and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
		ply:SetupBones()
	end

	local boneid = ply:LookupBone( self.AttachmentInfo.BoneName )

	if not boneid then
		return
	end

	local matrix = ply:GetBoneMatrix( boneid )

	if not matrix then
		return
	end

	return LocalToWorld( self.AttachmentInfo.OffsetVec , self.AttachmentInfo.OffsetAng , matrix:GetTranslation() , matrix:GetAngles() )
end

--if we're attached to a player, use custom origin from the function above
--this is called shared, yes it's more expensive than source's normal parenting but it's worth it

function ENT:CalcAbsolutePosition( pos , ang )
	if self.AttachesToPlayer and self:IsCarried() then
		return self:GetCustomParentOrigin()
	end
end

function ENT:EmitPESound( soundname , level , pitch , volume , chan , predicted , activator , worldpos )

	--must've been called manually by some ent:Fire or ent:Input functions
	if IsValid( activator ) and not activator:IsPlayer() then
		activator = NULL
	end

	if not level then
		level = 75
	end

	if not pitch then
		pitch = 100
	end

	if not volume then
		volume = 1
	end

	if not chan then
		chan = CHAN_AUTO
	end

	if game.SinglePlayer() then
		predicted = false
	end

	if not worldpos then
		worldpos = vector_origin
	end

	if SERVER then

		local plys = RecipientFilter()

		if IsValid( activator ) and not predicted and not activator:IsBot() then
			plys:AddPlayer( activator )
		else

			plys:AddPVS( self:GetPos() )

			if predicted and IsValid( self:GetControllingPlayer() ) then
				plys:RemovePlayer( self:GetControllingPlayer() )
			end

		end

		if plys:GetCount() == 0 then
			return
		end

		net.Start( "pe_playsound" )
			net.WriteEntity( self )
			net.WriteString( soundname )
			net.WriteFloat( level )
			net.WriteFloat( pitch )
			net.WriteFloat( volume )
			net.WriteUInt( chan , 8 )
			net.WriteVector( worldpos )
		net.Send( plys )

	else
		if ( predicted and IsFirstTimePredicted() ) or not predicted then
			if worldpos and worldpos ~= vector_origin then
				sound.Play( soundname, worldpos, level, pitch , volume )
			else
				self:EmitSound( soundname , level , pitch , volume , chan )
			end
		end
	end
end

function ENT:OnRemove()
	--if we're being forcibly removed, make sure we're also dropped properly, in case the entity needs to do
	--some stuff on the player before it expires
	if SERVER and self:IsCarried() then
		self:Remove( true )
	end

	if CLIENT then
		self:HandleContextMenuButton( true )
	end

	self:HandleHooks( true ) --remove the hooks immediately instead of relying on garry's "remove if called again"


end

--stuff that should be in an autorun file but that I can't be arsed to split up to

if SERVER then

	util.AddNetworkString( "pe_pickup" )
	util.AddNetworkString( "pe_playsound" )

	--save the function before ENT gets removed during registration
	local GetPredictedEntityOnPlayer = ENT.GetOnPlayer

	concommand.Add( "pe_drop" , function( ply , cmd , args , fullstr )

		if not IsValid( ply ) then
			return
		end

		local nwslot = args[1]

		if not nwslot then
			return
		end

		local slotent = GetPredictedEntityOnPlayer( ply , nwslot )--ply:GetNWEntity( nwslot )

		--user tried to drop an invalid or an entity which is not a predicted entity, or doesn't have a slot assigned

		if not IsValid( slotent ) or not slotent.IsPredictedEnt or slotent:GetSlotName() == "" then
			return
		end

		slotent:Remove( false )

	end)

else

	--tells the hud to show the player the entity pickup
	language.Add( "invalid_entity" , "Invalid Entity" )
	language.Add( "dropped_invalid_entity" , "Dropped Invalid Entity" )

	net.Receive( "pe_pickup" , function( len )
		local str = net.ReadString() or "invalid_entity"
		local dropped = tobool( net.ReadBit() )

		if dropped then
			str = "dropped_" .. str
		end

		gamemode.Call( "HUDItemPickedUp" , str )
	end)

	net.Receive( "pe_playsound" , function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.EmitPESound then
			return
		end

		local soundname = net.ReadString() --yes I know that I can do util.addnetworkstring to cache it but I cba

		local level = net.ReadFloat()
		local pitch = net.ReadFloat()
		local volume = net.ReadFloat()
		local chan = net.ReadUInt( 8 )
		local pos = net.ReadVector()

		ent:EmitPESound( soundname , level , pitch , volume , chan , false , NULL , pos )
	end)

	--[[
		A DProperty that allows the user to set a preferred key using the same DBinder used in sandbox's tools
	]]

	local DBinderProperty = {}

	function DBinderProperty:Init()
	end

	function DBinderProperty:Setup( vars )

		self:Clear()

		local ctrl = self:Add( "DBinder" )
		ctrl:Dock( FILL )

		self.IsEditing = function( self )
			return ctrl.Trapping
		end

		self.SetValue = function ( self , val )
			ctrl:SetSelected( tonumber( val ) )	--use this instead of setValue to possibly avoid feedback loops
		end

		--DBinder doesn't have an onchange callback, so we must do this little hack to add it
		--[[
		ctrl.SetValue = function( ctrl , val )
			ctrl:SetSelected( val )
			self:ValueChanged( val )
		end
		]]

		ctrl.OnChange = function( ctrl , val )
			self:ValueChanged( val )
		end


	end

	derma.DefineControl( "DProperty_EditKey" , "" , DBinderProperty , "DProperty_Generic" )

	local DPredEnt = {
		matOverlay_Normal = Material( "gui/ContentIcon-normal.png" ),
		matOverlay_Hovered = Material( "gui/ContentIcon-hovered.png" )
	}

	AccessorFunc( DPredEnt, "m_MaxBorder", "MaxBorder" )
	AccessorFunc( DPredEnt, "m_MaterialName", "MaterialName" )
	AccessorFunc( DPredEnt, "m_PredEnt", "PredEnt" )
	AccessorFunc( DPredEnt, "m_Border", "Border" )
	AccessorFunc( DPredEnt, "m_Color", "Color" )
	AccessorFunc( DPredEnt, "m_Type", "ContentType" )
	AccessorFunc( DPredEnt, "m_SpawnName", "SpawnName" )
	AccessorFunc( DPredEnt, "m_NPCWeapon", "NPCWeapon" )
	AccessorFunc( DPredEnt, "m_Image", "Image" )
	AccessorFunc( DPredEnt, "m_Label", "Label" )

	function DPredEnt:Init()

		local w , h = 128, 128
		self:SetSize( w , h )

		self:SetPaintBackground( false )

		self:SetText( "" )
		self:SetDoubleClickingEnabled( false )

		self:SetImage( self:Add( "DImage" ) )
		self:GetImage():SetVisible( false )

		self:SetLabel( self:Add( "DLabel" ) )
		self:GetLabel():Dock( BOTTOM )

		self:GetLabel():SetContentAlignment( 5 )

		self:GetLabel():SetTextColor( Color( 255, 255, 255, 255 ) )
		self:GetLabel():SetExpensiveShadow( 1, Color( 0, 0, 0, 200 ) )

		self:SetBorder( 0 )



	end



	function DPredEnt:PerformLayout( w , h )
		self:SetMaxBorder( w / 16 )
		self:GetImage():SetPos( w / 32 , w / 32 )
		self:GetImage():SetSize( w - w / 16 , h - w / 16 )
		self:GetLabel():SetTall( math.Round( w / 7 ) )
		self:GetLabel():DockMargin( math.Round( w / 32 ) , 0 , math.Round( w / 32 ) , math.Round( w / 21 ) )
	end


	function DPredEnt:SetClassName( name , class )

		self:SetTooltip( name )
		self:GetLabel():SetText( name )
		self:SetSpawnName( class )
	end

	function DPredEnt:SetMaterial( name )

		self:SetMaterialName( name )

		local mat = Material( name )

		-- Look for the old style material
		if not mat or mat:IsError() then

			name = name:Replace( "entities/", "VGUI/entities/" )
			name = name:Replace( ".png", "" )
			mat = Material( name )

		end

		-- Couldn't find any material.. just return
		if not mat or mat:IsError() then
			return
		end

		self:GetImage():SetMaterial( mat )

	end

	function DPredEnt:Think()
		if not IsValid( self:GetPredEnt() ) or not self:GetPredEnt().IsPredictedEnt  then
			self:Remove()
		end
	end

	function DPredEnt:DoRightClick()
		self:OpenMenu()
	end

	function DPredEnt:DoClick()
		RunConsoleCommand( "pe_drop" , self:GetSpawnName() or ""  )
	end

	function DPredEnt:OpenMenu()
		if IsValid( self:GetPredEnt() ) then
			properties.OpenEntityMenu( self:GetPredEnt() )
		end
	end

	function DPredEnt:OnDepressionChanged( b )
	end

	function DPredEnt:Paint( w, h )

		if self.Depressed and not self.Dragging then
			if self:GetBorder() ~= self:GetMaxBorder() then
				self:SetBorder( self:GetMaxBorder() )
				self:OnDepressionChanged( true )
			end
		else
			if self:GetBorder() ~= 0 then
				self:SetBorder( 0 )
				self:OnDepressionChanged( false )
			end
		end

		render.PushFilterMag( TEXFILTER.ANISOTROPIC )
		render.PushFilterMin( TEXFILTER.ANISOTROPIC )

		local bx , by , bw , bh = self:GetBorder(), self:GetBorder(), w - self:GetBorder() * 2 , h - self:GetBorder() * 2


		self:GetImage():PaintAt( bx + self:GetMaxBorder() / 2 , by + self:GetMaxBorder() / 2 , bw - self:GetMaxBorder() , bh - self:GetMaxBorder() )



		render.PopFilterMin()
		render.PopFilterMag()

		surface.SetDrawColor( 255, 255, 255, 255 )

		if not dragndrop.IsDragging() and ( self:IsHovered() or self.Depressed or self:IsChildHovered() ) then

			surface.SetMaterial( self.matOverlay_Hovered )
			self:GetLabel():Hide()

		else

			surface.SetMaterial( self.matOverlay_Normal )
			self:GetLabel():Show()

		end

		surface.DrawTexturedRect( bx , by , bw , bh )

	end

	derma.DefineControl( "DPredEnt" , "ContentIcon for Predicted entities in the context menu" , DPredEnt , "DButton" )

end

--PATH lua/entities/gmod_contr_spawner/shared.lua:
return gluapack()()
--PATH lua/entities/headhunter.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "Z-95 Headhunter"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Republic"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/z95/z951.mdl"
ENT.Vehicle = "Headhunter"
ENT.StartHealth = 1500;
ENT.Allegiance = "Rebels";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("headhunter");
	e:SetPos(tr.HitPos + Vector(0,0,0));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()


	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetForward()*70+self:GetRight()*-212.5+self:GetUp()*65,
		Right = self:GetPos()+self:GetForward()*70+self:GetRight()*212.5+self:GetUp()*65,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2500;
	self.ForwardSpeed = 1000;
	self.UpSpeed = 600;
	self.AccelSpeed = 8;
	self.CanStandby = true;
	self.CanBack = true;
	self.CanRoll = true;
	self.CanStrafe = false;
	self.Cooldown = 2;
	self.CanShoot = true;
	self.Bullet = CreateBulletStructure(75,"red");
	self.FireDelay = 0.2;
	self.AlternateFire = true;
	self.FireGroup = {"Left","Right",};
	self.HasWings = false;

	//self.ExitModifier = {x=0,y=-325,z=100};

	self.BaseClass.Initialize(self);
end

end

if CLIENT then
	
	ENT.CanFPV = false;
	ENT.Sounds={
		Engine=Sound("vehicles/xwing/xwing_fly2.wav"),
	}
	
	local matPlasma	= Material( "effects/strider_muzzle" )
	function ENT:Draw()
		self:DrawModel();

		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		local vel = self:GetVelocity():Length();
		
		if(vel > 150) then
			if(Flying and !TakeOff and !Land) then

				for i=1,4 do
					local vOffset = self.EnginePos[i] 
					local scroll = CurTime() * -20
						
					render.SetMaterial( matPlasma )
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 24, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 20, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 16, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 24, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 20, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 16, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 24, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 20, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 16, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
				end
			end
		end
	end
	
	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local p = LocalPlayer()		
		local FWD = self:GetForward();
		local id = self:EntIndex();

		for k,v in pairs(self.EnginePos) do
			
			local blue = self.FXEmitter:Add("sprites/bluecore",v+FWD*-3)
			blue:SetVelocity(normal)
			blue:SetDieTime(FrameTime()*1.25)
			blue:SetStartAlpha(255)
			blue:SetEndAlpha(255)
			blue:SetStartSize(8)
			blue:SetEndSize(5)
			blue:SetRoll(roll)
			blue:SetColor(255,255,255)
			
			local dynlight = DynamicLight(id + 4096 * k);
			dynlight.Pos = v+FWD*-5;
			dynlight.Brightness = 5;
			dynlight.Size = 150;
			dynlight.Decay = 1024;
			dynlight.R = 100;
			dynlight.G = 100;
			dynlight.B = 255;
			dynlight.DieTime = CurTime()+1;
			
		end
	
	end
	
	function ENT:Think()
		local Flying = self:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then
			self.EnginePos = {
				self:GetPos()+self:GetForward()*-185+self:GetUp()*42.5+self:GetRight()*49,
				self:GetPos()+self:GetForward()*-185+self:GetUp()*75+self:GetRight()*49,
				self:GetPos()+self:GetForward()*-185+self:GetUp()*42.5+self:GetRight()*-49,
				self:GetPos()+self:GetForward()*-185+self:GetUp()*75+self:GetRight()*-49,
			}
			self:FlightEffects();
		end
		self.BaseClass.Think(self);
	end
	
	ENT.ViewDistance = 800;
    ENT.ViewHeight = 200;
	
	function HeadhunterReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingHeadhunter");
		local self = p:GetNWEntity("Headhunter");
		if(Flying and IsValid(self)) then
			SW_HUD_DrawHull(1500);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			SW_HUD_Compass(self);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "HeadhunterReticle", HeadhunterReticle)

end
--PATH lua/entities/heart_turbolaser/shared.lua:
return gluapack()()
--PATH lua/entities/imp_speeder.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "speeder_base"
ENT.Type = "vehicle"

ENT.PrintName = "Imperial Speeder"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Empire"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.Vehicle = "ImperialSpeeder";
ENT.EntModel = "models/av21/av211.mdl";
ENT.StartHealth = 1000;
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.NextUse = {Use = CurTime(),Fire = CurTime()};
ENT.FireSound = Sound("weapons/xwing_shoot.wav");

AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("imp_speeder");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw+180,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()
	self.SeatClass = "phx_seat2";
	self.BaseClass.Initialize(self);
	local driverPos = self:GetPos()+self:GetUp()*10+self:GetForward()*35+self:GetRight()*-15;
	local driverAng = self:GetAngles()+Angle(0,90,0);
	local passPos = self:GetPos()+self:GetUp()*20+self:GetForward()*25+self:GetRight()*15
	self:SpawnChairs(driverPos,driverAng,true,passPos,driverAng);
	self.CanBack = true;
	self.ForwardSpeed = -650;
	self.BoostSpeed = -1000
	self.AccelSpeed = 8;
	self.StandbyHoverAmount = 80;

end


function ENT:OnTakeDamage(dmg) --########## Shuttle's aren't invincible are they? @RononDex

	local health=self:GetNetworkedInt("Health")-(dmg:GetDamage()/2)

	self:SetNWInt("Health",health);
	
	if(health<100) then
		self.CriticalDamage = true;
		self:SetNWBool("CriticalDamage",true);
	end
	
	
	if((health)<=0) then
		self:Bang() -- Go boom
	end
end



local ZAxis = Vector(0,0,1);

function ENT:PhysicsSimulate( phys, deltatime )
	self.BackPos = self:GetPos()+self:GetForward()*80+self:GetUp()*15
	self.FrontPos = self:GetPos()+self:GetForward()*-100+self:GetUp()*15
	self.MiddlePos = self:GetPos()+self:GetUp()*15;
	if(self.Inflight) then
		local UP = ZAxis;
		self.RightDir = self.Entity:GetForward():Cross(UP):GetNormalized();
		self.FWDDir = self.Entity:GetForward();	
				
		self:RunTraces();

		self.ExtraRoll = Angle(0,0,self.YawAccel / 2);
		if(!self.WaterTrace.Hit) then
			if(self.FrontTrace.HitPos.z >= self.BackTrace.HitPos.z) then
				self.PitchMod = Angle(math.Clamp((self.BackTrace.HitPos.z - self.FrontTrace.HitPos.z),-45,45)/2*-1,0,0)
			else
				self.PitchMod = Angle(math.Clamp(-(self.FrontTrace.HitPos.z - self.BackTrace.HitPos.z),-45,45)/2*-1,0,0)
			end
		end
	end

	
	self.BaseClass.PhysicsSimulate(self,phys,deltatime);
	

end

end

if CLIENT then
	ENT.Sounds={
		Engine=Sound("landspeeder_fly.wav"),
	}
	ENT.HasCustomCalcView = true;
	local Health = 0;
	function ENT:Think()
		self.BaseClass.Think(self);
		local p = LocalPlayer();
		local Flying = p:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then
			Health = self:GetNWInt("Health");
			local EnginePos = {
				self:GetPos()+self:GetForward()*120+self:GetRight()*55+self:GetUp()*20,
				self:GetPos()+self:GetForward()*120+self:GetRight()*-55+self:GetUp()*20,
			}
			self:Effects(EnginePos)
		end
		
	end

	local View = {}
	function CalcView()
		
		local p = LocalPlayer();
		local self = p:GetNWEntity("ImperialSpeeder", NULL)
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);

		if(IsValid(self)) then

			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					local pos = self:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-300+self:GetUp()*120;
					//local pos = self:GetPos()+self:GetRight()*250+self:GetUp()*100;
					//local face = self:GetAngles() + Angle(0,-90,0);
					local face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
						View.origin = pos;
						View.angles = face;
					return View;
				end
			end
			
			if(IsValid(PassengerSeat)) then
				if(PassengerSeat:GetThirdPersonMode()) then
					local pos = self:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-300+self:GetUp()*120;
					//local pos = self:GetPos()+self:GetRight()*250+self:GetUp()*100;
					//local face = self:GetAngles() + Angle(0,-90,0);
					local face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
						View.origin = pos;
						View.angles = face;
					return View;
				end
			end
		end
	end
	hook.Add("CalcView", "ImperialSpeederView", CalcView)

	
	hook.Add( "ShouldDrawLocalPlayer", "ImperialSpeederDrawPlayerModel", function( p )
		local self = p:GetNWEntity("ImperialSpeeder", NULL);
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);
		if(IsValid(self)) then
			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					return true;
				end
			elseif(IsValid(PassengerSeat)) then
				if(PassengerSeat:GetThirdPersonMode()) then
					return true;
				end
			end
		end
	end);
	
	function ImperialSpeederReticle()
	
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingImperialSpeeder");
		local self = p:GetNWEntity("ImperialSpeeder");
		if(Flying and IsValid(self)) then
				
			SW_Speeder_DrawHull(1000)
			SW_Speeder_DrawSpeedometer()
	

		end
	end
	hook.Add("HUDPaint", "ImperialSpeederReticle", ImperialSpeederReticle)
	
	
end
--PATH lua/entities/kingpommes_swv_patroltransport_rep.lua:

util.PrecacheModel( "models/KingPommes/starwars/patrol_transport/main.mdl" )
if (!util.IsValidModel( "models/KingPommes/starwars/patrol_transport/main.mdl" )) then return end

ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Base = "fighter_base"
ENT.Type = "vehicle"
 
ENT.PrintName = "Republic Patrol Transport"
ENT.Author = "KingPommes, Mattzi"
ENT.Category = "Star Wars Vehicles: Republic"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false
ENT.AdminSpawnable = false
 
ENT.EntModel = "models/KingPommes/starwars/patrol_transport/main.mdl"
ENT.Vehicle = "REP_PATROL"
ENT.StartHealth = 4500
ENT.Allegiance = "Republic"
list.Set("SWVehicles", ENT.PrintName, ENT)
if SERVER then
   
    ENT.FireSound = Sound("weapons/tie_shoot.wav")
   
    AddCSLuaFile()
    function ENT:SpawnFunction(pl, tr)
        local e = ents.Create("kingpommes_swv_patroltransport_rep")
        e:SetPos(tr.HitPos + Vector(0,0,2))
        e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0))
        e:Spawn()
        e:Activate()
        e:PrecacheGibs()
		e:SetSkin(3)
        return e
    end
 
    function ENT:SpawnLauncher()
        local pos = self:GetPos()
        local ang1 = self:GetAngles()
        local ang2 = self:GetAngles() + Angle(90, 0, 0)
 
        local e = ents.Create("info_target")
        e:SetPos(pos)
        e:SetAngles(ang1)
        e:SetParent(self)
        e:Spawn()
        e:Fire("AddOutput", "targetname target", 0)
        self.Target = e
 
        local e1 = ents.Create("npc_launcher")
        e1:SetPos(pos)
        e1:SetAngles(ang2)
        e1:SetParent(self)
        e1:Spawn()
        e1:Activate()
        e1:Fire("SetEnemyEntity", "target")
        e1:Fire("AddOutput", "damage 1000")
        e1:Fire("AddOutput", "DamageRadius 300")
        --e1:Fire("AddOutput", "FlySound weapons/rpg/rocket1.wav")
        e1:Fire("AddOutput", "Gravity 0")
        e1:Fire("AddOutput", "HomingDelay 0")
        e1:Fire("AddOutput", "HomingDuration 0")
        e1:Fire("AddOutput", "HomingStrength 0")
        e1:Fire("AddOutput", "LaunchSmoke 1")
        e1:Fire("AddOutput", "SmokeTrail 1")
        e1:Fire("AddOutput", "LaunchSound weapons/stinger_fire1.wav")
        e1:Fire("AddOutput", "LaunchSpeed 5000")
        e1:Fire("AddOutput", "MaxRange 99999")
        e1:Fire("AddOutput", "MinRange 100")
        e1:Fire("AddOutput", "MissileModel models/kingpommes/starwars/tie/missile.mdl")
        e1:Fire("AddOutput", "SpinMagnitude 0")
        e1:Fire("AddOutput", "SpinSpeed 0")
        self.Launcher = e1
    end
   
    function ENT:SpawnTurrets()
        self.Turrets = {}
        for k,v in pairs(self.WeaponLocations) do
            local e = ents.Create("base_anim")
            e:SetModel("models/KingPommes/starwars/patrol_transport/turret.mdl")
            e:SetPos(v)
            e:SetParent(self)
            e:Spawn()
            e:Activate()
            self.Turrets[k] = e
        end
    end
 
    function ENT:SpawnDoors()
        local e = ents.Create("prop_dynamic")
        e:SetModel("models/KingPommes/starwars/patrol_transport/doors.mdl")
        e:SetPos(self:GetPos())
        e:SetAngles(self:GetAngles())
        e:SetParent(self)
        e:PhysicsInit(SOLID_VPHYSICS)
        e:Spawn()
        e:Activate()
		e:SetSkin(2)
        self.Doors = e
    end
   
    function ENT:SpawnSeats()
        self.Seats = {}
        for k,v in pairs(self.SeatPos) do
            local e = ents.Create(self.SeatClass or "prop_vehicle_prisoner_pod")
            e:SetPos(v[1] or self:GetPos())
            e:SetAngles(v[2] or self:GetAngles())
            e:SetParent(self)
            e:SetModel("models/nova/airboat_seat.mdl")
            e:SetRenderMode(RENDERMODE_TRANSALPHA)
            e:SetColor(Color(255,255,255,0))
            e:Spawn()
            e:Activate()
            e:SetUseType(USE_OFF)
            e:GetPhysicsObject():EnableMotion(false)
            e:GetPhysicsObject():EnableCollisions(false)
            e:SetCollisionGroup(COLLISION_GROUP_WEAPON)
            e._ExitPos = v[3] or Vector(0,0,0)
            e._ExitAngles = v[4] or Angle(0,180,0)
            if (k == "Gunner") then
                e:SetVehicleClass("phx_seat2")
                e:SetName("Gunner")
            else
                e:SetVehicleClass("pommes_patrol_seat")
                e:SetName("Passenger")
            end
            self.Seats[k] = e
        end
    end
   
    function ENT:Initialize()
        self.FireGroup = {"Laser1","Laser2"}
        self:SetModel(self.EntModel);
 
        self.WeaponLocations = {
            self:GetAttachment(self:LookupAttachment("turret_L")).Pos,
            self:GetAttachment(self:LookupAttachment("turret_R")).Pos,
        }
 
        self.Flashlights = {
        {Vector(174,0,15),Angle(90,0,0)},
        }
 
        self.HasFlashlight = false;
        self.FlashlightDistance = 4000;
       
        self:SetNWInt("Health",self.StartHealth)
       
        self.CanShoot = false
        self.Cooldown = 2
        self.Overheat = 0
        self.Overheated = false
        self.Bullet = CreateBulletStructure(60,"green")
        self.FireDelay = 0.05
        self.AlternateFire = true
 
        self.WeaponsTable = {}
       
        self.Gunner = nil
        self.BoostSpeed = 1500
        self.ForwardSpeed = 600
        self.UpSpeed = 500
        self.AccelSpeed = 12
        self.CanBack = true
        self.CanRoll = false
        self.CanStrafe = true
        self.HasWings = true
        self.CanEject = false       
       
        self:SetSkin(3)
        self.rocketnum = 1
        self.al = 1
       
        self.ExitModifier = {x=0,y=250,z=4}
        self.LandOffset = Vector(0,0, 1)
 
		self.PilotPosition =  Vector(0,102,87)
        self.PilotVisible = true
        self.PilotAnim = "drive_jeep"
        self.HasLookaround = true
       
        self.HasSeats = true
        self.SeatPos = {
            Gunner = {self:GetPos()+self:GetForward()*145+self:GetRight()*1+self:GetUp()*39,self:GetAngles()+Angle(0,-90,0),Vector(0,95,4)},

            {self:GetPos()+self:GetForward()*26+self:GetRight()*16+self:GetUp()*26,self:GetAngles()+Angle(0,180,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*26+self:GetRight()*-16+self:GetUp()*26,self:GetAngles()+Angle(0,0,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*-6+self:GetRight()*16+self:GetUp()*26,self:GetAngles()+Angle(0,180,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*-6+self:GetRight()*-16+self:GetUp()*26,self:GetAngles()+Angle(0,0,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*-38+self:GetRight()*16+self:GetUp()*26,self:GetAngles()+Angle(0,180,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*-38+self:GetRight()*-16+self:GetUp()*26,self:GetAngles()+Angle(0,0,0),Vector(0,95,4)},
            {self:GetPos()+self:GetForward()*58+self:GetRight()*16+self:GetUp()*26,self:GetAngles()+Angle(0,90,0),Vector(-95,0,4), Angle(0,90,0)},
            {self:GetPos()+self:GetForward()*58+self:GetRight()*-16+self:GetUp()*26,self:GetAngles()+Angle(0,90,0),Vector(95,0,4), Angle(0,90,0)},
        }
		
		self.NextUse.ToogleSirens = CurTime()
        self.NextUse.FireRockets = CurTime()
        self.NextUse.ToogleDoors = CurTime()
        self:SpawnLauncher()
        self.BaseClass.Initialize(self)

        self.Filter = {self:GetChildEntities()}

        self:SpawnDoors()
        self:SpawnTurrets()

        self.Turrets[1]:Fire( "SetParentAttachment", "turret_L")
        self.Turrets[2]:Fire( "SetParentAttachment", "turret_R")

        self.Seats["Gunner"]:Fire( "Addoutput", "limitview 0")

        self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsOpen"))
        self.Doors:SetSolid(SOLID_NONE)
        self:SetNWEntity("REP_PATROL_DOORS", self.Doors)
    end

    function ENT:Think()
        self:NextThink(CurTime())
        if(self.Inflight) then
            if IsValid(self.Pilot) then
				if(self.Pilot:KeyDown(IN_ATTACK2)) then
					self:FireLauncher()
				elseif(!IsValid(self.Gunner) and self.Pilot:KeyDown(IN_ATTACK)) then
					self:FireWeapons(self:GetPos() +  self:GetAngles():Forward()*100000)
				elseif(self.Pilot:KeyDown(IN_RELOAD)) then
					self:ToggleSiren()
				end
            end
            if (IsValid(self.Gunner)) then
                if IsValid(self.Gunner) and self.Gunner:KeyDown(IN_ATTACK) then
                    self:FireWeapons()
                end
                if IsValid(self.Gunner) and self.Gunner:KeyDown(IN_ATTACK2) then
                    if(self.FlashlightOn) then
						self.Doors:SetSkin(2)
                        self.BaseClass.RemoveFlashlight(self)
						self:EmitSound("buttons/lightswitch2.wav")
                        --self:SetNWEntity("IMPPATROL_Flashlight", NULL)
                    else
						self.Doors:SetSkin(3)
                        self.BaseClass.CreateFlashlight(self)
                        self.Flashlight[1]:SetParent(self.Doors)
						self:EmitSound("buttons/lightswitch2.wav")
                        --self:SetNWEntity("IMPPATROL_Flashlight", self.Flashlight[1])
                        self.Flashlight[1]:Fire("SetParentAttachment", "spotlight")
                    end
                end
            end
           
            if(self.Land) then
                self:ToggleDoors(true)
            end
           
            if(self.Wings) then
                self:ToggleDoors(false)
            elseif(!self.Wings) then
                self:ToggleDoors(true)
            end
 
            self:NextThink(CurTime())
        end
        self.BaseClass.Think(self)
    end
   
    function ENT:GetChildEntities()
        return self
    end
   
    function ENT:Passenger(p)
        if(self.NextUse.Use > CurTime()) then return end;
        for k,v in pairs(self.Seats) do
            if v:GetPassenger(1) == NULL and k ~= "Gunner" then
                p:EnterVehicle(v)
                return
            end
        end
    end
 
    function ENT:EnterGunner(p)
        if not self.Pilot then self:SetSkin(4) self.BaseClass.Enter(self, p) return end
        if self.Gunner == p then return end
        if(self.NextUse.Use > CurTime()) then return end
        for k,v in pairs(self.Seats) do
            if v:GetPassenger(1) == NULL and k == "Gunner" then
                p:EnterVehicle(v)
                p:CrosshairEnable()
                return       
            end
        end
    end
   
    function ENT:Use(p)
        if(not self.Inflight) then
            if !p:KeyDown(IN_WALK) then
                self:EnterGunner(p)
            elseif p ~= self.Pilot and p ~= self.Gunner then
                self:Passenger(p)
            end
        else
            if(!p:KeyDown(IN_WALK)) then
                self:EnterGunner(p)
            elseif p ~= self.Pilot and p ~= self.Gunner then
                self:Passenger(p)
            end
        end
    end
   
    function ENT:Exit(kill)
        if not IsValid(self) then return end
        self.BaseClass.Exit(self,kill)
       
        self:ToggleDoors(true)
        self:SetSkin(3)
		self:StopSound("siren")
        if self.Gunner then
            local p = self.Gunner
            self:GunnerLeftVehicle(self.Gunner, self.Gunner:GetVehicle())
            p:ExitVehicle()
            self:SetSkin(4)
            timer.Simple(0, function()
                self.BaseClass.Enter(self, p)
            end)
        end
        self.Pilot = nil
    end
   
    function ENT:Bang()
        self.BaseClass.Bang(self)
        self:GibBreakClient(self:GetVelocity())
		self:StopSound("siren")
        self:Remove()
    end
   
    function ENT:ToggleDoors(bol)
        if(self.NextUse.ToogleDoors < CurTime()) then
       
            if (bol and self.Doors:GetSequence() ~= self.Doors:LookupSequence("DoorsOpen")) then
                self:ResetSequence(self:LookupSequence("WingClose"))
                self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsOpen"))
                self.Doors:SetSolid(SOLID_NONE)
                self.NextUse.ToogleDoors = CurTime()+2
               
            elseif (!bol and self.Doors:GetSequence() ~= self.Doors:LookupSequence("DoorsClose")) then
                self:ResetSequence(self:LookupSequence("WingOpen"))
                self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsClose"))
                self.Doors:SetSolid(SOLID_VPHYSICS)
                self.NextUse.ToogleDoors = CurTime()+2
            end
        end
    end
   
	sound.Add( {
		name = "siren",
		channel = CHAN_STATIC,
		volume = 1.0,
		level = 80,
		pitch = 100,
		sound = "KingPommes/starwars/patrol/siren.wav"
	} )
   
    function ENT:ToggleSiren()
        if self.NextUse.ToogleSirens < CurTime()  then
            if self:GetSkin() == 3 then
                self:SetSkin(5)
				self:EmitSound("siren")
            elseif self:GetSkin() == 5 then
                self:SetSkin(3)
				self:StopSound("siren")
            end
        self.NextUse.ToogleSirens = CurTime()+1
        end
    end
   
    function ENT:FireLauncher()
        if(self.NextUse.FireRockets < CurTime()) then
            if (self.rocketnum % 2 == 1) then
                self.Launcher:SetPos(self:GetPos() + self:GetForward()*250 + self:GetUp()*50 + self:GetRight()*32)
                self.Launcher:Fire("FireOnce")
                self.rocketnum = self.rocketnum + 1
            elseif (self.rocketnum %2 == 0) then
                self.Launcher:SetPos(self:GetPos() + self:GetForward()*250 + self:GetUp()*50 + self:GetRight()*-32)
                self.Launcher:Fire("FireOnce")
                self.rocketnum = self.rocketnum + 1
            end
            if (self.rocketnum == 6) then
                self.rocketnum = 0
                self.NextUse.FireRockets = CurTime()+15
                self:SetNWInt("FireBlast",self.NextUse.FireRockets)
            end
        end
    end
 
    function ENT:FireWeapons()
        if(self.NextUse.Fire < CurTime()) then
        local aim
        if IsValid(self.Gunner) then
            --aim = self.Gunner:EyeAngles()
            --aim = self:WorldToLocalAngles(self.Gunner:GetAimVector():Angle())
            aim = self.Gunner:GetAimVector():Angle()
        end
            for k,v in pairs(self.Weapons) do
                if(!IsValid(v)) then return end;
                local tr
                if IsValid(self.Gunner) then
                    tr = util.TraceLine({
                        start = v:GetPos(),
                        --endpos = self.Gunner:GetPos() + Angle(math.Clamp(aim.x,-15,90),math.Clamp(aim.y,-68,68),0):Forward() * 100000,
                        endpos = self.Gunner:GetPos() + Angle(aim.x,aim.y):Forward() * 100000,
                        filter = {self,self.Gunner},
                    })
                elseif IsValid(self.Pilot) then
                    tr = util.TraceLine({
                        start = v:GetPos(),
                        endpos = self:GetPos()+self:GetForward()*10000,
                        filter = {self},
                    })                    
                end
                local angPos = (tr.HitPos - v:GetPos())
               
                if(self.ShouldLock) then
                    local e = self:FindTarget();
                    if(IsValid(e)) then
                        local tr = util.TraceLine( {
                            start = v:GetPos(),
                            endpos = e:GetPos(),
                            filter = {self, v},
                        } )
                        if(!tr.HitWorld) then
                            angPos = (e:GetPos() + e:GetUp()*(e:GetModelRadius()/3) + (self.LockOnOverride or Vector(0,0,0))) - v:GetPos();
                        end
                    end
                end
               
                self.Bullet.Attacker = self.Gunner or self.Pilot or self;
                self.Bullet.Src     = v:GetPos();
                local spread = self.Accel.FWD/1000;
                self.Bullet.Spread = Vector(spread,spread,spread);
                self.Bullet.IgnoreEntity = self, v
   
                self.Bullet.Dir = angPos
               
                if(self.AlternateFire) then
                    if (self.al == 1 and (v == self.Weapons[1])) then
                        v:FireBullets(self.Bullet)
                    elseif (self.al == 2 and (v == self.Weapons[2])) then
                        v:FireBullets(self.Bullet)
                    end
                else
                    v:FireBullets(self.Bullet)
                end
            end
            self.al = self.al + 1
            if(self.al == 3) then
                self.al = 1
            end
            self:EmitSound(self.FireSound,100,math.random(90,110))
            self.NextUse.Fire = CurTime() + (self.FireDelay)
        end
    end
 
    hook.Add("CanPlayerEnterVehicle", "PatrolTransportRep.PreventEnter", function(p,v)
        if(IsValid(p) and IsValid(v)) then
            local e = v:GetParent();
            if e.IsSWVehicle and e:GetClass() == "pommes_patrol_transport_rep" then
                if p == e.Gunner or p == e.Pilot then return false end
                return
            end
        end
    end)
 
    hook.Add("PlayerEnteredVehicle","PatrolTransportRep.GunnerEnterVehicle", function(p,v)
        if(IsValid(p) and IsValid(v)) then
            local e = v:GetParent();
            if e.IsSWVehicle and e:GetClass() == "pommes_patrol_transport_rep" and v:GetName() == "Gunner" then
                e.Gunner = p
                e:SetNWEntity("REP_PATROL_GUNNER",p)
                p:SetNWEntity("REP_PATROL", e)
                p:SetNWBool("GunnerREP_PATROL", true)
                p:SetNWVector("Weapon1REP_PATROL", e.WeaponLocations[1])
                p:SetNWVector("Weapon2REP_PATROL", e.WeaponLocations[2])
            end
        end
    end)
	
	function ENT:GunnerLeftVehicle(p, v)
        if(IsValid(p) and IsValid(v)) then
            local e = v:GetParent();
            if e.IsSWVehicle and e:GetClass() == "pommes_patrol_transport_rep" then
                e.Gunner = nil
                e:SetNWEntity("REP_PATROL_GUNNER", NULL)
                p:SetNWEntity("REP_PATROL", nil)
                p:SetNWBool("GunnerREP_PATROL", false)
                if v then
                    local pos = v:LocalToWorld(v._ExitPos)
                    p:SetPos(pos);
                end
            end
        end
    end

    hook.Add("PlayerLeaveVehicle", "PatrolTransportRep.GunnerLeaveVehicle", function(p, v)
        if(IsValid(p) and IsValid(v)) then
            local e = v:GetParent()
            if e.IsSWVehicle and e:GetClass() == "pommes_patrol_transport_rep" and v:GetName() == "Gunner" then
                e.Gunner = nil
                e:SetNWEntity("REP_PATROL_GUNNER", NULL)
                p:SetNWEntity("REP_PATROL", nil)
                p:SetNWBool("GunnerREP_PATROL", false)
                local pos = v:LocalToWorld(v._ExitPos)
                p:SetPos(pos)
                if(e.FlashlightOn) then
				    e.Doors:SetSkin(2)
                    e.BaseClass.RemoveFlashlight(e)
					--e:EmitSound("items\flashlight1.wav")
                    --e:SetNWEntity("IMPPATROL_Flashlight", e)
                --else
				--	print("test")
				--	e.Doors:SetSkin(1)
                --    e.BaseClass.CreateFlashlight(e)
                --    e.Flashlight[1]:SetParent(e.Doors)
                --    e:SetNWEntity("IMPPATROL_Flashlight", e.Flashlight[1])
                --    e.Flashlight[1]:Fire("SetParentAttachment", "spotlight")
                end
            elseif e.IsSWVehicle and e:GetClass() == "pommes_patrol_transport_rep" and v:GetName() == "Passenger" then
                local pos = v:LocalToWorld(v._ExitPos)
                p:SetPos(pos)
                p:SetEyeAngles(v._ExitAngles)
            end
        end
    end)
       
end
 
 
 
if CLIENT then
 
    function ENT:Draw() self:DrawModel() end
 
    ENT.Sounds={
        Engine=Sound("vehicles/laat/laat_fly2.wav"),
    }
    ENT.CanFPV = true
	
	ENT.SpritePos = {}
 
    local Health = 0
    function ENT:Think()
        self.BaseClass.Think(self)

		--self:SetRenderBoundsWS(Vector(-9999999, -9999999, -9999999),Vector(9999999, 9999999, 9999999))
		
		local p = LocalPlayer()
        local IsDriver = p:GetNWEntity(self.Vehicle) == self.Entity
        local IsFlying = p:GetNWBool("Flying"..self.Vehicle)
		
		if(IsFlying and IsDriver) then
            Health = self:GetNWInt("Health")
        end     
 
        self.Gunner = self:GetNWEntity("REP_PATROL_GUNNER")
        self.Doors = self:GetNWEntity("REP_PATROL_DOORS")
		
        -- Dafuck, I need to do this because the Guns are always looking in one Direction when you are using global angles and are not the Localplayer
        -- If you use local angles its right for others but for the Localplayer its broken
		
        if IsValid(self.Gunner) and self.Gunner == LocalPlayer() then
            local aim = self.Gunner:EyeAngles()
            local x = math.Clamp(aim.x,-15,90)
            local y = math.Clamp(aim.y,22,158)
 
			self:ManipulateBoneAngles(self:LookupBone("turret_L"), Angle(0,-y + 90,x))
			self:ManipulateBoneAngles(self:LookupBone("turret_R"), Angle(0,-y + 90,x))
            if not IsValid(self.Doors) then return end
            self.Doors:ManipulateBoneAngles(self.Doors:LookupBone("spotlight"), Angle(0,-aim.x + 90,-aim.y + 90))
           
        elseif IsValid(self.Gunner) and self.Gunner ~= LocalPlayer() then
            local aim = self:WorldToLocalAngles(self.Gunner:EyeAngles())
			local x = math.Clamp(aim.x,-15,90)
            local y = math.Clamp(aim.y,-68,68)
 
            self:ManipulateBoneAngles(self:LookupBone("turret_L"), Angle(0,-y,x))
            self:ManipulateBoneAngles(self:LookupBone("turret_R"), Angle(0,-y,x))
 
            if not IsValid(self.Doors) then return end
            self.Doors:ManipulateBoneAngles(self.Doors:LookupBone("spotlight"), Angle(0,-aim.x + 90,-aim.y ))
           
        else
            self:ManipulateBoneAngles(self:LookupBone("turret_L"), Angle(0,0,0))
            self:ManipulateBoneAngles(self:LookupBone("turret_R"), Angle(0,0,0))
            if not IsValid(self.Doors) then return end
            self.Doors:ManipulateBoneAngles(self.Doors:LookupBone("spotlight"), Angle(0,0,0))
        end
    end
	
	ENT.ViewDistance = 700
	ENT.ViewHeight = 300
	ENT.FPVPos = Vector(115,0,121)
	ENT.HasCustomCalcView = true
	hook.Add("CalcVehicleView", "RepPatrol.CalcVehicleView", function(veh, p, view)
		local e = LocalPlayer():GetVehicle()
		local Piloting = p:GetViewEntity() != p and p:GetViewEntity().IsSWVehicle;
		if IsValid(e) and e:GetParent().IsSWVehicle and e:GetParent():GetClass() == "pommes_patrol_transport_rep" then
			if p:GetNWBool("GunnerREP_PATROL") and e:GetThirdPersonMode() then
                local view = {}
				view.origin = e:LocalToWorld(Vector(0,5,-30))
				view.angles = angles
				view.fov = fov
				view.drawviewer = true
				return view
			elseif not e:GetThirdPersonMode() and not p:GetNWBool("GunnerREP_PATROL") then
                --Player View Height
				view.origin = view.origin + Vector(0,0, 40)
			elseif not p:GetNWBool("GunnerREP_PATROL") then
                --Third Person View Height
                view.origin = view.origin + Vector(0,0, 40)
            end
		end
	end)

	hook.Add("CalcView", "RepPatrol.CalcView", function(p, origin, ang)
		local view = {}
		local e = LocalPlayer():GetVehicle()
		local Piloting = p:GetViewEntity() != p and p:GetViewEntity().IsSWVehicle;
		if Piloting and p:GetViewEntity():GetClass() == "pommes_patrol_transport_rep" then
			self = p:GetViewEntity();
			local pos = self:LocalToWorld(self.FPVPos or Vector(0,0,0));
			View = SWVehicleView(self,self.ViewDistance or 800,self.ViewHeight or 250,pos,self:GetNWBool("HasLookaround"))
			return View;
		end
	end)
	
	
	--TESTING RENDERBOUNDS
	
	--hook.Add("HUDPaint", "TestingAoroundMF", function()
	--	for k, v in pairs(ents.GetAll()) do
	--		if v:GetClass() == "pommes_patrol_transport" then
	--			local vec1, vec2 = v:GetRenderBounds()
	--			cam.Start3D()
	--				render.DrawWireframeBox(v:GetPos(), Angle(), vec1, vec2, Color(0, 0, 255, 255))
	--			cam.End3D()
	--		end
	--	end
	--end)
	
	

	function REP_PATROLOfDoomReticle()
		local p = LocalPlayer()
		local Flying = p:GetNWBool("FlyingREP_PATROL")
		local self = p:GetNWEntity("REP_PATROL")
		local Gunner = p:GetNWBool("GunnerREP_PATROL")
		local Weapon1 = p:GetNWVector("Weapon1REP_PATROL")
		local Weapon2 = p:GetNWVector("Weapon2REP_PATROL")

		if Flying and IsValid(self) then
			local x = ScrW()/4*0.1
			local y = ScrH()/4*2.5
			if(self:GetFPV()) then         
			end
			SW_HUD_DrawHull(self.StartHealth)
			SW_WeaponReticles(self)
			--SW_HUD_DrawOverheating(self)
			local pos = self:GetPos()+self:GetForward()*100+self:GetUp()*-45+self:GetRight()*0
			local x,y = SW_XYIn3D(pos)
			SW_HUD_Compass(self,x,y)
			SW_HUD_DrawSpeedometer()
			SW_HUD_WingsIndicator("patrol",x,y)
			SW_BlastIcon(self,15)
		end
	end
	hook.Add("HUDPaint", "REP_PATROLReticle", REP_PATROLOfDoomReticle)
end
--PATH gamemodes/starwarsrp/entities/entities/lab_base/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
    self:initVars()
end

local color_red = Color(140, 0, 0, 100)
local color_white = color_white

function ENT:DrawTranslucent()
    self:DrawModel()

    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    local owner = self:Getowning_ent()
    owner = (IsValid(owner) and owner:Nick()) or DarkRP.getPhrase("unknown")

    surface.SetFont("HUDNumber5")
    local text = self.labPhrase
    local text2 = DarkRP.getPhrase("priceTag", DarkRP.formatMoney(self:Getprice()), "")
    local TextWidth = surface.GetTextSize(text)
    local TextWidth2 = surface.GetTextSize(text2)

    Ang:RotateAroundAxis(Ang:Forward(), 90)
    local TextAng = Ang

    TextAng:RotateAroundAxis(TextAng:Right(), CurTime() * -180)

    cam.Start3D2D(Pos + Ang:Right() * self.camMul, TextAng, 0.2)
        draw.WordBox(2, -TextWidth * 0.5 + 5, -30, text, "HUDNumber5", color_red, color_white)
        draw.WordBox(2, -TextWidth2 * 0.5 + 5, 18, text2, "HUDNumber5", color_red, color_white)
    cam.End3D2D()
end

--PATH gamemodes/starwarsrp/entities/entities/letter/cl_init.lua:
include("shared.lua")

local frame
local SignButton

function ENT:Draw()
    self:DrawModel()
end

local function KillLetter(msg)
    hook.Remove("HUDPaint", "ShowLetter")
    frame:Remove()
end
usermessage.Hook("KillLetter", KillLetter)

local function ShowLetter(msg)
    if frame then
        frame:Remove()
    end

    local LetterMsg = ""
    local Letter = msg:ReadEntity()
    local LetterType = msg:ReadShort()
    local LetterPos = msg:ReadVector()
    local sectionCount = msg:ReadShort()
    local LetterY = ScrH() / 2 - 300
    local LetterAlpha = 255

    Letter:CallOnRemove("Kill letter HUD on remove", KillLetter)

    for k = 1, sectionCount, 1 do
        LetterMsg = LetterMsg .. msg:ReadString()
    end

    frame = vgui.Create("DFrame")
    frame:SetTitle("")
    frame:ShowCloseButton(false)

    SignButton = vgui.Create("DButton", frame)
    SignButton:SetText(DarkRP.getPhrase("sign_this_letter"))
    frame:SetPos(ScrW() - 256, ScrH() - 256)
    SignButton:SetSize(256, 256)
    frame:SetSize(256, 256)
    SignButton:SetSkin(GAMEMODE.Config.DarkRPSkin)
    frame:SizeToContents()
    frame:MakePopup()
    frame:SetKeyboardInputEnabled(false)

    function SignButton:DoClick()
        RunConsoleCommand("_DarkRP_SignLetter", Letter:EntIndex())
        SignButton:SetDisabled(true)
    end
    SignButton:SetDisabled(IsValid(Letter:Getsigned()))

    hook.Add("HUDPaint", "ShowLetter", function()
        if not Letter.dt then KillLetter() return end
        if LetterAlpha < 255 then
            LetterAlpha = math.Clamp(LetterAlpha + 400 * FrameTime(), 0, 255)
        end

        local font = (LetterType == 1 and "AckBarWriting") or "Default"

        draw.RoundedBox(2, ScrW() * .2, LetterY, ScrW() * .8 - (ScrW() * .2), ScrH(), Color(255, 255, 255, math.Clamp(LetterAlpha, 0, 200)))
        draw.DrawNonParsedText(LetterMsg .. "\n\n\n" .. DarkRP.getPhrase("signed", IsValid(Letter:Getsigned()) and Letter:Getsigned():Nick() or DarkRP.getPhrase("no_one")), font, ScrW() * .25 + 20, LetterY + 80, Color(0, 0, 0, LetterAlpha), 0)

        if LocalPlayer():GetPos():DistToSqr(LetterPos) > 10000 then
            LetterY = Lerp(0.1, LetterY, ScrH())
            LetterAlpha = Lerp(0.1, LetterAlpha, 0)
            if frame and frame.Close then frame:Close() end
            if math.Round(LetterAlpha) <= 10 then
                KillLetter()
            end
        end
    end)
end
usermessage.Hook("ShowLetter", ShowLetter)

--PATH addons/[miecze] moce i hilty/lua/entities/lscs_holocron_base.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_pickupable.lua:
return gluapack()()
--PATH lua/entities/lvs_base/cl_boneposeparemeter.lua:
return gluapack()()
--PATH lua/entities/lvs_base_gunner/shared.lua:
ENT.Type            = "anim"

ENT.PrintName = "LBaseGunner"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT.LVS_GUNNER = true
ENT.VectorNull = Vector(0,0,0)

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Driver" )
	self:NetworkVar( "Entity",1, "DriverSeat" )

	self:NetworkVar( "Int", 0, "PodIndex")
	self:NetworkVar( "Int", 1, "NWAmmo")
	self:NetworkVar( "Int", 2, "SelectedWeapon" )

	self:NetworkVar( "Float", 0, "NWHeat" )

	self:NetworkVar( "Bool", 0, "NWOverheated" )

	self:NetworkVar( "Vector", 0, "NWAimVector" )

	if SERVER then
		self:NetworkVarNotify( "SelectedWeapon", self.OnWeaponChanged )
	end
end

function ENT:UnlockAimVector()
	self._AimVectorUnlocked = true
end

function ENT:LockAimVector()
	self._AimVectorUnlocked = nil
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAI()
	if IsValid( self:GetDriver() ) then return false end

	local veh = self:GetVehicle()

	if not IsValid( veh ) then return false end

	return veh:GetAIGunners()
end

function ENT:GetAITEAM()
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return 0 end

	return Base:GetAITEAM()
end

function ENT:GetVehicle()
	local Pod = self:GetParent()

	if not IsValid( Pod ) then return NULL end

	return Pod:GetParent()
end

function ENT:HasWeapon( ID )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return false end

	return istable( Base.WEAPONS[ self:GetPodIndex() ][ ID ] )
end

function ENT:AIHasWeapon( ID )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return false end

	local weapon = Base.WEAPONS[ self:GetPodIndex() ][ ID ]

	if not istable( weapon ) then return false end

	return weapon.UseableByAI
end

function ENT:GetActiveWeapon()
	local SelectedID = self:GetSelectedWeapon()

	local Base = self:GetVehicle()

	if not IsValid( Base ) then return {}, SelectedID end

	local CurWeapon = Base.WEAPONS[ self:GetPodIndex() ][ SelectedID ]

	return CurWeapon, SelectedID
end

function ENT:GetMaxAmmo()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return -1 end

	return CurWeapon.Ammo or -1
end

function ENT:GetClip()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return 0 end

	local HeatIncrement = (CurWeapon.HeatRateUp or 0.2) * math.max(CurWeapon.Delay or 0, FrameTime())

	local Ammo = self:GetNWAmmo()

	if self:GetMaxAmmo() <= 0 and CurWeapon.Clip then
		Ammo = CurWeapon.Clip
	end

	return math.min( math.ceil( math.Round( (1 - self:GetNWHeat()) / HeatIncrement, 1 ) ), Ammo )
end

function ENT:GetCrosshairFilterEnts()
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return {} end

	return Base:GetCrosshairFilterEnts()
end

function ENT:Sign( n )
	if n > 0 then return 1 end

	if n < 0 then return -1 end

	return 0
end

function ENT:VectorSubtractNormal( Normal, Velocity )
	local VelForward = Velocity:GetNormalized()

	local Ax = math.acos( math.Clamp( Normal:Dot( VelForward ) ,-1,1) )

	local Fx = math.cos( Ax ) * Velocity:Length()

	local NewVelocity = Velocity - Normal * math.abs( Fx )

	return NewVelocity
end

function ENT:VectorSplitNormal( Normal, Velocity )
	return math.cos( math.acos( math.Clamp( Normal:Dot( Velocity:GetNormalized() ) ,-1,1) ) ) * Velocity:Length()
end

function ENT:AngleBetweenNormal( Dir1, Dir2 )
	return math.deg( math.acos( math.Clamp( Dir1:Dot( Dir2 ) ,-1,1) ) )
end

function ENT:GetVehicleType()
	return "LBaseGunner"
end
--PATH lua/entities/lvs_base_repulsorlift/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "[LVS] Base Gunship"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.ThrustVtol = 30
ENT.ThrustRateVtol = 2

ENT.MaxPitch = 60

ENT.DisableBallistics = true

function ENT:CalcVtolThrottle( ply, cmd )
	local Delta = FrameTime()

	local ThrottleZero = self:GetThrottle() <= 0

	local VtolX = ThrottleZero and (ply:lvsKeyDown( "-VTOL_X_SF" ) and -1 or 0) or 0
	local VtolY = ((ply:lvsKeyDown( "+VTOL_Y_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Y_SF" ) and 1 or 0))

	if ply:lvsMouseAim() then
		VtolY = math.Clamp( VtolY + ((ply:lvsKeyDown( "-ROLL_SF" ) and 1 or 0) - (ply:lvsKeyDown( "+ROLL_SF" ) and 1 or 0)), -1 , 1)
	end

	VtolY = VtolY * math.max( 1 - self:GetThrottle() ^ 2, 0 )
	local VtolZ = ((ply:lvsKeyDown( "+VTOL_Z_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Z_SF" ) and 1 or 0))

	local DesiredVtol = Vector(VtolX,VtolY,VtolZ)
	local NewVtolMove = self:GetNWVtolMove() + (DesiredVtol - self:GetNWVtolMove()) * self.ThrustRateVtol * Delta

	if not ThrottleZero or self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x > 100 then
		NewVtolMove.x = 0
	end

	self:SetVtolMove( NewVtolMove )
end

function ENT:GetVtolMove()
	if self:GetEngineActive() and not self:GetAI() then
		return self:GetNWVtolMove() * self.ThrustVtol
	else
		return Vector(0,0,0)
	end
end

function ENT:PlayerDirectInput( ply, cmd )
	local Pod = self:GetDriverSeat()

	local Delta = FrameTime()

	local KeyLeft = ply:lvsKeyDown( "-ROLL_SF" )
	local KeyRight = ply:lvsKeyDown( "+ROLL_SF" )
	local KeyPitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local KeyPitchDown = ply:lvsKeyDown( "-PITCH_SF" )

	local MouseX = cmd:GetMouseX()
	local MouseY = cmd:GetMouseY()

	if ply:lvsKeyDown( "FREELOOK" ) and not Pod:GetThirdPersonMode() then
		MouseX = 0
		MouseY = 0
	else
		ply:SetEyeAngles( Angle(0,90,0) )
	end

	local SensX, SensY, ReturnDelta = ply:lvsMouseSensitivity()

	if KeyPitchDown then MouseY = (10 / SensY) * ReturnDelta end
	if KeyPitchUp then MouseY = -(10 / SensY) * ReturnDelta end
	if KeyLeft then MouseX = -(10 / SensX) * ReturnDelta end
	if KeyRight then MouseX = (10 / SensX) * ReturnDelta end

	local Input = Vector( MouseX * 0.4 * SensX, MouseY * SensY, 0 )

	local Cur = self:GetSteer()

	local Rate = Delta * 3 * ReturnDelta

	local New = Vector(Cur.x, Cur.y, 0) - Vector( math.Clamp(Cur.x * Delta * 5 * ReturnDelta,-Rate,Rate), math.Clamp(Cur.y * Delta * 5 * ReturnDelta,-Rate,Rate), 0)

	local Target = New + Input * Delta * 0.8

	local Fx = math.Clamp( Target.x, -1, 1 )
	local Fy = math.Clamp( Target.y, -1, 1 )

	local TargetFz = (KeyLeft and 1 or 0) - (KeyRight and 1 or 0)
	local Fz = Cur.z + math.Clamp(TargetFz - Cur.z,-Rate * 3,Rate * 3)

	local F = Cur + (Vector( Fx, Fy, Fz ) - Cur) * math.min(Delta * 100,1)

	self:SetSteer( F )
end

function ENT:StartCommand( ply, cmd )
	if self:GetDriver() ~= ply then return end

	if SERVER then
		local KeyJump = ply:lvsKeyDown( "VSPEC" )

		if self._lvsOldKeyJump ~= KeyJump then
			self._lvsOldKeyJump = KeyJump

			if KeyJump then
				self:ToggleVehicleSpecific()
			end
		end
	end

	if ply:lvsMouseAim() then
		if SERVER then
			self:PlayerMouseAim( ply, cmd )
		end
	else
		self:PlayerDirectInput( ply, cmd )
	end

	self:CalcThrottle( ply, cmd )
	self:CalcVtolThrottle( ply, cmd )
end

function ENT:GetVehicleType()
	return "repulsorlift"
end
--PATH lua/entities/lvs_base_starfighter/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Base Starfighter"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.ThrottleRateUp = 0.6
ENT.ThrottleRateDown = 0.6

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.DisableBallistics = true

function ENT:SetupDataTables()
	self:AddDT( "Vector", "Steer" )
	self:AddDT( "Vector", "AIAimVector" )
	self:AddDT( "Vector", "NWVtolMove" )
	self:AddDT( "Float", "NWThrottle" )
	self:AddDT( "Float", "MaxThrottle" )

	if SERVER then
		self:SetMaxThrottle( 1 )
	end

	self:CreateBaseDT()
end

function ENT:PlayerDirectInput( ply, cmd )
	local Pod = self:GetDriverSeat()

	local Delta = FrameTime()

	local KeyLeft = ply:lvsKeyDown( "-ROLL_SF" )
	local KeyRight = ply:lvsKeyDown( "+ROLL_SF" )
	local KeyPitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local KeyPitchDown = ply:lvsKeyDown( "-PITCH_SF" )
	local KeyRollRight = ply:lvsKeyDown( "+YAW_SF" )
	local KeyRollLeft = ply:lvsKeyDown( "-YAW_SF" )

	local MouseX = cmd:GetMouseX()
	local MouseY = cmd:GetMouseY()

	if ply:lvsKeyDown( "FREELOOK" ) and not Pod:GetThirdPersonMode() then
		MouseX = 0
		MouseY = 0
	else
		ply:SetEyeAngles( Angle(0,90,0) )
	end

	local SensX, SensY, ReturnDelta = ply:lvsMouseSensitivity()

	if KeyPitchDown then MouseY = (10 / SensY) * ReturnDelta end
	if KeyPitchUp then MouseY = -(10 / SensY) * ReturnDelta end
	if KeyRollRight or KeyRollLeft then
		local NewX = (KeyRollRight and 10 or 0) - (KeyRollLeft and 10 or 0)

		MouseX = (NewX / SensX) * ReturnDelta
	end

	local Input = Vector( MouseX * 0.4 * SensX, MouseY * SensY, 0 )

	local Cur = self:GetSteer()

	local Rate = Delta * 3 * ReturnDelta

	local New = Vector(Cur.x, Cur.y, 0) - Vector( math.Clamp(Cur.x * Delta * 5 * ReturnDelta,-Rate,Rate), math.Clamp(Cur.y * Delta * 5 * ReturnDelta,-Rate,Rate), 0)

	local Target = New + Input * Delta * 0.8

	local Fx = math.Clamp( Target.x, -1, 1 )
	local Fy = math.Clamp( Target.y, -1, 1 )

	local TargetFz = (KeyLeft and 1 or 0) - (KeyRight and 1 or 0)
	local Fz = Cur.z + math.Clamp(TargetFz - Cur.z,-Rate * 3,Rate * 3)

	local F = Cur + (Vector( Fx, Fy, Fz ) - Cur) * math.min(Delta * 100,1)

	self:SetSteer( F )
end

function ENT:CalcThrottle( ply, cmd )
	if CLIENT then return end

	local Delta = FrameTime()

	local ThrottleUp =  ply:lvsKeyDown( "+THRUST_SF" ) and self.ThrottleRateUp or 0
	local ThrottleDown = ply:lvsKeyDown( "-THRUST_SF" ) and -self.ThrottleRateDown or 0

	local Throttle = (ThrottleUp + ThrottleDown) * Delta

	self:SetThrottle( self:GetThrottle() + Throttle )
end

function ENT:CalcVtolThrottle( ply, cmd )
	local Delta = FrameTime()

	local ThrottleZero = self:GetThrottle() <= 0

	local VtolX = ThrottleZero and (ply:lvsKeyDown( "-VTOL_X_SF" ) and -1 or 0) or 0
	local VtolY = ((ply:lvsKeyDown( "+VTOL_Y_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Y_SF" ) and 1 or 0))
	local VtolZ = ((ply:lvsKeyDown( "+VTOL_Z_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Z_SF" ) and 1 or 0))

	local DesiredVtol = Vector(VtolX,VtolY,VtolZ)
	local NewVtolMove = self:GetNWVtolMove() + (DesiredVtol - self:GetNWVtolMove()) * self.ThrustRateVtol * Delta

	if not ThrottleZero or self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x > 100 then
		NewVtolMove.x = 0
	end

	self:SetVtolMove( NewVtolMove )
end

function ENT:SetVtolMove( NewMove )
	if self:GetEngineActive() then
		self:SetNWVtolMove( NewMove )
	else
		self:SetNWVtolMove( Vector(0,0,0) )
	end
end

function ENT:SetThrottle( NewThrottle )
	if self:GetEngineActive() then
		self:SetNWThrottle( math.Clamp(NewThrottle,0,self:GetMaxThrottle()) )
	else
		self:SetNWThrottle( 0 )
	end
end

function ENT:GetThrottle()
	if self:GetEngineActive() then
		return self:GetNWThrottle()
	else
		return 0
	end
end

function ENT:GetVtolMove()
	if self:GetEngineActive() and not self:GetAI() then
		return self:GetNWVtolMove() * self.ThrustVtol * (1 - math.min( self:GetThrottle(), 1 ))
	else
		return Vector(0,0,0)
	end
end

function ENT:StartCommand( ply, cmd )
	if self:GetDriver() ~= ply then return end

	if SERVER then
		local KeyJump = ply:lvsKeyDown( "VSPEC" )

		if self._lvsOldKeyJump ~= KeyJump then
			self._lvsOldKeyJump = KeyJump

			if KeyJump then
				self:ToggleVehicleSpecific()
			end
		end
	end

	if not ply:lvsMouseAim() then
		self:PlayerDirectInput( ply, cmd )
	end

	self:CalcThrottle( ply, cmd )
	self:CalcVtolThrottle( ply, cmd )
end

function ENT:GetThrustStrenght()
	local ForwardVelocity = self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x

	return (self.MaxVelocity * self:GetThrottle() - ForwardVelocity) / self.MaxVelocity
end

function ENT:GetVehicleType()
	return "starfighter"
end

--PATH lua/entities/lvs_base_starfighter/cl_camera.lua:
return gluapack()()
--PATH lua/entities/lvs_base_starfighter/cl_camera.lua:

ENT._lvsSmoothFreeLook = 0

function ENT:CalcViewDirectInput( ply, pos, angles, fov, pod )
	local ViewPosL = pod:WorldToLocal( pos )

	local view = {}
	view.fov = fov
	view.drawviewer = true
	view.angles = self:GetAngles()

	local FreeLook = ply:lvsKeyDown( "FREELOOK" )
	local Zoom = ply:lvsKeyDown( "ZOOM" )

	if not pod:GetThirdPersonMode() then

		if FreeLook then
			view.angles = pod:LocalToWorldAngles( ply:EyeAngles() )
		end

		local velL = self:WorldToLocal( self:GetPos() + self:GetVelocity() )

		local Dividor = math.abs( velL.x )
		local SideForce = math.Clamp( velL.y / Dividor, -1, 1)
		local UpForce = math.Clamp( velL.z / Dividor, -1, 1)

		local ViewPunch = Vector(0,math.Clamp(SideForce * 10,-1,1),math.Clamp(UpForce * 10,-1,1))
		if Zoom then
			ViewPunch = Vector(0,0,0)
		end

		pod._lerpPosOffset = pod._lerpPosOffset and pod._lerpPosOffset + (ViewPunch - pod._lerpPosOffset) * RealFrameTime() * 5 or Vector(0,0,0)
		pod._lerpPos = pos

		view.origin = pos + pod:GetForward() *  -pod._lerpPosOffset.y * 0.5 + pod:GetUp() *  pod._lerpPosOffset.z * 0.5
		view.angles.p = view.angles.p - pod._lerpPosOffset.z * 0.1
		view.angles.y = view.angles.y + pod._lerpPosOffset.y * 0.1
		view.drawviewer = false

		return view
	end

	pod._lerpPos = pod._lerpPos or self:GetPos()

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	if FreeLook then
		local velL = self:WorldToLocal( self:GetPos() + self:GetVelocity() )

		local SideForce = math.Clamp(velL.y / 10,-250,250)
		local UpForce = math.Clamp(velL.z / 10,-250,250)

		pod._lerpPosL = pod._lerpPosL and (pod._lerpPosL + (Vector(radius, SideForce,150 + radius * 0.1 + radius * pod:GetCameraHeight() + UpForce) - pod._lerpPosL) * RealFrameTime() * 12) or Vector(0,0,0)
		pod._lerpPos = self:LocalToWorld( pod._lerpPosL )

		view.origin = pod._lerpPos
		view.angles = self:LocalToWorldAngles( Angle(0,180,0) )
	else
		local TargetPos = self:LocalToWorld( Vector(500,0,150 + radius * 0.1 + radius * pod:GetCameraHeight()) )

		local Sub = TargetPos - pod._lerpPos
		local Dir = Sub:GetNormalized()
		local Dist = Sub:Length()

		local DesiredPos = TargetPos - self:GetForward() * (300 + radius) - Dir * 100

		pod._lerpPos = pod._lerpPos + (DesiredPos - pod._lerpPos) * RealFrameTime() * (Zoom and 30 or 12)
		pod._lerpPosL = self:WorldToLocal( pod._lerpPos )

		local vel = self:GetVelocity()

		view.origin = pod._lerpPos
		view.angles = self:GetAngles()
	end

	view.origin = view.origin + ViewPosL

	return view
end

function ENT:CalcViewMouseAim( ply, pos, angles, fov, pod )
	local cvarFocus = math.Clamp( LVS.cvarCamFocus:GetFloat() , -1, 1 )

	self._lvsSmoothFreeLook = self._lvsSmoothFreeLook + ((ply:lvsKeyDown( "FREELOOK" ) and 0 or 1) - self._lvsSmoothFreeLook) * RealFrameTime() * 10

	local view = {}
	view.origin = pos
	view.fov = fov
	view.drawviewer = true
	view.angles = (self:GetForward() * (1 + cvarFocus) * self._lvsSmoothFreeLook * 0.8 + ply:EyeAngles():Forward() * math.max(1 - cvarFocus, 1 - self._lvsSmoothFreeLook)):Angle()

	if cvarFocus >= 1 then
		view.angles = LerpAngle( self._lvsSmoothFreeLook, ply:EyeAngles(), self:GetAngles() )
	else
		view.angles.r = 0
	end

	if not pod:GetThirdPersonMode() then

		view.drawviewer = false

		return view
	end

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin - view.angles:Forward() * radius  + view.angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	if ply:lvsMouseAim() then
		return self:CalcViewMouseAim( ply, pos, angles, fov, pod )
	else
		return self:CalcViewDirectInput( ply, pos, angles, fov, pod )
	end
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:LVSCalcView( ply, original_pos, original_angles, original_fov, pod )
	local pos, angles, fov = self:CalcViewOverride( ply, original_pos, original_angles, original_fov, pod )

	if self:GetDriverSeat() == pod then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else
		return self:CalcViewPassenger( ply, pos, angles, fov, pod )
	end
end
--PATH lua/entities/lvs_base_starfighter/cl_hud.lua:
ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local Throttle = self:GetThrottle()
	local Col = Throttle <= 1 and color_white or Color(0,0,0,255)
	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if not self:GetEngineActive() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )

	if Throttle > 1 then
		draw.SimpleText( "+"..math.Round((Throttle - 1) * 100,0).."%" , "LVS_FONT",  hX, hY, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
end

function ENT:LVSPreHudPaint( X, Y, ply )
	return true
end

function ENT:LVSHudPaint( X, Y, ply )
	if not self:LVSPreHudPaint( X, Y, ply ) then return end

	if ply ~= self:GetDriver() then return end

	local HitPlane = self:GetEyeTrace( true ).HitPos:ToScreen()
	local HitPilot = self:GetEyeTrace().HitPos:ToScreen()

	self:PaintCrosshairCenter( HitPlane )
	self:PaintCrosshairOuter( HitPilot )

	if ply:lvsMouseAim() and not ply:lvsKeyDown( "FREELOOK" ) then
		self:LVSHudPaintMouseAim( HitPlane, HitPilot )
	end

	self:LVSPaintHitMarker( HitPilot )
end

function ENT:LVSHudPaintDirectInput( Pos2D )
	self:PaintCrosshairCenter( Pos2D )
	self:PaintCrosshairOuter( Pos2D )
end

function ENT:LVSHudPaintMouseAim( HitPlane, HitPilot )
	local Sub = Vector(HitPilot.x,HitPilot.y,0) - Vector(HitPlane.x,HitPlane.y,0)
	local Len = Sub:Length()
	local Dir = Sub:GetNormalized()

	surface.SetDrawColor( 255, 255, 255, 100 )
	if Len > 20 then
		surface.DrawLine( HitPlane.x + Dir.x * 5, HitPlane.y + Dir.y * 5, HitPilot.x - Dir.x * 20, HitPilot.y- Dir.y * 20 )

		-- shadow
		surface.SetDrawColor( 0, 0, 0, 50 )
		surface.DrawLine( HitPlane.x + Dir.x * 5 + 1, HitPlane.y + Dir.y * 5 + 1, HitPilot.x - Dir.x * 20+ 1, HitPilot.y- Dir.y * 20 + 1 )
	end
end

--PATH lua/entities/lvs_base_turret/sh_camera_eyetrace.lua:
return gluapack()()
--PATH lua/entities/lvs_cisprotonbomb.lua:
AddCSLuaFile()

ENT.Base = "lvs_missile"

ENT.Type = "anim"

ENT.PrintName = "Hyena Proton Bomb"
ENT.Author = "Luna"
ENT.Information = "geht ab wie'n zpfchen"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_bomb_cisexplosion"
ENT.GlowColor = Color( 255, 40, 100, 255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 400)
	end

	function ENT:GetRadius() 
		return (self._radius or 600)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_concussion_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((45 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--PATH lua/entities/lvs_dwarfdroid/cl_prediction.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_aat/cl_init.lua:
include("shared.lua")
include( "sh_turret.lua" )
include( "cl_prediction.lua" )

function ENT:OnSpawn()
	local mins, maxs = self:GetRenderBounds()
	self:SetRenderBounds( mins, maxs, Vector( 80, 0, 0 ) )
end

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(11,0,46) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,-40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:DamageFX()
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 60 - self:GetUp() * 30, angles, fov
	end

	return pos, angles, fov
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

--PATH lua/entities/lvs_fakehover_aat/sh_turret.lua:

function ENT:SetPoseParameterTurret( weapon )
	if self:GetIsCarried() then
		self:SetPoseParameter("turret_pitch", 0 )
		self:SetPoseParameter("turret_yaw",  0 )

		if self.TurretWasSet then
			self.TurretWasSet = nil

			self:SetTurretPitch( 0 )
			self:SetTurretYaw( 0 )
		end

		return
	end

	self.TurretWasSet = true

	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	local AimRate = self.TurretTurnRate * FrameTime() 

	self:SetTurretPitch( math.ApproachAngle( self:GetTurretPitch(), AimAng.p, AimRate ) )
	self:SetTurretYaw( math.ApproachAngle( self:GetTurretYaw(), AimAng.y, AimRate ) )

	self:SetPoseParameter("turret_pitch", self:GetTurretPitch() )
	self:SetPoseParameter("turret_yaw", self:GetTurretYaw() )
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.3
	weapon.HeatRateUp = 1.25
	weapon.HeatRateDown = 0.2
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/vehicles/aat/overheat.mp3")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return true end

		local ID = base:LookupAttachment( "muzzle" )
		local Muzzle = base:GetAttachment( ID )

		if not Muzzle then return end

		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= Muzzle.Ang:Up()
		bullet.Spread 	= Vector(0,0,0)
		bullet.TracerName = "lvs_laser_red_aat"
		bullet.Force	= 16000
		bullet.HullSize 	= 30
		bullet.Damage	= 500
		bullet.SplashDamage = 250
		bullet.SplashDamageRadius = 250
		bullet.Velocity = 6000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion_aat", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Muzzle.Ang:Up() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		base:PlayAnimation( "fire" )

		local PhysObj = base:GetPhysicsObject()
		if IsValid( PhysObj ) then
			PhysObj:ApplyForceOffset( -Muzzle.Ang:Up() * 25000, Muzzle.Pos )
		end

		if not IsValid( base.SNDTurret ) then return end

		base.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterTurret( ent )
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "turret_view" )
		local Att = base:GetAttachment( ID )

		if Att then
			local Pos,_= LocalToWorld( Vector(0,12,30), Angle(0,0,0), Att.Pos, Att.Ang )
			view.origin = Pos
		end

		if not pod:GetThirdPersonMode() then
			return view
		end

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( Vector(-75,0,140) )
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

--PATH lua/entities/lvs_fakehover_barc/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_gunship_hmp/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_laatle_patrolgunship_rep/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_missile.lua:
return gluapack()()
--PATH lua/entities/lvs_protontorpedo.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/cl_prediction.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/cl_lights.lua:
return gluapack()()
--PATH lua/entities/lvs_soundemitter.lua:
return gluapack()()
--PATH addons/[tfres] lego vechicles/lua/entities/lvs_space_laat_lego/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.nextEFX = 0
	self.nextDFX = 0
	self.nextBeepSound = 0
	self.nextLFX = 0
	self.NextAlertSound = 0
	--self.ActiveTime = CurTime()
	self.bommed = false
	self.onact = false
end


local spotlight = Material("effects/lvs/laat_spotlight")
local glow_spotlight = Material("sprites/light_glow02_add")
local spotlight_color = Color(255, 255, 255)
local glow_color = Color(255, 255, 255, 10)
local glow_reactor = Material("sprites/light_glow02_add")
local lamp_pos = Vector(3, 0, 135)
local lamp_color_black = Color(0, 0, 0)
local lamp_color_red = Color(255, 0, 0)
local lamp_color_green = Color(0, 255, 0)
local reactor_color = Color(0, 127, 255)
local reactor_pos = {
	Vector(-165, -20, 240),
	Vector(-165, 20, 240),
}

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.Red = Color( 255, 0, 0, 255)
ENT.SignalSprite = Material( "sprites/light_glow02_add" )
ENT.Spotlight = Material( "effects/lvs/spotlight_projectorbeam" )

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(-110,0,76.85),
	[2] = Vector(-110,0,41.82),
}

function ENT:WingTurretProjector()
	local FireWingTurret = self:GetWingTurretFire()

	if FireWingTurret == self.OldWingTurretFire then return end

	self.OldWingTurretFire = FireWingTurret

	if FireWingTurret then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lfs_fb_wingturret_projector", effectdata )
	end
end



function ENT:OnFrame()
	self:Boom()

	self:WingTurretProjector()

	self:ENGCheck()

	self:DamageFX()

	self:ExhaustFX()

end

function ENT:Boom()
	if self:GetHP() > 2200 then
		self.bommed = false
		self:StopParticles()
	end
	if self.bommed == false then
		if self:GetHP() < 2200 then
			ParticleEffectAttach("env_fire_large_smoke", PATTACH_POINT_FOLLOW, self, self:LookupAttachment("R_Heat_Hatch"))
			self.bommed = true
			local effectdata = EffectData()
				effectdata:SetOrigin(self:LocalToWorld(Vector(-300, 0, 180)))
			util.Effect("lvs_explosion_small", effectdata)
		end
	end
end

function ENT:ENGCheck()
	if self.onact == false then
		if self:GetEngineActive() == true then
			self.ActiveTime = CurTime()
			self.onact = true
			self.nextEFX = CurTime() + 1
		end
	end
	if self.onact == true then
		if self:GetEngineActive() == false then
			self.onact = false
			self.StopTime = CurTime()
		end
	end
	if self:GetEngineActive() == false then
		self.onact = false
	end
end

function ENT:ExhaustFX()
	local FullThrottle = self:GetThrottle() >= 35

	if self.OldFullThrottle ~= FullThrottle then
		self.OldFullThrottle = FullThrottle
		if FullThrottle then 
			self:EmitSound("laat_bf2/boost_"..math.random(1, 2)..".wav")
		end
	end

	if self:GetEngineActive() then
		if self.nextEFX < CurTime() then
			self.nextEFX = CurTime() + 0.01
			
			local emitter = ParticleEmitter(self:GetPos(), false)
			local Pos = {
				Vector(-150, -20, 230),
				Vector(-150, 20, 230),
			}

			if emitter then
				for _, v in pairs(Pos) do
					local vOffset = self:LocalToWorld( v )
					local vNormal = -self:GetForward()
					local vOffset2 = vOffset + vNormal * 5

					local particle = emitter:Add("sprites/heatwave", vOffset2)
					if not particle then return end
						particle:SetVelocity(vNormal * math.Rand(1500, 1000) + self:GetVelocity())
						particle:SetLifeTime(0)
						particle:SetDieTime(0.1)
						particle:SetStartAlpha(255)
						particle:SetEndAlpha(0)
						particle:SetStartSize(math.Rand(35, 50))
						particle:SetEndSize(math.Rand(0, 5))
						particle:SetRoll(math.Rand(-1, 1) * 100)
						particle:SetColor(255, 255, 255)
				end
				
				emitter:Finish()
			end
		end
	end
end

function ENT:CanSound()
	self.NextSound = self.NextSound or 0
	return self.NextSound < CurTime()
end

function ENT:CanSound2()
	self.NextSound2 = self.NextSound2 or 0
	return self.NextSound2 < CurTime()
end

function ENT:DelayNextSound( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound = CurTime() + fDelay
end

function ENT:DelayNextSound2( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound2 = CurTime() + fDelay
end

function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(math.Clamp(math.Clamp(80 + Pitch * 25, 50, 255) + Doppler, 0, 255))
		self.ENG:ChangeVolume(math.Clamp(-1 + Pitch * 6, 0.5, 1))
	end
	
	if self.DIST then
		local ply = LocalPlayer()
		local DistMul = math.min((self:GetPos() - ply:GetPos()):Length() / 8000, 1) ^ 2
		self.DIST:ChangePitch(math.Clamp(100 + Doppler * 0.2, 0, 255))
		self.DIST:ChangeVolume(math.Clamp(-1.5 + Pitch * 6, 0.5, 1) * DistMul)
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP <= 0 or HP > self:GetMaxHP() * 0.5 then return end

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05
		
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-150, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-150, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-150, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)

		if HP <= 2200 then
			if math.random(0, 45) < 3 then
				if math.random(1, 3) == 1 then
					local Pos = self:LocalToWorld(Vector(0, 0, 140) + VectorRand() * 20)
						effectdata:SetOrigin(Pos)
					util.Effect("cball_explode", effectdata, true, true)
					sound.Play("laat_bf2/spark"..math.random(1, 4)..".ogg", Pos, 75)
				end
			end

			local ply = LocalPlayer()
			if self.NextAlertSound < CurTime() then
				self.NextAlertSound = CurTime() + 0.27
				self:EmitSound( "laat_bf2/crash.mp3", 85 )

				--sound.Play("laat_bf2/crash.mp3", self:GetPos() + self:GetForward() * 190 + self:GetUp() * 160, 75)
			end
		end
	end
end



function ENT:Draw()
	self:DrawModel()

	if self:GetEngineActive() then
		render.SetMaterial(glow_reactor)
		local delta = CurTime() - self.ActiveTime
		local max = math.min(15 * ( delta / 1 ), 15)

		local t = 0
		for _, v in pairs(reactor_pos) do
			if self:GetHP() < 2200 then
				if self.nextLFX > CurTime() && t == 1 then continue end
				self.nextLFX = CurTime() + math.random(0, 2)
			end

			local vOffset = self:LocalToWorld(v)
			local vNormal = -self:GetForward()
			
			for i = 0, max do 
				local vUp = -self:GetUp()
				local ind = i * 2
				local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind*0.6

				render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
			end

			t = t + 1
		end
	else
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 1)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[2])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
			
		end
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 2)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[1])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
		end
	end
	
end

function ENT:OnRemove()
	self:RemoveLight()
	self:RemoveLight2()
end

function ENT:RemoveLight2()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end

	if IsValid( self.frojector ) then
		self.frojector:Remove()
		self.frojector = nil
	end
end

function ENT:RemoveLight()
	if IsValid( self.projector_L ) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid( self.projector_R ) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end

function ENT:UpdateSpotlight(ent, attachmentID)

end

function ENT:CreateSpotlight()

end

function ENT:OnSpawn()

end

--[[


function ENT:EngineEffects()
	if not self:GetEngineActive() then return end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end
end
]]--
function ENT:OnStartBoost()
	self:EmitSound( "laat_bf2/boost_"..math.random(1, 2)..".wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod == self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

--[[
function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() or self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end]]

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight2()
		return false
	end

	local attachment = {
		Pos = Vector(332.26,-2.1,5.41),
		Ang = Angle(135.25,-0.01,0.71)
	}

	return false
end
--PATH addons/[tfres] lego vechicles/lua/entities/lvs_space_laat_lego/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT LEGO"
ENT.Author = "Dec/frestylek"
ENT.Information = "Spaace version of the LAAT"
ENT.Category = "[LVS] LEGO"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/lego/lego_republic_gunship.mdl"
ENT.GibModels = {
	"models/lego/lego_republic_gunship_gib1.mdl",
	"models/lego/lego_republic_gunship_gib1_r.mdl"
}

ENT.DamageSounds = {
	"physics/metal/metal_sheet_impact_bullet2.wav",
	"physics/metal/metal_sheet_impact_hard2.wav",
	"physics/metal/metal_sheet_impact_hard6.wav",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2650
ENT.MaxThrust = 2650

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 6000
ENT.MaxShield = 0

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingTurretFire" )
	self:AddDT( "Vector", "WingTurretTarget" )
	self:NetworkVar( "Int", 23, "LampMode" )
	self:AddDT( "Float", "Activetime" )
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )
	self:NetworkVar( "Bool", 24, "SpotlightOn" )
	self:AddDT( "Bool", "SpotlightToggle" )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "laat_bf2/laat_takeoff.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end

ENT.EngineSounds = {
	{
		sound = "laat_bf2/engine_loop.mp3",
		Pitch = 90,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 85,
	},
	{
		sound = "laat_bf2/laat_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 75,
	},
}

sound.Add( {
	name = "LAAT_FIREMISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "laat_bf2/rocket_shot.mp3"
} )


function ENT:SetNextRearGunFire( delay )
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:GetRearGunInRange( ent )
	return ent:AngleBetweenNormal( ent:GetAimVector(), -ent:GetForward() ) < 35
end

function ENT:HandleRearGun( ent, ShouldFire )

	local trace = ent:GetEyeTrace()

	local Pos,Ang = WorldToLocal( Vector(100,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

	if not self:GetRearGunInRange( ent ) then 
		self:SetPoseParameter("back_turret_y", 0 )

		return false
	end

	self:SetPoseParameter("back_turret_z", Ang.p )
	self:SetPoseParameter("back_turret_y", -Ang.y )

	if not ShouldFire or not self:CanFireRearGun() then self:GetRearGunInRange( ent ) return end

	local startpos = self:GetBonePosition(self:LookupBone("Rear_Gun_End"))

	self:SetNextRearGunFire( 0.2 )

	local bullet = {}
	bullet.Src 	= ent:LocalToWorld( Vector(-500,0 ,-20) )
	bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
	bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
	bullet.TracerName = "lvs_laser_green_short"
	bullet.Force	= 10
	bullet.HullSize 	= 25
	bullet.Damage	= 65
	bullet.Velocity = 20000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local NewHeat = ent:GetHeat() + 0.2


	ent:SetHeat( NewHeat )
	if NewHeat >= 1 then
		ent:SetOverheated( true )
	end

	if not IsValid( self.SNDTail ) then return end

	self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(100,0,103) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:InitWeapons()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	local MaxRange = 60
	local MaxTailRange = 35

	self.lor = 1

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.18
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= 20 then return true end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = ent:GetEyeTrace()

		local bullet = {}
		bullet.Spread 	= Vector( 0.02,  0.02, 0.02 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 60
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 28000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
	
		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(320,32 * i,37) )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
				
			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("Front_Turret_Z", 0 )
			ent:SetPoseParameter("Front_Turret_Y", 0 )

			return
		end

		ent:SetPoseParameter("Front_Turret_Z", AimAngles.p )
		ent:SetPoseParameter("Front_Turret_Y", -AimAngles.y )
	end
	self:AddWeapon( weapon )

	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.4
	weapon.HeatRateDown = 0
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.StartAttack = function( ent )
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function( ent )
		ent.ShouldFire = false

		local base = ent:GetVehicle()

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		for _, sound in pairs( snd ) do
			if not IsValid( sound ) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		local ShouldFire = (ent.ShouldFire == true) and ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) < MaxRange
	
		if base:HandleRearGun( ent, ent.ShouldFire ) then
			ShouldFire = false
		end

		if base:SetWingTurretFire() ~= ShouldFire then
			base:SetWingTurretFire( ShouldFire ) 
		end

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		if ent._oldShouldFire ~= ShouldFire then
			ent._oldShouldFire = ShouldFire
			if ShouldFire then
				for _, sound in pairs( snd ) do
					if not IsValid( sound ) then continue end

					sound:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
				end
			end
		end

		if not ShouldFire then
			for _, sound in pairs( snd ) do
				if not IsValid( sound ) then continue end
				sound:Stop()
			end

			ent:SetHeat( ent:GetHeat() - FrameTime() )

			return
		end
	
		if not active then
			return
		end

		local trace = ent:GetEyeTrace()
		local DesEndPos = trace.HitPos

		base:SetWingTurretTarget( DesEndPos )

		if not base:GetWingTurretFire() then return end
		
		local DesStartPos --= Vector(-55, 350, 90)

		if base:WorldToLocal( DesEndPos ).z < 0 then
			DesStartPos = Vector(-55, 350, 90)
		else
			DesStartPos = Vector(-55, 370, 125)
		end

		local NewHeat = ent:GetHeat()

		for i = -1,1,2 do
			local StartPos = self:LocalToWorld( DesStartPos * Vector(1,i,1)  )
			local beam = util.TraceLine( { start = StartPos, endpos = DesEndPos} )

			self:BallturretDamage( beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized() )

			if not IsValid( snd[i] ) then continue end

			if beam.Entity ~= base then
				snd[i]:Play()
				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * (350 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - clamped_angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 10
	weapon.Delay = 0 
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )

		local T = CurTime()
		local pos = 0
		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if self.lor == 1 then
			pos = Vector(-63.81,-263.11,132.86)
			self.lor = 2
		else
			pos = Vector(-65.8,271.86,131.86)
			self.lor = 1
		end

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( self:LocalToWorld( pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetDamage( 1250 )
		projectile:SetRadius( 350 )
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.2 )
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 40
	weapon.Delay = 2
	weapon.HeatRateUp = 1 
	weapon.HeatRateDown = 0.08
	weapon.Attack = function( ent )


		--if not ent:WeaponsInRange() then return true end
		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 100 then return true end

		for i = 1, 2 do
			timer.Simple( (i / 7) * 0.1, function()
				if not IsValid( ent ) then return end


				if self.lor == 1 then
					pos = Vector(99.71,69.93,276.31)
					self.lor = 2
				else
					pos = Vector(88.08,-69.92,276.24)
					self.lor = 1
				end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local trace = ent:GetEyeTrace()
				local Start = pos
				local Dir = (ent:GetEyeTrace().HitPos - veh:LocalToWorld(Start)):GetNormalized()
				local projectile = ents.Create( "lvs_protontorpedo" )
				projectile:SetPos(veh:LocalToWorld(Start))
				projectile:SetAngles( ent:GetAngles() )
				projectile:SetParent( )
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-5,5) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:SetDamage( 1250 )
				projectile:SetRadius( 550 )
				projectile:Enable()
				projectile:EmitSound("LAAT_FIREMISSILE" )
			end)
			self.RocketsModel:ResetSequence("Load_Missile")

		end
	end
	weapon.FinishAttack = function( ent )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()
	
		if not IsValid( base ) then return end
	
		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )
	
		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE
	
		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 
	
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon, 2 )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetBodygroup(7, 0)
		else
			self:SetBodygroup(7, 1)
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetSpotlightOn(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightOn(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:ToggleHatch()
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		if (self.gateDown) then
			self.gateDown = false
			self:DropHeldEntity()
		else
			self:GrabEntity()
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:DoorOC()
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightToggle(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

function ENT:IsSpotlightMounted()
	return self:GetBodygroup(7) == 1
end

--PATH lua/entities/lvs_starfighter_vulturedroid/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-151,87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,87,-15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,-15), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineFXColor = Color( 38, 0, 230, 255)
ENT.EngineFxPos = {
	Vector(-49.5,-45.31,1.9),
	Vector(-47,-48.39,1.8),
	Vector(-45,-51.55,1.7),
	Vector(-43,-54.71,1.6),
	Vector(-41,-57.97,1.5),
	Vector(-39,-60.82,1.4),
	Vector(-49.5,45.31,1.9),
	Vector(-47,48.39,1.8),
	Vector(-45,51.55,1.7),
	Vector(-43,54.71,1.6),
	Vector(-41,57.97,1.5),
	Vector(-39,60.82,1.4),
	Vector(-49.5,-45.31,-1.9),
	Vector(-47,-48.39,-1.8),
	Vector(-45,-51.55,-1.7),
	Vector(-43,-54.71,-1.6),
	Vector(-41,-57.97,-1.5),
	Vector(-39,-60.82,-1.4),
	Vector(-49.5,45.31,-1.9),
	Vector(-47,48.39,-1.8),
	Vector(-45,51.55,-1.7),
	Vector(-43,54.71,-1.6),
	Vector(-41,57.97,-1.5),
	Vector(-39,60.82,-1.4),
}

function ENT:PostDraw()
	if not self:GetEngineActive() then return end

	cam.Start3D2D( self:LocalToWorld( Vector(-36.2,-62.6,0) ), self:LocalToWorldAngles( Angle(0,299,90) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( -11, -1.5, 19.7, 6 , -3.4 )
		surface.DrawTexturedRectRotated( -11, 1.5, 19.7, 6 , 3.4 )
	cam.End3D2D()

	cam.Start3D2D( self:LocalToWorld( Vector(-36.2,62.6,0) ), self:LocalToWorldAngles( Angle(0,61,-90) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( -11, -1.5, 19.7, 6 , -3.4 )
		surface.DrawTexturedRectRotated( -11, 1.5, 19.7, 6 , 3.4 )
	cam.End3D2D()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + self:GetThrottle() * 15 + self:GetBoost() * 0.4

	render.SetMaterial( self.EngineGlow )

	for _, v in pairs( self.EngineFxPos ) do
		local pos = self:LocalToWorld( v )
		render.DrawSprite( pos, Size, Size, self.EngineFXColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/brake.wav", 85 )
end

--PATH lua/entities/lvs_sw_transport/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_aa_red/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_aa_red/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Air Turret"
ENT.Author = "Luna"
ENT.Information = "It shoots lasers into the sky and makes things go boom"
ENT.Category = "[LVS] - Turrets (CIS)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antiairturret/rep_anti-airturret.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 4800

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle1" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,60) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= -10 or AimAngles.p <= -180)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.HeatRateUp = .34
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID_1 = self:LookupAttachment( "muzzle1" )
		local ID_2 = self:LookupAttachment( "muzzle2" )
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )

		if not Muzzle1 or not Muzzle2 then return end		

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 100
		bullet.HullSize 	= 50
		bullet.Damage	= 35
		bullet.Velocity = 50000
		bullet.SplashDamage	= 70
		bullet.SplashDamageRadius	= 250
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = .2
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()
		local dir = ent:GetAimVector()
		local trace = ent:GetEyeTrace()
		local base = ent:GetVehicle()

		local ID_1 = self:LookupAttachment( "muzzle1" )
		local ID_2 = self:LookupAttachment( "muzzle2" )
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )

		if not Muzzle1 or not Muzzle2 then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Up()

		ent.SwapTopBottom = not ent.SwapTopBottom

		base.SecondarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = Pos
		bullet.Dir = Dir
		bullet.Spread 	= Vector( 0.07,  0.07, 0.07 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 50000
		--bullet.SplashDamage	= 20
		--bullet.SplashDamageRadius	= 200
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )
	end
	
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--PATH lua/entities/lvs_turret_av_red/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_av_red/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--PATH addons/[tfres] lego vechicles/lua/entities/lvs_vwing_advanced_lego/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "V-Wing Lego"
ENT.Author = "Dec/frestylek"
ENT.Information = "Starfighter of the Galactic Republic"
ENT.Category = "[LVS] LEGO"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/lego/lego_naboo_starfighter.mdl"
ENT.GibModels = {
	"models/lego/lego_jedi_interceptor_gib2_r.mdl",
	"models/lego/lego_naboo_starfighter_gib1.mdl",
}

ENT.TurnRatePitch = 1.5
ENT.TurnRateYaw = 1.5
ENT.TurnRateRoll = 1.5


ENT.AITEAM = 2

ENT.MaxHealth = 1000
ENT.MaxShield = 600

ENT.MaxVelocity = 2850
ENT.MaxThrust = 2850

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3


ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.FlyByAdvance = 0.6
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 3000
	weapon.Delay = 0.07
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.7
	weapon.Attack = function( ent )

		if not ent:GetFoils() then
			ent:SetHeat(ent:GetHeat() + 0.6 )
		end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local fP = {Vector(40,68,-13.5),Vector(40,-68,-23.5),Vector(40,68,-13.5),Vector(40,-68,-23.5)}

		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local Driver = self:GetDriver()

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld(fP[self.NumPrim])
		bullet.Dir 	= self:GetForward()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 80
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		self:EmitSound( "VANILLA_VWING_FIRE" )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")

		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 3
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 1 )
		end
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = self:GetDriver()

		local fP = {Vector(40,68,-13.5),Vector(40,-68,-23.5),Vector(40,68,-13.5),Vector(40,-68,-23.5)}

		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( self:LocalToWorld(fP[self.NumPrim]) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:SetDamage(1200)
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/nos.png")
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.UseableByAI = false
	weapon.Attack = function( ent )
		if ent:GetFoils() == false then return end
		local PhysObj = ent:GetPhysicsObject()
		if not IsValid( PhysObj ) then return end
		local THR = ent:GetThrottle()
		local FT = FrameTime()

		local Vel = ent:GetVelocity():Length()

		PhysObj:ApplyForceCenter( ent:GetForward() * math.Clamp(ent.MaxVelocity + 500 - Vel,0,1) * PhysObj:GetMass() * THR * FT * 150 ) -- increase speed
		PhysObj:AddAngleVelocity( PhysObj:GetAngleVelocity() * FT * 0.5 * THR ) -- increase turn rate
	end
	weapon.StartAttack = function( ent )
		ent.TargetThrottle = 1.3
		ent:EmitSound("lvs/vehicles/generic/boost.wav")
	end
	weapon.FinishAttack = function( ent )
		ent.TargetThrottle = 1
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("buttons/lever5.wav")
	end
	weapon.OnThink = function( ent, active )
		
		if not ent.TargetThrottle then return end

		local Rate = FrameTime() * 0.5

		ent:SetMaxThrottle( ent:GetMaxThrottle() + math.Clamp(ent.TargetThrottle - ent:GetMaxThrottle(),-Rate,Rate) )

		local MaxThrottle = ent:GetMaxThrottle()

		ent:SetThrottle( MaxThrottle )

		if MaxThrottle == ent.TargetThrottle then
			ent.TargetThrottle = nil
		end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat_boost.wav") end

	self:AddWeapon( weapon )
end



ENT.EngineSounds = {
	{
		sound = "VANILLA_VWING_ENGINE",
		sound_int = "lvs/vehicles/vwing/loop_interior.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
	{
		sound = "VANILLA_VWING_HUM",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "VANILLA_VWING_ENGINE",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 125,
	sound = "vanilla/vwing/vanilla_vwing_engine.wav"
} )

sound.Add( {
	name = "VANILLA_VWING_HUM",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 125,
	sound = "vanilla/vwing/vanilla_vwing_hum.wav"
} )

sound.Add( {
	name = "VANILLA_VWING_FIRE",
	channel = CHAN_WEAPON,
	volume = 0.8,
	level = 125,
	pitch = {95, 98},
	sound = "vanilla/vwing/vanilla_vwing_fire.wav"
} )
--PATH lua/entities/lvs_walker_atrt_flamethrower/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_flamethrower/cl_init.lua:
include("shared.lua")
include( "cl_ikfunctions.lua" )
include( "cl_camera.lua" )
include( "cl_legs.lua" )

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		if self:GetIsRagdoll() then
			if math.random(0,45) < 3 then
				if math.random(1,2) == 1 then
					local Pos = self:LocalToWorld( Vector(0,0,20) + VectorRand() * 80 )
					local effectdata = EffectData()
						effectdata:SetOrigin( Pos )
					util.Effect( "cball_explode", effectdata, true, true )
					
					sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
				end
			end
		end

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,100) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,20,80) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,-20,80) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local Vel = self:GetVelocity():Length()
	local kmh = math.Round(Vel * 0.09144,0)

	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if self:GetIsCarried() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )
	end
end



function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end


local spotlight = Material( "effects/lfs_base/spotlight_projectorbeam" )
local glow_spotlight = Material( "sprites/light_glow02_add" )

function ENT:Draw()
	self:DrawModel()
	
	if not self:GetFlashlightStatus(false) then 
		self:RemoveLight()

		return
	end
	
	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 20 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local StartPos = self:LocalToWorld( Vector(45,0,85) )
	local Dir = self:GetForward()

	render.SetMaterial( glow_spotlight )
	render.DrawSprite( StartPos + Dir * -10 , 120, 20, Color( 255, 255, 255, 255) )


	render.SetMaterial( spotlight )
	render.DrawBeam(  StartPos - Dir * 5,  StartPos + Dir * 200, 150, 0, 0.99, Color( 255, 255, 255, 10) ) 
	
	if IsValid( self.projector ) then
		self.projector:SetPos( StartPos )
		self.projector:SetAngles( Dir:Angle() )
		self.projector:Update()
	end
end
--PATH lua/entities/lvs_walker_atrt_flamethrower/cl_ikfunctions.lua:

function ENT:OnRemoved()
	self:LegClearAll()
	self:RemoveLight()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then 
		for _, tab in pairs( self.IK_Joints ) do
			for _,prop in pairs( tab ) do
				if IsValid( prop ) then
					prop:Remove()
				end
			end
		end
		
		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts( index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS )
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[ index ] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[ index ] then
		self.IK_Joints[ index ] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2 * 0.22 ) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.7) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()
		
		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )
	
	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--PATH lua/entities/lvs_walker_atrt_rotary/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "AT-RT (Rotary)"
ENT.Author = "Luna, Foranox"
ENT.Information = "Assault Walker of the Galactic Republic"
ENT.Category = "[LVS] - The Outer Rim"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Walkers"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/astartes/atrt/body.mdl"
ENT.GibModels = {
	"models/astartes/atrt/body.mdl",
	"models/astartes/atrt/leg2.mdl",
	"models/astartes/atrt/leg3.mdl",
	"models/astartes/atrt/leg0.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 2000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 92
ENT.HoverTraceLength = 137
ENT.HoverHullRadius = 10

ENT.LAATC_PICKUPABLE = false
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-220,0,-200)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()

	self:AddDT( "Float", "Move" )
	self:AddDT( "Bool", "FlashlightStatus" )
	self:AddDT( "Bool", "IsMoving" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Bool", "IsRagdoll" )
	self:AddDT( "Vector", "AIAimVector" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:ShootTurret(ent)
	local muzzle = self:GetAttachment( self:LookupAttachment( "turret" ) )

	if not muzzle then return end

	local AimAngles, AimPos, InRange = self:GetMainAimAngles()

	local Pos = muzzle.Pos
	local Dir = (AimPos - Pos):GetNormalized()

	if not InRange then return true end

	local bullet = {}
	bullet.Src 	= Pos
	bullet.Dir 	= Dir
	bullet.Spread 	= Vector( 0.01,  0.01, 0 )
	bullet.TracerName = "lvs_laser_blue_short"
	bullet.Force	= 10
	bullet.HullSize 	= 30
	bullet.Damage	= 80
	bullet.SplashDamage = 40
	bullet.SplashDamageRadius = 100
	bullet.Velocity = 8000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_explosion", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local effectdata = EffectData()
	effectdata:SetStart( Vector(50,50,250) )
	effectdata:SetOrigin( bullet.Src )
	effectdata:SetNormal( Dir )
	effectdata:SetEntity( ent )
	util.Effect( "lvs_muzzle_colorable", effectdata )

	ent:TakeAmmo()

	if not IsValid( ent.SNDPrimary ) then return end

	ent.SNDPrimary:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
end

function ENT:GetContraption()
	return {self}
end


function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end


function ENT:GetMainAimAngles()
	local trace = self:GetEyeTrace()
	
	--[[
	local Driver = self:GetDriver()
	if Driver:IsPlayer() then
		trace = Driver:GetEyeTrace()
	end ]]--


	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,100)) ):GetNormalized():Angle() )

	local ID = self:LookupAttachment( "turret" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return AimAngles, trace.HitPos, false end

	local DirAng = self:WorldToLocalAngles( (trace.HitPos - self:GetDriverSeat():LocalToWorld( Vector(0,0,33) ) ):Angle() )

	return AimAngles, trace.HitPos, (math.abs( DirAng.p ) < 100) and math.abs( DirAng.y ) < 60
end


function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 3000
	weapon.Delay = 0
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.5
	weapon.HudPaint = function( ent, X, Y, ply )
		local AimAngles, AimPos, InRange = self:GetMainAimAngles()
		
		if InRange then 

			local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

			local base = ent:GetVehicle()
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
			base:LVSPaintHitMarker( Pos2D )
		end
	end
	weapon.Attack = function( ent )
		if ent:GetIsCarried() then return true end
		if self.Ammo == 0 then return false end
		if (ent.MiniGunNextShoot or 0) > CurTime() then
			return 
		end
		-- ent:SetHeat( math.min( 1, ent:GetHeat() + weapon.HeatRateUp ) )


		local muzzle = self:GetAttachment( self:LookupAttachment( "turret" ) )

		if not muzzle then return end

		local AimAngles, AimPos, InRange = self:GetMainAimAngles()

		local Pos = muzzle.Pos
		local Dir = (AimPos - Pos):GetNormalized()

		if not InRange then return true end

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.03,  0.03, 0 )
		bullet.TracerName = "lvs_laser_blue_short"
		bullet.Force	= 10
		bullet.HullSize 	= 20
		bullet.Damage	= 30
		bullet.SplashDamage = 10
		bullet.SplashDamageRadius = 25
		bullet.Velocity = 15000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if not IsValid( ent.SNDPrimary ) then return end

		ent.SNDPrimary:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )

		ent.LastMinigunFire = CurTime()

		local nextShoot = math.max( 0.1, 1 - (ent:GetHeat() + 0.5) )
		ent.MiniGunNextShoot = CurTime() + nextShoot
	end

	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()
		if IsValid( base ) and base:GetIsCarried() then return end

		local AimAngles = ent:GetMainAimAngles()

		local p = math.Clamp(AimAngles.p, -25, 35)
		local y = math.Clamp(AimAngles.y, -78, 78)

		ent:ManipulateBoneAngles(2, Angle(0,0,p))
		ent:ManipulateBoneAngles(1, Angle(y,0,0))
	end

	self:AddWeapon( weapon )
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = 30
	weapon.Delay = 1
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 1

	weapon.Attack = function( ent )
		if ent:GetIsCarried() then return true end
		if self.Ammo == 0 then return false end
		if (ent.MiniGunNextShoot or 0) > CurTime() then
			return 
		end
		-- ent:SetHeat( math.min( 1, ent:GetHeat() + weapon.HeatRateUp ) )


		local muzzle = self:GetAttachment( self:LookupAttachment( "turret" ) )

		if not muzzle then return end

		local AimAngles, AimPos, InRange = self:GetMainAimAngles()

		local Pos = muzzle.Pos
		local Dir = (AimPos - Pos):GetNormalized()

		if not InRange then return true end

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.03,  0.03, 0 )
		bullet.TracerName = "lvs_tracer_proton"
		bullet.Force	= 10
		bullet.HullSize 	= 20
		bullet.Damage	= 120
		bullet.SplashDamage = 40
		bullet.SplashDamageRadius = 100
		bullet.Velocity = 5000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		self:EmitSound( "lvs/vehicles/atte/fire_turret.mp3", 75, 105 )
		ent:TakeAmmo()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if IsValid( base ) and base:GetIsCarried() then return end

		local AimAngles = ent:GetMainAimAngles()

		local p = math.Clamp(AimAngles.p, -25, 35)
		local y = math.Clamp(AimAngles.y, -78, 78)

		ent:ManipulateBoneAngles(2, Angle(0,0,p))
		ent:ManipulateBoneAngles(1, Angle(y,0,0))
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local AimAngles, AimPos, InRange = self:GetMainAimAngles()
		
		if InRange then 

			local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

			local base = ent:GetVehicle()
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
			base:LVSPaintHitMarker( Pos2D )
		end
	end
	self:AddWeapon( weapon )
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/light.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetFlashlightStatus(false) then
			self:SetFlashlightStatus(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetFlashlightStatus(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	self:AddWeapon( weapon )
end
--PATH lua/entities/lvs_walker_atrt_standart/cl_init.lua:
include("shared.lua")
include( "cl_ikfunctions.lua" )
include( "cl_camera.lua" )
include( "cl_legs.lua" )

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		if self:GetIsRagdoll() then
			if math.random(0,45) < 3 then
				if math.random(1,2) == 1 then
					local Pos = self:LocalToWorld( Vector(0,0,20) + VectorRand() * 80 )
					local effectdata = EffectData()
						effectdata:SetOrigin( Pos )
					util.Effect( "cball_explode", effectdata, true, true )
					
					sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
				end
			end
		end

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,100) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,20,80) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,-20,80) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local Vel = self:GetVelocity():Length()
	local kmh = math.Round(Vel * 0.09144,0)

	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if self:GetIsCarried() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )
	end
end



function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end


local spotlight = Material( "effects/lfs_base/spotlight_projectorbeam" )
local glow_spotlight = Material( "sprites/light_glow02_add" )

function ENT:Draw()
	self:DrawModel()
	
	if not self:GetFlashlightStatus(false) then 
		self:RemoveLight()

		return
	end
	
	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 20 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local StartPos = self:LocalToWorld( Vector(45,0,85) )
	local Dir = self:GetForward()

	render.SetMaterial( glow_spotlight )
	render.DrawSprite( StartPos + Dir * -10 , 120, 20, Color( 255, 255, 255, 255) )


	render.SetMaterial( spotlight )
	render.DrawBeam(  StartPos - Dir * 5,  StartPos + Dir * 200, 150, 0, 0.99, Color( 255, 255, 255, 10) ) 
	
	if IsValid( self.projector ) then
		self.projector:SetPos( StartPos )
		self.projector:SetAngles( Dir:Angle() )
		self.projector:Update()
	end
end
--PATH lua/entities/lvs_walker_atrt_standart/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "AT-RT (Standart)"
ENT.Author = "Luna, Foranox"
ENT.Information = "Assault Walker of the Galactic Republic"
ENT.Category = "[LVS] - The Outer Rim"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Walkers"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/astartes/atrt/body.mdl"
ENT.GibModels = {
	"models/astartes/atrt/body.mdl",
	"models/astartes/atrt/leg2.mdl",
	"models/astartes/atrt/leg3.mdl",
	"models/astartes/atrt/leg0.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 2000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 92
ENT.HoverTraceLength = 137
ENT.HoverHullRadius = 10

ENT.LAATC_PICKUPABLE = false
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-220,0,-200)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()

	self:AddDT( "Float", "Move" )
	self:AddDT( "Bool", "FlashlightStatus" )
	self:AddDT( "Bool", "IsMoving" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Bool", "IsRagdoll" )
	self:AddDT( "Vector", "AIAimVector" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:ShootTurret(ent)
	local muzzle = self:GetAttachment( self:LookupAttachment( "turret" ) )

	if not muzzle then return end

	local AimAngles, AimPos, InRange = self:GetMainAimAngles()

	local Pos = muzzle.Pos
	local Dir = (AimPos - Pos):GetNormalized()

	if not InRange then return true end

	local bullet = {}
	bullet.Src 	= Pos
	bullet.Dir 	= Dir
	bullet.Spread 	= Vector( 0.01,  0.01, 0 )
	bullet.TracerName = "lvs_laser_blue_short"
	bullet.Force	= 10
	bullet.HullSize 	= 30
	bullet.Damage	= 80
	bullet.SplashDamage = 40
	bullet.SplashDamageRadius = 100
	bullet.Velocity = 8000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_explosion", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local effectdata = EffectData()
	effectdata:SetStart( Vector(50,50,250) )
	effectdata:SetOrigin( bullet.Src )
	effectdata:SetNormal( Dir )
	effectdata:SetEntity( ent )
	util.Effect( "lvs_muzzle_colorable", effectdata )

	ent:TakeAmmo()

	if not IsValid( ent.SNDPrimary ) then return end

	ent.SNDPrimary:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
end

function ENT:GetContraption()
	return {self}
end


function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end


function ENT:GetMainAimAngles()
	local trace = self:GetEyeTrace()
	
	--[[
	local Driver = self:GetDriver()
	if Driver:IsPlayer() then
		trace = Driver:GetEyeTrace()
	end ]]--


	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,100)) ):GetNormalized():Angle() )

	local ID = self:LookupAttachment( "turret" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return AimAngles, trace.HitPos, false end

	local DirAng = self:WorldToLocalAngles( (trace.HitPos - self:GetDriverSeat():LocalToWorld( Vector(0,0,33) ) ):Angle() )

	return AimAngles, trace.HitPos, (math.abs( DirAng.p ) < 100) and math.abs( DirAng.y ) < 60
end


function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.3

	weapon.Attack = function( ent )
		if ent:GetIsCarried() then return true end
		if self.Ammo == 0 then return false end

		return self:ShootTurret(ent)
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local AimAngles, AimPos, InRange = self:GetMainAimAngles()
		
		if InRange then 

			local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

			local base = ent:GetVehicle()
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
			base:LVSPaintHitMarker( Pos2D )
		end
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 60
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.45
	weapon.HeatRateDown = 0.05

	weapon.Attack = function( ent )
		if ent:GetIsCarried() then return true end
		if self.Ammo == 0 then return false end

		return self:ShootTurret(ent)
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if IsValid( base ) and base:GetIsCarried() then return end

		local AimAngles = ent:GetMainAimAngles()

		local p = math.Clamp(AimAngles.p, -25, 35)
		local y = math.Clamp(AimAngles.y, -78, 78)

		ent:ManipulateBoneAngles(2, Angle(0,0,p))
		ent:ManipulateBoneAngles(1, Angle(y,0,0))
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local AimAngles, AimPos, InRange = self:GetMainAimAngles()
		
		if InRange then 

			local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

			local base = ent:GetVehicle()
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
			base:LVSPaintHitMarker( Pos2D )
		end
	end
	self:AddWeapon( weapon )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/light.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetFlashlightStatus(false) then
			self:SetFlashlightStatus(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetFlashlightStatus(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	self:AddWeapon( weapon )
end
--PATH lua/entities/lvs_walker_atrt_standart/cl_ikfunctions.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/sh_turret.lua:

function ENT:SetPosTurret()
	local Turret = self:GetTurretSeat()

	if not IsValid( Turret ) then return end

	local ID = self:LookupAttachment( "driver_turret" )
	local Att = self:GetAttachment( ID )

	if not Att then return end

	local PosL = self:WorldToLocal( Att.Pos + Att.Ang:Right() * 20 - Att.Ang:Up() * 5 )
	Turret:SetLocalPos( PosL )
end

function ENT:SetPoseParameterTurret( weapon )
	if self:GetIsCarried() then
		self:SetPoseParameter("cannon_pitch", 0 )
		self:SetPoseParameter("cannon_yaw", 180 )

		if self.TurretWasSet then
			self.TurretWasSet = nil

			self:SetTurretPitch( 0 )
			self:SetTurretYaw( 180 )
		end

		return
	end

	self.TurretWasSet = true

	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	local AimRate = self.TurretTurnRate * FrameTime() 

	self:SetTurretPitch( math.ApproachAngle( self:GetTurretPitch(), AimAng.p, AimRate ) )
	self:SetTurretYaw( math.ApproachAngle( self:GetTurretYaw(), AimAng.y, AimRate ) )

	self:SetPoseParameter("cannon_pitch", self:GetTurretPitch() )
	self:SetPoseParameter("cannon_yaw", self:GetTurretYaw() )
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 160
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.6
	weapon.HeatRateDown = 0.25
	weapon.OnOverheat = function( ent ) end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then ent:SetHeat( 0 ) return true end

		base:PlayAnimation( "fire_turret" )

		local ID = base:LookupAttachment( "muzzle_cannon" )
		local Muzzle = base:GetAttachment( ID )

		if not Muzzle then return end

		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= Muzzle.Ang:Up()
		bullet.Spread 	= Vector(0,0,0)
		bullet.TracerName = "lvs_tracer_proton"
		bullet.Force	= 150000
		bullet.EnableBallistics = true
		bullet.HullSize 	= 1
		bullet.Damage	= 400
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 250
		bullet.SplashDamageEffect = "lvs_proton_explosion"
		bullet.SplashDamageType = DMG_AIRBOAT
		bullet.Velocity = 25000
		bullet.Attacker 	= ent:GetDriver()
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(0,0,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Muzzle.Ang:Up() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if not IsValid( base.SNDTurret ) then return end

		base.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )		
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterTurret( ent )
		base:SetPosTurret()
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "driver_turret" )
		local Att = base:GetAttachment( ID )

		if Att then
			local Pos,_= LocalToWorld( Vector(0,25,110), Angle(0,0,0), Att.Pos, Att.Ang )
			view.origin = Pos
		end

		if not pod:GetThirdPersonMode() then
			return view
		end

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( Vector(95,0,280) )
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local ID = base:LookupAttachment( "muzzle_cannon" )
		local Muzzle = base:GetAttachment( ID )

		if not Muzzle then return end

		local dir = Muzzle.Ang:Up()
		local pos = Muzzle.Pos

		local trace = util.TraceLine( {
			start = pos,
			endpos = (pos + dir * 50000),
			filter = function( entity ) 
				if base:GetCrosshairFilterLookup()[ entity:EntIndex() ] or entity:GetClass():StartWith( "lvs_protontorpedo" ) then
					return false
				end

				return true
			end,
		} )

		local Pos2D = trace.HitPos:ToScreen()

		self:PaintCrosshairCenter( Pos2D )
		self:PaintCrosshairOuter( Pos2D )
		self:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/atte/overheat.mp3", 85) end
	self:AddWeapon( weapon, 2 )
end
--PATH lua/entities/lvs_walker_hsd/cl_prediction.lua:
return gluapack()()
--PATH lua/entities/mk6.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/money_printer/shared.lua:
--Static Vars
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Money Printer"
ENT.Author = "DarkRP Developers"
ENT.Spawnable = false
ENT.sparking = false
ENT.IsMoneyPrinter = true

function ENT:initVars()
    self.MoneyCount = GAMEMODE.Config.mprintamount
    self.OverheatChance = GAMEMODE.Config.printeroverheatchance
    self.model = "models/props_c17/consolebox01a.mdl"
    self.damage = 100
    self.DisplayName = "Money Printer"
    self.MinTimer = 100
    self.MaxTimer = 350
    self.SeizeReward = GAMEMODE.Config.printerreward
end

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "price")
    self:NetworkVar("Entity", 0, "owning_ent")
end

DarkRP.hookStub{
    name = "moneyPrinterCatchFire",
    description = "Called when a money printer is about to catch fire.",
    parameters = {
        {
            name = "moneyprinter",
            description = "The money printer that is about to catch fire",
            type = "Entity"
        }
    },
    returns = {
        {
            name = "prevent",
            description = "Set to true to prevent the money printer from catching fire",
            type = "boolean"
        }
    },
    realm = "Server"
}

DarkRP.hookStub{
    name = "moneyPrinterPrintMoney",
    description = "Called when a money printer is about to print money.",
    parameters = {
        {
            name = "moneyprinter",
            description = "The money printer that is about to print money",
            type = "Entity"
        },
        {
            name = "amount",
            description = "The amount to be printed",
            type = "number"
        }
    },
    returns = {
        {
            name = "prevent",
            description = "Set to true to prevent the money printer from printing the money.",
            type = "boolean"
        },
        {
            name = "amount",
            description = "Optionally override the amount of money that will be printed.",
            type = "number"
        }
    },
    realm = "Server"
}

DarkRP.hookStub{
    name = "moneyPrinterPrinted",
    description = "Called after a money printer is has printed money.",
    parameters = {
        {
            name = "moneyprinter",
            description = "The money printer",
            type = "Entity"
        },
        {
            name = "moneybag",
            description = "The moneybag produced by the printer.",
            type = "Entity"
        }
    },
    returns = {
    },
    realm = "Server"
}

--PATH lua/entities/mortar_bomb_shell/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_dioxis/shared.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Dioxis Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_grenade_dioxis.mdl"
ENT.FuseTime = 2

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        timer.Simple(self.FuseTime, function()
           if IsValid(self) then
              self:Detonate()
           end
        end)

        util.PrecacheSound("kraken/explosives/dioxis/beep.wav")
        self:EmitSound("kraken/explosives/dioxis/beep.wav")

        timer.Simple(0.1, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
        end)
    end
	ParticleEffectAttach("grenadetrail", PATTACH_ABSORIGIN_FOLLOW, self, 0)
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
			self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"), 75, 100, 0.3, CHAN_AUTO )
        elseif data.Speed > 45 then
			self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"), 75, 100, 0.3, CHAN_AUTO )
        end
    end
	self:StopParticles()
end

function ENT:Think()
    if SERVER then
        local phys = self:GetPhysicsObject()
        phys:ApplyForceCenter(self:GetAngles():Forward() * 500)
    end
end

function ENT:Detonate()
   if (self:WaterLevel() >= 1 or self:WaterLevel() >= 2) then
    SafeRemoveEntityDelayed(self, 0)
    self:Remove()
    self:EmitSound(Sound("kraken/explosives/dioxis/start" .. math.random(1,4) .. ".wav"), 75, 100, 0.3, CHAN_AUTO )
    else
    self:DoDetonate()
   end
end
  
function ENT:DoDetonate()
    if self:WaterLevel() > 0 then self:Remove() return end
    local attacker = self.Attacker or self:GetOwner() or self
        local cloud = ents.Create("dioxis_spawned")
        if IsValid(cloud) then
            cloud:SetPos(self:GetPos())
            cloud:SetAngles(self:GetAngles())
            cloud:SetOwner(attacker)
            cloud:Spawn()
            cloud:EmitSound(Sound("kraken/explosives/dioxis/start" .. math.random(1,4) .. ".wav"), 120, 100, 0.3, CHAN_AUTO )
            cloud:SetParent(self)
            cloud.NoIgnite = self
        end
        self:EmitSound(Sound("kraken/explosives/dioxis/start" .. math.random(1,4) .. ".wav"), 120, 100, 0.3, CHAN_AUTO )
	ParticleEffectAttach("AC_nade_gas_ejection", PATTACH_POINT_FOLLOW, self, 0)
    
    timer.Simple(18, function()
        if IsValid(self) then
            self:Remove()
        end
    end)
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_plasma.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_plasma.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "Plasma Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_DEBRIS

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_plasmagrenade.mdl"
ENT.FuseTime = 0.1
ENT.TrailColor = Color(35, 202, 228)
ENT.TrailTexture = "sprites/bluelaser1"

ENT.BlastDamage = {
    [0] = 100,
    [1] = 300,
    [2] = 100,
}

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:SetPhysicsAttacker(self:GetOwner(), 10)

        util.PrecacheSound("kraken/explosives/ion/beep.wav")
        self:EmitSound("kraken/explosives/ion/beep.wav", 90, 100, 1, CHAN_AUTO)
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))

            local tgt = data.HitEntity
            if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)
                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end
        elseif data.Speed > 25 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))
        end

    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "cryo_explosion_large" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            self:EmitSound("kraken/explosives/ion/close" .. math.random(1,3) .. ".wav", 90, 100, 1, CHAN_AUTO)
            self:EmitSound("kraken/explosives/ion/interior" .. math.random(1,3) ..  ".wav", 120, 100, 1, CHAN_AUTO)

            util.ScreenShake(self:GetPos(), 25, 4, 1, self.Radius * 4)
            self:EmitSound("ArcCW_Kraken.Explosives.Explosion")

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 420)) do
           
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_DISSOLVE)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(400 * f)
            dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
        end
        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 30))
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_shock.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "Shock Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_DEBRIS

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_grenade_shock.mdl"
ENT.FuseTime = 2

ENT.BlastDamage = {
    [0] = 100,
    [1] = 300,
    [2] = 100,
}

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:SetPhysicsAttacker(self:GetOwner(), 10)

        util.PrecacheSound("kraken/explosives/shock/beep.wav")
        self:EmitSound("kraken/explosives/shock/beep.wav")
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))

            local tgt = data.HitEntity
            if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)
                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end
        elseif data.Speed > 25 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))
        end
        if data.Speed < 15 then
            self:SetMoveType(MOVETYPE_NONE)
            self:EmitSound(Sound("kraken/explosives/shock/charge.wav"))
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "tfa_apex_arcstar_explode" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            self:EmitSound("ArcCW_Kraken.Explosives.Explosion", 120, 100, 1, CHAN_AUTO)
            
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 300)) do
            
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_SHOCK)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(190 * f)
            dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
            
        end
        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 30))
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_smoke/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_stun/shared.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "Stun Grenade"
ENT.Spawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE
ENT.Model = "models/arccw/kraken/sw/explosives/world/w_grenade_base.mdl"
ENT.PhysBoxSize = false
ENT.SphereSize = true
ENT.PhysMat = "grenade"
ENT.LifeTime = 1.5
ENT.Radius = 500
ENT.SmokeTrail = true

local BLUR_DURATION = 15
local BaseClass = baseclass.Get(ENT.Base)

local function isCowerSupportedForNPC(npc)
    for _, a in pairs(npc:GetSequenceList()) do
        if (npc:GetSequenceActivity(npc:LookupSequence(a)) == ACT_COWER) then
            return true
        end
    end

    return false
end

local lethalToNpcs = {
"npc_barnacle","npc_crow","npc_pigeon","npc_seagull","npc_zombie","npc_fastzombie","npc_zombie_torso","npc_zombine","npc_headcrab","npc_headcrab_black","npc_headcrab_fast","npc_headcrab_fast","npc_lambdaplayer",}

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:DrawShadow( true )
		
        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        util.PrecacheSound("kraken/explosives/shock/beep.wav")
        self:EmitSound("kraken/explosives/shock/beep.wav", 90, 100, 1, CHAN_AUTO)

        self.SpawnTime = CurTime()

        timer.Simple(0, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        end)
		sound.EmitHint(SOUND_DANGER, self:GetPos(), 200, 8, nil) --make shit run away (nil owner so even rebels run)
    end
	ParticleEffectAttach("grenadetrail", PATTACH_ABSORIGIN_FOLLOW, self, 0)
end

function ENT:PhysicsCollide(data)
   if data.Speed > 100 then
      local tgt = data.HitEntity

      if IsValid(tgt) and (self.NextHit or 0) < CurTime() then
         self.NextHit = CurTime() + 0.1
         local dmginfo = DamageInfo()
         dmginfo:SetDamageType(DMG_CLUB)
         dmginfo:SetDamage(5)
         dmginfo:SetAttacker(self:GetOwner())
         dmginfo:SetInflictor(self)
         dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
         tgt:TakeDamageInfo(dmginfo)

         if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
           local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity

         timer.Simple(0, function()
           if IsValid(self) then
              self:SetAngles(ang)
              self:SetPos(pos)
              self:GetPhysicsObject():SetVelocityInstantaneous(vel)
           end
         end)
      end
   end
end
		
if data.Speed > 100 then
    self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"), 75, 100, 0.6, CHAN_AUTO)
    elseif data.Speed > 75 then
        self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"), 75, 100, 0.6, CHAN_AUTO)
    elseif data.Speed > 50 then
        self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"), 75, 100, 0.6, CHAN_AUTO)
end

end

function ENT:Detonate()
    if not self:IsValid() then return end
    if self.Defused then return end
    if self:WaterLevel() > 0 then
        local tr = util.TraceLine({
            start = self:GetPos(),
            endpos = self:GetPos() + Vector(0, 0, 1) * 1024,
            filter = self,
        })
        local tr2 = util.TraceLine({
            start = tr.HitPos,
            endpos = self:GetPos(),
            filter = self,
            mask = MASK_WATER
        })
        ParticleEffect("explosion_water", tr2.HitPos + Vector(0, 0, 8), Angle(0, 0, 0), nil)

        self:EmitSound("weapons/underwater_explode3.wav", 100)
    else
        ParticleEffect("Generic_explo_flash", self:GetPos(), Angle(0, 0, 0), nil)
        self:EmitSound("ArcCW_Kraken.Explosives.Explosion", 120, 100, 1, CHAN_AUTO)
    end
	
    util.BlastDamage(self, IsValid(self:GetOwner()) and self:GetOwner() or self, self:GetPos(), self.Radius, 32)
    util.ScreenShake(self:GetPos(), 25, 4, 0.75, self.Radius * 4)
    local owner = self:GetOwner()

    for _, e in pairs(ents.FindInSphere(self:GetPos(), self.Radius)) do
        if ((e:IsPlayer() || e:IsNPC()) && !e:IsLineOfSightClear(self:GetPos())) then
            continue
        end
        if (e:IsNPC()) then
            e:StartEngineTask(89, 0) --task_sound_pain

            if (isCowerSupportedForNPC(e)) then
                e:SetSchedule(SCHED_COWER)
            else
                if (table.HasValue(lethalToNpcs, e:GetClass())) then
                    e:TakeDamage(e:Health(), self:GetOwner(), self || nil)
                end
            end
            continue
        end
    end
	
    for _, ply in pairs(ents.FindInSphere(self:GetPos(), self.Radius)) do
        if (ply:IsPlayer()) then
            self:ApplyBlurEffect(ply)
        end
    end
	
    if SERVER then
        local dir = self.HitVelocity or self:GetVelocity()

        if self.Boost <= 0 then
            dir = Vector(0, 0, -1)
        end

        self:FireBullets({
            Attacker = self,
            Damage = 0,
            Tracer = 0,
            Distance = 256,
            Dir = dir,
            Src = self:GetPos(),
            Callback = function(att, tr, dmg)
                if self.Scorch then
                    util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
                end
            end
        })
    end

    sound.EmitHint(SOUND_DANGER, self:GetPos(), self.Radius, 6, nil) --needed for task (make them blinded for a little longer)
    self:Remove()
end

function ENT:ApplyBlurEffect(ply)
    if SERVER then
        net.Start("BlurEffect")
        net.WriteFloat(BLUR_DURATION)
        net.Send(ply)
    end
end

if CLIENT then

    local colorModify = {
        ["$pp_colour_addr"] = 0,
        ["$pp_colour_addg"] = 0,
        ["$pp_colour_addb"] = 0,
        ["$pp_colour_brightness"] = 0,
        ["$pp_colour_contrast"] = 1,
        ["$pp_colour_colour"] = 1,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    }

    net.Receive("BlurEffect", function()
        local duration = net.ReadFloat()
        local endTime = CurTime() + duration
        
        hook.Add("RenderScreenspaceEffects", "BlurEffect", function()
            local timeLeft = endTime - CurTime()
            if timeLeft <= 0 then
                hook.Remove("RenderScreenspaceEffects", "BlurEffect")
                return
            end
            
            local fraction = timeLeft / duration
            DrawMotionBlur(0.4, fraction, 0.05)
            -- Apply color modify
            local colorFraction = fraction * 1 -- Adjust this multiplier to control color intensity
            colorModify["$pp_colour_brightness"] = -colorFraction * 0.5 -- Darken the screen
            colorModify["$pp_colour_colour"] = 1 - colorFraction * 0.1 -- Reduce color saturation
            DrawColorModify(colorModify)
			
            -- Apply bloom effect
            local bloomParams = {
                darken = 0.5 * fraction,
                multiply = 0.5 * fraction,
                sizex = 4,
                sizey = 4,
                passes = 2,
                colour = 2 * fraction,
            }
            DrawBloom(bloomParams.darken, bloomParams.multiply, bloomParams.sizex, bloomParams.sizey, bloomParams.passes, bloomParams.colour, 1, 1, 1)
        end)
    end)
end

if SERVER then
    util.AddNetworkString("BlurEffect")
end
--PATH lua/entities/nmg_eksoan_class_4ts_power_gen/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_droideka_droid_swrc/shared.lua:
ENT.Base 			= "npc_vj_creature_base" -- List of all base types: https://github.com/DrVrej/VJ-Base/wiki/Base-Types
ENT.Type 			= "ai"
ENT.PrintName 		= ""
ENT.Author 			= "Orion, Sirius, Zmaj"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "NPC/SNPC Battles or any other things"
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "[HC] NPC's"

if (CLIENT) then
	local Name = ""
	local LangName = "npc_vj_vulture"
	language.Add(LangName, Name)
	killicon.Add(LangName,"",Color(255,0,0,0))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"",Color(255,0,0,0))
end
--PATH lua/entities/npc_vj_human_base/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_human_base/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
ENT.Base 			= "base_entity"
ENT.Type 			= "ai"
ENT.PrintName 		= "VJ Human SNPC Base"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "To make SNPCs."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.AutomaticFrameAdvance = false

ENT.IsVJBaseSNPC = true -- Is it a VJ Base SNPC?
ENT.IsVJBaseSNPC_Human = true -- Is it a VJ Base human?
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:SetAutomaticFrameAdvance(val)
	self.AutomaticFrameAdvance = val
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:MatFootStepQCEvent(data)
	-- Return true to apply all changes done to the data table.
	-- Return false to prevent the sound from playing.
	-- Return nil or nothing to play the sound without altering it.
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	//ENT.RenderGroup = RENDERGROUP_BOTH
	function ENT:Initialize() end
	function ENT:Draw() self:DrawModel() self:CustomOnDraw() end
	function ENT:DrawTranslucent() self:Draw() end
	function ENT:BuildBonePositions(NumBones,NumPhysBones) end
	function ENT:SetRagdollBones(bIn) self.m_bRagdollSetup = bIn end
	function ENT:DoRagdollBone(PhysBoneNum,BoneNum) /*self:SetBonePosition(BoneNum,Pos,Angle)*/ end
	//function ENT:CalcAbsolutePosition(pos, ang) end
	-- Custom functions ---------------------------------------------------------------------------------------------------------------------------------------------
	function ENT:CustomOnDraw() end
end
--PATH lua/entities/npc_vj_magna_guard_swrc/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_sbdnew2/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_tank_base/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
ENT.Base 			= "npc_vj_creature_base"
ENT.Type 			= "ai"
ENT.PrintName 		= "VJ Tank Base"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "To make SNPCs."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.IsVJBaseSNPC_Tank = true -- Is it a VJ Base tank SNPC?
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:PhysicsCollide(data, physobj)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:PhysicsUpdate(physobj)
end
--PATH lua/entities/npc_vj_tridroid/shared.lua:
ENT.Base 			= "npc_vj_creature_base"
ENT.Type 			= "ai"
ENT.PrintName 		= "Tri Droid"
ENT.Author 			= "Mayhem - zhinged"
ENT.Contact 		= "http://vrejgaming.webs.com/"
ENT.Purpose 		= ""
ENT.Instructions	= "Click on it to spawn it."
ENT.Category		= "MGR"

if (CLIENT) then
local Name = "Tri Droid"
local LangName = "npc_vj_tridroid"
language.Add(LangName, Name)
killicon.Add(LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
language.Add("#"..LangName, Name)
killicon.Add("#"..LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
end
--PATH lua/entities/npc_vj_tridroidgun/shared.lua:
ENT.Base 			= "npc_vj_creature_base"
ENT.Type 			= "ai"
ENT.PrintName 		= "Tri Droidgun"
ENT.Author 			= "Mayhem - zhinged"
ENT.Contact 		= "http://vrejgaming.webs.com/"
ENT.Purpose 		= ""
ENT.Instructions	= "Click on it to spawn it."
ENT.Category		= "MGR"

if (CLIENT) then
local Name = "Tri Droid"
local LangName = "npc_vj_tridroidgun"
language.Add(LangName, Name)
killicon.Add(LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
language.Add("#"..LangName, Name)
killicon.Add("#"..LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
end
--PATH lua/entities/obj_vj_combineball.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()

ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Combine Ball"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "Projectiles"

ENT.VJ_IsDetectableDanger = true

if CLIENT then
	local Name = "Combine Ball"
	local LangName = "obj_vj_combineball"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))

	function ENT:Draw()
		self:DrawModel()
		self:SetAngles((LocalPlayer():EyePos() - self:GetPos()):Angle())
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.Model = {"models/effects/combineball.mdl"} -- The models it should spawn with | Picks a random one from the table
ENT.MoveCollideType = MOVECOLLIDE_FLY_BOUNCE
ENT.RemoveOnHit = false -- Should it remove itself when it touches something? | It will run the hit sound, place a decal, etc.
ENT.DoesDirectDamage = false -- Should it do a direct damage when it hits something?
ENT.DirectDamage = 200 -- How much damage should it do when it hits something
ENT.DirectDamageType = bit.bor(DMG_DISSOLVE, DMG_BLAST, DMG_SHOCK) -- Damage type
ENT.CollideCodeWithoutRemoving = true -- If RemoveOnHit is set to false, you can still make the projectile deal damage, place a decal, etc.
ENT.DecalTbl_DeathDecals = {"Scorch"}
ENT.SoundTbl_Idle = {"weapons/physcannon/energy_sing_loop4.wav"}
ENT.SoundTbl_OnCollide = {"weapons/physcannon/energy_bounce1.wav","weapons/physcannon/energy_bounce2.wav"}

ENT.IdleSoundPitch = VJ_Set(100, 100)
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomPhysicsObjectOnInitialize(phys)
	phys:Wake()
	phys:SetMass(1)
	phys:SetBuoyancyRatio(0)
	phys:EnableDrag(false)
	phys:EnableGravity(false)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnInitializeBeforePhys()
	self:PhysicsInitSphere(1, "metal_bouncy")
	construct.SetPhysProp(self:GetOwner(), self, 0, self:GetPhysicsObject(), {GravityToggle = false, Material = "metal_bouncy"})
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:SetCoreType(capture)
	if capture then
		self:SetSubMaterial(0, "models/effects/comball_glow1")
	else
		self:SetSubMaterial(0, "vj_base/effects/comball_glow2")
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
local colorWhite = Color(255, 255, 255, 255)
--
function ENT:CustomOnInitialize()
	timer.Simple(5, function() if IsValid(self) then self:DeathEffects() end end)

	self:DrawShadow(false)
	self:ResetSequence("idle")
	self:SetCoreType(false)

	util.SpriteTrail(self, 0, colorWhite, true, 15, 0, 0.1, 1 / 6 * 0.5, "sprites/combineball_trail_black_1.vmt")

	hook.Add("GravGunOnPickedUp", self, function(self, ply, ent)
		self:SetCoreType(true)
	end)

	hook.Add("GravGunOnDropped", self, function(ply, ent)
		self:SetCoreType(false)
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnBounce(data, phys)
	local myPos = self:GetPos()
	local owner = self:GetOwner()
	local newVel = phys:GetVelocity():GetNormal()
	local lastVel = math.max(newVel:Length(), math.max(data.OurOldVelocity:Length(), data.Speed)) -- Get the last velocity and speed
	-- phys:SetVelocity(newVel * lastVel * 0.985) -- Sometimes this could get the combine ball stuck in certain brushes, disabling it just because it looks better without it tbh

	if !IsValid(owner) then return end
	local closestDist = 1024
	local target = NULL
	for _, v in ipairs(ents.FindInSphere(myPos, 1024)) do
		if v == owner then continue end
		if (!v:IsNPC() && !v:IsPlayer()) then continue end
		if owner:IsNPC() && owner:CheckRelationship(v) == D_LI then continue end
		local dist = v:GetPos():Distance(myPos)
		if dist < closestDist && dist > 20 then
			closestDist = dist
			target = v
		end
	end
	
	if IsValid(target) then
		local targetPos = target:GetPos() + target:OBBCenter()
		local norm = (targetPos - myPos):GetNormalized()
		if self:GetForward():DotProduct(norm) < 0.75 then -- Lowered the visual range from 0.95, too accurate
			phys:SetVelocity(norm * lastVel)
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnPhysicsCollide(data, phys)
	local owner = self:GetOwner()
	local hitEnt = data.HitEntity
	if IsValid(owner) then
		if (VJ_IsProp(hitEnt)) or (owner:IsNPC() && owner:CheckRelationship(hitEnt) == D_HT && (hitEnt != owner) or true) then
			self:CustomOnDoDamage_Direct(data, phys, hitEnt)
			local dmgInfo = DamageInfo()
			dmgInfo:SetDamage(self.DirectDamage)
			dmgInfo:SetDamageType(self.DirectDamageType)
			dmgInfo:SetAttacker(owner)
			dmgInfo:SetInflictor(self)
			dmgInfo:SetDamagePosition(data.HitPos)
			hitEnt:TakeDamageInfo(dmgInfo, self)
			VJ_DestroyCombineTurret(owner, hitEnt)
		end
	else
		self:CustomOnDoDamage_Direct(data, phys, hitEnt)
		local dmgInfo = DamageInfo()
		dmgInfo:SetDamage(self.DirectDamage)
		dmgInfo:SetDamageType(self.DirectDamageType)
		dmgInfo:SetAttacker(self)
		dmgInfo:SetInflictor(self)
		dmgInfo:SetDamagePosition(data.HitPos)
		hitEnt:TakeDamageInfo(dmgInfo, self)
		VJ_DestroyCombineTurret(self, hitEnt)
	end

	if (hitEnt:IsNPC() or hitEnt:IsPlayer()) then return end
	
	self:OnBounce(data,phys)

	local dataF = EffectData()
	dataF:SetOrigin(data.HitPos)
	util.Effect("cball_bounce", dataF)

	dataF = EffectData()
	dataF:SetOrigin(data.HitPos)
	dataF:SetNormal(data.HitNormal)
	dataF:SetScale(50)
	util.Effect("AR2Impact", dataF)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:GravGunPunt(ply)
	self:SetCoreType(false)
	self:GetPhysicsObject():EnableMotion(true)
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
local sdHit = {"weapons/physcannon/energy_disintegrate4.wav", "weapons/physcannon/energy_disintegrate5.wav"}
--
function ENT:CustomOnDoDamage_Direct(data, phys, hitEnt)
	VJ_CreateSound(hitEnt, VJ_PICK(sdHit), 80)
end
---------------------------------------------------------------------------------------------------------------------------------------------
local color1 = Color(255, 255, 225, 32)
local color2 = Color(255, 255, 225, 64)
--
function ENT:DeathEffects(data, phys)
	local myPos = self:GetPos()
	effects.BeamRingPoint(myPos, 0.2, 12, 1024, 64, 0, color1, {material="sprites/lgtning.vmt", framerate=2, flags=0, speed=0, delay=0, spread=0})
	effects.BeamRingPoint(myPos, 0.5, 12, 1024, 64, 0, color2, {material="sprites/lgtning.vmt", framerate=2, flags=0, speed=0, delay=0, spread=0})

	local effectData = EffectData()
	effectData:SetOrigin(myPos)
	util.Effect("cball_explode", effectData)

	VJ_EmitSound(self, "weapons/physcannon/energy_sing_explosion2.wav", 150)
	util.ScreenShake(myPos, 20, 150, 1, 1250)
	util.VJ_SphereDamage(self, self, myPos, 400, 25, bit.bor(DMG_SONIC, DMG_BLAST), true, true, {DisableVisibilityCheck=true, Force=80})

	self:Remove()
end
--PATH lua/entities/obj_vj_sbdshoot.lua:
return gluapack()()
--PATH lua/entities/obj_vj_tank_shell.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Tank Shell"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "Projectiles"

ENT.VJ_IsDetectableDanger = true

---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local Name = "Tank Shell"
	local LangName = "obj_vj_tank_shell"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))

	function ENT:Think()
		/*if self:IsValid() then
			self.Emitter = ParticleEmitter(self:GetPos())
			self.SmokeEffect1 = self.Emitter:Add("particles/flamelet2",self:GetPos() +self:GetForward()*-7)
			self.SmokeEffect1:SetVelocity(self:GetForward() *math.Rand(0, -50) +Vector(math.Rand(5, -5), math.Rand(5, -5), math.Rand(5, -5)) +self:GetVelocity())
			self.SmokeEffect1:SetDieTime(0.2)
			self.SmokeEffect1:SetStartAlpha(100)
			self.SmokeEffect1:SetEndAlpha(0)
			self.SmokeEffect1:SetStartSize(10)
			self.SmokeEffect1:SetEndSize(1)
			self.SmokeEffect1:SetRoll(math.Rand(-0.2,0.2))
			self.SmokeEffect1:SetAirResistance(200)
			self.Emitter:Finish()
		end*/
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.Model = {"models/weapons/w_missile_launch.mdl"} -- The models it should spawn with | Picks a random one from the table
ENT.DoesRadiusDamage = true -- Should it do a blast damage when it hits something?
ENT.RadiusDamageRadius = 250 -- How far the damage go? The farther away it's from its enemy, the less damage it will do | Counted in world units
ENT.RadiusDamage = 110 -- How much damage should it deal? Remember this is a radius damage, therefore it will do less damage the farther away the entity is from its enemy
ENT.RadiusDamageUseRealisticRadius = true -- Should the damage decrease the farther away the enemy is from the position that the projectile hit?
ENT.RadiusDamageType = DMG_BLAST -- Damage type
ENT.RadiusDamageForce = 90 -- Put the force amount it should apply | false = Don't apply any force
ENT.DecalTbl_DeathDecals = {"Scorch"}
ENT.SoundTbl_Idle = {"weapons/rpg/rocket1.wav"}
ENT.SoundTbl_OnCollide = {"ambient/explosions/explode_8.wav"}
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnInitialize()
	//util.SpriteTrail(self, 0, Color(90,90,90,255), false, 10, 1, 3, 1/(15+1)*0.5, "trails/smoke.vmt")
	ParticleEffectAttach("vj_rpg1_fulltrail", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	ParticleEffectAttach("vj_rpg2_fulltrail", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	//ParticleEffectAttach("vj_rpg2_smoke2", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	//ParticleEffectAttach("rocket_smoke", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	//ParticleEffectAttach("smoke_burning_engine_01", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	
	/*self.StartLight1 = ents.Create("light_dynamic")
	self.StartLight1:SetKeyValue("brightness", "1")
	self.StartLight1:SetKeyValue("distance", "200")
	self.StartLight1:SetLocalPos(self:GetPos())
	self.StartLight1:SetLocalAngles( self:GetAngles() )
	self.StartLight1:Fire("Color", "255 150 0")
	self.StartLight1:SetParent(self)
	self.StartLight1:Spawn()
	self.StartLight1:Activate()
	self.StartLight1:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(self.StartLight1)*/
end
---------------------------------------------------------------------------------------------------------------------------------------------
local defAngle = Angle(0, 0, 0)
--
function ENT:DeathEffects(data, phys)
	util.ScreenShake(data.HitPos, 16, 200, 1, 3000)
	ParticleEffect("vj_explosion3", self:GetPos(), defAngle, nil)
	
	local effectData = EffectData()
	effectData:SetOrigin(data.HitPos)
	//effectData:SetScale(500)
	//util.Effect("HelicopterMegaBomb", effectData)
	//util.Effect("ThumperDust", effectData)
	util.Effect("Explosion", effectData)
	//util.Effect("VJ_Small_Explosion1", effectData)

	local expLight = ents.Create("light_dynamic")
	expLight:SetKeyValue("brightness", "4")
	expLight:SetKeyValue("distance", "300")
	expLight:SetLocalPos(data.HitPos)
	expLight:SetLocalAngles(self:GetAngles())
	expLight:Fire("Color", "255 150 0")
	expLight:SetParent(self)
	expLight:Spawn()
	expLight:Activate()
	expLight:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(expLight)
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_chair/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_npc/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	-- To prevent some weird issue where the animation was going crazy
	self:SetSequence(self:LookupSequence("idle_subtle"))

	self.hasInitialized = true
end


function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end

	surface.SetFont("pCasino.Entity.Arrows")
	self.textWidth = surface.GetTextSize(self.data.text.overhead)
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local black = Color(0, 0, 0, 155)
local white = Color(255, 255, 255, 100)
local gold = Color(255, 200, 0, 100)
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 200000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	if (not self.data.text.overhead) or (self.data.text.overhead == " ") then return end

	local ang = LocalPlayer():EyeAngles()
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(self:GetPos()+self:GetUp()*78, ang, 0.07)
		-- Previous bet step
		surface_setdrawcolor(black)
		surface_drawrect(-(self.textWidth + 10)*0.5, 5, self.textWidth + 10, 65)
		-- Border
		surface_setdrawcolor(white)
		surface_drawrect(-(self.textWidth + 20)*0.5, 0, self.textWidth + 20, 5)
		surface_drawrect(-(self.textWidth + 20)*0.5, 5, 5, 65)
		surface_drawrect((self.textWidth*0.5) + 5, 5, 5, 65)
		surface_drawrect(-(self.textWidth + 20)*0.5, 70, self.textWidth+20, 5)
		-- Text
		draw_simpletext(self.data.text.overhead, "pCasino.Entity.Arrows", 0, 35, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_prize_plinth/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_prize_plinth/cl_init.lua:
include("shared.lua")

function ENT:PostData()
	self.item = ClientsideModel(self.data.general.model)
	self.item:SetParent(self)
	self.item:SetPos(self:GetPos() + (self:GetUp() * 5))
	self.item:SetAngles(self:GetAngles())

	if self.data.general.bow then
		self.item.bow = ClientsideModel("models/freeman/owain_giantbow.mdl")
		self.item.bow:SetParent(self.item)
		local boundMin, boundMax = self.item:GetModelRenderBounds()
		self.item.bow:SetPos(self.item:GetPos() + Vector(0, 0, boundMax[3] + 8 + (self.data.general.bowOffset or 0)))
		self.item.bow:SetAngles(self.item:GetAngles())
	end
end

function ENT:Think()
	if not IsValid(self.item) then return end

	if not (self:GetBoneMatrix(1)) then return end
	
	local ang = self:GetBoneMatrix(1):GetAngles()
	ang:RotateAroundAxis(ang:Right(), -90)
	self.item:SetAngles(ang)
end

function ENT:OnRemove()

	if IsValid(self.item) then
		self.item:Remove()
		
		if IsValid(self.item.bow) then
			self.item.bow:Remove()
		end
	end

end

function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_roulette_table/cl_init.lua:
include("shared.lua")


function ENT:Initialize()
	self.currentBid = 0
	self.active = false
	self.currentBets = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end

	self.currentBid = self.data.bet.default
	self:GetCurrentPad(Vector(0, 0, 0)) -- To force generate the cache
end
function ENT:OnRemove()
	self:ClearBets()
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local black = Color(0, 0, 0, 155)
local white = Color(255, 255, 255, 100)
local gold = Color(255, 200, 0, 100)
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end


	local pos = self:GetPos()
	local ang = self:GetAngles()
	
	ang:RotateAroundAxis(ang:Up(), -90)

	cam.Start3D2D(pos + (ang:Up()*14.7) + (ang:Right()*20) + (ang:Forward()*-15.5), ang, 0.05)
		local button = self:GetCurrentPad(self:WorldToLocal(LocalPlayer():GetEyeTrace().HitPos))


		-- Bet limit
		if self.data.bet.betLimit and not (tonumber(self.data.bet.betLimit) == 0) then
			surface_setdrawcolor(black)
			surface_drawrect(5, -80, 410, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(0, -85, 420, 5)
			surface_drawrect(0, -80, 5, 65)
			surface_drawrect(415, -80, 5, 65)
			surface_drawrect(0, -15, 420, 5)
			-- Bet limit text
			draw_simpletext(string.format(PerfectCasino.Translation.UI.BetLimit, PerfectCasino.Config.FormatMoney(self.data.bet.betLimit)), "pCasino.Entity.Bid", 215, -47, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	
		-- Previous bet step
		surface_setdrawcolor(black)
		surface_drawrect(5, 5, 90, 65)
		-- Border
		surface_setdrawcolor(button == "bet_lower" and gold or white)
		surface_drawrect(0, 0, 100, 5)
		surface_drawrect(0, 5, 5, 65)
		surface_drawrect(95, 5, 5, 65)
		surface_drawrect(0, 70, 100, 5)
		-- Left arrow
		draw_simpletext("<", "pCasino.Entity.Arrows", 50, 35, button == "bet_lower" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		-- Current bet
		surface_setdrawcolor(black)
		surface_drawrect(115, 5, 190, 65)
		-- Border
		surface_setdrawcolor(white)
		surface_drawrect(110, 0, 200, 5)
		surface_drawrect(110, 5, 5, 65)
		surface_drawrect(305, 5, 5, 65)
		surface_drawrect(110, 70, 200, 5)
		-- Current Bid
		draw_simpletext(PerfectCasino.Config.FormatMoney(self.currentBid), "pCasino.Entity.Bid", 215, 37, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		-- Next bet step
		-- Box
		surface_setdrawcolor(black)
		surface_drawrect(325, 5, 90, 65)
		-- Border
		surface_setdrawcolor(button == "bet_raise" and gold or white)
		surface_drawrect(320, 0, 100, 5)
		surface_drawrect(320, 5, 5, 65)
		surface_drawrect(415, 5, 5, 65)
		surface_drawrect(320, 70, 100, 5)
		-- Right arrow
		draw_simpletext(">", "pCasino.Entity.Arrows", 370, 35, button == "bet_raise" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()

	if (not (self:GetStartRoundIn() == -1)) or (self:GetLastRoundNumber() >= 0) then
		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), 90)
		cam.Start3D2D(pos + (ang:Up()*-20.3) + (ang:Right()*-21.3) + (ang:Forward()*-15), ang, 0.05)
			
			-- Previous bet step
			surface_setdrawcolor(black)
			surface_drawrect(5, 5, 190, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(0, 0, 200, 5)
			surface_drawrect(0, 5, 5, 65)
			surface_drawrect(195, 5, 5, 65)
			surface_drawrect(0, 70, 200, 5)

			local text = (not (self:GetStartRoundIn() == -1)) and string.format(PerfectCasino.Translation.UI.Start, self.data.general.betPeriod - (os.time() - self:GetStartRoundIn())) or string.format(PerfectCasino.Translation.UI.Number, self:GetLastRoundNumber())
			draw_simpletext(text, "pCasino.Entity.Bid", 100, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		cam.End3D2D()
	end

end

local tempStack = {}
local lastPad = false

local function clearTempStack()
	for k, v in pairs(tempStack) do
		if not IsValid(v) then continue end
		v:Remove()
	end
	tempStack = {}
end

function ENT:Think()
	if self.active then return end
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	local pos = self:WorldToLocal(LocalPlayer():GetEyeTrace().HitPos)
	local curPad, padData = self:GetCurrentPad(pos)

	if (not curPad) or (curPad == "bet_raise") or (curPad == "bet_lower") then
		lastPad = curPad
		if not table.IsEmpty(tempStack) then
			clearTempStack()
		end
		return
	end -- Don't do anything if it's not a bet pad

	if not (curPad == lastPad) then
		clearTempStack()
	end
	lastPad = curPad

	if table.IsEmpty(tempStack) then
		local chips = PerfectCasino.Chips:GetFromNumber(self.currentBid)
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 90)

		for k=#PerfectCasino.Chips.Types, 0, -1 do -- Run it in reverse, putting the highest chips at the bottom
			if not chips[k] then continue end
			for i=1, chips[k] do
				local plaque = k >= 11 -- There are 11 normal skins, so anything over 10 (11-1, due to skins starting at 0) we use the big plaque models

				local chip = ClientsideModel(plaque and "models/freeman/owain_casino_plaque.mdl" or "models/freeman/owain_casino_chip.mdl")
				table.insert(tempStack, chip)
				chip:SetParent(self)
				chip:SetSkin(plaque and k-11 or k)
				chip:SetPos(self:LocalToWorld(Vector(padData.origin.x, padData.origin.y, 14.8+((#tempStack+(self.currentBets[curPad] and #self.currentBets[curPad] or 0))*0.3))))
				chip:SetAngles(ang)
			end
		end
	else
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), CurTime()*30%360)
		for k, v in pairs(tempStack) do
			v:SetAngles(ang)
		end
	end
end

-- Chip code
function ENT:AddBet(pad, amount)
	local padName, padData = self:GetPadByName(pad)
	if not padName then return end

	self.currentBets[padName] = self.currentBets[padName] or {}

	local chips = PerfectCasino.Chips:GetFromNumber(amount)
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Up(), 90)
	for k=#PerfectCasino.Chips.Types, 0, -1 do -- Run it in reverse, putting the highest chips at the bottom
		if not chips[k] then continue end
		for i=1, chips[k] do
			local plaque = k >= 11 -- There are 11 normal skins, so anything over 10 (11-1, due to skins starting at 0) we use the big plaque models

			local chip = ClientsideModel(plaque and "models/freeman/owain_casino_plaque.mdl" or "models/freeman/owain_casino_chip.mdl")
			table.insert(self.currentBets[padName], chip)
			chip:SetParent(self)
			chip:SetSkin(plaque and k-11 or k)
			chip:SetPos(self:LocalToWorld(Vector(padData.origin.x, padData.origin.y, 14.5+(#self.currentBets[padName]*0.3))))
			chip:SetAngles(ang)
		end
	end

	clearTempStack() -- To update the hight to have over the new stack
end
function ENT:ClearBets()
	for _, pad in pairs(self.currentBets) do
		for k, v in pairs(pad) do
			v:Remove()
		end
	end

	self.currentBets = {}
end

function ENT:OnRemove()
	-- Clear the board of last rounds best
	for k, v in pairs(self.currentBets) do
		if not IsValid(v) then continue end

		v:Remove()
	end
	
	clearTempStack()
end


net.Receive("pCasino:Roulette:Bet:Change", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end

	local newBet = net.ReadUInt(32)
	entity.currentBid = newBet
end)

net.Receive("pCasino:Roulette:Bet:Place", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100000 then return end

	local pad = net.ReadString()
	local betAmount = net.ReadUInt(32)


	entity:AddBet(pad, betAmount)
end)
net.Receive("pCasino:Roulette:Bet:Clear", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end

	entity:ClearBets()
end)
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_stand/shared.lua:
return gluapack()()
--PATH lua/entities/pfx1_02.lua:
return gluapack()()
--PATH lua/entities/pfx1_07.lua:
return gluapack()()
--PATH lua/entities/pfx1_08_l.lua:
return gluapack()()
--PATH lua/entities/pfx1_0b.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Candle flame"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]candle_flame"
--PATH lua/entities/pfx2_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Sparkle 2"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]sparkle2"



--PATH lua/entities/pfx2_02_s.lua:
return gluapack()()
--PATH lua/entities/pfx4_01~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Blue Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_b*"

--PATH lua/entities/pfx4_02_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Red Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_r_s"
--PATH lua/entities/pfx4_04.lua:
return gluapack()()
--PATH lua/entities/pfx4_04_s~.lua:
return gluapack()()
--PATH lua/entities/pfx4_09.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Matrix Core"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]matrix_core"
--PATH lua/entities/pfx4_0a.lua:
return gluapack()()
--PATH lua/entities/pfx4_0b.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Matrix Sphere"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]binary_sphere"
--PATH lua/entities/pfx5_00_alt_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Small Alt Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_micro_b"
--PATH lua/entities/pfx7_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Rain"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]rain"
--PATH lua/entities/pfx7_02.lua:
return gluapack()()
--PATH lua/entities/pfx7_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Snow"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]snow"
--PATH lua/entities/pfx7_05.lua:
return gluapack()()
--PATH lua/entities/pfx7_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Blizzard [Moderate]"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]blizzard_mod"
--PATH lua/entities/pfx8_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Magic Flame 2"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]magic_flame"
--PATH lua/entities/pfx8_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Blue Portal"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]magic_portal"
--PATH lua/entities/pfx8_05.lua:
return gluapack()()
--PATH lua/entities/portals_in.lua:
return gluapack()()
--PATH lua/entities/portals_out.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_ap.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_ap.lua:
ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "AP Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable 			= false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 4.5

if SERVER then

function ENT:Initialize()
    local pb_vert = 1
    local pb_hor = 1
    self:SetModel(self.Model)
    self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

    local phys = self:GetPhysicsObject()
    if phys:IsValid() then
        phys:Wake()
        phys:EnableGravity(false)
    end

    self.SpawnTime = CurTime()
    self.motorsound = CreateSound( self, "weapons/rpg/rocket1.wav")
    self.motorsound:Play()

    timer.Simple(0.1, function()
        if !IsValid(self) then return end
        self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
    end)
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:OnRemove()
    self.motorsound:Stop()
end

end

function ENT:Think()
    if SERVER then
        local phys = self:GetPhysicsObject()
        phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )

        if self.SpawnTime + self.FuseTime <= CurTime() then
            self:Detonate()
        end
    else
        if self.Ticks % 5 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
end

function ENT:Detonate()
    if !self:IsValid() then return end
    local effectdata = EffectData()
        effectdata:SetOrigin( self:GetPos() )

    if self:WaterLevel() >= 1 then
        util.Effect( "WaterSurfaceExplosion", effectdata )
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        util.Effect( "Explosion", effectdata)
        self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
    end

    local attacker = self

    if self.Owner:IsValid() then
        attacker = self.Owner
    end

    util.BlastDamage(self, attacker, self:GetPos(), 64, 1500)

    self:FireBullets({
        Attacker = attacker,
        Damage = 0,
        Tracer = 0,
        Distance = 20000,
        Dir = self:GetVelocity(),
        Src = self:GetPos(),
        Callback = function(att, tr, dmg)
            util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
        end
    })

    for k, v in pairs(ents.FindInSphere(self:GetPos(), 32)) do
        if IsValid(v) and (v.LFS or v.LVS) then
            if v.LFS then
                v:StopEngine()
                v:SetShield(0)
                v:SetHP( v:GetHP()/ 10 )
            end
            if v.LVS then
                v:StopEngine()
                v:SetShield(0)
                v:SetHP( v:GetHP()/ 10 )
            end
        end
    end

    self:Remove()
end

function ENT:PhysicsCollide(colData, collider)
    self:Detonate()
end

function ENT:Draw()
    cam.Start3D() -- Start the 3D function so we can draw onto the screen.
        render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
        render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 255, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    cam.End3D()
end
--PATH lua/entities/roy_eta2_lvs/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 0, 180, 255, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-115.797,-15.056,-18.838),
	Vector(-115.797,15.056,-18.838),
}

function ENT:OnSpawn()
	self:SetPoseParameter("sFoils", 0)
	self:RegisterTrail( Vector(-48.852,104.794,-24.138), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-48.852,-104.794,-24.138), 0, 20, 2, 1000, 150 )
end

local ply = nil

function ENT:OnFrame()

	ply = self:GetDriver()

	if IsValid(ply) or self:GetAI() then
		self.canopyState = 0
	else
		self.canopyState = 1
	end
	
	self.canopyLerp = Lerp(0.1, self.canopyLerp or 0, self.canopyState)
	self:SetPoseParameter("cockpitOpen", self.canopyLerp)

	self:EngineEffects()
	self:AnimAstromech()
	self:AnimWings()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(20,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 50, 180, 255 )
	end
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = 0 - math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown"..math.random(1,2)..".ogg",100 )
		else
			if math.random(0,4) == 3 then
				self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11)..".ogg", 70 )
			end
		end
		
		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles( 4, Angle(self.smastro,0,0) )
end

function ENT:AnimWings()
	self._sm_wing = self._sm_wing or 1

	local target_wing = self:GetFoils() and 0 or 1
	local RFT = RealFrameTime() * (0.5 + math.abs( math.sin( self._sm_wing * math.pi ) ) * 0.5)

	local Rate = RFT * 1

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing,-Rate,Rate)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	if self._oldDoneMoving ~= DoneMoving then
		self._oldDoneMoving = DoneMoving
		if not DoneMoving then
			self:EmitSound("lvs/vehicles/arc170/sfoils.wav")
		end
	end

	if ( self:GetFoils() ) then
		self.foilVar = 0
	else
		self.foilVar = 1
	end
	self.foilLerp = Lerp(0.01, self.foilLerp or 0, self.foilVar)

	self:SetPoseParameter("sFoils", 1-self._sm_wing)

	self:InvalidateBoneCache()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 50 + self:GetThrottle() * 120 + self:GetBoost() * 6

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
		render.DrawSprite(  self:LocalToWorld( pos ), Size*.4, Size*.4, Color( 255, 255, 255, 120) )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

--PATH lua/entities/rw_sw_dispencer_ammobox/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

local dispencer_health = GetConVar("rw_sw_dispenser_health"):GetInt()
ENT.BaseHealth = dispencer_health

ENT.PrintName		= "AmmoCrate Dispenser"
ENT.Author			= "ChanceSphere574"
ENT.Category		= "StarWars Reworked Armory"
ENT.Spawnable 		= true
ENT.AdminSpawnable	= false

ENT.UseTimer = CurTime()
ENT.Status   = 0

ENT.LoadingSkin = 3
ENT.CurSkin = 5
--PATH lua/entities/rw_sw_dispencer_armor/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

local dispencer_health = GetConVar("rw_sw_dispenser_health"):GetInt()
ENT.BaseHealth = dispencer_health

ENT.PrintName		= "Armor Dispenser"
ENT.Author			= "ChanceSphere574"
ENT.Category		= "StarWars Reworked Armory"
ENT.Spawnable 		= true
ENT.AdminSpawnable	= false

ENT.UseTimer = CurTime()
ENT.Status   = 0

ENT.LoadingSkin = 3
ENT.CurSkin = 6
--PATH lua/entities/rw_sw_dispencer_grenade/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/sent_vj_adminhealthkit.lua:
return gluapack()()
--PATH lua/entities/sent_vj_adminhealthkit.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_gmodentity"
ENT.Type 			= "anim"
ENT.PrintName 		= "Admin Health Kit"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Gives a lot of health when taken."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = true
ENT.AdminOnly = true
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local textColor = Color(0, 255, 0, 255)
	local vec = Vector(90, 90, 90)
	
	function ENT:Draw()
		self:DrawModel()
		
		local angs = self:GetAngles()
		angs:RotateAroundAxis(angs:Right(), vec.x)
		angs:RotateAroundAxis(angs:Up(), vec.y)
		angs:RotateAroundAxis(angs:Forward(), vec.z)
		cam.Start3D2D(self:GetPos() + self:GetForward()*7 + self:GetUp()*6 + self:GetRight()*2, angs, 0.07)
		draw.SimpleText("Admin Health Kit", "DermaLarge", 31, -22, textColor, 1, 1)
		cam.End3D2D()
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

function ENT:Initialize()
	self:SetModel("models/items/healthkit.mdl")
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	//self:SetCollisionGroup(COLLISION_GROUP_NONE)
	self:SetUseType(SIMPLE_USE)
	
	local phys = self:GetPhysicsObject()
	if phys and IsValid(phys) then
		phys:Wake()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:PhysicsCollide(data, physobj)
	//self:EmitSound("physics/cardboard/cardboard_box_impact_soft"..math.random(1,5)..".wav")
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Use(activator, caller)
	if activator:IsPlayer() then
		self:EmitSound(Sound("items/smallmedkit1.wav"), 70, 100)
		activator:SetHealth(activator:Health() + 1000000)
		activator:PrintMessage(HUD_PRINTTALK, "#vjbase.print.adminhealth.pickup")
		self:Remove()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnTakeDamage(dmginfo)
	self:GetPhysicsObject():AddVelocity(dmginfo:GetDamageForce() * 0.1)
end
--PATH lua/entities/sent_vj_test/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/spawned_food/shared.lua:
return gluapack()()
--PATH lua/entities/speeder_base.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_stun.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Shock_Explosion_02.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/weapons/tfa_starwars/w_flash.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end
		
		self.Delay = CurTime() + 3
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("weapons/tfa_starwars/Shock_Charge_01.wav")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end
		
		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
		
	end
end

function ENT:Think()
    if SERVER then    
        if CurTime() > self.Delay then
            if self.IsDetonated == false then
                self:Detonate(self,self:GetPos())
                self.IsDetonated = true
            end
        end
    end
    if self.IsDetonated == true then
			local elec = EffectData()
		elec:SetOrigin(self:GetPos())
		elec:SetMagnitude(3)
		util.Effect("Sparks", elec)
for k, v in pairs( ents.FindInSphere( self:GetPos(), 120 ) ) do
    if v:IsPlayer() then
			FreezePlayer(self)
			v:ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 100), 0.2, 0)
			v:EmitSound("weapons/stunstick/spark"..math.random(1,3)..".wav")
			damage = DamageInfo()
                damage:SetDamage( math.random( 2, 5 ) )
                damage:SetAttacker( self:GetOwner() )
                damage:SetDamageType( DMG_SHOCK )
            v:TakeDamageInfo( damage )
                    end
                end
			end
	
    self:NextThink( CurTime() + 0.3 )
    return true
end

function FreezePlayer(self,pos)
	for k, v in pairs( ents.FindInSphere( self:GetPos(), 200 ) ) do
    if v:IsPlayer() then
	local fx = EffectData()
        fx:SetOrigin( v:GetPos() )
        fx:SetMagnitude(2)
        util.Effect("TeslaHitBoxes",fx)
            v:Freeze( true )
timer.Simple(3, function()
            v:Freeze( false )
			end)
		end
	end
end
	
function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
	end
	
	self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,5)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--PATH lua/entities/tfa_csgo_fire_1/shared.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Damage = 1

function ENT:Draw()
end

function ENT:Initialize()
	self.Damage = 1
	self:SetNWBool("extinguished",false)
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_incendiary.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		self:DrawShadow( false )
		for i = 1, 20 do
			local fire = ents.Create("info_particle_system")
			if (i < 2) then
				fire:SetKeyValue("effect_name","molotov_fire_main_gm")
			else
				fire:SetKeyValue("effect_name","molotov_fire_child_gm")
			end
			local pos = self:GetPos()
			//fire:SetPos( Vector( pos.x + 100 * math.sin( math.rad( i * 20 ) ), pos.y + 100 * math.cos( math.rad( i * 20 ) ), pos.z ) )
			fire:SetPos( Vector( pos.x + math.Rand(0, 144) * math.sin( math.rad( i * math.Rand( 0, 180 ) ) ), pos.y + math.Rand(0, 144) * math.cos( math.rad( i * math.Rand( 0, 180 ) ) ), pos.z ) )
			fire:SetAngles( self:GetAngles() )
			fire:SetParent( self )
			fire:Spawn()
			fire:Activate()
			fire:Fire("Start","",0)
			fire:Fire("Kill","",8)
		end
	end
	self:NextThink( CurTime() )
end

function ENT:Think()
	if SERVER then
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 150 ) ) do
			if v:IsPlayer() or v:IsNPC() then
				if v:GetPos():Distance( self:GetPos() ) < 150 then
					damage = DamageInfo()
					damage:SetDamage( math.random( 3, 7 ) )
					damage:SetAttacker( self:GetOwner() )
					damage:SetInflictor( self:GetCreator() )
					damage:SetDamageType( DMG_BURN )
					v:TakeDamageInfo( damage )
				end
			end
		end
	end
	if self:GetNWBool("extinguished",true) then
		if not self.PlayedSound then
			self:EmitSound("TFA_CSGO_Molotov.Extinguish")
			self.PlayedSound = true
		end
		if SERVER then
			SafeRemoveEntity( self )
		end
	end
	self:NextThink( CurTime() + math.Rand( 0.2, 0.7 ) )
end
--PATH lua/entities/tfa_exp_base/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Base Explosive"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.DoNotDuplicate = true
ENT.DisableDuplicator = true

local sp = game.SinglePlayer()

function ENT:EmitSoundNet(sound)
	if CLIENT or sp then
		if sp and not IsFirstTimePredicted() then return end

		self:EmitSound(sound)

		return
	end

	local filter = RecipientFilter()
	filter:AddPAS(self:GetPos())
	if IsValid(self:GetOwner()) then
		filter:RemovePlayer(self:GetOwner())
	end

	net.Start("tfaSoundEvent", true)
	net.WriteEntity(self)
	net.WriteString(sound)
	net.WriteBool(false)
	net.Send(filter)
end

--PATH lua/entities/tfbow_arrow_stuck/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() -- Draw the model.
end

--PATH addons/[tfres] datapad/lua/entities/tfres_arrests/shared.lua:
return gluapack()()
--PATH lua/entities/tie_bomber.lua:
return gluapack()()
--PATH lua/entities/turbolaserspawner/cl_init.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/arc9_opencrate.lua:
return gluapack()()
--PATH lua/effects/arccw_shelleffect.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/astw2_muzzleflash_swrc_blue_sniper/init.lua:
local AddVel = Vector()

function EFFECT:Init(data)
    local quality = GetConVar("astw2_quality"):GetInt()
    if GetConVar("astw2_force_effect_minlevel_1"):GetBool() and quality == 0 then
        quality = 1
    end

    if quality == 0 then return end

    self.WeaponEnt = data:GetEntity()
    if !IsValid(self.WeaponEnt) then return end
    self.Owner = self.WeaponEnt:GetOwner()
    if !IsValid(self.Owner) then return end
    local dir = data:GetNormal()
    local scale = self.WeaponEnt.Primary.Damage * self.WeaponEnt.Primary.Num
    scale = scale * 0.01

    self.vOffset = self.WeaponEnt:GetBorePos()

    AddVel = self.WeaponEnt.Owner:GetVelocity()

    local emitter = ParticleEmitter(self.vOffset)

    if !self.WeaponEnt.Suppressed then
        local particle = emitter:Add("effects/swrc/muzzlesniper", self.vOffset)

        if (particle) then
            particle:SetVelocity(AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.07 ,0.1))
            particle:SetStartAlpha(155)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(5, 10))
            particle:SetEndSize(scale * math.Rand(40, 60))
            particle:SetLighting(false)
            particle:SetRoll(math.random(0, 0))
            particle:SetColor(255, 255, 255)
        end
    end

        local particle2 = emitter:Add("effects/swrc/flare_5", self.vOffset)

        if (particle2) then
            particle2:SetVelocity(AddVel)
            particle2:SetLifeTime(0)
            particle2:SetDieTime(math.Rand(0.07 ,0.1))
            particle2:SetStartAlpha(255)
            particle2:SetEndAlpha(155)
            particle2:SetStartSize(math.Rand(15, 20))
            particle2:SetEndSize(scale * math.Rand(50, 75))
            particle2:SetLighting(false)
            particle2:SetRoll(math.random(0, 0))
            particle2:SetColor(255, 255, 255)
        end

    local particlecount = quality * 2


    if quality >= 3 then
        local particle = emitter:Add("sprites/heatwave", self.vOffset)

        if (particle) then
            particle:SetVelocity((dir * 25) + 1.05 * AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(0.1)
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(80, 100))
            particle:SetEndSize(0)
            particle:SetRoll(math.Rand(0, 360))
            particle:SetRollDelta(math.Rand(-2, 2))
            particle:SetAirResistance(5)
            particle:SetGravity(Vector(0, 0, 40))
            particle:SetColor(255, 255, 255)
        end
    end

    emitter:Finish()
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/astw2_muzzleflash_swrc_red/init.lua:
local AddVel = Vector()

function EFFECT:Init(data)
    local quality = GetConVar("astw2_quality"):GetInt()
    if GetConVar("astw2_force_effect_minlevel_1"):GetBool() and quality == 0 then
        quality = 1
    end

    if quality == 0 then return end

    self.WeaponEnt = data:GetEntity()
    if !IsValid(self.WeaponEnt) then return end
    self.Owner = self.WeaponEnt:GetOwner()
    if !IsValid(self.Owner) then return end
    local dir = data:GetNormal()
    local scale = self.WeaponEnt.Primary.Damage * self.WeaponEnt.Primary.Num
    scale = scale * 0.025

    self.vOffset = self.WeaponEnt:GetBorePos()

    AddVel = self.WeaponEnt.Owner:GetVelocity()

    local emitter = ParticleEmitter(self.vOffset)

    if !self.WeaponEnt.Suppressed then
        local particle = emitter:Add("effects/swrc/a_FLASHRED", self.vOffset)

        if (particle) then
            particle:SetVelocity(AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.1 ,0.15))
            particle:SetStartAlpha(155)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(5, 10))
            particle:SetEndSize(scale * math.Rand(40, 60))
            particle:SetLighting(false)
            particle:SetRoll(math.random(0, 0))
            particle:SetColor(255, 255, 255)
        end
	local particle2 = emitter:Add("effects/swrc/glow_red", self.vOffset)

        if (particle2) then
            particle2:SetVelocity(AddVel)
            particle2:SetLifeTime(0)
            particle2:SetDieTime(math.Rand(0.07 ,0.1))
            particle2:SetStartAlpha(255)
            particle2:SetEndAlpha(0)
            particle2:SetStartSize(math.Rand(2, 5))
            particle2:SetEndSize(scale * math.Rand(20, 30))
            particle2:SetLighting(false)
            particle2:SetRoll(math.random(-5, 5))
            particle2:SetColor(255, 255, 255)
        end
	

    end

       
    local particlecount = quality * 2


    if quality >= 3 then
        local particle = emitter:Add("sprites/heatwave", self.vOffset)

        if (particle) then
            particle:SetVelocity((dir * 25) + 1.05 * AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(0.1)
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(80, 100))
            particle:SetEndSize(0)
            particle:SetRoll(math.Rand(0, 360))
            particle:SetRollDelta(math.Rand(-2, 2))
            particle:SetAirResistance(5)
            particle:SetGravity(Vector(0, 0, 40))
            particle:SetColor(255, 255, 255)
        end
    end

    emitter:Finish()
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/astw2_muzzleflash_swrc_tran/init.lua:
return gluapack()()
--PATH lua/effects/astw2_swrc_conc_rifle_explosion/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 125
            light.g = 85
            light.b = 200
            light.Brightness = 8
            light.Decay = 32
            light.Size = 324
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/swrc/explosion", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(50,75) )
    particle:SetEndSize( math.Rand(375,475) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-3,3) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )


    particle = emitter:Add( "particle/warp5_warp", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand( 0.6, 2) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(1,2) )
        particle:SetEndSize( math.Rand(400,475) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 100,100,255 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/bactanade/init.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/ca3_tracer_noattach.lua:
return gluapack()()
--PATH lua/effects/cod2019_725_smoke/init.lua:
function EFFECT:Init(data)
    self.Weapon = data:GetEntity()
    self.Owner = self.Weapon:GetOwner()
    
    if IsValid(self.Owner) and self.Owner:IsPlayer() then
        self.ViewModel = self.Owner:GetViewModel()
        
        if IsValid(self.ViewModel) then
            ParticleEffectAttach("barrel_smoke_3", PATTACH_POINT_FOLLOW, self.ViewModel, 4)
        end
    end
end

function EFFECT:Think()
    if not IsValid(self.Weapon) or not IsValid(self.Owner) or not IsValid(self.ViewModel) then 
        return false 
    end
    return true
end

function EFFECT:Render()
end
--PATH lua/effects/cod2019_tracer_2/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_tracer_inc/init.lua:
PrecacheParticleSystem("mw2019_tracer_inc")
EFFECT.TracerName = "mw2019_tracer_inc"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    local hit = data:GetOrigin()
    local wep = data:GetEntity()
    if !IsValid(wep) then return end
	local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()
    self.Attachment = data:GetAttachment() or 1

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.StartPos = start
    self.EndPos = hit
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_ABSORIGIN, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.StartPos)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(1.2, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--PATH lua/effects/cod2019_tracer_rainbow/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_tracer_rainbow/init.lua:
PrecacheParticleSystem("mw2019_tracer_rainbow")
EFFECT.TracerName = "mw2019_tracer_rainbow"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    local hit = data:GetOrigin()
    local wep = data:GetEntity()
    if !IsValid(wep) then return end
	local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()
    self.Attachment = data:GetAttachment() or 1

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.StartPos = start
    self.EndPos = hit
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_ABSORIGIN, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.StartPos)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(1.2, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--PATH lua/effects/csgo_muzzle_awp/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_awp"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end

    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_he/init.lua:
function EFFECT:Init(data, weapon, dmgInfo, tr)
    local pos = data:GetOrigin()
    local norm = data:GetNormal()
    ParticleEffect("weapon_muzzle_flash_HE", pos, norm:Angle())
    sound.Play("HE.ExplosiveHit", data:GetOrigin(), SNDLVL_100dB, 100, 1)
    local dynlight = DynamicLight(0)
    dynlight.Pos = data:GetOrigin()
    dynlight.Size = 20
    dynlight.Decay = 20
    dynlight.R = 255
    dynlight.G = 150
    dynlight.B = 0
    dynlight.Brightness = 5
    dynlight.DieTime = CurTime() + 0.1
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_para/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_para"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_pistol_silenced/init.lua:
return gluapack()()
--PATH lua/effects/csgo_taser_tracer/init.lua:
return gluapack()()
--PATH lua/effects/dark_infect.lua:
local mat_glow = Material( "models/elemental/dark_highlight" )

function EFFECT:Init( data )

	if ( GetConVar( "mat_fillrate" ):GetBool() ) then return end

	self.Time = 1.5
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	self.Flags = data:GetFlags()
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end

	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + (EyePos() - PPos):GetNormal() )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
			
	return false
	
end

function EFFECT:RenderOverlay( entity )

	local Fraction = ( self.LifeTime - CurTime() ) / self.Time

	Fraction = 1 - math.Clamp( Fraction, 0, 1 )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()

	local Pos = EyePos() + EyeNormal * Distance * 0

	cam.Start3D( Pos, EyeAngles() )
		render.UpdateRefractTexture()
		
		mat_glow:SetFloat( "$SilhouetteThickness", 1 * Fraction + 4 * Fraction * Fraction  )
		mat_glow:SetFloat( "$refractamount", 0.01 * Fraction )
		mat_glow:SetFloat( "$bluramount", 0.01 * Fraction )

		mat_glow:SetVector( "$colortint", Vector( 1, 1, 1 ) - Vector( 2, 2.5, 3 ) * Fraction )
		mat_glow:SetVector( "$SilhouetteColor", Vector( 1, 1, 1 ) - Vector( 2, 5, 8 ) * Fraction )
		
		mat_glow:SetFloat( "$GroundMin", -12 * Fraction )
		mat_glow:SetFloat( "$GroundMax", 2 * Fraction )

		render.MaterialOverride( mat_glow )
		entity:DrawModel()
		render.MaterialOverride()
		
	cam.End3D()

end

function EFFECT:Render()

end

function EFFECT:RenderParent()
	
	self:DrawModel()
	
	self.SpawnEffect:RenderOverlay( self )

end
--PATH lua/effects/effect_astw2_swrc_impact_wookie/init.lua:
EFFECT.Duration			= 0.5;
EFFECT.Size				= 64;

local MaterialGlow		= Material( "effects/swrc/impact_green" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/swbf/sparks", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.5 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 25, 30 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/swbf/thicksmoke"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(2, 5));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(20, 40));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--PATH lua/effects/effect_astw2_swrc_laser_blue_sniper/init.lua:

local Tracer = Material( "effects/swrc/a_bluebeam" )
local Tracer2  = Material( "effects/blueblacklargebeam" )
local Width = 15
local Width2 = 10

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.15
	self.LifeTime2 = 0.25
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 155, 175, 255, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 200, 195, 255, (v2 * 100)*3/2.5 ) )

end

--PATH lua/effects/effect_sw_impact_2/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_blue_old/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/effect_sw_laser_blue_stun/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_green_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_green_main")
local MaterialFront = Material("effects/sw_laser_green_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_purple_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_purple_main")
local MaterialFront = Material("effects/sw_laser_purple_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_red_akimbo/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_red_main" );
local MaterialFront			= Material( "effects/sw_laser_red_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		local att = 2 - entity.AnimCycle or data:GetAttachment()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(att)

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/effect_sw_laser_red_long/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6000
EFFECT.Length				= 250
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 200

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightning_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 150, 150, 255, 255) )
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningii.lua:

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 111 --EDT
					dlight.g = 0 --EDT
					dlight.b = 255 --EDT
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect( "force_lightningii_hit", effectdata )

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 111 --EDT
							dlight.g = 0 --EDT
							dlight.b = 255 --EDT
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 111, 0, 255) ) --Elden Cikan Yes
			render.DrawSprite( StartPos, 16, 16, Color( 111, 0, 255, 255) ) --Bilmiyorum

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 111, 0, 255) ) --Az Elektrik

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 255, 255 + 150 * Width, 255, 255 ) ) --Etraftaki Cok Fazla Elektrik

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 111, 0, 255, 255 ) ) --Aradakilerin yarisi 
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 255, 255, 255) ) --Kalanlar

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--PATH lua/effects/gravrifle_preexplode.lua:
------------------------------------------------------------------
-- Darken217's Sci-Fi Weapons v18 								--
-- gravrifle_preexplode											--
-- Elemental effect to go along with Helios' elemental effect 	--
------------------------------------------------------------------

--[[
Hypocritical naming convention:
	I encourage you to stick to a specific naming convention for your variables, so you know what you're dealing with.
	I try to stick to a prefix-system to show the datatype assigned to a specific variable. 
	For example bEnabled is a boolean, vPosition is a vector, aRotation an angle and so on. 
	It's not mendatory, but it'll help you keep your code manageable, especially when you get to a point where you experiment around.
]]--

-- The material we'll be writing data to. We'll apply the material to the effect later.
EFFECT.FxMaterial = Material( "models/elemental/gravrifled" )
EFFECT.DeltaTime = 1

local m_sprite = Material( "particle/warp1_warp.vmt" )

-- The default color. This technically equates to "255 153 1020", which is something the engine technically cannot display.
-- However, we're overshooting the color to fake actual light emission, relying on bloom effects along with the emissive glow in the material to create a feeling of "glow".
EFFECT.LightColor = Vector( 1, 0.6, 4 )

-- local mBloom = Material( "bloom/halo_static" )

local cmd_sunbeams = GetConVar( "sfw_fx_individualsunbeams" )
EFFECT.SpriteSize = 64
EFFECT.SpriteAlpha = 128

-- Precache sounds. 
-- Technically this is also done in /base/scifi_sounds.lua, however, we want to adjust the sounds on the fly, which a sound-script created by sound.Add() doesn't allow us to do.
-- Note, that in any other scenario where you don't pass additional data to the EmitSound() function, the sound script addition is the way to go.
local tDistantBlastSounds = {
	Sound( "weapons/calhan/blast_distant1.wav" ),
	Sound( "weapons/calhan/blast_distant2.wav" ),
	Sound( "weapons/calhan/blast_distant3.wav" ),
	Sound( "weapons/calhan/blast_distant4.wav" )
}

--[[
Init
--
Runs on effect creation
--
Initialize the effect and pass the EffectData() passed by util.Effect().
Effect-specific data, like EFFECT.ParentEntity is defined in here.
]]--
function EFFECT:Init( data )

	if ( GetConVar( "mat_fillrate" ):GetBool() ) then return end

	-- Effects loop ad-infinitum, until emergency cleanup (don't rely on this) or until the parent entity is removed.
	-- Life-time is calculated by determining a point in time at which the effect should self-terminate (see EFFECT.Think()).
	self.Time = data:GetScale()
	self.Origin = data:GetOrigin()
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	-- Check whether or not the parent entity is the current player.
	-- If so, target the viewmodel, so it has a proper 1st-person representation.
	local entPlayer = LocalPlayer()
	if ( ent == entPlayer ) && ( !entPlayer:ShouldDrawLocalPlayer() ) then
		self.ViewModel = true -- Set ViewModel to true, we'll look this up later in EFFECT.RenderOverlay().
			
		ent = entPlayer:GetHands()
	end
	
	self.ParentEntity = ent
	
	-- Self-terminate in case the entity's RenderOverride slot is already taken. (usually by a dissolve effect)
	if ( self.ParentEntity.RenderOverride ) then
		return
	end
	
	-- Apply the target entity's model to this effect, effectively creating a mesh-layer.
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self
	
	-- Write a randomized value to the effect's target material. This is not mandatory but can be useful create a more "individualized" appearance and reduce repititiveness.
	self.FxMaterial:SetVector( "$emissiveBlendScrollVector", Vector( 0.1, 0.15 ) * ( 14 - data:GetScale() ) )

end

--[[
Think 
--
Runs every frame as long as the effect lives.
--
Handle timed events and self-termination.
Returns TRUE as long as the effect's survival conditions are met (valid parent, CurTime() < Expiration Time).
Returns FALSE when the effect should self-terminate. 
]]--
function EFFECT:Think( )

	-- Self-terminate if the parent entity is invalid.
	if ( !IsValid( self.ParentEntity ) ) then return false end

	-- Offset the effect slightly towards the player's eyes, so the overlay doesn't intersect with the actual model and always appears on top.
	local vParentOrigin = self.ParentEntity:GetPos()
	self:SetPos( vParentOrigin + ( EyePos() - vParentOrigin ):GetNormal() )
	
	-- Determine how much "life time" the effect has left until self-termination.
	local DieTime = self.LifeTime - CurTime()
	
	-- The sound-effect is not stretched. Play the "pre-explode" sound in case the remaining lifetime is equal or less than half-a-second.
	if ( DieTime <= 0.58 && self.DeltaTime >= 0.58 ) then
		self.ParentEntity:EmitSound( "scifi.gravrifle.preexplode" )
	end
	
	-- Write a delta-time. We use this value to compare between current frame and last frame to determine an exact moment in time.
	self.DeltaTime = DieTime
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity:StopSound( "scifi.gravrifle.preexplode" )
	
	-- Start of death-event
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
	
	-- Emit explosion sound on client. Note, that this will not always take place, depending on the entity it's called on. See /scifi_base/scifi_elementals.lua
	
	local sParentClass = self.ParentEntity:GetClass()	
	local bIsRagdoll = ( sParentClass == "prop_ragdoll" || sParentClass == "class C_HL2MPRagdoll" ) -- apparently, entity.IsRagdoll() does no longer work for clientside ragdolls, i.e. player ragdoll entities. This will have to make due.
	if ( game.SinglePlayer() && !bIsRagdoll ) || ( !game.SinglePlayer() && bIsRagdoll ) then
		self.ParentEntity:EmitSound( "scifi.gravrifle.blast" )
	end

	-- Determine the distance between the player (or otherwise current view entity, i.e. a gmod_cameraprop) and the explosion.
	-- We use 4000 as an arbitrary falloff distance at which the explosion will not be heard anymore and 0.3 as maximum playback volume.
	local iDistance = vParentOrigin:Distance( EyePos() )
	local fVolume = math.Clamp( iDistance / 4000, 0, 0.3 )

	if ( fVolume > 0.06 ) then
		EmitSound( tDistantBlastSounds[ math.random( 1, #tDistantBlastSounds ) ], vParentOrigin, -1, CHAN_STATIC, fVolume, SNDLVL_95dB, SND_NOFLAGS, math.random( 90, 110 ) )
	end
	
	-- Self-termination		
	return false
	
end

--[[
Render function. This is default for effects, but since we have a custom one (EFFECT.RenderOverlay) 
]]--
function EFFECT:Render()

end

--[[
Render the effect
--
Runs every frame as long as the effect lives.
--
The core function of the effect. Work with the acquired data, make the effect happen.
In here, we're creating dynamic light emission and write data into the override material.
We're also rendering the overlay mesh.
]]--
function EFFECT:RenderOverlay( entParent )
	
	-- Calculate a scale that is relative to the life-time. This scales from 0 to 1.
	local fFraction = 1 - ( self.LifeTime - CurTime() ) / self.Time
	
	-- Clamp the fraction (see above) between 0 and 1. This is a safety percussion. 
	-- Mathematically, there should be no reason to do this, however, if the player is suffereing from very low FPS the timing could be off, causing fFraction to get out of the desired bounds.
	fFraction = math.Clamp( fFraction, 0, 1 )
	
	local vOrigin = entParent:GetPos()
	local vEyeOrigin = EyePos()
	local EyeNormal = vOrigin - vEyeOrigin
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local vOffset
	
	if ( self.ViewModel ) then
		-- We're arbitrarily assuming that the viewmodel FOV is 54 (default for HL2 weapons unless altered by a mod).
		local iFov = 54
		local entWeapon = LocalPlayer():GetActiveWeapon()
		if ( IsValid( entWeapon ) && entWeapon.ViewModelFOV ) then
			iFov = entWeapon.ViewModelFOV
		end
		
		local add = -54 + iFov
		add = add * 0.3
		
		-- Offset the effect away from the player, because it would otherwise be "inside" them and thus "behind" the camera. 
		-- This is INCREDIBLY hacky.
		vOffset = EyeAngles():Forward() * ( 12 - add )
	else
		-- Offset the effect slightly towards the player's eyes, so the overlay doesn't intersect with the actual model and always appears on top.
		vOffset = EyeNormal * Distance * 0.01
	end
	
	-- Set the mesh-overlay's position.
	local Pos = vEyeOrigin + vOffset
	
	local entOwner
	if ( self.ViewModel ) then
		entOwner = entParent:GetOwner()
	else
		entOwner = entParent
	end

	-- Since the effect's appearence is pretty irratic, we'd like the dynamic light to act in a similar manner.
	-- We're using a sine function of the current time and a randomized value to create apparently randomized flicker.
	-- Finally, the fFraction value (see above) to scale it according to life-time, creating a "increasing" feeling.
	local fFlicker = math.sin( CurTime() * math.random( 16, 64 ) ) + 1.2 * fFraction
	local fStrength = fFraction * 2 ^ ( fFraction * 1.2 )
	
	-- Determine the light emission's location. We're idealy choosing the target entity's root bone.
	-- On a typical Valve-esque bone rig, this will be at or around the pelvis. On non-ragdoll entities (i.e. prop_physics), bone "0" will of course be the only bone present.
	local vLightOrigin = entOwner:GetBonePosition( 0 )
	if ( !entOwner:IsRagdoll() ) then
		vLightOrigin = entOwner:GetPos() + entOwner:OBBCenter()
	end
	
	-- Create the dynamic light.
	local dlight = DynamicLight( entOwner:EntIndex() )
	if ( dlight ) then
		dlight.pos = vLightOrigin
		dlight.r = math.min( self.LightColor.r * 10, 255 ) 	-- Remember the "color overshooting" we did above.
		dlight.g = math.min( self.LightColor.g * 10, 255 ) 	-- Note, that DynamicLight() is unable to display colors like 256, it'll effectively break and mutate the color.
		dlight.b = math.min( self.LightColor.b * 10, 255 )
		dlight.brightness = 2 * fFraction					-- Scale the brightness with the fFraction.
		dlight.Size = ( 600 + 400 * fFlicker ) * fFraction 	-- Don't just multiply .Size with fFraction, since the light will appear too small or won't be visible to the player. We'll be using a base size and add an increasing size to it. 
		dlight.Decay = 2048
		dlight.Style = 1									-- Light style "1" is mildly flickering on its own already, but we'll add our flicker created above regardless.
		dlight.DieTime = CurTime() + self.Time				-- Technically we're setting the lifetime to an unnecessarily long value, but since we're overwriting the light each frame anyway, it doesn't matter at all.
	end

	-- Write data into the material --
	-- See developer.valvesoftware.com for the specific material effects, most notably $EmissiveBlend and $Flesh.
	-- Essentially, we're using the effects created for the Vortigaunt teleport scene and the Alyx healing scene, like we did in many other effects before.
	-- The arbitrary values used here have been determined through fine tuning and gut-feeling.
	self.FxMaterial:SetFloat( "$emissiveBlendStrength", fStrength ) 		-- Scale the brightness of the purple swirl effect.
	self.FxMaterial:SetFloat( "$FleshBorderSoftness", 0.1 * fFraction )		-- Scale the black-hole effect to grow until it covers the entire model. 
	self.FxMaterial:SetFloat( "$FleshBorderWidth", 7 - fStrength * 3 )		-- Different value, but the goal is the same as above. ^
	self.FxMaterial:SetFloat( "$time", fFraction )							-- $time is equal to CurTime() inside materials unless otherwise specified. We'll write it equal to the effect's lifetime so the effects behave according to their internal time.
	self.FxMaterial:SetVector( "$energycolor", self.LightColor * fStrength )			-- $energycolor is a placeholder variable used inside the material. It's the color applied to glow emissions, so we don't have to write colors to multiple values via lua and let the engine do the copy-pasta for us.

	--[[--- Ignore this one. Gmod doesn't support this cinematic feature ------
	]]-------------------------------------------------------------------------	
	self.FxMaterial:SetFloat( "$SphereMaskRadius", 72 * fFraction )
	self.FxMaterial:SetFloat( "$FleshGlobalOpacity", 1 * fStrength )
	
	if ( self.Origin ) then
		self.FxMaterial:SetVector( "$SphereMaskOrigin", self.Origin )
	else
		self.FxMaterial:SetVector( "$SphereMaskOrigin", origin )
	end
	
	-- Create a 3d rendering context at the offset position and actually draw the mesh-overlay with the effect material.
	cam.Start3D( Pos, EyeAngles() )
		render.MaterialOverride( self.FxMaterial )
		entParent:DrawModel()
		render.MaterialOverride() -- Don't forget to reset MaterialOverride() once you've set it, so you don't break literally everything that ever wanted to apply a material.
	cam.End3D()
	
	local fSpriteScale = math.Clamp( -0.4 + fFraction * 1.4, 0, 1 )

	local color_1 = Color( 255, 255, 255, 255 )
	color_1.a = self.SpriteAlpha * fSpriteScale

	local size = ( entOwner:BoundingRadius() + self.SpriteSize ) * fSpriteScale

	render.SetMaterial( m_sprite )
	render.DrawSprite( vLightOrigin, size, size, color_1 )
	
	-- Finish here unless individual sunbeams are enabled.
	local bSunBeams = cmd_sunbeams:GetBool()
	if ( !bSunBeams ) then return end 
	
	local screen = vLightOrigin				-- The soon-to-be "sun" origin.
	local vNormal = screen - vEyeOrigin		-- Normal pointing from our view point towards the effect.
	
	-- Compute the dot product of the normal (essentially a floating point number that is positive if you look at it, negative when you don't).
	-- See http://wiki.garrysmod.com/page/Vector/Dot for details.
	local dot = ( vNormal:Dot( EyeVector() ) - 0.8 ) * 5
	if ( dot <= 0 ) then return end -- Stop if we're facing away.

	-- The sunbeam effect requires you to be very, very far away
	screen = screen + ( vNormal * 16384 )
	
	-- Since the sunbeam effect is 2d, we're determing the position on screen, relateive to screen size to properly position the sun effect.
	screen = screen:ToScreen()
	
	local w, h = ScrW(), ScrH()
	local glowX, glowY = screen.x, screen.y
	
	-- Draw the sun effect. See /postprocessing/sunbeams.lua or http://wiki.garrysmod.com/page/Global/DrawSunbeams for details.
	DrawSunbeams( 0.85, 0.1 * fStrength, 0.04 - fStrength * 0.01, glowX / w, glowY / h )

end

--[[
Render the effect
--
Runs every frame as long as the effect lives.
--
Draw the parent with the original model and call the actual render function EFFECT.RenderOverlay().
]]--
function EFFECT:RenderParent()
	
	-- Draw the target entity.
	self:DrawModel()
	
	-- Draw the effect and pass the effect.
	self.SpawnEffect:RenderOverlay( self )

end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/laser_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)

	self.mat = Material( "sprites/light_glow02_add" )

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()

	local emitter = ParticleEmitter( Pos, false )

	for i = 0, 2 do
		local particle = emitter:Add( "sprites/light_glow02_add", Pos )

		local vel = VectorRand() * 200 - Dir  * 80

		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 150 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(1, 20) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100, 100) )
			particle:SetRollDelta( math.Rand(-100, 100) )
			particle:SetColor( Col.x,Col.y,Col.z )
			particle:SetGravity( Vector(0, 0, -600) )

			particle:SetAirResistance( 0 )

			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.mat )
	render.DrawSprite( self.Pos, 50 * Scale, 50 * Scale, Color( self.Col.x, self.Col.y, self.Col.z, 255) )
	render.DrawSprite( self.Pos, 10 * Scale, 10 * Scale, color_white )
end

--PATH lua/effects/lfs_fb_wingturret_projector.lua:
return gluapack()()
--PATH lua/effects/lvs_capital_red_geono.lua:
return gluapack()()
--PATH lua/effects/lvs_concussion_trail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "effects/select_ring" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		if particle then
			particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
			particle:SetVelocity( -self.Entity:GetForward() * 200  )
			particle:SetAirResistance( 600 ) 
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(5,6) )
			particle:SetEndSize( math.Rand(12,30) )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 50,50,50 )
			particle:SetCollide( false )
		end

		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(10,15) )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 150,50,100 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 0.25 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(6,10) )
			particle:SetEndSize( math.Rand(2,3) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,100,200 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity
	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )

	render.DrawSprite( pos, 100, 100, Color( 255, 40, 100, 50 ) )
end

--PATH lua/effects/lvs_laser_blue_short.lua:
return gluapack()()
--PATH lua/effects/lvs_proton_trail.lua:
return gluapack()()
--PATH lua/effects/lvs_tracer_green.lua:
return gluapack()()
--PATH lua/effects/lvs_tracer_proton.lua:

EFFECT.GlowColor = Color( 0, 127, 255, 255 )
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

EFFECT.MatSprite = Material( "effects/select_ring" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	self.emitter = ParticleEmitter( pos, false )

	self.OldPos = pos
	self.Dir = dir
end

function EFFECT:doFX( pos, curpos )
	if not IsValid( self.emitter ) then return end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), pos )
	if particle then
		particle:SetVelocity( -self.Dir * math.Rand(250,800) + self.Dir * 5000 )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 8 )
		particle:SetEndSize( 1 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 0,0,255 )
		particle:SetGravity( Vector( 0, 0, 600 ) )
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), curpos )
	if particle then
		particle:SetVelocity( self.Dir * 5000 + VectorRand() * 50 )
		particle:SetDieTime( 1 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 6 )
		particle:SetEndSize( 2 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 0,0,255 )
		particle:SetGravity( Vector( 0, 0, 600 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then
		if self.emitter then
			self.emitter:Finish()
		end

		return false
	end

	if not self.emitter then return true end

	local T = CurTime()

	if (self.nextDFX or 0) <= T then
		self.nextDFX = T + 0.02
		
		local bullet = LVS:GetBullet( self.ID )

		local Pos = bullet:GetPos()

		local Sub = self.OldPos - Pos
		local Dist = Sub:Length()
		local Dir = Sub:GetNormalized()

		for i = 0, Dist, 45 do
			local cur_pos = self.OldPos + Dir * i

			self:doFX( cur_pos, Pos )
		end

		self.OldPos = Pos
	end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local pos = bullet:GetPos()

	render.SetMaterial( self.MatSprite )
	render.DrawSprite( pos, 100, 100, Color( 0, 127, 255, 50 ) )

	render.SetMaterial( self.GlowMat )

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - self.Dir * i * 7, Size, Size, self.GlowColor )
	end
end

--PATH lua/effects/lvs_tracer_white.lua:
return gluapack()()
--PATH lua/effects/lvs_tracer_white.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 150, 150, 150, 255 ) )
end

--PATH lua/effects/meridian_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"meridian_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/effects/meridian_tracer_noattach.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 6500 --16000
EFFECT.Length	= 64

function EFFECT:Init( data )

	self.StartPos = data:GetStart() --self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	util.ParticleTracerEx( 
		"meridian_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/nio_dissolve.lua:
local mat_glow = Material( "models/elemental/neutrinoed" )

function EFFECT:Init( data )

	self.Time = 1.55
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self
	
	if ( GetConVar( "sfw_fx_particles" ):GetBool() ) then
		ParticleEffectAttach( "nio_dissolve", PATTACH_ABSORIGIN_FOLLOW, ent, -1 )
	else
		ParticleEffectAttach( "nio_dissolve_cheap", PATTACH_ABSORIGIN_FOLLOW, ent, -1 ) 
	end

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + (EyePos() - PPos):GetNormal() )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
			
	return false
	
end

function EFFECT:Render()

end

local pi = math.pi

function EFFECT:RenderOverlay( entity )
		
	local fFraction = ( self.LifeTime - 0.1 - CurTime() ) / self.Time
	local fColFrac = ( fFraction - 0.5 ) * 2
	
	fFraction = math.Clamp( fFraction, 0, 1 )
	fColFrac =  math.Clamp( fColFrac, 0, 1 )
	
	local fFractionReversed = ( 1 - fFraction )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local Pos = EyePos() + EyeNormal * Distance * 0.01
	local bClipping = self:StartClip( entity, 1 )

	local iFrames = math.Clamp( 24 - ( 24 * fColFrac ), 1, 24 )
	iFrames = math.Round( iFrames, 0 )
	
	mat_glow:SetInt( "$frame", iFrames )
	
	cam.Start3D( Pos, EyeAngles() )
		local amount = math.Clamp( -0.2 + fFraction, 0, 1 )
		render.SetColorModulation( amount, amount, amount )
		render.SetBlend( fColFrac )
	
		render.MaterialOverride()
		entity:DrawModel()

		render.SetColorModulation( 1, 1, 1 )
		render.SetBlend( 1 )
	cam.End3D()

	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )
	
	local evilmath = 2 * 2 ^ ( fFractionReversed * 2 - fFraction )
	evilmath = evilmath * 0.125

	mat_glow:SetFloat( "$FleshBorderWidth", 6 * evilmath )
	mat_glow:SetFloat( "$FleshBorderSoftness", 0.5 * fFraction )
	mat_glow:SetFloat( "$FleshGlossBrightness", 12 * fFractionReversed )
	mat_glow:SetVector( "$selfillumtint", Vector( 0.2, 12, 0.4 ) * fFraction )

end

function EFFECT:RenderParent()
	
	render.SetColorModulation( 1, 3, 1 )
	render.MaterialOverride( mat_glow )
	
	self:DrawModel()
	
	self.SpawnEffect:RenderOverlay( self )

end

function EFFECT:StartClip( model, spd )

	local mn, mx = model:GetRenderBounds()
	local Up = (mx-mn):GetNormal()
	local Bottom =  model:EyePos() + mn
	local Top = model:EyePos() + mx
	
	local fFraction = ( self.LifeTime - CurTime() ) / self.Time
	fFraction = math.Clamp( fFraction / spd, 0, 1 )
	
	local Lerped = LerpVector( fFraction, Top, Bottom )
	
	local normal = Up 
	local distance = normal:Dot( Lerped )
	local bEnabled = render.EnableClipping( true )
	render.PushCustomClipPlane( normal, distance )
	
	local mLight = DynamicLight( self.ParentEntity:EntIndex() * -1 )
	if ( mLight ) then
		mLight.pos = Lerped
		mLight.r = 80
		mLight.g = 255
		mLight.b = 40
		mLight.brightness = 3 * fFraction
		mLight.Size = 180 + 400 * fFraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end

	return bEnabled
	
end
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/pest_tracer.lua:
return gluapack()()
--PATH lua/effects/pest_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()
	
	util.ParticleTracerEx( 
		"corro_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/pulsar_tracer.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH addons/[miecze] moce i hilty/lua/effects/rb655_force_repulse_in.lua:
return gluapack()()
--PATH lua/effects/red_tracer.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )

function EFFECT:GetTracerOrigin( data )

	local start = data:GetStart()

	if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity()

		if ( not IsValid( entity ) ) then return start end
		if ( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end

		if ( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then

			local pl = entity:GetOwner()
			if ( IsValid( pl ) ) then
				local vm = pl:GetViewModel()
				if ( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm
				else
					if ( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel )
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() )
		if ( attachment ) then
			start = attachment.Pos
		end

	end

	return start

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()

	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )

	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed


	local weapon = data:GetEntity()
	if ( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then
		util.DistanceToLine( self.StartPos, self.EndPos, EyePos() )
	end

end


function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end


function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length

	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * (endDistance * 1.2)

	render.SetMaterial( MaterialFront )
	render.DrawSprite( endPos, 32, 24, color_white )

	render.SetMaterial( MaterialMain )
	render.DrawBeam( startPos, endPos, 20, 0, 1, color_white )
end

--PATH lua/effects/rw_sw_dual_laser_blue.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_blue_main")
local MaterialFront 		= Material("effects/sw_laser_blue_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 30
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_dual_laser_purple.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_purple_main")
local MaterialFront 		= Material("effects/sw_laser_purple_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 125
			dlight.g = 0
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_dual_laser_redpink.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_green.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_green" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_impact_servius.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_white.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_orange.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_purple.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_aqua.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,255,160)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/rw_sw_muzzleflash_blue.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_lightblue.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,160,255)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH addons/[miecze] moce i hilty/lua/effects/saber_block.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/saber_hit.lua:
return gluapack()()
--PATH lua/effects/serv_passive_stun.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/swep_flamethrower_flame2/init.lua:
//Main function
function EFFECT:Init(data)


//Default performance settings
local DrawFlame = 1
local DrawSmoke = 1
local DrawRefraction = 0

//Adjust performance depending on user settings
local PerfIndex = GetConVar("flamethrower_fx"):GetInt()
if PerfIndex == 1 then DrawSmoke = 0 end
if PerfIndex == 3 then DrawRefraction = 1 end


//Muzzle and desired position vectors
local StartPos = self:GetTracerShootPos(self.Position, data:GetEntity(), data:GetAttachment())
local HitPos = data:GetOrigin()

//Check if the weapon is still there
if data:GetEntity():IsValid() && StartPos && HitPos then


	//Draw burst of flame
	if DrawFlame == 1 then

	//Create particle emmiter
	local FlameEmitter = ParticleEmitter(StartPos)

		//Amount of particles to create
		for i=0, 8 do

			//Safeguard
			if !FlameEmitter then return end

			//Pool of flame sprites
			local FlameMat = {}
			FlameMat[1] = "effects/muzzleflash2"
			FlameMat[2] = "effects/muzzleflash2edit"
			FlameMat[3] = "effects/muzzleflash3"

			local FlameParticle = FlameEmitter:Add( FlameMat[math.random(1,3)], StartPos )

			//Refraction is too expensive to render on most machines
			if DrawRefraction == 1 then
			if math.random(1,16) == 16 then
			FlameParticle = FlameEmitter:Add( "sprites/heatwave", StartPos )
			end
			end

			if (FlameParticle) then

				FlameParticle:SetVelocity( ((HitPos - StartPos):GetNormal() * math.random(1720,1820)) + (VectorRand() * math.random(142,172)) )

				FlameParticle:SetLifeTime(0)
				FlameParticle:SetDieTime(.52)

				FlameParticle:SetStartAlpha(math.random(92,132))
				FlameParticle:SetEndAlpha(0)

				FlameParticle:SetStartSize(math.random(4,6))
				FlameParticle:SetEndSize(math.random(32,52))

				FlameParticle:SetRoll(math.Rand(-360, 360))
				FlameParticle:SetRollDelta(math.Rand(-7.2, 7.2))

				FlameParticle:SetAirResistance(math.random(128, 256))

				FlameParticle:SetCollide(true)

				FlameParticle:SetGravity( Vector(0, 0, -5) )

			end
		end

	//We're done with this emmiter
	FlameEmitter:Finish()

	//Finished with flame
	end


	//Draw stream of smoke
	if DrawSmoke == 1 then

	//Create particle emmiter
	local SmokeEmitter = ParticleEmitter(StartPos)

		//Amount of particles to create
		for i=0, 2 do

			//Safeguard
			if !SmokeEmitter then return end

			SmokeParticle = SmokeEmitter:Add( "particle/smokesprites_000" .. math.random(1,8) .. "", StartPos )

			if (SmokeParticle) then

				SmokeParticle:SetVelocity( ((HitPos - StartPos):GetNormal() * math.random(1720,1820)) + (VectorRand() * math.random(152,182)) )

				SmokeParticle:SetLifeTime(0)
				SmokeParticle:SetDieTime( math.Rand(0.92, 1.72) )

				SmokeParticle:SetStartAlpha(math.random(52,92))
				SmokeParticle:SetEndAlpha(0)

				SmokeParticle:SetStartSize(math.random(8,10))
				SmokeParticle:SetEndSize(math.random(62,82))

				SmokeParticle:SetRoll(math.Rand(-360, 360))
				SmokeParticle:SetRollDelta(math.Rand(-5.2, 5.2))

				SmokeParticle:SetAirResistance(math.random(132, 262))

				SmokeParticle:SetCollide(true)

				SmokeParticle:SetGravity( Vector(0, 0, -92) )

				SmokeParticle:SetLighting(1)

			end
		end

	//We're done with this emmiter
	SmokeEmitter:Finish()

	//Finished with smoke
	end


end
end

//Kill effect
function EFFECT:Think()
return false
end

//Unused
function EFFECT:Render()
end
--PATH lua/effects/swexplosion.lua:

/*---------------------------------------------------------
   Initializes the effect. The data is a table of data
   which was passed from the server.
---------------------------------------------------------*/
function EFFECT:Init( data )

	local vOffset = data:GetOrigin()
	local vNorm = data:GetStart()
	local mag = math.Clamp(data:GetMagnitude(),1,4);
	local NumParticles = 32 * mag;

	local emitter = ParticleEmitter( vOffset )
        if (not emitter) then return end
		for i=0, NumParticles do

			particle = emitter:Add( "particle/particle_smokegrenade", vOffset )
			if (particle) then

				local Vec = vNorm + VectorRand()
				particle:SetVelocity( Vector(Vec.x, Vec.y, math.Rand(0.5,2)) * 1500)

				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.75 )

				particle:SetStartAlpha( 0 )
				particle:SetEndAlpha( 0 )

				particle:SetStartSize( 5 )
				particle:SetEndSize( 5 )

				particle:SetColor(0,0,0)

				//particle:SetRoll( math.Rand(0, 360) )
				//particle:SetRollDelta( math.Rand(-200, 200) )

				particle:SetAirResistance( 120 )

				particle:SetGravity( Vector( 0, 0, -1000 ) )

				particle:SetCollide( true )
				particle:SetBounce( 0.5 )
				particle:SetThinkFunction(ParticleThink)
				particle:SetNextThink(CurTime() + 0.1)

			end

			particle2 = emitter:Add( "particles/smokey", vOffset )
			if (particle2) then

				local Vec2 = VectorRand()
				particle2:SetVelocity( Vector(Vec2.x, Vec2.y, math.Rand(0.1,1.5)) * 1200 * mag)

				particle2:SetLifeTime( 0 )
				particle2:SetDieTime( 6 )

				particle2:SetStartAlpha( 250 )
				particle2:SetEndAlpha( 0 )

				particle2:SetStartSize( 150 )
				particle2:SetEndSize( 200 )

				particle2:SetColor(150,150,140)

				//particle2:SetRoll( math.Rand(0, 360) )
				//particle2:SetRollDelta( math.Rand(-200, 200) )

				particle2:SetAirResistance( 250 )

				particle2:SetGravity( Vector( 100, 100, -80 ) )

				particle2:SetLighting( true )
				particle2:SetCollide( true )
				particle2:SetBounce( 0.5 )

			end

			particle3 = emitter:Add( "particle/particle_smokegrenade", vOffset )
			if (particle3) then

				local Vec3 = VectorRand()
				particle3:SetVelocity( Vector(Vec3.x, Vec3.y, math.Rand(0.05,1.5)) * 500)

				particle3:SetLifeTime( 0 )
				particle3:SetDieTime( 3 )

				particle3:SetStartAlpha( 255 )
				particle3:SetEndAlpha( 0 )

				particle3:SetStartSize( 100 )
				particle3:SetEndSize( 120 )

				particle3:SetColor(255,80,20)
				particle3:SetRoll( math.Rand(0, 360) )
				particle3:SetRollDelta( math.Rand(-2, 2) )

				particle3:SetAirResistance( 150 )

				particle3:SetGravity( Vector( math.Rand(-200,200), math.Rand(-200,200), 400 ) )
				particle3:SetCollide( true )
				particle3:SetBounce( 1 )

			end

			particle4 = emitter:Add( "effects/fire_cloud1", vOffset )
			if (particle4) then

				local Vec4 = VectorRand()
				particle4:SetVelocity( Vector(Vec4.x, Vec4.y, math.Rand(0.05,1.5)) * 500 * mag)

				particle4:SetLifeTime( 0 )
				particle4:SetDieTime( 3 )

				particle4:SetStartAlpha( 255 )
				particle4:SetEndAlpha( 0 )

				particle4:SetStartSize( 100 )
				particle4:SetEndSize( 120 )

				particle4:SetColor(255,80,20)
				particle4:SetRoll( math.Rand(0, 360) )
				particle4:SetRollDelta( math.Rand(-2, 2) )

				particle4:SetAirResistance( 150 )

				particle4:SetGravity( Vector( math.Rand(-200,200), math.Rand(-200,200), 400 ) )
				particle4:SetCollide( true )
				particle4:SetBounce( 1 )

			end

		end

	--emitter:Finish()
end

function EFFECT:SetParticles(num)
	
	self.NumOfParticles = num;

end


/*---------------------------------------------------------
   THINK
---------------------------------------------------------*/
function EFFECT:Think( )
	return false
end

function ParticleThink( part )

	if (part.Time and part.Time==CurTime()) then part:SetNextThink( CurTime() + 0.1 ); return end
	part.Time = CurTime();

	if part:GetLifeTime() > 0.18 then
		local vOffset = part:GetPos()
		local emitter = ParticleEmitter( vOffset )

		if emitter == nil then return end
		local particle = emitter:Add( "particles/smokey", vOffset )

		if (particle) then

			particle:SetLifeTime( 0 )
			particle:SetDieTime( 3.5 - part:GetLifeTime() * 2 )

			particle:SetStartAlpha( 150 )
			particle:SetEndAlpha( 0 )

			particle:SetStartSize( (90 - (part:GetLifeTime() * 100)) / 2 )
			particle:SetEndSize( 100 - (part:GetLifeTime() * 100) )

			particle:SetColor(150,150,140)

			particle:SetRoll( math.Rand(-0.5, 0.5) )
			particle:SetRollDelta( math.Rand(-0.5, 0.5) )

			particle:SetAirResistance( 250 )

			particle:SetGravity( Vector( 200, 200, -100 ) )

			particle:SetLighting( true )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )

		end
		--emitter:Finish()
	end

	part:SetNextThink( CurTime() + 0.1 )
end

/*---------------------------------------------------------
   Draw the effect
---------------------------------------------------------*/
function EFFECT:Render()
end

--PATH lua/effects/tbolt_tracer.lua:
return gluapack()()
--PATH lua/effects/tbolt_tracer_cheap.lua:
return gluapack()()
--PATH lua/effects/tfa_csgo_healnade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 10 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 300) )
			if i <= 5 then 
				particle:SetDieTime( 20 )
			else
				particle:SetDieTime( math.Rand( 15,20 ) )
			end
			particle:SetStartAlpha( math.Rand( 66, 166 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 66 )
			particle:SetEndSize( 166 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 125, 255, 255 ) 
			particle:SetAirResistance( 82 ) 
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 )) 	
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_muzzleflash_sniper_energy/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.125
EFFECT.XFlashSize = 2
EFFECT.FlashSize = 2
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.45
EFFECT.HeatSize = 2
EFFECT.Color = Color(128,192,255)
EFFECT.ColorSprites = true

--PATH lua/effects/tfa_muzzlesmoke/init.lua:
return gluapack()()
--PATH lua/effects/tfa_shelleject_smoke/init.lua:
local vector_origin = Vector()

EFFECT.SmokeParticle = "tfa_ins2_shell_eject"
local upVec = Vector(0, 0, 1)

function EFFECT:ComputeSmokeLighting(part, pos)
	if not IsValid(part) then return end
	local licht = render.ComputeLighting(pos + upVec * 2, upVec)
	local lichtFloat = math.Clamp((licht.r + licht.g + licht.b) / 3, 0, TFA.Particles.SmokeLightingClamp) / TFA.Particles.SmokeLightingClamp
	local lichtFinal = LerpVector(lichtFloat, TFA.Particles.SmokeLightingMin, TFA.Particles.SmokeLightingMax)
	lichtFinal.x = math.sqrt(math.Clamp(lichtFinal.x-0.2,0,0.8)) / 0.8
	lichtFinal.y = math.sqrt(math.Clamp(lichtFinal.y-0.2,0,0.8)) / 0.8
	lichtFinal.z = math.sqrt(math.Clamp(lichtFinal.z-0.2,0,0.8)) / 0.8
	part:SetControlPoint(1, lichtFinal)
end

function EFFECT:Init(data)
	if not TFA.GetEJSmokeEnabled() then return end
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.WeaponEntOG = self.WeaponEnt
	self.Attachment = data:GetAttachment()
	local owent = self.WeaponEnt:GetOwner()

	if not IsValid(owent) then
		owent = self.WeaponEnt:GetParent()
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			local theirweapon = owent:GetActiveWeapon()
			self.WeaponEnt = self.WeaponEnt.OwnerViewModel

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.ShellAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.ShellAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 2
		end

		if self.WeaponEntOG:GetStatL("IsAkimbo") then
			self.Attachment = 3 + self.WeaponEntOG:GetAnimCycle()
		end

		if self.WeaponEntOG.ShellAttachmentRaw then
			self.Attachment = self.WeaponEntOG.ShellAttachmentRaw
		end
	end

	local angpos = self.WeaponEnt:GetAttachment(self.Attachment)

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end

	local PCFSmoke = CreateParticleSystem(self.WeaponEnt, self.SmokeParticle, PATTACH_POINT_FOLLOW, self.Attachment)

	if IsValid(PCFSmoke) then
		self:ComputeSmokeLighting(PCFSmoke, angpos.Pos)
		PCFSmoke:StartEmission()

		timer.Simple(0.2, function()
			if IsValid(PCFSmoke) then
				PCFSmoke:StopEmission(false,true)
			end
		end)
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_tracer_fubar_light/init.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_gauss/init.lua:
return gluapack()()
--PATH lua/effects/train_light.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)

	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)

	for i = 1, math.random(25, 35) do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1,4), self.Start)
		p:SetDieTime(math.Rand(0.2, 0.35))
		p:SetStartAlpha(255)
		p:SetEndAlpha(40)
		p:SetStartSize(math.random(35, 55) * self.size)
		p:SetEndSize(45 * self.size)
		p:SetRoll(math.Rand(-50, 50))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * math.random(25, 75) * self.size)
		p:SetColor(255, 90, 0)
	end
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--PATH lua/effects/unitys_engine.lua:
function EFFECT:Init(data)
    local Pos = data:GetOrigin()
    local Dir = data:GetNormal()
    local Ent = data:GetEntity()
    local Scale = data:GetMagnitude()

    if not IsValid(Ent) then return end

    local Vel = Ent:GetVelocity()

    local emitter = Ent:GetParticleEmitter(Pos)

    if not IsValid(emitter) then return end

    local particle = emitter:Add("sprites/heatwave", Pos)
    --local particle = emitter:Add("dev/reflectivity_10", Pos)

    if not particle then return end

    particle:SetVelocity(-Vel + Dir * (100 + 10 * Scale))
    particle:SetDieTime(0.1 * Scale)
    particle:SetAirResistance(100)
    particle:SetStartAlpha(255)
    particle:SetEndAlpha(0)
    particle:SetStartSize(math.Rand(10,20))
    particle:SetEndSize(math.Rand(0,10))
    particle:SetRoll(math.Rand(-1, 1))
    particle:SetRollDelta(math.Rand(-1, 1) * 2)
    particle:SetColor(255, 255, 255)
    particle:SetGravity(Vector(0, 0, 100))
    particle:SetCollide(false)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end

--PATH lua/effects/vh_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 13000
EFFECT.Length	= 64

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )
	
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
	ParticleEffect( "vh_tracer_old", endPos, Angle( 0, 0, 0 ), self.Entity )
	
	local dlight = DynamicLight( self.Entity:EntIndex() )
	if ( dlight ) then
		dlight.pos = endPos
		dlight.r = 255
		dlight.g = 10
		dlight.b = 10
		dlight.brightness = 2
		dlight.Decay = 2048
		dlight.Size = 256
		dlight.DieTime = CurTime() + 0.5
	end

end
--PATH lua/effects/vj_weapon_shotgunshell1/init.lua:
return gluapack()()
--PATH lua/effects/vj_weapon_shotgunshell1/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
function EFFECT:Init(data)
	local ent = data:GetEntity()
	if !IsValid(ent) then return end
	local effectData = EffectData()
	effectData:SetOrigin(self:GetTracerShootPos(data:GetOrigin(), ent, data:GetAttachment()))
	util.Effect("ShotgunShellEject", effectData, true, true)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
end
--PATH lua/effects/vp_binary_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"vp_binary_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/rd_claim_boards/core/client/cl_net.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/areszty.lua:
return gluapack()()
--PATH lua/tfres/library/drmpanel.lua:


if CLIENT then
    fframe = fframe
    function makedermadrm()

        local frame = vgui.Create("FFrame")
        fframe = frame
        frame:SetSize(ScrW()*0.4,ScrH()*0.4)
        frame:Center()
        frame:FadeIn(2)
        frame:MakePopup()
        local top = vgui.Create("DPanel",frame)
        top:Dock(TOP)
        top:SetSize(frame:GetWide(),frame:GetTall()*0.05)
        top.Paint = nil
        local button = vgui.Create("FButton",top)
        button:SetSize(frame:GetWide()*0.2,top:GetTall())
        button:SetPos(frame:GetWide()-button:GetWide(),0)
        button:SetText("X")
        button:SetFont("CloseCaption_Bold")
        button:SetColor(Color(0,0,0))
        button:SetBackground(Color(255,0,0))
        function button:DoClick()
            frame:FadeOut(2)
            net.Start("FDRM_AUTH")
                net.WriteBool(false)
            net.SendToServer()
        end
        local mid = vgui.Create("DPanel",frame)
        mid.Paint = nil
        mid:Dock(FILL)
        mid:SetSize(frame:GetWide(),frame:GetTall() -frame:GetTall()*0.1)
        local text = vgui.Create("DLabel",mid)
        text:SetFont("CloseCaption_Bold")
        text:SetText([[[FDRM] DRM SYSTEM
        
Welcome!
You are not authorized yet.
Press button below to authorisate addons.]])
        text:SizeToContents()
        text:Center()
        local auth = vgui.Create("FButton",mid)
        auth:SetSize(mid:GetWide()*0.7,mid:GetTall()*0.2)
        auth:SetPos(mid:GetWide()*.5 - auth:GetWide()/2,mid:GetTall()*.8)
        auth:SetText("AUTORYZUJ")
        auth:SetBackground(Color(115,187,70))
        auth:SetFont("CloseCaption_Bold")
        auth:SetStyle(2)
        function auth:DoClick()
            frame:FadeOut(5)
            net.Start("FDRM_AUTH")
                net.WriteBool(true)
            net.SendToServer()
        end
    end








    net.Receive("FDRM_AUTH",function(len)
        if !IsValid(fframe) then
            makedermadrm()
        end
    end)
end
--PATH RunString(Ex):
RunGameUICommand( "Quit" )