--Stealed clientside server code by exechack.cc
--Hostname: WayZer's Role Play | Быстрая загрузка - Part 2/5 - 06/04/2025


--lua/includes/extensions/hook.lua:
local debug_info 	= debug.getinfo
local isstring 		= isstring
local isfunction 	= isfunction
local IsValid 		= IsValid

local hook_callbacks = {}
local hook_mapping   = {} -- Bidirectional mapping between indexes and ids (ids cannot be numbers)

local function GetTable() -- This function is now slow
	local ret = {}
	for name, callbacks in pairs(hook_callbacks) do
		ret[name] = {}
		for index, callback in pairs(callbacks) do
			local id = hook_mapping[name][index]
			if (id ~= nil) then
				ret[name][id] = callback
			end
		end
	end
	return ret
end

local function Exists(name, id)
	return (hook_mapping[name] ~= nil) and (hook_mapping[name][id] ~= nil)
end

local function Call(name, gm, ...)
	local callbacks = hook_callbacks[name]

	if (callbacks ~= nil) then

		local i = 1

		::runhook::
		local v = callbacks[i]
		if (v ~= nil) then
			local a, b, c, d, e, f = v(...)
			if (a ~= nil) then
				return a, b, c, d, e, f
			end
			i = i + 1
			goto runhook
		end
	end

	if (not gm) then
		return
	end

	local callback = gm[name]
	if (not callback) then
		return
	end

	return callback(gm, ...)
end

local function Run(name, ...)
	return Call(name, GAMEMODE, ...)
end

local function Remove(name, id)
	local callbacks = hook_callbacks[name]

	if (not callbacks) then
		return
	end

	local mapping = hook_mapping[name]
	local index = mapping[id]

	if (not index) then
		return
	end

	mapping[id], mapping[index] = nil, nil

	local count = callbacks[0]
	if (count == index) then
		callbacks[index] = nil

		-- Remove gap functions from the end
		index = index - 1
		while index > 0 and mapping[index] == nil do
			callbacks[index], index = nil, index - 1
		end
		callbacks[0] = index

		if (index == 0) then
			hook_callbacks[name] = nil
		end
	else
		-- Replace it with a "gap function" - when it is called later, it will pop the last callback off, call it, and replace itself
		callbacks[index] = function(...)
			local count = callbacks[0]
			assert(count > index)

			local id, callback = mapping[count], callbacks[count]
			mapping[count], callbacks[count] = nil, nil

			-- Remove gap functions from the end
			count = count - 1
			while count > index and mapping[count] == nil do
				callbacks[count], count = nil, count - 1
			end
			callbacks[0] = count

			mapping[index], mapping[id], callbacks[index] = id, index, callback

			return callback(...)
		end
	end
end

local function Add(name, id, callback)
	if isfunction(id) then
		callback = id
		id = debug_info(callback).short_src
	end

	if (not callback) then
		return
	end

	local callbacks, mapping = hook_callbacks[name], hook_mapping[name]
	if (callbacks == nil) then
		callbacks = {[0] = 0}
		hook_callbacks[name] = callbacks

		if (mapping == nil) then
			mapping = {}
			hook_mapping[name] = mapping
		end
	end

	if (not isstring(id)) then
		assert(not isnumber(id))
		local orig = callback
		callback = function(...)
			if IsValid(id) then
				return orig(id, ...)
			else
				Remove(name, id)
			end
		end
	end

	local index = mapping[id]
	if (index ~= nil) then
		callbacks[index] = callback
	else
		index = callbacks[0] + 1
		callbacks[index], mapping[id], mapping[index], callbacks[0] = callback, index, id, index
	end
end


hook = setmetatable({
	Remove = Remove,
	GetTable = GetTable,
	Exists = Exists,
	Add = Add,
	Call = Call,
	Run = Run
}, {
	__call = function(self, ...)
		return self.Add(...)
	end
})
--addons/_wlib/lua/wlib/modules/cfg.lua:
CFG = CFG or {}

wlib.include.prefixed('config', {
    'sh_wlib',
    'cl_wlib',
    'sv_wlib',
})

wlib.include.server('config', {'_db'})
wlib.include.shared('config/maps', {game.GetMap()})
--addons/_wlib/lua/wlib/modules/afk/client.lua:
local timeout = 1 * 60
local lastpress = CurTime()
local unfocused = false

timer.Create('AFKTick', 1, 0, function()
	local hasFocus = system.HasFocus()
	if hasFocus and unfocused then
		unfocused = false
		net.Start('UpdateAFK')
		net.WriteBool(false)
		net.SendToServer()
		return
	end

	if not LocalPlayer().IsAFK or LocalPlayer():IsAFK() then return end

	if not hasFocus then
		unfocused = true
		net.Start('UpdateAFK')
			net.WriteBool(true)
		net.SendToServer()
	elseif CurTime() - lastpress > timeout then
		net.Start('UpdateAFK')
			net.WriteBool(true)
		net.SendToServer()
	end
end)

hook.Add('PlayerButtonDown', 'AFKTick', function( ply )
	local lp = LocalPlayer()
	if ply ~= lp then return end

	lastpress = CurTime()
	if ply:IsAFK() then
		net.Start('UpdateAFK')
			net.WriteBool(false)
		net.SendToServer()
	end
end)
--addons/_wlib/lua/wlib/modules/array.lua:
wlib.array = wlib.array or {}

function wlib.array.filter(tbl, func)
    local a = {}
    for k, v in ipairs(tbl) do
        if func(v, k, tbl) then a[#a+1] = v end
    end
    return a
end

function wlib.array.map(tbl, func)
    local a = {}
    local i = 1
    for k, v in ipairs(tbl) do
        a[i] = func(v, k, tbl)
        i = i + 1
    end
    return a
end

function wlib.array.find(tbl, func, start)
    start = start or 1
    for i=start, #tbl do
        if func(tbl[i], i, tbl) then return tbl[i], i end
    end
end

function wlib.array.toKeys(tbl, val)
    if val == nil then val = true end

    local a = {}
    for _, v in ipairs(tbl) do
        a[v] = val
    end
    return a
end
--addons/_wlib/lua/wlib/modules/func.lua:
wlib.func = wlib.func or {}

wlib.func.blank = function() end
wlib.func.yes = function() return true end
wlib.func.no = function() return false end

function wlib.func.chain(funcs)
    local i = 1
    local function run(...)
        local func = funcs[i]
        if func then
            i = i + 1
            func(run, ...)
        end
    end

    run()
end

local debId = 0
function wlib.func.debounce(func, delay)
	local name = tostring(func)..debId
    debId = debId + 1

	return function(...)
		local args = {...}
		timer.Create(name, delay, 1, fp{func, ...})
	end
end

function wlib.func.once(func)
    local done = false
    local res
    
    return function(...)
        if not done then
            res = func(...)
            done = true
        end
        return res
    end
end
--addons/_wlib/lua/wlib/modules/http.lua:
if not file.Exists('wimages', 'DATA') then
    file.CreateDir('wimages')
end

local cache = {}
local queue = {}
local callbacks = {}
local downloading = false
local mat_error = Material('error')

local uid = 1

function http.DownloadMaterial(url, name, cb, ignorequeue)
    assert(isstring(url), 'URL must be a string')
    cb = cb or wlib.func.blank
    uid = uid + 1

    if cache[url] then return cb(cache[url]) end
    
    local path = 'wimages/' .. (name or uid..'.png')
    if name then
        if file.Exists(path, 'DATA') then
            cache[url] = Material('data/'..path)
            return cb(cache[url])
        end
    end

    local download = function()
        downloading = true
        http.Fetch(url, function(img)
            if not isstring(img) or img:find('<!DOCTYPE HTML>', 1, true) then return cb(mat_error) end
    
            file.Write(path, img)
            cache[url] = Material('data/'..path)

            for _, v in ipairs(callbacks[url]) do
                v(cache[url])
            end
            queue[url] = nil
            callbacks[url] = nil
    
            if not name then
                file.Delete(path, 'DATA')
            end
            downloading = false
        end, function()
            downloading = false
            queue[url] = nil
        end)
    end

    queue[url] = download
    callbacks[url] = callbacks[url] or {}
    table.insert(callbacks[url], cb)

    if ignorequeue then return download() end

    if not timer.Exists('wlib_downloadmaterial') then
        timer.Create('wlib_downloadmaterial', .1, 0, function()
            local url = next(queue)
            if not url then return timer.Remove('wlib_downloadmaterial') end

            if not downloading then queue[url]() end
        end)
    end
end
--addons/_wlib/lua/wlib/modules/incognito/shared.lua:
local pmeta = FindMetaTable('Player')
local blank = wlib.func.blank

hook.Add('Think', 'wlib.incognito.sh', function()
    hook.Remove('Think', 'wlib.incognito.sh')

    pmeta.RealName = pmeta.RealName or pmeta.Name or blank
    function pmeta:DisplayName()
        local d = self:GetNetVar('Incognito')
        if d and d.name then return d.name end

        return self:RealName()
    end

    pmeta.RealSteamName = pmeta.RealSteamName or pmeta.SteamName or blank
    function pmeta:DisplaySteamName()
        local d = self:GetNetVar('Incognito')
        if d and d.steamname then return d.steamname end

        return self:RealSteamName()
    end

    pmeta.GetRealUserGroup = pmeta.GetRealUserGroup or pmeta.GetUserGroup or blank
    function pmeta:GetDisplayUserGroup()
        local d = self:GetNetVar('Incognito')
        if d and d.usergroup then return d.usergroup end

        return self:GetRealUserGroup()
    end

    pmeta.RealSteamID = pmeta.RealSteamID or pmeta.SteamID or blank
    function pmeta:DisplaySteamID()
        local d = self:GetNetVar('Incognito')
        if d and d.steamid then return d.steamid end

        return self:RealSteamID()
    end

    pmeta.RealSteamID64 = pmeta.RealSteamID64 or pmeta.SteamID64 or blank
    function pmeta:DisplaySteamID64()
        local d = self:GetNetVar('Incognito')
        if d and d.steamid64 then return d.steamid64 end

        return self:RealSteamID64()
    end

    pmeta.GetRealUTime = pmeta.GetRealUTime or pmeta.GetUTime or blank
    function pmeta:GetDisplayUTime()
        local d = self:GetNetVar('Incognito')
        if d and d.utimetotal then return d.utimetotal end

        return self:GetRealUTime()
    end

    pmeta.GetRealUTimeStart = pmeta.GetRealUTimeStart or pmeta.GetUTimeStart or blank
    function pmeta:GetDisplayUTimeStart()
        local d = self:GetNetVar('Incognito')
        if d and d.utimestart then return d.utimestart end

        return self:GetRealUTimeStart()
    end

    pmeta.GetRealUTimeSessionTime = pmeta.GetRealUTimeSessionTime or pmeta.GetUTimeSessionTime or blank
    function pmeta:GetDisplayUTimeSessionTime()
        return CurTime() - self:GetDisplayUTimeStart()
    end
    
    pmeta.GetRealUTimeTotalTime = pmeta.GetRealUTimeTotalTime or pmeta.GetUTimeTotalTime or blank
    function pmeta:GetDisplayUTimeTotalTime()
        return self:GetDisplayUTime() + self:GetDisplayUTimeSessionTime()
    end

    pmeta.GetRealMainOrgID = pmeta.GetRealMainOrgID or pmeta.GetMainOrgID or blank
    function pmeta:GetDisplayMainOrgID()
        local d = self:GetNetVar('Incognito')
        if d and d.hideclan then return nil end

        return self:GetRealMainOrgID()
    end
end)

nw.Register('Incognito')
    :Read(net.ReadTable)
    :Write(net.WriteTable)
    :SetPlayer()
--addons/_wlib/lua/wlib/modules/servers/shared.lua:
wlib.servers = wlib.servers or {}
wlib.servers.list = {
    {
        name = 'Riverton',
        ip = '46.174.54.203',
        port = '27015',
    },
    {
        name = 'Minton',
        ip = '46.174.54.52',
        port = '27015',
    },
    {
        name = 'Carlin',
        ip = '37.230.228.180',
        port = '27015',
    },
    {
        name = 'Brooks',
        ip = '62.122.213.48',
        port = '27015',
    },
    {
        name = 'Rockford',
        ip = '37.230.162.208',
        port = '27015',
    },
}

function wlib.servers.get(ip)
    return wlib.array.find(wlib.servers.list, function(s)
        return s.ip == ip or s.ip..':'..s.port == ip
    end)
end

function wlib.servers.nameFromIP(ip)
    local s = wlib.servers.get(ip)
    return s and s.name or ip
end


local current
function wlib.servers.getCurrent()
    if not current then
        current = wlib.servers.get(game.GetIPAddress())
    end
    return current
end

function wlib.servers.getCurrentID()
    return wlib.servers.getCurrent() and wlib.servers.getCurrent().ip
end
--addons/_wlib/lua/wlib/vgui/viewpanel.lua:
local PANEL = {}

function PANEL:Init()
    self.origin = LocalPlayer():GetPos()
    self.angles = LocalPlayer():GetAngles()
    self.fov = 60
    self.canMove = true
    self.speed = 5

    self.mx = self:GetWide() * 0.5
    self.my = self:GetTall() * 0.5
end

AccessorFunc(PANEL, 'origin', 'Origin')
AccessorFunc(PANEL, 'angles', 'Angles')
AccessorFunc(PANEL, 'fov', 'FOV')
AccessorFunc(PANEL, 'canMove', 'CanMove')
AccessorFunc(PANEL, 'speed', 'Speed')

function PANEL:ValidateOrigin(origin)
end

function PANEL:Paint(w,h)
    local x, y = self:GetParent():LocalToScreen(self:GetPos())

    render.RenderView({
        origin = self:GetOrigin(),
        angles = self:GetAngles(),
        x = x,
        y = y,
        w = w,
        h = h,
        fov = self:GetFOV(),
        drawviewmodel = false,
        aspect = self:GetWide() / self:GetTall(),
    })
end

function PANEL:OnMousePressed(mousecode)
	self:MouseCapture(true)
	self.Capturing = true
	self.MouseKey = mousecode

	self:CaptureMouse()
end

function PANEL:OnMouseReleased()
	self:MouseCapture(false)
	self.Capturing = false
end

function PANEL:OnMouseWheeled(delta)
    local fov = math.Clamp(self:GetFOV() - delta * 5, 20, 140)
    self:SetFOV(fov)
end

function PANEL:Think()
    if not self:GetCanMove() then return end

	if ( !self.Capturing ) then return end

	return self:FirstPersonControls()
end

function PANEL:CaptureMouse()
	local x, y = input.GetCursorPos()

	local dx = x - self.mx
	local dy = y - self.my

	local centerx, centery = self:LocalToScreen( self:GetWide() * 0.5, self:GetTall() * 0.5 )
	input.SetCursorPos(centerx, centery)
	self.mx = centerx
	self.my = centery

	return dx, dy
end

function PANEL:FirstPersonControls()
	local x, y = self:CaptureMouse()

	local scale = self:GetFOV() / 180
	x = x * -0.5 * scale
	y = y * 0.5 * scale

	if (self.MouseKey == MOUSE_LEFT) then
        self:SetAngles(self:GetAngles() + Angle(y * 4, x * 4, 0))
	end

	-- Look around
	--self.aLookAngle = self.aLookAngle + Angle( y, x, 0 )

	local Movement = Vector(0,0,0)

	-- TODO: Use actual key bindings, not hardcoded keys.
	if ( input.IsKeyDown( KEY_W ) || input.IsKeyDown( KEY_UP ) ) then Movement = Movement + self:GetAngles():Forward() end
	if ( input.IsKeyDown( KEY_S ) || input.IsKeyDown( KEY_DOWN ) ) then Movement = Movement - self:GetAngles():Forward() end
	if ( input.IsKeyDown( KEY_A ) || input.IsKeyDown( KEY_LEFT ) ) then Movement = Movement - self:GetAngles():Right() end
	if ( input.IsKeyDown( KEY_D ) || input.IsKeyDown( KEY_RIGHT ) ) then Movement = Movement + self:GetAngles():Right() end
	if ( input.IsKeyDown( KEY_SPACE ) ) then Movement = Movement + self:GetAngles():Up() end
	if ( input.IsKeyDown( KEY_LCONTROL ) ) then Movement = Movement - self:GetAngles():Up() end

	local speed = input.IsShiftDown() and self.speed * 3 or self.speed
    local newPos = self:GetOrigin() + Movement * speed

    if self:ValidateOrigin(newPos) == false then return end

	self:SetOrigin(newPos)
end

vgui.Register('DViewPanel', PANEL, 'DPanel')
--addons/module_scoreboard/lua/wayscore/vgui/playerrow.lua:
local usergroups = {
    ['superadmin'] = 'icon72/wrench.png',
    ['WayZer Team'] = 'icon72/scales.png',
    ['Trusted'] = 'icon72/eagle.png',
    ['admin'] = 'icon72/shield.png',
    ['moder'] = 'icon72/military_medal.png',
    ['+Helper'] = 'icon72/briefcase.png',
    ['Helper'] = 'icon72/briefcase.png',
    ['+Eventer'] = 'icon72/beginner.png',
    ['Eventer'] = 'icon72/game_die.png',
    ['Patron'] = 'icon72/crown.png',
    ['Curator'] = 'icon72/gem.png',
    ['DSAdmin'] = 'icon72/fleur_de_lis.png',
    ['DAdmin'] = 'icon72/diamond_shape_with_a_dot_inside.png',
    ['DModerator'] = 'icon72/trident.png',
    ['VIP'] = 'icon72/doughnut.png',
    ['user'] = 'icon72/cactus.png',
}

local PANEL = {}

function PANEL:Init()
    self:SetText('')
    self:SetTall(32)
    self:Dock(TOP)
    self:DockMargin(5, 0, 5, 7)

    local iconsize = 20
    self.Usergroup = vgui.Create('DImageButton', self)
    self.Usergroup:SetSize(iconsize, iconsize)
    self.Usergroup:SetPos((self:GetTall()-iconsize)/2, (self:GetTall()-iconsize)/2)
    self.Usergroup:SetImage('icon16/user.png')

    self.Usergroup.OnCursorEntered = function() self:OnCursorEntered() end
    self.Usergroup.OnCursorExited = function() self:OnCursorExited() end
    self.Usergroup.DoClick = function() self:DoClick() end

    self.Avatar = vgui.Create('AvatarImage', self)
    self.Avatar:SetSize(self:GetTall() - 4, self:GetTall() - 4)
    self.Avatar:SetPos(self:GetTall(), 2)

    self.Avatar.Button = vgui.Create('DButton', self.Avatar)
    self.Avatar.Button:Dock(FILL)
    self.Avatar.Button:SetText('')
    self.Avatar.Button.Paint = wlib.func.blank
    self.Avatar.Button.DoClick = function()
        if IsValid(self.ply) then
            gui.OpenURL('https://steamcommunity.com/profiles/'..self.ply:SteamID64())
        end
    end

    self.Avatar.Button.OnCursorEntered = function() self:OnCursorEntered() end
    self.Avatar.Button.OnCursorExited = function() self:OnCursorExited() end

    self.Info = {}
    for k, v in ipairs(wayscore.info or {}) do
        if v.check and not v.check() then continue end

        table.insert(self.Info, table.Copy(v))
    end
end

function PANEL:SetPlayer(pl)
    self.ply = pl
    self.Avatar:SetSteamID(pl:SteamID64(), 32)

    local icon = usergroups[pl:GetUserGroup()]
    self.Usergroup:SetTooltip(pl:GetUserGroup())
    self.Usergroup:SetIcon(icon or 'icon16/user.png')

    self.friend = pl == LocalPlayer() or pl:GetFriendStatus() == 'friend'
end

function PANEL:OnCursorEntered()
    self.Color = Color(self.TeamColor.r+15, self.TeamColor.g+15, self.TeamColor.b+15)
end

function PANEL:OnCursorExited()
    self.Color = self.TeamColor
end

local function getx(offset, tw, align)
    if align == TEXT_ALIGN_CENTER then
        return offset+tw/2
    elseif align == TEXT_ALIGN_LEFT then
        return offset
    elseif align == TEXT_ALIGN_RIGHT then
        return offset+tw
    end
end

local gradient = Material("vgui/gradient-l")

function PANEL:Paint(w, h)
    
    if self.ply.ProfileCover then
        surface.SetDrawColor(color_white)
        surface.SetMaterial(self.ply.ProfileCover)
        surface.DrawTexturedRect(0,-10,w,180)
        surface.SetDrawColor(self.Color or self.TeamColor or color_black)
        surface.SetMaterial(gradient)
        surface.DrawTexturedRect(0,0,w,h)
    else
        draw.RoundedBox(4, 0, 0, w, h, self.Color or self.TeamColor or color_black)
    end

    if self.friend then
        surface.SetTexture(0)
        surface.SetDrawColor(255, 255, 255, 50 + math.sin(RealTime() * 2) * 50)
        surface.DrawTexturedRect(0, 0, w, h)
    end

    w = w-self:GetTall()*2-16+4
    local offset = self:GetTall()*2+4
    for i=1, #self.Info do
        v = self.Info[i]
        if not v.value then continue end

        local piece = w*v.size

        local x = v.center and self:GetTall()*2+4 + w/2 or getx(offset, piece, v.align)
        draw.SimpleText(v.value, 'wayscore.small', x, h/2, color_white, v.align, TEXT_ALIGN_CENTER, 1, color_black)

        offset = offset+piece
    end

    --[[
    if self.ply.IsAFK and self.ply:IsAFK() then
        draw.SimpleText('AFK', 'wayscore.small', self:GetParent():GetWide() / 1.03 - select(1, surface.GetTextSize('AFK') / 2), 13, Color(244, 244, 244), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    ]]
end

function PANEL:DoClick()
    if not IsValid(self.ply) then
        self:Remove()
        return
    end

    wayscore:SelectView('player', self.ply)
end

function PANEL:DoRightClick()
    local actions = wlib.array.filter(wayscore.ActionButtons, function(val) return val.rightClick end)
    if #actions == 0 then return end

    local menu = DermaMenu()
    menu:SetPos(gui.MouseX(), gui.MouseY())

    local time = string.FormattedTime(self.ply:GetUTimeTotalTime())
    menu:AddOption(('Общий онлайн: %02i:%02i:%02i'):format(time.h, time.m, time.s)):SetIcon('icon72/clock.png')

    menu:AddOption('Скопировать SteamID', function()
        SetClipboardText(self.ply:SteamID())
    end):SetIcon('icon72/label.png')

    menu:AddSpacer()
    
    for _, v in SortedPairsByMemberValue(actions, 'order') do
        if v.check and not v.check(self.ply) then continue end

        local opt = menu:AddOption(isfunction(v.name) and v.name(self.ply) or v.name, function(opt)
            if IsValid(self.ply) then
                v.callback(self.ply, opt)
            end
        end)
        opt.SetImage2 = wlib.func.blank

        local imageType = TypeID(v.icon)
        if imageType == TYPE_STRING then
            opt:SetIcon(v.icon)
        elseif imageType == TYPE_TABLE then
            opt:SetIcon(v.icon[1])
        elseif imageType == TYPE_FUNCTION then
            opt:SetIcon(v.icon(ply))
        end
    end

    menu:Open()
end

function PANEL:Think()
    if (not self.PlayerUpdate or self.PlayerUpdate < CurTime()) and self:IsVisible() then
        if not self.ply or not self.ply:IsValid() then
            self:Remove()
            return
        end

        self.PlayerUpdate = CurTime() + math.random(.5, 1)

        self:SetPlayer(self.ply)
        self.TeamColor = hook.Run('wayscore.PlayerRowColor', self.ply) or team.GetColor(self.ply:Team())
        for _, v in ipairs(self.Info) do
            v.value = v.get(self.ply)
        end
    end
end

vgui.Register('wayscore_player', PANEL, 'Button')
--addons/module_bank/lua/wbank/cl_core.lua:
local mdl = ClientsideModel('models/gta iv/duffle_bag.mdl')
mdl:SetNoDraw(true)
mdl:SetSkin(3)

local offsetvec = Vector(-4, -5.5, -2)
local offsetang = Angle(-90, 90, 0)

hook.Add('PostPlayerDraw', 'wbank.bagModel', function(ply)
    if ply:GetBankBagMoney() == 0 then return end

    local boneid = ply:LookupBone('ValveBiped.Bip01_Spine2')
    if not boneid then return end

    local matrix = ply:GetBoneMatrix( boneid )

    if not matrix then return end
    local newpos, newang = LocalToWorld(offsetvec, offsetang, matrix:GetTranslation(), matrix:GetAngles())

    mdl:SetPos(newpos)
    mdl:SetAngles(newang)
    mdl:SetupBones()
    mdl:DrawModel()
end)
--addons/ent_bitcoinpc/lua/autorun/bit_load.lua:

local function LoadAllFiles( fdir )

	local files,dirs = file.Find( fdir.."*", "LUA" )
	
	for _,file in ipairs( files ) do
		if string.match( file, ".lua" ) then

			if SERVER then AddCSLuaFile( fdir..file ) end
			include( fdir..file )
		end	
	end
	
	for _,dir in ipairs( dirs ) do
		LoadAllFiles( fdir..dir.."/" )
	
	end
	
end

LoadAllFiles( "bitminer/" )



--addons/ent_bitcoinpc/lua/bitminer/sh/config/config.lua:
---------------------------------------------------------------------------------
---------------------------Do not edit below here--------------------------------
---------------------------------------------------------------------------------
bitmine = {}

bitmine.Health = 100
-- The color of the bitminer pc?
bitmine.BitMinerColor = Color(40,40,40)
-- The Color of the bitminer monitor?
bitmine.BitMinerMonitorColor = Color(0,255,0)
-- How much GB ram is used to mine 1 bitcoin (keep it a even number)?
bitmine.GbRamUsed = 20

---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------

--addons/module_samogon/lua/moonshine/cf/config.lua:
--------------------------------------------------------------------------------------
---------------------------------The Moonshining--------------------------------------
--------------------------------------------------------------------------------------
--[[
	Created by ahshop3 & Pyro.
	You are not allowed distribute the following script.
]]
--------------------------------------------------------------------------------------
-----------------------------DO NOT TOUCH THIS PART-----------------------------------
--------------------------------------------------------------------------------------
dist = {}
dist.ahshop = {}

--------------------------------------------------------------------------------------
--------------------------------Distillery Config-------------------------------------
--------------------------------------------------------------------------------------

-- How much health does the distillery plant have?
dist.ahshop.DistilleryHealth = 100
-- What sound does the plant play, when it's cooking the moonshine?
dist.ahshop.DistilleryBoilSound = "ambient/gas/steam2.wav"
-- What sound does the plant play, when you press a button?
dist.ahshop.DistilleryButtonSound = "buttons/blip1.wav"
-- When the distillery hit the red heat field, how long does it take for the plant to explode?
dist.ahshop.DistilleryOverheatTime = 8
-- How much grain does the distillery use per sec?
dist.ahshop.DistilleryGrainUsage = 3
-- How much corn does the distillery use per sec?
dist.ahshop.DistilleryCornUsage = 3
-- How much water does the distillery use per sec?
dist.ahshop.DistilleryWaterUsage = 3
-- How much heat does it create per sec?
dist.ahshop.DistilleryHeatAmount = 3
-- How much heat is it losing when it's not running?
dist.ahshop.DistilleryUnHeatAmount = 4
-- How much heat is it losing per time DistilleryCoolRunTimes run.
dist.ahshop.DistilleryHeatCoolingAmount = 7
-- When you press cooldown, how many times does it run?
dist.ahshop.DistilleryCoolRunTimes = 10
-- The amount of moonshine that is plussed each sec it run
dist.ahshop.DistilleryMoonshineAmount = 6
-- How much grain does a grain box give?
dist.ahshop.DistilleryGrainAmount = 10
-- How much corn does a corn box give?
dist.ahshop.DistilleryCornAmount = 10
-- How much water does a water bucket give?
dist.ahshop.DistilleryWaterAmount = 10

--------------------------------------------------------------------------------------
-----------------------------------NPC Config-----------------------------------------
--------------------------------------------------------------------------------------



--------------------------------------------------------------------------------------
--------------------------------Oxidation Config--------------------------------------
--------------------------------------------------------------------------------------

-- How long does it take to oxidate a single barrel?
dist.ahshop.OxidationSingleBarrelTime = 10

--------------------------------------------------------------------------------------
----------------------------------Plant Config----------------------------------------
--------------------------------------------------------------------------------------

-- Take the number and * it with 6, and you got the grow time for the grain plant.
dist.ahshop.GrainGrowTime = 27 
-- Take the number and * it with 6, and you got the grow time for the corn plant.
dist.ahshop.CornGrowTime = 24

--------------------------------------------------------------------------------------
----------------------------------Stand Config----------------------------------------
--------------------------------------------------------------------------------------

-- How much does the stand sell the moonshine bottles for?
dist.ahshop.StandBottlePrice = 2500
-- How much money do you receive per bottle of moonshine?
dist.ahshop.StandBottleSellPrice = 2000

--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------


--addons/module_samogon/lua/moonshine/sv/api/api.lua:
if SERVER then
util.AddNetworkString("dist_effect_api")
 
function dist_effect(ply, value)
    net.Start("dist_effect_api")
    net.WriteInt(value, 16)
    net.Send(ply)
end
 
function dist_sound(value, pos)
    sound.Play( value, pos )
end
 
function dist_math(value)
    return math.random(1, value)
end
 
function dist_pass(self, degree, ran, grain, corn, water)
    return self:Getdist_degree() >= degree
    && self:Getdist_ran() >= ran
    && self:Getdist_grain() >= grain
    && self:Getdist_corn() >= corn
    && self:Getdist_water() >= water
end

end
function dist_3d2d(ply, self, vector1, vector2)
	if ply:GetEyeTrace().Entity != self then return end
	local dist_tr = self:WorldToLocal( ply:GetEyeTrace().HitPos ) 
	--print("Vector("..dist_tr.x .. ", " .. dist_tr.y .. ", " .. dist_tr.z..")")
	return dist_tr:WithinAABox( vector1, vector2) 
end 
 

--addons/module_clans/lua/dorgs/classes/org.lua:
dOrgs.classes = dOrgs.classes or {}

dOrgs.classes.org = {
    __index = dOrgs.classes.org,
}

function net.WriteOrg(org)
    net.WriteTable(org)
end

function net.ReadOrg()
    local org = dOrgs.classes.org:New(net.ReadTable())
    return org
end

function dOrgs.classes.org:New(d)
    local obj = {
        name = 'Новая организация',
        members = {},
        ranks = {},
        upgrades = {},
    }

    table.Merge(obj, d or {})

    for k, v in pairs(obj.members or {}) do
        local member = dOrgs.classes.member:New(v)
        local p = player.GetBySteamID(member:GetSteamID())
        member:SetPlayer(p)

        obj.members[k] = member
    end

    for k, v in pairs(obj.ranks or {}) do
        obj.ranks[k] = dOrgs.classes.rank:New(v)
    end

    --obj.__index = self

    return setmetatable(obj, {
        __index = dOrgs.classes.org,
        __eq = function(a, b)
            return a.id == b.id
        end,
    })
end

AccessorFunc(dOrgs.classes.org, 'id', 'ID')
AccessorFunc(dOrgs.classes.org, 'maxMembers', 'MaxMembers')
AccessorFunc(dOrgs.classes.org, 'description', 'Description')
AccessorFunc(dOrgs.classes.org, 'money', 'Money')
AccessorFunc(dOrgs.classes.org, 'xp', 'XP')
AccessorFunc(dOrgs.classes.org, 'clanwarStatus', 'ClanwarStatus')
AccessorFunc(dOrgs.classes.org, 'upgrades', 'Upgrades')

function dOrgs.classes.org:GetMaxMembers()
    return dOrgs.config.default_maxMembers + self:GetUpgradeLevel('max_members') * 10
end

function dOrgs.classes.org:GetCommission()
    return dOrgs.config.commission
end

function dOrgs.classes.org:SetName(name)
  --  local res, err = self:ValidateName(name)
  --  if res == false then return res, err end

    self.name = name
end

function dOrgs.classes.org:GetName()
    return self.name
end

function dOrgs.classes.org:ValidateName(name)
    name = string.Trim(name):gsub('%s+', ' ')

    if utf8.len(name) <= 2 then return false, 'Название слишком короткое' end
    if utf8.len(name) > 28 then return false, 'Название слишком длинное' end
    if not name:match('^[a-zA-ZЀ-џ0-9 ]+$') then return false, 'В названии содержатся недопустимые символы' end
    
    return true
end

function dOrgs.classes.org:ValidateDescription(desc)
    desc = string.Trim(desc):gsub('%s+', ' ')

    if desc:len() > 400 then return false, 'Описание слишком длинное' end

    return true
end

function dOrgs.classes.org:ValidateAvatar(url)
    if not url or url == '' then return true end

    local imgur = url:match('https://i.imgur.com/%w+%.%w+')
    if not imgur then return false, 'Ссылка должна быть на Imgur' end
    if imgur ~= url then return false, 'В ссылке не должно содержаться ничего постороннего' end 

    return true
end

function dOrgs.classes.org:ValidateWebhook(url)
    local id, token = url:match('https://discord[%w%.]+/api/webhooks/(%d+)/(.+)')
    if not id or not token then return false, 'Указана некорректная ссылка' end

    return true
end

function dOrgs.classes.org:SetAvatar(url)
    self.avatar = url
end

function dOrgs.classes.org:GetAvatar()
    return self.avatar and self.avatar ~= '' and self.avatar or dOrgs.config.defaultAvatar
end

function dOrgs.classes.org:CanAddMember(sid)
    sid = sid.SteamID and sid:SteamID() or sid
    if not wlib.string.isSteamID(sid) then return false, 'Некорректный SteamID' end

    local curMembers = table.Count(self:GetMembers())
    if curMembers >= self:GetMaxMembers() then return false, 'Достигнут лимит участников' end

    if self:GetMember(sid) then return false, 'Этот игрок уже состоит в организации' end

    return true
end

function dOrgs.classes.org:AddMember(sid, name, rank)
    local member = dOrgs.classes.member:New()
    member:SetName(name)
    member:SetSteamID(sid)
    member:SetRankLevel(rank or 0)

    local res, err = self:CanAddMember(member)
    if res == false then return res, err end

    member:SetOrg(self)

    self.members[sid] = member

    local ply = player.GetBySteamID(sid)
    if IsValid(ply) then
        member:SetPlayer(ply)
        ply:SetOrgMember(self:GetID(), member)
    end
end

function dOrgs.classes.org:GetMembers()
    return self.members
end

function dOrgs.classes.org:GetMember(sid)
    if IsValid(sid) then
        if sid == LocalPlayer() then
            sid = sid:RealSteamID()
        else
            sid = sid:SteamID()
        end
    end

    return self.members[sid]
end

function dOrgs.classes.org:GetOnlineMembers()
    local members = {}

    for _, member in pairs(self:GetMembers()) do
        if IsValid(member:GetPlayer()) then
            table.insert(members, member)
        end
    end

    return members
end

function dOrgs.classes.org:GetMembersByRank(lvl)
    local members = {}

    for _, member in pairs(self:GetMembers()) do
        if member:GetRankLevel() == lvl then
            table.insert(members, member)
        end
    end

    return members
end

function dOrgs.classes.org:AddRank(rank)
    self.ranks[rank:GetLevel()] = rank
end

function dOrgs.classes.org:GetRank(lvl)
    return self.ranks[lvl]
end

function dOrgs.classes.org:GetRanks()
    return self.ranks
end

function dOrgs.classes.org:SetUpgradeLevel(id, lvl)
    self.upgrades[id] = lvl
end

function dOrgs.classes.org:GetUpgradeLevel(id)
    return self.upgrades[id] or 0
end

function dOrgs.classes.org:HasUpgrade(id)
    return self:GetUpgradeLevel(id) > 0 and true or false
end

if SERVER then
    function dOrgs.classes.org:InviteMember(inviter, ply)
        dOrgs.debug('Trying to invite '..tostring(ply)..' by '..tostring(inviter))
        local res, err = self:CanAddMember(ply)
        if res == false then return res, err end
    
        DarkRP.createQuestion((IsValid(inviter) and inviter:Name() or 'Сервер')..' пригласил тебя в клан '..self:GetName(), 'dOrgs.invite.'..ply:SteamID64(), ply, 60, function(ans)
            if tobool(ans) then
                local res, err = self:AddMember(ply:SteamID(), ply:Name())
                if res == false then return DarkRP.notify(inviter, 1, 10, err) end
    
                dOrgs.provider:CreateMember(self:GetID(), ply:SteamID(), ply:Name(), 0, function()
                    dOrgs.loadOrg(self:GetID(), function(org)
                        hook.Run('dOrgs.memberJoinedOrg', org, org:GetMember(ply:SteamID()))
                    end)
                end)

                DarkRP.notify(inviter, 0, 10, ply:Name()..' вступил в организацию')
                DarkRP.notify(ply, 0, 10, 'Ты вступил в организацию '..self:GetName())
            else
                DarkRP.notify(inviter, 1, 10, ply:Name()..' отказался от приглашения в организацию')
            end
        end, inviter, ply)
    end

    function dOrgs.classes.org:DepositMoney(amount, cb)
        dOrgs.provider:OrgDepositMoney(self:GetID(), amount, cb)
    end

    function dOrgs.classes.org:WithdrawMoney(amount, cb)
        dOrgs.provider:OrgWithdrawMoney(self:GetID(), amount, cb)
    end

    function dOrgs.classes.org:DeleteMember(sid, cb)
        dOrgs.provider:DeleteMember(self:GetMember(sid), cb)
        self.members[sid] = nil
        
        local p = player.GetBySteamID(sid)
        if IsValid(p) then
            p:SetOrgMember(self:GetID(), nil)
        end
    end

    function dOrgs.classes.org:DeleteRank(level, cb)
        dOrgs.provider:DeleteRank(self:GetRank(level), cb)
        self.ranks[level] = nil
    end

    function dOrgs.classes.org:Save(cb)
        dOrgs.provider:UpdateOrg(self, function()
            dOrgs.loadOrg(self:GetID(), cb)
        end)
    end

    util.AddNetworkString('dOrgs.networkOrg')
    function dOrgs.classes.org:Network(p, privateFields)
        net.Start('dOrgs.networkOrg')
        net.WriteOrg(self)
        if p then
            net.Send(p)
        else
            net.Broadcast()
        end
    end

end
--addons/module_clans/lua/dorgs/sh_config.lua:
dOrgs.config = {
    debug = false,
    
    dataProvider = 'mysqlite',

    flags = {
        ['invite'] = {
            desc = 'Приглашать участников',
            category = 'Управление участниками',
        },
        ['kick'] = {
            desc = 'Исключать участников',
            category = 'Управление участниками',
        },
        ['setrank'] = {
            desc = 'Изменять ранги участников',
            category = 'Управление участниками',
        },

        ['deposit_money'] = {
            desc = 'Вкладывать деньги в банк',
            category = 'Банк',
        },
        ['withdraw_money'] = {
            desc = 'Снимать деньги из банка',
            category = 'Банк',
        },

        ['rank_manage'] = {
            desc = 'Создавать/Редактировать ранги',
            category = 'Ранги',
        },

        ['webhook_edit'] = {
            desc = 'Изменять WebHook для логов',
            category = 'Управление организацией',
        },
        ['org_editinfo'] = {
            desc = 'Изменять информацию об организации',
            category = 'Управление организацией',
        },

        ['createmarker'] = {
            desc = 'Создавать маркеры',
            category = 'Прочее',
        },
        ['chat_sendmessage'] = {
            desc = 'Использовать чат',
            category = 'Прочее',
        },
    },

    -- Если добавить сюда еще рангов, то создадутся все равно только два: 0 и 100
    defaultRanks = {
        [0] = {
            name = 'Участник',
            flags = {},
        },
        [100] = {
            name = 'Создатель',
            flags = {},
        },
    },

    default_maxMembers = 10,

    -- Стоимость создания орги
    createPrice = 15000000,
    -- Максимальное количество созданных орг
    maxCreatedOrgs = 1,
    -- Коммисия при вводе/выводе денег из банка
    commission = 0.03,
    -- Стандартная аватарка клана
    defaultAvatar = 'https://i.imgur.com/aUhTiwe.png',
    -- Стоимость приглашения участника
    invitePrice = 2500,

    messagesOnPage = 50,
}

dOrgs.upgrades = {}

dOrgs.createUpgrade('max_members')
    :SetName('Вместимость')
    :SetDescription('Увеличивает максимальное количество участников клана на 10 за уровень')
    :SetImage(Material('icon72/people_holding_hands.png'))
    :SetMaxLevel(5)
    :SetPrice({
        100000,
        150000,
        200000,
        250000,
        300000,
    })
    :Save()

dOrgs.createUpgrade('map_members')
    :SetName('Карта')
    :SetDescription('Позволяет видеть соклановцев на карте')
    :SetImage(Material('icon72/map.png'))
    :SetMaxLevel(1)
    :SetPrice(500000)
    :Save()

dOrgs.createUpgrade('chat')
    :SetName('Чат')
    :SetDescription('Добавляет чат клана')
    :SetImage(Material('icon72/speech_balloon.png'))
    :SetMaxLevel(1)
    :SetPrice(500000)
    :Save()

dOrgs.createUpgrade('map_markers')
    :SetName('Метки')
    :SetDescription('Позволяет создавать метки на экране у соклановцев (по-умолчанию на колесо мыши)')
    :SetImage(Material('icon72/pushpin.png'))
    :SetMaxLevel(1)
    :SetPrice(250000)
    :Save()
--addons/module_clans/lua/dorgs/vgui/vgui_orgheader.lua:
local mat_error = Material('icon72/error.png')

local PANEL = {}

function PANEL:Init()
    self.image = vgui.Create('DImage', self)
    self.image:Dock(LEFT)
    self.image:DockMargin(8,8,0,8)

    self.buttons = vgui.Create('DPanel', self)
    self.buttons:Dock(RIGHT)
    self.buttons:SetPaintBackground(false)
    self.buttons.list = {}

    self.info = vgui.Create('DPanel', self)
    self.info:Dock(FILL)
    self.info:DockMargin(12,8,0,8)
    self.info:SetPaintBackground(false)

    self.info.name = vgui.Create('DLabel', self.info)
    self.info.name:Dock(TOP)
    self.info.name:SetFont('dorgs.24')

    self.info.members = vgui.Create('DLabel', self.info)
    self.info.members:Dock(TOP)
    self.info.members:SetFont('dorgs.20')

    self.info.id = vgui.Create('DLabel', self.info)
    self.info.id:Dock(TOP)
    self.info.id:SetFont('dorgs.20')
end

wlib.accessor(PANEL, 'org', 'Org')

function PANEL:SetOrg(org)
    if isnumber(org) then org = dOrgs.getOrg(org) end
    self.org = org

    self.image:SetMaterial(org.AvatarMaterial)

    self.info.name:SetText(org:GetName())
    self.info.members:SetText(('Участников %s из %s'):format(table.Count(org:GetMembers()), org:GetMaxMembers()))
    self.info.id:SetText('ID: '..org:GetID())

    self.info.name:SizeToContents()
    self.info.members:SizeToContents()
    self.info.id:SizeToContents()

    self:RebuildButtons()
end

function PANEL:PerformLayout(w, h)
    self.image:SetWide(h-16)

    self.buttons:DockMargin(0, h/4, 8, h/4)

    local wide = 0
    for _, v in ipairs(self.buttons:GetChildren()) do
        v:SetWide(h/2)
        wide = wide + h/2 + 6
    end
    self.buttons:SetWide(wide)
end

function PANEL:AddButton(d)
    local _, index = wlib.array.find(self.buttons.list, function(i) return i.id == d.id end)
    if index then table.remove(self.buttons.list, index) end

    table.insert(self.buttons.list, d)
    table.sort(self.buttons.list, function(a, b) return a.order > b.order end)

    self:RebuildButtons()
end

function PANEL:RebuildButtons()
    self.buttons:Clear()

    if not self.org then return end

    for _, v in ipairs(self.buttons.list) do
        if v.check and v.check(self.org) == false then continue end

        local btn = vgui.Create('DButton', self.buttons)
        btn:Dock(RIGHT)
        btn:DockMargin(6,0,0,0)
        btn:SetText('')
        btn:SetTooltipDelay(0)
        if v.name then
            btn:SetTooltip(v.name)
        end
        if v.color then
            btn.color = v.color
            btn.color_hover = Color(v.color.r + 10, v.color.g + 10, v.color.b + 10)
        end
        btn.selected = v.selected
        btn.image = v.image
        btn.DoClick = function(s)
            if v.tab then
                for _, v in ipairs(self.buttons:GetChildren()) do
                    v.selected = nil
                end
                s.selected = true
            end
            if v.callback then
                v.callback(self.org)
            end
        end

        btn.Paint = function(s,w,h)
            local col = s.color or color_white
            if s.selected or s:IsHovered() then
                col = f4menu.col.buttonCol
            end
            draw.RoundedBox(6, 0, 0, w, h, col)

            surface.SetMaterial(btn.image or mat_error)
            surface.SetDrawColor(color_white)
            surface.DrawTexturedRect(8, 8, w-16, h-16)
        end
        --[[
        btn.OnCursorEntered = function(s)
            s.hovered = true
        end
        btn.OnCursorExited = function(s)
            s.hovered = false
        end
        ]]
    end

    self:InvalidateLayout(true)
end

vgui.Register('dorgs.orgheader', PANEL, 'DPanel')
--addons/module_duels/lua/duelsystem/config.lua:
duelSystem.Config = {
    mapPositions = {
        ['rp_bangclaw'] = {
            [1] = {Vector('-5765.309082 -10117.721680 753.310425'), Vector('-6688.732422 -10022.154297 714.474426')},
            [2] = {Vector('-8052.538574 -7967.012695 762.036316'), Vector('-8112.412109 -8712.087891 695.871765')}
        },
        ['rp_rockford_open'] = {
            [1] = {Vector('6054 11871 -12010'), Vector('5212.470215 12047.700195 -11976')},
            [2] = {Vector('4803 9684 -11978'), Vector('5176.492676 9594.735352 -11978')}
        }
    },
    weaponPresets = {
        ['01. Кулаки'] = {
            weapons = {'weapon_fists'},
            ammo = {}
        },
        ['02. Нож'] = {
            weapons = {'csgo_bayonet'},
            ammo = {}
        },
        ['03. Тяжелые пистолеты'] = {
            weapons = {'ptp_cs_deagle', 'ptp_cs_357'},
            ammo = {
                [3] = 300
            }
        },
        ['04. Легкие пистолеты'] = {
            weapons = {'ptp_cs_p228', 'ptp_cs_usp', 'ptp_cs_fiveseven'},
            ammo = {
                [3] = 300
            }
        },
        ['05. АК-47'] = {
            weapons = {'ptp_cs_ak47', 'ptp_cs_glock'},
            ammo = {
                [3] = 300,
                [4] = 300
            }
        },
        ['06. М4А1'] = {
            weapons = {'ptp_cs_m4', 'ptp_cs_usp'},
            ammo = {
                [3] = 300,
                [4] = 300
            }
        },
        ['07. AWP'] = {
            weapons = {'ptp_cs_awp', 'ptp_cs_fiveseven'},
            ammo = {
                [3] = 300,
                [4] = 300
            }
        },
        ['08. Scout'] = {
            weapons = {'ptp_cs_scout', 'ptp_cs_fiveseven'},
            ammo = {
                [3] = 300,
                [4] = 300
            }
        },
        ['09. LAR Grizzly .50'] = {
            weapons = {'wrp_weapon_grizzly'},
            ammo = {
                [4] = 300
            }
        },
        ['10. HK MP7'] = {
            weapons = {'wrp_weapon_mp7'},
            ammo = {
                [4] = 300
            }
        },
        ['11. Franchi SPAS12'] = {
            weapons = {'wrp_weapon_spas12'},
            ammo = {
                [7] = 300
            }
        },
        ['12. S-LAR AR2'] = {
            weapons = {'wrp_weapon_ar2'},
            ammo = {
                [4] = 300
            }
        },
        ['13. Гвоздомет'] = {
            weapons = {'wrp_weapon_nailgun'},
            ammo = {
                [3] = 300
            }
        },
        ['14. Двуствольный дробовик'] = {
            weapons = {'wrp_weapon_dbshotgun'},
            ammo = {
                [7] = 300
            }
        },
        ['15. Охотничья винтовка'] = {
            weapons = {'wrp_weapon_huntrifle'},
            ammo = {
                [4] = 300
            }
        },
        ['16. Катана'] = {
            weapons = {'weapon_hl2katana'},
            ammo = {}
        },
        ['17. Полуавтоматические винтовки'] = {
            weapons = {'ptp_cs_sg550', 'ptp_cs_g3sg1'},
            ammo = {
                [4] = 300
            }
        },
        ['18. Дробовики'] = {
            weapons = {'ptp_cs_autoshotgun', 'ptp_cs_pumpshotgun'},
            ammo = {
                [7] = 100
            }
        },
        ['19. Пистолеты-пулеметы'] = {
            weapons = {'ptp_cs_ump45', 'ptp_cs_mp5', 'ptp_cs_p90'},
            ammo = {
                [4] = 300
            }
        },
        ['20. Специалист спецназа'] = {
            weapons = {'ptp_cs_aug', 'ptp_cs_famas', 'ptp_cs_p228', 'swat_shield'},
            ammo = {
                [3] = 300,
                [4] = 300
            }
        },
        ['21. Специалист мафии'] = {
            weapons = {'ptp_cs_sg552', 'ptp_cs_galil', 'ptp_cs_elites', 'fridge_shield_unbreakable'},
            ammo = {
                [3] = 300,
                [4] = 300
            }
        },
        ['22. Большие пушки'] = {
            weapons = {'ptp_cs_para', 'ptp_cs_autoshotgun'},
            ammo = {
                [7] = 100,
                [4] = 300
            }
        },
        ['23. Мусорный воин'] = {
            weapons = {'weapon_hl2shovel', 'weapon_hl2hook', 'weapon_hl2axe'},
            ammo = {}
        },
        ['24. Драка в подворотне'] = {
            weapons = {'weapon_hl2pipe', 'weapon_hl2brokenbottle', 'weapon_hl2pan'},
            ammo = {}
        },
        ['25. Взрывное вооружение'] = {
            weapons = {'weapon_fists', 'weapon_slam', 'weapon_frag'},
            ammo = {
                [11] = 25,
                [10] = 25
            }
        },
        ['26. CSG-12 Drum'] = {
            weapons = {'wrp_weapon_csg'},
            ammo = {
                [7] = 200
            }
        },
        ['27. FN Fal'] = {
            weapons = {'wrp_weapon_fal'},
            ammo = {
                [4] = 300
            }
        },
        ['28. Colt Python'] = {
            weapons = {'wrp_weapon_python'},
            ammo = {
                [3] = 300
            }
        },
        ['29. M1A1 Thompson'] = {
            weapons = {'wrp_weapon_thompson'},
            ammo = {
                [4] = 300
            }
        },
        ['30. C96 Mauser'] = {
            weapons = {'wrp_weapon_mauser'},
            ammo = {
                [3] = 300
            }
        },
        ['31. HK21'] = {
            weapons = {'wrp_weapon_hk21'},
            ammo = {
                [4] = 300
            }
        },
    },
    -- https://wiki.facepunch.com/gmod/Default_Ammo_Types
    hp = {
        min = 1,
        max = 200,
        default = 100
    },
    armor = {
        min = 0,
        max = 200,
        default = 0
    }
}

if not duelSystem.Config.mapPositions[game.GetMap()] then
    duelSystem.Config.mapPositions[game.GetMap()] = {}
end
--addons/module_elitef4menu/lua/f4/tabs/jobs.lua:
local icon_star = Material('icon72/star.png')
local gradient = Material("gui/center_gradient")
local color_gray = Color(150,150,150)

local favorites = waySettings.registerVar('f4_favorites')
local last = waySettings.registerVar('f4_last')
local extraCategory = waySettings.registerVar('f4_extracategory', 'Дополнительная категория профессий в F4', 'Интерфейс', 'combobox', 'last', {
	{name = 'Недавние', data = 'last'},
	{name = 'Избранные', data = 'favorites'},
})

local panel_list
local PopulateJobList
local function createJobButton(job, panel)
	local v = RPExtraTeams[job]

	if not v then return end

	local name = v.name
	local VIP = false

	local show = true
	if v.NotDisplay then
		show = false
	elseif team.GetName( LocalPlayer():Team() ) == v.name then
		show = false
	elseif v.admin == 1 and not LocalPlayer():IsAdmin() then
		show = false
	end

	if v.admin > 1 and not LocalPlayer():IsSuperAdmin() then
		show = false
	end

	if v.customCheck then
		VIP = true
	end
	if (type(v.NeedToChangeFrom) == "number" and LocalPlayer():Team() ~= v.NeedToChangeFrom) or (type(v.NeedToChangeFrom) == "table" and not table.HasValue(v.NeedToChangeFrom, LocalPlayer():Team())) then
		show = false
	end
    
	if show then
		local jobFrame = vgui.Create( "DPanel", panel ) -- surface.DrawLine( 24, self:GetTall() - 44, self:GetWide() - 24, self:GetTall() - 44 )
		jobFrame:SetTall(60)
		jobFrame:SetSize( panel_list:GetWide(), 60 )
		jobFrame:SetTooltip( v.description )
		jobFrame.Paint = function( self, w, h )
			--if VIP then
			--	draw.RoundedBox( 0, 0, 0, w, h, Color( 240, 251, 255 ) )
			--end


			draw.RoundedBox( 4, 0, 0, w, h, f4menu.col.bg)-- v.color )
        	surface.SetMaterial( gradient )
        	surface.SetDrawColor( v.color )
        	surface.DrawTexturedRect( 0, 0, w, h )
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor )
            
			draw.SimpleText( name, "f4.main", 56, 14, color_white )
			draw.SimpleText( "Зарплата: "..DarkRP.formatMoney(v.salary), "f4.main", 56, 35, Color( 190, 190, 190 ) )
		end
		jobFrame.OnCursorEntered = function( self )

		end
		jobFrame.OnCursorEntered = function( self )

		end
		
		--[[
		local favoriteButton = vgui.Create( "DImageButton", jobFrame )
		favoriteButton:SetSize( 24, 24 )
		favoriteButton:SetPos( jobFrame:GetWide() - 145, (jobFrame:GetTall() / 2) - 12 )
		favoriteButton:SetMaterial(star)
		if not table.HasValue(favorites, job) then
			favoriteButton:SetColor(Color(150,150,150))
		end

		favoriteButton.DoClick = function(self)
			if table.HasValue(favorites, job) then
				self:SetColor(Color(150,150,150))
				table.RemoveByValue(favorites, job)
				cookie.Set('wrp.f4_favorite_jobs', util.TableToJSON(favorites))
			else
				self:SetColor(color_white)
				table.insert(favorites, job)
				cookie.Set('wrp.f4_favorite_jobs', util.TableToJSON(favorites))
			end
		end
		]]

		local jobButton = vgui.Create( "DButton", jobFrame )
		jobButton:SetSize( jobFrame:GetWide(), jobFrame:GetTall() )
		--jobButton:Dock(RIGHT)
		--jobButton:DockMargin(0, 12, 5, 12)
		--jobButton:SetPos( jobFrame:GetWide() - 110, (jobFrame:GetTall() / 2) - 17.5 )
		jobButton:SetFont( "f4.main" )

		if v.max ~= 0 and team.NumActivePlayers(v.team) >= (v.max >= 1 and v.max or math.floor(v.max*player.GetCount())) then
			jobButton:SetText("")
			jobButton:SetEnabled(false)
		else
			jobButton:SetText("")
			jobButton:SetEnabled(true)
		end
		
		jobButton.Paint = function( self, w, h )
		    if self:IsEnabled() then return end
		    draw.RoundedBox(6,0,0,w,h,Color(30,30,30, 200))
		end
		jobButton.DoClick = function( self )
			if v.vote then
				if ((v.admin == 0 and LocalPlayer():IsAdmin()) or (v.admin == 1 and LocalPlayer():IsSuperAdmin())) then
					RunConsoleCommand('darkrp', 'vote'..v.command)
					f4menu:close()
				else
					RunConsoleCommand('darkrp', 'vote'..v.command)
					f4menu:close()
				end
			else
				RunConsoleCommand('darkrp', v.command)
				f4menu:close()
			end
		end
		jobButton.OnCursorEntered = function( self )
			self.hover = true
		end
		jobButton.OnCursorExited = function( self )
			self.hover = false
		end
		
		local model
		
		if type( v.model ) == "table" then
			model = table.Random( v.model )
		else
			model = v.model
		end

		local jobModel = vgui.Create( "SpawnIcon", jobFrame )
		jobModel:SetSize( 45, 45 )
		jobModel:SetPos( 5, 5 )
		jobModel:SetModel( model )

		if extraCategory:GetValue() == 'favorites' then
			local fav = favorites:GetValue({})
			local is_fav = table.HasValue(fav, job)
			jobModel:SetTooltip(is_fav and 'Убрать из избранного' or 'Добавить в избранное')

			jobModel.DoClick = function()
				if is_fav then
					table.RemoveByValue(fav, job)
				else
					table.insert(fav, job)
				end
				favorites:SetValue(fav)
				PopulateJobList(panel_list:GetVBar():GetScroll())
			end

			local old = jobModel.PaintOver or wlib.func.blank
			jobModel.PaintOver = function(self, w, h)
				old(self,w,h)
				
				surface.SetDrawColor(is_fav and color_white or color_gray)
				surface.SetMaterial(icon_star)
				local size = self:IsHovered() and 20 or 16
				surface.DrawTexturedRect(w-20, h-20, size, size)
			end
		end
		
		return jobFrame
	end
end

PopulateJobList = function(scroll)
	panel_list:Clear()

	local f = favorites:GetValue({})
	local l = last:GetValue({})

	if extraCategory:GetValue() == 'favorites' then
		if #f > 0 and (#f > 1 or LocalPlayer():Team() ~= f[1]) then
			local favCat = panel_list:Add('Избранные')
			favCat:InvalidateParent(true)

			local scroll = vgui.Create('DScrollPanel', favCat)
			favCat:SetContents(scroll)
			favCat.Header:SetFont('f4.main')
			favCat.Paint = wlib.func.blank
			favCat.Header.Paint = function(s,w,h)
		        draw.RoundedBox(6,0,0,w,h,f4menu.col.buttonCol) 
		    end

			local favList = vgui.Create('DIconLayout', scroll)
			favList:Dock(FILL)
			favList:SetSpaceX(4)
			favList:SetSpaceY(8)
			favList:DockMargin(0,8,0,0)

			scroll:InvalidateParent(true)
			favList:InvalidateParent(true)

			for _, v in pairs(f) do
				local btn = createJobButton(tonumber(v), favList)
				if IsValid(btn) then
					btn:SetWide(btn:GetParent():GetWide()/2 - 8)
					favList:Add(btn)
				end
			end
		end
	elseif extraCategory:GetValue() == 'last' then
		if #l > 0 and (#l > 1 or LocalPlayer():Team() ~= l[1]) then
			local lastCat = panel_list:Add('Недавние')
			lastCat:InvalidateParent(true)

			local scroll = vgui.Create('DScrollPanel', lastCat)
			lastCat:SetContents(scroll)
			lastCat.Header:SetFont('f4.main')
			lastCat.Paint = wlib.func.blank
			lastCat.Header.Paint = function(s,w,h)
		        draw.RoundedBox(6,0,0,w,h,f4menu.col.buttonCol) 
		    end

			local lastList = vgui.Create('DIconLayout', scroll)
			lastList:Dock(FILL)
			lastList:SetSpaceX(4)
			lastList:SetSpaceY(8)
			lastList:DockMargin(0,8,0,0)

			scroll:InvalidateParent(true)
			lastList:InvalidateParent(true)

			for _, v in pairs(l) do
				local btn = createJobButton(tonumber(v), lastList)
				if IsValid(btn) then
					btn:SetWide(btn:GetParent():GetWide()/2 - 8)
					lastList:Add(btn)
				end
			end
		end
	end

	for _, cat in pairs(DarkRP.getCategories().jobs) do
		local category = panel_list:Add(cat.name)
		category:InvalidateParent(true)

		local scroll = vgui.Create('DScrollPanel', category)
		category:SetContents(scroll)
		category:DockMargin(0,15,0,0)
		category.Header:SetFont('f4.main')
		category.Paint = function(s,w,h) 
		--    draw.RoundedBox(6,0,0,w,h,f4menu.col.bg) 
		end
		category.Header.Paint = function(s,w,h)
		   draw.RoundedBox(6,0,0,w,h,f4menu.col.buttonCol) 
		end

		local main = vgui.Create('DIconLayout', scroll)
		main:Dock(FILL)
		main:SetSpaceX(4)
		main:SetSpaceY(8)
		main:DockMargin(0,8,0,0)

		scroll:InvalidateParent(true)
		main:InvalidateParent(true)

		for _, v in pairs(cat.members) do
			local id = v.team

			if extraCategory:GetValue() == 'favorites' and table.HasValue(f, id) then continue end

			local name = v.name
		
			local show = true
			if v.NotDisplay then
				show = false
			elseif team.GetName( LocalPlayer():Team() ) == v.name then
				show = false
			elseif v.admin == 1 and not LocalPlayer():IsAdmin() then
				show = false
			end
	
			if v.admin > 1 and not LocalPlayer():IsSuperAdmin() then
				show = false
			end
	
			if (type(v.NeedToChangeFrom) == "number" and LocalPlayer():Team() ~= v.NeedToChangeFrom) or (type(v.NeedToChangeFrom) == "table" and not table.HasValue(v.NeedToChangeFrom, LocalPlayer():Team())) then
				show = false
			end
	
			if show then
				local btn = createJobButton(id, main)
				if IsValid(btn) then
					btn:SetWide(btn:GetParent():GetWide()/2 - 8)
					main:Add(btn)
				end
			end
		end
	end

	panel_list:GetVBar():SetScroll(scroll or 0)
end

local function LoadCmdPanel(tab, parent)
	local pnl = vgui.Create('DPanel', parent)
	pnl:Dock(FILL)
	pnl.Paint = function(s,w,h)
		draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
	end
	pnl:DockMargin(30, 30, 30, 30)
	pnl:DockPadding(25, 25, 25, 25)

	pnl:SetParent(parent)
	pnl:InvalidateParent(true)

	pnl:SetSkin('WayZer')

	local lbl = vgui.Create('DLabel', pnl)
	lbl:Dock(TOP)
	lbl:SetAutoStretchVertical(true)
	lbl:SetFont('f4.main')
	lbl:SetTextColor(f4menu.col.text_inactive)
	lbl:SetText('Список работ')

	panel_list = vgui.Create('DCategoryList', pnl)
	panel_list.Paint = wlib.func.blank
	panel_list:Dock(FILL)
	panel_list:DockMargin(0, 10, 0, 0)
	panel_list.VBar.Paint = function( s, w, h )
		draw.RoundedBox( 4, 3, 13, 8, h-24, f4menu.col.color_scroll)
	end
	panel_list.VBar.btnUp.Paint = function( s, w, h ) end
	panel_list.VBar.btnDown.Paint = function( s, w, h ) end
	panel_list.VBar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 4, 5, 0, 4, h+22, f4menu.col.color_scroll)
	end

	panel_list:InvalidateParent(true)

	pnl.OnSelected = function() PopulateJobList() end
	PopulateJobList()

	return pnl
end

f4menu.addTab('jobs', {
	order = 100,
	title = 'Работы',
	panel = LoadCmdPanel,
	icon = Material('icon72/briefcase.png'),
})

hook.Add('OnPlayerChangedTeam', 'elitef4', function(ply, old, new)
	timer.Simple(0.5, fp{f4menu.updateTabs, f4menu})
	
	if ply ~= LocalPlayer() then return end

	local l = last:GetValue({})

	if #l >= 4 then
		table.remove(l, 1)
	end

	if not table.HasValue(l, tonumber(new)) then
		table.insert(l, tonumber(new))
	end

	last:SetValue(l)
end)
--addons/module_hits/lua/hitsystem/config.lua:
hitSystem.Config = {
    debug = false,
    allHitJobs = {
        ['Ассасин'] = true,
        ['Опытный наёмник'] = true,
        ['Наемный Убийца'] = true,
        ['Иссохший'] = true
    },
    types = {
        ['kill'] = {
            name = hitSystem.L'typeKillName',
            hitJobs = {
                ['Ассасин'] = true,
                ['Опытный наёмник'] = true,
                ['Наемный Убийца'] = true
            },
            Price = 50000,
            maxOrders = 1,
            entityClass = {
                ['Player'] = true
            },
            getEnts = function()
                return player.GetAll()
            end,
            canPlace = function(target, customer)
                if target:GetNetVar('hitSystem.IsOrdered') or target == customer then return false end
                if customer:IsHitMan() then return false end
                if customer:Team() == TEAM_ADMIN or customer:Team() == TEAM_BANNED or hitSystem.Config.types['kill'].hitJobs[team.GetName(customer:Team())] then return false end

                return true
            end,
            canAccept = function(target, killer)
                local orders = hitSystem:GetOrders()
                if not target:GetNetVar('hitSystem.IsOrdered') then return false end -- Если он не заказан :flushed::flushed::flushed:
                if target == killer then return false end -- Низя принимать на себя заказ
                if orders['kill'][target:EntIndex()].killer and IsValid(orders['kill'][target:EntIndex()].killer) then return false end -- Если есть киллер и он валид
                if target:Team() == TEAM_ADMIN or target:Team() == TEAM_BANNED then return false end -- Если цель админ :flushed:
                if not killer:IsHitMan() then return false end -- А чо ты не хитман?!??!
                if orders['kill'][target:EntIndex()].customer == killer then return false end -- Нельзя свои заказы принимать :flushed:
                if not hitSystem.Config.types['kill'].hitJobs[team.GetName(killer:Team())] then return false end -- Если профы нет в соответсвующем списке

                return true
            end,
            task = 'Убить %s',
            uiWeith = 10
        },
        ['abduction'] = {
            name = hitSystem.L'typeAbductionName',
            hitJobs = {
                ['Опытный наёмник'] = true,
                ['Иссохший'] = true
            },
            Price = 50000,
            maxOrders = 1,
            entityClass = {
                ['Player'] = true
            },
            getEnts = function()
                return player.GetAll()
            end,
            canPlace = function(target, customer)
                if target:GetNetVar('hitSystem.IsOrdered') or target == customer then return false end
                if customer:Team() == TEAM_ADMIN or customer:Team() == TEAM_BANNED or hitSystem.Config.types['abduction'].hitJobs[team.GetName(customer:Team())] then return false end
                if customer:IsHitMan() then return false end

                return true
            end,
            canAccept = function(target, killer)
                local orders = hitSystem:GetOrders()
                if not target:GetNetVar('hitSystem.IsOrdered') then return false end -- Если он не заказан :flushed::flushed::flushed:
                if target == killer then return false end -- Низя принимать на себя заказ
                if orders['abduction'][target:EntIndex()].killer and IsValid(orders['abduction'][target:EntIndex()].killer) then return false end -- Если есть киллер и он валид
                if target:Team() == TEAM_ADMIN or target:Team() == TEAM_BANNED then return false end -- Если цель админ :flushed:
                if not killer:IsHitMan() then return false end -- А чо ты не хитман?!??!
                if orders['abduction'][target:EntIndex()].customer == killer then return false end -- Нельзя свои заказы принимать :flushed:
                if not hitSystem.Config.types['abduction'].hitJobs[team.GetName(killer:Team())] then return false end -- Если профы нет в соответсвующем списке

                return true
            end,
            task = 'Похитить %s и отдать %s',
            uiWeith = 20
        }
    }
}
--addons/module_hits/lua/hitsystem/cl/cl_main.lua:
local function placehit()
    if LocalPlayer():IsHitMan() then return end
    local frame = vgui.Create('DFrame')
    frame:SetSize(400, 600)
    frame:MakePopup()
    frame:Center()
    frame:SetTitle('Меню заказа')
    frame:SetDraggable(false)
    frame:SetSizable(false)
    local sheet = vgui.Create('DPropertySheet', frame)
    sheet:Dock(FILL)
    local orders = hitSystem:GetOrders()

    local selected = {
        ply = nil,
        type = nil
    }

    local button = vgui.Create('DButton', frame)
    button:Dock(BOTTOM)
    button:SetText('Выберите цель')
    button:SetEnabled(false)
    button:SetIcon('icon16/cancel.png')

    function button:DoClick()
        if not selected.ply or not IsValid(selected.ply) or not selected.type then return end
        net.Start('hitSystem.PlaceHit')
        net.WriteString(selected.type)
        net.WriteEntity(selected.ply)
        net.SendToServer()
        frame:Remove()
    end

    local price = vgui.Create('DLabel', frame)
    price:DockMargin(0, 10, 0, 10)
    price:SetTall(36)
    price:Dock(BOTTOM)
    price:SetText('')
    price:SetFont('DermaLarge')

    function price:Paint(w, h)
        draw.SimpleText('Цена: ' .. DarkRP.formatMoney(selected.type and hitSystem.Config.types[selected.type].Price or 0), self:GetFont(), 0, h / 2, self:GetColor(), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    for k, v in SortedPairsByMemberValue(hitSystem.Config.types, 'uiWeith') do
        local da = vgui.Create('DCategoryList')
        da:Dock(FILL)
        local plys = {}

        for _, v in player.Iterator() do
            local t = v:GetNetVar('disguised') and v:GetNetVar('disguise_team') or v:Team()
            plys[t] = plys[t] or {}
            table.insert(plys[t], v)
        end

        for job, i in pairs(plys) do
            local collapsible = da:Add(team.GetName(job))
            local main = vgui.Create('DListLayout')
            collapsible:SetContents(main)

            for d, i in pairs(i) do
                if not v.canPlace(i, LocalPlayer()) then continue end
                local btn = vgui.Create('DButton', da)
                btn:Dock(TOP)
                btn:SetTall(40)
                btn:DockMargin(0, 0, 0, 4)
                btn:SetText('')

                function btn:Paint(w, h)
                    if selected.ply == i and selected.type == k then
                        draw.RoundedBox(2, 0, 0, w, h, Color(0, 150, 0))
                    end
                end

                local text = i:Name()
                local icon = vgui.Create('SpawnIcon', btn)
                icon:Dock(LEFT)
                icon:SetWide(40)
                icon:SetModel(i:GetModel())

                function btn:DoClick()
                    selected.ply = i
                    selected.type = k
                    button:SetEnabled(true)
                    button:SetIcon('icon16/accept.png')
                    button:SetText('Заказать')
                end

                local label = vgui.Create('DLabel', btn)
                label:Dock(FILL)
                label:SetFont('Trebuchet24')
                label:SetText(text)
                main:Add(btn)
            end
        end

        sheet:AddSheet(hitSystem.Config.types[k].name, da, 'icon16/user_gray.png')
    end
end

concommand.Add('PlaceHit', placehit)

local function hits()
    if not LocalPlayer():IsHitMan() then return end
    local frame = vgui.Create('DFrame')
    frame:SetSize(400, 600)
    frame:MakePopup()
    frame:Center()
    frame:SetTitle('Список заказов')
    frame:SetDraggable(false)
    frame:SetSizable(false)
    local sheet = vgui.Create('DPropertySheet', frame)
    sheet:Dock(FILL)
    local orders = hitSystem:GetOrders()

    for k, v in pairs(orders) do
        local plys = {}

        for d, v in pairs(v) do
            _ = Entity(d)
            if not IsValid(_) then continue end
            if not hitSystem.Config.types[k].canAccept(_, LocalPlayer()) then continue end
            if _ == LocalPlayer() then continue end
            local t = _:GetNetVar('disguised') and _:GetNetVar('disguise_team') or _:Team()
            plys[t] = plys[t] or {}
            plys[t][d] = v
        end

        if table.Count(plys) <= 0 then continue end
        local da = vgui.Create('DCategoryList')
        da:Dock(FILL)

        for job, i in pairs(plys) do
            local collapsible = da:Add(team.GetName(job))
            local main = vgui.Create('DListLayout')
            collapsible:SetContents(main)

            for d, i in pairs(i) do
                local btn = vgui.Create('DButton', da)
                btn:Dock(TOP)
                btn:SetTall(40)
                btn:DockMargin(0, 0, 0, 4)
                btn:SetText('')

                function btn:Paint()
                end

                local text = Entity(d):Name() .. ' ( $' .. i.price .. ' )'
                local icon = vgui.Create('SpawnIcon', btn)
                icon:Dock(LEFT)
                icon:SetWide(40)
                icon:SetModel(Entity(d):GetModel())

                function btn:DoClick()
                    net.Start('hitSystem.AcceptHit')
                    net.WriteString(k)
                    net.WriteEntity(Entity(d))
                    net.SendToServer()
                    frame:Remove()
                end

                local label = vgui.Create('DLabel', btn)
                label:Dock(FILL)
                label:SetFont('Trebuchet24')
                label:SetText(text)
                main:Add(btn)
            end
        end

        sheet:AddSheet(hitSystem.Config.types[k].name, da, 'icon16/user_gray.png')
    end
end

concommand.Add('Hits', hits)

net.Receive('hitSystem.OpenMenu', function()
    local typ = net.ReadInt(3)

    if typ == 1 then
        hits()
    end
end)

local task = ''

local targData = {
    {
        name = 'Ник',
        val = function(pl)
            return pl:Name()
        end,
        barClr = Color(0, 0, 0, 0)
    },
    {
        name = 'ХП',
        val = function(pl)
            return pl:Health()
        end,
        barClr = Color(255, 25, 25, 100),
        perc = function(pl)
            return math.Clamp(pl:Health(), 0, 100) / 100
        end
    },
    {
        name = 'Броня',
        val = function(pl)
            return pl:Armor()
        end,
        barClr = Color(25, 25, 255, 100),
        perc = function(pl)
            return math.Clamp(pl:Armor(), 0, 100) / 100
        end
    },
    {
        name = 'Дистанция',
        val = function(pl, l_pl)
            local dist = pl:GetPos():Distance(l_pl:GetPos())

            return math.Clamp(math.Round(dist / 50), 1, dist) .. 'm'
        end,
        barClr = Color(0, 0, 0, 0)
    },
    {
        name = 'Профессия',
        val = function(pl)
            return pl:GetNetVar'job' or 'Unknown'
        end,
        barClr = Color(0, 0, 0, 0)
    },
    {
        name = 'Отмена заказа',
        val = function(pl)
            return '!cancel'
        end,
        barClr = Color(0, 0, 0, 0)
    }
}

local target = nil

hook.Add('hitSystem.DoOrderUpdate', 'hitSystem.UpdateTarget', function()
    target = LocalPlayer():GetNetVar('hitSystem.DoOrder')

    if not target then
        task = ''
        dMarkers.removeAll('hits')
        return
    end

    for k, v in pairs(hitSystem:GetOrders()) do
        if v[target:EntIndex()] then
            task = string.format(hitSystem.Config.types[k].task, target:Name(), v[target:EntIndex()].customer and v[target:EntIndex()].customer:Name() or '')
            break
        end
    end
end)

hook.Add('HUDPaint', 'hitSystem.TotalOrder', function()
    local ply = LocalPlayer()

    if target and IsValid(target) then
        local w = ScrW() * .2
        local h = 300
        local x, y = 5, ScrH() / 2 - (h * .5)
        local topHeight = 23
        local barHeight = 20
        local curY = y + topHeight + 3
        draw.RoundedBox(0, x, y, w, topHeight, Color(220, 106, 65, 200))
        draw.SimpleText(task, 'PS_ItemName', x + 2, y + topHeight / 2, Color(255, 255, 255), 0, 1)

        for i = 1, #targData do
            local data = targData[i]
            draw.RoundedBox(0, x, curY, w, barHeight, Color(0, 0, 0, 200))
            draw.RoundedBox(0, x, curY, not data.perc and w or (w * data.perc(target)), barHeight, data.barClr)
            draw.SimpleText(data.name .. ': ' .. data.val(target, ply), 'PS_ItemName', x + 2, curY + (barHeight / 2), Color(255, 255, 255), 0, 1)
            curY = curY + barHeight + 3
        end
    end
end)

hook.Add("OnPlayerChangedTeam", "hitSystem.markers", function(ply, old, new)
    if not ply:IsHitMan() then return end
    dMarkers.removeAll('hits')
end)


local last = {}

hook.Add('hitSystem.OrdersChange', 'hitSystem.OrdersChange', function()
    local edit = false
    local templast = {}

    for k, v in pairs(hitSystem:GetOrders()) do
        if table.Count(v) <= 0 then continue end

        if not last[k] then
            edit = true
            templast[k] = true
        end
    end

    last = templast

    if edit and LocalPlayer():IsHitMan() then
        notification.AddLegacy('Появился новый заказ, напиши !hits чтобы посмотреть.', 0, 10)
    end
end)
--addons/tool_keypad/lua/pkeypad_config.lua:
----------------------------------------------------------------------------
----------------------------------------------------------------------------
--  ____       _   _                    _  __                          _  --
-- |  _ \ __ _| |_| |_ ___ _ __ _ __   | |/ /___ _   _ _ __   __ _  __| | --
-- | |_) / _` | __| __/ _ \ '__| '_ \  | ' // _ \ | | | '_ \ / _` |/ _` | --
-- |  __/ (_| | |_| ||  __/ |  | | | | | . \  __/ |_| | |_) | (_| | (_| | --
-- |_|   \__,_|\__|\__\___|_|  |_| |_| |_|\_\___|\__, | .__/ \__,_|\__,_| --
--                                               |___/|_|                 --
--                       ____             __ _                            --
--                      / ___|___  _ __  / _(_) __ _                      --
--                     | |   / _ \| '_ \| |_| |/ _` |                     --
--                     | |__| (_) | | | |  _| | (_| |                     --
--                      \____\___/|_| |_|_| |_|\__, |                     --
--                                             |___/                      --
----------------------------------------------------------------------------
----------------------------------------------------------------------------

PatternKeypad.clickRange         = 80 -- Max range a user can interact with the keypad

PatternKeypad.availableColors    = { -- Can either be in format Color(r, g, b) or "#RRGGBB"
    Color(59, 73, 84),
    Color(100, 255, 50),
    Color(255, 40, 20),
    "#D32F2F",
    "#C2185B",
    "#7B1FA2",
    "#512DA8",
    "#303F9F",
    "#1976D2",
    "#0288D1",
    "#0097A7",
    "#00796B",
    "#388E3C",
    "#689F38",
    "#AFB42B",
    "#FBC02D",
    "#FFA000",
    "#F57C00",
    "#E64A19",
    "#5D4037",
}

PatternKeypad.soundHover         = "garrysmod/ui_hover.wav" -- Sound when hovering ui elements
PatternKeypad.soundClick         = "buttons/button15.wav"   -- Sound when clicking ui elements
PatternKeypad.soundAccessGranted = "buttons/button9.wav"    -- Sound when access is granted
PatternKeypad.soundAccessDenied  = "buttons/button11.wav"   -- Sound when access is denied


----------------------------
-- Language configuration --
----------------------------

PatternKeypad.language = {
    toolName               = "Keypad",
    toolWireName           = "Keypad",
    toolInstruction        = "Левый клик: Создать/Обновить",
    toolDescription        = "Создает кейпады",

    toolGridColumns        = "Столбы",
    toolGridRows           = "Строки",

    toolColorPrimary       = "Основной",
    toolColorSecondary     = "Доп.",
    toolColorGranted       = "Принято",
    toolColorDenied        = "Отказано",

    toolWeld               = "Сварить",
    toolFreeze             = "Заморозить",
    toolOutputOn           = "Output On:",
    toolOutputOff          = "Output Off:",
    toolGrantedSettings    = "Настройки при верном вводе",
    toolDeniedSettings     = "Настройки при неверном вводе",
    toolHoldLength         = "Длительность:",
    toolInitialDelay       = "Задержка:",
    toolMultiplePressDelay = "Задержка повторений:",
    toolAdditionalRepeats  = "Кол-во повторений",
    toolDefaults           = "Сброс настроек",

    undo                   = "Отмена Pattern Keypad",
    cleanName              = "Pattern Keypads",
    cleanedUp              = "Очистить все Pattern Keypads",
    limitReached           = "Достигнут лимит Pattern Keypad",

    textGranted            = "ПРИНЯТО",
    textDenied             = "ОТКАЗАНО",

    errorNoPattern         = "There is no pattern set!",
}

--addons/module_hitregtest/lua/autorun/leyhitreg.lua:
if (SERVER) then
    AddCSLuaFile()
end

LeyHitreg = LeyHitreg or {}


-- ShotDirForceDisabled allows is for testing with bullet dirs to test how problematic some swep bases are
-- if this alleviates issues, then you need to disable bullet penetration etc in your swep base
LeyHitreg.ShotDirForceDisabled = true
LeyHitreg.DisableSecurityChecks = false
LeyHitreg.IgnoreCanNextPrimaryAttack = true





-- don't touch anything below this. no config. no, leave it. thanks.

LeyHitreg.Disabled = false -- debug: disable addon
LeyHitreg.DisabledOnlyOnClient = false -- debug: disable only on cl
LeyHitreg.NoSpread = false -- debug: enable nospread for everyone
LeyHitreg.ShowActualShotHit = false -- debug: show where the shot actually landed on the sv without spread
LeyHitreg.ShowActualShotSpreadedHit = false -- debug: show where the shot actually landed on the sv with spread
LeyHitreg.BrokenDefaultSpread = false -- debug: enable broken default spread behaviour, broken because its only applied visually now
LeyHitreg.LogHitgroupMismatches = false -- debug: log hitgroup mismatches
LeyHitreg.LogFixedBullets = false -- debug: log the amount of bullets which got hitregged
LeyHitreg.LogInvalidFOV = false -- debug: log invalid FOV
LeyHitreg.LogInvalidShots = false -- debug: log the invalid shots
LeyHitreg.BulletAimbot = false -- debug: set eyeangles to position of bullet
LeyHitreg.LogTargetBone = false -- debug: log target bone
LeyHitreg.HitScanDisabled = false -- debug: disable hitscan within bullet cb
LeyHitreg.BulletOverwriteDisabled = false -- debug: disable hitscan and bullet overwrite
LeyHitreg.AnnounceClientHits = false -- debug: log when the client sends a hit to server
LeyHitreg.DisableLagComp = false -- debug: disable sources original lag compensation

if (LeyHitreg.Disabled) then
    print("[/LeyHitreg/] Disabled")
    return
end

LeyHitreg.svfiles = {
    "leyhitreg/server/bulletprocessing/hitscan.lua",
    "leyhitreg/server/bulletprocessing/processbullet.lua",
    "leyhitreg/server/damageinfo/scaledamagehack.lua",
    "leyhitreg/server/damageinfo/fixscaling.lua",
    "leyhitreg/server/receiveshotinfo/receiveshotinfo.lua",
    "leyhitreg/server/receiveshotinfo/shotvalidator.lua",
}

LeyHitreg.clfiles = {
    "leyhitreg/client/sendshots/sendshots.lua",
    "leyhitreg/client/sendshots/fetchspreads.lua"
}

LeyHitreg.sharedfiles = {
    "leyhitreg/shared/spreadsystem/bulletspread.lua",
    "leyhitreg/shared/spreadsystem/firebullets.lua",
    "leyhitreg/shared/disablelagcomp/disablelagcomp.lua",
    "leyhitreg/shared/workarounds/workarounds.lua",
    "leyhitreg/shared/workarounds/swepbases.lua"
}

local function includeOnCS(filename)
    if (SERVER) then
        print("Sending to clients: " .. filename)
        AddCSLuaFile(filename)
    end

    if (CLIENT) then
        include(filename)
    end
end

local function includeOnSV(filename)
    if (SERVER) then
        print("Loading: " .. filename)
        include(filename)
    end
end

function LeyHitreg:ProcessLuaFiles()
    for k,v in pairs(LeyHitreg.clfiles) do
        includeOnCS(v)
    end

    for k,v in pairs(LeyHitreg.svfiles) do
        includeOnSV(v)
    end

    for k,v in pairs(LeyHitreg.sharedfiles) do
        includeOnCS(v)
        includeOnSV(v)
    end
end

LeyHitreg:ProcessLuaFiles()

function LeyHitreg:DisableMoatHitreg()
    if (MOAT_HITREG) then
        MOAT_HITREG.MaxPing = 1
    end

    if (ConVarExists("moat_alt_hitreg")) then
        RunConsoleCommand("moat_alt_hitreg", "0")
    end

    if (SHR) then
        if (SHR.Config) then
            SHR.Config.Enabled = false
            SHR.Config.ClientDefault = 0
        end
        hook.Remove("EntityFireBullets", "SHR.FireBullets")
        hook.Remove("EntityFireBullets", "‍a")
        net.Receivers["shr"] = function() end
    end
end
--addons/module_hitregtest/lua/leyhitreg/shared/spreadsystem/firebullets.lua:
function LeyHitreg:SpreadedEntityFireBullets(ply, wep, bullet, spread)
    if (LeyHitreg.Disabled) then
        return
    end

    if (LeyHitreg.BrokenDefaultSpread) then
        return
    end

    local bulletSpread = spread or LeyHitreg:GetWeaponSpread(ply, wep, bullet)
    local appliedAny, newDir = self:ApplyBulletSpread(ply, bullet.Dir, bulletSpread)

    if (not appliedAny) then
        return
    end

    bullet.Spread = vector_origin
    bullet.Dir = newDir
    return true
end

--addons/module_hitregtest/lua/leyhitreg/shared/disablelagcomp/disablelagcomp.lua:
local meta = FindMetaTable("Player")
meta.OldLagCompensation = meta.OldLagCompensation or meta.LagCompensation

function meta:LagCompensation(...)
    if (LeyHitreg.DisableLagComp and not LeyHitreg.Disabled) then
        return
    end

    return self:OldLagCompensation(...)
end
--addons/module_luadev/lua/luadev/luadev.lua:
module("luadev",package.seeall)

local function CMD(who)
	return CLIENT and "CMD" or who or "CMD"
end

COMMAND('run_sv',function(ply,_,script,who)
	RunOnServer(script,CMD(who),MakeExtras(ply))
end,true)

COMMAND('run_sh',function(ply,_,script,who)
	RunOnShared(script,CMD(who),MakeExtras(ply))
end,true)

COMMAND('run_clients',function(ply,_,script,who)
	RunOnClients(script,CMD(who),MakeExtras(ply))
end,true)

COMMAND('run_self',function(ply,_,script,who)
	RunOnSelf(script,CMD(who),MakeExtras(ply))
end,true)

COMMAND('run_client',function(ply,tbl,script,who)

	if !tbl[1] or !tbl[2] then Print("Syntax: lua_run_client (steamid/userid/uniqueid/part of name) script") return end

	local cl=FindPlayer(tbl[1])

	if !cl then Print("Client not found!\n") return end
	if CLIENT then
		Print("Running script on "..tostring(cl:Name()))
	end

	local _, e = script:find('^%s*"[^"]+')
	if e then
		script = script:sub(e+2)
	else
		local _, e = script:find('^%s*[^%s]+%s')
		if not e then
			Print("Invalid Command syntax.")
			return
		end
		script = script:sub(e)
	end

	script = script:Trim()

	RunOnClient(script,cl,CMD(who),MakeExtras(ply))

end)

COMMAND('send_cl',function(ply,tbl,cmd,who)

	if !tbl[1] or !tbl[2] then Print("Syntax: lua_send_cl (steamid/userid/uniqueid/part of name) \"path\"") return end

	local cl=FindPlayer(tbl[1])

	if !cl then Print("Client not found!\n") return end
	Print("Running script on "..tostring(cl:Name()))


	table.remove(tbl,1)
	local path=TableToString(tbl)

	local Path,searchpath=RealFilePath(path)
	if !Path then Print("Could not find the file\n") return end

	local content = Path and GiveFileContent(Path,searchpath)
	if !content then Print("Could not read the file\n") return end

	RunOnClient(content,cl,who or CMD(who),MakeExtras(ply))

end)

COMMAND('send_sv',function(ply,c,cmd,who)

	local Path,searchpath=RealFilePath(c[2] and TableToString(c) or c[1])
	if !Path then Print("Could not find the file\n") return end

	local content = Path and GiveFileContent(Path,searchpath)
	if !content then Print("Could not read the file\n") return end

	local who=string.GetFileFromFilename(Path)

	RunOnServer(content,who or CMD(who),MakeExtras(ply))

end)

COMMAND('send_clients',function(ply,c,cmd,who)

	local Path,searchpath=RealFilePath(c[2] and TableToString(c) or c[1])
	if !Path then Print("Could not find the file\n") return end

	local content = Path and GiveFileContent(Path,searchpath)
	if !content then Print("Could not read the file\n") return end

	local who=string.GetFileFromFilename(Path)

	RunOnClients(content,who or CMD(who),MakeExtras(ply))

end)

COMMAND('send_sh',function(ply,c,cmd,who)

	local Path,searchpath=RealFilePath(c[2] and TableToString(c) or c[1])
	if !Path then Print("Could not find the file\n") return end

	local content = Path and GiveFileContent(Path,searchpath)
	if !content then Print("Could not read the file\n") return end

	local who=string.GetFileFromFilename(Path)

	RunOnShared(content,who or CMD(who),MakeExtras(ply))

end)

local function Guess(name,Path)
	
	if name=="init" or name=="shared"  or name=="cl_init" then
		local newname = Path:gsub("\\","/"):match("^.+%/([^%/]-)/.-%.lua$")
		Print("Guessing identifier: "..tostring(newname or "<Failed>"))
		return newname or name
	end
	
	return name
end

local function SendEFFECT(cl,Path,ply,c,cmd,who)
	local who=string.GetFileFromFilename(Path)
	
	local effectname=string.GetFileFromFilename(Path):gsub("%.lua","")
	
	effectname = Guess(effectname,Path)
	
	if cl then
		RunOnClients(cl,who or CMD(who),MakeExtras(ply,{effect=effectname}))
	end
	
end

COMMAND('send_effect',function(ply,c,cmd,who)
	local path = c[2] and TableToString(c) or c[1]
	
	local Path,searchpath=RealFilePath(path)
	if not Path then
		Print("Could not find the file\n")
		return
	end
	
	local content = GiveFileContent(Path,searchpath)
	if content then
		local sh = content
		SendEFFECT(content,Path,ply,c,cmd,who)
		return
	end
	
	local cl = GiveFileContent(Path..'/init.lua',searchpath)
	
	if cl then
		SendEFFECT(cl,Path,ply,c,cmd,who)
		return
	else
		Print("Could not find required files from the folder\n")
	end

end)



local function SendSWEP(cl,sh,sv,Path,ply,c,cmd,who)
	local who=string.GetFileFromFilename(Path)
	
	local swepname=string.GetFileFromFilename(Path):gsub("%.lua","")
	swepname=Guess(swepname,Path)
	
	if cl then
		RunOnClients(cl,who or CMD(who),MakeExtras(ply,{swep=swepname}))
	end
	if sh then
		RunOnShared(sh,who or CMD(who),MakeExtras(ply,{swep=swepname}))
	end
	if sv then
		RunOnServer(sv,who or CMD(who),MakeExtras(ply,{swep=swepname}))
	end
	
end

COMMAND('send_wep',function(ply,c,cmd,who)
	local path = c[2] and TableToString(c) or c[1]
	
	local Path,searchpath=RealFilePath(path)
	if not Path then
		Print("Could not find the file\n")
		return
	end
	
	local content = GiveFileContent(Path,searchpath)
	if content then
		local sh = content
		SendSWEP(nil,sh,nil,Path,ply,c,cmd,who)
		return
	end
	
	local cl = GiveFileContent(Path..'/cl_init.lua',searchpath)
	local sh = GiveFileContent(Path..'/shared.lua',searchpath)
	local sv = GiveFileContent(Path..'/init.lua',searchpath)
	
	if sv or sh or cl then
		SendSWEP(cl,sh,sv,Path,ply,c,cmd,who)
		return
	else
		Print("Could not find required files from the folder\n")
	end

end)


local function SendENT(cl,sh,sv,Path,ply,c,cmd,who)
	local who=string.GetFileFromFilename(Path)
	
	local entname=string.GetFileFromFilename(Path):gsub("%.lua","")
	entname = Guess(entname,Path)
	if cl then
		RunOnClients(cl,who or CMD(who),MakeExtras(ply,{sent=entname}))
	end
	if sh then
		RunOnShared(sh,who or CMD(who),MakeExtras(ply,{sent=entname}))
	end
	if sv then
		RunOnServer(sv,who or CMD(who),MakeExtras(ply,{sent=entname}))
	end
	
end

COMMAND('send_ent',function(ply,c,cmd,who)
	local path = c[2] and TableToString(c) or c[1]
	
	local Path,searchpath=RealFilePath(path)
	if not Path then
		Print("Could not find the file\n")
		return
	end
	
	local content = GiveFileContent(Path,searchpath)
	if content then
		local sh = content
		SendENT(nil,sh,nil,Path,ply,c,cmd,who)
		return
	end
	
	local cl = GiveFileContent(Path..'/cl_init.lua',searchpath)
	local sh = GiveFileContent(Path..'/shared.lua',searchpath)
	local sv = GiveFileContent(Path..'/init.lua',searchpath)
	
	if sv or sh or cl then
		SendENT(cl,sh,sv,Path,ply,c,cmd,who)
		return
	else
		Print("Could not find required files from the folder\n")
	end

end)


COMMAND('watch_kill',function(ply,c,cmd,wholeline)
	
	local watchlist = GetWatchList()
	
	if c[1]=="" or not c[1] then 
		Print"Killing all"
		table.Empty(watchlist) 
		return 
	end
	
	local t= table.remove(watchlist,tonumber(c[1]))
	Print("killing",t and tostring(t.path) or "(not found)")
end,true)

COMMAND('watch',function(ply,c,cmd,wholeline)

 	local path_orig = c[1]
	table.remove(c,1)
	
	local fpath,searchpath=RealFilePath(path_orig,findpath)
	if not fpath then Print("Could not find the file\n") return end
	
	local content = fpath and GiveFileContent(fpath,searchpath)
	local time = content and fpath and FileTime(fpath,searchpath)
	if not content or not time then Print("File not readable\n") return end
	
	local found
	for k,v in next,c do
		if v=="PATH" then
			c[k] = path_orig
			found = true
		end
		if v=="FILE" then
			c[k] = path_orig
			found = true
		end
		if v=="RPATH" then
			c[k] = fpath
			found = true
		end
		if v=="NOPATH" then
			c[k] = false
			found=true
		end
	end
	
	for i=#c,1,-1 do
		if c[i]==false then
			table.remove(c,i)
		end
	end
	
	if not c[1] then
		Print"Missing command, assuming lua_send_self" 
		c[1] = 'lua_send_self'
	end
	
	if not found then
		table.insert(c,path_orig)
	end
	
	local cmdd = {}
	for k,v in next,c do
		cmdd[k]=('%q'):format(tostring(v))
	end
	Print("Watching '"..tostring(fpath).."': ",table.concat(cmdd," "))
	
	local entry = {
		path = fpath,
		searchpath = searchpath,
		time = time,
		cmd = c,
	}
	
	local watchlist = GetWatchList()
	watchlist[#watchlist+1] = entry
	
end)






COMMAND('send_self',function(ply,c,cmd,who)

	local Path,searchpath=RealFilePath(c[2] and TableToString(c) or c[1])
	if !Path then Print("Could not find the file\n") return end

	local content = GiveFileContent(Path,searchpath)
	if !content then Print("Could not read the file\n") return end

	local who=string.GetFileFromFilename(Path)

	RunOnSelf(content,who or CMD(who),MakeExtras(ply))

end)


if SERVER then return end

net.Receive(Tag,function(...) _ReceivedData(...) end)

function _ReceivedData(len)
	
	local script = ReadCompressed()
	local decoded=net.ReadTable()
	
	local info=decoded.info
	local extra=decoded.extra

	local ok,ret = Run(script,tostring(info),extra)

	if not ok then
		ErrorNoHalt(tostring(ret)..'\n')
	end
	
	--[[ -- Not done
	if extra.retid then
		net.Start(net_retdata)
			net.WriteUInt(extra.retid,32)
			net.WriteBool(ok)
			net.WriteTable(ret)
		net.SendToServer()
	end --]]

end

function CheckStore(src)
	if not ShouldStore() then return end
	local crc = util.CRC(src)
	local path = "luadev_hist/".. crc ..'.txt'
	
	if file.Exists(path,'DATA') then return end
	if not file.IsDir("luadev_hist",'DATA') then file.CreateDir("luadev_hist",'DATA') end
	
	file.Write(path,tostring(src),'DATA')
end

function ToServer(data)
	if TransmitHook(data)~=nil then return end
	
	CheckStore(data.src)
	
	net.Start(Tag)
		WriteCompressed(data.src or "")
		
		-- clear extra data
		data.src = nil
		if data.extra then
			data.extra.ply = nil
			if table.Count(data.extra)==0 then data.extra=nil end
		end
		
		net.WriteTable(data)
		if net.BytesWritten()==65536 then 
			Print("Unable to send lua code (too big)\n")
			return nil,"Unable to send lua code (too big)"
		end
		
	net.SendToServer()
	return true
end


function RunOnClients(script,who,extra)
	
	if not who and extra and isentity(extra) then extra = {ply=extra} end
	
	local data={
		src=script,
		dst=TO_CLIENTS,
		info=who,
		extra=extra,
	}

	return ToServer(data)

end


function RunOnSelf(script,who,extra)
	if not isstring(who) then who = nil end
	if not who and extra and isentity(extra) then extra = {ply=extra} end
	--if luadev_selftoself:GetBool() then
	--	Run
	--end
	return RunOnClient(script,LocalPlayer(),who,extra)
end

function RunOnClient(script,targets,who,extra)
	-- compat
		if not targets and isentity(who) then
			targets=who
			who = nil
		end
		
		if extra and isentity(extra) and who==nil then extra={ply=extra} end
		
	if (not istable(targets) and !IsValid(targets))
	or (istable(targets) and table.Count(targets)==0)
	then error"Invalid player(s)" end
	
	local data={
		src=script,
		dst=TO_CLIENT,
		dst_ply=targets,
		info=who,
		extra=extra,
	}

	return ToServer(data)

end

function RunOnServer(script,who,extra)
	if not who and extra and isentity(extra) then extra = {ply=extra} end
	
	local data={
		src=script,
		dst=TO_SERVER,
		--dst_ply=pl
		info=who,
		extra=extra,
	}
	return ToServer(data)

end

function RunOnShared(script,who,extra)
	if not who and extra and isentity(extra) then extra = {ply=extra} end
	
	local data={
		src=script,
		dst=TO_SHARED,
		--dst_ply=pl
		info=who,
		extra=extra,
	}

	return ToServer(data)

end

--addons/module_market/lua/market/sh_util.lua:
function wmarket.getMaxOrders(ply)
    return wmarket.config.maxOrders
end

function wmarket.getPriceWithComission(ply, price)
    local comm = ply:IsVIP() and wmarket.config.comission or wmarket.config.comission_vip

    return price - price * comm
end

wmarket.items = wmarket.items or {}
function wmarket.addItem(id, data)
    local _, index = wmarket.getItem(id)
    if index then table.remove(wmarket.items, index) end

    data.id = id
    table.insert(wmarket.items, data)
end

function wmarket.getItem(id)
    return wlib.array.find(wmarket.items, function(i) return i.id == id end)
end

wmarket.currencies = wmarket.currencies or {}
function wmarket.addCurrency(id, data)
    local _, index = wmarket.getCurrency(id)
    if index then table.remove(wmarket.currencies, index) end

    data.id = id
    table.insert(wmarket.currencies, data)

    --wmarket.addItem(id, data)
end

function wmarket.getCurrency(id)
    return wlib.array.find(wmarket.currencies, function(i) return i.id == id end)
end

function wmarket.getSummary(cur, item)
    local cid, itemid = isstring(cur) and cur or cur.id, isstring(item) and item or item.id
    return wmarket.summary[cid] and wmarket.summary[cid][itemid]
end

--
local mat_error = Material('error')

function wmarket.addItemStoreItem(id, data)
    local d = {
        name = 'ITEMSTORE ITEM',
        description = '',
        itemstore_class = '',
        weapon_class = '',
        canAdd = function(self, ply, amount)
            local con = SERVER and ply.Inventory or itemstore.containers.Get(ply.InventoryID)
            local base = itemstore.items.Get(self.itemstore_class)
            local stacks = base.Stackable and math.ceil(amount/base.MaxStack) or amount
    
            local hasEmpty = 0
            for i=1, con:GetSize() do
                if not con:GetItem(i) then
                    hasEmpty = hasEmpty + 1
                end
    
                if hasEmpty >= stacks then
                    return true
                end
            end
    
            return false, 'Недостаточно места в инвентаре'
        end,
        add = function(self, ply, amount)
            local con = ply.Inventory
            local base = itemstore.items.Get(self.itemstore_class)
            local maxstack = base.Stackable and base.MaxStack or 1
            local stacks = base.Stackable and math.ceil(amount/base.MaxStack) or amount
    
            for i=1, stacks do
                local item = itemstore.Item(self.itemstore_class)
                for k, v in pairs(self.item_fields or {}) do
                    item:SetData(k, v)
                end
                local count = math.min(amount, maxstack)
                item:SetAmount(count)
    
                assert(con:AddItem(item), 'Cant add item "'..self.id..'" to inventory')
    
                amount = amount - count
            end
        end,
        canTake = function(self, ply, amount)
            local con = SERVER and ply.Inventory or itemstore.containers.Get(ply.InventoryID)
    
            local has = 0
            for _, item in pairs(con:GetItems()) do
                if item:GetClass() == self.itemstore_class and (not self.item_customcheck or self:item_customcheck(item)) then
                    has = has + item:GetAmount()
                end
    
                if has >= amount then
                    return true
                end
            end
        
            return false
        end,
        take = function(self, ply, amount)
            local con = ply.Inventory
    
            con:Suppress(function()
                for k, item in pairs(con:GetItems()) do
                    if item:GetClass() == self.itemstore_class and (not self.item_customcheck or self:item_customcheck(item)) then
                        local toTake = item:GetAmount()
                        toTake = math.min(toTake, amount)
        
                        item:SetAmount(item:GetAmount() - toTake)
        
                        if item:GetAmount() <= 0 then
                            con:SetItem(k, nil)
                        end
        
                        amount = amount - toTake
    
                        if amount <= 0 then break end
                    end
                end
    
                return true
            end)
        end,
        getAmount = function(self, ply)
            local con = SERVER and ply.Inventory or itemstore.containers.Get(ply.InventoryID)
    
            local amount = 0
            for _, item in pairs(con:GetItems()) do
                if item:GetClass() == self.itemstore_class and (not self.item_customcheck or self:item_customcheck(item)) then
                    amount = amount + item:GetAmount()
                end
            end
        
            return amount
        end,
    }

    table.Merge(d, data)

    return wmarket.addItem(id, d)
end

function wmarket.addPSItem(id, data)
    local d = {
        name = 'PS ITEM',
        description = '',
        ps_class = '',
        canAdd = function(self, ply, amount)
            return true
        end,
        add = function(self, ply, amount)
            ply:PS_AddToInventory(self.ps_class, amount)
        end,
        canTake = function(self, ply, amount)
            return ply:PS_InventoryCount(self.ps_class) >= amount
        end,
        take = function(self, ply, amount)
            ply:PS_RemoveFromInventory(self.ps_class, amount)
        end,
        getAmount = function(self, ply)
            return ply:PS_InventoryCount(self.ps_class)
        end,
        getMaterial = function(self)
            return PS.Items[self.ps_class].Material or mat_error
        end,
    }

    table.Merge(d, data)

    return wmarket.addItem(id, d)
end
--addons/module_market/lua/market/cl_core.lua:
surface.CreateFont('wmarket.14', {
    font = 'Calibri',
    extended = true,
    size = 14,
    weight = 350,
})

surface.CreateFont('wmarket.18', {
    font = 'Calibri',
    extended = true,
    size = 18,
    weight = 350,
})

surface.CreateFont('wmarket.20', {
    font = 'Calibri',
    extended = true,
    size = 20,
    weight = 350,
})

surface.CreateFont('wmarket.24', {
    font = 'Calibri',
    extended = true,
    size = 24,
    weight = 350,
})

surface.CreateFont('wmarket.32', {
    font = 'Calibri',
    extended = true,
    size = 32,
    weight = 350,
})
surface.CreateFont('wmarket.32.bold', {
    font = 'Calibri',
    extended = true,
    size = 32,
    weight = 800,
})

hook.Add('InitPostEntity', 'wmarket.getSummary', function()
    wmarket.requestSummary()
end)

function wmarket.selectItemPage(item, cur)
    local pnl = wmarket.mainPanel
    if not IsValid(pnl) then return end

    item = isstring(item) and wmarket.getItem(item) or item
    if not item then return end
    cur = isstring(cur) and wmarket.getCurrency(cur) or cur
    cur = (item.currency and wmarket.getCurrency(item.currency)) or cur or pnl:GetSelectedCurrency()
    if not cur then return end

    wmarket.selectedItem, wmarket.selectedCurrency = item, cur

    pnl.curbox:ChooseOption(pnl.curbox:GetOptionTextByData(cur))
    pnl:SetSelectedCurrency(cur)
    pnl:RefreshOrders()

    if not IsValid(pnl.itempage) then
        pnl.itempage = vgui.Create('wmarket_itempage', pnl.right)
        pnl.itempage:Dock(FILL)
    end

    pnl.itempage:SetItem(item)
    pnl.itempage:SetCurrency(cur)
    timer.Simple(0, fp{pnl.itempage.Rebuild, pnl.itempage})
end

local myorders
function wmarket.openMyOrders(parent)
    if IsValid(myorders) then myorders:Remove() end

    myorders = vgui.Create('wmarket_myorders')
    myorders:SetSize(math.min(800, parent:GetWide()), math.min(400, parent:GetTall()))

    wlib.panels.overlay(parent, myorders)
    wmarket.requestMyOrders()
end

net.Receive('wmarket.getMyOrders', function()
    if not IsValid(myorders) then return end
    
    myorders:SetData(net.ReadTable())
end)

local storage
function wmarket.openStorage(parent)
    if IsValid(storage) then storage:Remove() end

    storage = vgui.Create('DScrollPanel')
    storage:SetSize(math.min(300, parent:GetWide()), math.min(400, parent:GetTall()))

    wlib.panels.overlay(parent, storage)

    for _, v in ipairs(wmarket.storage or {}) do
        local item = vgui.Create('wmarket_storageitem', scroll)
        item:Dock(TOP)
        item:InvalidateParent(true)
        item:InvalidateLayout(true)

        item:SetData(v)
        timer.Simple(0, fp{item.SizeToContents, item})

        storage:AddItem(item)
    end
end

hook.Add('wmarket.storageUpdated', 'updatestorage', function()
    if not IsValid(storage) then return end
    if #wmarket.storage == 0 then return storage:Remove() end

    storage:Clear()
    for _, v in ipairs(wmarket.storage or {}) do
        local item = vgui.Create('wmarket_storageitem', scroll)
        item:Dock(TOP)
        item:InvalidateParent(true)
        item:InvalidateLayout(true)

        item:SetData(v)
        timer.Simple(0, fp{item.SizeToContents, item})

        storage:AddItem(item)
    end
end)

local inventory
function wmarket.openInventory(parent)
    if IsValid(inventory) then inventory:Remove() end

    inventory = vgui.Create('wmarket_inventory')
    inventory:SetSize(math.min(800, parent:GetWide()), math.min(600, parent:GetTall()))

    wlib.panels.overlay(parent, inventory)
end

function wmarket.openCreateOrder(parent, item, currency, type, amount, selfprice, customerprice)
    local createorder = vgui.Create('wmarket_createorder')
    createorder:SetItem(item)
    createorder:SetCurrency(currency)
    if type then createorder:SetType(type) end
    if amount then createorder:SetAmount(amount) end
    if selfprice then createorder:SetSelfPrice(selfprice) end
    if customerprice then createorder:SetCustomerPrice(customerprice) end

    createorder:SetWide(math.min(300, parent:GetWide()))
    wlib.panels.overlay(parent, createorder)
    createorder:InvalidateLayout(true)
    createorder:SizeToChildren(false, true)
end
--addons/module_market/lua/market/vgui/storageitem.lua:
local PANEL = {}

function PANEL:Init()
    self:DockPadding(6,6,6,6)

    self.desc = vgui.Create('DLabel', self)
    self.desc:Dock(TOP)
    self.desc:SetZPos(0)
    self.desc:SetDark(true)
    --self.desc:SetAutoStretchVertical(true)
    
    self.footer = vgui.Create('DPanel', self)
    self.footer:Dock(TOP)
    self.footer:DockMargin(0, 12, 0, 0)
    self.footer:SetZPos(10)
    self.footer:SetTall(22)
    self.footer:SetPaintBackground(false)

    self.claim = vgui.Create('DButton', self.footer)
    self.claim:Dock(RIGHT)
    self.claim:SetWide(100)
    self.claim:SetText('Забрать')
    self.claim:SetIcon('icon16/accept.png')
    self.claim.DoClick = fp{self.Claim, self}
end

wlib.accessor(PANEL, 'id', 'ID')
wlib.accessor(PANEL, 'item', 'Item')
wlib.accessor(PANEL, 'amount', 'Amount')
wlib.accessor(PANEL, 'description', 'Description')

function PANEL:SizeToContents()
    self.desc:SetText(wlib.string.wrap(self:GetDescription() or '', self.desc:GetFont(), self:GetWide()-10))
    self.desc:SizeToContents()

    self:SizeToChildren(false, true)
end

function PANEL:PerformLayout(w, h)
    self:SizeToContents()
end

function PANEL:SetData(d)
    self:SetID(d.id)
    self:SetItem(wmarket.getItem(d.item) or wmarket.getCurrency(d.item))
    self:SetAmount(d.amount)
    self:SetDescription(d.description)

    self:SizeToContents()
end

function PANEL:Claim()
    local res, err = self.item:canAdd(LocalPlayer(), self.amount)
    if not res then return notification.AddLegacy(err or 'Ты не можешь забрать этот предмет', 1, 5) end

    wmarket.claimStoredItem(self.id)
end

vgui.Register('wmarket_storageitem', PANEL, 'DPanel')
--addons/module_outfitter/lua/includes/modules/coext.lua:

local Tag='coext'
if SERVER then AddCSLuaFile() end


if not co then require"co" end

local function http_wrap(ok,err,okerr,...)
	if okerr==ok then
		return true,...
	elseif okerr==err then
		return false,...
	else
		error"Invalid fetch callback called"
	end
end

function co.post(url,data,hdr)
	
	local ok,err = co.newcb(),co.newcb()
	http.Post(url,data,ok,err,hdr)
	
	return http_wrap(ok,err,co.waitone())

end

function co.fetch(url,hdr)
	
	local ok,err = co.newcb(),co.newcb()
	http.Fetch(url,ok,err,hdr)
	
	return http_wrap(ok,err,co.waitone())

end


co.PlayURL=function(url,params)
	local cb=co.newcb()
	sound.PlayURL(url,params or '',cb)
	return co.waitcb(cb)
end

co.PlayFile=function(url,params)
	local cb=co.newcb()
	sound.PlayFile(url,params or '',cb)
	return co.waitcb(cb)
end



-- server info query
-- TODO: Validate IP
do
	local cbs={}

	local _sinfo
	local function runcbs(entry,...)
		local ip,port = entry[1],entry[2]
		local callbacks = cbs[ip] and cbs[ip][port]
		
		if not callbacks then return end
		
		cbs[ip][port]=nil
		if not next(cbs[ip]) then
			cbs[ip]=nil
		end
		
		local ncallbacks = #callbacks
		for i=1,ncallbacks do
			local func = callbacks[i]
			local ok,err = xpcall(func,debug.traceback,...)
			if not ok then ErrorNoHalt(err..'\n') end
		end
	end

	local function sinfo()
		_sinfo = _sinfo or serverquery.getServerInfoWorker(function(ret,entry,err)
			--print(">",ret,entry,err)
			if ret then
				
				assert(entry,"entry missing??")
			
				runcbs(entry,entry)
				
				return
			end
			
			if ret==false then
				if entry==true then
					return -- worker started
				elseif entry==false then
					return --worker ended
				else
					-- error
					runcbs(entry,nil,err or "timeout",entry)
					
					return
					
				end
			end
		
			if err then
				ErrorNoHalt(tostring(err)..'\n')
			end
		end)
		return _sinfo
	end

	function co.serverinfo(ip,port)
		if not port then port=27015 end
		local a,b = ip:match'^(.+)%:(%d+)$'
		if b then
			ip,port = a,tonumber(b)
		end
		assert(not ip:find(":",1,true))
		assert(ip and port)
		
		local cb = co.newcb()
		
		cbs[ip] = cbs[ip] or {}
		cbs[ip][port] = cbs[ip][port] or {}
		local t = cbs[ip][port]
		t[#t+1]=cb
		
		sinfo().add_queue(ip, port)
		
		return co.waitcb(cb)
		
	end

	--co(function()
	--	print("1",co.serverinfo"195.154.166.219".name)
	--	print("2",co.serverinfo"195.154.166.219".name)
	--	print("7",co.serverinfo"46.174.53.218:27015".name)
	--	co(function()
	--		print("3",co.serverinfo"94.23.170.2".name)
	--		print("4",co.serverinfo"94.23.170.2".name)
	--	end)
	--	print("8",co.serverinfo"94.23.170.2".name)
	--end)
	--co(function()
	--	print("5",co.serverinfo"46.174.53.218:27015".name)
	--	print("6",co.serverinfo"46.174.53.218:27015".name)
	--end)
end


-- server players query
-- TODO: Validate IP
do

	local cbs={}

	local _sinfo
	local function runcbs(entry,...)
		local ip,port = entry[1],entry[2]
		local callbacks = cbs[ip] and cbs[ip][port]
		
		if not callbacks then return end
		
		cbs[ip][port]=nil
		if not next(cbs[ip]) then
			cbs[ip]=nil
		end
		
		local ncallbacks = #callbacks
		for i=1,ncallbacks do
			local func = callbacks[i]
			local ok,err = xpcall(func,debug.traceback,...)
			if not ok then ErrorNoHalt(err..'\n') end
		end
	end

	local function sinfo()
		_sinfo = _sinfo or serverquery.playerListFetcher(function(ret,entry,err)
			--print(">",ret,entry,err)
			if ret then
				
				assert(entry,"entry missing??")
			
				runcbs(entry,entry)
				
				return
			end
			
			if ret==false then
				if entry==true then
					return -- worker started
				elseif entry==false then
					return --worker ended
				else
					-- error
					runcbs(entry,nil,err or "timeout",entry)
					
					return
					
				end
			end
		
			if err then
				ErrorNoHalt(tostring(err)..'\n')
			end
		end)
		return _sinfo
	end

	function co.serverplayers(ip,port)
		if not port then port=27015 end
		local a,b = ip:match'^(.+)%:(%d+)$'
		if b then
			ip,port = a,tonumber(b)
		end
		assert(not ip:find(":",1,true))
		assert(ip and port)
		
		local cb = co.newcb()
		
		cbs[ip] = cbs[ip] or {}
		cbs[ip][port] = cbs[ip][port] or {}
		local t = cbs[ip][port]
		t[#t+1]=cb
		
		sinfo().add_queue(ip, port)
		
		return co.waitcb(cb)
		
	end

	--co(function()
	--	PrintTable(co.serverplayers"195.154.166.219")
	--end)
end

local function shuffle( t )
    local rand = math.random
    local iterations = #t
    local j
    
    for i = iterations, 2, -1 do
        j = rand(i)
        t[i], t[j] = t[j], t[i]
    end
end


function co.dns(a,b)
	local cb = co.newcb()
	b=b or 'A'
	http.ResolveDNS(a,b,cb)
	
	local ret,err = co.waitcb(cb)
	if not ret then return nil,err end
	if ret.errstr then
		return nil,ret.errstr,ret.errcode
	end
	if not ret[1] then
		return ret
	end
	
	shuffle(ret)
	for _,v in next,ret do
		if (b=='A' or b=='AAAA') and v.address then
			return v.address,ret
		elseif b=='TXT' and v.txt then
			return v.txt,ret
		elseif b~='A' and b~='AAAA' and v.address then
			return v.address,ret
		end
	end
	return true,ret
	
end
--[[
co(function()
	local ip = assert(co.dns("g1.metastruct.net"))
	PrintTable(assert(co.serverinfo(ip)))
end)
--]]








if not CLIENT then return end

function steamworks.coGetList(a,b,c,d,e,f)
	local cb = co.newcb()
	steamworks.GetList(a,b,c,d,e,f,cb)
	return co.waitcb(cb)
end


function steamworks.coFileInfo(a)
	local cb = co.newcb()
	steamworks.FileInfo(a,cb)
	return co.waitcb(cb)
end

function steamworks.coFileInfos(idlist)
	if not idlist[1] then return end
	local cb = co.newcb()
	local t = {}
	for _,id in next,idlist do
		t[id]=false
	end
	
	for id,state in next,t do
		steamworks.FileInfo(id,cb)
	end
	
	local any
	for id,state in next,t do
		local _,data = co.waitone(cb)
		if data then
			local id = data.id
			if nil == t[id] then
				print("WTF",id)
			else
				any = true
				t[id] = data
			end
			
		end
	end
	return any and t
end

function steamworks.coDownload( fileid, uncomp )
	local instant
	local path
	local cb = co.newcb()
	local function cb2(...)
		if instant==nil then
			path = ...
			instant = true
			return
		end
		return cb(...)
	end
	steamworks.Download( fileid, uncomp, cb2 )

	if instant==nil then
		instant = false
		path = co.waitcb(cb)
	end
	return path
end


function steamworks.coDownloadUGC( fileid )
	local instant
	local path,fd
	local cb = co.newcb()
	local function cb2(...)
		if instant==nil then
			path,fd = ...
			instant = true
			return
		end
		return cb(...)
	end
	steamworks.DownloadUGC( fileid, cb2 )

	if instant==nil then
		instant = false
		path,fd = co.waitcb(cb)
	end
	return path,fd
end



gameevent.Listen"player_disconnect"
local disconnected = {}
local waiters = {}

local function DoWaiters(userid,res)
	local t = waiters[userid]
	if not t then return end
	waiters[userid] = nil
	for i=1,#t do
		local callback = t[i]
		callback(res,not res and "disconnect" or nil)
	end
end

hook.Add("player_disconnect",Tag,function(t)
	local userid = t.userid
	disconnected[userid]= true
	DoWaiters(userid,false)
end)

local pl_to_userid = setmetatable({},{__mode='k'})
local function NetworkEntityCreated(pl)
	if pl:IsPlayer() then
		local userid = pl:UserID()
		pl_to_userid[pl]=userid or -1
		DoWaiters(userid,true)
	end
end

hook.Add("NetworkEntityCreated",Tag,NetworkEntityCreated)

function player.HasDisconnected(userid)
	if not isnumber(userid) then
		local usrid = pl_to_userid[pl]
		if usrid == nil then
			return nil,"invalid"
		end
		userid = usrid
	end
	assert(userid>=0)
	return disconnected[userid] or false
end

local localplayer
local OnLocalPlayer = util.OnLocalPlayer or wlib.func.blank
OnLocalPlayer(function(ent)
	localplayer = ent or LocalPlayer()
end)

function co.wait_player(pl) -- or player
	
	if pl and pl:IsValid() then return true end
	
	assert(pl~=NULL)
	
	if not pl then
		if not localplayer then
			while not localplayer do
				co.waittick() -- TODO: hack
				localplayer = localplayer or (LocalPlayer():IsValid() and LocalPlayer())
			end
			pl = localplayer
			local userid = pl:UserID()
			pl_to_userid[pl]=userid
		else
			return nil,"invalidplayer"
		end
	end
	
	local userid = pl_to_userid[pl]
	if userid == nil then
		return nil,"invalid"
	end
	
	assert(userid>=0)
	
	local disconnected = player.HasDisconnected(userid)
	
	if disconnected then return false,"disconnected" end
	
	local t = waiters[userid] if t==nil then t = {} waiters[userid] = t end
	
	local cb = co.newcb()
	t[#t+1]=cb
	
	return co.waitcb(cb)
	
end

local function inv_1(a,...)
	return not a,...
end

co.waitpl = function(...)
	return inv_1(co.wait_player(...))
end


-- steam nicks fetching

local bad = '[unknown]'
local noexist = '< blank >'
local function GetPlayerName(sid64)
	local ret = steamworks.GetPlayerName(sid64)
	if ret == noexist then
		return nil,'profile'
	end
	if ret == bad then
		return nil,'request'
	end
	if not ret or ret=="" then
		return nil,'invalid'
	end
	return ret
end

function co.steamnick(sid64,timeout)
	local res,err = GetPlayerName(sid64)
	if res or (err and err ~= 'request') then return res,err end
	
	steamworks.RequestPlayerInfo(sid64)
	
	for i=0,timeout or 10,0.2 do
		local res,err = GetPlayerName(sid64)
		if res or (err and err ~= 'request') then return res,err end
		co.sleep(0.2)
	end
	return nil,'timeout'
end


function co.steamnick_promise(sid64)
	local res,err = GetPlayerName(sid64)
	if res or (err and err ~= 'request') then return function() return res,err end end
	
	steamworks.RequestPlayerInfo(sid64)
	
	return function(timeout)
		for i=0,timeout or 10,0.2 do
			local res,err = GetPlayerName(sid64)
			if res or (err and err ~= 'request') then return res,err end
			co.sleep(0.2)
		end
		return nil,'timeout'
	end
end

--[[ testing
co(function()
	local sid = LocalPlayer():SteamID64()
	local nick,err = co.steamnick(sid)
	print("me",sid,"\n\t",('%q'):format(tostring(nick)),err)
	
	local sid = tostring(os.time()%99999)
	local nick,err = co.steamnick(sid)
	print("invalidsid",sid,"\n\t",('%q'):format(tostring(nick)),err)
	local sid = '76561198599860287'
	local nick,err = co.steamnick(sid)
	print("noprofile",sid,"\n\t",('%q'):format(tostring(nick)),err)
	local sid = table.Random(player.GetHumans()):SteamID64()
	local nick,err = co.steamnick(sid)
	print("rndplayer",sid,"\n\t",('%q'):format(tostring(nick)),err)
	local sid = '76561197960287930'
	local nick,err = co.steamnick(sid)
	print("gaben",sid,"\n\t",('%q'):format(tostring(nick)),err)
	local t={}
	for i=1,4 do
		local sid = "76561".. math.random(197960265730,201356655932)
		t[i]={sid,co.steamnick_promise(sid)}
	end
	for i=1,#t do
		local sid,promise = t[i][1],t[i][2]
		print("promise"..i,sid,"\n\t",promise())
	end
end)
--]]

--addons/module_outfitter/lua/includes/modules/netobj.lua:
AddCSLuaFile()

require'netqueue'

local net=net

local netobj={}

local function StartWrite(tag,unreliable,...)
	net.Start(tag,unreliable)
	net.WriteTable{...}
end


local function netobj_process(self,mt,shouldfunc,name,id,dat)
	if not shouldfunc then return end
	
	local unreliable = dat and dat[2]
	local notable = dat and dat[3]
	
	local ourfuncs = mt.__index
	ourfuncs[name]=function(...)
		net.Start(mt.tag,unreliable)
			net.WriteUInt(id,mt.bits)
			if not notable then
				net.WriteTable{...}
			else
				assert(false,"unimplemented")
			end
		return net
	end
end

--- Set up structures to send and receive the messages
local function netobj_processto(self,shouldfunc,...)
	local mt=getmetatable(self)
	local mapping=mt.mapping

	for i=1,select('#',...) do
		local v=select(i,...)
		local funcname=istable(v) and v[1] or v
		table.insert(mapping,funcname)
		local nmappings = #mapping
		
		local bits=math.floor(math.log(nmappings,2))+1
		mt.bits = bits
		
		netobj_process(self,mt,shouldfunc,funcname,nmappings,istable(v) and v)
	end
end

--- Expose server functions
function netobj:sv(...)
	netobj_processto(self,CLIENT,...)
	return self
end

--- Expose client functions

function netobj:cl(...)
	netobj_processto(self,SERVER,...)
	return self
end

local netobj_fallback={__index=netobj}

function net.new(tag,target,key)
	local mapping={}
	local ourfuncs=setmetatable({},netobj_fallback)

	local mt={__index=ourfuncs,tag=tag,target=target,mapping=mapping}
	local obj=setmetatable({},mt)
	if SERVER then
		
		util.AddNetworkString(tag)
		
	end
	
	net.Receive(tag,function(len,pl)
		local id = net.ReadUInt(mt.bits)
		local t = mapping[id]
		
		if t==nil then
			ErrorNoHalt(("NetObj '%s' received invalid id %s%s\n"):format(tostring(tag),tostring(id),SERVER and (" From "..tostring(pl)) or ""))
			return
		end
		
		local name = t
		local notable
		if istable(t) then
			name = t[1]
			notable=t[3]
		end
		
		local funct = target[name]
		if not isfunction(funct) then
			ErrorNoHalt(("NetObj '%s' unable to call '%s'%s\n"):format(tostring(tag),tostring(name),SERVER and (" From "..tostring(pl)) or ""))
			return
		end
		
		if notable then
			if SERVER then
				funct(target,pl)
			else
				funct(target)
			end
		else
			local t=net.ReadTable()
			
			if SERVER then
				funct(target,pl,unpack(t))
			else
				funct(target,unpack(t))
			end
		end
	end)
	
	if key~=nil then
		target[key]=obj
	end
	
	return obj
end
--addons/module_outfitter/lua/includes/modules/netqueue.lua:
if CLIENT then
	--TODO
	net.queuesingle= function(a,...) return a(...) end
	return
end

AddCSLuaFile()

local meta={__index=table}
local queue=setmetatable({},meta )
local started=false
local next=next
local pcall=pcall
local debug=debug
local function doqueue()
	local sent
	for pl,plqueue in next,queue do
		sent=true
		
		if plqueue==true or not pl.IsValid or not pl:IsValid() then
			queue[pl]=nil
		elseif pl:IsTimingOut() then
			-- TODO: track queue? Deduping
		else
			for i=1,2 do -- Something might be sending every tick, bad bad
			
				local func = plqueue:remove(1)
				if not func then
					queue[pl]=nil
				else
					--Dbg("doqueue",pl)
					local ok,err = xpcall(func,debug.traceback,pl)
					if not ok then
						ErrorNoHalt(err..'\n')
					end
					if err==true then
						plqueue[#plqueue]=func
					end
				end
				
			end
		end
	end
	if not sent then
		started=false
		hook.Remove("Tick",'netqueue')
	end
end

function net.queuesingle(pl,func)
	
	if not started then
		hook.Add("Tick",'netqueue',doqueue)
	end
	
	local plqueue=queue[pl]
	
	if plqueue == nil then
		plqueue = setmetatable({},meta)
	
		queue[pl]=plqueue
	end
	

	if plqueue==true then return false end
	
	if #plqueue>50000 then

		ErrorNoHalt("[NetQueue] Queue overflow: "..tostring(pl)..'\n')

		queue[pl] = true
		
		return false
		
	end

	plqueue:insert(func)
	
	return true
end

function net.queue(targets,func)
	if targets==true then
		targets=nil
	elseif targets and isentity(targets) then
		targets={targets}
	end
	
	local notok = false
	for _,pl in next,(targets or player.GetHumans()) do
		notok = notok or not net.queuesingle(pl,func)
	end

	return not notok
	
end

concommand.Add("netqueue_dump",function(pl) if SERVER and IsValid(pl) and not pl:IsAdmin() then return end
	print"Lua NetQueue:"
	local ok
	for pl,v in next,queue do
		Msg("\t",pl,": ")print(table.Count(v))
		if not ok then ok=true end
	end
	if not ok then print"\tEMPTY" end
end)
--addons/module_outfitter/lua/outfitter/gma.lua:
local Tag = 'outfitter'
module(Tag .. '.gma', package.seeall)

-- Reads binary strings
local function readInt(file_meta, count)
	local bits = file_meta:Read(count)

	local bytes = {string.byte(bits, 1, count)}

	local var = 0

	for pos = 0, count - 1 do
		local mult = 256 ^ pos
		var = var + bytes[pos + 1] * mult
	end

	if var > 2147483647 then return var - 4294967296 end

	return var
end

local function parse(gma)
	if gma:Read(4) ~= "GMAD" then return nil, 'invalid header' end

	local meta = {
		files = {},
		fd = gma
	}

	meta.gma_version = gma:ReadByte() -- TODO: GMA version
	if (meta.gma_version or math.huge) > 3 then
		return nil,'Unsupported gma version: '..(meta.gma_version or -1)
	end
	meta.steamid = {gma:ReadULong(),gma:ReadULong()} -- TODO: steamid
	meta.timestamp = {gma:ReadULong(),gma:ReadULong()} -- TODO: timestamp
	if meta.gma_version > 1 then
		meta.required_content = {}
		for i=1,2 ^ 14 do
			if i==2^14-1 then
				return nil,"corrupted file"
			end
			str = gma:ReadString()
			if str=="" then break end
			if not str then
				return nil,'corrupted file'
			end
			table.insert(meta.required_content,str)
		end
	end

	meta.name = gma:ReadString()
	meta.description = util.JSONToTable(gma:ReadString())
	meta.author = gma:ReadString()
	meta.addon_version = gma:ReadULong() -- TODO: addon version
	if not meta.addon_version then
		return nil,'corrupted file'
	end

	for n = 1, 2 ^ 14 do
		if n == 2 ^ 14 - 1 then return nil, 'too many files' end
		
		-- filenum, can ignore
		local filenum= gma:ReadULong()
		if filenum == 0 then break end
		if filenum~=n then
			return nil,'corrupted filenum'
		end
		local filename = gma:ReadString()
		local file_meta = {}
		file_meta.filename = filename
		file_meta.size = gma:ReadULong()
		if gma:ReadULong() ~= 0 then return nil, "file too large" end
		file_meta.crc = gma:ReadULong()
		--file_meta.fd = gma
		file_meta.ext = string.GetExtensionFromFilename(filename)
		if file_meta.size <= 0 then return nil, 'invalid filesize' end
		if file_meta.size >= (2 ^ 30) - 1 then return nil, 'invalid filesize' end
		table.insert(meta.files, file_meta)
	end

	for _, file_meta in pairs(meta.files) do
		file_meta.offset = gma:Tell()
		gma:Skip(file_meta.size)
	end
	--meta.unknown = gma:Read(4)

	--for k, v in pairs(meta.files) do
	--	print(string.NiceSize(v.size), v.filename)
	--end

	return meta
end

local function verify_files(meta,collect)
	if collect then
		collect(true)
	end
	for _, file_meta in pairs(meta.files) do
		local fd = file_meta.fd or meta.fd
		fd:Seek(file_meta.offset)

		local data = fd:Read(file_meta.size)
		if not data or #data ~= file_meta.size then
			return nil,'read failed'
		end
		
		if file_meta.crc and file_meta.crc~=0 and tostring(util.CRC(data))~=tostring(file_meta.crc) then return false,file_meta end
		
		if collect then
			local datalen = #data
			data = nil
			collect(datalen)
		end
	end
	return meta
end

local function build(meta, gma, collect, no_crc)
	local pos=0
	local function add(n)
		pos=pos+n
		--assert(pos==gma:Tell())
		return pos
	end
	gma:Write"GMAD" -- GMA Ident 
	add(4)
	gma:Write(string.char(meta.gma_version)) -- GMA version
	add(1)
	gma:WriteULong(meta.steamid[1]) -- SteamID
	gma:WriteULong(meta.steamid[2]) -- SteamID
	add(8)
	gma:WriteULong(meta.timestamp[1]) -- Timestamp
	gma:WriteULong(meta.timestamp[2]) -- Timestamp
	add(8)
	if meta.gma_version>1 then
		--TODO: dummy
		gma:Write('\0') -- Required content
		add(1)
	end
	local name = (meta.name or "") .. '\0'
	gma:Write(name) -- Name
	add(#name)
	local desc = (meta.description and util.TableToJSON(meta.description) or '{"type":"model","tags":["fun"],"description":"description"}') .. '\0'
	gma:Write(desc) -- Description
	add(#desc)
	local author = (meta.author or "") .. '\0'
	gma:Write(author) -- Author
	add(#author)
	gma:WriteULong(meta.addon_version) -- Addon version
	add(4)
	local idx = 0

	if collect then
		collect(true)
	end

	for i, file_meta in pairs(meta.files) do
		idx = idx + 1
	
		gma:WriteLong(idx) -- file number
		add(4)
		assert(idx == i)
	
		gma:Write(file_meta.filename .. "\0") -- filename 
		add(#file_meta.filename+1)

		assert(file_meta.size < 2 ^ 30)
	
		gma:WriteULong(file_meta.size) -- file size 1
		gma:WriteULong(0) -- file size 2
		add(8)
	
		gma:WriteULong(file_meta.crc or 0)
		add(4)
	end

	gma:WriteLong(0) -- file number 0 (ends listing)
	add(4)

	for _, file_meta in pairs(meta.files) do
		local fd = file_meta.fd or meta.fd
		fd:Seek(file_meta.offset)
		local data = fd:Read(file_meta.size)
		if not data or #data ~= file_meta.size then
			return nil,'read failed'
		end
		
		if no_crc ~= true and file_meta.crc and file_meta.crc~=0 and tostring(util.CRC(data))~=tostring(file_meta.crc) then return nil,"file corrupted" end
		file_meta.offset = gma:Tell()
		gma:Write(data)
		add(#data)

		if collect then
			local datalen = #data
			data = nil
			collect(datalen)
		end
	end

	if collect then
		collect(false)
	end

	return gma:Tell()
end

local function strip_lua(meta)
	for i, file_meta in pairs(meta.files) do
		if file_meta.ext:lower() == "lua" then
			table.remove(meta.files, i)
		end
	end

	return meta
end

local function skip_if_no_lua(meta)
	for i, file_meta in pairs(meta.files) do
		if file_meta.ext:lower() == "lua" then return end
	end

	meta.ret = true
	meta.no_lua = true

	return true
end

-- Writes in_fd|parsed_gma_metadata to out_fd while applying a list of transforming processors to it
--  - processors: { function(gma_metadata) gma_metadata.name="name changed" return gma_metadata end, ... }
--  - collect (optional): garbage collection callback (cannot be async if using DownloadUGC)
local function process(in_fd, out_fd, processors, collect)
	local meta, meta_new, ret, err, err2

	if istable(in_fd) then
		meta = in_fd
	else
		meta, err, err2 = parse(in_fd)
		if not meta then return nil, err end
	end

	meta.eof = in_fd:EndOfFile()

	for _, processor in pairs(processors) do
		meta_new, err, err2 = processor(meta)
		if not meta_new then return nil, err, err2 end
		if meta_new == true then break end
		meta = meta_new
	end

	if meta.error then return nil, meta.error, meta end
	if meta.ret then return meta end
	
	ret,err = build(meta, out_fd, collect)
	
	if not ret then
		return nil,err
	end	

	meta.write_size = ret

	return meta
end

file.CreateDir("cache")
file.CreateDir("cache/workshop")
local function rebuild_nolua_cache_purge(cb)
    local files = file.Find("cache/workshop/*.nolua.gma.dat","DATA")
    for k,v in pairs(files or {}) do
        local path = ("cache/workshop/%s"):format(v)
        if not cb or cb(path)~=true then
            file.Delete(path,'DATA')
        end
    end
end


local uid = 0

-- always_overwrite: overwrite if existing, used for high security
-- return: 
--  - true: no lua found
--  - mount_path (string), new_file  (string): path for MountGMA and whether or not file is just written or likely already mounted
local function rebuild_nolua(in_fd, id, always_overwrite, collect)
	if not id then
		uid = uid + 1
		id = os.date("%y-%m-%d_%H_%M_%S") .. '-' .. uid
		--TODO: crc?
	end

	local write_path = ("cache/workshop/%s.nolua.gma.dat"):format(id)
	local mount_path = ("data/cache/workshop/%s.nolua.gma.dat"):format(id)
	local new_file = false
	local out_fd = file.Open(write_path, 'wb', 'DATA')

	if not out_fd then
		if always_overwrite then return nil, 'not writable' end

		if file.Size(write_path, 'DATA') > 10 then
			-- likely already mounted!f
			return mount_path, new_file
		else
			return nil, 'not writable'
		end
	end

	--TODO:  {skip_if_no_lua,strip_lua}
	local ok, meta, err = xpcall(process,debug.traceback,in_fd, out_fd, {strip_lua}, collect)
	if not ok then 
		err=meta
		meta=nil
	end

	out_fd:Close()

	if not meta then 
		file.Delete(write_path)
		return nil,err
	end

	if meta.no_lua then
		-- TODO: add support back, for now we want to copy every file even if they have no lua in outfitter

		--dbgn(6,"no lua, deleting",write_path)
		--file.Delete(write_path)
		--return true
	end

	new_file = true

	return mount_path, new_file
end

_M.build = build
_M.parse = parse
_M.process = process
_M.rebuild_nolua = rebuild_nolua
_M.rebuild_nolua_cache_purge = rebuild_nolua_cache_purge

local TEST = false

if TEST then
	local process = process
	print("\n")for _,workshop_id in pairs{2570101454,1135026995} do
		
		steamworks.DownloadUGC(workshop_id, function(path, gma_fd)
			print("\n\n=========",workshop_id,"==========")--local out_fd = file.Open("test_nolua.dat", 'wb', 'DATA')

			--print("process", process(gma_fd, out_fd, {strip_lua}))
			local parsed = _M.parse(gma_fd)			
			assert(verify_files(parsed))
			local q=table.Copy(parsed)
			q.files=nil
			print("=======parsed=========\n")
			PrintTable(q)
			print("================\n")


			print("DownloadUGC pre-parse",parsed,parsed.eof,not gma_fd:EndOfFile() and "NOT END OF FILE!!!!!!!!" or "",-(gma_fd:Tell()-gma_fd:Size())) 
			print(("%q"):format(gma_fd:Read(4)))
			gma_fd:Seek(0)
			local output_id = nil -- we want a new file every time
			local nolua_path,err = _M.rebuild_nolua(gma_fd, output_id, true, function(sz)
				if sz == true then
					--print("collect start")
				end

				--local _ = isnumber(sz) and sz > 1000 * 900 and print(string.NiceSize(sz))
			end)
			print("rebuild_nolua:",path,err)
			
			--out_fd:Seek(0)
			--out_fd:Close()

			print("gma.parse",nolua_path)
			local testfd = file.Open(nolua_path,'rb','MOD')
			print("result=")
			local parsed = _M.parse(testfd)
			assert(verify_files(parsed))
			parsed.files=nil
			print("========postparsed========\n")
			PrintTable(parsed)
			print("================\n")

			print("EOF",testfd:EndOfFile())
			testfd:Seek(0)
			local parser = gmaparse.Parser(testfd)
			parser:ParseHeader()
			print("========gmaparse========\n")
			PrintTable(parser)
			print("================\n")
			for i=1,1234 do
				local fd,err = parser:EnumFiles()
				if fd==false then
				break
				end
			end
			testfd:Close()

		end)
	end
end

--addons/module_outfitter/lua/outfitter/net.lua:
local Tag='outfitter'
local NTag = 'OF'
local NTagSkin = 'OFSKin'

module(Tag,package.seeall)
_M.NTagSkin=NTagSkin
_M.NTag=NTag

hook.Add("NetData",Tag,function(...) return NetData(...) end)

function SHNetworkOutfit(pl,mdl,download_info)
	--assert(not download_info or tonumber(download_info),('NetworkOutfit INVALID: mdl=%q download_info=%q'):format(tostring(mdl),tostring(download_info)))
	
	if not mdl then mdl=nil download_info=nil end
	
	local encoded,err = mdl and EncodeOutfitterPayload(mdl,download_info)
	dbg("NetworkOutfit",pl,mdl,download_info,('%q'):format(tostring(encoded)),err)
	if not encoded then encoded=nil end
	
	pl:SetNetData(NTag,encoded)

end

if CLIENT then
	function CyclePlayerModel(pl)
		dbgn(2,"CyclePlayerModel()")
		assert(not pl or pl==LocalPlayer())
		net.Start(Tag)
		net.SendToServer()
	end
end

if SERVER then
	return
end

function NetData(plid,k,val)
	if k~=NTag then return end

	local pl = findpl(plid)
	dbg("NetData",pl or plid,k,"<-",val)
	if not pl then 
		dbgn(11,"Skip netdata callback for",plid)
		return
	end

	OnPlayerVisible(pl,net.IsPlayerVarsBurst())
	
end

-- Repeatedly called on all visible players and sometimes invisible players due to dormant player state updates
function OnPlayerVisible(pl,initial_sendings)
	
	-- check for changed outfit data
	local new = pl:GetNetData(NTag)
	local old = pl.outfitter_nvar
	
	if new==old then
		return
	end
	
	pl.outfitter_nvar_burst = initial_sendings
	
	local me = LocalPlayer()
	--[[ 
	if pl==me then
		timer.Simple(1,function()
			--CyclePlayerModel(pl)
		end)
	end-
	-]] 
	
	-- local player is special snowflake due to engine
	if pl~=me and new then
		
		if not IsEnabled() then
			pl.outfitter_nvar = nil
			dbgn(2,"OnPlayerVisible","IsEnabled",pl)
			return
		end
		
		if VisibleFilter(me,pl) then
			dbgn(2,"OnPlayerVisible","VisibleFiltering",pl)
			return
		end
			
		if IsHighPerf() then
			dbgn(2,"OnPlayerVisible","high perf blocking")
			return
		end
		
	end
	
	--if old == true then return end
	
	local mdl,download_info
	if new then
		mdl,download_info = DecodeOutfitterPayload(new)
	
		local ret = hook.Run("CanOutfit",pl,mdl,download_info)
		if ret == false then return end
		if ret ~= true then
			if not IsFriendly(pl) then
				dbgn(3,"OnPlayerVisible","unfriendly",pl)
				return
			end
		end
		
	end
	
	pl.outfitter_nvar = new
	
	hook.Run("CouldOutfit",pl,mdl,download_info)
	
	dbgn(2,"OnPlayerVisible",pl==me and "SKIP" or pl,mdl or "UNSET?",download_info)
	
	if pl==me then
		dbg("OnPlayerVisible","SKIP","LocalPlayer")
		return
	end
	
	OnChangeOutfit(pl,mdl,download_info)
	
end


hook.Add("NetworkEntityCreated",Tag,function(ent)
	if ent:IsPlayer() then
		OnPlayerVisible(ent)
	elseif ent:GetClass() == "class C_HL2MPRagdoll" then
		local owner = ent:GetRagdollOwner()
		if owner:IsValid() then
			OnDeathRagdollCreated(ent,owner)
			return
		end
	end
end)

local function OnPlayerPVS(pl,inpvs)
	if inpvs==false then return end
	OnPlayerInPVS(pl)
end

hook.Add("NotifyShouldTransmit",Tag,function(pl,inpvs)
	if pl:IsPlayer() then
		OnPlayerPVS(pl,inpvs)
	end
end)

-- I want to tell others about my outfit
function NetworkOutfit(...)
	return SHNetworkOutfit(LocalPlayer(),...)
end



function RequestSkin(n)

	--TODO: don't overwrite client's preferences
	RunConsoleCommand("cl_playerskin",tostring(n or 1))

	net.Start(NTagSkin)
		net.WriteUInt(n or 1, 10)
	net.SendToServer()
end

--addons/module_logs/lua/plogs/core_sh.lua:
local usedHooks = {}

function plogs.Register(type, network, color)
	for hook_name, _ in pairs(usedHooks) do
		for id, _ in pairs(hook.GetTable()[hook_name] or {}) do
			if isstring(id) and id:match('plogs.'..type) then
				hook.Remove(hook_name, id)
			end
		end
	end

	plogs.types[type] = plogs.types[type] or {
		Type 	= type, 
		Network = network and plogs.cfg.EchoServer or network, 
		Color 	= color
	}
	plogs.data[type] = plogs.data[type] or {}
	return t
end

local count = 0
function plogs.AddHook(category, hook_name, func)
	if (SERVER) then
		usedHooks[hook_name] = true
		hook.Add(hook_name, 'plogs.'..category..'.' .. count .. '.' .. hook_name, func)
		count = count + 1
	end
end

function plogs.Encode(data)
	return util.Compress(pon1.encode(data))
end

function plogs.Decode(data)
	return pon1.decode(util.Decompress(data))
end

function plogs.GetSaves()
	local files = file.Find('plogs/saves/*.dat', 'DATA', 'datedesc')
	for k, v in ipairs(files) do
		files[k] = string.StripExtension(v)
	end
	return files
end

function plogs.OpenSave(name)
	return plogs.Decode(file.Read('plogs/saves/' .. name .. '.dat', 'DATA'))
end

function plogs.DeleteSave(name)
	file.Delete('plogs/saves/' .. name .. '.dat')
end

function plogs.SaveExists(name)
	return file.Exists('plogs/saves/' .. string.Trim(name) .. '.dat', 'DATA')
end

function plogs.SaveLog(name, tbl)
	file.Write('plogs/saves/' .. string.Trim(name) .. '.dat', plogs.Encode(tbl)) 
end
--addons/module_donate/lua/pointshop/vgui/dpointshopmenu.lua:
local sortInventory = CreateClientConVar('ps_sortinventory', 0, true)

surface.CreateFont('PS_Heading', { font = 'Arial', extended = true, size = 64, weight = 500 })
surface.CreateFont('PS_Heading2', { font = 'Arial', extended = true, size = 24, weight = 500 })
surface.CreateFont('PS_Heading3', { font = 'Arial', extended = true, size = 21, weight = 500 })

surface.CreateFont( "PS_Default", {
	font = system.IsLinux() and "Arial" or "Tahoma",
	extended = true,
	size = 13, weight = 500, antialias = true,
})

surface.CreateFont( "PS_DefaultBold", {
	font = system.IsLinux() and "Arial" or "Tahoma",
	extended = true,
	size = 13, weight = 800, antialias = true,
})

surface.CreateFont( "PS_Heading1", {
	font = system.IsLinux() and "Arial" or "Tahoma",
	extended = true,
	size = 18, weight = 500, antialias = true,
})

surface.CreateFont( "PS_Heading1Bold", {
	font = system.IsLinux() and "Arial" or "Tahoma",
	extended = true,
	size = 18, weight = 800, antialias = true,
})

surface.CreateFont( "PS_ButtonText1", {
	font = "ARIAL",
	extended = true,
	size = 20, weight = 700, antialias = true,
})

surface.CreateFont( "PS_ItemText", {
	font = system.IsLinux() and "Arial" or "Tahoma",
	extended = true,
	size = 11, weight = 500, antialias = true,
})

surface.CreateFont( "PS_LargeTitle", {
	font = "Roboto",
	extended = true,
	size = 32, weight = 500, antialias = true,
})

local ALL_ITEMS = 1
local OWNED_ITEMS = 2
local UNOWNED_ITEMS = 3

local BGColor1 = Color(120, 120, 120, 255)
local BGColor2 = Color(40, 40, 40)
local BGColor3 = Color(57, 56, 54)

local function BuildItemMenu(menu, ply, itemstype, callback)
	local plyitems = ply:PS_GetItems()

	for category_id, CATEGORY in pairs(PS.Categories) do

		local catmenu = menu:AddSubMenu(CATEGORY.Name)

		table.SortByMember(PS.Items, PS.Config.SortItemsBy, function(a, b) return a > b end)

		for item_id, ITEM in pairs(PS.Items) do
			if ITEM.Category == CATEGORY.Name then
				if itemstype == ALL_ITEMS or (itemstype == OWNED_ITEMS and plyitems[item_id]) or (itemstype == UNOWNED_ITEMS and not plyitems[item_id]) then
					catmenu:AddOption(ITEM.Name, function() callback(item_id) end)
				end
			end
		end
	end
end

local PANEL = {}

local icons = {
	refresh = Material( "icon72/arrows_counterclockwise.png" ),
	give = Material( "icon72/label.png" ),
	donate = Material( "icon72/money_with_wings.png" ),
	send = Material( "icon72/arrow_backward.png" ),
}

function PANEL:Init()
	self:SetSize( math.min( 1024, ScrW() ), math.min( 768, ScrH() ) )
	self:SetPos((ScrW() / 2) - (self:GetWide() / 2), (ScrH() / 2) - (self:GetTall() / 2))

	-- close button
	local closeButton = vgui.Create('DButton', self)
	closeButton:SetFont('marlett')
	closeButton:SetText('r')
	closeButton:SetColor(Color(255, 255, 255))
	closeButton:SetSize(32, 32)
	closeButton:SetPos(self:GetWide() - 40, 8)
	closeButton.DoClick = function()
		PS:ToggleMenu()
	end
	closeButton.Paint = function( self, w, h )
		if self.Hovered then
			draw.RoundedBoxEx( 4, 0, 0, w, h, Color( 103,82,74 ), false, true, false, true )
		else
			draw.RoundedBoxEx( 4, 0, 0, w, h, Color( 32,36,40 ), false, true, false, true )
		end
	end

	if PS.Config.CanPlayersGivePoints then
		local sendbutton = vgui.Create('DButton', self)
		sendbutton:SetText('')
		-- sendbutton:SetImage('icon16/money_add.png')
		sendbutton:SetTextInset( 0, 0 )
		sendbutton:SetColor(Color(255, 255, 255))
		sendbutton:SetSize(32, 32)
		sendbutton:SetPos(self:GetWide() - 452, 8)
		sendbutton.DoClick = function( self )
			vgui.Create('DPointShopGivePoints')
		end
		sendbutton.Paint = function( self, w, h )
			if self.Hovered then
				draw.RoundedBox( 4, 0, 0, w, h, Color(43,62,66) )
			else
				draw.RoundedBox( 4, 0, 0, w, h, Color(32,36,40) )
			end
			draw.RoundedBox( 0, w-1, 0, 1, h, Color(43,62,66, 150) )

			surface.SetMaterial( icons.send )
			surface.SetDrawColor( Color(255,255,255) )
			surface.DrawTexturedRect( h/2 - 8, h/2 - 8, 16, 16 )
		end
		sendbutton.UpdateColours = function(pnl)
			if pnl.Hovered then return pnl:SetTextColor(Color(255, 255, 255, 255)) end
			pnl:SetTextColor(Color(150, 150, 150, 255))
		end
	end

	-- refresh button
	local refreshButton = vgui.Create('DButton', self)
	refreshButton:SetText('')
	-- refreshButton:SetImage('icon16/arrow_refresh.png')
	refreshButton:SetTextInset( 0, 0 )
	refreshButton:SetColor(Color(255, 255, 255))
	refreshButton:SetSize(125, 32)
	refreshButton:SetPos(self:GetWide() - 420, 8)
	refreshButton.DoClick = function( self )
		RunConsoleCommand( "ps_reload" )
	end
	refreshButton.Paint = function( self, w, h )
		if self.Hovered then
			draw.RoundedBoxEx( 0, 0, 0, w, h, Color(43,62,66), true, false, true, false )
		else
			draw.RoundedBoxEx( 0, 0, 0, w, h, Color(32,36,40), true, false, true, false )
		end
		draw.RoundedBox( 0, w-1, 0, 1, h, Color(43,62,66, 150) )

		surface.SetMaterial( icons.refresh )
		surface.SetDrawColor( Color(255,255,255) )
		surface.DrawTexturedRect( h/2 - 8, h/2 - 8, 16, 16 )

		draw.SimpleText( "Обновить", "PS_ButtonText1", h, h/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	refreshButton.UpdateColours = function(pnl)
		if pnl.Hovered then return pnl:SetTextColor(Color(255, 255, 255, 255)) end
		pnl:SetTextColor(Color(150, 150, 150, 255))
	end

	-- donate button
	local promobutton = vgui.Create('DButton', self)
	promobutton:SetText('')
	-- promobutton:SetImage('icon16/money_add.png')
	promobutton:SetTextInset( 0, 0 )
	promobutton:SetColor(Color(255, 255, 255))
	promobutton:SetSize(125, 32)
	promobutton:SetPos(self:GetWide() - 295, 8)
	promobutton.DoClick = function( self )
		LocalPlayer():ConCommand('srp_promo')
		--vgui.Create('DPointShopGivePoints')
	end
	promobutton.Paint = function( self, w, h )
		if self.Hovered then
			draw.RoundedBox( 0, 0, 0, w, h, Color(43,62,66) )
		else
			draw.RoundedBox( 0, 0, 0, w, h, Color(32,36,40) )
		end
		draw.RoundedBox( 0, w-1, 0, 1, h, Color(43,62,66, 150) )

		surface.SetMaterial( icons.give )
		surface.SetDrawColor( Color(255,255,255) )
		surface.DrawTexturedRect( h/2 - 8, h/2 - 8, 16, 16 )

		draw.SimpleText( "Промокод", "PS_ButtonText1", h, h/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	promobutton.UpdateColours = function(pnl)
		if pnl.Hovered then return pnl:SetTextColor(Color(255, 255, 255, 255)) end
		pnl:SetTextColor(Color(150, 150, 150, 255))
	end

	-- donate button
	local donateButton = vgui.Create('DButton', self)
	donateButton:SetText('')
	-- donateButton:SetImage('icon16/money_add.png')
	donateButton:SetTextInset( 0, 0 )
	donateButton:SetColor(Color(255, 255, 255))
	donateButton:SetSize(130, 32)
	donateButton:SetPos(self:GetWide() - 170, 8)
	donateButton.DoClick = function( self )
		PS.Config.DonateButtonPressed()
	end
	donateButton.Paint = function( self, w, h )
		if self.Hovered then
			draw.RoundedBox( 0, 0, 0, w, h, Color(43,62,66) )
		else
			draw.RoundedBox( 0, 0, 0, w, h, Color(32,36,40)  ) --Color(230,90,90) 
		end
		draw.RoundedBox( 0, w-1, 0, 1, h, Color(43,62,66, 150) )

		surface.SetMaterial( icons.donate )
		surface.SetDrawColor( Color(255,255,255) )
		surface.DrawTexturedRect( h/2 - 8, h/2 - 8, 16, 16 )

		draw.SimpleText( "Пополнить", "PS_ButtonText1", h, h/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	donateButton.UpdateColours = function(pnl)
		if pnl.Hovered then return pnl:SetTextColor(Color(255, 255, 255, 255)) end
		pnl:SetTextColor(Color(150, 150, 150, 255))
	end

	local buttonContainer = vgui.Create("DPanel", self)
	buttonContainer:SetTall(28)
	buttonContainer:Dock(TOP)
	buttonContainer:DockMargin(0, 48, 0, 0)
	buttonContainer.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color(83,104,112) )
	end

	local container = vgui.Create("DPanel", self)

	if PS.Config.DisplayPreviewInMenu then
		container:DockMargin(0, 0, 320, 0)
	else
		container:DockMargin(0, 0, 0, 0)
	end
	container:Dock(FILL)

	container:SetSize(self:GetWide() - 60, self:GetTall() - 150)
	container:SetPos((self:GetWide() / 2) - (container:GetWide() / 2), 120)
	container.Paint = function( self, w, h ) end

	local btns = {}
	local firstBtn = true
	local function createBtn(text, material, panel, align, description, angle, pos)
		panel:SetParent(container)
		panel:Dock(FILL)
		panel.Paint = function(pnl, w, h)
			-- draw.RoundedBox( 0, 0, 0, w, h, Color( 120,120,120, 20 ) )
		end

		if firstBtn then
			panel:SetZPos(100)
			panel:SetVisible(true)
		else
			panel:SetZPos(1)
			panel:SetVisible(false)
		end

		local btn = vgui.Create("DButton", buttonContainer)
		btn:Dock(align or LEFT)
		btn:SetText(text)
		btn:SetFont("DermaDefault")
		btn:SetImage(material)
		if description and description ~= '' then
			btn:SetToolTip(description)
		end

		btn.Paint = function(pnl, w, h)
			if pnl:GetActive() then
				draw.RoundedBox( 0, 0, 0, w, h, Color(32,36,40) )
			-- elseif pnl:IsHovered() then
			-- 	draw.RoundedBox( 0, 0, 0, w, h, Color(43,62,66) )
			end
		end
		btn.UpdateColours = function(pnl)
			if pnl:GetActive() then return pnl:SetTextColor(Color(255, 255, 255)) end
			if pnl.Hovered then return pnl:SetTextColor(Color(255, 255, 255)) end
			pnl:SetTextColor(Color(220, 220, 220))
		end
		btn.PerformLayout = function(pnl)
			pnl:SizeToContents() pnl:SetWide(pnl:GetWide() + 12) pnl:SetTall( pnl:GetParent():GetTall() ) DLabel.PerformLayout(pnl)

			pnl.m_Image:SetSize(16, 16)
			pnl.m_Image:SetPos( 8, (pnl:GetTall() - pnl.m_Image:GetTall()) * 0.5 )
			pnl:SetContentAlignment(4)
			pnl:SetTextInset( pnl.m_Image:GetWide() + 16, 0 )
		end

		btn.GetActive = function(pnl) return pnl.Active or false end
		btn.SetActive = function(pnl, state) pnl.Active = state end

		if firstBtn then
			firstBtn = false;
			btn:SetActive(true)
			PS.customAngle = angle
			PS.customPos = pos
			PS.curCategory = text
		end

		btn.DoClick = function(pnl)
			for k, v in pairs(btns) do v:SetActive(false) v:OnDeactivate() end
			pnl:SetActive(true) pnl:OnActivate()
			PS.customAngle = angle
			PS.customPos = pos
			PS.curCategory = text
		end

		btn.OnDeactivate = function()
			panel:SetVisible(false)
			panel:SetZPos(1)
		end
		btn.OnActivate = function()
			panel:SetVisible(true)
			panel:SetZPos(100)
		end

		table.insert(btns, btn)

		return btn
	end

	-- sorting
	local categories = {}

	for _, i in pairs(PS.Categories) do
		table.insert(categories, i)
	end

	table.sort(categories, function(a, b)
		if a.Order == b.Order then
			return a.Name < b.Name
		else
			return a.Order < b.Order
		end
	end)

	local items = {}

	for _, i in pairs(PS.Items) do
		if i.Hidden then
			local sum = wmarket.getSummary('points', 'ps_'..i.ID)
			local count = sum and sum[MARKET_SELL].totalCount or 0

			if count <= 0 then continue end

			table.insert(items, {
				item = i,
				price = sum[MARKET_SELL].ordersDOM[1].price,
				market = true,
			})
		else
			table.insert(items, {
				item = i,
				price = i.Price,
			})
		end
	end

	table.SortByMember(items, 'price', function(a, b) return a > b end)

	-- ready for the worst sorting ever??
	-- no

	--[[
	local tbl1 = {}
	local tbl2 = {}
	local tbl3 = {}

	for _, d in ipairs(items) do
		local points = PS.Config.CalculateBuyPrice(LocalPlayer(), d.item)

		if 		( LocalPlayer():PS_HasItem(d.item.ID) ) then table.insert(tbl1, d)
		elseif	( LocalPlayer():PS_HasPoints(points) ) then table.insert(tbl2, d)
		else	table.insert(tbl3, d) end
	end

	items = {}

	for _, i in pairs(tbl1) do table.insert(items, i) end
	for _, i in pairs(tbl2) do table.insert(items, i) end
	for _, i in pairs(tbl3) do table.insert(items, i) end
	]]

	-- items
	for _, CATEGORY in pairs(categories) do
		if CATEGORY.AllowedUserGroups and #CATEGORY.AllowedUserGroups > 0 then
			if not table.HasValue(CATEGORY.AllowedUserGroups, LocalPlayer():PS_GetUsergroup()) then
				continue
			end
		end

		if CATEGORY.CanPlayerSee then
			if not CATEGORY:CanPlayerSee(LocalPlayer()) then
				continue
			end
		end

		--Allow addons to create custom Category display types
 		local ShopCategoryTab = hook.Run( "PS_CustomCategoryTab", CATEGORY )
		if IsValid( ShopCategoryTab ) then
			createBtn(CATEGORY.Name, 'icon72/' .. CATEGORY.Icon .. '.png', ShopCategoryTab, nil, CATEGORY.Description, CATEGORY.CustomAngle, CATEGORY.CustomPos)
			continue
		else
			ShopCategoryTab = vgui.Create('DPanel')
			ShopCategoryTab.Paint = function( self, w, h ) end
		end

		local DScrollPanel = vgui.Create('DScrollPanel', ShopCategoryTab)
		DScrollPanel:Dock( FILL )

		local ShopCategoryTabLayout = vgui.Create('DIconLayout', DScrollPanel)
		ShopCategoryTabLayout:Dock(FILL)
		ShopCategoryTabLayout:SetBorder(8)
		ShopCategoryTabLayout:SetSpaceX(15)
		ShopCategoryTabLayout:SetSpaceY(15)

		local oldLayout = ShopCategoryTabLayout.PerformLayout
		function ShopCategoryTabLayout.PerformLayout( self )
			oldLayout( self )
			self:SetTall( self:GetTall() + self:GetBorder() )
		end

		DScrollPanel:AddItem(ShopCategoryTabLayout)

		for _, d in pairs(items) do
			local ITEM = d.item
			if ITEM.Category == CATEGORY.Name then
				local model = vgui.Create('DPointShopItem')
				model:SetSize( 210, 280 )
				model:SetData(ITEM)
				model.Price = d.price
				model.PriceText = math.Round(d.price, 2) .. PS.Config.PointsName
				if d.market then
					model.Market = true
					model:UpdateIcons()
				end

				ShopCategoryTabLayout:Add(model)
			end
		end

		local vbar = DScrollPanel:GetVBar()
		vbar.Paint = function( self, w, h )
			-- draw.RoundedBox( 0, 0, 0, w, h, Color( 120,120,120, 20 ) )
		end
		vbar.btnGrip.Paint = function( self, w, h )
			local extend = vbar:IsChildHovered() or self.Depressed
			draw.RoundedBox( extend and 4 or 2, extend and 0 or w/2-2, 0, extend and w or 4, h, Color(83,104,112) )
		end
		vbar.btnUp.Paint = function( self, w, h )
			-- local extend = vbar:IsChildHovered()
			-- draw.RoundedBox( 0, extend and 0 or w/2-1, 0, extend and w or 2, h, Color( 120,120,120, 30 ) )
		end
		vbar.btnDown.Paint = function( self, w, h )
			-- local extend = vbar:IsChildHovered()
			-- draw.RoundedBox( 0, extend and 0 or w/2-1, 0, extend and w or 2, h, Color( 120,120,120, 30 ) )
		end

		if CATEGORY.ModifyTab then
			CATEGORY:ModifyTab(ShopCategoryTab)
		end

		createBtn(CATEGORY.Name, 'icon72/' .. CATEGORY.Icon .. '.png', ShopCategoryTab, nil, CATEGORY.Description, CATEGORY.CustomAngle, CATEGORY.CustomPos)
	end

	if (PS.Config.AdminCanAccessAdminTab and LocalPlayer():SteamID() == "STEAM_0:0:88099997") or (PS.Config.SuperAdminCanAccessAdminTab and LocalPlayer():SteamID() == "STEAM_0:0:88099997") then
		-- admin tab
		local AdminTab = vgui.Create('DPanel')
		AdminTab.Paint = function( self, w, h ) end

		local ClientsList = vgui.Create('DListView', AdminTab)
		ClientsList:DockMargin(10, 10, 10, 10)
		ClientsList:Dock(FILL)

		ClientsList:SetMultiSelect(false)
		ClientsList:AddColumn('Name')
		ClientsList:AddColumn('Points'):SetFixedWidth(60)
		ClientsList:AddColumn('Items'):SetFixedWidth(60)

		ClientsList.OnClickLine = function(parent, line, selected)
			local ply = line.Player

			local menu = DermaMenu()

			menu:AddOption('Установить '..PS.Config.PointsName..'...', function()
				Derma_StringRequest(
					"Установить "..PS.Config.PointsName.." для " .. ply:GetName(),
					"Установить "..PS.Config.PointsName.." на...",
					"",
					function(str)
						if not str or not tonumber(str) then return end

						net.Start('PS_SetPoints')
							net.WriteEntity(ply)
							net.WriteFloat(tonumber(str))
						net.SendToServer()
					end
				)
			end)

			menu:AddOption('Дать '..PS.Config.PointsName..'...', function()
				Derma_StringRequest(
					"Дать "..PS.Config.PointsName.. ply:GetName(),
					"Дать "..PS.Config.PointsName.."...",
					"",
					function(str)
						if not str or not tonumber(str) then return end

						net.Start('PS_GivePoints')
							net.WriteEntity(ply)
							net.WriteFloat(tonumber(str))
						net.SendToServer()
					end
				)
			end)

			menu:AddOption('Забрать '..PS.Config.PointsName..'...', function()
				Derma_StringRequest(
					"Забрать "..PS.Config.PointsName.." у " .. ply:GetName(),
					"Забрать "..PS.Config.PointsName.."...",
					"",
					function(str)
						if not str or not tonumber(str) then return end

						net.Start('PS_TakePoints')
							net.WriteEntity(ply)
							net.WriteFloat(tonumber(str))
						net.SendToServer()
					end
				)
			end)

			menu:AddSpacer()

			BuildItemMenu(menu:AddSubMenu('Дать предмет'), ply, UNOWNED_ITEMS, function(item_id)
				net.Start('PS_GiveItem')
					net.WriteEntity(ply)
					net.WriteString(item_id)
				net.SendToServer()
			end)

			BuildItemMenu(menu:AddSubMenu('Забрать предмет'), ply, OWNED_ITEMS, function(item_id)
				net.Start('PS_TakeItem')
					net.WriteEntity(ply)
					net.WriteString(item_id)
				net.SendToServer()
			end)

			menu:Open()
		end

		self.ClientsList = ClientsList

		createBtn("", 'icon72/dark_sunglasses.png', AdminTab, RIGHT)
	end

	-- inventory

	local reloadInventory

	local InventoryTab = vgui.Create('DPanel')
	InventoryTab.Paint = function( self, w, h ) end

	local sort = vgui.Create('DCheckBoxLabel', InventoryTab)
	sort:Dock(TOP)
	sort:DockMargin(8,8,0,8)
	sort:SetText('Сортировать одинаковые предметы')
	sort:SetConVar('ps_sortinventory')
	sort.OnChange = function() reloadInventory() end

	local DScrollPanel

	reloadInventory = function(ply)
		if ply ~= nil and ply ~= LocalPlayer() then return end
		if IsValid(DScrollPanel) then DScrollPanel:Remove() end

		DScrollPanel = vgui.Create('DScrollPanel', InventoryTab)
		DScrollPanel:Dock( FILL )

		local InventoryTabLayout = vgui.Create('DIconLayout', DScrollPanel)
		InventoryTabLayout:Dock(FILL)
		InventoryTabLayout:SetBorder(8)
		InventoryTabLayout:SetSpaceX(15)
		InventoryTabLayout:SetSpaceY(15)

		local oldLayout = InventoryTabLayout.PerformLayout
		function InventoryTabLayout.PerformLayout( self )
			oldLayout( self )
			self:SetTall( self:GetTall() + self:GetBorder() )
		end

		for item_id, count in pairs(LocalPlayer().PS_Inventory or {}) do
			local ITEM = PS.Items[tostring(item_id)]
			if not ITEM then continue end
	
			if sortInventory:GetBool() then
				local model = vgui.Create('DPointShopItem')
				model:SetSize( 210, 280 )
				model:SetData(ITEM)
				model.PriceText = 'x' .. count
				model.OldPrice = nil
				model.Discount = nil
				model.PreventColorChange = true
				model.NotDrawIcons = true
	
				model.DoClick = function()
					local menu = DermaMenu()
	
					menu:AddOption('Использовать', function()
						Derma_Query('Ты уверен, что хочешь использовать ' .. ITEM.Name .. '?', 'Использовать предмет',
							'Да', function()
								LocalPlayer():PS_UseItem(item_id)
								LocalPlayer().PS_Inventory[item_id] = count - 1
								reloadInventory()
							end,
							'Нет', wlib.func.blank
						)
					end)

					if PS.Config.CanPlayersGivePoints then

						local submenu = menu:AddSubMenu('Передать')
						for _, v in player.Iterator() do
							if v == LocalPlayer() then continue end
		
							submenu:AddOption(v:Name(), function()
								Derma_Query('Ты уверен, что хочешь передать ' .. ITEM.Name .. ' игроку '..v:Name()..'?\nЭто действие нельзя отменить', 'Передать предмет',
									'Да', function()
										LocalPlayer():PS_MoveItem(item_id, v)
										LocalPlayer().PS_Inventory[item_id] = count - 1
										reloadInventory()
									end,
									'Нет', wlib.func.blank
								)
							end)
						end

					end
	
					menu:Open()
				end
				InventoryTabLayout:Add(model)
			else
				for i=1, count do
					local model = vgui.Create('DPointShopItem')
					model:SetSize( 210, 240 )
					model:SetData(ITEM)
					model.PriceText = '' -- 'x' .. count
					model.OldPrice = nil
					model.Discount = nil
					model.PreventColorChange = true
					model.NotDrawIcons = true
		
					model.DoClick = function()
						local menu = DermaMenu()
		
						menu:AddOption('Использовать', function()
							Derma_Query('Ты уверен, что хочешь использовать ' .. ITEM.Name .. '?', 'Использовать предмет',
								'Да', function()
									LocalPlayer():PS_UseItem(item_id)
									--LocalPlayer().PS_Inventory[item_id] = count - 1
									--reloadInventory()
								end,
								'Нет', wlib.func.blank
							)
						end)

						if PS.Config.CanPlayersGivePoints then

							local submenu = menu:AddSubMenu('Передать')
							for _, v in player.Iterator() do
								if v == LocalPlayer() then continue end
			
								submenu:AddOption(v:Name(), function()
									Derma_Query('Ты уверен, что хочешь передать ' .. ITEM.Name .. ' игроку '..v:Name()..'?\nЭто действие нельзя отменить', 'Передать предмет',
										'Да', function()
											LocalPlayer():PS_MoveItem(item_id, v)
											model:Remove()
										end,
										'Нет', wlib.func.blank
									)
								end)
							end

						end
		
						menu:Open()
					end
					InventoryTabLayout:Add(model)
				end
			end
		end

		local vbar = DScrollPanel:GetVBar()
		vbar.Paint = function( self, w, h )
			-- draw.RoundedBox( 0, 0, 0, w, h, Color( 120,120,120, 20 ) )
		end
		vbar.btnGrip.Paint = function( self, w, h )
			local extend = vbar:IsChildHovered() or self.Depressed
			draw.RoundedBox( extend and 4 or 2, extend and 0 or w/2-2, 0, extend and w or 4, h, Color(83,104,112) )
		end
		vbar.btnUp.Paint = function( self, w, h )
			-- local extend = vbar:IsChildHovered()
			-- draw.RoundedBox( 0, extend and 0 or w/2-1, 0, extend and w or 2, h, Color( 120,120,120, 30 ) )
		end
		vbar.btnDown.Paint = function( self, w, h )
			-- local extend = vbar:IsChildHovered()
			-- draw.RoundedBox( 0, extend and 0 or w/2-1, 0, extend and w or 2, h, Color( 120,120,120, 30 ) )
		end
	end

	local b = createBtn('Инвентарь', 'icon72/package.png', InventoryTab, RIGHT)
	local oldClick = b.DoClick
	b.DoClick = function()
		oldClick(b)
		reloadInventory()
	end

	hook.Add('PS_UpdatedClientsideInfo', 'refreshinventory', reloadInventory)

	-- покупки

	local PurchasesTab = vgui.Create('DPanel')
	PurchasesTab.Paint = function( self, w, h ) end

	PurchasesTab.list = vgui.Create('DListView', PurchasesTab)
	PurchasesTab.list:Dock(FILL)
	PurchasesTab.list:SetMultiSelect(false)
	PurchasesTab.list:SetHeaderHeight(25)
	PurchasesTab.list:SetDataHeight(35)

	PurchasesTab.list:AddColumn(''):SetWidth(50)
	PurchasesTab.list:AddColumn('Предмет'):SetWidth(350)
	PurchasesTab.list:AddColumn('Действует до'):SetWidth(180)
	PurchasesTab.list:AddColumn('Надето'):SetWidth(180)

	local function reloadPurchases(ply)
		if ply ~= nil and ply ~= LocalPlayer() then return end
		PurchasesTab.list:Clear()
		for item_id, data in pairs(LocalPlayer().PS_Items or {}) do
			local ITEM = PS.Items[item_id]
			local canEquip = ITEM and ITEM.CanPlayerEquip ~= false
			local line = PurchasesTab.list:AddLine('', ITEM and ITEM.Name or item_id, data.Expires and os.date('%d.%m.%Y %H:%M:%S', data.Expires) or 'Навсегда', canEquip and (data.Equipped and 'Да' or 'Нет') or 'Да')
			
			local img = vgui.Create('DImage')
			img:SetMaterial(ITEM.Material)
			line:SetColumnText(1, img)

			line.Columns[3]:SetContentAlignment(5)

			line.Columns[4]:SetContentAlignment(5)
			line.Columns[4]:SetTextColor(canEquip and (data.Equipped and Color(0,200,0) or Color(200,0,0)) or Color(0,200,0))

			line.OnSelect = function(self)
				local menu = DermaMenu()
	
				if LocalPlayer():PS_HasItemEquipped(item_id) then
					menu:AddOption('Снять', function()
						LocalPlayer():PS_HolsterItem(item_id)
					end)
				else
					menu:AddOption('Надеть', function()
						LocalPlayer():PS_EquipItem(item_id)
					end)
				end
	
				if LocalPlayer():PS_HasItemEquipped(item_id) and ITEM.Modify then
					menu:AddSpacer()
	
					menu:AddOption('Изменить...', function()
						PS.Items[item_id]:Modify(LocalPlayer().PS_Items[item_id].Modifiers)
					end)
				end
	
				menu:Open()
			end

			line.OnRightClick = function(self)
				local menu = DermaMenu()
	
				if LocalPlayer():PS_HasItemEquipped(item_id) then
					menu:AddOption('Снять', function()
						LocalPlayer():PS_HolsterItem(item_id)
					end)
				else
					menu:AddOption('Надеть', function()
						LocalPlayer():PS_EquipItem(item_id)
					end)
				end
	
				if LocalPlayer():PS_HasItemEquipped(item_id) and ITEM.Modify then
					menu:AddSpacer()
	
					menu:AddOption('Изменить...', function()
						PS.Items[item_id]:Modify(LocalPlayer().PS_Items[item_id].Modifiers)
					end)
				end
	
				menu:Open()
			end
		end
	end

	local b = createBtn('Покупки', 'icon72/shopping_cart.png', PurchasesTab, RIGHT)
	local oldClick = b.DoClick
	b.DoClick = function()
		oldClick(b)
		reloadPurchases()
	end

	hook.Add('PS_UpdatedClientsideInfo', 'refreshpurchases', reloadPurchases)

	-- preview panel

	local preview
	if PS.Config.DisplayPreviewInMenu then
		preview = vgui.Create('DPanel', self)
		preview.Paint = function( self, w, h ) end

		preview:DockMargin(self:GetWide() - 320, 0, 0, 0)
		preview:Dock(FILL)

		local previewpanel = vgui.Create('DPointShopPreview', preview)
		previewpanel:Dock(FILL)

		--- Drag Rotate
		previewpanel.Angles = Angle( 0, 0, 0 )
		previewpanel.Pos = Vector( 0, 0, -10 )

		function previewpanel:DragMousePress()
			self.PressX, self.PressY = gui.MousePos()
			self.Pressed = true
		end

		function previewpanel:DragMouseRelease()
			self.Pressed = false
			self.lastPressed = RealTime()
		end

		function previewpanel:LayoutEntity( thisEntity )
			if ( self.bAnimated ) then self:RunAnimation() end

			if ( self.Pressed ) then
				local mx, my = gui.MousePos()
				self.Angles = self.Angles - Angle( 0, ( self.PressX or mx ) - mx, 0 )
				self.Pos = self.Pos + Vector( 0, 0, ((self.PressY or my) - my) / 10 )
				self.PressX, self.PressY = gui.MousePos()
			end

			if PS.customPos then
				thisEntity:SetPos( PS.customPos )
			else
				thisEntity:SetPos( Vector() )
			end

			if PS.HoverModel then
				local ITEM = PS.Items[PS.HoverModel]
				if ITEM.CustomPos then
					thisEntity:SetPos( ITEM.CustomPos )
				end
			end

			-- if ( RealTime() - ( self.lastPressed or 0 ) ) < 4 or self.Pressed then
				thisEntity:SetAngles( self.Angles )
				thisEntity:SetPos( self.Pos )
			-- else
			-- 	if PS.customAngle then
			-- 		self.Angles.y = PS.customAngle
			-- 	else
			-- 		self.Angles.y = math.NormalizeAngle(self.Angles.y + (RealFrameTime() * 21))
			-- 	end
			-- 	thisEntity:SetAngles( Angle( 0, self.Angles.y ,  0) )
			-- end

        end
	end

	self.Preview = preview

	self.BPTab = vgui.Create('waypass_main', self)
	if  not IsValid(self.BPTab) then return end
	self.BPTab:Dock(FILL)
	self.BPTab:SetVisible(false)
	self.BPTab:SetBPID(waypass.GetActiveBP() and waypass.GetActiveBP():GetID())

	local reload = function()
		if IsValid(self.BPTab) then self.BPTab:Reload() end
	end
	hook.Add('waypass.BPsUpdated', 'reload', reload)
	hook.Add('waypass.ChallengesUpdated', 'reload', reload)

	local dummy = vgui.Create('DPanel')
	dummy.Paint = wlib.func.blank

	local bpbutton = createBtn('Боевой пропуск', 'icon72/star.png', dummy, RIGHT)

	self.OpenCase = vgui.Create('DPointShopOpenCase', self)
	if not IsValid(self.OpenCase) then return end
	self.OpenCase:Dock(FILL)
	self.OpenCase:SetVisible(false)

	for _, v in ipairs(btns) do
		local old = v.OnActivate
		v.OnActivate = function()
			self.OpenCase:SetVisible(false)
			self.BPTab:SetVisible(false)
			preview:SetVisible(true)
			old()
		end
	end

	if waypass.GetActiveBP() then
		bpbutton.OnActivate = function()
			self.BPTab:SetVisible(true)
			preview:SetVisible(false)
		end
	end

	self.Buttons = btns
end

function PANEL:OpenCaseMenu(data, case, s, e)
	self.OpenCase:SetVisible(true)
	self.OpenCase:SetCase(data, case, s, e)

	self.Preview:SetVisible(false)
	for _, v in ipairs(self.Buttons or {}) do
		if IsValid(v) then v:SetActive(false) end
	end
end

function PANEL:Think()
	if self.ClientsList then
		local lines = self.ClientsList:GetLines()

		for _, ply in player.Iterator() do
			local found = false

			for _, line in pairs(lines) do
				if line.Player == ply then
					found = true
				end
			end

			if not found then
				self.ClientsList:AddLine(ply:GetName(), math.Round(ply:PS_GetPoints(), 2), table.Count(ply:PS_GetItems())).Player = ply
			end
		end

		for i, line in pairs(lines) do
			if IsValid(line.Player) then
				local ply = line.Player

				line:SetValue(1, ply:GetName())
				line:SetValue(2, math.Round(ply:PS_GetPoints(), 2))
				line:SetValue(3, table.Count(ply:PS_GetItems()))
			else
				self.ClientsList:RemoveLine(i)
			end
		end
	end
end

--local logo = Material( "data/wimages/wlogo.png", "unlitgeneric noclamp smooth" )
function PANEL:Paint(w, h)
	surface.DisableClipping( true )
		local x, y = self:ScreenToLocal(0,0)
		draw.RoundedBox( 4, x-1, y-1, ScrW()+2, ScrH()+2, Color(32,36,40, 220) )

		draw.RoundedBox( 4, -1, -1, w+2, h+2, Color(83,104,112) )
		draw.RoundedBox( 4, 0, 0, w, h, Color(32,36,40) )
	surface.DisableClipping( false )

	draw.RoundedBoxEx( 4, -1, -1, w+2, 49, Color(83,104,112) )

	if PS.Config.CommunityName then
		--[[ 		
		surface.SetDrawColor(255,255,255)
        	http.DownloadMaterial("http://wayzerroleplay.myarena.ru/x2.png", "x2.png", function(mat)
				surface.SetMaterial(mat)
			end)
		surface.DrawTexturedRect( 120, -25, 100, 100 )
		--]] 
		draw.SimpleText(PS.Config.CommunityName, 'PS_LargeTitle', 15, 8, color_white)
	else
		draw.SimpleText("PointShop", 'PS_LargeTitle', 55, 8, color_white)
	end

	draw.SimpleText('Баланс: ' .. math.Round(LocalPlayer():PS_GetPoints(), 2) .. PS.Config.PointsName, 'PS_Heading3', self:GetWide() - 460, 24, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

end

vgui.Register('DPointShopMenu', PANEL)

--addons/module_donate/lua/pointshop/vgui/dpointshopopencase.lua:
local dollarImage = 'data/wimages/moneybox.png'
local rubleImage = 'data/wimages/gem.png'
local PANEL = {}

function PANEL:Init()
    local main = self
    -- Предпросмотр кейса
    self.CasePrev = vgui.Create('Panel', self)
    self.CasePrev:Dock(FILL)

    function self.CasePrev:Paint(w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(32, 36, 40))
    end

    -- Панель кейса
    self.CasePrev.Prev = vgui.Create('Panel', self.CasePrev)
    self.CasePrev.Prev:Dock(FILL)
    local wh = math.min(1024, ScrW()) / 2 - 100

    function self.CasePrev.Prev:Paint(w, h)
        draw.RoundedBox(0, wh, 210, 200, 30, Color(235, 235, 235))
        draw.SimpleText(self.Case or 'Кейс...', 'PS_ItemName', wh + 5, 215, Color(0, 0, 0))
    end

    -- Иконка кейса
    self.CasePrev.Prev.Image = vgui.Create('DImage', self.CasePrev.Prev)
    self.CasePrev.Prev.Image:SetImage(dollarImage)
    self.CasePrev.Prev.Image:SetSize(200, 200)
    self.CasePrev.Prev.Image:SetPos(wh, 10)
    -- Кнопка открытия
    self.CasePrev.Prev.Open = vgui.Create('DButton', self.CasePrev.Prev)
    self.CasePrev.Prev.Open:SetSize(200, 25)
    self.CasePrev.Prev.Open:SetPos(wh, 245)
    self.CasePrev.Prev.Open:SetText('Открыть')

    function self.CasePrev.Prev.Open:DoClick()
        if not IsValid(self.spin) then
            self.spin = vgui.Create('DPointShopCaseSpin', main.CasePrev.Prev)
            self.spin:SetTall(300)
            self.spin:SetWide(680)
            self.spin:SetPos(math.min(1024, ScrW()) / 2 - 340, 0)
            self.spin.main = main
        end

        if not main.data or not main.case or not main.Speed or not main.EndPoint then return end
        self.spin:SetCase(main.data, main.case, main.Speed, main.EndPoint)
        self.spin:SetVisible(true)
    end

    -- Содержимое кейса
    self.CasePrev.Category = vgui.Create("DCollapsibleCategory", self.CasePrev)

    function self.CasePrev.Category:Paint(w, h)
        draw.RoundedBox(0, 0, 0, w - 15, 23, Color(236, 113, 73))
        draw.SimpleText('Предметы, которые могут быть в этом кейсе', 'chelog-ib.small', 12, 0, Color(255, 255, 255))
    end

    self.CasePrev.Category.CatagoryColor = Color(25, 52, 25)
    self.CasePrev.Category:Dock(FILL)
    self.CasePrev.Category:DockMargin(15, 300, 0, 0)
    self.CasePrev.Category:SetLabel('')

    function self.CasePrev.Category:Toggle()
    end

    self.CasePrev.Items = vgui.Create('DPanelList', self.CasePrev.Category)
    self.CasePrev.Items:Dock(FILL)
    self.CasePrev.Items:SizeToContents()
    self.CasePrev.Items:SetSpacing(30)
    self.CasePrev.Items:EnableHorizontal(true)
    self.CasePrev.Items:EnableVerticalScrollbar(true)
    self.CasePrev.Items:DockMargin(0, 10, 15, 0)

    function self.CasePrev.Items:SetCase(case)
        for k, v in pairs(self:GetItems()) do
            v:Remove()
        end

        local ITEM = PS.Items[case]

        main.CasePrev.Prev.Case = ITEM and ITEM.Name or 'Кейс'
        main.CasePrev.Prev.Image:SetMaterial(ITEM and ITEM.Material)
        local hasItem = {}

        for k, v in pairs(main.data) do
            if hasItem[v.itemName] then continue end

            hasItem[v.itemName] = {
                sort = v.itemChance,
                name = v.itemName,
                type = v.Type,
                color = v.itemColor,
                model = v.itemModel
            }
        end

        for k, v in SortedPairsByMemberValue(hasItem, 'sort', true) do
            item = vgui.Create('DPanel')
            item:SetSize(170, 200)

            function item:Paint(w, h)
                draw.RoundedBox(0, 0, 170, w, 30, v.color or Color(0, 0, 0))
                draw.SimpleText(v.name, 'PS_ItemName', 5, 175, Color(255, 255, 255))
            end

            if v.type == "POINTS" then
                item.modelView = vgui.Create("DImage", item)
                item.modelView:SetSize(170, 170)
                item.modelView:SetImage(rubleImage)
            elseif v.type == "MONEY" then
                item.modelView = vgui.Create("DImage", item)
                item.modelView:SetSize(170, 170)
                item.modelView:SetImage(dollarImage)
            else
                item.modelView = vgui.Create("DImage", item)
                item.modelView:SetSize(170, 170)
                item.modelView:SetImage(v.model)
            end

            self:AddItem(item)
        end
    end
end

function PANEL:SetCase(data, case, s, e)
    self.data = data
    self.case = case
    self.Speed = s
    self.EndPoint = e
    self.CasePrev.Items:SetCase(case)
    self.CasePrev.Prev.Open:DoClick()
end

vgui.Register('DPointShopOpenCase', PANEL, 'DPanel')
--addons/module_donate/lua/pointshop/items/cases/case_butterfly.lua:
ITEM.Name = 'Секретный Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Нож Бабочка"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_butterfly.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_butterfly')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_dollar.lua:
ITEM.Name = 'Долларовый кейс'
ITEM.Price = 19
ITEM.Description = "Что можно выбить?\n- 100.000$\n- 300.000$\n- 500.000$\n- 1.000.000$\n- 5.000.000$\n- 10.000.000$\n- 100.000.000$"
--ITEM.Material =  Material( "data/wimages/case_dollar.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_dollar.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:OpenCrate('case_dollar')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_steel.lua:
ITEM.Name = 'Стальной Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Винтовка мосин навсегда"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_steel.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_steel')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/companions/bomb.lua:
ITEM.Name = 'Бомба'
ITEM.Price = 299
ITEM.Model = 'models/dynamite/dynamite.mdl'
--ITEM.Material = Material( "data/wimages/bomb.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bomb.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true


function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y + 90
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/dog.lua:
ITEM.Name = 'Собака'
ITEM.Price = 299
ITEM.Model = 'models/balloons/balloon_dog.mdl'
--ITEM.Material = Material( "data/wimages/dog.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dog.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/gravityrings.lua:
ITEM.Name = 'Гравитационные Кольца'
ITEM.Price = 349
ITEM.Model = 'models/maxofs2d/hover_rings.mdl'
--ITEM.Material = Material( "data/wimages/superball.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/superball.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/skull.lua:
ITEM.Name = 'Череп ( Хэллоуин )'
ITEM.Price = 349
ITEM.Model = 'models/Gibs/HGIBS.mdl'
--ITEM.Material = Material( "data/wimages/skull.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/skull.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/cover/cover_cybercity.lua:
ITEM.Name = 'Город будущего'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_cybercity.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_cybercity.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_ice.lua:
ITEM.Name = 'Горная прохлада'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_ice.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_ice.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_sun.lua:
ITEM.Name = 'Над небесами'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_sun.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_sun.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_toska.lua:
ITEM.Name = 'Вечная тоска'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_toska.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_toska.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/moneypacks/__category.lua:
CATEGORY.Name = 'Деньги'
CATEGORY.Icon = 'money_with_wings'

--addons/module_donate/lua/pointshop/items/moneypacks/500k.lua:
ITEM.Name = '500,000 $'
ITEM.Price = 19
--ITEM.Material = Material( "data/wimages/moneybox.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moneybox.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:addMoney( 500000 )
end

--addons/module_donate/lua/pointshop/items/other/__category.lua:
CATEGORY.Name = 'Разное'
CATEGORY.Icon = 'pill'
CATEGORY.AllowedEquipped = 1

--addons/module_donate/lua/pointshop/items/other/2d.lua:
ITEM.Name = '2D модельки на 5 минут'
ITEM.Description = 'Делает всех игроков на сервере плоскими'
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/props.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/props.png'
ITEM.NoScroll = true
ITEM.SingleUse = true
ITEM.NoPreview = true

function ITEM:OnUse( ply )
	net.Start('Set2DPlayer')
	net.Broadcast()
  	DarkRP.notifyAll(0, 10, ply:Name().." сделал всех 2D на 5 минут")
end
--addons/module_donate/lua/pointshop/items/other/ar_boost.lua:
ITEM.Name = '100 брони при спавне'
ITEM.Description = 'Выдает 100 брони при спавне за любую профессию'
ITEM.Price = 490
--ITEM.Material =  Material( "data/wimages/armor.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/armor.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
--addons/module_donate/lua/pointshop/items/other/doublejump_navsegda.lua:
ITEM.Name = 'Двойной прыжок навсегда'
ITEM.Description = 'Ты получаешь возможность совершить двойной прыжок за любую профессию'
ITEM.Price = 990
--ITEM.Material =  Material( "data/wimages/doublejump.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/doublejump.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
--addons/module_donate/lua/pointshop/items/other/govorilka_navsegda.lua:
ITEM.Name = 'Говорилка навсегда'
ITEM.Description = 'Озвучивает весь написанный текст вслух!'
ITEM.Price = 490
--ITEM.Material =  Material( "data/wimages/microphone.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/microphone.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.Voices = {
    alyss = {
        name = 'Алиса (Ж)',
    },
    oksana = {
        name = 'Оксана (Ж)',
    },
    jane = {
        name = 'Джейн (Ж)',
    },
    omazh = {
        name = 'Оммаж (Ж)',
    },
    zahar = {
        name = 'Захар (М)',
    },
    ermil = {
        name = 'Эрмиль (М)',
    },
    google = {
        name = 'Гуглесса (Ж)',
        url = 'https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q={text}&tl=ru',
    },
}

local char_to_hex = function(c)
    return string.format("%%%02X", string.byte(c))
end

local function urlencode(url)
    if url == nil then
    return
    end
    url = url:gsub("\n", "\r\n")
    url = url:gsub("([^%w ])", char_to_hex)
    url = url:gsub(" ", "+")
    return url
end

function ITEM:GetURL(voice, text)
    if not self.Voices[voice] then return end

    local url = self.Voices[voice].url or 'http://tts.voicetech.yandex.net/tts?speaker={voice}&text={text}'
    url = string.Replace(url, '{voice}', voice)
    url = string.Replace(url, '{text}', urlencode(text))

    return url
end

function ITEM:OnEquip(ply, modifications)
    if not modifications or not modifications.voice then
        ply:PS_ModifyItem(self.ID, {voice = 'zahar'})

        ply:PS_Notify('Ты можешь изменить голос говорилки')
        ply:PS_Notify('Для этого нажми на нее в магазине и выбери "Изменить..."')
    end
end

function ITEM:CanPlayerModify(ply, modifications)
    for k, v in pairs(modifications) do
        if k ~= 'voice' then return false, 'Куда ты лезешь?' end
    end

    return self.Voices[modifications.voice] or false
end

ITEM.Samples = {
    'Я в своем познании настолько преисполнился, что я как будто бы уже сто триллионов миллиардов лет проживаю на триллионах и триллионах таких же планет, как эта Земля',
    'Эх, как же хочется тяночку, худенькую, бледную, не очень высокую',
    'Нужно построить Зиккурат',
    'Купил как-то мужик шляпу, а она ему как раз!',
    'Идет медведь по лесу, видит, машина горит. Сел в нее и сгорел',
    
    'Помогите, он держит меня в заложниках и заставляет делать аддоны для гаррис мода. Я не видел солнечного света уже 2 года!',
}

local curplaying
function ITEM:Modify(modifications)
    local frame = vgui.Create('DFrame')
    frame:SetSize(300, 100)
    frame:SetTitle('Изменение голоса')
    frame:MakePopup()
    frame:Center()
    frame:SetDraggable(false)
    frame:SetBackgroundBlur(true)
    frame:SetDrawOnTop(true)

    local pnl = vgui.Create('DPanel', frame)
    pnl:SetPaintBackground(false)
    pnl:Dock(TOP)
    pnl:DockMargin(0,4,0,0)
    pnl:SetTall(25)

    pnl:InvalidateParent(true)

    local combo = vgui.Create('DComboBox', pnl)
    combo:Dock(LEFT)
    combo:SetWide(pnl:GetWide() - 30)

    for k, v in pairs(self.Voices) do
        combo:AddChoice(v.name, k, modifications and modifications.voice == k)
    end

    local play = vgui.Create('DImageButton', pnl)
    play:Dock(RIGHT)
    play:SetSize(24, 24)
    play:SetImage('icon16/sound.png')
    play.DoClick = function()
        local voice = combo:GetOptionData(combo:GetSelectedID())
        
        local text = math.random(1, 100) <= 5 and self.Samples[#self.Samples] or self.Samples[math.random(1, #self.Samples-1)]
        
        if IsValid(curplaying) then curplaying:Stop() end
    
        sound.PlayURL(self:GetURL(voice, text), 'mono', function(station, errorId, errorName)
            if IsValid(station) then
                curplaying = station
                curplaying:Play()
            end
        end)
    end

    local submit = vgui.Create('DButton', frame)
    submit:Dock(BOTTOM)
    submit:SetText('Готово')
    submit:SetTall(25)
    submit:SetImage('icon16/accept.png')

    submit.DoClick = function()
        local voice = combo:GetOptionData(combo:GetSelectedID())

        if self.Voices[voice] then
            PS:SendModifications(self.ID, {voice = voice})
        else
            notification.AddLegacy('Ты не выбрал голос', 1, 5)
        end
        
        frame:Close()
    end
end
--addons/module_donate/lua/pointshop/items/other/message.lua:
ITEM.Name = 'Уведомление на 5 минут'
ITEM.Description = 'Показывает уведомление в нижней части экрана\nвсем игрокам в течение 5 минут'
ITEM.Price = 49
--ITEM.Material = Material( "data/wimages/props.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/props.png'
ITEM.NoScroll = true
ITEM.SingleUse = true
ITEM.NoPreview = true

function ITEM:OnUse( ply )
	ply:GivePSNotification( 5, self.Price )
end
--addons/module_donate/lua/pointshop/items/other/outfit_guitar.lua:
ITEM.Name = 'Гитара на спине'
ITEM.Price = 999
ITEM.Description = 'Косметика для всех профессий'
ITEM.Model = 'models/props_phx/misc/fender.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Bone = 'ValveBiped.Bip01_Spine2'
ITEM.NoScroll = true
ITEM.Hidden = true
--ITEM.Job = {['maniak'] = true}
--ITEM.NoDrawDisguise = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 3) + (ang:Up() * 1) + (ang:Forward() * 1)
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Up(), 160)

	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/outfit_knife.lua:
-- должно показыватся только с ножом в руках ( все профессии )

ITEM.Name = 'Нож в левую руку'
ITEM.Price = 999
ITEM.Model = 'models/weapons/w_knife_ct.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Bone = 'ValveBiped.Bip01_L_Hand'
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 1.5) + (ang:Up() * 2) 
	
	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/outfit_outbreak.lua:
ITEM.Name = 'Outbreak за спиной'
ITEM.Price = 999
ITEM.Description = 'Косметика для всех профессий'
ITEM.Model = 'models/weapons/outbreak/w_outbreak.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Bone = 'ValveBiped.Bip01_Spine2'
ITEM.NoScroll = true
ITEM.Hidden = true
--ITEM.Job = {['gangstervip'] = true, ['gangstercannon'] = true, ['gangster'] = true, ['gangstermedic'] = true}
--ITEM.NoDrawDisguise = false

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 4) + (ang:Up() * 7) + (ang:Forward() * 1)
	--ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 160)

	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/outfit_shoes_secondary.lua:
ITEM.Name = 'Кроссовки Nike (П)'
ITEM.Price = 999
ITEM.Description = '*'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/shoes.png'
ITEM.Model = 'models/denom/amongusdrip/amongusrightshoe.mdl'
ITEM.Bone = 'ValveBiped.Bip01_R_Foot'
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
--    ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
--    ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
    pos = pos + (ang:Forward() * 4) + (ang:Right() * -3) + (ang:Up() * 3) -- vpered, vniz/vverx, vlevo vpravo
   ang:RotateAroundAxis(ang:Forward(), 90)
   ang:RotateAroundAxis(ang:Right(), 30)
   model:SetModelScale(2, 0)

    return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/ranks/__category.lua:
CATEGORY.Name = 'Привилегии'
CATEGORY.Icon = 'crown'
CATEGORY.AllowedEquipped = 1
CATEGORY.CustomAngle = 45
CATEGORY.CustomPos = Vector(10,10,-20)

--addons/module_donate/lua/pointshop/items/ranks/dmoderator_navsegda.lua:
ITEM.Name = 'DModerator навсегда'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования"
ITEM.Price = 990
--ITEM.Material = Material( "data/wimages/moder_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moder_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DModerator"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dsadmin_3m.lua:
ITEM.Name = 'DSAdmin на 3 месяца'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет все привилегии DAdmin \n Доступ к спавну через Q меню, оружия, энтити, транспорта, но только из категории Разрешено \n - При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 499
--ITEM.Material = Material( "data/wimages/dsadmin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dsadmin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DSAdmin"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/armorvape.lua:
ITEM.Name = 'Armor Vape навсегда'
ITEM.Description = "Вейп с жижкой, восстанавливает Броню до 110, обходя лимит"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/vape.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vape.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "weapon_vape_armor"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
	ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/karambit_knife.lua:
ITEM.Name = 'Нож Karambit'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_karambit"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_spawnguard/lua/rsp/shared.lua:
local spawn = {
	rp_bangclaw = {
		Vector( -1723, -1384, 59 ),
		Vector( -1242, -1007, 320 ),
	},

	rp_downtown_tits_2019 = {
		Vector(-1713, -2473, 14),
		Vector(-2382, -3321, -203),
	},
	
	rp_rockford_open = {
		Vector(-5475, -5736, -13397),
		Vector(-3802, -4565, -13939),
	},
}


function InSpawn( ent )
	local current_map = game.GetMap()
	
	if not spawn[current_map] then return false end

	return ent:GetPos():WithinAABox(spawn[current_map][1], spawn[current_map][2])
end

hook.Add('StartCommand', 'spawnguard', function(ply, cmd)
	if not InSpawn(ply) or not ply:Alive() then return end
	if IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == 'weapon_physgun' then return end

	cmd:RemoveKey(IN_ATTACK)
	cmd:RemoveKey(IN_ATTACK2)
	cmd:RemoveKey(IN_RELOAD)
end)
--addons/ent_top/lua/scoresheet/sheets/timeplay/config.lua:
scoresheet.time_header_text = "Больше всего наиграно времени" // the header text
scoresheet.time_header_text_color = Color( 150, 150, 105 ) // the color of the header bg

scoresheet.time_max_count = 10 // how many people does it show?
scoresheet.time_cut_at_row_count = 5 // how many rows of people untill it cuts to a new line? ( 5 seems to be max )

scoresheet.time_first_place_icon = Material( "icon16/clock.png" ) // the icon next to #1 name

scoresheet.time_font_header = "score_row_header" // the font used for the header of the row, # number - name
scoresheet.time_font_text = "score_row_text" // font used for the text of the row, $ money
--addons/module_rewards/lua/rewards/methods/discord/shared.lua:
rewards.methods.discord.name = 'Discord'
rewards.methods.discord.reward_text = '$50.000 и 15₽'
rewards.methods.discord.link_text = 'Привязать'
--addons/module_rewards/lua/rewards/methods/forum/client.lua:
function rewards.methods.forum:Link()
    Derma_Query('Убедись в том, что твой Steam-аккаунт привязан к форумному и нажми кнопку "Проверить"', 'Привязка форума', 'Проверить', function()
        net.Start('rewards.linkMethod')
        net.WriteString('forum')
        net.SendToServer()
    end, 'Отмена')
end

function rewards.methods.forum:Update(data, card)
    rewards.imageURL('https://forum.wayzer.ru/assets/avatars/'..data.data.avatar_url, 'forumavatar.png', function(img)
        if not IsValid(card) then return end
        card:SetImage(img)
    end)

    if data.received then
        card:SetText('Награда получена')
        card:SetTextColor(Color(200,200,200))
		card:SetButtonText('Получено')
        card:SetCallback(wlib.func.blank)
    end
end
--addons/model_santa/lua/autorun/santa_player.lua:
list.Set( "PlayerOptionsModel", "Santa", "models/Jaanus/santa.mdl" )

player_manager.AddValidHands( "Santa", "models/weapons/c_arms_santaclaus.mdl", 0, "00000000" )

player_manager.AddValidModel( "Santa", "models/Jaanus/santa.mdl" )
--addons/module_apg/lua/autorun/sh_apg.lua:
-- ULX Admin Commands Coming Soon!
--- PLanned Commands for Prop Management, and Server Cleanup.

--addons/module_donate/lua/pointshop/items/companions/bomb.lua:
ITEM.Name = 'Бомба'
ITEM.Price = 299
ITEM.Model = 'models/dynamite/dynamite.mdl'
--ITEM.Material = Material( "data/wimages/bomb.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bomb.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true


function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y + 90
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/cube.lua:
ITEM.Name = 'Куб'
ITEM.Price = 349
ITEM.Model = 'models/maxofs2d/cube_tool.mdl'
--ITEM.Material = Material( "data/wimages/skull.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cube.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/death.lua:
ITEM.Name = 'Смерть'
ITEM.Price = 999
ITEM.Model = 'models/roblox/ghost_of_the_week__lil_reaper.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/death.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:CanPlayerSell(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = ply:EyePos(), ply:EyeAngles()
	plyAng.y = plyAng.y + 180
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end
--addons/module_donate/lua/pointshop/items/companions/gravityrings.lua:
ITEM.Name = 'Гравитационные Кольца'
ITEM.Price = 349
ITEM.Model = 'models/maxofs2d/hover_rings.mdl'
--ITEM.Material = Material( "data/wimages/superball.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/superball.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/katana.lua:
ITEM.Name = 'Катана'
ITEM.Price = 349
ITEM.Model = 'models/weapons/w_hiltless.mdl'
--ITEM.Material = Material( "data/wimages/superball.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/katana.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.z = plyAng.z - 90
	plyAng.y = plyAng.y - 90
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-10, 1 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) - 20), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/cover/cover_flowers.lua:
ITEM.Name = 'Цветущие луга'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_flowers.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_flowers.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_halloween.lua:
ITEM.Name = 'Тыквенный переполох'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_halloween.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_halloween.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_ice.lua:
ITEM.Name = 'Горная прохлада'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_ice.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_ice.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_night.lua:
ITEM.Name = 'Лазурная полночь'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_night.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_night.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_outbreak.lua:
ITEM.Name = 'Могущество прорыва'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_outbreak.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_outbreak.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_rose.lua:
ITEM.Name = 'Дворец роз'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_rose.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_rose.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_ruin.lua:
ITEM.Name = 'Руины цивилизации'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_ruin.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_ruin.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_snegovik.lua:
ITEM.Name = 'Дух нового года'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_snegovik.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_snegovik.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_space.lua:
ITEM.Name = 'Пурпурный космос'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_space.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_space.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/other/doublejump_navsegda.lua:
ITEM.Name = 'Двойной прыжок навсегда'
ITEM.Description = 'Ты получаешь возможность совершить двойной прыжок за любую профессию'
ITEM.Price = 990
--ITEM.Material =  Material( "data/wimages/doublejump.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/doublejump.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
--addons/module_donate/lua/pointshop/items/other/entity_spawn.lua:
ITEM.Name = 'Спавн Entity через Q меню на месяц'
ITEM.Description = 'Ты получишь возможность спавнить энтити из вкладки Разрешено и Half - Life 2 ( не все предметы )'
ITEM.Price = 99
--ITEM.Material =  Material( "data/wimages/health.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/health.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
--addons/module_donate/lua/pointshop/items/other/govorilka_navsegda.lua:
ITEM.Name = 'Говорилка навсегда'
ITEM.Description = 'Озвучивает весь написанный текст вслух!'
ITEM.Price = 490
--ITEM.Material =  Material( "data/wimages/microphone.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/microphone.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.Voices = {
    alyss = {
        name = 'Алиса (Ж)',
    },
    oksana = {
        name = 'Оксана (Ж)',
    },
    jane = {
        name = 'Джейн (Ж)',
    },
    omazh = {
        name = 'Оммаж (Ж)',
    },
    zahar = {
        name = 'Захар (М)',
    },
    ermil = {
        name = 'Эрмиль (М)',
    },
    google = {
        name = 'Гуглесса (Ж)',
        url = 'https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q={text}&tl=ru',
    },
}

local char_to_hex = function(c)
    return string.format("%%%02X", string.byte(c))
end

local function urlencode(url)
    if url == nil then
    return
    end
    url = url:gsub("\n", "\r\n")
    url = url:gsub("([^%w ])", char_to_hex)
    url = url:gsub(" ", "+")
    return url
end

function ITEM:GetURL(voice, text)
    if not self.Voices[voice] then return end

    local url = self.Voices[voice].url or 'http://tts.voicetech.yandex.net/tts?speaker={voice}&text={text}'
    url = string.Replace(url, '{voice}', voice)
    url = string.Replace(url, '{text}', urlencode(text))

    return url
end

function ITEM:OnEquip(ply, modifications)
    if not modifications or not modifications.voice then
        ply:PS_ModifyItem(self.ID, {voice = 'zahar'})

        ply:PS_Notify('Ты можешь изменить голос говорилки')
        ply:PS_Notify('Для этого нажми на нее в магазине и выбери "Изменить..."')
    end
end

function ITEM:CanPlayerModify(ply, modifications)
    for k, v in pairs(modifications) do
        if k ~= 'voice' then return false, 'Куда ты лезешь?' end
    end

    return self.Voices[modifications.voice] or false
end

ITEM.Samples = {
    'Я в своем познании настолько преисполнился, что я как будто бы уже сто триллионов миллиардов лет проживаю на триллионах и триллионах таких же планет, как эта Земля',
    'Эх, как же хочется тяночку, худенькую, бледную, не очень высокую',
    'Нужно построить Зиккурат',
    'Купил как-то мужик шляпу, а она ему как раз!',
    'Идет медведь по лесу, видит, машина горит. Сел в нее и сгорел',
    
    'Помогите, он держит меня в заложниках и заставляет делать аддоны для гаррис мода. Я не видел солнечного света уже 2 года!',
}

local curplaying
function ITEM:Modify(modifications)
    local frame = vgui.Create('DFrame')
    frame:SetSize(300, 100)
    frame:SetTitle('Изменение голоса')
    frame:MakePopup()
    frame:Center()
    frame:SetDraggable(false)
    frame:SetBackgroundBlur(true)
    frame:SetDrawOnTop(true)

    local pnl = vgui.Create('DPanel', frame)
    pnl:SetPaintBackground(false)
    pnl:Dock(TOP)
    pnl:DockMargin(0,4,0,0)
    pnl:SetTall(25)

    pnl:InvalidateParent(true)

    local combo = vgui.Create('DComboBox', pnl)
    combo:Dock(LEFT)
    combo:SetWide(pnl:GetWide() - 30)

    for k, v in pairs(self.Voices) do
        combo:AddChoice(v.name, k, modifications and modifications.voice == k)
    end

    local play = vgui.Create('DImageButton', pnl)
    play:Dock(RIGHT)
    play:SetSize(24, 24)
    play:SetImage('icon16/sound.png')
    play.DoClick = function()
        local voice = combo:GetOptionData(combo:GetSelectedID())
        
        local text = math.random(1, 100) <= 5 and self.Samples[#self.Samples] or self.Samples[math.random(1, #self.Samples-1)]
        
        if IsValid(curplaying) then curplaying:Stop() end
    
        sound.PlayURL(self:GetURL(voice, text), 'mono', function(station, errorId, errorName)
            if IsValid(station) then
                curplaying = station
                curplaying:Play()
            end
        end)
    end

    local submit = vgui.Create('DButton', frame)
    submit:Dock(BOTTOM)
    submit:SetText('Готово')
    submit:SetTall(25)
    submit:SetImage('icon16/accept.png')

    submit.DoClick = function()
        local voice = combo:GetOptionData(combo:GetSelectedID())

        if self.Voices[voice] then
            PS:SendModifications(self.ID, {voice = voice})
        else
            notification.AddLegacy('Ты не выбрал голос', 1, 5)
        end
        
        frame:Close()
    end
end
--addons/module_donate/lua/pointshop/items/other/message.lua:
ITEM.Name = 'Уведомление на 5 минут'
ITEM.Description = 'Показывает уведомление в нижней части экрана\nвсем игрокам в течение 5 минут'
ITEM.Price = 49
--ITEM.Material = Material( "data/wimages/props.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/props.png'
ITEM.NoScroll = true
ITEM.SingleUse = true
ITEM.NoPreview = true

function ITEM:OnUse( ply )
	ply:GivePSNotification( 5, self.Price )
end
--addons/module_donate/lua/pointshop/items/ranks/dadmin_3m.lua:
ITEM.Name = 'DAdmin на 3 месяца'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования \n - Может заморозить игрока \n - Может выдавать оружие \n - Может поджечь игрока \n - Может дать регдолл игроку"
ITEM.Price = 299
--ITEM.Material = Material( "data/wimages/admin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/admin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DAdmin"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dsadmin_3m.lua:
ITEM.Name = 'DSAdmin на 3 месяца'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет все привилегии DAdmin \n Доступ к спавну через Q меню, оружия, энтити, транспорта, но только из категории Разрешено \n - При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 499
--ITEM.Material = Material( "data/wimages/dsadmin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dsadmin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DSAdmin"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/vip_navsegda.lua:
ITEM.Name = 'VIP навсегда'
ITEM.Description = " - Имеет доступ ко всем вип профессиям \n - Имеет доступ ко всем VIP предметам \n - Дополнительный кликер"
ITEM.Price = 490
--ITEM.Material = Material( "data/wimages/vip_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vip_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "VIP"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/__category.lua:
CATEGORY.Name = 'Оружие'
CATEGORY.Icon = 'zap'
CATEGORY.AllowedEquipped = 1
CATEGORY.CustomAngle = 45
CATEGORY.CustomPos = Vector(10,10,-20)

--addons/module_donate/lua/pointshop/items/weapons/huckleberry.lua:
ITEM.Name = 'Huckleberry'
ITEM.Description = 'Раздавай праздничный свинец под звон новогодних салютов!'
ITEM.Price = 999
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/huckleberry.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_huckleberry"
ITEM.Hidden = true


function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/magnun_hl2.lua:
ITEM.Name = 'Магнум навсегда'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 149
--ITEM.Material = Material( "data/wimages/magnum.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/magnum.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "ptp_cs_357"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/outbreak.lua:
ITEM.Name = 'OUTBREAK PERFECTED'
ITEM.Description = '~directive = KILL while enemies = PRESENT: execute(directive)~'
ITEM.Price = 999
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/outbreak.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_outbreak"
ITEM.Hidden = true


function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/wowozela_navsegda.lua:
ITEM.Name = 'Вовозелка навсегда'
ITEM.Description = "Вовозелка\n- Позволяет издавать различные звуки с разноцветным эффектом\n- Еще ты можешь загрузить любые звуки из интернета в вовозелку\n- Даже свой голос с определенными фразами ;)"
ITEM.Price = 499
--ITEM.Material = Material( "data/wimages/wowozela.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/wowozela.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wowozela"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/weapon_cuffs/lua/autorun/sh_handcuffs.lua:
AddCSLuaFile()

local ProtectedJobs = {
	"TEAM_ADMIN", "TEAM_MOD", "TEAM_MODERATOR", "TEAM_BANNED"
}

local function GetTrace( ply )
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
		local cuffed,wep = tr.Entity:IsHandcuffed()
		if cuffed then return tr,wep end
	end
end

local PLAYER = FindMetaTable( "Player" )

function PLAYER:IsHandcuffed()
	local wep = self:GetActiveWeapon()
	if not IsValid(wep) then return false end
	if not wep.IsHandcuffs then return false end

	return true,wep
end

local forcejump = {}

hook.Add( "SetupMove", "Cuffs Move Penalty", function(ply, mv, cmd)
	local cuffed, cuffs = ply:IsHandcuffed()
	if not (cuffed and IsValid(cuffs)) then return end
	
	mv:SetMaxClientSpeed( mv:GetMaxClientSpeed()*0.6 )
	
	if cuffs:GetRopeLength()<=0 then return end // No forced movement
	if not IsValid(cuffs:GetKidnapper()) then return end // Nowhere to move to
	
	local kidnapper = cuffs:GetKidnapper()
	if kidnapper==ply then return end
	
	local TargetPoint = (kidnapper:IsPlayer() and kidnapper:GetShootPos()) or kidnapper:GetPos()
	local MoveDir = (TargetPoint - ply:GetPos()):GetNormal()
	local ShootPos = ply:GetShootPos() + (Vector(0,0, (ply:Crouching() and 0)))
	local Distance = cuffs:GetRopeLength()
	
	local distFromTarget = ShootPos:Distance( TargetPoint )
	if distFromTarget<=(Distance+5) then return end
	if ply:InVehicle() then
		if SERVER and (distFromTarget>(Distance*3)) then
			ply:ExitVehicle()
		end
		
		return
	end
	
	local TargetPos = TargetPoint - (MoveDir*Distance)
	
	local xDif = math.abs(ShootPos[1] - TargetPos[1])
	local yDif = math.abs(ShootPos[2] - TargetPos[2])
	local zDif = math.abs(ShootPos[3] - TargetPos[3])
	
	local speedMult = 3+ ( (xDif + yDif)*0.5)^1.01
	local vertMult = math.max((math.Max(300-(xDif + yDif), -10)*0.08)^1.01  + (zDif/2),0)
	
	if kidnapper:GetGroundEntity()==ply then vertMult = -vertMult end
	
	local TargetVel = (TargetPos - ShootPos):GetNormal() * 10
	TargetVel[1] = TargetVel[1]*speedMult
	TargetVel[2] = TargetVel[2]*speedMult
	TargetVel[3] = TargetVel[3]*vertMult
	local dir = mv:GetVelocity()
	
	local clamp = 50
	local vclamp = 20
	local accel = 2000
	local vaccel = 30*(vertMult/50)

	dir[1] = (dir[1]>TargetVel[1]-clamp or dir[1]<TargetVel[1]+clamp) and math.Approach(dir[1], TargetVel[1], accel) or dir[1]
	dir[2] = (dir[2]>TargetVel[2]-clamp or dir[2]<TargetVel[2]+clamp) and math.Approach(dir[2], TargetVel[2], accel) or dir[2]
	
	if ShootPos[3]<TargetPos[3] then
		dir[3] = (dir[3]>TargetVel[3]-vclamp or dir[3]<TargetVel[3]+vclamp) and math.Approach(dir[3], TargetVel[3], vaccel) or dir[3]
		if vertMult>0 then 
			forcejump[ply:UserID()] = ply
		end
	end

	mv:SetVelocity( dir )
end)

if SERVER then
	timer.Create("Cuffs ForceJump CleanupTieHooks", 1, 0, function()
		for _,v in ipairs(forcejump) do
			if not IsValid(v) then forcejump[_] = nil return end
			if not v:OnGround() then return end
			
			local tr = util.TraceLine( {start = v:GetPos(), endpos = v:GetPos()+Vector(0,0,20), filter = v} )
			if tr.Hit then return end
			
			v:SetPos(v:GetPos()+Vector(0,0,5) )
			
			forcejump[_] = nil
		end
	end)
end

hook.Add( "CanPlayerEnterVehicle", "Cuffs PreventVehicle", function( ply )
	if ply:IsHandcuffed() then return false end
end)


hook.Add( "CuffsCanHandcuff", "Cuff ProtectAdmin", function( ply, target )
	if IsValid(target) and target:IsPlayer() and ProtectedJobs then
		for i=1,#ProtectedJobs do
			if ProtectedJobs[i] and _G[ ProtectedJobs[i] ] and target:Team()==_G[ ProtectedJobs[i] ] then return false end
		end
	end
end)

if CLIENT then
	local Col = {
		Text = Color(255,255,255), TextShadow=Color(0,0,0), Rope = Color(255,255,255),
		
		BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
	}

	local matGrad = Material( "gui/gradient" )
	
	hook.Add( "HUDPaint", "Cuffs CuffedInteractPrompt", function()
		if LocalPlayer():IsHandcuffed() then return end
		
		local tr,cuff = GetTrace( LocalPlayer() )
		if not (tr and IsValid(cuff)) then return end
		
		local w,h = (ScrW()/2), (ScrH()/2)
		
		local TextPos = h-40
		
		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, TextPos-1, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, TextPos, 200, 20 )
		
		render.SetScissorRect( w-100, TextPos, (w-100)+((cuff:GetCuffBroken()/100)*200), TextPos+20, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,TextPos, 200,20 )
			
			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,TextPos, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )
		TextPos = TextPos-25
		
		if IsValid(cuff:GetFriendBreaking()) then
			if cuff:GetFriendBreaking()==LocalPlayer() then
				draw.SimpleText( "Развязывание...", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
				draw.SimpleText( "Развязывание...", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
				TextPos = TextPos-20
			end
		else
			local str = string.format( "%s — развязать", (input.LookupBinding("+use") or "E"):upper() )
			draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
			TextPos = TextPos-20
		end
		
		if cuff:GetRopeLength()>0 then
			if IsValid(cuff:GetKidnapper()) then
				if cuff:GetKidnapper()==LocalPlayer() then
					local str = string.format( "%s — снять поводок", (input.LookupBinding("+reload") or "R"):upper() )
					draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
					draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
					TextPos = TextPos-20
				end
			else
				local str = string.format( "%s — надеть поводок", (input.LookupBinding("+reload") or "R"):upper() )
				draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
				draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
				TextPos = TextPos-20
			end
		end
		
		if cuff:GetCanBlind() then
			local str = string.format( "%s — %s", ("ПКМ"):upper(), cuff:GetIsBlind() and "развязать глаза" or "завязать глаза" )
			draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
			TextPos = TextPos-20
		end
		
		if cuff:GetCanGag() then
			local str = string.format( "%s — %s", ("ЛКМ"):upper(), cuff:GetIsGagged() and "вынуть кляп" or "вставить кляп" )
			draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
			TextPos = TextPos-20
		end
	end)
	
	//
	// Bind hooks
	hook.Add( "PlayerBindPress", "Cuffs CuffedInteract", function(ply, bind, pressed)
		if ply~=LocalPlayer() then return end
		
		if bind:lower()=="+attack" and pressed then
			if ply:KeyDown( IN_USE ) then
				local isDragging = false
				for _,c in pairs(ents.FindByClass("weapon_handcuffed")) do
					if c.GetRopeLength and c.GetKidnapper and c:GetRopeLength()>0 and c:GetKidnapper()==ply then
						isDragging=true
						break
					end
				end
			end
			local tr,cuffs = GetTrace( ply )
			if tr and cuffs:GetCanGag() then
				net.Start( "Cuffs_GagPlayer" )
					net.WriteEntity( tr.Entity )
					net.WriteBit( not cuffs:GetIsGagged() )
				net.SendToServer()
				return true
			end
		elseif bind:lower()=="+attack2" and pressed then
			local tr,cuffs = GetTrace( ply )
			if tr and cuffs:GetCanBlind() then
				net.Start( "Cuffs_BlindPlayer" )
					net.WriteEntity( tr.Entity )
					net.WriteBit( not cuffs:GetIsBlind() )
				net.SendToServer()
				return true
			end
		elseif bind:lower()=="+reload" and pressed then
			local tr,cuffs = GetTrace( ply )
			if tr and cuffs:GetRopeLength()>0 then
				net.Start( "Cuffs_DragPlayer" )
					net.WriteEntity( tr.Entity )
					net.WriteBit( LocalPlayer()~=cuffs:GetKidnapper() )
				net.SendToServer()
				return true
			end
		elseif bind:lower()=="+use" and pressed then
			local tr,cuffs = GetTrace( ply )
			if tr then
				net.Start( "Cuffs_FreePlayer" )
					net.WriteEntity( tr.Entity )
				net.SendToServer()
				return true
			else
				local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
				if IsValid(tr.Entity) and tr.Entity:GetNWBool("Cuffs_TieHook") then
					net.Start("Cuffs_UntiePlayers") net.SendToServer()
				end
			end
		end
	end)
	
	//
	// Render
	local DragBone = "ValveBiped.Bip01_R_Hand"
	local DefaultRope = Material("cable/rope")
	hook.Add( "PostDrawOpaqueRenderables", "Cuffs DragRope", function()
		local allCuffs = ents.FindByClass( "weapon_handcuffed" )
		for i=1,#allCuffs do
			local cuff = allCuffs[i]
			if not (IsValid(cuff) and IsValid(cuff.Owner) and cuff.GetRopeLength and cuff:GetRopeLength()>0 and cuff.GetKidnapper and IsValid(cuff:GetKidnapper())) then continue end
			
			local kidnapper = cuff:GetKidnapper()
			local kidPos = (kidnapper:IsPlayer() and kidnapper:GetPos() + Vector(0,0,37)) or kidnapper:GetPos()
			
			local pos = cuff.Owner:GetPos()
			local bone_cuffed = cuff.Owner:LookupBone( DragBone )
			if bone_cuffed then
				pos = cuff.Owner:GetBonePosition( bone_cuffed )
				if (pos.x==0 and pos.y==0 and pos.z==0) then pos = cuff.Owner:GetPos() end
			end
			local bone_kidnapper = kidnapper:LookupBone( DragBone )
			if bone_kidnapper then
				kidPos = kidnapper:GetBonePosition( bone_kidnapper )
				if (kidPos.x==0 and kidPos.y==0 and kidPos.z==0) then kidPos = kidnapper:GetPos() end
			end
			
			if not cuff.RopeMat then cuff.RopeMat = DefaultRope end
			render.SetMaterial( cuff.RopeMat )
			render.DrawBeam( kidPos, pos, 0.7, 0, 5, Col.Rope )
			render.DrawBeam( pos, kidPos, -0.7, 0, 5, Col.Rope )
		end
	end)
	
	local HeadBone = "ValveBiped.Bip01_Head1"
	local RenderPos = {
		Blind = {Vector(3.5,3,2.6), Vector(3.8,4.8,0), Vector(3.5,3,-2.8), Vector(2.4,-2,-3.8), Vector(1.5,-4.5,0), Vector(2.4,-2,3.8)},
		Gag = {Vector(1.0,4.2,2), Vector(1.0,5.5,-0.1), Vector(1.0,4.5,-2), Vector(0,0,-3.4), Vector(-0.8,-3,0), Vector(0,0,3.4)},
	}
	hook.Add( "PostPlayerDraw", "Cuffs DrawGag", function( ply )
		if not IsValid(ply) then return end
		
		local cuffed, cuff = ply:IsHandcuffed()
		if not (cuffed and IsValid(cuff)) then return end
		
		render.SetMaterial( DefaultRope )
		if cuff:GetIsBlind() then
			local pos,ang
			local bone = cuff.Owner:LookupBone( HeadBone )
			if bone then
				pos, ang = cuff.Owner:GetBonePosition( bone )
			end
			if pos and ang then
				local firstpos = pos + (ang:Forward()*RenderPos.Blind[1].x) + (ang:Right()*RenderPos.Blind[1].y) + (ang:Up()*RenderPos.Blind[1].z)
				local lastpos = firstpos
				for i=2,#RenderPos.Blind do
					local newPos = pos + (ang:Forward()*RenderPos.Blind[i].x) + (ang:Right()*RenderPos.Blind[i].y) + (ang:Up()*RenderPos.Blind[i].z)
					render.DrawBeam( newPos, lastpos, 1.5, 0, 1, Col.Rope )
					lastpos = newPos
				end
				render.DrawBeam( lastpos, firstpos, 1.5, 0, 1, Col.Rope )
			end
		end
		if cuff:GetIsGagged() then
			local pos,ang
			local bone = cuff.Owner:LookupBone( HeadBone )
			if bone then
				pos, ang = cuff.Owner:GetBonePosition( bone )
			end
			if pos and ang then
				local firstpos = pos + (ang:Forward()*RenderPos.Gag[1].x) + (ang:Right()*RenderPos.Gag[1].y) + (ang:Up()*RenderPos.Gag[1].z)
				local lastpos = firstpos
				for i=2,#RenderPos.Gag do
					local newPos = pos + (ang:Forward()*RenderPos.Gag[i].x) + (ang:Right()*RenderPos.Gag[i].y) + (ang:Up()*RenderPos.Gag[i].z)
					render.DrawBeam( newPos, lastpos, 1.5, 0, 1, Col.Rope )
					lastpos = newPos
				end
				render.DrawBeam( lastpos, firstpos, 1.5, 0, 1, Col.Rope )
			end
		end
	end)
end

--addons/_smallscripts/lua/autorun/sh_materials.lua:
list.Add( "OverrideMaterials", "models/wayzer/logo")
list.Add( "OverrideMaterials", "models/XQM//Deg360" )
list.Add( "OverrideMaterials", "models/XQM//LightLinesGB" )
list.Add( "OverrideMaterials", "models/XQM//LightLinesRed" )
list.Add( "OverrideMaterials", "models/XQM//SquaredMat" )
list.Add( "OverrideMaterials", "models/XQM//WoodTexture_1" )
list.Add( "OverrideMaterials", "models/airboat/airboat_blur02" )
list.Add( "OverrideMaterials", "models/alyx/emptool_glow" )
list.Add( "OverrideMaterials", "models/antlion/antlion_innards" )
list.Add( "OverrideMaterials", "models/barnacle/roots" )
list.Add( "OverrideMaterials", "models/combine_advisor/body9" )
list.Add( "OverrideMaterials", "models/combine_advisor/mask" )
list.Add( "OverrideMaterials", "models/combine_scanner/scanner_eye" )
list.Add( "OverrideMaterials", "models/debug/debugwhite" )
list.Add( "OverrideMaterials", "models/dog/eyeglass" )
list.Add( "OverrideMaterials", "models/effects/portalrift_sheet" )
list.Add( "OverrideMaterials", "models/effects/slimebubble_sheet" )
list.Add( "OverrideMaterials", "models/effects/splode1_sheet" )
list.Add( "OverrideMaterials", "models/effects/splode_sheet" )
list.Add( "OverrideMaterials", "models/gibs/metalgibs/metal_gibs" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs01" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs02" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs03" )
list.Add( "OverrideMaterials", "models/player/player_chrome1" )
list.Add( "OverrideMaterials", "models/props_animated_breakable/smokestack/brickwall002a" )
list.Add( "OverrideMaterials", "models/props_building_details/courtyard_template001c_bars" )
list.Add( "OverrideMaterials", "models/props_building_details/courtyard_template001c_bars" )
list.Add( "OverrideMaterials", "models/props_buildings/destroyedbuilldingwall01a" )
list.Add( "OverrideMaterials", "models/props_buildings/plasterwall021a" )
list.Add( "OverrideMaterials", "models/props_c17/frostedglass_01a" )
list.Add( "OverrideMaterials", "models/props_c17/furniturefabric001a" )
list.Add( "OverrideMaterials", "models/props_c17/furniturefabric002a" )
list.Add( "OverrideMaterials", "models/props_c17/furnituremetal001a" )
list.Add( "OverrideMaterials", "models/props_c17/gate_door02a" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder001" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder002" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder003" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01a" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01b" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01c" )
list.Add( "OverrideMaterials", "models/props_canal/canalmap_sheet" )
list.Add( "OverrideMaterials", "models/props_canal/coastmap_sheet" )
list.Add( "OverrideMaterials", "models/props_canal/metalcrate001d" )
list.Add( "OverrideMaterials", "models/props_canal/metalwall005b" )
list.Add( "OverrideMaterials", "models/props_canal/rock_riverbed01a" )
list.Add( "OverrideMaterials", "models/props_combine/citadel_cable" )
list.Add( "OverrideMaterials", "models/props_combine/citadel_cable_b" )
list.Add( "OverrideMaterials", "models/props_combine/com_shield001a" )
list.Add( "OverrideMaterials", "models/props_combine/combine_interface_disp" )
list.Add( "OverrideMaterials", "models/props_combine/combine_monitorbay_disp" )
list.Add( "OverrideMaterials", "models/props_combine/metal_combinebridge001" )
list.Add( "OverrideMaterials", "models/props_combine/pipes01" )
list.Add( "OverrideMaterials", "models/props_combine/pipes03" )
list.Add( "OverrideMaterials", "models/props_combine/prtl_sky_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/stasisfield_beam" )
list.Add( "OverrideMaterials", "models/props_debris/building_template010a" )
list.Add( "OverrideMaterials", "models/props_debris/building_template022j" )
list.Add( "OverrideMaterials", "models/props_debris/composite_debris" )
list.Add( "OverrideMaterials", "models/props_debris/concretefloor013a" )
list.Add( "OverrideMaterials", "models/props_debris/concretefloor020a" )
list.Add( "OverrideMaterials", "models/props_debris/concretewall019a" )
list.Add( "OverrideMaterials", "models/props_debris/metalwall001a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterceiling008a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall009d" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall021a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall034a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall034d" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall039c" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall040c" )
list.Add( "OverrideMaterials", "models/props_debris/tilefloor001c" )
list.Add( "OverrideMaterials", "models/props_foliage/driftwood_01a" )
list.Add( "OverrideMaterials", "models/props_foliage/oak_tree01" )
list.Add( "OverrideMaterials", "models/props_foliage/tree_deciduous_01a_trunk" )
list.Add( "OverrideMaterials", "models/props_interiors/metalfence007a" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01a" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01b" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01c" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01d" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01e" )
list.Add( "OverrideMaterials", "models/props_lab/Tank_Glass001" )
list.Add( "OverrideMaterials", "models/props_lab/cornerunit_cloud" )
list.Add( "OverrideMaterials", "models/props_lab/door_klab01" )
list.Add( "OverrideMaterials", "models/props_lab/security_screens" )
list.Add( "OverrideMaterials", "models/props_lab/security_screens2" )
list.Add( "OverrideMaterials", "models/props_lab/warp_sheet" )
list.Add( "OverrideMaterials", "models/props_lab/xencrystal_sheet" )
list.Add( "OverrideMaterials", "models/props_pipes/GutterMetal01a")
list.Add( "OverrideMaterials", "models/props_pipes/destroyedpipes01a" )
list.Add( "OverrideMaterials", "models/props_pipes/pipemetal001a" )
list.Add( "OverrideMaterials", "models/props_pipes/pipeset_metal02" )
list.Add( "OverrideMaterials", "models/props_pipes/pipesystem01a_skin1" )
list.Add( "OverrideMaterials", "models/props_pipes/pipesystem01a_skin2" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001b" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001c" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretefloor010a" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretewall064b" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretewall066a" )
list.Add( "OverrideMaterials", "models/props_wasteland/dirtwall001a" )
list.Add( "OverrideMaterials", "models/props_wasteland/metal_tram001a" )
list.Add( "OverrideMaterials", "models/props_wasteland/quarryobjects01" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02a" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02b" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02c" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff04a" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockgranite02a" )
list.Add( "OverrideMaterials", "models/props_wasteland/tugboat01" )
list.Add( "OverrideMaterials", "models/props_wasteland/tugboat02" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a_skin2" )
list.Add( "OverrideMaterials", "models/shadertest/predator" )
list.Add( "OverrideMaterials", "models/weapons/v_crossbow/rebar_glow" )
list.Add( "OverrideMaterials", "models/weapons/v_crowbar/crowbar_cyl" )
list.Add( "OverrideMaterials", "models/weapons/v_grenade/grenade body" )
list.Add( "OverrideMaterials", "models/weapons/v_slam/new light1" )
list.Add( "OverrideMaterials", "models/weapons/v_slam/new light2" )
list.Add( "OverrideMaterials", "models/weapons/v_smg1/texture5" )
list.Add( "OverrideMaterials", "models/XQM/BoxFull_diffuse" )
list.Add( "OverrideMaterials", "models/XQM/CellShadedCamo_diffuse" )
list.Add( "OverrideMaterials", "models/XQM/CinderBlock_Tex" )
list.Add( "OverrideMaterials", "models/XQM/JetBody2TailPiece_diffuse" )
list.Add( "OverrideMaterials", "models/XQM/PoleX1_diffuse" )
list.Add( "OverrideMaterials", "models/XQM/Rails/gumball_1" )
list.Add( "OverrideMaterials", "models/XQM/SquaredMatInverted" )
list.Add( "OverrideMaterials", "models/XQM/WoodPlankTexture" )
list.Add( "OverrideMaterials", "models/XQM/boxfull_diffuse" )
list.Add( "OverrideMaterials", "models/dav0r/hoverball" )
list.Add( "OverrideMaterials", "models/spawn_effect" )
list.Add( "OverrideMaterials", "phoenix_storms/Fender_chrome" )
list.Add( "OverrideMaterials", "phoenix_storms/Fender_white" )
list.Add( "OverrideMaterials", "phoenix_storms/Fender_wood" )
list.Add( "OverrideMaterials", "phoenix_storms/Future_vents" )
list.Add( "OverrideMaterials", "phoenix_storms/FuturisticTrackRamp_1-2" )
list.Add( "OverrideMaterials", "phoenix_storms/OfficeWindow_1-1" )
list.Add( "OverrideMaterials", "phoenix_storms/Pro_gear_side" )
list.Add( "OverrideMaterials", "phoenix_storms/black_brushes" )
list.Add( "OverrideMaterials", "phoenix_storms/black_chrome" )
list.Add( "OverrideMaterials", "phoenix_storms/blue_steel" )
list.Add( "OverrideMaterials", "phoenix_storms/camera" )
list.Add( "OverrideMaterials", "phoenix_storms/car_tire" )
list.Add( "OverrideMaterials", "phoenix_storms/checkers_map" )
list.Add( "OverrideMaterials", "phoenix_storms/cigar" )
list.Add( "OverrideMaterials", "phoenix_storms/concrete0" )
list.Add( "OverrideMaterials", "phoenix_storms/concrete1" )
list.Add( "OverrideMaterials", "phoenix_storms/concrete2" )
list.Add( "OverrideMaterials", "phoenix_storms/concrete3" )
list.Add( "OverrideMaterials", "phoenix_storms/construct/concrete_barrier00" )
list.Add( "OverrideMaterials", "phoenix_storms/construct/concrete_barrier2_00" )
list.Add( "OverrideMaterials", "phoenix_storms/construct/concrete_pipe_00" )
list.Add( "OverrideMaterials", "phoenix_storms/egg" )
list.Add( "OverrideMaterials", "phoenix_storms/gear" )
list.Add( "OverrideMaterials", "phoenix_storms/gear_top" )
list.Add( "OverrideMaterials", "phoenix_storms/grey_chrome" )
list.Add( "OverrideMaterials", "phoenix_storms/grey_steel" )
list.Add( "OverrideMaterials", "phoenix_storms/heli" )
list.Add( "OverrideMaterials", "phoenix_storms/indentTiles2" )
list.Add( "OverrideMaterials", "phoenix_storms/iron_rails" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_carbonfiber" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_carbonfiber2" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_metallic" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_metallic2" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_plastic" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_plastic2" )
list.Add( "OverrideMaterials", "phoenix_storms/metal_plate" )
list.Add( "OverrideMaterials", "phoenix_storms/metal_wheel" )
list.Add( "OverrideMaterials", "phoenix_storms/metalbox" )
list.Add( "OverrideMaterials", "phoenix_storms/metalbox2" )
list.Add( "OverrideMaterials", "phoenix_storms/metalfence004a" )
list.Add( "OverrideMaterials", "phoenix_storms/middle" )
list.Add( "OverrideMaterials", "phoenix_storms/mrref2" )
list.Add( "OverrideMaterials", "phoenix_storms/output_jack" )
list.Add( "OverrideMaterials", "phoenix_storms/pack2/chrome" )
list.Add( "OverrideMaterials", "phoenix_storms/pack2/interior_sides" )
list.Add( "OverrideMaterials", "phoenix_storms/pack2/train_floor" )
list.Add( "OverrideMaterials", "phoenix_storms/potato" )
list.Add( "OverrideMaterials", "phoenix_storms/pro_gear_top2" )
list.Add( "OverrideMaterials", "phoenix_storms/ps_grass" )
list.Add( "OverrideMaterials", "phoenix_storms/road" )
list.Add( "OverrideMaterials", "phoenix_storms/roadside" )
--list.Add( "OverrideMaterials", "phoenix_storms/scrnspace" )
list.Add( "OverrideMaterials", "phoenix_storms/side" )
list.Add( "OverrideMaterials", "phoenix_storms/simplyMetallic1" )
list.Add( "OverrideMaterials", "phoenix_storms/simplyMetallic2" )
list.Add( "OverrideMaterials", "phoenix_storms/smallwheel" )
list.Add( "OverrideMaterials", "phoenix_storms/spheremappy" )
list.Add( "OverrideMaterials", "phoenix_storms/t_light" )
list.Add( "OverrideMaterials", "phoenix_storms/thruster" )
list.Add( "OverrideMaterials", "phoenix_storms/tiles2" )
list.Add( "OverrideMaterials", "phoenix_storms/top" )
list.Add( "OverrideMaterials", "phoenix_storms/torpedo" )
list.Add( "OverrideMaterials", "phoenix_storms/trains/track_beamside" )
list.Add( "OverrideMaterials", "phoenix_storms/trains/track_beamtop" )
list.Add( "OverrideMaterials", "phoenix_storms/trains/track_plate" )
list.Add( "OverrideMaterials", "phoenix_storms/trains/track_plateside" )
list.Add( "OverrideMaterials", "phoenix_storms/white_brushes" )
list.Add( "OverrideMaterials", "phoenix_storms/white_fps" )
list.Add( "OverrideMaterials", "phoenix_storms/window" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_blue" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_green" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_red" )
list.Add( "OverrideMaterials", "phoenix_storms/wood_dome" )
list.Add( "OverrideMaterials", "phoenix_storms/wood_side" )
list.Add( "OverrideMaterials", "models/cs_havana/wndb" )
list.Add( "OverrideMaterials", "models/cs_havana/wndd" )
list.Add( "OverrideMaterials", "models/cs_italy/light_orange" )
list.Add( "OverrideMaterials", "models/cs_italy/plaster" )
list.Add( "OverrideMaterials", "models/cs_italy/pwtrim2" )
list.Add( "OverrideMaterials", "models/de_cbble/wndarch" )
list.Add( "OverrideMaterials", "models/de_chateau/ch_arch_b1" )
list.Add( "OverrideMaterials", "models/pi_window/plaster" )
list.Add( "OverrideMaterials", "models/pi_window/trim128" )
list.Add( "OverrideMaterials", "models/props/cs_assault/dollar" )
list.Add( "OverrideMaterials", "models/props/cs_assault/fireescapefloor" )
list.Add( "OverrideMaterials", "models/props/cs_assault/metal_stairs1" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneywrap" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneywrap02" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneytop" )
list.Add( "OverrideMaterials", "models/props/cs_assault/pylon" )
list.Add( "OverrideMaterials", "models/props/CS_militia/boulder01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/milceil001" )
list.Add( "OverrideMaterials", "models/props/CS_militia/militiarock" )
list.Add( "OverrideMaterials", "models/props/CS_militia/militiarockb" )
list.Add( "OverrideMaterials", "models/props/CS_militia/milwall006" )
list.Add( "OverrideMaterials", "models/props/CS_militia/rocks01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams02" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams03" )
list.Add( "OverrideMaterials", "models/props/CS_militia/RoofEdges" )
list.Add( "OverrideMaterials", "models/props/cs_office/clouds" )
list.Add( "OverrideMaterials", "models/props/cs_office/file_cabinet2" )
list.Add( "OverrideMaterials", "models/props/cs_office/file_cabinet3" )
list.Add( "OverrideMaterials", "models/props/cs_office/screen" )
list.Add( "OverrideMaterials", "models/props/cs_office/snowmana" )
list.Add( "OverrideMaterials", "models/props/de_inferno/de_inferno_boulder_03" )
list.Add( "OverrideMaterials", "models/props/de_inferno/infflra" )
list.Add( "OverrideMaterials", "models/props/de_inferno/infflrd" )
list.Add( "OverrideMaterials", "models/props/de_inferno/inftowertop" )
list.Add( "OverrideMaterials", "models/props/de_inferno/offwndwb_break" )
list.Add( "OverrideMaterials", "models/props/de_inferno/roofbits" )
list.Add( "OverrideMaterials", "models/props/de_inferno/tileroof01" )
list.Add( "OverrideMaterials", "models/props/de_inferno/woodfloor008a" )
list.Add( "OverrideMaterials", "models/props/de_nuke/nukconcretewalla" )
list.Add( "OverrideMaterials", "models/props/de_nuke/nukecardboard" )
list.Add( "OverrideMaterials", "models/props/de_nuke/pipeset_metal" )
list.Add( "OverrideMaterials", "models/wireframe" )
list.Add( "OverrideMaterials", "debug/env_cubemap_model" )
list.Add( "OverrideMaterials", "models/shadertest/shader3" )
list.Add( "OverrideMaterials", "models/shadertest/shader4" )
list.Add( "OverrideMaterials", "models/shadertest/shader5" )
list.Add( "OverrideMaterials", "models/shiny" )
list.Add( "OverrideMaterials", "models/debug/debugwhite" )
list.Add( "OverrideMaterials", "Models/effects/comball_sphere" )
list.Add( "OverrideMaterials", "Models/effects/comball_tape" )
list.Add( "OverrideMaterials", "Models/effects/splodearc_sheet" )
list.Add( "OverrideMaterials", "Models/effects/vol_light001" )
list.Add( "OverrideMaterials", "models/props_combine/stasisshield_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/portalball001_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/com_shield001a" )
list.Add( "OverrideMaterials", "models/props_c17/frostedglass_01a" )
list.Add( "OverrideMaterials", "models/props_lab/Tank_Glass001" )
list.Add( "OverrideMaterials", "models/props_combine/tprings_globe" )
list.Add( "OverrideMaterials", "models/rendertarget" )
list.Add( "OverrideMaterials", "models/screenspace" )
list.Add( "OverrideMaterials", "brick/brick_model" )
list.Add( "OverrideMaterials", "models/props_pipes/GutterMetal01a" )
list.Add( "OverrideMaterials", "models/props_pipes/Pipesystem01a_skin3" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a" )
list.Add( "OverrideMaterials", "models/props_foliage/tree_deciduous_01a_trunk" )
list.Add( "OverrideMaterials", "models/props_c17/FurnitureFabric003a" )
list.Add( "OverrideMaterials", "models/props_c17/FurnitureMetal001a" )
list.Add( "OverrideMaterials", "models/props_c17/paper01" )
list.Add( "OverrideMaterials", "models/flesh" )
list.Add( "OverrideMaterials", "models/airboat/airboat_blur02" )
list.Add( "OverrideMaterials", "models/alyx/emptool_glow" )
list.Add( "OverrideMaterials", "models/antlion/antlion_innards" )   
list.Add( "OverrideMaterials", "models/barnacle/roots" )
list.Add( "OverrideMaterials", "models/combine_advisor/body9" )
list.Add( "OverrideMaterials", "models/combine_advisor/mask" )
list.Add( "OverrideMaterials", "models/combine_scanner/scanner_eye" )
list.Add( "OverrideMaterials", "models/debug/debugwhite" )
list.Add( "OverrideMaterials", "models/dog/eyeglass" )
list.Add( "OverrideMaterials", "models/effects/comball_glow1" )
list.Add( "OverrideMaterials", "models/effects/comball_glow2" )
list.Add( "OverrideMaterials", "models/effects/portalrift_sheet" )
list.Add( "OverrideMaterials", "models/effects/slimebubble_sheet" )
list.Add( "OverrideMaterials", "models/effects/splode1_sheet" )
list.Add( "OverrideMaterials", "models/effects/splodearc_sheet" )
list.Add( "OverrideMaterials", "models/effects/splode_sheet" )
list.Add( "OverrideMaterials", "models/effects/vol_light001" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs01" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs02" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs03" )
list.Add( "OverrideMaterials", "models/gibs/metalgibs/metal_gibs" )
list.Add( "OverrideMaterials", "models/items/boxsniperrounds" )
list.Add( "OverrideMaterials", "models/player/player_chrome1" )
list.Add( "OverrideMaterials", "models/props_animated_breakable/smokestack/brickwall002a" )
list.Add( "OverrideMaterials", "models/props_building_details/courtyard_template001c_bars" )
list.Add( "OverrideMaterials", "models/props_building_details/courtyard_template001c_bars" )
list.Add( "OverrideMaterials", "models/props_buildings/destroyedbuilldingwall01a" )
list.Add( "OverrideMaterials", "models/props_buildings/plasterwall021a" )
list.Add( "OverrideMaterials", "models/props_c17/frostedglass_01a" )
list.Add( "OverrideMaterials", "models/props_c17/furniturefabric001a" )
list.Add( "OverrideMaterials", "models/props_c17/furniturefabric002a" )
list.Add( "OverrideMaterials", "models/props_c17/furnituremetal001a" )
list.Add( "OverrideMaterials", "models/props_c17/gate_door02a" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder001" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder002" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder003" )
list.Add( "OverrideMaterials", "models/props_canal/canalmap_sheet" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01a" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01b" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01c" )
list.Add( "OverrideMaterials", "models/props_canal/coastmap_sheet" )
list.Add( "OverrideMaterials", "models/props_canal/metalcrate001d" )
list.Add( "OverrideMaterials", "models/props_canal/metalwall005b" )
list.Add( "OverrideMaterials", "models/props_canal/rock_riverbed01a" )
list.Add( "OverrideMaterials", "models/props_combine/citadel_cable" )
list.Add( "OverrideMaterials", "models/props_combine/citadel_cable_b" )
list.Add( "OverrideMaterials", "models/props_combine/combine_interface_disp" )
list.Add( "OverrideMaterials", "models/props_combine/combine_monitorbay_disp" )
list.Add( "OverrideMaterials", "models/props_combine/com_shield001a" )
list.Add( "OverrideMaterials", "models/props_combine/health_charger_glass" )
list.Add( "OverrideMaterials", "models/props_combine/metal_combinebridge001" )
list.Add( "OverrideMaterials", "models/props_combine/pipes01" )
list.Add( "OverrideMaterials", "models/props_combine/pipes03" )
list.Add( "OverrideMaterials", "models/props_combine/prtl_sky_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/stasisfield_beam" )
list.Add( "OverrideMaterials", "models/props_debris/building_template010a" )
list.Add( "OverrideMaterials", "models/props_debris/building_template022j" )
list.Add( "OverrideMaterials", "models/props_debris/composite_debris" )
list.Add( "OverrideMaterials", "models/props_debris/concretefloor013a" )
list.Add( "OverrideMaterials", "models/props_debris/concretefloor020a" )
list.Add( "OverrideMaterials", "models/props_debris/concretewall019a" )
list.Add( "OverrideMaterials", "models/props_debris/metalwall001a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterceiling008a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall009d" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall021a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall034a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall034d" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall039c" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall040c" )
list.Add( "OverrideMaterials", "models/props_debris/tilefloor001c" )
list.Add( "OverrideMaterials", "models/props_foliage/driftwood_01a" )
list.Add( "OverrideMaterials", "models/props_foliage/oak_tree01" )
list.Add( "OverrideMaterials", "models/props_foliage/tree_deciduous_01a_trunk" )
list.Add( "OverrideMaterials", "models/props_interiors/metalfence007a" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01a" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01b" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01c" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01d" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01e" )
list.Add( "OverrideMaterials", "models/props_lab/cornerunit_cloud" )
list.Add( "OverrideMaterials", "models/props_lab/door_klab01" )
list.Add( "OverrideMaterials", "models/props_lab/security_screens" )
list.Add( "OverrideMaterials", "models/props_lab/security_screens2" )
list.Add( "OverrideMaterials", "models/props_lab/Tank_Glass001" )
list.Add( "OverrideMaterials", "models/props_lab/warp_sheet" )
list.Add( "OverrideMaterials", "models/props_lab/xencrystal_sheet" )
list.Add( "OverrideMaterials", "models/props_pipes/destroyedpipes01a" )
list.Add( "OverrideMaterials", "models/props_pipes/GutterMetal01a")
list.Add( "OverrideMaterials", "models/props_pipes/pipemetal001a" )
list.Add( "OverrideMaterials", "models/props_pipes/pipeset_metal02" )
list.Add( "OverrideMaterials", "models/props_pipes/pipesystem01a_skin1" )
list.Add( "OverrideMaterials", "models/props_pipes/pipesystem01a_skin2" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001b" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001c" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretefloor010a" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretewall064b" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretewall066a" )
list.Add( "OverrideMaterials", "models/props_wasteland/dirtwall001a" )
list.Add( "OverrideMaterials", "models/props_wasteland/metal_tram001a" )
list.Add( "OverrideMaterials", "models/props_wasteland/quarryobjects01" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02a" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02b" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02c" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff04a" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockgranite02a" )
list.Add( "OverrideMaterials", "models/props_wasteland/tugboat01" )
list.Add( "OverrideMaterials", "models/props_wasteland/tugboat02" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a_skin2" )
list.Add( "OverrideMaterials", "models/roller/rollermine_glow" )
list.Add( "OverrideMaterials", "models/weapons/v_crossbow/rebar_glow" )
list.Add( "OverrideMaterials", "models/weapons/v_crowbar/crowbar_cyl" )
list.Add( "OverrideMaterials", "models/weapons/v_grenade/grenade body" )
list.Add( "OverrideMaterials", "models/weapons/v_smg1/texture5" )
list.Add( "OverrideMaterials", "models/weapons/w_smg1/smg_crosshair" )
list.Add( "OverrideMaterials", "models/weapons/v_slam/new light2" )
list.Add( "OverrideMaterials", "models/weapons/v_slam/new light1" )
list.Add( "OverrideMaterials", "models/props/cs_assault/dollar" )
list.Add( "OverrideMaterials", "models/props/cs_assault/fireescapefloor" )
list.Add( "OverrideMaterials", "models/props/cs_assault/metal_stairs1" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneywrap" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneywrap02" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneytop" )
list.Add( "OverrideMaterials", "models/props/cs_assault/pylon" )
list.Add( "OverrideMaterials", "models/props/CS_militia/boulder01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/milceil001" )
list.Add( "OverrideMaterials", "models/props/CS_militia/militiarock" )
list.Add( "OverrideMaterials", "models/props/CS_militia/militiarockb" )
list.Add( "OverrideMaterials", "models/props/CS_militia/milwall006" )
list.Add( "OverrideMaterials", "models/props/CS_militia/rocks01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams02" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams03" )
list.Add( "OverrideMaterials", "models/props/CS_militia/RoofEdges" )
list.Add( "OverrideMaterials", "models/props/cs_office/clouds" )
list.Add( "OverrideMaterials", "models/props/cs_office/file_cabinet2" )
list.Add( "OverrideMaterials", "models/props/cs_office/file_cabinet3" )
list.Add( "OverrideMaterials", "models/props/cs_office/screen" )
list.Add( "OverrideMaterials", "models/props/cs_office/snowmana" )
list.Add( "OverrideMaterials", "models/props/de_inferno/de_inferno_boulder_03" )
list.Add( "OverrideMaterials", "models/props/de_inferno/infflra" )
list.Add( "OverrideMaterials", "models/props/de_inferno/infflrd" )
list.Add( "OverrideMaterials", "models/props/de_inferno/inftowertop" )
list.Add( "OverrideMaterials", "models/props/de_inferno/offwndwb_break" )
list.Add( "OverrideMaterials", "models/props/de_inferno/roofbits" )
list.Add( "OverrideMaterials", "models/props/de_inferno/tileroof01" )
list.Add( "OverrideMaterials", "models/props/de_inferno/woodfloor008a" )
list.Add( "OverrideMaterials", "models/props/de_nuke/nukconcretewalla" )
list.Add( "OverrideMaterials", "models/props/de_nuke/nukecardboard" )
list.Add( "OverrideMaterials", "models/props/de_nuke/pipeset_metal" )
list.Add( "OverrideMaterials", "models/shadertest/predator" )
list.Add( "OverrideMaterials", "patterns/texture1" )
list.Add( "OverrideMaterials", "patterns/texture2" )
list.Add( "OverrideMaterials", "patterns/texture3" )
list.Add( "OverrideMaterials", "patterns/texture4" )
list.Add( "OverrideMaterials", "patterns/texture5" )
list.Add( "OverrideMaterials", "patterns/texture6" )
list.Add( "OverrideMaterials", "patterns/texture7" )
list.Add( "OverrideMaterials", "patterns/texture8" )
list.Add( "OverrideMaterials", "patterns/texture9" )
list.Add( "OverrideMaterials", "patterns/texture10" )
list.Add( "OverrideMaterials", "patterns/texture11" )
list.Add( "OverrideMaterials", "patterns/texture12" )
list.Add( "OverrideMaterials", "patterns/texture13" )
list.Add( "OverrideMaterials", "patterns/texture14" )
list.Add( "OverrideMaterials", "patterns/texture15" )
list.Add( "OverrideMaterials", "patterns/texture16" )
list.Add( "OverrideMaterials", "patterns/texture17" )
list.Add( "OverrideMaterials", "patterns/texture18" )
list.Add( "OverrideMaterials", "patterns/texture19" )
list.Add( "OverrideMaterials", "patterns/texture20" )
list.Add( "OverrideMaterials", "patterns/texture21" )
list.Add( "OverrideMaterials", "patterns/texture22" )
list.Add( "OverrideMaterials", "patterns/texture23" )
list.Add( "OverrideMaterials", "patterns/texture24" )
--addons/_smallscripts/lua/autorun/sh_other.lua:
timer.Simple( .1, function()
	DarkRP.removeChatCommand("makeshipment")
    FAdmin.Access.AddPrivilege('Noclip', 2)
end)

hook.Add('PlayerFootstep', 'NonRP', function(ply)
	if ply:FAdmin_GetGlobal('FAdmin_cloaked') then return true end
end)

local allowed = {
    ['slot_fifty_fifty'] = true,
    ['slot_roulette'] = true,
    ['slot_slots'] = true,
    ['slot_double'] = true,
    ['ent_graffiti'] = true,
}

hook.Add("canDoorRam", "allowed_ram", function(ply, trace, ent)
    local class = ent:GetClass()
    local victim = ent:CPPIGetOwner()
  
    if allowed[class] and victim.warranted then 
        ent:Remove()
        return true
    end

    return nil
end)

/*

if CLIENT then
    local IsValid = IsValid
    local halloween_cache = {}

    timer.Create("halloween_cache", 1, 0, function()
        local lp = LocalPlayer()
        if IsValid(lp) then
            local count = 0
            halloween_cache = {}

            for k,v in ipairs(ents.FindInSphere(lp:GetPos(), 200)) do
                if v == lp then continue end
                if v:GetNoDraw() then continue end
                if v:GetClass() == "player" then
                    local lPos = lp:EyePos()
                    local trace = util.TraceLine({
                        start = lPos,
                        endpos = v:EyePos(),
                        filter = lp,
                    })

                    if trace.Entity ~= v then continue end
                    
                    count = count + 1
                    halloween_cache[count] = v
                end
            end
        end
    end)

    local matLight = Material( "sprites/light_ignorez" )
    local color_eye = Color(255,0,0,255)

    hook.Add('PostDrawOpaqueRenderables', 'halloween_eye', function()
        for k,v in ipairs(halloween_cache) do
            if not IsValid(v) then continue end
            local eye = v:LookupAttachment( "eyes" )
            if ( eye ~= 0 ) then
                local pos = v:GetAttachment(eye).Pos
                local dir = v:EyeAngles()
                local offset = dir:Right() * 1.5
                
                render.SetMaterial( matLight )
                render.DrawSprite( pos - offset, 16, 16, color_eye, 255 )
                render.DrawSprite( pos + offset, 16, 16, color_eye, 255 )
            end
        end
    end)
end

*/
--addons/module_call/lua/autorun/sh_phone.lua:
phone = phone or {}

phone.tag = 'gmphone'
phone.cl_tag = 'gmphone_cl'

phone.Ringtones = {
	HL2_song29 = true,
	hl1_song10 = true,
	hl1_song11 = true,
	hl1_song25_remix3 = true,
	hl2_song1 = true,
	hl2_song12_long = true,
	hl2_song14 = true,
	hl2_song20_submix0 = true,
	hl2_song23_suitsong3 = true,
	hl2_song25_teleporter = true,
	hl2_song26 = true,
	hl2_song31 = true,
	hl2_song32 = true,
	hl2_song4 = true,
	radio1 = true,
	ravenholm_1 = true,
}

local sound_mat = Material( 'icon16/sound.png' )

nw.Register('phone_status')
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetPlayer()

nw.Register('phone_ringtone')
	:Write(net.WriteString)
	:Read(net.ReadString)
	:SetPlayer()

nw.Register('phone_talk')
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetPlayer()

phone.SelectRingtone = function()

	local fr = vgui.Create( 'DFrame' )
	fr:SetSize( 300, 150 )
	fr:SetTitle( ' Выбрать рингтон' )
	fr:Center()
	fr:MakePopup()
	fr:SetIcon('icon16/ipod.png')

	function fr:Close()
		if playing then
			RunConsoleCommand( 'play', '---------------------' ) -- kostyl time
		end
		fr:Remove()
	end

	local ringpanel = fr:Add( 'DPanel' )
	ringpanel:SetSize( 224, 24 )
	ringpanel:Center()

	local ringtones = ringpanel:Add( "DComboBox" )
	ringtones:SetSize(200, 24)
	ringtones:SetValue( LocalPlayer():GetNetVar('phone_ringtone') or 'HL2_song29' )

	for k,v in pairs(phone.Ringtones) do
		ringtones:AddChoice( k )
	end

	local ringtone = ringtones:GetValue()

	ringtones.OnSelect = function(self,index,value)
		ringtone = value
	end

	local playbtn = ringpanel:Add( 'DButton' )
	playbtn:SetSize( 24, 24 )
	playbtn:SetPos(200)
	playbtn:CenterVertical()
	playbtn:SetText("")

	playbtn.PaintOver = function(self, w, h)
		surface.SetMaterial( sound_mat )
		surface.SetDrawColor(color_white)
		surface.DrawTexturedRect( 4, 4, 16, 16 )
	end

	playbtn.DoClick = function()
		playing = true
		RunConsoleCommand( 'play', 'music/'..ringtone..'.mp3')
	end

	local save = fr:Add( 'DButton' )
	save:SetSize( 100, 24 )
	save:SetPos( 0, 100 )
	save:CenterHorizontal()
	save:SetText("Сохранить")

	save.DoClick = function()
		RunConsoleCommand( 'darkrp', 'ringtone', ringtone )
		fr:Close()
	end

end
hook.Add("DarkRPFinishedLoading", 'call_commands', function()
    timer.Simple(1, function()
		DarkRP.declareChatCommand{
			command = "call",
			description = "Позвонить игроку",
			delay = 1.5
		}

		DarkRP.declareChatCommand{
			command = "phone_reply",
			description = "Ответить на звонок",
			delay = 0
		}

		DarkRP.declareChatCommand{
			command = "phone_decline",
			description = "Ответить на звонок",
			delay = 0
		}

		DarkRP.declareChatCommand{
			command = "ringtone",
			description = "Сменить мелодию звонка",
			delay = 60
		}

		DarkRP.declareChatCommand{
			command = "toggleon_phone",
			description = "Включить телефон",
			delay = 5
		}

		DarkRP.declareChatCommand{
			command = "toggleoff_phone",
			description = "Выключить телефон",
			delay = 5
		}

		DarkRP.declareChatCommand{
			command = "phone_sendpos",
			description = "Отправить собеседнику свою геолокацию",
			delay = 5
		}
    end)
end)

if CLIENT then
	local color_dark = Color(54,57,62,255)
	local scrW,scrH = ScrW(), ScrH()

	phone.CreateVgui = function( ply, incoming, tmr )
		if phone.vgui then phone.vgui:Remove() end
		phone.vgui = vgui.Create( 'DFrame' )
		phone.vgui:SetSize( 200, 100 )
		phone.vgui:SetPos(scrW-205)
		phone.vgui:SetTitle( 'Телефон' )
		phone.vgui:CenterVertical()
		phone.vgui:ShowCloseButton(false)
		phone.vgui.Paint = function()
		  draw.RoundedBox(0,0,0,scrW / 4,scrH / 2, color_dark)	
		end

		phone.vgui.Close = function(self)
			self:Remove()
			RunConsoleCommand( 'darkrp', 'phone_decline')
		end
		
		local frame = phone.vgui

		local avatar = frame:Add( "AvatarImage" )
		avatar:SetPos(5,30)
		avatar:SetSize(40,40)
		avatar:SetSteamID(ply:SteamID64(), 32)

		local label = frame:Add( 'DLabel' )
		label:SetPos(55, 36)
		label:SetText( ply:GetName() )
		label:SizeToContents()

		if tmr then
			local starttime = CurTime()

			local timer = frame:Add( 'DLabel' )
			timer:SetPos(55, 2)
			timer.Think = function(self)
				local ct = math.floor( CurTime() - starttime )
				local timeformat = (ct>3600 and "%H:" or "") .. "%M:%S"
				if ct > 86400 then timeformat = 'охуел весь день звонить?' end
				self:SetText(os.date(timeformat, ct))
			end
		end

		local job = frame:Add( 'DLabel' )
		job:SetPos(55, 50)
		job:SetText(ply:GetNetVar('job'))
		job:SizeToContents()

		if incoming then

			local button1 = frame:Add( 'DButton' )
			button1:SetPos( 5, 75)
			button1:SetSize(95,20)
			button1:SetText('Принять')
			button1:SetImage("icon16/tick.png")
			button1.DoClick = function()
				phone.vgui:Remove()
				RunConsoleCommand( 'darkrp', 'phone_reply' )
			end

		end

		local button2 = frame:Add( 'DButton' )
		button2:SetPos( incoming and 100 or 5, 75)
		button2:SetSize( incoming and 95 or 190,20)
		button2:SetText('Отклонить')
		button2:SetImage("icon16/cancel.png")
		button2.DoClick = function()
			frame:Close()
		end
	end
	
	phone.CloseVgui = function()
		if IsValid( phone.vgui ) then
			phone.vgui:Remove()
		end
	end
	
	phone.EmitRingtone = function( ply )
		if !IsValid(ply) then return end
		local snd = ply:GetNetVar( 'phone_ringtone' ) or 'HL2_song29'
		snd = 'music/'..snd..'.mp3'

		if ply.ringtone then
			ply.ringtone:Stop()
			ply.ringtone = nil
		end
		
		util.PrecacheSound(snd)
		
		local VSnd = CreateSound(ply, snd)
		VSnd:SetSoundLevel(60)
		VSnd:Stop() VSnd:Play()
		VSnd:ChangePitch(100,0)
		VSnd:ChangeVolume(0.9, 0)
		
		ply.ringtone = VSnd
	end
	
	phone.ReadStatus = function()
		local status, data = net.ReadString(), net.ReadTable()
		
		if status == 'stopringtone' then
			if data.ply.ringtone then
				data.ply.ringtone:Stop()
				data.ply.ringtone = nil
			end
		end
		
		if status == 'decline' then
			phone.CloseVgui()
		end
		
		if status == 'started' then
			notification.AddLegacy('Твой собеседник будет видеть все сообщения, которые ты пишешь в чат', NOTIFY_HINT, 5)
			if LocalPlayer() == data.talker then
				phone.CreateVgui( data.receiver, false, true )
			else
				phone.CreateVgui( data.talker, false, true )
			end
		end
		
		if status == 'calling' then
			phone.CreateVgui( data.ply, false, true )
		end
		
		if status == 'incoming' then
			phone.CreateVgui( data.ply, true, true )
		end
		
		if status == 'ringtone' then
			phone.EmitRingtone( data.ply )
		end
		
	end
	net.Receive( phone.cl_tag, phone.ReadStatus )
end

--addons/module_police/lua/autorun/sh_simfphys_kickfromcar.lua:
properties.Add("kickfromcar", {
	MenuLabel = "Выгнать из авто",
	Order = 1,
	MenuIcon = "icon16/car_delete.png",

	Filter = function( self, ent, ply )
        if not simfphys then return false end
        if not IsValid(ent) then return false end
        if not simfphys.IsCar(ent) then return false end
        if ply:GetPos():DistToSqr(ent:GetPos()) > 40000 then return false end
        
        local driver = ent:GetDriverSeat():GetDriver()
        if IsValid(driver) then
            if ply ~= driver then return false end
        elseif ent:DoorGetOwner() ~= ply then return false end

        local check = false
        for _, v in ipairs(ent.pSeat) do
            if IsValid(v) and IsValid(v:GetDriver()) then
                check = true
                break
            end
        end

        return check
 	end,
    MenuOpen = function( self, option, ent, tr )
        local submenu = option:AddSubMenu()

        for _, v in pairs(ent.pSeat) do
            if not IsValid(v) then continue end

            local driver = v:GetDriver()
            if IsValid(driver) then
                submenu:AddOption(driver:Name(), function()
                    self:MsgStart()
                        net.WriteEntity(ent)
                        net.WriteEntity(driver)
                    self:MsgEnd()
                end)
            end
        end
    end,
	Action = function( self, ent )

	end,
	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
        local target = net.ReadEntity()

		if not self:Filter(ent, ply) then return end

        target.forceSittingHandcuffs = true
		target:ExitVehicle()
        target.forceSittingHandcuffs = false
	end
})
--addons/weapon_cuffs/lua/autorun/sv_handcuffs.lua:
if CLIENT then return end

util.AddNetworkString( "Cuffs_GagPlayer" )
util.AddNetworkString( "Cuffs_BlindPlayer" )
util.AddNetworkString( "Cuffs_FreePlayer" )
util.AddNetworkString( "Cuffs_DragPlayer" )

util.AddNetworkString( "Cuffs_TiePlayers" )
util.AddNetworkString( "Cuffs_UntiePlayers" )

local function GetTrace( ply )
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
		local cuffed,wep = tr.Entity:IsHandcuffed()
		if cuffed then return tr,wep end
	end
end

hook.Add( "CanPlayerSuicide", "Cuffs RestrictSuicide", function( ply )
	if ply:IsHandcuffed() then return false end
end)

hook.Add( "PlayerCanJoinTeam", "Cuffs RestrictTeam", function( ply )
	if ply:IsHandcuffed() then return false end
end)

hook.Add( "PlayerCanSeePlayersChat", "Cuffs ChatGag", function( _,_,_, ply )
	if not IsValid(ply) then return end
	
	local cuffed,wep = ply:IsHandcuffed()
	if cuffed and wep:GetIsGagged() then return false end
end)

hook.Add( "PlayerCanHearPlayersVoice", "Cuffs VoiceGag", function( _, ply )
	if not IsValid(ply) then return end
	
	local cuffed,wep = ply:IsHandcuffed()
	if cuffed and wep:GetIsGagged() then return false end
end)

hook.Add( "canRequestWarrant", "Cuffs PreventWarrant", function( crim, cop, reason )
	if cop:IsHandcuffed() then return false,"Ты не можешь это сделать в наручниках!" end
end)

hook.Add( "canWanted", "Cuffs PreventWarrant", function( crim, cop, reason )
	if cop:IsHandcuffed() then return false,"Ты не можешь это сделать в наручниках!" end
end)

hook.Add( "canArrest", "Cuffs RestrictArrest", function( cop, crim ) // DarkRP Arrest hook
    if crim:GetNetVar("Arrested") then return true end
	if IsValid(crim) and not crim:IsHandcuffed() then return false,"Ты должен надеть на него наручники!" end
end)

hook.Add( "playerCanChangeTeam", "Cuffs RestrictTeam", function( ply, tm, force )
	if ply:IsHandcuffed() and cvars.Bool("cuffs_restrictteams") and not force then return false,"Ты не можешь это сделать в наручниках!" end
end)

hook.Add( "CanChangeRPName", "Cuffs RestrictName", function( ply )
	if ply:IsHandcuffed() then return false,"Ты не можешь это сделать в наручниках!" end
end)

hook.Add('DoubleJumpAllowed', 'cuffs', function(ply)
	if ply:IsHandcuffed() then return false end
end)

net.Receive( "Cuffs_GagPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetCanGag()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldGag = net.ReadBit()==1
	cuffs:SetIsGagged( shouldGag )
	hook.Call( shouldGag and "OnHandcuffGag" or "OnHandcuffUnGag", GAMEMODE, ply, target, cuffs )
end)

net.Receive( "Cuffs_BlindPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetCanBlind()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldBlind = net.ReadBit()==1
	cuffs:SetIsBlind( shouldBlind )
	hook.Call( shouldBlind and "OnHandcuffBlindfold" or "OnHandcuffUnBlindfold", GAMEMODE, ply, target, cuffs )
end)

net.Receive( "Cuffs_FreePlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs)) then return end
	if IsValid(cuffs:GetFriendBreaking()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end

	if ply:Team() == TEAM_BANNED then return end
	
	cuffs:SetFriendBreaking( ply )
end)

net.Receive( "Cuffs_DragPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetRopeLength()>0) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldDrag = net.ReadBit()==1
	if shouldDrag then
		if not (IsValid(cuffs:GetKidnapper())) then
			cuffs:SetKidnapper( ply )
			hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, target, cuffs )
		end
	else
		if ply==cuffs:GetKidnapper() then
			cuffs:SetKidnapper( nil )
			hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, target, cuffs )
		end
	end
end)

local HookModel = Model("models/props_c17/TrapPropeller_Lever.mdl")
net.Receive("Cuffs_TiePlayers", function(_, ply)
    if (not IsValid(ply)) or ply:IsHandcuffed() then return end
    local DraggedCuffs = {}

    for _, c in pairs(ents.FindByClass("weapon_handcuffed")) do
        if c:GetRopeLength() > 0 and c:GetKidnapper() == ply then
            table.insert(DraggedCuffs, c)
        end
    end

    if #DraggedCuffs <= 0 then return end

    local tr = util.TraceLine({
        start = ply:EyePos(),
        endpos = ply:EyePos() + (ply:GetAimVector() * 100),
        filter = ply
    })

    if not tr.Hit then return end

    -- Pass to another player
    if IsValid(tr.Entity) then
        if tr.Entity:IsPlayer() then
            for i = 1, #DraggedCuffs do
                if DraggedCuffs[i].Owner == tr.Entity then
                    DraggedCuffs[i]:SetKidnapper(nil)
                    hook.Call("OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i])
                else
                    DraggedCuffs[i]:SetKidnapper(tr.Entity)
                    hook.Call("OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i])
                    hook.Call("OnHandcuffStartDragging", GAMEMODE, tr.Entity, DraggedCuffs[i].Owner, DraggedCuffs[i])
                    hook.Call('hitSystem.CuffsBroadcast', nil, DraggedCuffs[i].Owner, tr.Entity, ply)
                end
            end

            return
        end
    end
end)

local function DoUntie( ply, ent )
	for i=1,#ent.TiedHandcuffs do
		if not IsValid(ent.TiedHandcuffs[i]) then continue end
		
		ent.TiedHandcuffs[i]:SetKidnapper( ply )
		hook.Call( "OnHandcuffUnTied", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i], ent )
		hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i] )
	end
	
	ent:Remove()
end

net.Receive( "Cuffs_UntiePlayers", function(_,ply)
	-- if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	-- local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	-- if IsValid(tr.Entity) and tr.Entity.IsHandcuffHook and tr.Entity.TiedHandcuffs then
	-- 	DoUntie( ply, tr.Entity )
	-- end
end)
-- hook.Add( "AllowPlayerPickup", "Cuffs UntieHook", function(ply,ent)
-- 	if IsValid(ent) and ent.IsHandcuffHook and ent.TiedHandcuffs then
-- 		if (not IsValid(ply)) or ply:IsHandcuffed() then return end
		
-- 		DoUntie( ply, ent )
-- 		return false
-- 	end
-- end)
--addons/module_utime/lua/utime/sh_utime.lua:
-- Written by Team Ulysses, http://ulyssesmod.net/

nw.Register('TotalUTime')
	:Write(net.WriteFloat)
	:Read(net.ReadFloat)
	:SetPlayer()

nw.Register('UTimeStart')
	:Write(net.WriteFloat)
	:Read(net.ReadFloat)
	:SetPlayer()

local PLAYER = FindMetaTable("Player")

function PLAYER:GetUTime()
	return self:GetNetVar("TotalUTime", 0)
end

function PLAYER:GetUTimeStart()
	return self:GetNetVar( "UTimeStart", 0 )
end

function PLAYER:GetUTimeSessionTime()
	return CurTime() - self:GetUTimeStart()
end

function PLAYER:GetUTimeTotalTime()
	return self:GetUTime() + self:GetUTimeSessionTime()
end
--addons/module_wmap/lua/waymap/vgui_map.lua:
local PANEL = {}

wayMap.Zones = {
    ['rp_bangclaw'] = util.JSONToTable('[{"x":3519.0,"toY":-3983.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-4160.0,"toX":4609.0},{"x":4224.0,"toY":-3517.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-3983.0,"toX":4607.0},{"x":3518.0,"toY":-3103.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-3983.0,"toX":3713.0},{"x":7863.0,"toY":-1841.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-4524.0,"toX":10750.0},{"x":1408.0,"toY":-2369.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-3263.0,"toX":1536.0},{"x":1536.0,"toY":-2121.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-3135.0,"toX":2878.0},{"x":960.0,"toY":-2369.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2881.0,"toX":1408.0},{"x":-1024.0,"toY":-2367.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2495.0,"toX":959.0},{"x":-1025.0,"toY":-2175.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2368.0,"toX":-384.0},{"x":-465.0,"toY":-1512.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2175.0,"toX":-384.0},{"x":-1441.0,"toY":-1024.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1984.0,"toX":-1023.0},{"x":-1217.0,"toY":-1984.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2160.0,"toX":-1023.0},{"x":-1279.0,"toY":-511.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1024.0,"toX":-1088.0},{"x":-1088.0,"toY":-958.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1024.0,"toX":-1023.0},{"x":-384.0,"toY":384.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2367.0,"toX":67.0},{"x":-1022.0,"toY":-958.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1409.0,"toX":-383.0},{"x":66.0,"toY":-1536.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2369.0,"toX":1057.0},{"x":1057.0,"toY":-1919.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2369.0,"toX":1537.0},{"x":1536.0,"toY":-1918.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2122.0,"toX":2106.0},{"x":2105.0,"toY":-2050.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2122.0,"toX":2162.0},{"x":2162.0,"toY":-2087.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2122.0,"toX":2197.0},{"x":2106.0,"toY":-2022.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2050.0,"toX":2133.0},{"x":-464.0,"toY":-1409.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1513.0,"toX":-384.0},{"x":-1023.0,"toY":-1409.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1482.0,"toX":-987.0},{"x":-987.0,"toY":-1407.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1452.0,"toX":-956.0},{"x":-1086.0,"toY":-2160.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2228.0,"toX":-1023.0},{"x":-1058.0,"toY":-2228.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2263.0,"toX":-1025.0},{"x":-1118.0,"toY":-2160.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-2191.0,"toX":-1085.0},{"x":1698.0,"toY":-1090.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1918.0,"toX":2113.0},{"x":64.0,"toY":384.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1088.0,"toX":1918.0},{"x":67.0,"toY":-1089.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1535.0,"toX":154.0},{"x":1918.0,"toY":-993.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1089.0,"toX":2012.0},{"x":2011.0,"toY":-1039.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1089.0,"toX":2059.0},{"x":1918.0,"toY":-944.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-993.0,"toX":1965.0},{"x":2112.0,"toY":-1087.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1535.0,"toX":3906.0},{"x":2111.0,"toY":-1533.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1628.0,"toX":2155.0},{"x":2155.0,"toY":-1535.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1591.0,"toX":2190.0},{"x":2188.0,"toY":-1535.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1562.0,"toX":2215.0},{"x":3904.0,"toY":-1424.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1535.0,"toX":4608.0},{"x":3200.0,"toY":-385.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1087.0,"toX":3903.0},{"x":3081.0,"toY":-1016.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1089.0,"toX":3200.0},{"x":3130.0,"toY":-970.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1016.0,"toX":3202.0},{"x":3174.0,"toY":-924.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-971.0,"toX":3201.0},{"x":3036.0,"toY":-1058.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1092.0,"toX":3082.0},{"x":3200.0,"toY":-104.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-387.0,"toX":5294.0},{"x":3906.0,"toY":-387.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-1423.0,"toX":4802.0},{"x":1919.0,"toY":384.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-66.0,"toX":5001.0},{"x":3047.0,"toY":-64.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-105.0,"toX":5001.0},{"x":3200.0,"toY":-161.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-103.0,"toX":3107.0},{"x":3151.0,"toY":-157.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":-207.0,"toX":3202.0},{"x":896.0,"toY":1151.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":383.0,"toX":1344.0},{"x":701.0,"toY":443.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":383.0,"toX":897.0},{"x":768.0,"toY":512.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":441.0,"toX":897.0},{"x":828.0,"toY":572.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":512.0,"toX":897.0},{"x":867.0,"toY":611.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":572.0,"toX":898.0},{"x":702.0,"toY":1569.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":1150.0,"toX":1344.0},{"x":385.0,"toY":2689.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":1567.0,"toX":1888.0},{"x":281.0,"toY":2689.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":1569.0,"toX":385.0},{"x":1375.0,"toY":1536.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":911.0,"toX":2848.0},{"x":2847.0,"toY":1795.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":911.0,"toX":5471.0},{"x":3201.0,"toY":416.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":382.0,"toX":3649.0},{"x":3103.0,"toY":914.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":414.0,"toX":3744.0},{"x":2846.0,"toY":2112.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":1794.0,"toX":4031.0},{"x":4031.0,"toY":2112.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":1795.0,"toX":5182.0},{"x":2828.0,"toY":1538.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":2702.0,"toX":1884.0},{"x":1479.0,"toY":903.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":500.0,"toX":2200.0},{"x":2374.0,"toY":900.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":503.0,"toX":3092.0},{"x":4472.0,"toY":498.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":896.0,"toX":3747.0},{"x":4654.0,"toY":905.0,"col":{"r":255.0,"b":0.0,"a":60.0,"g":0.0},"y":513.0,"toX":5376.0},{"x":1481.0,"toY":503.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":901.0,"toX":2205.0},{"x":2369.0,"toY":501.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":904.0,"toX":3103.0},{"x":3059.0,"toY":1829.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":2125.0,"toX":4016.0},{"x":4217.0,"toY":1845.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":2117.0,"toX":5167.0},{"x":3748.0,"toY":497.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":888.0,"toX":4484.0},{"x":4645.0,"toY":512.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":897.0,"toX":5395.0},{"x":158.0,"toY":-1532.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":-1091.0,"toX":63.0},{"x":67.0,"toY":-1866.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":-1535.0,"toX":527.0},{"x":127.0,"toY":-1917.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":-1866.0,"toX":464.0},{"x":-1285.0,"toY":-1984.0,"col":{"r":255.0,"b":255.0,"a":60.0,"g":0.0},"y":-1025.0,"toX":-1439.0}]'),
    ['rp_1944berlin_v1'] = {},
    ['rp_downtown_tits_2019'] = {},
    ['rp_rockford_open'] = {}
}

wayMap.DoDrawZones = true

function PANEL:Init()
    self.markers = {}
    self.zoom = 1.8
    self.minZoom = 0.5
    self.maxZoom = 50
    self.origin = Vector(0, 0, 0)
    self.rotate = true
    self.minZ = 1800
    self.categories = {}
    self.sidebar = vgui.Create('DScrollPanel', self)
    self.sidebar:Dock(RIGHT)
    self.sidebar:DockMargin(4, 4, 4, 4)
    self.sidebar:SetWide(200)
    self.sidebar:SetPaintBackground(false)
    --[[
    self.player = vgui.Create('waymap_marker', self)
    self.player:SetName('Игрок')
    self.player:SetSize(16, 16)
    --self.player:SetOrigin(LocalPlayer():GetPos())
    self.player:SetTarget(LocalPlayer())
    self.player:SetMaterial(Material('icon16/user.png'))
    ]]
    self.scrw = ScrW()
    self.scrh = ScrH()
    self.oldRT = render.GetRenderTarget()
    self.RT = GetRenderTarget('wayMap', 1024, 1024)
    self:RebuildSidebar()
end

AccessorFunc(PANEL, 'origin', 'Origin')
AccessorFunc(PANEL, 'zoom', 'Zoom')
AccessorFunc(PANEL, 'rotate', 'Rotate')
AccessorFunc(PANEL, 'minZ', 'MinZ')
AccessorFunc(PANEL, 'minZoom', 'MinZoom')
AccessorFunc(PANEL, 'maxZoom', 'MaxZoom')

function PANEL:SetOrigin(origin)
    self.origin = origin
    self:UpdateMarkerPositions()
end

function PANEL:SetZoom(zoom)
    self.zoom = math.Clamp(zoom, self.minZoom, self.maxZoom)
end

function PANEL:Paint(w, h)
    local x, y = self:GetParent():LocalToScreen(self:GetPos())
    local zoom = self:GetZoom()
    local origin = self:GetOrigin()

    for _, v in ents.Iterator() do
        if v:GetNoDraw() then continue end
        v:SetNoDraw(true)
        v.wayMapNoDraw = true
    end

    render.SuppressEngineLighting(true)

    render.RenderView({
        origin = Vector(origin.x, origin.y, math.max(1000 * zoom, self:GetMinZ())),
        angles = Angle(90, self.rotate and 90 or 0, 0),
        x = x,
        y = y,
        w = w,
        h = h,
        zfar = 25000 * zoom,
        ortho = {
            left = -w * zoom,
            right = w * zoom,
            top = -h * zoom,
            bottom = h * zoom,
        },
        dopostprocess = false,
        drawhud = false,
        drawviewmodel = false,
        drawmonitors = false,
    })

    render.SuppressEngineLighting(false)

    for _, v in ents.Iterator() do
        if not v.wayMapNoDraw then continue end
        v:SetNoDraw(false)
        v.wayMapNoDraw = nil
    end

    self:UpdateMarkerPositions()
end

function PANEL:UpdateMarkerPositions()
    for id, marker in ipairs(wayMap.markers) do
        local sx, sy = self:VectorToLocal(marker:GetOrigin())
        marker:SetPos(sx - marker:GetWide() / 2, sy - marker:GetTall() / 2)
    end
end

function PANEL:VectorToLocal(vec)
    if not vec then return 0, 0 end
    local w, h = self:GetSize()
    local origin = self:GetOrigin()
    local zoom = self:GetZoom()
    local x, y

    if self.rotate then
        x = w / 2 - (origin.x - vec.x) / zoom * 0.5
        y = h / 2 + (origin.y - vec.y) / zoom * 0.5
    else
        x = w / 2 + (origin.y - vec.y) / zoom * 0.5
        y = h / 2 + (origin.x - vec.x) / zoom * 0.5
    end

    return x, y
end

function PANEL:LocalToVector(x, y)
    local w, h = self:GetSize()
    local origin = self:GetOrigin()
    local zoom = self:GetZoom()
    local vec = Vector(0, 0, origin.z)

    if self.rotate then
        vec.x = origin.x - (w / 2 - x) * zoom * 2
        vec.y = origin.y + (h / 2 - y) * zoom * 2
    else
        vec.x = origin.x + (h / 2 - y) * zoom * 2
        vec.y = origin.y + (w / 2 - x) * zoom * 2
    end

    return vec
end

function PANEL:Move(x, y)
    local old = self:GetOrigin()
    self:SetOrigin(Vector(old.x + x, old.y + y, old.z))
end

function PANEL:CreateMarker()
    local marker = vgui.Create('waymap_marker')
    marker:SetMarkerID(#self.markers + 1)
    table.insert(self.markers, marker)

    return self.markers[#self.markers]
end

function PANEL:GetMarker(id)
    return self.markers[id]
end

function PANEL:OnMousePressed(mousecode)
    self.MouseKey = mousecode
    if mousecode == MOUSE_RIGHT then return end
    self:MouseCapture(true)
    self.Capturing = true
    self:CaptureMouse()
end

function PANEL:OnMouseReleased()
    if self.MouseKey == MOUSE_RIGHT then
        local x, y = self:ScreenToLocal(input.GetCursorPos())
        local vec = self:LocalToVector(x, y)
        local menu = DermaMenu()

        for _, v in SortedPairsByMemberValue(wayMap.context, 'order') do
            if v.check and v.check(vec) == false then continue end

            if v.submenu then
                local submenu, option = menu:AddSubMenu(v.name)

                if v.icon then
                    option:SetIcon(v.icon)
                end

                v.submenu(submenu, vec)
            else
                local option = menu:AddOption(v.name, function()
                    if v.callback then
                        v.callback(vec)
                    end
                end)

                if v.icon then
                    option:SetIcon(v.icon)
                end
            end
        end

        menu:Open()
    end

    self:MouseCapture(false)
    self.Capturing = false
end

function PANEL:OnMouseWheeled(delta)
    --if self.Capturing then return end
    self:SetZoom(self:GetZoom() - delta * 0.1)
    self:UpdateMarkerPositions()
end

function PANEL:CaptureMouse()
    local x, y = input.GetCursorPos()
    local dx = x - (self.mx or 0)
    local dy = y - (self.my or 0)
    self.mx = x
    self.my = y

    if self.rotate then
        return -dx, dy
    else
        return dy, dx
    end
end

function PANEL:Think()
    if self.Capturing then
        local dx, dy = self:CaptureMouse()
        local zoom = self:GetZoom()
        self:Move(dx * zoom, dy * zoom, 0, 0)
    end
end

function PANEL:RebuildSidebar()
    self.sidebar:Clear()
    self.categories = {}

    table.sort(wayMap.markers, function(a, b)
        return a.order < b.order
    end)

    for id, marker in ipairs(wayMap.markers) do
        local btn = self.categories[marker:GetCategory() or id]

        if IsValid(btn) then
            table.insert(btn.markers, marker)
        else
            btn = vgui.Create('DButton', self.sidebar)
            btn:Dock(TOP)
            btn:SetTall(25)
            btn:SetText(marker:GetName())
            btn:SetIcon(marker:GetIcon())
            btn.current = 1

            btn.markers = {marker}

            btn.selected = false
            btn.OldPaint = btn.Paint

            btn.Paint = function(s, w, h)
                if s.selected then
                    draw.RoundedBox(2, 0, 0, w, h, Color(236, 113, 71))
                else
                    s.OldPaint(s, w, h)
                end
            end

            btn.DoClick = function()
                btn.current = btn.selected and btn.current + 1 or 1

                if not btn.markers[btn.current] then
                    btn.current = 1
                end

                self:SelectCategory(marker:GetCategory() or id)
                wayMap.map:SetOrigin(btn.markers[btn.current]:GetOrigin())
            end

            self.categories[marker:GetCategory() or id] = btn
        end
    end
end

function PANEL:SelectCategory(cat)
    for k, v in pairs(self.categories) do
        v.selected = k == cat and true or false
    end
end

vgui.Register('waymap', PANEL, 'DPanel')
local ourMat = Material("vgui/white")

hook.Add("PostDrawTranslucentRenderables", "DrawQuad_Example", function()
    if not IsValid(wayMap.frame) then return end
    if not wayMap.frame:IsVisible() then return end
    if not wayMap.Zones then return end
    if not wayMap.map then return end
    if not wayMap.DoDrawZones then return end
    render.SetMaterial(ourMat)
    local zz = -10000

    for k, v in pairs(wayMap.Zones[game.GetMap()]) do
        if not v.toX then continue end
        local vec1, vec2 = Vector(v.x, v.y, zz), Vector(v.toX, v.toY, zz)
        render.DrawBox(Vector((vec1.x + vec2.x) / 2, (vec1.y + vec2.y) / 2, zz), Angle(0, 0, 0), -(vec2 - vec1) / 2, (vec2 - vec1) / 2, v.col)
    end
end)
--addons/module_wmap/lua/waymap/cl_waymap.lua:
wayMap.markers = {}

wayMap.config = {
    ['rp_bangclaw'] = {
        zoom = {
            min = 0.5,
            max = 50,
        },
        minZ = 1800,
        rotate = true,
        markers = {
            {
                name = 'Мэрия',
                pos = Vector(1121, 2376, 208),
                icon = 'icon72/office.png',
                size = 16,
                order = 10,
            },
            {
                name = 'Полицейский участок',
                pos = Vector(4187, -767, 136),
                icon = 'icon72/oncoming_police_car.png',
                size = 16,
                order = 20,
            },
            {
                name = 'Торговый центр',
                pos = Vector(2546, -544, 144),
                icon = 'icon72/convenience_store.png',
                size = 16,
                order = 30,
            },
            {
                name = 'База ЧВК',
                pos = Vector(8901, -3062, 204),
                icon = 'icon72/camping.png',
                size = 16,
                order = 50,
            },
        }
    },
    ['rp_downtown_tits_2019'] = {
        zoom = {
            min = 0.5,
            max = 12,
        },
        rotate = false,
        markers = {
            {
                name = 'Мэрия',
                pos = Vector(-1759, 686, 76),
                icon = 'icon72/office.png',
                size = 16,
                order = 27,
            },
            {
                name = 'Полицейский участок',
                pos = Vector(-1454, 98, -95),
                icon = 'icon72/oncoming_police_car.png',
                size = 16,
                order = 28,
            },
        }
    },
    ['rp_rockford_open'] = {
        zoom = {
            min = 1.6,
            max = 11.2,
        },
        rotate = false,
        markers = {
            {
                name = 'Мэрия',
                pos = Vector(-4692, -5904, -13823),
                icon = 'icon72/office.png',
                size = 16,
                order = 27,
            },
            {
                name = 'Полицейский участок',
                pos = Vector(-7661, -5600, -13879),
                icon = 'icon72/oncoming_police_car.png',
                size = 16,
                order = 28,
            },
            {
                name = 'База ЧВК',
                pos = Vector(-6196, 7990, -13872),
                icon = 'icon72/camping.png',
                size = 16,
                order = 50,
            },
        }
    },
}

wayMap.entities = {
    ['bank_vault'] = {
        name = 'Банк',
        icon = 'icon72/bank.png',
        size = 16,
        order = 995,
    },
    ['itemstore_bank'] = {
        name = 'Хранилище',
        icon = 'icon72/package.png',
        size = 16,
        order = 996,
    },
    ['slot_fifty_fifty'] = {
        name = 'Казино',
        icon = 'icon72/slot_machine.png',
        size = 16,
        order = 997,
    },
    ['slot_roulette'] = {
        name = 'Казино',
        icon = 'icon72/slot_machine.png',
        size = 16,
        order = 997,
    },
    ['slot_slots'] = {
        name = 'Казино',
        icon = 'icon72/slot_machine.png',
        size = 16,
        order = 997,
    },
    ['zhits_phone'] = {
        name = 'Телефон',
        icon = 'icon72/iphone.png',
        size = 16,
        order = 997,
    },
    ['gmod_sent_vehicle_fphysics_gaspump'] = {
        name = 'Заправка',
        icon = 'icon72/fuelpump.png',
        size = 16,
        order = 998,
    },
    ['npc_cardealer'] = {
        name = 'Транспорт',
        icon = 'icon72/red_car.png',
        size = 16,
        order = 999,
    },
    ['box_ammo'] = {
        name = 'Боеприпасы',
        icon = 'icon72/firecracker.png',
        size = 16,
        order = 1000,
    },
    ['v_maverick'] = {
        name = 'Вертолет мэрии',
        icon = 'icon72/helicopter.png',
        size = 16,
        order = 1001,
    },
    ['v_polmav'] = {
        name = 'Полицейский вертолет',
        icon = 'icon72/helicopter.png',
        size = 16,
        order = 1002,
    },
    ['v_buzzard2'] = {
        name = 'Гражданский вертолет',
        icon = 'icon72/helicopter.png',
        size = 16,
        order = 1003,
    },
    ['npc_waydealer'] = {
        name = 'Скупщик',
        icon = 'icon72/shopping_cart.png',
        size = 16,
        order = 1004,
    },
    ['trash_dumpster'] = {
        name = 'Мусорка',
        icon = 'icon72/recycle.png',
        size = 16,
        order = 1005,
    },
}

wayMap.context = {
    {
        name = 'Создать маркер для себя',
        icon = 'icon72/pushpin.png',
        order = 10,
        callback = function(vec)
            dMarkers.create({
                title = 'Маркер',
                uid = 'wayMap.marker',
                color = Color(255, 255, 255),
                pos = vec,
                icon = 'icon72/triangular_flag_on_post.png',
            })
        end,
    },
    {
        name = 'Перезагрузить карту',
        icon = 'icon16/arrow_refresh.png',
        order = 100000,
        check = function()
            return false
        end,
        callback = function()
            RunConsoleCommand('waymap_reload')
        end,
    },
    {
        name = 'Добавить общ зону',
        icon = 'icon16/arrow_refresh.png',
        order = 100001,
        check = function()
            return false
        end,
        callback = function(vec)
            if not wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]] or wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]]['toX'] then
                wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()] + 1] = {
                    x = math.Round(vec.x, 0),
                    y = math.Round(vec.y, 0),
                    col = nil,
                    toX = nil,
                    toY = nil
                }
            else
                Derma_StringRequest('Укажи цвет зоны', 'Укажи цвет зоны', '255,0,0,60', function(text)
                    local temp = string.Split(text, ',')
                    wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]]['col'] = Color(temp[1], temp[2], temp[3], temp[4])
                    wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]]['toX'] = math.Round(vec.x, 0)
                    wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]]['toY'] = math.Round(vec.y, 0)
                end)
            end
        end,
    },
}

function wayMap.refreshEntMarkers()
    for class, v in pairs(wayMap.entities) do
        v.markers = v.markers or {}

        for _, marker in ipairs(v.markers) do
            if not IsValid(marker) then continue end
            marker:Remove()
        end

        for _, ent in ipairs(ents.FindByClass(class) or {}) do
            if FPP and IsValid(FPP.entGetOwner(ent)) then continue end

            local marker = wayMap.createMarker({
                name = v.name,
                icon = v.icon,
                size = v.size,
                order = v.order,
                target = ent,
                category = class,
            })

            table.insert(v.markers, marker)
        end
    end
end

function wayMap.open()
    if IsValid(wayMap.frame) then
        wayMap.refreshEntMarkers()
        wayMap.frame:Show()

        return
    end

    wayMap.frame = vgui.Create('DFrame')
    wayMap.frame:SetSize(ScrW() * 0.6, ScrH() * 0.8)
    wayMap.frame:SetTitle('Карта')
    wayMap.frame:Center()
    wayMap.frame:SetSizable(true)
    wayMap.frame:MakePopup()
    wayMap.frame:SetKeyboardInputEnabled(false)
    wayMap.frame:SetDeleteOnClose(false)

    wayMap.frame.OnClose = function()
        wayMap.close()
    end

    wayMap.map = vgui.Create('waymap', wayMap.frame)
    wayMap.map:Dock(FILL)
    wayMap.map:SetOrigin(LocalPlayer():GetPos())
    wayMap.markers = {}

    wayMap.createMarker({
        name = 'Ты',
        size = 16,
        icon = 'icon72/person_standing.png',
        target = LocalPlayer(),
        order = 0,
    })

    local settings = wayMap.config[game.GetMap()]

    if settings then
        wayMap.map:SetMinZ(settings.minZ or 1800)

        if settings.zoom then
            wayMap.map:SetMinZoom(settings.zoom.min)
            wayMap.map:SetMaxZoom(settings.zoom.max)
        end

        wayMap.map:SetRotate(settings.rotate or false)

        for _, v in ipairs(settings.markers) do
            wayMap.createMarker(v)
        end
    end

    wayMap.refreshEntMarkers()
    hook.Run('wayMap.builded')
    wayMap.onoroff = vgui.Create('DCheckBoxLabel', wayMap.frame)
    wayMap.onoroff:SetPos(wayMap.frame:GetWide() - 255, 5)
    wayMap.onoroff:SetText('Общественные места')
    wayMap.onoroff:SetValue(wayMap.DoDrawZones)

    function wayMap.onoroff:OnChange(val)
        wayMap.DoDrawZones = val
    end

    local tooltip = vgui.Create('DImageButton', wayMap.frame)
    tooltip:SetPos(wayMap.frame:GetWide() - 115, 5)
    tooltip:SetSize(16, 16)
    tooltip:SetIcon('icon16/information.png')
    tooltip:SetText('')
    tooltip:SetTooltip('Красное - общ.место\nРозовое - общ.место ( только крыша )')
end

function wayMap.close()
    if not IsValid(wayMap.frame) then return end
    wayMap.frame:Hide()
end

function wayMap.createMarker(d)
    if not IsValid(wayMap.map) then
        wayMap.open()
        wayMap.close()
    end

    local marker = vgui.Create('waymap_marker', wayMap.map)
    marker:SetName(d.name)
    marker:SetSize(d.size, d.size)
    marker:SetOrigin(d.pos)
    marker:SetCategory(d.category)
    marker:SetTarget(d.target)
    marker:SetThink(d.think)
    marker:SetOrder(d.order)

    if d.icon then
        marker:SetIcon(d.icon)
        marker:SetMaterial(Material(d.icon))
    end

    marker:SetTooltip(d.name)

    marker.DoClick = function(self)
        wayMap.map:SelectCategory(self:GetCategory() or table.KeyFromValue(wayMap.markers, self))
        wayMap.map:SetOrigin(self:GetOrigin())
    end

    table.insert(wayMap.markers, marker)
    wayMap.map:RebuildSidebar()

    return marker
end

hook.Add('dMarkers.created', 'wayMap.marker', function(id, d)
    local marker = wayMap.createMarker({
        name = d.title,
        size = 16,
        icon = d.icon,
        pos = d.pos,
        target = d.target,
        category = d.type,
        order = 5000,
    })

    dMarkers.markers[id].mapMarker = marker
end)

hook.Add('dMarkers.removed', 'wayMap.removeMarker', function(id)
    local marker = dMarkers.markers[id]
    if not IsValid(marker.mapMarker) then return end
    marker.mapMarker:Remove()
end)

concommand.Add('waymap_reload', function()
    if IsValid(wayMap.frame) then
        wayMap.frame:Remove()
    end

    wayMap.open()
end)
--addons/module_wmap/lua/waymap/cl_waymap.lua:
wayMap.markers = {}

wayMap.config = {
    ['rp_bangclaw'] = {
        zoom = {
            min = 0.5,
            max = 50,
        },
        minZ = 1800,
        rotate = true,
        markers = {
            {
                name = 'Мэрия',
                pos = Vector(1121, 2376, 208),
                icon = 'icon72/office.png',
                size = 16,
                order = 10,
            },
            {
                name = 'Полицейский участок',
                pos = Vector(4187, -767, 136),
                icon = 'icon72/oncoming_police_car.png',
                size = 16,
                order = 20,
            },
            {
                name = 'Торговый центр',
                pos = Vector(2546, -544, 144),
                icon = 'icon72/convenience_store.png',
                size = 16,
                order = 30,
            },
            {
                name = 'База ЧВК',
                pos = Vector(8901, -3062, 204),
                icon = 'icon72/camping.png',
                size = 16,
                order = 50,
            },
        }
    },
    ['rp_downtown_tits_2019'] = {
        zoom = {
            min = 0.5,
            max = 12,
        },
        rotate = false,
        markers = {
            {
                name = 'Мэрия',
                pos = Vector(-1759, 686, 76),
                icon = 'icon72/office.png',
                size = 16,
                order = 27,
            },
            {
                name = 'Полицейский участок',
                pos = Vector(-1454, 98, -95),
                icon = 'icon72/oncoming_police_car.png',
                size = 16,
                order = 28,
            },
        }
    },
    ['rp_rockford_open'] = {
        zoom = {
            min = 1.6,
            max = 11.2,
        },
        rotate = false,
        markers = {
            {
                name = 'Мэрия',
                pos = Vector(-4692, -5904, -13823),
                icon = 'icon72/office.png',
                size = 16,
                order = 27,
            },
            {
                name = 'Полицейский участок',
                pos = Vector(-7661, -5600, -13879),
                icon = 'icon72/oncoming_police_car.png',
                size = 16,
                order = 28,
            },
            {
                name = 'База ЧВК',
                pos = Vector(-6196, 7990, -13872),
                icon = 'icon72/camping.png',
                size = 16,
                order = 50,
            },
        }
    },
}

wayMap.entities = {
    ['bank_vault'] = {
        name = 'Банк',
        icon = 'icon72/bank.png',
        size = 16,
        order = 995,
    },
    ['itemstore_bank'] = {
        name = 'Хранилище',
        icon = 'icon72/package.png',
        size = 16,
        order = 996,
    },
    ['slot_fifty_fifty'] = {
        name = 'Казино',
        icon = 'icon72/slot_machine.png',
        size = 16,
        order = 997,
    },
    ['slot_roulette'] = {
        name = 'Казино',
        icon = 'icon72/slot_machine.png',
        size = 16,
        order = 997,
    },
    ['slot_slots'] = {
        name = 'Казино',
        icon = 'icon72/slot_machine.png',
        size = 16,
        order = 997,
    },
    ['zhits_phone'] = {
        name = 'Телефон',
        icon = 'icon72/iphone.png',
        size = 16,
        order = 997,
    },
    ['gmod_sent_vehicle_fphysics_gaspump'] = {
        name = 'Заправка',
        icon = 'icon72/fuelpump.png',
        size = 16,
        order = 998,
    },
    ['npc_cardealer'] = {
        name = 'Транспорт',
        icon = 'icon72/red_car.png',
        size = 16,
        order = 999,
    },
    ['box_ammo'] = {
        name = 'Боеприпасы',
        icon = 'icon72/firecracker.png',
        size = 16,
        order = 1000,
    },
    ['v_maverick'] = {
        name = 'Вертолет мэрии',
        icon = 'icon72/helicopter.png',
        size = 16,
        order = 1001,
    },
    ['v_polmav'] = {
        name = 'Полицейский вертолет',
        icon = 'icon72/helicopter.png',
        size = 16,
        order = 1002,
    },
    ['v_buzzard2'] = {
        name = 'Гражданский вертолет',
        icon = 'icon72/helicopter.png',
        size = 16,
        order = 1003,
    },
    ['npc_waydealer'] = {
        name = 'Скупщик',
        icon = 'icon72/shopping_cart.png',
        size = 16,
        order = 1004,
    },
    ['trash_dumpster'] = {
        name = 'Мусорка',
        icon = 'icon72/recycle.png',
        size = 16,
        order = 1005,
    },
}

wayMap.context = {
    {
        name = 'Создать маркер для себя',
        icon = 'icon72/pushpin.png',
        order = 10,
        callback = function(vec)
            dMarkers.create({
                title = 'Маркер',
                uid = 'wayMap.marker',
                color = Color(255, 255, 255),
                pos = vec,
                icon = 'icon72/triangular_flag_on_post.png',
            })
        end,
    },
    {
        name = 'Перезагрузить карту',
        icon = 'icon16/arrow_refresh.png',
        order = 100000,
        check = function()
            return false
        end,
        callback = function()
            RunConsoleCommand('waymap_reload')
        end,
    },
    {
        name = 'Добавить общ зону',
        icon = 'icon16/arrow_refresh.png',
        order = 100001,
        check = function()
            return false
        end,
        callback = function(vec)
            if not wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]] or wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]]['toX'] then
                wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()] + 1] = {
                    x = math.Round(vec.x, 0),
                    y = math.Round(vec.y, 0),
                    col = nil,
                    toX = nil,
                    toY = nil
                }
            else
                Derma_StringRequest('Укажи цвет зоны', 'Укажи цвет зоны', '255,0,0,60', function(text)
                    local temp = string.Split(text, ',')
                    wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]]['col'] = Color(temp[1], temp[2], temp[3], temp[4])
                    wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]]['toX'] = math.Round(vec.x, 0)
                    wayMap.Zones[game.GetMap()][#wayMap.Zones[game.GetMap()]]['toY'] = math.Round(vec.y, 0)
                end)
            end
        end,
    },
}

function wayMap.refreshEntMarkers()
    for class, v in pairs(wayMap.entities) do
        v.markers = v.markers or {}

        for _, marker in ipairs(v.markers) do
            if not IsValid(marker) then continue end
            marker:Remove()
        end

        for _, ent in ipairs(ents.FindByClass(class) or {}) do
            if FPP and IsValid(FPP.entGetOwner(ent)) then continue end

            local marker = wayMap.createMarker({
                name = v.name,
                icon = v.icon,
                size = v.size,
                order = v.order,
                target = ent,
                category = class,
            })

            table.insert(v.markers, marker)
        end
    end
end

function wayMap.open()
    if IsValid(wayMap.frame) then
        wayMap.refreshEntMarkers()
        wayMap.frame:Show()

        return
    end

    wayMap.frame = vgui.Create('DFrame')
    wayMap.frame:SetSize(ScrW() * 0.6, ScrH() * 0.8)
    wayMap.frame:SetTitle('Карта')
    wayMap.frame:Center()
    wayMap.frame:SetSizable(true)
    wayMap.frame:MakePopup()
    wayMap.frame:SetKeyboardInputEnabled(false)
    wayMap.frame:SetDeleteOnClose(false)

    wayMap.frame.OnClose = function()
        wayMap.close()
    end

    wayMap.map = vgui.Create('waymap', wayMap.frame)
    wayMap.map:Dock(FILL)
    wayMap.map:SetOrigin(LocalPlayer():GetPos())
    wayMap.markers = {}

    wayMap.createMarker({
        name = 'Ты',
        size = 16,
        icon = 'icon72/person_standing.png',
        target = LocalPlayer(),
        order = 0,
    })

    local settings = wayMap.config[game.GetMap()]

    if settings then
        wayMap.map:SetMinZ(settings.minZ or 1800)

        if settings.zoom then
            wayMap.map:SetMinZoom(settings.zoom.min)
            wayMap.map:SetMaxZoom(settings.zoom.max)
        end

        wayMap.map:SetRotate(settings.rotate or false)

        for _, v in ipairs(settings.markers) do
            wayMap.createMarker(v)
        end
    end

    wayMap.refreshEntMarkers()
    hook.Run('wayMap.builded')
    wayMap.onoroff = vgui.Create('DCheckBoxLabel', wayMap.frame)
    wayMap.onoroff:SetPos(wayMap.frame:GetWide() - 255, 5)
    wayMap.onoroff:SetText('Общественные места')
    wayMap.onoroff:SetValue(wayMap.DoDrawZones)

    function wayMap.onoroff:OnChange(val)
        wayMap.DoDrawZones = val
    end

    local tooltip = vgui.Create('DImageButton', wayMap.frame)
    tooltip:SetPos(wayMap.frame:GetWide() - 115, 5)
    tooltip:SetSize(16, 16)
    tooltip:SetIcon('icon16/information.png')
    tooltip:SetText('')
    tooltip:SetTooltip('Красное - общ.место\nРозовое - общ.место ( только крыша )')
end

function wayMap.close()
    if not IsValid(wayMap.frame) then return end
    wayMap.frame:Hide()
end

function wayMap.createMarker(d)
    if not IsValid(wayMap.map) then
        wayMap.open()
        wayMap.close()
    end

    local marker = vgui.Create('waymap_marker', wayMap.map)
    marker:SetName(d.name)
    marker:SetSize(d.size, d.size)
    marker:SetOrigin(d.pos)
    marker:SetCategory(d.category)
    marker:SetTarget(d.target)
    marker:SetThink(d.think)
    marker:SetOrder(d.order)

    if d.icon then
        marker:SetIcon(d.icon)
        marker:SetMaterial(Material(d.icon))
    end

    marker:SetTooltip(d.name)

    marker.DoClick = function(self)
        wayMap.map:SelectCategory(self:GetCategory() or table.KeyFromValue(wayMap.markers, self))
        wayMap.map:SetOrigin(self:GetOrigin())
    end

    table.insert(wayMap.markers, marker)
    wayMap.map:RebuildSidebar()

    return marker
end

hook.Add('dMarkers.created', 'wayMap.marker', function(id, d)
    local marker = wayMap.createMarker({
        name = d.title,
        size = 16,
        icon = d.icon,
        pos = d.pos,
        target = d.target,
        category = d.type,
        order = 5000,
    })

    dMarkers.markers[id].mapMarker = marker
end)

hook.Add('dMarkers.removed', 'wayMap.removeMarker', function(id)
    local marker = dMarkers.markers[id]
    if not IsValid(marker.mapMarker) then return end
    marker.mapMarker:Remove()
end)

concommand.Add('waymap_reload', function()
    if IsValid(wayMap.frame) then
        wayMap.frame:Remove()
    end

    wayMap.open()
end)
--addons/module_battlepass/lua/waypass/challenges/arrest.lua:
waypass.challenges.Create('arrest')
    :SetName('На страже порядка')
    :SetDesc('Арестуй {goal} игроков')
    :AddHook('playerArrested', function(self, owner, criminal, time, ply)
        if ply ~= owner then return end
        if criminal:isArrested() then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/arrestbank.lua:
waypass.challenges.Create('arrestbank')
    :SetName('Обезьяны в загоне')
    :SetDesc('Убей/Арестуй {goal} раз грабителя банка')
    :AddHook('OnPlayerRobberyArrest', function(self, owner, police, robber)
        if owner ~= police then return end
        self:AddProgress(1)
    end)
    :AddHook('OnPlayerRobberyKill', function(self, owner, police, robber)
        if owner ~= police then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/clickers.lua:
waypass.challenges.Create('clickers')
    :SetName('Печатная машинка')
    :SetDesc('Заработай на кликерах {goal}')
    :AddHook('MoneyClickerWithdraw', function(self, owner, ply, money)
        if ply ~= owner then return end
        self:AddProgress(money)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/explodebomb.lua:
waypass.challenges.Create('explodebomb')
    :SetName('Подрыватель')
    :SetDesc('Успешно взорви бомбу {goal} раз')
    :AddHook('BombExplode', function(self, owner, terror, bomb)
        if not IsValid(terror) then return end
        if terror ~= owner then return end
        
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/meth.lua:
waypass.challenges.Create('meth')
    :SetName('Во все тяжкие')
    :SetDesc('Продай {goal} грамм метамфетамина')
    :AddHook('WayDealerSell', function(self, owner, ply, class, amount, profit)
        if ply ~= owner then return end
        if class ~= "eml_meth" then return end
        self:AddProgress(amount)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/promo.lua:
waypass.challenges.Create('promo')
    :SetName('Дитя промокода')
    :SetDesc('Активируй любой промокод {goal} раз')
    :AddHook('PlayerGivePromo', function(self, owner, ply)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/stealmoney.lua:
waypass.challenges.Create('stealmoney')
    :SetName('Дырявые карманы')
    :SetDesc('Обворуй {goal} игроков')
    :AddHook('PlayerStealMoney', function(self, owner, ply, money, victim)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/rewards/points.lua:
local REWARD = {}
REWARD.Name = 'Рубли'
REWARD.Material = 'data/wimages/gem.png'
http.DownloadMaterial('http://wayzerroleplay.myarena.ru/wimages/gem.png', 'gem.png')

AccessorFunc(REWARD, 'Name', 'Name')
AccessorFunc(REWARD, 'Material', 'Material')

function REWARD:Give(ply, amount)
    ply:PS_GivePoints(amount)
end

function REWARD:GetCount(amount)
    return amount..PS.Config.PointsName
end

function REWARD:Preview(amount, mpanel)
    if IsValid(mpanel.previewpanel) then mpanel.previewpanel:Remove() end
    
    mpanel:SetShouldDrawModels(false)
    local mat = Material(self:GetMaterial(amount))

    local scaleW, scaleH = ScrW()/1920, ScrH()/1080
    local pos = mpanel:GetCamPos()+Vector(-6*scaleW, -15*scaleW, 3.5*scaleH)

    mpanel.PreDrawModel = function(ent)
        --cam.Start3D2D(Vector(23*scale,15*scale,43+math.sin(CurTime())/2), Angle(180,-80,-90), .01)
        --cam.Start3D2D(Vector(24*scale,15*scale,43+math.sin(CurTime())/2), Angle(180,-70,-90), .01)
        cam.Start3D2D(Vector(pos.x, pos.y, pos.z+math.sin(CurTime())/3), Angle(180,-70,-90), 0.01)
            surface.SetDrawColor(color_white)
            surface.SetMaterial(mat)
            surface.DrawTexturedRect(0,0,550,530)
        cam.End3D2D()

        return false
    end
end

function REWARD:UnPreview(amount, mpanel)
    mpanel:SetShouldDrawModels(true)
    mpanel.PreDrawModel = wlib.func.blank
end

waypass.RegisterReward('points', REWARD)
--addons/module_battlepass/lua/waypass/vgui/challenge.lua:
local font_name = 'dorgs.24'
local font_desc = 'DermaDefault'
local color_footer = Color(47,49,54)
local color_footer_reward = Color(37,39,44)
local color_footer_progress = Color(100,100,100)
local mat_completed = Material('icon72/white_check_mark.png')
local min_height = 100

local PANEL = {}

function PANEL:Init()
    self.progress = 0
    self:DockPadding(6,6,6,6)

    self.name = vgui.Create('DLabel', self)
    self.name:SetFont(font_name)
    self.name:Dock(TOP)
    self.name:SetAutoStretchVertical(true)

    self.desc = vgui.Create('DLabel', self)
    self.desc:SetFont(font_desc)
    self.desc:Dock(TOP)
    self.desc:DockMargin(0,4,0,0)
    --self.desc:SetColor(Color(230,230,230))
end

AccessorFunc(PANEL, 'challenge', 'Challenge')
AccessorFunc(PANEL, 'progress', 'Progress')
AccessorFunc(PANEL, 'completed', 'Completed')

function PANEL:SetChallenge(c)
    self.challenge = c

    self.name:SetText(c:GetName())
    local desc = waypass.Format(c:GetDesc(), {
        goal = c:GetGoal(),
    })
    self.desc:SetText(desc)
    if self:GetProgress() == c:GetGoal() then
        self:SetCompleted(true)
    end
    
    self:InvalidateLayout()
end

function PANEL:Paint(w, h)
    --surface.DisableClipping(true)
        draw.RoundedBox(4, -2, -2, w+4, h+4, waypass.skin.COLOR_OUTLINE)
    --surface.DisableClipping(false)

    draw.RoundedBox(0, 0, 0, w, h, waypass.skin.COLOR_SECONDARY)

    if not self.challenge then return end

    surface.SetTextColor(color_white)
    
    local rtext = self.challenge:GetReward()..' xp'
    local ptext = self:GetProgress()..'/'..self.challenge:GetGoal()
    local completed = self:GetProgress() == self.challenge:GetGoal()

    surface.SetFont(font_name)
    local rw, rh = surface.GetTextSize(rtext)

    -- footer height
    local fh = rh+8

    -- footer
    surface.SetDrawColor(color_footer)
    surface.DrawRect(0, h-fh, w, fh)

    -- footer reward bg
    surface.SetDrawColor(color_footer_reward)
    surface.DrawRect(completed and w-fh or w-rw-8, h-fh, completed and fh or rw+8, fh)

    -- reward text
    if completed then
        surface.SetDrawColor(color_white)
        surface.SetMaterial(mat_completed)
        surface.DrawTexturedRect(w-rh-4, h-fh+4, rh, rh)
    else
        surface.SetTextPos(w-rw-4, h-fh+4)
        surface.DrawText(rtext)
    end

    surface.SetFont(font_desc)
    local pw, ph = surface.GetTextSize(ptext)

    -- progress bar
    local pbarw, pbarh = completed and w-fh-12 or w-rw-8-12, ph+4
    local pbary = (h-fh)+(fh-pbarh)/2
    surface.SetDrawColor(color_footer_progress)
    surface.DrawRect(6, pbary, pbarw, pbarh)
    surface.SetDrawColor(waypass.skin.COLOR_PRIMARY)
    surface.DrawRect(6, pbary, pbarw*(self:GetProgress()/self.challenge:GetGoal()), pbarh)

    -- progress text
    surface.SetTextPos(6+pbarw/2-pw/2, h-fh/2-ph/2)
    surface.DrawText(ptext)
end

function PANEL:PerformLayout(w,h)
    self:SizeToContents()
end

function PANEL:SizeToContents(w)
    local c = self:GetChallenge()
    if not c then return end

    local desc = waypass.Format(c:GetDesc(), {
        goal = c:GetGoal(),
    })
    self.desc:SetText(DarkRP.textWrap(desc, font_desc, self.desc:GetWide()))
    self.desc:SizeToContents()

    local rtext = self.challenge:GetReward()..' xp'

    surface.SetFont(font_name)
    local rw, rh = surface.GetTextSize(rtext)

    -- footer height
    local fh = rh+8
    
    local tall = 6 + self.name:GetTall() + 4 + self.desc:GetTall() + 6 + fh
    self:SetTall(math.max(min_height, tall))
end

vgui.Register('waypass_challenge', PANEL, 'DPanel')
--addons/module_battlepass/lua/waypass/vgui/level.lua:
local header_height = 20
local triangle_width = 10
local font = 'dorgs.18'

local PANEL = {}

function PANEL:Init()
    self.lvl = 0

    self.container = vgui.Create('DPanel', self)
    self.container:Dock(BOTTOM)
    self.container:SetPaintBackground(false)

    self.free = vgui.Create('waypass_reward', self.container)

    self.premium = vgui.Create('waypass_reward', self.container)
    self.premium:SetPremium(true)
end

AccessorFunc(PANEL, 'lvl', 'Level')
AccessorFunc(PANEL, 'reached', 'Reached')
AccessorFunc(PANEL, 'free', 'Free')
AccessorFunc(PANEL, 'premium', 'Premium')
AccessorFunc(PANEL, 'bpId', 'BPID')
function PANEL:GetBP()
    return waypass.GetBP(self:GetBPID())
end
function PANEL:SetBPID(id)
    self.bpId = id
    self.free:SetBPID(id)
    self.premium:SetBPID(id)
end

function PANEL:PerformLayout(w, h)
    local con_h = h-header_height-8
    self.container:SetTall(con_h)

    self.free:SetSize(con_h, con_h)
    self.free:SetPos(0, 0)

    self.premium:SetSize(con_h, con_h)
    self.premium:SetPos(w-con_h, 0)
end

function PANEL:Paint(w, h)
    surface.SetDrawColor(self.reached and waypass.skin.COLOR_PRIMARY or waypass.skin.COLOR_SECONDARY)
    --surface.DrawRect(0,0,w,header_height)
    draw.NoTexture()
    surface.DrawPoly({
        {x = w-triangle_width, y = 0},
        {x = w, y = 0},
        {x = w-triangle_width, y = header_height},
        {x = 0, y = header_height},
        {x = 0, y = 0},
    })
    
    draw.SimpleText('Уровень '..self:GetLevel(), font, 8, header_height/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

vgui.Register('waypass_level', PANEL, 'DPanel')
--addons/module_battlepass/lua/waypass/vgui/multipanel.lua:
local PANEL = {}

function PANEL:Init()
    self.panels = {}
    self.active = nil
end

function PANEL:Clear()
    for _, v in ipairs(self.panels) do
        v:Remove()
    end
    self.panels = {}
end

function PANEL:AddPanel(panel, id, selected)
    panel:SetSize(self:GetSize())
    panel:SetVisible(false)
    panel:SetParent(self)

    panel.ID = table.insert(self.panels, panel)
    panel.ID = id or panel.ID

    if selected then self:SelectPanel(panel.ID) end

    return panel.ID
end

function PANEL:SelectPanel(id, ...)
    for _, panel in ipairs(self.panels) do
        panel.Active = panel.ID == id

        panel:SetVisible(false)
        panel:Dock(NODOCK)

        if panel.ID == id then
            self.active = panel
            panel:SetVisible(true)
            panel:Dock(FILL)

            if panel.OnOpen then panel:OnOpen(...) end
        end
    end
end

function PANEL:GetActivePanel()
	return self.active
end

function PANEL:GetActiveID()
    return self.active and self.active.ID
end

vgui.Register('waypass_multipanel', PANEL, 'DPanel')
--addons/module_media/lua/wayradio/medialib.min.lua:
local blank = wlib.func.blank local a;do local b="git@871fb36d"local c=true;a={}a.VERSION=b;a.DISTRIBUTABLE=c;a.INSTANCE=a.VERSION.."_"..tostring(10000+math.random(90000))a.Modules={}local d=CreateConVar("medialib_debug","0",FCVAR_ARCHIVE)cvars.AddChangeCallback(d:GetName(),function(e,e,f)a.DEBUG=f=="1"end)a.DEBUG=d:GetBool()function a.modulePlaceholder(g)a.Modules[g]={}end;function a.module(g,h)if a.DEBUG then print("[MediaLib] Creating module "..g)end;local i=a.Modules[g]or{name=g,options=h}a.Modules[g]=i;return i end;if SERVER then for e,j in pairs(file.Find("medialib/*","LUA"))do AddCSLuaFile("medialib/"..j)end end;local k=file.Exists;function a.tryInclude(file)if k(file,"LUA")then include(file)return true end;if a.DEBUG then print("[MediaLib] Attempted to include nonexistent file "..file)end;return false end;function a.load(g)local i=a.Modules[g]if i then return i end;if a.DEBUG then print("[MediaLib] Loading unreferenced module "..g)end;local file="medialib/"..g..".lua"if not a.tryInclude(file)then return nil end;return a.Modules[g]end;local l=setmetatable({medialib=a},{__index=_G})local m={read=function(self)return file.Read(self.lua_path,"LUA")end,load=function(self)return include(self.lua_path)end,addcs=function(self)AddCSLuaFile(self.lua_path)end}m.__index=m;local n={read=function(self)return self.source end,load=function(self)local o=CompileString(self:read(),"MediaLib_DynFile_"..self.name)setfenv(o,l)return o()end,addcs=blank}n.__index=n;a.FolderItems={}function a.folderIterator(p)local q={}for e,j in pairs(file.Find("medialib/"..p.."/*.lua","LUA"))do table.insert(q,setmetatable({name=j,lua_path="medialib/"..p.."/"..j},m))end;for r,s in pairs(a.FolderItems)do local t=r:match("^([^/]*).+")if t==p then table.insert(q,setmetatable({name=r:match("^[^/]*/(.+)"),source=s},n))end end;return pairs(q)end;if CLIENT then local function u()for v=1,30 do MsgC(HSVToColor(30*v,0.5,0.9)," "..string.rep("SEE BELOW FOR INSTRUCTIONS  ",3).."\n")end end;concommand.Add("medialib_noflash",function(e,e,w)if w[1]=="rainbow"then u()end;SetClipboardText("http://get.adobe.com/flashplayer/otherversions/")MsgN("[ MediaLib: How to get Flash Player ]")MsgN("1. Open this website in your browser (not the ingame Steam browser): ".."http://get.adobe.com/flashplayer/otherversions/")MsgN("   (the link has been automatically copied to your clipboard)")MsgN("2. Download and install the NSAPI (for Firefox) version")MsgN("3. Restart your Garry's Mod and rejoin this server")MsgN("[ ======================= ]")end)concommand.Add("medialib_lowaudio",function(e,e,w)if w[1]=="rainbow"then u()end;SetClipboardText("http://windows.microsoft.com/en-us/windows7/adjust-the-sound-level-on-your-computer")MsgN("[ MediaLib: How to fix muted sound ]")MsgN("1. Follow instructions here: ".."http://windows.microsoft.com/en-us/windows7/adjust-the-sound-level-on-your-computer")MsgN("   (the link has been automatically copied to your clipboard, you can open it in the steam ingame browser)")MsgN("2. Increase the volume of a process called 'Awesomium Core'")MsgN("3. You should immediately start hearing sound if a mediaclip is playing")MsgN("[ ======================= ]")end)hook.Add("OnPlayerChat","MediaLib.ShowInstructions",function(e,x)if x:match("!ml_noflash")then RunConsoleCommand("medialib_noflash","rainbow")RunConsoleCommand("showconsole")elseif x:match("!ml_lowvolume")then RunConsoleCommand("medialib_lowaudio","rainbow")RunConsoleCommand("showconsole")end end)end end;a.modulePlaceholder("oop")do local b=a.module("oop")b.Classes=b.Classes or{}function b.class(c,d)local e=b.Classes[c]if not e then e=b.createClass(c,d)b.Classes[c]=e;if a.DEBUG then print("[MediaLib] Registering oopclass "..c)end end;return e end;function b.resolveClass(f)if f==nil then return b.Object end;local g=type(f)if g=="string"then local h=b.Classes[f]if h then return h end;error("Resolving class from inexistent class string '"..tostring(f).."'")end;if g=="table"then return f end;error("Resolving class from invalid object '"..tostring(f).."'")end;local i={}local j={'__add','__call','__concat','__div','__ipairs','__le','__len','__lt','__mod','__mul','__pairs','__pow','__sub','__tostring','__unm'}function b.createClass(c,d)local e={}local k;if d~=i then k=b.resolveClass(d)end;e.name=c;e.super=k;e.members=setmetatable({},{__index=e.super})e.members.class=e;e.members.super=e.super;local l={}do l.__index=e.members;for m,n in pairs(j)do l[n]=function(...)local o=e.members[n]if o then return o(...)end end end end;local p={}do p.__index=e.members;p.__newindex=e.members;p.__tostring=function(self)return"class "..self.name end;function p:__call(...)local q={}setmetatable(q,l)local r=q.initialize;if r then r(q,...)end;return q end end;setmetatable(e,p)return e end;b.Object=b.createClass("Object",i)function b.Object:hashCode()local s=getmetatable(self)local t=s.__tostring;s.__tostring=nil;local u=tostring(self):match("table: 0x(.*)")s.__tostring=t;return u end;function b.Object:__tostring()return string.format("%s@%s",self.class.name,self:hashCode())end end;a.modulePlaceholder("mediabase")do local b=a.load("oop")local c=b.class("Media")function c:on(d,e)self._events=self._events or{}self._events[d]=self._events[d]or{}self._events[d][e]=true end;function c:emit(d,...)if not self._events then return end;local f=self._events[d]if not f then return end;for g,h in pairs(f)do g(...)end end;function c:getServiceBase()error("Media:getServiceBase() not implemented!")end;function c:getService()return self._service end;function c:getUrl()return self._unresolvedUrl end;function c:lookupMetadata()local i=self._metadata;if type(i)=="table"then return i end;if i==true or type(i)=="string"then return nil end;self._metadata=true;self:getService():query(self:getUrl(),function(j,k)if j then self._metadata=j else self._metadata=k end end)return nil end;function c:isValid()return false end;function c:IsValid()return self:isValid()end;function c:setVolume(l)end;function c:getVolume()end;function c:setQuality(m)end;function c:seek(n)end;function c:getTime()return 0 end;function c:sync(o,p)if self._lastSync and self._lastSync>CurTime()-5 then return end;local q=self:shouldSync(o,p)if not q then return end;self:seek(o+0.1)self._lastSync=CurTime()end;function c:shouldSync(o,p)if not self:isValid()or not self:isPlaying()then return false end;p=p or 2;local r=self:getTime()local s=math.abs(r-o)return s>p end;function c:getState()end;function c:isPlaying()return self:getState()=="playing"end;function c:play()end;function c:pause()end;function c:stop()end;function c:runCommand(t)end;function c:draw(u,v,w,x)end;function c:getTag()return self._tag end;function c:setTag(y)self._tag=y end;function c:guessDefaultTag()for z=1,10 do local A=debug.getinfo(z,"S")if not A then break end;local B=A.short_src;local C=B:match("addons/(.-)/")if C and C~="medialib"then return string.format("addon:%s",C)end end;return"addon:medialib"end;function c:setDefaultTag()self:setTag(self:guessDefaultTag())end;function c:getDebugInfo()return string.format("[%s] Media [%s] valid:%s state:%s url:%s time:%d",self:getTag(),self.class.name,tostring(self:isValid()),self:getState(),self:getUrl(),self:getTime())end end;a.modulePlaceholder("media")do local b=a.module("media")b.Services={}function b.registerService(c,d)b.Services[c]=d()end;b.RegisterService=b.registerService;function b.service(c)return b.Services[c]end;b.Service=b.service;function b.guessService(e,f)for c,g in pairs(b.Services)do local h=true;if f and f.whitelist then h=h and table.HasValue(f.whitelist,c)end;if f and f.blacklist then h=h and not table.HasValue(f.blacklist,c)end;if h and g:isValidUrl(e)then return g end end end;b.GuessService=b.guessService end;a.modulePlaceholder("mediaregistry")do local b=a.module("mediaregistry")local c=setmetatable({},{__mode="v"})function b.add(d)table.insert(c,d)end;function b.get()return c end;concommand.Add("medialib_listall",function()hook.Run("MediaLib_ListAll")end)hook.Add("MediaLib_ListAll","MediaLib_"..a.INSTANCE,function()print("Media for medialib version "..a.INSTANCE..":")for e,f in pairs(c)do print(f:getDebugInfo())end end)concommand.Add("medialib_stopall",function()hook.Run("MediaLib_StopAll")end)hook.Add("MediaLib_StopAll","MediaLib_"..a.INSTANCE,function()for e,f in pairs(c)do f:stop()end;table.Empty(c)end)local g=CreateConVar("medialib_debugmedia","0")hook.Add("HUDPaint","MediaLib_G_DebugMedia",function()if not g:GetBool()then return end;local h={0}hook.Run("MediaLib_DebugPaint",h)end)hook.Add("MediaLib_DebugPaint","MediaLib_"..a.INSTANCE,function(h)local i=h[1]for e,d in pairs(c)do local j=string.format("#%d %s",i,d:getDebugInfo())draw.SimpleText(j,"DermaDefault",10,10+i*15)i=i+1 end;h[1]=i end)end;a.modulePlaceholder("servicebase")do local b=a.load("oop")local c=a.load("mediaregistry")local d=b.class("Service")function d:on(e,f)self._events={}self._events[e]=self._events[e]or{}self._events[e][f]=true end;function d:emit(e,...)for g,h in pairs(self._events[e]or{})do g(...)end;if e=="error"then MsgN("[MediaLib] Video error: "..table.ToString{...})end end;function d:load()end;function d:loadMediaObject(i,j,k)i._unresolvedUrl=j;i._service=self;i:setDefaultTag()hook.Run("Medialib_ProcessOpts",i,k or{})c.add(i)self:resolveUrl(j,function(l,m)i:openUrl(l)if m and m.start and(not k or not k.dontSeek)then i:seek(m.start)end end)end;function d:isValidUrl()end;function d:directQuery()end;local n={}n.__index=n;function n:addCallback(o)table.insert(self._callbacks,o)end;function n:run(p,q)local r=table.remove(self._callbacks,1)if not r then return end;r(p,q,function(s,t)self:run(s,t)end)end;function d:query(j,f)local u=setmetatable({_callbacks={}},n)u:addCallback(function(h,h,o)return self:directQuery(j,o)end)hook.Run("Medialib_ExtendQuery",j,u)u:addCallback(function(p,q)f(p,q)end)u:run(j)end;function d:parseUrl()end;function d:resolveUrl(j,o)o(j,self:parseUrl(j))end end;a.modulePlaceholder("timekeeper")do local b=a.load("oop")local c=b.class("TimeKeeper")function c:initialize()self:reset()end;function c:reset()self.cachedTime=0;self.running=false;self.runningTimeStart=0 end;function c:getTime()local d=self.cachedTime;if self.running then d=d+RealTime()-self.runningTimeStart end;return d end;function c:isRunning()return self.running end;function c:play()if self.running then return end;self.runningTimeStart=RealTime()self.running=true end;function c:pause()if not self.running then return end;local e=RealTime()-self.runningTimeStart;self.cachedTime=self.cachedTime+e;self.running=false end;function c:seek(d)self.cachedTime=d;if self.running then self.runningTimeStart=RealTime()end end end;a.modulePlaceholder("service_html")do local b=a.load("oop")a.load("timekeeper")local c=b.class("HTMLService","Service")function c:load(d,e)local f=b.class("HTMLMedia")()self:loadMediaObject(f,d,e)return f end;function c:hasReliablePlaybackEvents(g)return false end;local h={instances={}}local function i()return a.MAX_HTMLPOOL_INSTANCES or 0 end;hook.Add("MediaLib_HTMLPoolInfo",a.INSTANCE,function()print(a.INSTANCE.."> Free HTMLPool instance count: "..#h.instances.."/"..i())end)concommand.Add("medialib_htmlpoolinfo",function()hook.Run("MediaLib_HTMLPoolInfo")end)timer.Create("MediaLib."..a.INSTANCE..".HTMLPoolCleaner",60,0,function()if#h.instances==0 then return end;local j=table.remove(h.instances,1)if IsValid(j)then j:Remove()end end)function h.newInstance()return vgui.Create("DHTML")end;function h.get()if#h.instances==0 then if a.DEBUG then MsgN("[MediaLib] Returning new instance; htmlpool empty")end;return h.newInstance()end;local j=table.remove(h.instances,1)if not IsValid(j)then if a.DEBUG then MsgN("[MediaLib] Returning new instance; instance was invalid")end;return h.newInstance()end;if a.DEBUG then MsgN("[MediaLib] Returning an instance from the HTML pool")end;return j end;function h.free(j)if not IsValid(j)then return end;if#h.instances>=i()then if a.DEBUG then MsgN("[MediaLib] HTMLPool full; removing the freed instance")end;j:Remove()else if a.DEBUG then MsgN("[MediaLib] Freeing an instance to the HTMLPool")end;j:SetHTML("")table.insert(h.instances,j)end end;local k=CreateConVar("medialib_showallmessages","0")local l=b.class("HTMLMedia","Media")local m,n=1280,720;function l:initialize()self.timeKeeper=b.class("TimeKeeper")()self.panel=h.get()local o=self.panel;o:SetPos(0,0)o:SetSize(m,n)local p="MediaLib.HTMLMedia.FakeThink-"..self:hashCode()hook.Add("Think",p,function()if not IsValid(self.panel)then hook.Remove("Think",p)return end;self.panel:Think()end)local q=o._OldCM or o.ConsoleMessage;o._OldCM=q;o.ConsoleMessage=function(r,s)if s and not k:GetBool()then if string.find(s,"XMLHttpRequest",nil,true)then return end;if string.find(s,"Unsafe JavaScript attempt to access",nil,true)then return end;if string.find(s,"Unable to post message to",nil,true)then return end;if string.find(s,"ran insecure content from",nil,true)then return end;if string.find(s,"Mixed Content:",nil,true)then return end end;return q(r,s)end;o:AddFunction("console","warn",function(t)if not k:GetBool()then return end;o:ConsoleMessage(t)end)o:SetPaintedManually(true)o:SetVisible(false)o:AddFunction("medialiblua","Event",function(u,v)self:handleHTMLEvent(u,util.JSONToTable(v))end)end;function l:getBaseService()return"html"end;function l:openUrl(d)self.panel:OpenURL(d)self.URLChanged=CurTime()end;function l:runJS(w,...)local x=string.format(w,...)self.panel:QueueJavascript(x)end;function l:handleHTMLEvent(u,y)if a.DEBUG then MsgN("[MediaLib] HTML Event: "..u.." ("..table.ToString(y)..")")end;if u=="stateChange"then local z=y.state;local A;if y.time then self.timeKeeper:seek(y.time)end;if z=="playing"then A="playing"self.timeKeeper:play()elseif z=="ended"or z=="paused"or z=="buffering"then A=z;self.timeKeeper:pause()end;if A then self.state=A;self:emit(A)end elseif u=="playerLoaded"then for B,C in pairs(self.commandQueue or{})do C()end elseif u=="error"then self:emit("error",{errorId="service_error",errorName="Error from service: "..tostring(y.message)})else MsgN("[MediaLib] Unhandled HTML event "..tostring(u))end end;function l:getState()return self.state end;local D=CreateConVar("medialib_html_updatestride","1",FCVAR_ARCHIVE)function l:setUpdateStrideOverride(E)self._updateStrideOverride=E end;function l:updateTexture()local F=FrameNumber()local G=self._nextTextureUpdateFrame or 0;local H=self._updateStrideOverride or D:GetInt()if G<=F then self.panel:UpdateHTMLTexture()self._nextTextureUpdateFrame=F+H end end;function l:getHTMLMaterial()if self._htmlMat then return self._htmlMat end;local I=self.panel:GetHTMLMaterial()self._htmlMat=I;return I end;function l:draw(J,K,L,M)self:updateTexture()local I=self:getHTMLMaterial()if not I then return end;surface.SetMaterial(I)surface.SetDrawColor(255,255,255)local N,O=m/I:Width(),n/I:Height()surface.DrawTexturedRectUV(J or 0,K or 0,L or m,M or n,0,0,N,O)end;function l:getTime()return self.timeKeeper:getTime()end;function l:setQuality(P)if self.lastSetQuality and self.lastSetQuality==P then return end;self.lastSetQuality=P;self:runJS("medialibDelegate.run('setQuality', {quality: %q})",P)end;function l:applyVolume()local Q=self.internalVolume or 1;local R=self.volume or 1;local S=Q*R;if self.lastSetVolume and self.lastSetVolume==S then return end;self.lastSetVolume=S;self:runJS("medialibDelegate.run('setVolume', {vol: %f})",S)end;function l:setVolume(S)self.volume=S;self:applyVolume()end;function l:getVolume()return self.volume or 1 end;local T=0.2;function l:seek(U)self.timeKeeper:seek(U-T)self:runJS("medialibDelegate.run('seek', {time: %.1f})",U)end;function l:hasReliablePlaybackEvents()local V=self:getService()return V and V:hasReliablePlaybackEvents(self)end;function l:play()if not self:hasReliablePlaybackEvents()then self.timeKeeper:play()end;self:runJS("medialibDelegate.run('play')")end;function l:pause()if not self:hasReliablePlaybackEvents()then self.timeKeeper:pause()end;self:runJS("medialibDelegate.run('pause')")end;function l:stop()h.free(self.panel)self.panel=nil;self.timeKeeper:pause()self:emit("ended",{stopped=true})self:emit("destroyed")end;function l:runCommand(C)if self._playerLoaded then C()else self.commandQueue=self.commandQueue or{}self.commandQueue[#self.commandQueue+1]=C end end;function l:isValid()return IsValid(self.panel)end end;a.modulePlaceholder("service_bass")do local b=a.load("oop")local c=b.class("BASSService","Service")function c:load(d,e)local f=b.class("BASSMedia")()self:loadMediaObject(f,d,e)return f end;local g=b.class("BASSMedia","Media")function g:initialize()self.bassPlayOptions={"noplay","noblock"}self.commandQueue={}end;function g:getBaseService()return"bass"end;function g:updateFFT()local h=FrameNumber()if self._lastFFTUpdate and self._lastFFTUpdate==h then return end;self._lastFFTUpdate=h;local i=self.chan;if not IsValid(i)then return end;self.fftValues=self.fftValues or{}i:FFT(self.fftValues,FFT_512)end;function g:getFFT()return self.fftValues end;function g:draw(j,k,l,m)surface.SetDrawColor(0,0,0)surface.DrawRect(j,k,l,m)self:updateFFT()local n=self:getFFT()if not n then return end;local o=#n;local p=l/o;for q=1,o do surface.SetDrawColor(HSVToColor(q,0.9,0.5))local r=n[q]*m;surface.DrawRect(j+q*p,k+m-r,p,r)end end;function g:openUrl(d)self._openingInfo={"url",d}local s=table.concat(self.bassPlayOptions," ")sound.PlayURL(d,s,function(i,t,u)self:bassCallback(i,t,u)end)end;function g:openFile(v)self._openingInfo={"file",v}local s=table.concat(self.bassPlayOptions," ")sound.PlayFile(v,s,function(i,t,u)self:bassCallback(i,t,u)end)end;function g:reload()local w,x=unpack(self._openingInfo or{})if not w then MsgN("[Medialib] Attempting to reload BASS stream that was never started the first time!")return end;if IsValid(self.chan)then self.chan:Stop()self.chan=nil end;self._stopped=false;self:stopStateChecker()self.commandQueue={}MsgN("[Medialib] Attempting to reload BASS stream ",w,x)if w=="url"then self:openUrl(x)elseif w=="file"then self:openFile(x)elseif w then MsgN("[Medialib] Failed to reload audio resource ",w,x)return end;self:applyVolume(true)if self._commandState=="play"then self:play()end end;function g:bassCallback(i,t,u)if not IsValid(i)then ErrorNoHalt("[MediaLib] BassMedia play failed: ",u)self._stopped=true;self:emit("error","loading_failed",string.format("BASS error id: %s; name: %s",t,u))return end;if self._stopped then MsgN("[MediaLib] Loading BASS media aborted; stop flag was enabled")i:Stop()return end;self.chan=i;for y,z in pairs(self.commandQueue)do z(i)end;self.commandQueue={}self:startStateChecker()end;function g:startStateChecker()timer.Create("MediaLib_BASS_EndChecker_"..self:hashCode(),1,0,function()if IsValid(self.chan)and self.chan:GetState()==GMOD_CHANNEL_STOPPED then self:emit("ended")self:stopStateChecker()end end)end;function g:stopStateChecker()timer.Remove("MediaLib_BASS_EndChecker_"..self:hashCode())end;function g:runCommand(A)if IsValid(self.chan)then A(self.chan)else self.commandQueue[#self.commandQueue+1]=A end end;function g:applyVolume(B)local C=self.internalVolume or 1;local D=self.volume or 1;local E=C*D;if not B and self.lastSetVolume and self.lastSetVolume==E then return end;self.lastSetVolume=E;self:runCommand(function(i)i:SetVolume(E)end)end;function g:setVolume(E)self.volume=E;self:applyVolume()end;function g:getVolume()return self.volume or 1 end;function g:seek(F)self:runCommand(function(i)if i:IsBlockStreamed()then return end;self._seekingTo=F;local G="MediaLib_BASSMedia_Seeker_"..self:hashCode()local function H()if self._seekingTo~=F or not IsValid(i)then timer.Destroy(G)return end;i:SetTime(F)if math.abs(i:GetTime()-F)<0.25 then timer.Destroy(G)end end;timer.Create(G,0.2,0,H)H()end)end;function g:getTime()if self:isValid()and IsValid(self.chan)then return self.chan:GetTime()end;return 0 end;function g:getState()if not self:isValid()then return"error"end;if not IsValid(self.chan)then return"loading"end;local I=self.chan:GetState()if I==GMOD_CHANNEL_PLAYING then return"playing"end;if I==GMOD_CHANNEL_PAUSED then return"paused"end;if I==GMOD_CHANNEL_STALLED then return"buffering"end;if I==GMOD_CHANNEL_STOPPED then return"paused"end;return end;function g:play()self:runCommand(function(i)i:Play()self:emit("playing")self._commandState="play"end)end;function g:pause()self:runCommand(function(i)i:Pause()self:emit("paused")self._commandState="pause"end)end;function g:stop()self._stopped=true;self:runCommand(function(i)i:Stop()self:emit("ended",{stopped=true})self:emit("destroyed")self:stopStateChecker()end)end;function g:isValid()return not self._stopped end;local J=a.load("mediaregistry")local K="ML_MapCleanHack_"..a.INSTANCE;if CLIENT then net.Receive(K,function()for y,L in pairs(J.get())do if L:getBaseService()=="bass"and L:isValid()and IsValid(L.chan)and L.chan:GetState()==GMOD_CHANNEL_STOPPED then L:reload()end end end)end;if SERVER then util.AddNetworkString(K)hook.Add("PostCleanupMap","MediaLib_BassReload"..a.INSTANCE,function()net.Start(K)net.Broadcast()end)end end;a.FolderItems["services/gdrive.lua"]="local a=medialib.load(\"oop\")local b=a.class(\"GDriveService\",\"HTMLService\")b.identifier=\"GDrive\"local c={\"^https?://drive.google.com/file/d/([^/]*)/edit\"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local function h(i)if i then i=string.gsub(i,\"\\n\",\"\\r\\n\")i=string.gsub(i,\"([^%w ])\",function(j)return string.format(\"%%%02X\",string.byte(j))end)i=string.gsub(i,\" \",\"+\")end;return i end;local k=\"https://wyozi.github.io/gmod-medialib/mp4.html?id=%s\"local l=\"https://drive.google.com/uc?export=download&confirm=yTib&id=%s\"function b:resolveUrl(d,m)local n=self:parseUrl(d)local o=string.format(k,h(string.format(l,n.id)))m(o,{start=n.start})end;function b:directQuery(d,m)m(nil,{title=d:match(\"([^/]+)$\")})end;function b:hasReliablePlaybackEvents()return true end;return b"a.FolderItems["services/mp4.lua"]="local a=medialib.load(\"oop\")local b=a.class(\"Mp4Service\",\"HTMLService\")b.identifier=\"mp4\"local c={\"^https?://.*%.mp4\"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local h=\"https://wyozi.github.io/gmod-medialib/mp4.html?id=%s\"function b:resolveUrl(d,i)local j=self:parseUrl(d)local k=string.format(h,j.id)i(k,{start=j.start})end;function b:directQuery(d,i)i(nil,{title=d:match(\"([^/]+)$\")})end;function b:hasReliablePlaybackEvents()return true end;return b"a.FolderItems["services/soundcloud.lua"]="local a=medialib.load(\"oop\")local b=a.class(\"SoundcloudService\",\"BASSService\")b.identifier=\"soundcloud\"local c={\"^https?://www.soundcloud.com/([A-Za-z0-9_%-]+/[A-Za-z0-9_%-]+)/?.*$\",\"^https?://soundcloud.com/([A-Za-z0-9_%-]+/[A-Za-z0-9_%-]+)/?.*$\"}local d=\"^https?://api.soundcloud.com/tracks/(%d+)\"function b:parseUrl(e)for f,g in pairs(c)do local h=string.match(e,g)if h then return{path=h}end end;local i=string.match(e,d)if i then return{id=i}end end;function b:isValidUrl(e)return self:parseUrl(e)~=nil end;function b:resolveUrl(e,j)local k=medialib.SOUNDCLOUD_API_KEY;if not k then ErrorNoHalt(\"SoundCloud error: Missing SoundCloud API key\")return end;if type(k)==\"table\"then k=table.Random(k)end;local l=self:parseUrl(e)if l.id then j(string.format(\"https://api.soundcloud.com/tracks/%s/stream?client_id=%s\",l.id,k),{})else http.Fetch(string.format(\"https://api.soundcloud.com/resolve.json?url=http://soundcloud.com/%s&client_id=%s\",l.path,k),function(m)local n=util.JSONToTable(m)if not n then ErrorNoHalt(\"Failed to retrieve SC track id for \"..l.path..\": empty JSON\")return end;local i=n.id;j(string.format(\"https://api.soundcloud.com/tracks/%s/stream?client_id=%s\",i,k),{})end)end end;function b:directQuery(e,j)local k=medialib.SOUNDCLOUD_API_KEY;if not k then j(\"Missing SoundCloud API key\")return end;if type(k)==\"table\"then k=table.Random(k)end;local l=self:parseUrl(e)local o;if l.path then o=string.format(\"https://api.soundcloud.com/resolve.json?url=http://soundcloud.com/%s&client_id=%s\",l.path,k)else o=string.format(\"https://api.soundcloud.com/tracks/%s?client_id=%s\",l.id,k)end;http.Fetch(o,function(p,q)if q==0 then j(\"http body size = 0\")return end;local r=util.JSONToTable(p)if r.errors then local s=r.errors[1].error_message or\"error\"local t=s;if string.StartWith(s,\"404\")then t=\"Invalid id\"end;j(t)return end;j(nil,{title=r.title,duration=tonumber(r.duration)/1000})end,function(u)j(\"HTTP: \"..u)end)end;return b"a.FolderItems["services/twitch.lua"]="local a=medialib.load(\"oop\")local b=a.class(\"TwitchService\",\"HTMLService\")b.identifier=\"twitch\"local c={\"https?://www.twitch.tv/([A-Za-z0-9_%-]+)\",\"https?://twitch.tv/([A-Za-z0-9_%-]+)\"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local h=\"https://wyozi.github.io/gmod-medialib/twitch.html?channel=%s\"function b:resolveUrl(d,i)local j=self:parseUrl(d)local k=string.format(h,j.id)i(k,{start=j.start})end;local l=\"4cryixome326gh0x0j0fkulahsbdvx\"local function m(n,i)http.Fetch(\"https://api.twitch.tv/kraken/users?login=\"..n,function(o)local p=util.JSONToTable(o)if not p then i(\"malformed response JSON\")return end;i(nil,p.users[1]._id)end,function()i(\"failed HTTP request\")end,{Accept=\"application/vnd.twitchtv.v5+json\",[\"Client-ID\"]=l})end;local function q(g,i)http.Fetch(\"https://api.twitch.tv/kraken/channels/\"..g,function(o)local p=util.JSONToTable(o)if not p then i(\"malformed response JSON\")return end;i(nil,p)end,function()i(\"failed HTTP request\")end,{Accept=\"application/vnd.twitchtv.v5+json\",[\"Client-ID\"]=l})end;function b:directQuery(d,i)local j=self:parseUrl(d)m(j.id,function(r,g)if r then i(r)return end;q(g,function(s,t)if s then i(s)return end;local u={}u.id=j.id;if t.error then i(t.message)return else u.title=t.display_name..\": \"..t.status end;i(nil,u)end)end)end;return b"a.FolderItems["services/vimeo.lua"]="local a=medialib.load(\"oop\")local b=a.class(\"VimeoService\",\"HTMLService\")b.identifier=\"vimeo\"local c={\"https?://www.vimeo.com/([0-9]+)\",\"https?://vimeo.com/([0-9]+)\",\"https?://www.vimeo.com/channels/staffpicks/([0-9]+)\",\"https?://vimeo.com/channels/staffpicks/([0-9]+)\"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local h=\"http://wyozi.github.io/gmod-medialib/vimeo.html?id=%s\"function b:resolveUrl(d,i)local j=self:parseUrl(d)local k=string.format(h,j.id)i(k,{start=j.start})end;function b:directQuery(d,i)local j=self:parseUrl(d)local l=string.format(\"http://vimeo.com/api/v2/video/%s.json\",j.id)http.Fetch(l,function(m,n,o,p)if n==0 then i(\"http body size = 0\")return end;if p==404 then i(\"Invalid id\")return end;local q={}q.id=j.id;local r=util.JSONToTable(m)if r then q.title=r[1].title;q.duration=r[1].duration else q.title=\"ERROR\"end;i(nil,q)end,function(s)i(\"HTTP: \"..s)end)end;function b:hasReliablePlaybackEvents()return true end;return b"a.FolderItems["services/webaudio.lua"]="local a=medialib.load(\"oop\")local b=a.class(\"WebAudioService\",\"BASSService\")b.identifier=\"webaudio\"local c={\"^https?://(.*)%.mp3\",\"^https?://(.*)%.ogg\"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;function b:resolveUrl(d,h)h(d,{})end;function b:directQuery(d,h)h(nil,{title=d:match(\"([^/]+)$\")})end;return b"a.FolderItems["services/webm.lua"]="local a=medialib.load(\"oop\")local b=a.class(\"WebmService\",\"HTMLService\")b.identifier=\"webm\"local c={\"^https?://.*%.webm\"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local h=\"http://wyozi.github.io/gmod-medialib/webm.html?id=%s\"function b:resolveUrl(d,i)local j=self:parseUrl(d)local k=string.format(h,j.id)i(k,{start=j.start})end;function b:directQuery(d,i)i(nil,{title=d:match(\"([^/]+)$\")})end;return b"a.FolderItems["services/webradio.lua"]="local a=medialib.load(\"oop\")local b=a.class(\"WebRadioService\",\"BASSService\")b.identifier=\"webradio\"local c={\"^https?://(.*)%.pls\",\"^https?://(.*)%.m3u\"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;function b:resolveUrl(d,h)h(d,{})end;function b:directQuery(d,h)h(nil,{title=d:match(\"([^/]+)$\")})end;return b"a.FolderItems["services/youtube.lua"]="local a=medialib.load(\"oop\")local b=a.class(\"YoutubeService\",\"HTMLService\")b.identifier=\"youtube\"local c={\"^https?://[A-Za-z0-9%.%-]*%.?youtu%.be/([A-Za-z0-9_%-]+)\",\"^https?://[A-Za-z0-9%.%-]*%.?youtube%.com/watch%?.*v=([A-Za-z0-9_%-]+)\",\"^https?://[A-Za-z0-9%.%-]*%.?youtube%.com/v/([A-Za-z0-9_%-]+)\"}local d={}for e,f in pairs(c)do local function g(h)table.insert(d,f..h..\"t=(%d+)m(%d+)s\")table.insert(d,f..h..\"t=(%d+)s?\")end;g(\"#\")g(\"&\")g(\"?\")table.insert(d,f)end;function b:parseUrl(i)for e,j in pairs(d)do local k,l,m=string.match(i,j)if k then local n;if l and m then n=tonumber(l)*60+tonumber(m)else n=tonumber(l)end;return{id=k,start=n}end end end;function b:isValidUrl(i)return self:parseUrl(i)~=nil end;local o=\"https://api.wayzer.ru/youtube.html?id=%s\"function b:resolveUrl(i,p)local q=self:parseUrl(i)local r=string.format(o,q.id)p(r,{start=q.start})end;local function s(t)local u=t:match(\"(%d+)H\")or 0;local v=t:match(\"(%d+)M\")or 0;local w=t:match(\"(%d+)S\")or 0;return u*60*60+v*60+w end;local x=\"AIzaSyBmQHvMSiOTrmBKJ0FFJ2LmNtc4YHyUJaQ\"function b:directQuery(i,p)local y=medialib.YOUTUBE_API_KEY or x;local q=self:parseUrl(i)local z=string.format(\"https://www.googleapis.com/youtube/v3/videos?part=snippet%%2CcontentDetails&id=%s&key=%s\",q.id,y)http.Fetch(z,function(A,B)if B==0 then p(\"http body size = 0\")return end;local C={}C.id=q.id;local D=util.JSONToTable(A)if D and D.items then local E=D.items[1]if not E then p(\"No video id found\")return end;C.title=E.snippet.title;local F=E.snippet.liveBroadcastContent==\"live\"if F then C.live=true else C.duration=tonumber(s(E.contentDetails.duration))end;C.raw=E else p(A)return end;p(nil,C)end,function(G)p(\"HTTP: \"..G)end)end;function b:hasReliablePlaybackEvents()return true end;return b"a.modulePlaceholder("serviceloader")do a.load("servicebase")a.load("service_html")a.load("service_bass")local b=a.load("media")for c,d in a.folderIterator("services")do if a.DEBUG then print("[MediaLib] Registering service "..d.name)end;if SERVER then d:addcs()end;local e,f=pcall(function()return d:load()end)if e then b.registerService(f.identifier,f)else print("[MediaLib] Failed to load service ",d,": ",f)end end end;a.modulePlaceholder("__loader")do a.load("mediabase")a.load("media")a.load("serviceloader")end;return a
--MediaLib_DynFile_webm.lua:
local a=medialib.load("oop")local b=a.class("WebmService","HTMLService")b.identifier="webm"local c={"^https?://.*%.webm"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local h="http://wyozi.github.io/gmod-medialib/webm.html?id=%s"function b:resolveUrl(d,i)local j=self:parseUrl(d)local k=string.format(h,j.id)i(k,{start=j.start})end;function b:directQuery(d,i)i(nil,{title=d:match("([^/]+)$")})end;return b
--addons/module_media/lua/wayradio/mp3duration.lua:
-- Enables parsing ID3 headers of given mp3 files. This means service:query returns a lot more relevant
-- information, such as artist and title instead of just the filename.
--
-- The downside is that parsing the header requires fetching the whole mp3 file, which is expensive and
-- takes a while.
--
-- Orig. Source: https://gist.github.com/mkottman/1162235

local function textFrame(name)
	return function (reader, info, frameSize)
		local encoding = reader.readByte()
		info[name] =  reader.readStr(frameSize - 1)
	end
end

-- only decode these ID3v2 frames
local frameDecoders = {
	COMM = function (reader, info, frameSize)
		local encoding = reader.readByte()
		local language = reader.readStr(4)
		info.comment = reader.readStr(frameSize - 5)
	end,
	TALB = textFrame 'album',
	TBPM = textFrame 'bpm',
	TENC = textFrame 'encoder',
	TLEN = textFrame 'length',
	TIT2 = textFrame 'title',
	TPE1 = textFrame 'artist',
	TRCK = textFrame 'track',
	TYER = textFrame 'year',
}

local function unpad(str)
	return (str:gsub('[%s%z]+$', ''))
end

local function isbitset(x, p)
	local b = 2 ^ (p - 1)
	return x % (b + b) >= b
end

--- Read ID3 tags from MP3 file. First tries ID3v2 tags, then ID3v1 and returns those
-- which are found first. Returns the following tags (if they are contained in the file):
-- <ul><li>title</li><li>artist</li><li>album</li><li>year</li><li>comment</li></ul>
-- @name readtags
-- @param file Either string (filename) or a file object opened by io.open()
-- @return Table containing the metadata from ID3 tag, or nil.
local function readtags(file)
	local position = file:seek()

	local function decodeID3v2(reader)
		local info = {}
		local rb = reader.readByte
		local version = reader.readInt(2)
		local flags = rb()
		local size = reader.readInt(4, 128)

		if isbitset(flags, 7) then
			local mult = version >= 0x0400 and 128 or 256
			local extendedSize = reader.readInt(4, mult)
			local extendedFlags = reader.readInt(2)
			local padding = reader.readInt(4)
			reader.skip(extendedSize - 10)
		end
		while reader.position() < size + 3 do
			local frameID = reader.readStr(4)
			local frameSize = reader.readInt(4)
			local frameFlags = reader.readInt(2)
			if frameDecoders[frameID] then
				frameDecoders[frameID](reader, info, frameSize)
			else
				reader.skip(frameSize)
			end
		end
		file:seek('set', position)
		return info
	end

	local function decodeID3v1(reader)
		local info = {}
		info.title = reader.readStr(30)
		info.artist = reader.readStr(30)
		info.album = reader.readStr(30)
		info.year = reader.readStr(4)
		info.comment = reader.readStr(28)
		local zero = reader.readByte()
		local track = reader.readByte()
		local genre = reader.readByte()
		if zero == 0 then
			info.track = track
			info.genre = genre
		else
			info.comment = unpad(info.comment .. string.char(zero, track, genre))
		end

		file:seek('end', -128 - 227)
		local hdr = reader.readStr(4)
		if hdr == "TAG+" then
			info.title = unpad(info.title .. reader.readStr(60))
			info.artist = unpad(info.artist .. reader.readStr(60))
			info.album = unpad(info.album .. reader.readStr(60))
			-- some other tags omitted
		end

		file:seek('set', position)
		return info
	end

	local function readByte()
		local byte = assert(file:read(1), 'Could not read byte.')
		return string.byte(byte)
	end
	local reader = {
		readStr = function(len)
			local str = assert(file:read(len), 'Could not read '..len..'-byte string.')
			return unpad(str)
		end,
		readByte = readByte,
		readInt = function(size, mult)
			mult = mult or 256
			local n = readByte()
			for i=2, size do
				n = n*mult + readByte()
			end
			return n
		end,
		position = function() return file:seek() end,
		skip = function(offset) file:seek('cur', offset) end
	}

	-- try ID3v2
	file:seek('set', 0)
	local header = file:read(3)
	if header == "ID3" then
		return decodeID3v2(reader)
	end

	-- try ID3v1
	file:seek('end', -128)
	header = file:read(3)
	if header == "TAG" then
		return decodeID3v1(reader)
	end
end

local function readtags_data(data)
	-- Simulated file handle
	local sfh = {pos = 0, data = data}
	function sfh:seek(whence, offset)
		offset = offset or 0

		if whence == "set" then
			self.pos = offset + 0
		elseif whence == "cur" then
			self.pos = offset + self.pos
		elseif whence == "end" then
			self.pos = offset + #self.data-1
		end
		return self.pos
	end
	function sfh:read(bytes)
		local subData = string.sub(self.data, self.pos+1, self.pos+1+bytes-1)
		self.pos = self.pos + bytes
		return subData
	end

	return readtags(sfh)
end

hook.Add("Medialib_ExtendQuery", "Medialib_ID3Parser", function(url, cbchain)
	if not string.EndsWith(url, ".mp3") then return end

	local function ParseID3(err, data, cb)
		local tags = readtags_data(data._raw_fetcheddata)
		if tags and tags.title then
			local title = tags.title
			if tags.artist then title = tags.artist .. " - " .. title end

			data.title = title

			-- Some soundfiles have duration as a string containing milliseconds
			if tags.length then
				local length = tonumber(tags.length)
				if length then data.duration = length / 1000 end
			end
		end

		cb(err, data)
	end

	cbchain:addCallback(function(err, data, cb)
		if data._raw_fetcheddata then
			ParseID3(err, data, cb)
		else
			http.Fetch(url, function(rawdata)
				data._raw_fetcheddata = rawdata
				ParseID3(err, data, cb)
			end)
		end
	end)
end)
--addons/module_scoreboard/lua/wayscore/vgui/frame.lua:
local opacity = CreateClientConVar('wayscore_opacity', 0.95, true)

local PANEL = {}

local circlered = Material('icon72/red_circle.png')
local yellowcircle = Material('icon72/yellow_circle.png')
local greencircle = Material('icon72/green_circle.png')
local dbackColor = Color(120, 35, 4)
local backColor = Color(186, 55, 14)

function PANEL:Init()
    self:SetSize(math.min(965, ScrW() - 100), math.max(ScrH() - 300, 400))
    self:Center()
    self.Headder = vgui.Create('DPanel', self)
    self.Headder:SetTall(30)
    self.Headder:Dock(TOP)
    self.BackButton = vgui.Create('DButton', self)
    self.BackButton:SetText('')
    self.BackButton:SetPos(10, 5)
    self.BackButton:SetSize(20,20)
    self.BackButton.FontColor = Color( 236, 240, 241)
    
    function self.BackButton:Paint(w, h)
        if wayscore.view == 'main' then return end 
        draw.RoundedBox(2, 0, 0, w, h, dbackColor)
        draw.RoundedBox(2, 0, 0, w, h-2, backColor)
        draw.SimpleText('X', 'wayscore.small', w / 2, h / 2, self.FontColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end

    function self.BackButton:DoClick()
        if wayscore.view == 'main' then return end
        wayscore:SelectView('main')
    end

    function self.Headder:Paint(w, h)
        draw.RoundedBox(6, 0, 0, w, h, Color(47, 52, 57))
        if wayscore.view ~= 'main' then return end 
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( circlered )
        surface.DrawTexturedRect( 16, 10, 12, 12 )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( yellowcircle )
        surface.DrawTexturedRect( 32, 10, 12, 12 )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( greencircle )
        surface.DrawTexturedRect( 48, 10, 12, 12 )
    --    draw.SimpleText(GetHostName(), 'wayscore.small', w/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText('Онлайн: '..player.GetCount()..'/'..game.MaxPlayers(), 'wayscore.small', w/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end

function PANEL:Paint(w, h)
    --draw.RoundedBox(0, 0, 10, w, 55, Color(47, 52, 57))
    draw.RoundedBox(6, 0, 0, w, h, Color( 47, 52, 57, math.Clamp(255*opacity:GetFloat(), 0, 255)))
end

vgui.Register('wayscore_frame', PANEL, 'Panel')
--addons/module_skins/lua/autorun/weaponskins_init.lua:
weaponSkins = {}

if SERVER then
    AddCSLuaFile('weaponskins/shared.lua')
    include('weaponskins/shared.lua')

    AddCSLuaFile('weaponskins/client.lua')

    include('weaponskins/server.lua')
else
    include('weaponskins/shared.lua')
    include('weaponskins/client.lua')
end
--addons/_wlib/lua/wlib/modules/include.lua:
-- inspired by octolib (https://octothorp.team/)

wlib.include = wlib.include or {}
wlib.include.modes = wlib.include.modes or {}

local function normalizePath(path)
	return path .. (string.EndsWith(path, '/') and '' or '/')
end

function wlib.include.modes.shared(path)
    local includes = {}
	local files = file.Find(path..'*.lua', 'LUA') or {}

	for _, fileName in pairs(files) do
		local path = path..fileName

		includes[string.StripExtension(fileName)] = function()
			if SERVER then
				AddCSLuaFile(path)
			end

			include(path)
		end
	end

	return includes
end

function wlib.include.modes.server(path)
    local includes = {}
	local files = file.Find(path..'*.lua', 'LUA') or {}

	for _, fileName in pairs(files) do
		local path = path..fileName

		includes[string.StripExtension(fileName)] = function()
			include(path)
		end
	end

	return includes
end

function wlib.include.modes.client(path)
    local includes = {}
	local files = file.Find(path..'*.lua', 'LUA') or {}

	for _, fileName in pairs(files) do
		local path = path..fileName

		includes[string.StripExtension(fileName)] = function()
			if SERVER then
				AddCSLuaFile(path)
			else
				include(path)
			end
		end
	end

	return includes
end

function wlib.include.modes.modules(path)
	local includes = {}
	local _, folders = file.Find(path..'*', 'LUA')

	for _, moduleName in ipairs(folders or {}) do
		if string.StartsWith(moduleName, '.') then continue end

		local path = path..moduleName

		includes[moduleName] = function()
			if CLIENT then
				if file.Exists(path .. '/shared.lua', 'LUA') then
					include(path .. '/shared.lua')
				end

				if file.Exists(path .. '/client.lua', 'LUA') then
					include(path .. '/client.lua')
				end

				for _, v in ipairs(file.Find(path..'/sh_*.lua', 'LUA') or {}) do
					include(path..'/'..v)
				end

				for _, v in ipairs(file.Find(path..'/cl_*.lua', 'LUA') or {}) do
					include(path..'/'..v)
				end
				return
			end

			if file.Exists(path .. '/shared.lua', 'LUA') then
				include(path .. '/shared.lua')
				AddCSLuaFile(path .. '/shared.lua')
			end
			for _, v in ipairs(file.Find(path..'/sh_*.lua', 'LUA') or {}) do
				include(path..'/'..v)
				AddCSLuaFile(path..'/'..v)
			end

			if file.Exists(path .. '/server.lua', 'LUA') then
				include(path .. '/server.lua')
			end
			for _, v in ipairs(file.Find(path..'/sv_*.lua', 'LUA') or {}) do
				include(path..'/'..v)
			end

			if file.Exists(path .. '/client.lua', 'LUA') then
				AddCSLuaFile(path .. '/client.lua')
			end
			for _, v in ipairs(file.Find(path..'/cl_*.lua', 'LUA') or {}) do
				AddCSLuaFile(path..'/'..v)
			end
		end
	end

	return includes
end

function wlib.include.custom(path, findfuncs, order)
	if isfunction(findfuncs) then
		findfuncs = {findfuncs}
	end

	local includes = {}
	for _, func in ipairs(findfuncs) do
		table.Merge(includes, func(normalizePath(path)))
	end

	if istable(order) then
		for _, name in ipairs(order) do
			local names = {}
			local ignore = string.StartWith(name, '!')

			if ignore then
				name = string.sub(name, 2)
			end

			if string.find(name, '*') then
				local includeNames = table.GetKeys(includes)
				for _, includeName in SortedPairsByValue(includeNames) do
					if string.match(includeName, '^' .. string.Replace(name, '*', '.+') .. '$') then
						table.insert(names, includeName)
					end
				end
			elseif includes[name] then
				table.insert(names, name)
			end

			for _, name in ipairs(names) do
				if not ignore then
					includes[name]()
				end

				includes[name] = nil
			end
		end
	else
		for _, includeFunc in SortedPairs(includes) do
			includeFunc()
		end
	end
end

function wlib.include.prefixed(path, order)
	local sh, sv, cl = {}, {}, {}

	if istable(order) then
		for _, v in ipairs(order) do
			if string.StartsWith(v, 'sh_') then
				table.insert(sh, v)
			elseif string.StartsWith(v, 'sv_') then
				table.insert(sv, v)
			elseif string.StartsWith(v, 'cl_') then
				table.insert(cl, v)
			elseif v == '*' then
				table.insert(sh, 'sh_*')
				table.insert(sv, 'sv_*')
				table.insert(cl, 'cl_*')
			end
		end
	else
		table.insert(sh, 'sh_*')
		table.insert(sv, 'sv_*')
		table.insert(cl, 'cl_*')
	end

	wlib.include.custom(path, wlib.include.modes.shared, sh)
	wlib.include.custom(path, wlib.include.modes.server, sv)
	wlib.include.custom(path, wlib.include.modes.client, cl)
end

function wlib.include.module(path, order)
	wlib.include.custom(path, wlib.include.modes.shared, {'shared'})
	wlib.include.custom(path, wlib.include.modes.server, {'server'})
	wlib.include.custom(path, wlib.include.modes.client, {'client'})

	wlib.include.prefixed(path, order)
end

function wlib.include.modules(path, order)
	wlib.include.custom(path, {
		wlib.include.modes.modules,
		wlib.include.modes.shared,
	}, order)
end

function wlib.include.server(path, order)
	wlib.include.custom(path, wlib.include.modes.server, order)
end

function wlib.include.shared(path, order)
	wlib.include.custom(path, wlib.include.modes.shared, order)
end

function wlib.include.client(path, order)
	wlib.include.custom(path, wlib.include.modes.client, order)
end
--addons/_wlib/lua/wlib/modules/cfg.lua:
CFG = CFG or {}

wlib.include.prefixed('config', {
    'sh_wlib',
    'cl_wlib',
    'sv_wlib',
})

wlib.include.server('config', {'_db'})
wlib.include.shared('config/maps', {game.GetMap()})
--addons/_wlib/lua/wlib/libraries/pon.lua:
--[[
	PON
	created by thelastpenguin
	improved by Octothorp Team
]]
local pon = {}
_G.pon = pon

local type = type
local tonumber = tonumber
local format = string.format
local insert = table.insert

do
	local encode = {}

	local cacheSize = 0

	encode["table"] = function(tbl, output, cache)
		if cache[tbl] then
			insert(output, format("(%u)", cache[tbl]))
			return
		else
			cacheSize = cacheSize + 1
			cache[tbl] = cacheSize
		end

		local first = next(tbl)
		local predictedNumeric = 1

		-- starts with a sequential type
		if first == 1 then
			insert(output, "{")

			for k, v in next, tbl do
				if k == predictedNumeric then
					predictedNumeric = predictedNumeric + 1

					local tv = type(v)
					if tv == "string" then
						local pid = cache[v]
						if pid then
							insert(output, format("(%u)", pid))
						else
							cacheSize = cacheSize + 1
							cache[v] = cacheSize
							encode.string(v, output)
						end
					else
						encode[tv](v, output, cache)
					end
				else
					break
				end
			end

			predictedNumeric = predictedNumeric - 1
		else
			predictedNumeric = nil
		end

		-- start with dictionary type
		if predictedNumeric == nil then
			insert(output, "[")
		else
			-- break sequential for dictionary
			local kv = next(tbl, predictedNumeric)
			if kv then
				insert(output, "~")
			end
		end

		for k, v in next, tbl, predictedNumeric do
			local tk, tv = type(k), type(v)

			-- WRITE KEY
			if tk == "string" then
				local pid = cache[k]
				if pid then
					insert(output, format("(%u)", pid))
				else
					cacheSize = cacheSize + 1
					cache[k] = cacheSize

					encode.string(k, output)
				end
			else
				encode[tk](k, output, cache)
			end

			-- WRITE VALUE
			if tv == "string" then
				local pid = cache[v]
				if pid then
					insert(output, format("(%u)", pid))
				else
					cacheSize = cacheSize + 1
					cache[v] = cacheSize

					encode.string(v, output)
				end
			else
				encode[tv](v, output, cache)
			end
		end

		insert(output, "}")
	end
	--	ENCODE STRING
	local gsub = string.gsub
	encode["string"] = function(str, output)
		local estr, count = gsub(str, ";", "\\;")
		if count == 0 then
			insert(output, "'" .. str .. ";")
		else
			insert(output, '"' .. estr .. '";')
		end
	end
	--	ENCODE NUMBER
	encode["number"] = function(num, output)
		if num % 1 == 0 then
			if num < 0 then
				insert(output, format("x%x;", -num))
			else
				insert(output, format("X%x;", num))
			end
		else
			insert(output, tonumber(num) .. ";")
		end
	end
	--	ENCODE BOOLEAN
	encode["boolean"] = function(val, output)
		insert(output, val and "t" or "f")
	end
	--	ENCODE VECTOR
	encode["Vector"] = function(val, output)
		insert(output, "v" .. val.x .. "," .. val.y .. "," .. val.z .. ";")
	end
	--	ENCODE ANGLE
	encode["Angle"] = function(val, output)
		insert(output, "a" .. val.p .. "," .. val.y .. "," .. val.r .. ";")
	end
	encode["Entity"] = function(val, output)
		insert(output, "E" .. (IsValid(val) and (val:EntIndex() .. ";") or "#"))
	end
	encode["Player"] = encode["Entity"]
	encode["Vehicle"] = encode["Entity"]
	encode["Weapon"] = encode["Entity"]
	encode["NPC"] = encode["Entity"]
	encode["NextBot"] = encode["Entity"]
	encode["PhysObj"] = encode["Entity"]

	-- untransmittable values fix
	encode["function"] = function(val, output)
		insert(output, 'w')
	end
	encode["userdata"] = function(val, output)
		insert(output, 'u')
	end
	encode["thread"] = function(val, output)
		insert(output, 'h')
	end
	encode["CSoundPatch"] = function(val, output)
		insert(output, 'c')
	end

	do
		local concat = table.concat
		function pon.encode(tbl)
			assert(istable(tbl), "Table excepted for encode.")

			local output = {}
			cacheSize = 0
			encode["table"](tbl, output, {})
			local res = concat(output)

			return res
		end
	end
end

do
	local tonumber = tonumber
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode
	local Vector, Angle, Entity = Vector, Angle, Entity

	local decode = {}

	-- sequential or mixed table
	decode["{"] = function(index, str, cache)
		local cur = {}
		insert(cache, cur)

		local k = 1
		local v, tv
		while true do
			tv = sub(str, index, index)
			if not tv or tv == "~" then
				index = index + 1
				break
			end
			if tv == "}" then
				return index + 1, cur
			end

			index = index + 1
			index, v = decode[tv](index, str, cache)

			cur[k] = v

			k = k + 1
		end

		-- dictionary after sequential
		local tk
		while true do
			tk = sub(str, index, index)
			if not tk or tk == "}" then
				index = index + 1
				break
			end

			index = index + 1
			index, k = decode[tk](index, str, cache)

			tv = sub(str, index, index)
			index = index + 1
			index, v = decode[tv](index, str, cache)

			cur[k] = v
		end

		return index, cur
	end

	-- dictionary table
	decode["["] = function(index, str, cache)
		local cur = {}
		insert(cache, cur)

		local k, v, tk, tv
		while true do
			tk = sub(str, index, index)
			if not tk or tk == "}" then
				index = index + 1
				break
			end

			index = index + 1
			index, k = decode[tk](index, str, cache)

			tv = sub(str, index, index)
			index = index + 1
			index, v = decode[tv](index, str, cache)

			cur[k] = v
		end

		return index, cur
	end

	-- pointer
	decode["("] = function(index, str, cache)
		local finish = find(str, ")", index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1
		return index, cache[num]
	end

	-- string
	decode["'"] = function(index, str, cache)
		local finish = find(str, ";", index, true)
		local res = sub(str, index, finish - 1)
		index = finish + 1

		insert(cache, res)
		return index, res
	end
	-- escaped string
	decode['"'] = function(index, str, cache)
		local finish = find(str, '";', index, true)
		local res = gsub(sub(str, index, finish - 1), "\\;", ";")
		index = finish + 2

		insert(cache, res)
		return index, res
	end

	-- number
	decode["n"] = function(index, str)
		index = index - 1
		local finish = find(str, ";", index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1
		return index, num
	end
	decode["0"] = decode["n"]
	decode["1"] = decode["n"]
	decode["2"] = decode["n"]
	decode["3"] = decode["n"]
	decode["4"] = decode["n"]
	decode["5"] = decode["n"]
	decode["6"] = decode["n"]
	decode["7"] = decode["n"]
	decode["8"] = decode["n"]
	decode["9"] = decode["n"]
	decode["-"] = decode["n"]
	-- positive hex
	decode["X"] = function(index, str)
		local finish = find(str, ";", index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1
		return index, num
	end
	-- negative hex
	decode["x"] = function(index, str)
		local finish = find(str, ";", index, true)
		local num = -tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1
		return index, num
	end

	-- boolean
	decode["t"] = function(index)
		return index, true
	end
	decode["f"] = function(index)
		return index, false
	end

	-- Vector
	decode["v"] = function(index, str)
		local finish = find(str, ";", index, true)
		local vecStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(",", vecStr, false)
		return index, Vector(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end
	-- Angle
	decode["a"] = function(index, str)
		local finish = find(str, ";", index, true)
		local angStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(",", angStr, false)
		return index, Angle(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end
	-- Entity
	decode["E"] = function(index, str)
		if str[index] == "#" then
			index = index + 1
			return index, NULL
		else
			local finish = find(str, ";", index, true)
			local num = tonumber(sub(str, index, finish - 1))
			index = finish + 1
			return index, Entity(num)
		end
	end

	-- untransmittable values fix
	decode["w"] = function(index)
		return index, 'function'
	end
	decode["u"] = function(index)
		return index, 'userdata'
	end
	decode["h"] = function(index)
		return index, 'thread'
	end
	decode["с"] = function(index)
		return index, 'sound'
	end

	function pon.decode(data)
		assert(isstring(data), "String excepted for decode.")

		local succ, _, res = pcall(decode[sub(data, 1, 1)], 2, data, {})
		if succ then return res end
	end
end
--addons/_wlib/lua/wlib/libraries/speedy.lua:
do 
	local IsValid 	= IsValid
	local Entity 	= Entity
	local Color 	= Color
	local WriteUInt = net.WriteUInt
	local ReadUInt 	= net.ReadUInt

	function net.WriteEntity(ent)
		if IsValid(ent) then 
			WriteUInt(ent:EntIndex(), 12)
		else
			WriteUInt(0, 12)
		end
	end

	function net.ReadEntity()
		local i = ReadUInt(12)
		if (not i) then return end
		return Entity(i)
	end

	function net.WriteColor(c)
		WriteUInt(c.r, 8)
		WriteUInt(c.g, 8)
		WriteUInt(c.b, 8)
		WriteUInt(c.a, 8)
	end

	function net.ReadColor()
		return Color(ReadUInt(8), ReadUInt(8), ReadUInt(8), ReadUInt(8))
	end
end


if (SERVER) then return end

do
	local pl
	local _LocalPlayer = LocalPlayer
	function LocalPlayer()
		pl = _LocalPlayer()
		if IsValid(pl) then
			LocalPlayer = function()
				return pl
			end
		end
		return pl
	end
	
	local SetFont 		= surface.SetFont
	local GetTextSize 	= surface.GetTextSize

	local Font 			= 'TargetID'
	local SizeCache 	= {}

	function surface.SetFont(font)
		Font = font
		return SetFont(font)
	end
	 
	function surface.GetTextSize(text)
		if (not SizeCache[Font]) then
			SizeCache[Font] = {}
		end
		   
		if (not SizeCache[Font][text]) then
			local x, y = GetTextSize(text)
			SizeCache[Font][text] = {
				x = x, 
				y = y
			}
			return x, y
		end
		   
		return SizeCache[Font][text].x, SizeCache[Font][text].y
	end
	 
	timer.Create('PurgeFontCache', 1200, 0, function()
		SizeCache = {}
	end)
end

--addons/_wlib/lua/wlib/libraries/_client/circles.lua:
if SERVER then return false end

local _R = debug.getregistry()
if _R.Circles then return _R.Circles end

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local New do
	local err_number = "bad argument #%i to 'New' (number expected, got %s)"

	function New(t, r, x, y, ...)
		assert(isnumber(t), string.format(err_number, 1, type(t)))
		assert(isnumber(r), string.format(err_number, 2, type(r)))
		assert(isnumber(x), string.format(err_number, 3, type(x)))
		assert(isnumber(y), string.format(err_number, 4, type(y)))

		local circle = setmetatable({}, CIRCLE)

		circle:SetType(t)
		circle:SetRadius(r)
		circle:SetX(x)
		circle:SetY(y)

		circle:SetVertices({Count = 0})

		if t == CIRCLE_OUTLINED then
			local outline_width = ...
			assert(outline_width == nil or isnumber(outline_width), string.format(err_number, 5, type(outline_width)))

			circle:SetOutlineWidth(outline_width)
		elseif t == CIRCLE_BLURRED then
			local blur_layers, blur_density = ...
			assert(blur_layers == nil or isnumber(blur_layers), string.format(err_number, 5, type(blur_layers)))
			assert(blur_density == nil or isnumber(blur_density), string.format(err_number, 6, type(blur_density)))

			circle:SetBlurLayers(blur_layers)
			circle:SetBlurDensity(blur_density)
		end

		return circle
	end
end

local RotateVertices do
	local err_table = "bad argument #1 to 'RotateVertices' (table expected, got %s)"
	local err_number = "bad argument #%i to 'RotateVertices' (number expected, got %s)"

	function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
		assert(istable(vertices), string.format(err_table, type(vertices)))
		assert(isnumber(ox), string.format(err_number, 2, type(ox)))
		assert(isnumber(oy), string.format(err_number, 3, type(oy)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))

		local rotation = math.rad(rotation)
		local c = math.cos(rotation)
		local s = math.sin(rotation)

		for i = 1, vertices.Count or #vertices do
			local vertex = vertices[i]
			local vx, vy = vertex.x, vertex.y

			vx = vx - ox
			vy = vy - oy

			vertex.x = ox + (vx * c - vy * s)
			vertex.y = oy + (vx * s + vy * c)

			if rotate_uv == false then
				local u, v = vertex.u, vertex.v
				u, v = u - 0.5, v - 0.5

				vertex.u = 0.5 + (u * c - v * s)
				vertex.v = 0.5 + (u * s + v * c)
			end
		end
	end
end

local CalculateVertices do
	local err_number = "bad argument #%i to 'CalculateVertices' (number expected, got %s)"

	function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		assert(isnumber(radius), string.format(err_number, 3, type(radius)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))
		assert(isnumber(start_angle), string.format(err_number, 5, type(start_angle)))
		assert(isnumber(end_angle), string.format(err_number, 6, type(end_angle)))
		assert(isnumber(distance), string.format(err_number, 7, type(distance)))

		local vertices = {Count = 0}
		local step = distance / radius

		local rad_start_angle = math.rad(start_angle)
		local rad_end_angle = math.rad(end_angle)
		local rad_rotation = math.rad(rotation)

		for a = rad_start_angle, rad_end_angle + step, step do
			a = math.min(a, rad_end_angle)

			local c = math.cos(a + rad_rotation)
			local s = math.sin(a + rad_rotation)

			local vertex = {
				x = x + c * radius,
				y = y + s * radius,
			}

			if rotate_uv == false then
				vertex.u = 0.5 + math.cos(a) / 2
				vertex.v = 0.5 + math.sin(a) / 2
			else
				vertex.u = 0.5 + c / 2
				vertex.v = 0.5 + s / 2
			end

			vertices.Count = vertices.Count + 1
			vertices[vertices.Count] = vertex
		end

		if end_angle - start_angle ~= 360 then
			table.insert(vertices, 1, {
				x = x, y = y,
				u = 0.5, v = 0.5,
			})

			vertices.Count = vertices.Count + 1
		else
			table.remove(vertices)
			vertices.Count = vertices.Count - 1
		end

		return vertices
	end
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:IsValid()
	return (
		not self.m_Dirty and
		self.m_Vertices.Count >= 3 and
		self.m_Radius >= 1 and
		self.m_Distance >= 1
	)
end

function CIRCLE:Calculate()
	local rotate_uv = self.m_RotateMaterial

	local radius = self.m_Radius
	local x, y = self.m_X, self.m_Y

	local rotation = self.m_Rotation
	local start_angle = self.m_StartAngle
	local end_angle = self.m_EndAngle

	local distance = self.m_Distance

	assert(radius >= 1, string.format("circle radius should be >= 1 (%.4f)", radius))
	assert(distance >= 1, string.format("circle distance should be >= 1 (%.4f)", distance))

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if self.m_Type == CIRCLE_OUTLINED then
		local inner = self.m_ChildCircle or self:Copy()
		local inner_r = radius - self.m_OutlineWidth

		if inner_r >= radius then
			self:SetShouldRender(false)
		else
			if inner_r >= 1 then
				inner:SetType(CIRCLE_FILLED)

				inner:SetRadius(inner_r)
				inner:SetAngles(start_angle, end_angle)

				inner:SetColor(false)
				inner:SetMaterial(false)

				inner:SetShouldRender(true)
			else
				inner:SetShouldRender(false)
			end

			self:SetShouldRender(true)
		end

		self:SetChildCircle(inner)
	elseif self.m_ChildCircle then
		self.m_ChildCircle = nil
	end

	self:SetDirty(false)
end

do
	local blur = Material("pp/blurscreen")

	function CIRCLE:__call()
		if self.m_Dirty then
			self:Calculate()
		end

		if not self.m_ShouldRender or not self:IsValid() then
			return false
		end

		do
			local col, mat = self.m_Color, self.m_Material

			if IsColor(col) then
				if col.a <= 0 then return end
				surface.SetDrawColor(col.r, col.g, col.b, col.a)
			end

			if mat == true then
				draw.NoTexture()
			elseif TypeID(mat) == TYPE_MATERIAL then
				surface.SetMaterial(mat)
			end
		end

		if self.m_Type == CIRCLE_OUTLINED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				self.m_ChildCircle()

				render.SetStencilCompareFunction(STENCIL_GREATER)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.DrawPoly(self.m_Vertices)
			render.SetStencilEnable(false)
		elseif self.m_Type == CIRCLE_BLURRED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				surface.DrawPoly(self.m_Vertices)

				render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.SetMaterial(blur)

				local sw, sh = ScrW(), ScrH()

				for i = 1, self.m_BlurLayers do
					blur:SetFloat("$blur", (i / self.m_BlurLayers) * self.m_BlurDensity)
					blur:Recompute()

					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(0, 0, sw, sh)
				end
			render.SetStencilEnable(false)
		else
			surface.DrawPoly(self.m_Vertices)
		end

		return true
	end
end

do
	local err_number = "bad argument #%i to 'Translate' (number expected, got %s)"

	function CIRCLE:Translate(x, y)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		if x == 0 and y == 0 then return end

		self.m_X = self.m_X + x
		self.m_Y = self.m_Y + y

		if not self:IsValid() then return end

		for i = 1, self.m_Vertices.Count do
			local vertex = self.m_Vertices[i]

			vertex.x = vertex.x + x
			vertex.y = vertex.y + y
		end

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Translate(x, y)
		end
	end
end

do
	local err_number = "bad argument #1 to 'Scale' (number expected, got %s)"

	function CIRCLE:Scale(scale)
		assert(isnumber(scale), string.format(err_number, type(scale)))
		if scale == 1 then return end

		self.m_Radius = self.m_Radius * scale

		if not self:IsValid() then return end

		local x, y = self.m_X, self.m_Y

		for i = 1, self.m_Vertices.Count do
			local vertex = self.m_Vertices[i]

			vertex.x = x + (vertex.x - x) * scale
			vertex.y = y + (vertex.y - y) * scale
		end

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Scale(scale)
		end
	end
end

do
	local err_number = "bad argument #1 to 'Rotate' (number expected, got %s)"

	function CIRCLE:Rotate(rotation)
		assert(isnumber(rotation), string.format(err_number, type(rotation)))
		if rotation == 0 then return end

		self.m_Rotation = self.m_Rotation + rotation

		if not self:IsValid() then return end

		local x, y = self.m_X, self.m_Y
		local vertices = self.m_Vertices
		local rotate_uv = self.m_RotateMaterial

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Rotate(rotation)
		end
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if default ~= nil and value == nil then
				value = default
			end

			if self[varname] ~= value then
				if dirty then
					self[dirty] = true
				end

				if isfunction(callback) then
					local new = callback(self, self[varname], value)
					value = new ~= nil and new or value
				end

				self[varname] = value
			end
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if not circle:IsValid() then return end

		circle:Translate(new - old, 0)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			OffsetVerticesX(circle.m_ChildCircle, old, new)
		end

		return new
	end

	local function OffsetVerticesY(circle, old, new)
		if not circle:IsValid() then return end

		circle:Translate(0, new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			OffsetVerticesY(circle.m_ChildCircle, old, new)
		end

		return new
	end

	local function UpdateRotation(circle, old, new)
		if not circle:IsValid() then return end

		local vertices = circle.m_Vertices
		local x, y = circle.m_X, circle.m_Y
		local rotation = new - old
		local rotate_uv = circle.m_RotateMaterial

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			UpdateRotation(circle.m_ChildCircle, old, new)
		end

		return new
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)
	AccessorFunc("ShouldRender", true)

	AccessorFunc("Color", false)				-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)				-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)			-- Sets whether or not the circle's UV points should be rotated with the vertices.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty")		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX)		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY)		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty")			-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty")		-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")		-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")			-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurLayers", 3)				-- The circle's blur layers if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurDensity", 2)				-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")		-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		x = tonumber(x) or 0
		y = tonumber(y) or 0

		self:Translate(x - self.m_X, y - self.m_Y)
	end

	function CIRCLE:SetAngles(s, e)
		s = tonumber(s) or self.m_StartAngle
		e = tonumber(e) or self.m_EndAngle

		self:SetDirty(self.m_Dirty or s ~= self.m_StartAngle or e ~= self.m_EndAngle)

		self.m_StartAngle = s
		self.m_EndAngle = e
	end

	function CIRCLE:GetPos()
		return self.m_X, self.m_Y
	end

	function CIRCLE:GetAngles()
		return self.m_StartAngle, self.m_EndAngle
	end
end

_R.Circles = {
	_MT = CIRCLE,

	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

wlib.Circles = _R.Circles

return _R.Circles
--addons/_wlib/lua/wlib/modules/func.lua:
wlib.func = wlib.func or {}

wlib.func.blank = function() end
wlib.func.yes = function() return true end
wlib.func.no = function() return false end

function wlib.func.chain(funcs)
    local i = 1
    local function run(...)
        local func = funcs[i]
        if func then
            i = i + 1
            func(run, ...)
        end
    end

    run()
end

local debId = 0
function wlib.func.debounce(func, delay)
	local name = tostring(func)..debId
    debId = debId + 1

	return function(...)
		local args = {...}
		timer.Create(name, delay, 1, fp{func, ...})
	end
end

function wlib.func.once(func)
    local done = false
    local res
    
    return function(...)
        if not done then
            res = func(...)
            done = true
        end
        return res
    end
end
--addons/_wlib/lua/wlib/modules/notification/shared.lua:
notification = notification or {}

NOTIFY_GENERIC = 0
NOTIFY_ERROR = 1
NOTIFY_UNDO = 2
NOTIFY_HINT = 3
NOTIFY_CLEANUP = 4
NOTIFY_POLICE = 5
NOTIFY_CHAT = 6

notification.Icons = {
	[NOTIFY_GENERIC] = Material('icon72/bulb.png'),
	[NOTIFY_ERROR] = Material('icon72/warning.png'),
	[NOTIFY_UNDO] = Material('icon72/leftwards_arrow_with_hook.png'),
	[NOTIFY_HINT] = Material('icon72/video_game.png'),
	[NOTIFY_CLEANUP] = Material('icon72/four_leaf_clover.png'),
	[NOTIFY_POLICE] = Material('icon72/rotating_light.png'),
	[NOTIFY_CHAT] = Material('icon72/speech_balloon.png'),
}
--addons/_wlib/lua/wlib/modules/notification/client.lua:
local surface = surface
local IsValid = IsValid
local LocalPlayer = LocalPlayer
local math = math
local table = table
local CurTime = CurTime
local string = string
local MsgC = MsgC
local Color = Color
local ipairs = ipairs
local hook = hook
local Material = Material
local ScrW = ScrW
local ScrH = ScrH
local draw = draw

local enabled_notify = CreateClientConVar("wrp_notifies_enabled", "1", true)
local align_notify = CreateClientConVar("wrp_notifies_align", "3", true)
local hudscale_cvar = CreateClientConVar('wayhud_scale', 0.75, true)
cvars.AddChangeCallback('wayhud_scale', function(cvar, old, new)
	surface.CreateFont('wlib_notify', {
		font = 'Roboto Bold',
		size = 19*(new/0.75),
		weight = 500,
		extended = true,
	})
end, 'hudnotify')

local cache = {}

ease = {}
function ease.quadOut( t, b, c, d )
	t = t / d;
	return -c * t * (t - 2) + b
end

surface.CreateFont('wlib_notify', {
	font = 'Roboto Bold',
	size = 19*(hudscale_cvar:GetFloat()/0.75),
	weight = 500,
	extended = true,
})

notification.Aligns = {
	-- снизу справа
	[0] = function(self, w, h, yoff, st)
		local mapoffset = (wmap.minimapEnabled and 455 or 120)*hudscale_cvar:GetFloat()
		local xoff = #g_VoicePanelList:GetChildren()*40 + mapoffset
		local hoffset = self.progress and 20 or 0
		return ScrW()-w-20, ScrH() - xoff - (yoff + h + hoffset) * st
	end,
    -- снизу по центру
	[1] = function(self, w, h, yoff, st)
		local hoffset = self.progress and 20 or 0
		return ScrW()/2-w/2, ScrH() - (yoff + h + hoffset) * st - 10
	end,
	-- справа сверху
	[2] = function(self, w, h, yoff, st)
		return ScrW()-w-20, (yoff + h) * st
	end,
}

function notification.AddLegacy( text, msgType, msgTime, align)
	if not IsValid(LocalPlayer()) then return end
	if not enabled_notify:GetBool() then return end

	LocalPlayer():EmitSound('ambient/water/rain_drip1.wav', 75, math.random(90,110), 0.5)

	text = wlib.string.wrap(text, 'wlib_notify', 400)

	surface.SetFont('wlib_notify')
	local textW, textH = surface.GetTextSize(text)
	
	table.insert(cache, 1, {
		startTime = CurTime(),
		removeTime = CurTime() + msgTime + 1.5,
		text = text,
		type = msgType,
		align = align or align_notify:GetInt(),
		a = 0,
		width = textW+24,
		height = textH+10,
	})

	MsgC(Color(200,150,50), 'УВЕДОМЛЕНИЕ', color_white, ': ' .. text .. '\n')
end

function notification.AddProgress(id, text, frac, type, align)
	if not IsValid(LocalPlayer()) then return end
	if not enabled_notify:GetBool() then return end

	for _, v in ipairs(cache) do
		if v.id and v.id == id then
			v.text = text
			v.frac = frac
			v.type = type
			return
		end
	end

	LocalPlayer():EmitSound('ambient/water/rain_drip1.wav', 75, math.random(90,110), 0.5)

	text = wlib.string.wrap(text, 'wlib_notify', 400)

	surface.SetFont('wlib_notify')
	local textW, textH = surface.GetTextSize(text)
	
	table.insert( cache, 1, {
		startTime = CurTime(),
		text = text,
		type = type,
		a = 0,
		id = id,
		frac = frac,
		progress = true,
		align = align or align_notify:GetInt(),
		width = textW+24,
		height = textH+10,
	})
end

function notification.Kill(id)
	for _, v in ipairs(cache) do
		if v.id and v.id == id then
			v.removeTime = CurTime()+0.5
		end
	end
end

hook.Add('Think', 'wlib_notify', function()
	for k=#cache, 1, -1 do
		local data = cache[k]
		if not data then return end

		local lifeTime = CurTime() - data.startTime
		local timeLeft = (data.removeTime or math.huge) - CurTime()

		data.a = (lifeTime < 1 and lifeTime) or (timeLeft < 0.5 and (timeLeft * 2)) or 1
		if timeLeft <= 0 then
			table.remove(cache, k)
		end
	end
end)

local color_progress_background = Color(35,40,45)
local color_background = Color(47,52,57)
local color_icon = Color(236,113,73)

local progress_back = Color(100,100,100)
local progress_line = Color(236,113,73)
hook.Add('PostRenderVGUI', 'wlib_notify', function()
	if enabled_notify:GetInt() == 0 then return end

	local drawOrder = {}
	local yoffs = {}
	for i = 1, #cache do
		local data = cache[i]

		data.align = notification.Aligns[data.align] and data.align or 0
		
		yoffs[data.align] = yoffs[data.align] or 0
		local yoff = yoffs[data.align]

		local st = ease.quadOut( data.a, 0, 1, 1 )
        
		local width, height = data.width, data.height
		local hoffset = data.progress and 20 or 0

		local align = notification.Aligns[data.align]
		local x, y = align(data, width, height, yoff, st)
		--local x, y = (ScrW() - width - 34) - 15, ScrH() - (yoff + h + hoffset) * st - 70
		yoffs[data.align] = yoff + (height + hoffset + 5) * st

		if data.progress then draw.RoundedBox(6, x, y - 5, width+16, height + hoffset, color_progress_background ) end
		draw.RoundedBox(6, x, y - 5, width+16, height, color_background )
		draw.RoundedBox(6, x, y - 5, 30, height, color_icon )

		draw.DrawText(data.text, 'wlib_notify', x + 34, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, st * 255 )
		if data.progress then
			local lineW = width+6
			if data.frac then
				local frac = data.frac
				draw.RoundedBox(0, x+5, y+height, lineW, 10, progress_back)
				draw.RoundedBox(0, x+5, y+height, frac*lineW, 10, progress_line)
			else
				--[[
				local frac = 1 - math.abs(math.sin(CurTime()))
				local width = (w+30)/3
				draw.RoundedBox(0, x-5, y+h+10, w+30, 10, progress_back)
				draw.RoundedBox(0, x-5+frac*(w+30-width), y+h+10, width, 10, progress_line)
				]]
				local frac = math.abs(math.sin(CurTime()))
				draw.RoundedBox(0, x+5, y+height, lineW, 10, progress_back)
				draw.RoundedBox(0, x+5, y+height, frac*lineW, 10, progress_line)
			end
		end

		surface.SetMaterial(notification.Icons[data.type] or notification.Icons[0])
		surface.SetDrawColor(color_white)
		surface.DrawTexturedRect(x+4, y+height/2-16, 22, 22)
	end
end)

net.Receive('wlib.notify', function()
    local type = net.ReadUInt(4)
    local len = net.ReadUInt(16)
    local text = net.ReadString()
    local align = net.ReadUInt(2)

    GAMEMODE:AddNotify(text, type, len, align)
end)
--addons/_wlib/lua/wlib/modules/players/shared.lua:
wlib.player = wlib.player or {}

local PLAYER = FindMetaTable('Player')

function PLAYER:IsVIP()
    return self:GetUserGroup() ~= 'user'
end

function player.GetVIP()
    local p = {}
    local count = 0

    for _, v in player.Iterator() do
        if v:IsVIP() then
            count = count + 1
            p[count] = v 
        end
    end
    return p
end

local nabor = {
    ['+Eventer'] = true,
    ['Helper'] = true,
    ['+Helper'] = true,
    ['moder'] = true,
    ['admin'] = true,
    ['Trusted'] = true,
    ['WayZer Team'] = true,
    ['superadmin'] = true,
}

function PLAYER:IsNabor()
    local usergroup = CLIENT and self == LocalPlayer() and self:GetRealUserGroup() or self:GetUserGroup()
    return nabor[usergroup] or false
end

function wlib.player.getNabor()
    local p = {}
    local count = 0

    for _, v in player.Iterator() do
        if v:IsNabor() then 
            count = count + 1
            p[count] = v 
        end
    end
    return p
end

local sadmin = {
    ['Trusted'] = true,
    ['WayZer Team'] = true,
    ['superadmin'] = true,
}

function PLAYER:IsRealSuperAdmin()
    return sadmin[self:GetUserGroup()] or false
end

function PLAYER:IsNonRP()
    return self:Team() == TEAM_ADMIN or self:Team() == TEAM_BANNED
end

local guns = {
    ['weapon_357'] = true,
    ['weapon_pistol'] = true,
    ['weapon_crossbow'] = true,
    ['weapon_ar2'] = true,
    ['weapon_rpg'] = true,
    ['weapon_shotgun'] = true,
    ['weapon_smg1'] = true,
}
function PLAYER:IsHoldingGun()
    local wep = self:GetActiveWeapon()
    if not IsValid(wep) then return false end

    if guns[wep:GetClass()] or wep.Base == 'swb_base' then return true end
    if wep:GetClass() == 'laserjetpack' and wep.GetDmg and wep:GetDmg() then return true end

    return false
end

function PLAYER:GetTeamColor()
    return hook.Run('GetTeamColor', self) or team.GetColor(self:Team())
end

function wlib.player.find(info)
    if not info or info == '' then return nil end
    local pls = player.GetAll()

    for i=1, #pls do
        local ply = pls[i]
        if tonumber(info) == ply:UserID() then
            return ply
        end

        if info == ply:DisplaySteamID() or info == ply:RealSteamID() then
            return ply
        end

        local succ, name = pcall(utf8.lower, ply:DisplayName())
        if succ and string.find(name, utf8.lower(tostring(info)), 1, true) ~= nil then
            return ply
        end

        local succ, name = pcall(utf8.lower, ply:SteamName())
        if succ and string.find(name, utf8.lower(tostring(info)), 1, true) ~= nil then
            return ply
        end
    end
    return nil
end

function wlib.player.findAll(info)
    if not info or info == '' then return {} end
    if info == '*' then return player.GetAll() end

    return wlib.array.filter(player.GetAll(), function(ply)
        if tonumber(info) == ply:UserID() then
            return true
        end

        if info == ply:DisplaySteamID() or info == ply:RealSteamID() then
            return true
        end

        local succ, name = pcall(utf8.lower, ply:DisplayName())
        if succ and string.find(name, utf8.lower(tostring(info)), 1, true) ~= nil then
            return true
        end

        local succ, name = pcall(utf8.lower, ply:SteamName())
        if succ and string.find(name, utf8.lower(tostring(info)), 1, true) ~= nil then
            return true
        end
    end)
end

nw.Register('SteamAvatar')
    :Write(net.WriteString)
    :Read(net.ReadString)
    :SetPlayer()
    :SetHook('SteamAvatarUpdated')

function PLAYER:GetAvatarHash()
    return self:GetNetVar('SteamAvatar')
end

function PLAYER:GetAvatarURL(type)
    return 'https://avatars.steamstatic.com/'..self:GetNetVar('SteamAvatar', '')..(type ~= nil and '_'..type or '')..'.jpg'
end
--addons/_wlib/lua/wlib/modules/transaction.lua:
local TRANSACTION = {}
TRANSACTION.__index = TRANSACTION

local lastId = 0

function TRANSACTION:func(f)
    local id = #self.funcs + 1
    
    local function finish(error)
        if self.stopped then return end

        if error then
            if self.fallback then self.fallback() end
            self:stop()
            return
        end

        table.insert(self.finished, id)
        if #self.finished >= #self.funcs then
            if self.callback then self.callback() end
        end
    end

    table.insert(self.funcs, function()
        f(finish)
    end)
end

function TRANSACTION:commit(cb, fb)
    if #self.funcs == 0 then
        if cb then cb() end
        return
    end
    
    self.callback = cb
    self.fallback = fb
    for _, func in ipairs(self.funcs) do
        func()
    end
end

function TRANSACTION:stop()
    self.stopped = true
end

function wlib.transaction(timeout)
    lastId = lastId + 1
    local tr = setmetatable({
        funcs = {},
        finished = {},
        timeout = timeout,
        id = lastId,
    }, TRANSACTION)

    return tr
end
--addons/_wlib/lua/wlib/modules/vars.lua:
wlib.vars = wlib.vars or {}
wlib.vars.list = wlib.vars.list or {}

local function load()
    local d = file.Read('wlib_vars.dat', 'DATA') or '[}'
    wlib.vars.data = pon.decode(d) or {}
end

local function save()
    file.Write('wlib_vars.dat', pon.encode(wlib.vars.data))
end
local saveAsync = wlib.func.debounce(save, 1)

function wlib.vars.set(id, val, now)
    if not istable(val) and wlib.vars.data[id] == val then return end
    wlib.vars.data[id] = val
    
    if now then
        save()
    else
        saveAsync()
    end
    hook.Run('wlib.setVar', id, val)
end

function wlib.vars.get(id, fallback)
    return wlib.vars.data[id] or fallback
end

function wlib.vars.default(id, val)
    if wlib.vars.data[id] == nil then wlib.vars.data[id] = val end
end

load()
--addons/_wlib/lua/wlib/vgui/circleavatar.lua:
local PANEL = {}

function PANEL:Init()
    self.avatar = vgui.Create('AvatarImage', self)
    self.avatar:SetPaintedManually(true)
    self.avatar:Dock(FILL)
end

local circle = wlib.Circles.New(CIRCLE_FILLED, 0, 0, 0)
function PANEL:Paint(w,h)
    render.ClearStencil()
    render.SetStencilEnable(true)

    render.SetStencilWriteMask(1)
    render.SetStencilTestMask(1)

    render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
    render.SetStencilPassOperation(STENCILOPERATION_ZERO)
    render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
    render.SetStencilReferenceValue(1)

    draw.NoTexture()
    surface.SetDrawColor(color_white)
    circle:SetRadius(h/2)
    circle:SetPos(w/2, h/2)
    circle()

    render.SetStencilFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
    render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
    render.SetStencilReferenceValue(1)

    self.avatar:PaintManual()

    render.SetStencilEnable(false)
    render.ClearStencil()
end

function PANEL:SetPlayer(...)
    self.avatar:SetPlayer(...)
end

function PANEL:SetSteamID(...)
    self.avatar:SetSteamID(...)
end

vgui.Register('wlib.circleAvatar', PANEL, 'DPanel')
--addons/module_scoreboard/lua/wayscore/vgui/view_player.lua:
local PANEL = {}
local color_scroll = Color(38, 42, 46, 255)

function PANEL:Init()
    self:Dock(FILL)
    self:GetCanvas():DockPadding(20,20,20,20)

    self.header = vgui.Create('Panel', self)
    self.header:Dock(TOP)
    self.header:DockPadding(10,10,10,10)
    self.header.Material = nil
    
    function self.header.Paint(s,w,h)
        if self.ply and self.ply.ProfileCover then
            surface.SetMaterial(self.ply.ProfileCover)
            surface.SetDrawColor(color_white)
            surface.DrawTexturedRect(0,0,w,h)
        end
    end
    
    self.PlayerInfo = vgui.Create('DListLayout', self.header)
    self.PlayerInfo:Dock(RIGHT)
    self.PlayerInfo:DockMargin(20,0,0,0)

    self.Avatar = vgui.Create('AvatarImage', self.header)
    self.Avatar:Dock(TOP)
    self.Avatar:SetPlayer(self.ply)
    self.Avatar:SetTall(160)

    self.Avatar.Button = vgui.Create('DButton', self.Avatar)
    self.Avatar.Button:Dock(FILL)
    self.Avatar.Button:SetText('')
    self.Avatar.Button.Paint = wlib.func.blank
    self.Avatar.Button.DoClick = function()
        if IsValid(self.ply) then
            gui.OpenURL('https://steamcommunity.com/profiles/'..self.ply:SteamID64())
        end
    end

    self.Avatar.Button:SetTooltip('Нажми чтобы перейти в профиль')
    
    self.BPLevel = LocalPlayer():GetBPLevel(waypass.GetActiveBP():GetID()) or '1'
    self.BPPremium = LocalPlayer():HasBP(waypass.GetActiveBP():GetID(), true)
    
    self.InfoPanel = vgui.Create('DPanel', self)
    self.InfoPanel:Dock(TOP)
    self.InfoPanel:DockMargin(0,10,0,0)
    self.InfoPanel:SetTall(82)
    self.InfoPanel.Paint = wlib.func.blank

    self.HorizontalScroll = vgui.Create( "DHorizontalScroller", self.InfoPanel )
    self.HorizontalScroll:Dock( FILL )
    self.HorizontalScroll:SetOverlap( -4 )

    self.BPPanel = vgui.Create('DPanel', self.InfoPanel)
    self.BPPanel:Dock(LEFT)
    self.BPPanel:DockMargin(0,0,5,0)
    self.BPPanel:SetWide(250)
    self.HorizontalScroll:AddPanel( self.BPPanel )
    
    self.BPImage = vgui.Create('DImage', self.BPPanel)
    self.BPImage:Dock(LEFT)
    self.BPImage:DockMargin(10,10,10,10)
    self.BPImage:SetMaterial('data/wimages/bp.png')
    
    self.BPInfo = vgui.Create('DPanel', self.BPPanel)
    self.BPInfo:Dock(FILL)
    --self.CInfo:SetWide(200)
    self.BPInfo.Paint = function(s,w,h)
       draw.SimpleText('Уровень БП: '..self.BPLevel, 'chelog-ib.small', 10,10,color_white)
       draw.SimpleText('Премиум: '..(self.BPPremium and 'Есть' or 'Нет'), 'chelog-ib.small', 10,30,color_white)
    end
    
    function self.BPPanel:Paint(w, h)
        draw.RoundedBox(6, 0, 0, w, h, color_scroll)
    end

    self.clan = dOrgs.orgs[LocalPlayer():GetMainOrgID()]
    if clan ~= nil then
        self.clanmember = LocalPlayer():GetOrgMember(LocalPlayer():GetMainOrgID()):GetRank():GetName()
    end
    
    self.CPanel = vgui.Create('DPanel', self.InfoPanel)
    self.CPanel:Dock(LEFT)
    self.CPanel:DockMargin(0,0,5,0)
    self.CPanel:SetWide(400)
    self.HorizontalScroll:AddPanel( self.CPanel )

    self.CImage = vgui.Create('DImage', self.CPanel)
    self.CImage:Dock(LEFT)
    self.CImage:DockMargin(10,10,10,10)
    self.CImage:SetMaterial('icon72/x.png')
    
    self.CInfo = vgui.Create('DPanel', self.CPanel)
    self.CInfo:Dock(FILL)
    --self.CInfo:SetWide(200)
    self.CInfo.Paint = function(s,w,h)
       draw.SimpleText('Организация: '..self.clan.name, 'chelog-ib.small', 10,10,color_white)
       draw.SimpleText('Ранг: '..self.clanmember, 'chelog-ib.small', 10,30,color_white)
       draw.SimpleText('Участников: '..table.Count(self.clan.members) or '', 'chelog-ib.small', 10,50,color_white)
    end

    function self.CPanel:Paint(w, h)
        draw.RoundedBox(6, 0, 0, w, h, color_scroll)
    end

    local vbar = self:GetVBar()
    vbar.Paint = function( s, w, h )
        draw.RoundedBox( 4, 3, 13, 8, h - 20, Color(60,60,60))
    end
    vbar.btnUp.Paint = function( s, w, h ) end
    vbar.btnDown.Paint = function( s, w, h ) end
    vbar.btnGrip.Paint = function( s, w, h )
        draw.RoundedBox( 4, 5, 0, 4, h, color_scroll)
    end

    self.cat = vgui.Create('DCollapsibleCategory', self)
    self.cat:Dock(TOP)
    self.cat:DockMargin(0,10,0,0)
    self.cat.Paint = function(s, w, h)
        draw.RoundedBox(6, 5, 0, w - 10, 22, color_scroll)
        draw.SimpleText('Команды', 'chelog-ib.small', 12, 0, Color(255, 255, 255))
    end
    self.cat:SetLabel('')
    self.cat:SetVisible(true)
    self.cat:SetTall(400)
    
    --self.cat.Toggle = wlib.func.blank

    self.cat.list = vgui.Create('FAdminPanelList', self.cat)
    self.cat.list:SetSpacing(5)
    self.cat.list:EnableHorizontal(true)
    self.cat.list:EnableVerticalScrollbar(true)
    self.cat.list:SizeToContents()
    self.cat.list:SetVisible(true)
    self.cat.list:Dock(TOP)
    self.cat.list:DockMargin(5, 5, 5, 5)
    self.cat.list:SetTall(400)
end


function PANEL:PerformLayout(w, h)
    w, h = self:GetCanvas():GetSize()
    self.PlayerInfo:SetWide(w-60-180)
end

function PANEL:SetPlayer(ply)
    if not IsValid(ply) then return end
    
    local main = self
    self.ply = ply
    self.Avatar:SetSteamID(self.ply:SteamID64(), 184)
    self.PlayerInfo:Clear()

    for _, v in SortedPairsByMemberValue(wayscore.Information, 'order') do
        local Value = v.get(self.ply)

        if Value and Value ~= '' then
            local Text = vgui.Create('DLabel')
            Text:Dock(TOP)
            Text:SetFont('chelog-ib.small')
            Text:SetText(v.name .. ': ' .. Value)
            Text:SizeToContents()
            Text:SetColor(color_white)
            if not v.callback then Text:SetTooltip('Нажми чтобы скопировать в буфер обмена') end

            function Text:OnMousePressed(mcode)
                if v.callback then return v.callback(main.ply, Value) end
                SetClipboardText(Value)
            end

            function Text:OnCursorEntered()
                Text:SetCursor("hand")
            end

            timer.Create('wayscore_updateinfo_' .. v.name, 1, 0, function()
                if not IsValid(self.ply) or not IsValid(self) or not IsValid(Text) then
                    timer.Remove('wayscore_updateinfo_' .. v.name)

                    if wayscore:IsVisible() then
                        wayscore:SelectView('main')
                    end

                    return
                end

                Value = v.get(self.ply)

                if not Value or Value == "" then
                    Value = "N/A"
                end

                Text:SetText(wlib.string.wrap(v.name .. ": " .. Value, Text:GetFont(), Text:GetWide()))
            end)

            self.PlayerInfo:Add(Text)
        end
    end

    self.PlayerInfo:SizeToChildren(false, true)
    self.header:SizeToChildren(false, true)
    
    self.clan = dOrgs.orgs[ply:GetMainOrgID()]

    if self.clan ~= nil then
        self.clanmember = ply:GetOrgMember(ply:GetMainOrgID()):GetRank():GetName()
        self.CPanel:SetVisible(true)
        self.CPanel:Dock(LEFT)
        self.CImage:SetMaterial(self.clan.AvatarMaterial or 'icon72/x.png')
    else
        self.CPanel:SetVisible(false) 
        self.CPanel:Dock(NODOCK)    
    end
    
    self.BPLevel = ply:GetBPLevel(waypass.GetActiveBP():GetID()) or '1'
    self.BPPremium = ply:HasBP(waypass.GetActiveBP():GetID(), true)


    self.cat.list:Clear()
    for _, v in SortedPairsByMemberValue(wayscore.ActionButtons, 'order') do
        if v.check and not v.check(self.ply) then continue end

        local ActionButton = vgui.Create('wayscore_button')
        ActionButton:SetData(v, self.ply)

        function ActionButton:DoClick()
            if IsValid(main.ply) then return v.callback(main.ply, self) end
        end

        self.cat.list:AddItem(ActionButton)
        self.cat.list:SizeToContents()
        self.cat.list:SizeToChildren(false, true)
        self.cat:SizeToChildren(false, true)
        if v.onCreated then
            v.onCreated(self.ply, ActionButton)
        end
    end
    self.cat.list:SetTall(400)
end

function PANEL:Think()
    if not IsValid(self.ply) then wayscore:SelectView('main') end
end

function PANEL:Select(ply)
    self:SetPlayer(ply)
end

vgui.Register('wayscore_view_player', PANEL, 'DScrollPanel')
--addons/weapon_wowozela/lua/autorun/wowozela.lua:
if SERVER then
    AddCSLuaFile()
    resource.AddWorkshop("108170491")
end

local wowozela = _G.wowozela or {}
_G.wowozela = wowozela

wowozela.ValidNotes = {
    ["Left"] = IN_ATTACK,
    ["Right"] = IN_ATTACK2
}

wowozela.ValidKeys = {IN_ATTACK, IN_ATTACK2, IN_WALK, IN_SPEED, IN_USE}

wowozela.KnownSamples = wowozela.KnownSamples or {}
wowozela.Samplers = wowozela.Samplers or {}

function wowozela.GetSamples()
    return wowozela.KnownSamples
end

function wowozela.GetSample(i)
    return wowozela.KnownSamples[i]
end



if CLIENT then
    wowozela.volume = CreateClientConVar("wowozela_volume", "0.5", true, false)
    wowozela.hudtext = CreateClientConVar("wowozela_hudtext", "1", true, false)
    wowozela.pitchbar = CreateClientConVar("wowozela_pitchbar", "1", true, false)
    wowozela.help = CreateClientConVar("wowozela_help", "1", true, false)
    wowozela.defaultpage = CreateClientConVar("wowozela_defaultpage", "", true, false)

    local function set_sample_index(which, note_index)
        local wep = LocalPlayer():GetActiveWeapon()

        if not wep:IsValid() or wep:GetClass() ~= "wowozela" then
            return
        end

        net.Start("wowozela_select_" .. which)
        net.WriteInt(note_index, 32)
        net.SendToServer()

        if not wowozela.KnownSamples[note_index] then
            print("wowozela " .. which .. ": note index " .. note_index .. " is out of range")
        end
    end

    function wowozela.SetSampleIndexLeft(noteIndex)
        return set_sample_index("left", noteIndex)
    end

    function wowozela.SetSampleIndexRight(noteIndex)
        return set_sample_index("right", noteIndex)
    end


    function wowozela.RequestCustomSamplesIndexes(samples)
        net.Start("wowozela_customsample")
            net.WriteTable(samples)
        net.SendToServer()
    end

    local function update_sample(ply, i, v)
        local sampler = wowozela.GetSampler(ply)
        if not sampler then return end
        if v then
            sampler:SetSample(i, v.custom, v.path)
        elseif sampler.Samples and sampler.Samples[i] then
            if IsValid(sampler.Samples[i].obj) then
                sampler.Samples[i].obj:Stop()
            end
            sampler.Samples[i] = nil
        end
    end

    net.Receive("wowozela_update_samples", function()
        for i, v in pairs(net.ReadTable()) do
            wowozela.KnownSamples[i] = v
        end

        if not net.ReadBool() then
            local updatedPly = 4500 + net.ReadUInt(6) * 15
            for _, ply in player.Iterator() do
                for i = updatedPly, updatedPly + 11 do
                    local v = wowozela.KnownSamples[i]
                    update_sample(ply, i, v)
                end
            end
            return
        end

        wowozela.SetSampleIndexLeft(1)
        wowozela.SetSampleIndexRight(1)

        for _, ply in player.Iterator() do
            local sampler = wowozela.GetSampler(ply)
            if sampler then
                for _,v in pairs(sampler.Samples or {}) do
                    if v.obj then
                        v.obj:Stop()
                    end
                end
                wowozela.CreateSampler(ply)
            end
            local wep = ply:GetActiveWeapon()
            if wep:IsValid() and wep:GetClass() == "wowozela" then
                wep:LoadPages()
            end
        end
    end)

    local FOLDER = "wowozela_cache"
    file.CreateDir(FOLDER, "DATA")
    local ID_OGG = "\x4F\x67\x67\x53"
    local ID_ID3 = "\x49\x44\x33"
    local ID_MP3_1 = "\xFF\xFB"
    local ID_MP3_2 = "\xFF\xF3"
    local ID_MP3_3 = "\xFF\xF2"
    local FILE_LIMIT_MB = 10
    local FILE_LIMIT = FILE_LIMIT_MB * 1024 * 1024
    local function isOGGorMP3(data)
        return  data:sub(1, 3) == ID_ID3 or
                data:sub(1, 4) == ID_OGG or
                data:sub(1, 2) == ID_MP3_1 or
                data:sub(1, 2) == ID_MP3_2 or
                data:sub(1, 2) == ID_MP3_3
    end
    local function GetURLSound(url, back, fail)
        if url == "" then return end
        local path = FOLDER .. "/" .. util.CRC(url) .. ".dat"

        local exists = file.Exists(path, "DATA")
        if exists then
            back("data/" .. path)
            return
        end

        http.Fetch(url,function(data,len,hdr,code)
            if string.len(data) > FILE_LIMIT then
                return fail(("Too big (>%s MB)."):format(FILE_LIMIT_MB))
            end
            if not isOGGorMP3(data) then
                return fail("Not an ogg/mp3, or download failed.")
            end
            file.Write(path, data)
            back("data/" .. path)
        end, function(err)
            fail(("HTTP %s"):format(err))
        end, {
            ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.214 Safari/537.36 Vivaldi/3.8.2259.42"
        })
    end

    local patterns = {
        ["^https?://drive%.google%.com/file/d/(.-)/"] = "https://drive.google.com/u/0/uc?id=%s&export=download",
        ["^https?://drive%.google%.com/file/d/(.-)$"] = "https://drive.google.com/u/0/uc?id=%s&export=download",
        ["^https?://drive%.google%.com/open%?id=(.-)$"] = "https://drive.google.com/u/0/uc?id=%s&export=download",
        ["^https?://www%.dropbox%.com/s/(.+)%?dl%=[01]$"] = "https://dl.dropboxusercontent.com/s/%s",
        ["^https?://www%.dropbox%.com/s/(.+)$"] = "https://dl.dropboxusercontent.com/s/%s",
        ["^https?://dl%.dropbox%.com/s/(.+)%?dl%=[01]$"] = "https://dl.dropboxusercontent.com/s/%s",
        ["^https?://dl%.dropbox%.com/s/(.+)$"] = "https://dl.dropboxusercontent.com/s/%s",
        ["^https://vocaroo.com/(.+)$"] = "https://media1.vocaroo.com/mp3/%s",
    }
    function wowozela.ProcessURL(url)
        for pattern, replace in pairs(patterns) do
            local match = string.match(url, pattern)
            if match then
                return string.format(replace, match), match
            end
        end

        return url
    end

    function wowozela.PlayURL(name, settings, callback, failurecallback)
        if #name == 0 then return failurecallback and failurecallback("Empty URL?") end
        if not wowozela.URLWhitelist(name) then
            return failurecallback and failurecallback("Not a whitelisted URL.")
        end

        name = wowozela.ProcessURL(name)
        GetURLSound(name, function(sndPath)
            sound.PlayFile(sndPath, settings, callback)
        end, failurecallback or wlib.func.blank)
    end
end

if SERVER then
    wowozela.allowcustomsamples = CreateConVar("wowozela_customsamples", "1", {FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY})
    net.Receive("wowozela_customsample", function(_, ply)
        if not wowozela.allowcustomsamples:GetBool() then return end

        local samples = net.ReadTable()
        local startID = 4500 + ply:EntIndex() * 15
        for I = startID, startID + 11 do
            wowozela.KnownSamples[I] = nil
        end

        local newSamples = {}
        for k,v in pairs(samples) do
            local newSample = {
                category = "custom-sample-hidden",
                owner = ply:EntIndex(),
                custom = true,
                path = v[1],
                name = v[2]
            }

            wowozela.KnownSamples[startID + k] = newSample
            newSamples[startID + k] = newSample
        end

        net.Start("wowozela_update_samples")
            net.WriteTable(newSamples)
            net.WriteBool(false)
            net.WriteUInt(ply:EntIndex(), 6)
        net.Broadcast()
    end)



    for key, in_enum in pairs(wowozela.ValidNotes) do
        util.AddNetworkString("wowozela_select_" .. key)

        net.Receive("wowozela_select_" .. key:lower(), function(len, ply)
            local wep = ply:GetActiveWeapon()
            if wep:IsValid() and wep:GetClass() == "wowozela" then
                local value = net.ReadInt(32)
                local function_name = "SetNoteIndex" .. key

                if wep[function_name] then
                    wep[function_name](wep, value)
                    net.Start("wowozela_sample")
                    net.WriteEntity(ply)
                    net.WriteInt(in_enum, 32)
                    net.WriteInt(value, 32)
                    net.Broadcast()
                end
            end
        end)
    end

    function wowozela.LoadSamples()
        wowozela.KnownSamples = {}

        local _, directories = file.Find("sound/wowozela/samples/*", "GAME")

        for _, directory in ipairs(directories) do
            for _, file_name in ipairs(file.Find("sound/wowozela/samples/" .. directory .. "/*", "GAME")) do
                if file_name:EndsWith(".ogg") or file_name:EndsWith(".mp3") then
                    if file_name == 'saw880.ogg' or file_name == 'square880.ogg' or file_name == 'airhorn.ogg' then continue end
                    table.insert(wowozela.KnownSamples, {
                        category = directory,
                        path = "wowozela/samples/" .. directory .. "/" .. file_name,
                        name = file_name:match("(.+)%.")
                    })
                end
            end
        end

        table.sort(wowozela.KnownSamples, function(a, b)
            return a.path < b.path
        end)
    end

    wowozela.LoadSamples()

    util.AddNetworkString("wowozela_customsample")
    util.AddNetworkString("wowozela_update_samples")
    util.AddNetworkString("wowozela_key")
    util.AddNetworkString("wowozela_sample")

    resource.AddWorkshop("108170491")

    function wowozela.BroacastSamples(ply)
        net.Start("wowozela_update_samples")
        net.WriteTable(wowozela.KnownSamples)
        net.WriteBool(true)
        net.Send(ply)
    end

    hook.Add("PlayerInitialSpawn", "send_wowozela_samples", function(ply)
        timer.Simple(60, function()
            wowozela.BroacastSamples(ply)
        end)
    end)
end

function wowozela.IsValidKey(key)
    return table.HasValue(wowozela.ValidKeys, key)
end

function wowozela.KeyToButton(key)
    for k, v in pairs(wowozela.ValidNotes) do
        if v == key then
            return k
        end
    end
    return false
end


do -- sample meta
    local META = {}
    META.__index = META

    META.Weapon = NULL

    function META:Initialize(ply)
        ply.wowozela_sampler = self

        self.Player = NULL

        self.Pitch = 100
        self.Volume = 1

        self.Keys = {}
        self.Samples = {}

        self.Player = ply
        for i, sample in pairs(wowozela.KnownSamples) do
            self:SetSample(i, sample.custom, sample.path)
        end

        self.KeyToSample = {}
    end

    function META:KeyToSampleIndex(key)
        local button = wowozela.KeyToButton(key)
        if button then
            local wep = self.Player:GetActiveWeapon()
            local get = "GetNoteIndex" .. button
            if wep:IsWeapon() and wep:GetClass() == "wowozela" and wep[get] then
                return wep[get](wep)
            end
        end
    end

    function META:CanPlay()
        local wep = self.Player:GetActiveWeapon()
        if wep:IsWeapon() and wep:GetClass() == "wowozela" then
            self.Weapon = wep
            return true
        end

        return false
    end

    function META:GetPos()
        if self.Player == LocalPlayer() and not self.Player:ShouldDrawLocalPlayer() then
            return self.Player:EyePos()
        end

        local id = self.Player:LookupBone("ValveBiped.Bip01_Head1")
        local pos = id and self.Player:GetBonePosition(id)
        return pos or self.Player:EyePos()
    end

    function META:GetAngles()
        local ang = self.Player:GetAimVector():Angle()

        ang.r = 0

        return ang
    end

    function META:IsPlaying() -- hm
        for _, on in pairs(self.Keys) do
            if on then
                return true
            end
        end

        return false
    end

    local function create_sound(path, isHttp, sampler)
        if SERVER then return end
        local processing = false
        local _smeta = {
            __index = function(self, index)
                if index == "create" then
                    return function(callback)
                        if IsValid(rawget(self, "obj")) then
                            callback()
                        else
                            if processing then return end
                            processing = true
                            local func, newPath =  (isHttp and wowozela.PlayURL or sound.PlayFile), isHttp and path or "sound/" .. path
                            func(newPath, "3d noplay noblock", function(snd, errnum, err)
                                if not snd or err then return end
                                processing = false
                                self.paused = true
                                self.looping = true
                                self.obj = snd
                                snd:EnableLooping(true)
                                snd:SetVolume(wowozela.intvolume or 1)
                                snd:SetPlaybackRate((sampler.Pitch or 100) / 100)
                                snd:Set3DEnabled(sampler.Player ~= LocalPlayer())
                                callback()
                            end)
                        end
                    end
                end
                return rawget(self, index)
            end
        }

        return setmetatable({}, _smeta)
    end

    local function set_volume(snd, num, sampler)
        if not IsValid(snd.obj) then return end

        snd.obj:SetVolume(num * (wowozela.intvolume or 1))
        snd.obj:SetPos(sampler.Player:EyePos(), sampler.Player:GetAimVector())
    end

    local function set_pitch(snd, num, sampler)
        if not IsValid(snd.obj) then return end

        snd.obj:SetPlaybackRate(num / 100)
        snd.obj:SetPos(sampler.Player:EyePos(), sampler.Player:GetAimVector())
    end

    local function stop_sound(snd, sampler)
        if not IsValid(snd.obj) then return end
        if snd.paused then return end

        snd.obj:Pause()
        snd.obj:SetTime(0)
        snd.paused = true
    end

    local function play_sound(snd, sampler)
        if not IsValid(snd.obj) then return end
        if not snd.paused or wowozela.disabled then return end

        snd.obj:Play()
        snd.obj:SetPos(sampler.Player:EyePos(), sampler.Player:GetAimVector())

        snd.paused = false
    end

    function META:SetSample(i, ishttp, path)
        if self.Samples[i] and IsValid(self.Samples[i].obj) then
            self.Samples[i].obj:Stop()
            self.Samples[i].obj = nil
        end
        self.Samples[i] = create_sound(path or wowozela.DefaultSound, ishttp, self)
    end

    function META:SetPitch(num) -- ???
        num = num or 1

        if self:IsKeyDown(IN_WALK) then
            num = num - 7 / 12
        end

        local lastPitch = self.Pitch
        self.Pitch = math.Clamp(math.floor((100 * 2 ^ num) * 100) / 100, 0.01, 2048)
        if lastPitch ~= self.Pitch then
            for _, sample in pairs(self.Samples) do
                set_pitch(sample, self.Pitch, self)
            end
        end
    end

    function META:SetVolume(num)
        local lastVol = self.Volume
        self.Volume = math.Clamp(num or self.Volume, 0.0001, 1)

        if lastVol ~= self.Volume then
            for _, sample in pairs(self.Samples) do
                set_volume(sample, self.Volume, self)
            end
        end
    end

    cvars.AddChangeCallback("wowozela_volume", function(cvar, oldval, newval)
        if SERVER then return end
        if oldval == newval then return end

        local vol = tonumber(newval) or 0.5
        wowozela.intvolume = math.Clamp(vol, 0, 1)
        wowozela.disabled = vol < 0.01

        for _, ply in player.Iterator() do
            local sampler = wowozela.GetSampler(ply)

            if sampler and sampler.Samples then
                for _, sample in pairs(sampler.Samples) do
                    set_volume(sample, sampler.Volume, sampler)
                end
            end
        end
    end, "wowozela")

    function META:Start(sample_index, key)
        if not self:CanPlay() then
            return
        end

        local sample = self.Samples[sample_index]
        if not sample then
            return
        end

        if key then
            local previous_sample = self.KeyToSample[key]
            if previous_sample then
                stop_sound(previous_sample, self)
            end

            self.KeyToSample[key] = sample


            sample.create(function()
                if self.KeyToSample[key] == sample then
                    play_sound(sample, self)
                end
            end)
        end
    end

    function META:Stop(sample_index, key)
        local sample = self.Samples[sample_index]
        if not sample then
            return
        end

        if sample == self.last_sample then return end
        if key then
            for k,v in pairs(self.KeyToSample) do
                if v == sample and key ~= k then

                    stop_sound(sample, self)
                    play_sound(sample, self)

                    self.KeyToSample[key] = nil
                    return
                end
            end

            local previous_sample = self.KeyToSample[key]
            if previous_sample then
                stop_sound(previous_sample, self)
                -- previous_sample:Stop() 
            end

            self.KeyToSample[key] = nil
        end

        if sample then
            -- sample:Stop()
            stop_sound(sample, self)
        end
    end

    function META:IsKeyDown(key)
        return self.Keys[key] == true
    end

    function META:OnKeyEvent(key, press)
        local id = self:KeyToSampleIndex(key)
        if id then
            if press then
                self:Start(id, key)
                self:SetVolume(1)
            else
                self:Stop(id, key)
            end
        end
    end
    function META:GetPlayerPitch()
        local ply = self.Player

        if ply.wowozela_real_pitch then
            return -(ply.wowozela_real_pitch / 90)
        end

        local pitch = self:GetAngles().p
        return -pitch / 89
    end

    function META:Think()
        if not self:CanPlay() or wowozela.disabled then
           -- if self.WasPlaying then
           --     for _, csp in pairs(self.Samples) do
           --         if not csp.paused then
           --             stop_sound(csp, self)
           --         end
           --     end
           --     self.WasPlaying = false
           -- end
            return
        end

        self.WasPlaying = true
        local wep = self.Player:GetActiveWeapon()
        if wep.GetLooping and not wep:GetLooping() then
            for k,v in pairs(self.Samples) do
                if IsValid(v.obj) and v.looping then
                    v.obj:EnableLooping(false)
                    v.obj:SetTime(0)
                    v.looping = false
                end
            end
        else
            for k,v in pairs(self.Samples) do
                if IsValid(v.obj) and not v.looping then
                    v.obj:EnableLooping(true)
                    v.obj:SetTime(0)
                    v.looping = true
                end
            end
        end

        self:SetPitch(self:GetPlayerPitch())
    end

    local emitter
    local function fade_in(p)
        local f = p:GetLifeTime()
        p:SetStartSize(p:GetRoll() * (f ^ 0.25))
        if f < 1 then
            p:SetNextThink(CurTime())
        end
    end

    function META:Destroy()
        for _,v in pairs(self.Samples) do
            if v.obj then
                v.obj:Stop()
                v.obj = nil
            end
        end

        self.Samples = {}
    end

    wowozela.SamplerMeta = META

    function wowozela.CreateSampler(ply)
        local sampler = setmetatable({}, wowozela.SamplerMeta)
        sampler:Initialize(ply)
        ply.wowozela_sampler = sampler

        wowozela.Samplers[ply:UserID()] = sampler
        return sampler
    end

    function wowozela.GetSampler(ply)
        return ply.wowozela_sampler
    end
end

do -- hooks
    function wowozela.KeyEvent(ply, key, press)
        local sampler = wowozela.GetSampler(ply)
        if sampler and sampler.OnKeyEvent and ply == sampler.Player then
            sampler.Keys[key] = press
            return sampler:OnKeyEvent(key, press)
        end
    end

    timer.Create('wowozela_think', 1, 0, function()
        if not wowozela.KnownSamples[1] then
            return
        end

        if CLIENT then
            local vol = wowozela.volume:GetFloat()
            wowozela.intvolume = math.Clamp(vol, 0, 1)
            wowozela.disabled = vol < 0.01
        end

        for _, ply in player.Iterator() do
            local sampler = wowozela.GetSampler(ply)

            if not sampler then
                sampler = wowozela.CreateSampler(ply)
            end

            if sampler and sampler.Think then
                sampler:Think()
            end
        end

        for k, sampler in next, wowozela.Samplers do
            if not IsValid(sampler.Player) then
                sampler:Destroy()
                wowozela.Samplers[k] = nil
            end
        end
    end)

    hook.Remove("Think", "wowozela_think")


    /*
    function wowozela.Draw()
        if not wowozela.KnownSamples[1] then
            return
        end

        for key, ply in pairs(player.GetHumans()) do
            local sampler = wowozela.GetSampler(ply)

            if sampler and sampler.Draw then
                sampler:Draw()
            end
        end
    end

    hook.Add("PostDrawOpaqueRenderables", "wowozela_draw", wowozela.Draw)
    */

    hook.Remove("PostDrawOpaqueRenderables", "wowozela_draw")

    function wowozela.BroadcastKeyEvent(ply, key, press, filter)
        net.Start("wowozela_key", true)
        net.WriteEntity(ply)
        net.WriteInt(key, 32)
        net.WriteBool(press)
        if not filter then
            net.SendOmit(ply)
        else
            net.Broadcast()
        end
    end

    hook.Add("KeyPress", "wowozela_keypress", function(ply, key)
        if not IsFirstTimePredicted() and not game.SinglePlayer() then
            return
        end

        local wep = ply:GetActiveWeapon()
        if wep:IsValid() and wep:GetClass() == "wowozela" and wowozela.IsValidKey(key) then
            if SERVER and wep.OnKeyEvent then
                wowozela.BroadcastKeyEvent(ply, key, true)
                wep:OnKeyEvent(key, true)
            end

            if CLIENT then
                wowozela.KeyEvent(ply, key, true)
            end
        end
    end)

    hook.Add("KeyRelease", "wowozela_keyrelease", function(ply, key)
        if not IsFirstTimePredicted() and not game.SinglePlayer() then
            return
        end

        local wep = ply:GetActiveWeapon()
        if wep:IsValid() and wep:GetClass() == "wowozela" and wowozela.IsValidKey(key) then
            if SERVER and wep.OnKeyEvent then
                wowozela.BroadcastKeyEvent(ply, key, false)
                wep:OnKeyEvent(key, false)
            end

            if CLIENT then
                wowozela.KeyEvent(ply, key, false)
            end
        end
    end)

    if CLIENT then

        net.Receive("wowozela_sample", function()
            local ply = net.ReadEntity()
            if not ply:IsValid() then
                return
            end
            local sampler = wowozela.GetSampler(ply)
            if not sampler then
                return
            end
            local key = net.ReadInt(32)
            local id = net.ReadInt(32)

            if sampler:IsPlaying() then
                sampler:Start(id, key)
            end
        end)

        net.Receive("wowozela_key", function()
            local ply = net.ReadEntity()
            if not ply:IsValid() or not wowozela.GetSampler(ply) then
                return
            end
            local key = net.ReadInt(32)
            local press = net.ReadBool()

            wowozela.KeyEvent(ply, key, press)
        end)
    end
end

if CLIENT then
    for _, ply in player.Iterator() do
        wowozela.CreateSampler(ply)
    end
end

if SERVER then
    timer.Simple(0.1, function()
        for _, ply in player.Iterator() do
            wowozela.BroacastSamples(ply)
        end
    end)
end


---------------------------------------------
-- https://github.com/Metastruct/gurl/     --
---------------------------------------------
local URLWhiteList = {}

local TYPE_SIMPLE = 1
local TYPE_PATTERN = 2
local TYPE_BLACKLIST = 4

local function pattern(pattern)
  URLWhiteList[#URLWhiteList + 1] = {TYPE_PATTERN, "^http[s]?://" .. pattern}
end
local function simple(txt)
  URLWhiteList[#URLWhiteList + 1] = {TYPE_SIMPLE, "^http[s]?://" .. txt}
end
local function blacklist(txt)
  URLWhiteList[#URLWhiteList + 1] = {TYPE_BLACKLIST, txt}
end


simple [[www.dropbox.com/s/]]
simple [[dl.dropboxusercontent.com/]]
simple [[dl.dropbox.com/]] --Sometimes redirects to usercontent link

-- OneDrive
-- Examples: 
-- https://onedrive.live.com/redir?resid=123!178&authkey=!gweg&v=3&ithint=abcd%2cefg

simple [[onedrive.live.com/redir]]

-- Google Drive
--- Examples: 
---  https://docs.google.com/uc?export=download&confirm=UYyi&id=0BxUpZqVaDxVPeENDM1RtZDRvaTA

simple [[docs.google.com/uc]]
simple [[drive.google.com/file/d/]]
simple [[drive.google.com/u/0/uc]]
simple [[drive.google.com/open]]

--[=[
-- Imgur
--- Examples: 
---  http://i.imgur.com/abcd123.xxx

simple [[i.imgur.com/]]


-- pastebin
--- Examples: 
---  http://pastebin.com/abcdef

simple [[pastebin.com/]]
]=]

-- github / gist
--- Examples: 
---  https://gist.githubusercontent.com/LUModder/f2b1c0c9bf98224f9679/raw/5644006aae8f0a8b930ac312324f46dd43839189/sh_sbdc.lua
---  https://raw.githubusercontent.com/LUModder/FWP/master/weapon_template.txt

simple [[raw.githubusercontent.com/]]
simple [[gist.githubusercontent.com/]]
simple [[github.com/]]
simple [[www.github.com/]]

-- pomf
-- note: there are a lot of forks of pomf so there are tons of sites. I only listed the mainly used ones. --Flex
--- Examples: 
---  https://my.mixtape.moe/gxiznr.png
---  http://a.1339.cf/fppyhby.txt
---  http://b.1339.cf/fppyhby.txt
---  http://a.pomf.cat/jefjtb.txt

simple [[my.mixtape.moe/]]
simple [[a.1339.cf/]]
simple [[b.1339.cf/]]
simple [[a.pomf.cat/]]

--[=[
-- TinyPic
--- Examples: 
---  http://i68.tinypic.com/24b3was.gif
pattern [[i(.+)%.tinypic%.com/]]


-- paste.ee
--- Examples: 
---  https://paste.ee/r/J3jle
simple [[paste.ee/]]


-- hastebin
--- Examples: 
---  http://hastebin.com/icuvacogig.txt
simple [[hastebin.com/]]
]=]

-- puush
--- Examples:
---  http://puu.sh/asd/qwe.obj
simple [[puu.sh/]]

-- Steam
--- Examples:
---  http://images.akamai.steamusercontent.com/ugc/367407720941694853/74457889F41A19BD66800C71663E9077FA440664/
---  https://steamcdn-a.akamaihd.net/steamcommunity/public/images/apps/4000/dca12980667e32ab072d79f5dbe91884056a03a2.jpg
simple [[images.akamai.steamusercontent.com/]]
simple [[steamcdn-a.akamaihd.net/]]
simple [[steamcommunity.com/]]
simple [[www.steamcommunity.com/]]
simple [[store.steampowered.com/]]
blacklist [[steamcommunity.com/linkfilter/]]
blacklist [[www.steamcommunity.com/linkfilter/]]

---------------------------------------------
-- https://github.com/thegrb93/StarfallEx/ --
---------------------------------------------

-- Discord
--- Examples:
---  https://cdn.discordapp.com/attachments/269175189382758400/421572398689550338/unknown.png
---  https://images-ext-2.discordapp.net/external/UVPTeOLUWSiDXGwwtZ68cofxU1uaA2vMb2ZCjRY8XXU/https/i.imgur.com/j0QGfKN.jpg?width=1202&height=677

pattern [[cdn[%w-_]*.discordapp%.com/(.+)]]
pattern [[images-([%w%-]+)%.discordapp%.net/external/(.+)]]

-- Reddit
--- Examples:
---  https://i.redd.it/u46wumt13an01.jpg
---  https://i.redditmedia.com/RowF7of6hQJAdnJPfgsA-o7ioo_uUzhwX96bPmnLo0I.jpg?w=320&s=116b72a949b6e4b8ac6c42487ffb9ad2
---  https://preview.redd.it/injjlk3t6lb51.jpg?width=640&height=800&crop=smart&auto=webp&s=19261cc37b68ae0216bb855f8d4a77ef92b76937

simple [[i.redditmedia.com]]
simple [[i.redd.it]]
simple [[preview.redd.it]]
--[=[
-- Furry things
--- Examples:
--- https://static1.e621.net/data/8f/db/8fdbc9af34698d470c90ca6cb69c5529.jpg

simple [[static1.e621.net]]
]=]
-- ipfs
--- Examples:
--- https://ipfs.io/ipfs/QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco/I/m/Ellis_Sigil.jpg

simple [[ipfs.io]]
simple [[www.ipfs.io]]

-- neocities
--- Examples:
--- https://fauux.neocities.org/LainDressSlow.gif

pattern [[([%w-_]+)%.neocities%.org/(.+)]]

--[=[
-- Soundcloud
--- Examples:
--- https://i1.sndcdn.com/artworks-000046176006-0xtkjy-large.jpg
pattern [[(%w+)%.sndcdn%.com/(.+)]]

-- Shoutcast
--- Examples:
--- http://yp.shoutcast.com/sbin/tunein-station.pls?id=567807
simple [[yp.shoutcast.com]]

-- Google Translate API
--- Examples:
--- http://translate.google.com/translate_tts?&q=Hello%20World&ie=utf-8&client=tw-ob&tl=en
simple [[translate.google.com]]
]=]


-- END OF SHARED --

-- Vocaroo
--- Examples:
--- https://media1.vocaroo.com/mp3/1mO2ie6J4r3O
--- http://vocaroo.com/16aWnwy2hwVH
pattern [[media%d.vocaroo.com/mp3/]]
simple [[vocaroo.com/]]


function wowozela.URLWhitelist(url)
    local out = 0x000
    for _, testPattern in pairs(URLWhiteList) do
        if testPattern[1] == TYPE_SIMPLE then
            if string.find(url, testPattern[2]) then
                out = bit.bor(out, TYPE_SIMPLE)
            end
        elseif testPattern[1] == TYPE_PATTERN then
            if string.match(url, testPattern[2]) then
                out = bit.bor(out, TYPE_PATTERN)
            end
        elseif testPattern[1] == TYPE_BLACKLIST then
            if string.find(url, testPattern[2]) then
                out = bit.bor(out, TYPE_BLACKLIST)
            end
        end
    end

    if bit.band(out, TYPE_BLACKLIST) == TYPE_BLACKLIST then return false end
    if bit.band(out, TYPE_SIMPLE) == TYPE_SIMPLE or bit.band(out, TYPE_PATTERN) == TYPE_PATTERN then return true end
    return false
end

--addons/tool_duplicator/lua/advdupe2/file_browser.lua:
--[[
	Title: Adv. Dupe 2 File Browser

	Desc: Displays and interfaces with duplication files.

	Author: TB

	Version: 1.0
]]

local History = {}
local Narrow = {}

local switch = true
local count = 0

local function AddHistory(txt)
	txt = string.lower(txt)
	local char1 = txt[1]
	local char2
	for i = 1, #History do
		char2 = History[i][1]
		if (char1 == char2) then
			if (History[i] == txt) then
				return
			end
		elseif (char1 < char2) then
			break
		end
	end

	table.insert(History, txt)
	table.sort(History, function(a, b) return a < b end)
end

local function NarrowHistory(txt, last)
	txt = string.lower(txt)
	local temp = {}
	if (last <= #txt and last ~= 0 and #txt ~= 1) then
		for i = 1, #Narrow do
			if (Narrow[i][last + 1] == txt[last + 1]) then
				table.insert(temp, Narrow[i])
			elseif (Narrow[i][last + 1] ~= '') then
				break
			end
		end
	else
		local char1 = txt[1]
		local char2
		for i = 1, #History do
			char2 = History[i][1]
			if (char1 == char2) then
				if (#txt > 1) then
					for k = 2, #txt do
						if (txt[k] ~= History[i][k]) then
							break
						end
						if (k == #txt) then
							table.insert(temp, History[i])
						end
					end
				else
					table.insert(temp, History[i])
				end
			elseif (char1 < char2) then
				break
			end
		end
	end

	Narrow = temp
end

local function tableSortNodes(tbl)
    for k, v in ipairs(tbl) do tbl[k] = {string.lower(v.Label:GetText()), v} end
    table.sort(tbl, function(a,b) return a[1]<b[1] end)
    for k, v in ipairs(tbl) do tbl[k] = v[2] end
end

local BROWSERPNL = {}
AccessorFunc(BROWSERPNL, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(BROWSERPNL, "m_bgColor", "BackgroundColor")
Derma_Hook(BROWSERPNL, "Paint", "Paint", "Panel")
Derma_Hook(BROWSERPNL, "PerformLayout", "Layout", "Panel")

local setbrowserpnlsize
local function SetBrowserPnlSize(self, x, y)
	setbrowserpnlsize(self, x, y)
	self.pnlCanvas:SetWide(x)
	self.pnlCanvas.VBar:SetUp(y, self.pnlCanvas:GetTall())
end

function BROWSERPNL:Init()
	setbrowserpnlsize = self.SetSize
	self.SetSize = SetBrowserPnlSize
	self.pnlCanvas = vgui.Create("advdupe2_browser_tree", self)

	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self:SetBackgroundColor(self:GetSkin().text_bright)
end

function BROWSERPNL:OnVScroll(iOffset)
	self.pnlCanvas:SetPos(0, iOffset)
end

derma.DefineControl("advdupe2_browser_panel", "AD2 File Browser", BROWSERPNL, "Panel")

local BROWSER = {}
AccessorFunc(BROWSER, "m_pSelectedItem", "SelectedItem")
Derma_Hook(BROWSER, "Paint", "Paint", "Panel")

local origSetTall
local function SetTall(self, val)
	origSetTall(self, val)
	self.VBar:SetUp(self:GetParent():GetTall(), self:GetTall())
end

function BROWSER:Init()
	self:SetTall(0)
	origSetTall = self.SetTall
	self.SetTall = SetTall

	self.VBar = vgui.Create("DVScrollBar", self:GetParent())
	self.VBar:Dock(RIGHT)
	self.Nodes = 0
	self.ChildrenExpanded = {}
	self.ChildList = self
	self.m_bExpanded = true
	self.Folders = {}
	self.Files = {}
	self.LastClick = CurTime()
end

local function GetNodePath(node)
	local path = node.Label:GetText()
	local area = 0
	local name = ""
	node = node.ParentNode
	if (not node.ParentNode) then
		if (path == "-Public-") then
			area = 1
		elseif (path == "-Advanced Duplicator 1-") then
			area = 2
		end
		return "", area
	end

	while (true) do

		name = node.Label:GetText()
		if (name == "-Advanced Duplicator 2-") then
			break
		elseif (name == "-Public-") then
			area = 1
			break
		elseif (name == "-Advanced Duplicator 1-") then
			area = 2
			break
		end
		path = name .. "/" .. path
		node = node.ParentNode
	end

	return path, area
end

function BROWSER:DoNodeLeftClick(node)
	if (self.m_pSelectedItem == node and CurTime() - self.LastClick <= 0.25) then -- Check for double click
		if (node.Derma.ClassName == "advdupe2_browser_folder") then
			if (node.Expander) then
				node:SetExpanded() -- It's a folder, expand/collapse it
			end
		else
			AdvDupe2.UploadFile(GetNodePath(node))
		end
	else
		self:SetSelected(node) -- A node was clicked, select it
	end
	self.LastClick = CurTime()
end

local function AddNewFolder(node)
	local Controller = node.Control:GetParent():GetParent()
	local name = Controller.FileName:GetValue()
	local char = string.match(name, "[^%w_ ]")
	if char then
		AdvDupe2.Notify("Name contains invalid character ("..char..")!", NOTIFY_ERROR)
		Controller.FileName:SelectAllOnFocus(true)
		Controller.FileName:OnGetFocus()
		Controller.FileName:RequestFocus()
		return
	end
	if (name == "" or name == "Folder_Name...") then
		AdvDupe2.Notify("Name is blank!", NOTIFY_ERROR)
		Controller.FileName:SelectAllOnFocus(true)
		Controller.FileName:OnGetFocus()
		Controller.FileName:RequestFocus()
		return
	end
	local path, area = GetNodePath(node)
	if (area == 0) then
		path = AdvDupe2.DataFolder .. "/" .. path .. "/" .. name
	elseif (area == 1) then
		path = AdvDupe2.DataFolder .. "/=Public=/" .. path .. "/" .. name
	else
		path = "adv_duplicator/" .. path .. "/" .. name
	end

	if (file.IsDir(path, "DATA")) then
		AdvDupe2.Notify("Folder name already exists.", NOTIFY_ERROR)
		Controller.FileName:SelectAllOnFocus(true)
		Controller.FileName:OnGetFocus()
		Controller.FileName:RequestFocus()
		return
	end
	file.CreateDir(path)

	local Folder = node:AddFolder(name)
	node.Control:Sort(node)

	if (not node.m_bExpanded) then
		node:SetExpanded()
	end

	node.Control:SetSelected(Folder)
	if (Controller.Expanded) then
		AdvDupe2.FileBrowser:Slide(false)
	end
end

local function CollapseChildren(node)
	node.m_bExpanded = false
	if (node.Expander) then
		node.Expander:SetExpanded(false)
		node.ChildList:SetTall(0)
		for i = 1, #node.ChildrenExpanded do
			CollapseChildren(node.ChildrenExpanded[i])
		end
		node.ChildrenExpanded = {}
	end
end

local function CollapseParentsComplete(node)
	if (not node.ParentNode.ParentNode) then
		node:SetExpanded(false)
		return
	end
	CollapseParentsComplete(node.ParentNode)
end

function AdvDupe2.GetFilename(path, overwrite)
	if not overwrite and file.Exists(path .. ".txt", "DATA") then
		for i = 1, AdvDupe2.FileRenameTryLimit do
			local p = string.format("%s_%03d.txt", path, i)
			if not file.Exists(p, "DATA") then
				return p
			end
		end
		return false
	end
	return path .. ".txt"
end

local function GetFullPath(node)
	local path, area = GetNodePath(node)
	if (area == 0) then
		path = AdvDupe2.DataFolder .. "/" .. path .. "/"
	elseif (area == 1) then

	else
		path = "adv_duplicator/" .. path .. "/"
	end
	return path
end

local function GetNodeRoot(node)
	local Root
	while (true) do
		if (not node.ParentNode.ParentNode) then
			Root = node
			break
		end
		node = node.ParentNode
	end
	return Root
end

local function RenameFileCl(node, name)
	local path, area = GetNodePath(node)
	local File, FilePath, tempFilePath = "", "", ""
	if (area == 0) then
		tempFilePath = AdvDupe2.DataFolder .. "/" .. path
	elseif (area == 1) then
		tempFilePath = AdvDupe2.DataFolder .. "/=Public=/" .. path
	elseif (area == 2) then
		tempFilePath = "adv_duplicator/" .. path
	end

	File = file.Read(tempFilePath .. ".txt")
	FilePath = AdvDupe2.GetFilename(
		string.sub(tempFilePath, 1, #tempFilePath - #node.Label:GetText()) .. name)

	if (not FilePath) then
		AdvDupe2.Notify("Rename limit exceeded, could not rename.", NOTIFY_ERROR)
		return
	end
	file.Write(FilePath, File)
	if (file.Exists(FilePath, "DATA")) then
		file.Delete(tempFilePath .. ".txt")
		local NewName = string.Explode("/", FilePath)
		NewName = string.sub(NewName[#NewName], 1, -5)
		node.Label:SetText(NewName)
		node.Label:SizeToContents()
		AdvDupe2.Notify("File renamed to " .. NewName)
	else
		AdvDupe2.Notify("File was not renamed.", NOTIFY_ERROR)
	end

	node.Control:Sort(node.ParentNode)
end

local function MoveFileClient(node)
	if (not node) then
		AdvDupe2.Notify("Select a folder to move the file to.", NOTIFY_ERROR)
		return
	end
	if (node.Derma.ClassName == "advdupe2_browser_file") then
		AdvDupe2.Notify("You muse select a folder as a destination.", NOTIFY_ERROR)
		return
	end
	local base = AdvDupe2.DataFolder
	local ParentNode

	local node2 = node.Control.ActionNode
	local path, area = GetNodePath(node2)
	local path2, area2 = GetNodePath(node)

	if (area ~= area2 or path == path2) then
		AdvDupe2.Notify("Cannot move files between these directories.", NOTIFY_ERROR)
		return
	end
	if (area == 2) then base = "adv_duplicator" end

	local savepath = AdvDupe2.GetFilename(
						 base .. "/" .. path2 .. "/" .. node2.Label:GetText())
	local OldFile = base .. "/" .. path .. ".txt"

	local ReFile = file.Read(OldFile)
	file.Write(savepath, ReFile)
	file.Delete(OldFile)
	local name2 = string.Explode("/", savepath)
	name2 = string.sub(name2[#name2], 1, -5)
	node2.Control:RemoveNode(node2)
	node2 = node:AddFile(name2)
	node2.Control:Sort(node)
	AdvDupe2.FileBrowser:Slide(false)
	AdvDupe2.FileBrowser.Info:SetVisible(false)
end

local function DeleteFilesInFolders(path)
	local files, folders = file.Find(path .. "*", "DATA")

	for k, v in pairs(files) do file.Delete(path .. v) end

	for k, v in pairs(folders) do DeleteFilesInFolders(path .. v .. "/") end

	file.Delete(path)
end

local function SearchNodes(node, name)
	local tab = {}
	for k, v in pairs(node.Files) do
		if (string.find(string.lower(v.Label:GetText()), name)) then
			table.insert(tab, v)
		end
	end

	for k, v in pairs(node.Folders) do
		for i, j in pairs(SearchNodes(v, name)) do
			table.insert(tab, j)
		end
	end

	return tab
end

local function Search(node, name)
	local pnFileBr = AdvDupe2.FileBrowser
	pnFileBr.Search = vgui.Create("advdupe2_browser_panel", pnFileBr)
	pnFileBr.Search:SetPos(pnFileBr.Browser:GetPos())
	pnFileBr.Search:SetSize(pnFileBr.Browser:GetSize())
	pnFileBr.Search.pnlCanvas.Search = true
	pnFileBr.Browser:SetVisible(false)
	local Files = SearchNodes(node, name)
	tableSortNodes(Files)
	for k, v in pairs(Files) do
		pnFileBr.Search.pnlCanvas:AddFile(v.Label:GetText()).Ref = v
	end
end

function BROWSER:DoNodeRightClick(node)
	self:SetSelected(node)

	local parent = self:GetParent():GetParent()
	parent.FileName:KillFocus()
	parent.Desc:KillFocus()
	local Menu = DermaMenu()
	local root = GetNodeRoot(node).Label:GetText()
	if (node.Derma.ClassName == "advdupe2_browser_file") then
		if (node.Control.Search) then
			Menu:AddOption("Open", function()
				AdvDupe2.UploadFile(GetNodePath(node.Ref))
			end)
			Menu:AddOption("Preview", function()
				local ReadPath, ReadArea = GetNodePath(node.Ref)
				if (ReadArea == 0) then
					ReadPath = AdvDupe2.DataFolder .. "/" .. ReadPath .. ".txt"
				elseif (ReadArea == 1) then
					ReadPath = AdvDupe2.DataFolder .. "/-Public-/" .. ReadPath .. ".txt"
				else
					ReadPath = "adv_duplicator/" .. ReadPath .. ".txt"
				end
				if (not file.Exists(ReadPath, "DATA")) then
					AdvDupe2.Notify("File does not exist", NOTIFY_ERROR)
					return
				end

				local read = file.Read(ReadPath)
				local name = string.Explode("/", ReadPath)
				name = name[#name]
				name = string.sub(name, 1, #name - 4)
				local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
				if (success) then
					AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, true)
				end
			end)
		else
			Menu:AddOption("Open", function()
				AdvDupe2.UploadFile(GetNodePath(node))
			end)
			Menu:AddOption("Preview", function()
				local ReadPath, ReadArea = GetNodePath(node)
				if (ReadArea == 0) then
					ReadPath = AdvDupe2.DataFolder .. "/" .. ReadPath .. ".txt"
				elseif (ReadArea == 1) then
					ReadPath = AdvDupe2.DataFolder .. "/-Public-/" .. ReadPath .. ".txt"
				else
					ReadPath = "adv_duplicator/" .. ReadPath .. ".txt"
				end
				if (not file.Exists(ReadPath, "DATA")) then
					AdvDupe2.Notify("File does not exist", NOTIFY_ERROR)
					return
				end

				local read = file.Read(ReadPath)
				local name = string.Explode("/", ReadPath)
				name = name[#name]
				name = string.sub(name, 1, #name - 4)
				local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
				if (success) then
					AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, true)
				end
			end)
			Menu:AddSpacer()
			Menu:AddOption("Rename", function()
				if (parent.Expanding) then return end
				parent.Submit:SetMaterial("icon16/page_edit.png")
				parent.Submit:SetTooltip("Rename File")
				parent.Desc:SetVisible(false)
				parent.Info:SetVisible(false)
				parent.FileName.FirstChar = true
				parent.FileName.PrevText = parent.FileName:GetValue()
				parent.FileName:SetVisible(true)
				parent.FileName:SetText(node.Label:GetText())
				parent.FileName:SelectAllOnFocus(true)
				parent.FileName:OnMousePressed()
				parent.FileName:RequestFocus()
				parent.Expanding = true
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local name = parent.FileName:GetValue()
					if (name == "") then
						AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
						parent.FileName:SelectAllOnFocus(true)
						parent.FileName:OnGetFocus()
						parent.FileName:RequestFocus()
						return
					end
					AddHistory(name)
					RenameFileCl(node, name)
					AdvDupe2.FileBrowser:Slide(false)
				end
				parent.FileName.OnEnter = parent.Submit.DoClick
			end)
			Menu:AddOption("Move File", function()
				parent.Submit:SetMaterial("icon16/page_paste.png")
				parent.Submit:SetTooltip("Move File")
				parent.FileName:SetVisible(false)
				parent.Desc:SetVisible(false)
				parent.Info:SetText(
					"Select the folder you want to move \nthe File to.")
				parent.Info:SizeToContents()
				parent.Info:SetVisible(true)
				AdvDupe2.FileBrowser:Slide(true)
				node.Control.ActionNode = node
				parent.Submit.DoClick = function()
					MoveFileClient(node.Control.m_pSelectedItem)
				end
			end)
			Menu:AddOption("Delete", function()
				parent.Submit:SetMaterial("icon16/bin_empty.png")
				parent.Submit:SetTooltip("Delete File")
				parent.FileName:SetVisible(false)
				parent.Desc:SetVisible(false)
				if (#node.Label:GetText() > 22) then
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FILE, "' ..
							node.Label:GetText() .. '" \nfrom your CLIENT?')
				else
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FILE, "' ..
							node.Label:GetText() .. '" from your CLIENT?')
				end
				parent.Info:SizeToContents()
				parent.Info:SetVisible(true)
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local path, area = GetNodePath(node)
					if (area == 1) then
						path = "-Public-/" .. path
					end
					if (area == 2) then
						path = "adv_duplicator/" .. path .. ".txt"
					else
						path = AdvDupe2.DataFolder .. "/" .. path .. ".txt"
					end
					node.Control:RemoveNode(node)
					file.Delete(path)
					AdvDupe2.FileBrowser:Slide(false)
				end
			end)
		end
	else
		if (root ~= "-Advanced Duplicator 1-") then
			Menu:AddOption("Save", function()
				if (parent.Expanding) then return end
				parent.Submit:SetMaterial("icon16/page_save.png")
				parent.Submit:SetTooltip("Save Duplication")
				if (parent.FileName:GetValue() == "Folder_Name...") then
					parent.FileName:SetText("File_Name...")
				end
				parent.Desc:SetVisible(true)
				parent.Info:SetVisible(false)
				parent.FileName.FirstChar = true
				parent.FileName.PrevText = parent.FileName:GetValue()
				parent.FileName:SetVisible(true)
				parent.FileName:SelectAllOnFocus(true)
				parent.FileName:OnMousePressed()
				parent.FileName:RequestFocus()
				node.Control.ActionNode = node
				parent.Expanding = true
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local name = parent.FileName:GetValue()
					if (name == "" or name == "File_Name...") then
						AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
						parent.FileName:SelectAllOnFocus(true)
						parent.FileName:OnGetFocus()
						parent.FileName:RequestFocus()
						return
					end
					local desc = parent.Desc:GetValue()
					if (desc == "Description...") then
						desc = ""
					end
					AdvDupe2.SavePath = GetFullPath(node) .. name
					AddHistory(name)
					if (game.SinglePlayer()) then
						RunConsoleCommand("AdvDupe2_SaveFile", name, desc, GetNodePath(node))
					else
						RunConsoleCommand("AdvDupe2_SaveFile", name)
					end
					AdvDupe2.FileBrowser:Slide(false)
				end
				parent.FileName.OnEnter =
					function()
						parent.FileName:KillFocus()
						parent.Desc:SelectAllOnFocus(true)
						parent.Desc.OnMousePressed()
						parent.Desc:RequestFocus()
					end
				parent.Desc.OnEnter = parent.Submit.DoClick
			end)
		end
		Menu:AddOption("New Folder", function()
			if (parent.Expanding) then return end
			parent.Submit:SetMaterial("icon16/folder_add.png")
			parent.Submit:SetTooltip("Add new folder")
			if (parent.FileName:GetValue() == "File_Name...") then
				parent.FileName:SetText("Folder_Name...")
			end
			parent.Desc:SetVisible(false)
			parent.Info:SetVisible(false)
			parent.FileName.FirstChar = true
			parent.FileName.PrevText = parent.FileName:GetValue()
			parent.FileName:SetVisible(true)
			parent.FileName:SelectAllOnFocus(true)
			parent.FileName:OnMousePressed()
			parent.FileName:RequestFocus()
			parent.Expanding = true
			AdvDupe2.FileBrowser:Slide(true)
			parent.Submit.DoClick = function() AddNewFolder(node) end
			parent.FileName.OnEnter = parent.Submit.DoClick
		end)
		Menu:AddOption("Search", function()
			parent.Submit:SetMaterial("icon16/find.png")
			parent.Submit:SetTooltip("Search Files")
			if (parent.FileName:GetValue() == "Folder_Name...") then
				parent.FileName:SetText("File_Name...")
			end
			parent.Desc:SetVisible(false)
			parent.Info:SetVisible(false)
			parent.FileName.FirstChar = true
			parent.FileName.PrevText = parent.FileName:GetValue()
			parent.FileName:SetVisible(true)
			parent.FileName:SelectAllOnFocus(true)
			parent.FileName:OnMousePressed()
			parent.FileName:RequestFocus()
			parent.Expanding = true
			AdvDupe2.FileBrowser:Slide(true)
			parent.Submit.DoClick = function()
				Search(node, string.lower(parent.FileName:GetValue()))
				AddHistory(parent.FileName:GetValue())
				parent.FileName:SetVisible(false)
				parent.Submit:SetMaterial("icon16/arrow_undo.png")
				parent.Submit:SetTooltip("Return to Browser")
				parent.Info:SetVisible(true)
				parent.Info:SetText(#parent.Search.pnlCanvas.Files ..
										' files found searching for, "' ..
										parent.FileName:GetValue() .. '"')
				parent.Info:SizeToContents()
				parent.Submit.DoClick = function()
					parent.Search:Remove()
					parent.Search = nil
					parent.Browser:SetVisible(true)
					AdvDupe2.FileBrowser:Slide(false)
					parent.Cancel:SetVisible(true)
				end
				parent.Cancel:SetVisible(false)
			end
			parent.FileName.OnEnter = parent.Submit.DoClick
		end)
		if (node.Label:GetText()[1] ~= "-") then
			Menu:AddOption("Delete", function()
				parent.Submit:SetMaterial("icon16/bin_empty.png")
				parent.Submit:SetTooltip("Delete Folder")
				parent.FileName:SetVisible(false)
				parent.Desc:SetVisible(false)
				if (#node.Label:GetText() > 22) then
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FOLDER, "' ..
							node.Label:GetText() .. '" \nfrom your CLIENT?')
				else
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FOLDER, "' ..
							node.Label:GetText() .. '" from your CLIENT?')
				end
				parent.Info:SizeToContents()
				parent.Info:SetVisible(true)
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local path, area = GetNodePath(node)
					if (area == 1) then
						path = "-Public-/" .. path
					end
					if (area == 2) then
						path = "adv_duplicator/" .. path .. "/"
					else
						path = AdvDupe2.DataFolder .. "/" .. path .. "/"
					end
					node.Control:RemoveNode(node)
					DeleteFilesInFolders(path)
					AdvDupe2.FileBrowser:Slide(false)
				end
			end)
		end
	end
	if (not node.Control.Search) then
		Menu:AddSpacer()
		Menu:AddOption("Collapse Folder", function()
			if (node.ParentNode.ParentNode) then
				node.ParentNode:SetExpanded(false)
			end
		end)
		Menu:AddOption("Collapse Root", function() CollapseParentsComplete(node) end)
		if (parent.Expanded) then
			Menu:AddOption("Cancel Action", function() parent.Cancel:DoClick() end)
		end
	end

	Menu:Open()
end

local function CollapseParents(node, val)
	if (not node) then return end
	node.ChildList:SetTall(node.ChildList:GetTall() - val)
	CollapseParents(node.ParentNode, val)
end

function BROWSER:RemoveNode(node)
	local parent = node.ParentNode
	parent.Nodes = parent.Nodes - 1
	if (node.IsFolder) then
		if (node.m_bExpanded) then
			CollapseParents(parent, node.ChildList:GetTall() + 20)
			for i = 1, #parent.ChildrenExpanded do
				if (node == parent.ChildrenExpanded[i]) then
					table.remove(parent.ChildrenExpanded, i)
					break
				end
			end
		elseif (parent.m_bExpanded) then
			CollapseParents(parent, 20)
		end
		for i = 1, #parent.Folders do
			if (node == parent.Folders[i]) then
				table.remove(parent.Folders, i)
			end
		end
		node.ChildList:Remove()
		node:Remove()
	else
		for i = 1, #parent.Files do
			if (node == parent.Files[i]) then
				table.remove(parent.Files, i)
			end
		end
		CollapseParents(parent, 20)
		node:Remove()
		if (#parent.Files == 0 and #parent.Folders == 0) then
			parent.Expander:Remove()
			parent.Expander = nil
			parent.m_bExpanded = false
		end
	end
	if (self.VBar.Scroll > self.VBar.CanvasSize) then
		self.VBar:SetScroll(self.VBar.Scroll)
	end
	if (self.m_pSelectedItem) then
		self.m_pSelectedItem = nil
	end
end

function BROWSER:OnMouseWheeled(dlta)
	return self.VBar:OnMouseWheeled(dlta)
end

function BROWSER:AddFolder(text)
	local node = vgui.Create("advdupe2_browser_folder", self)
	node.Control = self

	node.Offset = 0
	node.ChildrenExpanded = {}
	node.Icon:SetPos(18, 1)
	node.Label:SetPos(44, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.ParentNode = self
	node.IsFolder = true
	self.Nodes = self.Nodes + 1
	node.Folders = {}
	node.Files = {}
	table.insert(self.Folders, node)
	self:SetTall(self:GetTall() + 20)

	return node
end

function BROWSER:AddFile(text)
	local node = vgui.Create("advdupe2_browser_file", self)
	node.Control = self
	node.Offset = 0
	node.Icon:SetPos(18, 1)
	node.Label:SetPos(44, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.ParentNode = self
	self.Nodes = self.Nodes + 1
	table.insert(self.Files, node)
	self:SetTall(self:GetTall() + 20)

	return node
end

function BROWSER:Sort(node)
	tableSortNodes(node.Folders)
	tableSortNodes(node.Files)

	for i = 1, #node.Folders do
		node.Folders[i]:SetParent(nil)
		node.Folders[i]:SetParent(node.ChildList)
		node.Folders[i].ChildList:SetParent(nil)
		node.Folders[i].ChildList:SetParent(node.ChildList)
	end
	for i = 1, #node.Files do
		node.Files[i]:SetParent(nil)
		node.Files[i]:SetParent(node.ChildList)
	end
end

function BROWSER:SetSelected(node)
	if (IsValid(self.m_pSelectedItem)) then
		self.m_pSelectedItem:SetSelected(false)
	end
	self.m_pSelectedItem = node
	if (node) then node:SetSelected(true) end
end

local function ExpandParents(node, val)
	if (not node) then return end
	node.ChildList:SetTall(node.ChildList:GetTall() + val)
	ExpandParents(node.ParentNode, val)
end

function BROWSER:Expand(node)
	node.ChildList:SetTall(node.Nodes * 20)
	table.insert(node.ParentNode.ChildrenExpanded, node)
	ExpandParents(node.ParentNode, node.Nodes * 20)
end

local function ExtendParents(node)
	if (not node) then return end
	node.ChildList:SetTall(node.ChildList:GetTall() + 20)
	ExtendParents(node.ParentNode)
end

function BROWSER:Extend(node)
	node.ChildList:SetTall(node.ChildList:GetTall() + 20)
	ExtendParents(node.ParentNode)
end

function BROWSER:Collapse(node)
	CollapseParents(node.ParentNode, node.ChildList:GetTall())

	for i = 1, #node.ParentNode.ChildrenExpanded do
		if (node.ParentNode.ChildrenExpanded[i] == node) then
			table.remove(node.ParentNode.ChildrenExpanded, i)
			break
		end
	end
	CollapseChildren(node)
end

function BROWSER:RenameNode(name)
	self.ActionNode.Label:SetText(name)
	self.ActionNode.Label:SizeToContents()
	self:Sort(self.ActionNode.ParentNode)
end

function BROWSER:MoveNode(name)
	self:RemoveNode(self.ActionNode)
	self.ActionNode2:AddFile(name)
	self:Sort(self.ActionNode2)
end

function BROWSER:DeleteNode()
	self:RemoveNode(self.ActionNode)
end

derma.DefineControl("advdupe2_browser_tree", "AD2 File Browser", BROWSER, "Panel")

local FOLDER = {}

AccessorFunc(FOLDER, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(FOLDER, "m_bgColor", "BackgroundColor")

Derma_Hook(FOLDER, "Paint", "Paint", "Panel")

function FOLDER:Init()
	self:SetMouseInputEnabled(true)

	self:SetTall(20)
	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self:SetBackgroundColor(Color(0, 0, 0, 0))

	self.Icon = vgui.Create("DImage", self)
	self.Icon:SetImage("icon16/folder.png")

	self.Icon:SizeToContents()

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetDark(true)

	self.m_bExpanded = false
	self.Nodes = 0
	self.ChildrenExpanded = {}

	self:Dock(TOP)

	self.ChildList = vgui.Create("Panel", self:GetParent())
	self.ChildList:Dock(TOP)
	self.ChildList:SetTall(0)
end

local function ExpandNode(self)
	self:GetParent():SetExpanded()
end

function FOLDER:AddFolder(text)
	if (self.Nodes == 0) then
		self.Expander = vgui.Create("DExpandButton", self)
		self.Expander.DoClick = ExpandNode
		self.Expander:SetPos(self.Offset, 2)
	end

	local node = vgui.Create("advdupe2_browser_folder", self.ChildList)
	node.Control = self.Control

	node.Offset = self.Offset + 20

	node.Icon:SetPos(18 + node.Offset, 1)
	node.Label:SetPos(44 + node.Offset, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.Label:SetDark(true)
	node.ParentNode = self
	node.IsFolder = true
	node.Folders = {}
	node.Files = {}

	self.Nodes = self.Nodes + 1
	table.insert(self.Folders, node)

	if (self.m_bExpanded) then
		self.Control:Extend(self)
	end

	return node
end

function FOLDER:AddFile(text)
	if (self.Nodes == 0) then
		self.Expander = vgui.Create("DExpandButton", self)
		self.Expander.DoClick = ExpandNode
		self.Expander:SetPos(self.Offset, 2)
	end

	local node = vgui.Create("advdupe2_browser_file", self.ChildList)
	node.Control = self.Control
	node.Offset = self.Offset + 20
	node.Icon:SetPos(18 + node.Offset, 1)
	node.Label:SetPos(44 + node.Offset, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.Label:SetDark(true)
	node.ParentNode = self

	self.Nodes = self.Nodes + 1
	table.insert(self.Files, node)

	if (self.m_bExpanded) then
		self.Control:Extend(self)
	end

	return node
end

function FOLDER:SetExpanded(bool)
	if (not self.Expander) then return end
	if (bool == nil) then
		self.m_bExpanded = not self.m_bExpanded
	else
		self.m_bExpanded = bool
	end
	self.Expander:SetExpanded(self.m_bExpanded)
	if (self.m_bExpanded) then
		self.Control:Expand(self)
	else
		self.Control:Collapse(self)
	end
end

function FOLDER:SetSelected(bool)
	if (bool) then
		self:SetBackgroundColor(self:GetSkin().bg_color_bright)
	else
		self:SetBackgroundColor(Color(0, 0, 0, 0))
	end
end

function FOLDER:OnMousePressed(code)
	if (code == 107) then
		self.Control:DoNodeLeftClick(self)
	elseif (code == 108) then
		self.Control:DoNodeRightClick(self)
	end
end

derma.DefineControl("advdupe2_browser_folder", "AD2 Browser Folder node", FOLDER, "Panel")

local FILE = {}

AccessorFunc(FILE, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(FILE, "m_bgColor", "BackgroundColor")
Derma_Hook(FILE, "Paint", "Paint", "Panel")

function FILE:Init()
	self:SetMouseInputEnabled(true)

	self:SetTall(20)
	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self:SetBackgroundColor(Color(0, 0, 0, 0))

	self.Icon = vgui.Create("DImage", self)
	self.Icon:SetImage("icon16/page.png")

	self.Icon:SizeToContents()

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetDark(true)

	self:Dock(TOP)
end

function FILE:SetSelected(bool)
	if (bool) then
		self:SetBackgroundColor(self:GetSkin().bg_color_bright)
	else
		self:SetBackgroundColor(Color(0, 0, 0, 0))
	end
end

function FILE:OnMousePressed(code)
	if (code == 107) then
		self.Control:DoNodeLeftClick(self)
	elseif (code == 108) then
		self.Control:DoNodeRightClick(self)
	end
end

derma.DefineControl("advdupe2_browser_file", "AD2 Browser File node", FILE, "Panel")

local PANEL = {}
AccessorFunc(PANEL, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(PANEL, "m_bgColor", "BackgroundColor")
Derma_Hook(PANEL, "Paint", "Paint", "Panel")
Derma_Hook(PANEL, "PerformLayout", "Layout", "Panel")

function PANEL:PerformLayout()
	if (self:GetWide() == self.LastX) then return end
	local x = self:GetWide()

	if (self.Search) then
		self.Search:SetWide(x)
	end

	self.Browser:SetWide(x)
	local x2, y2 = self.Browser:GetPos()
	local BtnX = x - self.Help:GetWide() - 5
	self.Help:SetPos(BtnX, 3)
	BtnX = BtnX - self.Refresh:GetWide() - 5
	self.Refresh:SetPos(BtnX, 3)

	BtnX = x - self.Submit:GetWide() - 15
	self.Cancel:SetPos(BtnX, self.Browser:GetTall() + 20)
	BtnX = BtnX - self.Submit:GetWide() - 5
	self.Submit:SetPos(BtnX, self.Browser:GetTall() + 20)

	self.FileName:SetWide(BtnX - 10)
	self.FileName:SetPos(5, self.Browser:GetTall() + 20)
	self.Desc:SetWide(x - 10)
	self.Desc:SetPos(5, self.Browser:GetTall() + 39)
	self.Info:SetPos(5, self.Browser:GetTall() + 20)

	self.LastX = x
end

local pnlorigsetsize
local function PanelSetSize(self, x, y)
	if (not self.LaidOut) then
		pnlorigsetsize(self, x, y)

		self.Browser:SetSize(x, y - 20)
		self.Browser:SetPos(0, 20)

		if (self.Search) then
			self.Search:SetSize(x, y - 20)
			self.Search:SetPos(0, 20)
		end

		self.LaidOut = true
	else
		pnlorigsetsize(self, x, y)
	end

end

local function PurgeFiles(path, curParent)
	local files, directories = file.Find(path .. "*", "DATA")
	if (directories) then
		for k, v in pairs(directories) do
			curParent = curParent:AddFolder(v)
			PurgeFiles(path .. v .. "/", curParent)
			curParent = curParent.ParentNode
		end
	end

	if (files) then
		for k, v in pairs(files) do
			curParent:AddFile(string.sub(v, 1, #v - 4))
		end
	end
end

local function UpdateClientFiles()

	local pnlCanvas = AdvDupe2.FileBrowser.Browser.pnlCanvas

	for i = 1, 2 do
		if (pnlCanvas.Folders[1]) then
			pnlCanvas:RemoveNode(pnlCanvas.Folders[1])
		end
	end

	PurgeFiles("advdupe2/", pnlCanvas:AddFolder("-Advanced Duplicator 2-"))

	PurgeFiles("adv_duplicator/", pnlCanvas:AddFolder("-Advanced Duplicator 1-"))

	if (pnlCanvas.Folders[2]) then
		if (#pnlCanvas.Folders[2].Folders == 0 and #pnlCanvas.Folders[2].Files == 0) then
			pnlCanvas:RemoveNode(pnlCanvas.Folders[2])
		end

		pnlCanvas.Folders[1]:SetParent(nil)
		pnlCanvas.Folders[1]:SetParent(pnlCanvas.ChildList)
		pnlCanvas.Folders[1].ChildList:SetParent(nil)
		pnlCanvas.Folders[1].ChildList:SetParent(pnlCanvas.ChildList)
	end

end

function PANEL:Init()

	AdvDupe2.FileBrowser = self
	self.Expanded = false
	self.Expanding = false
	self.LastX = 0
	self.LastY = 0
	pnlorigsetsize = self.SetSize
	self.SetSize = PanelSetSize

	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetBackgroundColor(self:GetSkin().bg_color_bright)

	self.Browser = vgui.Create("advdupe2_browser_panel", self)
	UpdateClientFiles()
	self.Refresh = vgui.Create("DImageButton", self)
	self.Refresh:SetMaterial("icon16/arrow_refresh.png")
	self.Refresh:SizeToContents()
	self.Refresh:SetTooltip("Refresh Files")
	self.Refresh.DoClick = function(button) UpdateClientFiles() end

	self.Help = vgui.Create("DImageButton", self)
	self.Help:SetMaterial("icon16/help.png")
	self.Help:SizeToContents()
	self.Help:SetTooltip("Help Section")
	self.Help.DoClick = function(btn)
		local Menu = DermaMenu()
		Menu:AddOption("Bug Reporting", function()
			gui.OpenURL("https://github.com/wiremod/advdupe2/issues")
		end)
		Menu:AddOption("Controls", function()
			gui.OpenURL("https://github.com/wiremod/advdupe2/wiki/Controls")
		end)
		Menu:AddOption("Commands", function()
			gui.OpenURL(
				"https://github.com/wiremod/advdupe2/wiki/Server-settings")
		end)
		Menu:Open()
	end

	self.Submit = vgui.Create("DImageButton", self)
	self.Submit:SetMaterial("icon16/page_save.png")
	self.Submit:SizeToContents()
	self.Submit:SetTooltip("Confirm Action")
	self.Submit.DoClick = function()
		self.Expanding = true
		AdvDupe2.FileBrowser:Slide(false)
	end

	self.Cancel = vgui.Create("DImageButton", self)
	self.Cancel:SetMaterial("icon16/cross.png")
	self.Cancel:SizeToContents()
	self.Cancel:SetTooltip("Cancel Action")
	self.Cancel.DoClick = function()
		self.Expanding = true
		AdvDupe2.FileBrowser:Slide(false)
	end

	self.FileName = vgui.Create("DTextEntry", self)
	self.FileName:SetAllowNonAsciiCharacters(true)
	self.FileName:SetText("File_Name...")
	self.FileName.Last = 0

	self.FileName.OnEnter = function()
		self.FileName:KillFocus()
		self.Desc:SelectAllOnFocus(true)
		self.Desc.OnMousePressed()
		self.Desc:RequestFocus()
	end
	self.FileName.OnMousePressed = function()
		self.FileName:OnGetFocus()
		if (self.FileName:GetValue() == "File_Name..." or
			self.FileName:GetValue() == "Folder_Name...") then
			self.FileName:SelectAllOnFocus(true)
		end
	end
	self.FileName:SetUpdateOnType(true)
	self.FileName.OnTextChanged = function()

		if (self.FileName.FirstChar) then
			if (string.lower(self.FileName:GetValue()[1] or "") == string.lower(input.LookupBinding("menu") or "q")) then
				self.FileName:SetText(self.FileName.PrevText)
				self.FileName:SelectAll()
				self.FileName.FirstChar = false
			else
				self.FileName.FirstChar = false
			end
		end

		local new, changed = self.FileName:GetValue():gsub("[^%w_ ]", "")
		if changed > 0 then
			self.FileName:SetText(new)
			self.FileName:SetCaretPos(#new)
		end
		if (#self.FileName:GetValue() > 0) then
			NarrowHistory(self.FileName:GetValue(), self.FileName.Last)
			local options = {}
			if (#Narrow > 4) then
				for i = 1, 4 do table.insert(options, Narrow[i]) end
			else
				options = Narrow
			end
			if (#options ~= 0 and #self.FileName:GetValue() ~= 0) then
				self.FileName.HistoryPos = 0
				self.FileName:OpenAutoComplete(options)
				self.FileName.Menu.Attempts = 1
				if (#Narrow > 4) then
					self.FileName.Menu:AddOption("...", wlib.func.blank)
				end
			elseif (IsValid(self.FileName.Menu)) then
				self.FileName.Menu:Remove()
			end
		end
		self.FileName.Last = #self.FileName:GetValue()
	end
	self.FileName.OnKeyCodeTyped = function(txtbox, code)
		txtbox:OnKeyCode(code)

		if (code == KEY_ENTER and not txtbox:IsMultiline() and txtbox:GetEnterAllowed()) then
			if (txtbox.HistoryPos == 5 and txtbox.Menu:ChildCount() == 5) then
				if ((txtbox.Menu.Attempts + 1) * 4 < #Narrow) then
					for i = 1, 4 do
						txtbox.Menu:GetChild(i):SetText(Narrow[i + txtbox.Menu.Attempts * 4])
					end
				else
					txtbox.Menu:GetChild(5):Remove()
					for i = 4, (txtbox.Menu.Attempts * 4 - #Narrow) * -1 + 1, -1 do
						txtbox.Menu:GetChild(i):Remove()
					end

					for i = 1, #Narrow - txtbox.Menu.Attempts * 4 do
						txtbox.Menu:GetChild(i):SetText(Narrow[i + txtbox.Menu.Attempts * 4])
					end
				end
				txtbox.Menu:ClearHighlights()
				txtbox.Menu:HighlightItem(txtbox.Menu:GetChild(1))
				txtbox.HistoryPos = 1
				txtbox.Menu.Attempts = txtbox.Menu.Attempts + 1
				return true
			end

			if (IsValid(txtbox.Menu)) then
				txtbox.Menu:Remove()
			end
			txtbox:FocusNext()
			txtbox:OnEnter()
			txtbox.HistoryPos = 0
		end

		if (txtbox.m_bHistory or IsValid(txtbox.Menu)) then
			if (code == KEY_UP) then
				txtbox.HistoryPos = txtbox.HistoryPos - 1;
				if (txtbox.HistoryPos ~= -1 or txtbox.Menu:ChildCount() ~= 5) then
					txtbox:UpdateFromHistory()
				else
					txtbox.Menu:ClearHighlights()
					txtbox.Menu:HighlightItem(txtbox.Menu:GetChild(5))
					txtbox.HistoryPos = 5
				end
			end
			if (code == KEY_DOWN or code == KEY_TAB) then
				txtbox.HistoryPos = txtbox.HistoryPos + 1;
				if (txtbox.HistoryPos ~= 5 or txtbox.Menu:ChildCount() ~= 5) then
					txtbox:UpdateFromHistory()
				else
					txtbox.Menu:ClearHighlights()
					txtbox.Menu:HighlightItem(txtbox.Menu:GetChild(5))
				end
			end

		end
	end
	self.FileName.OnValueChange = function()
		if (self.FileName:GetValue() ~= "File_Name..." and
			self.FileName:GetValue() ~= "Folder_Name...") then
			local new, changed = self.FileName:GetValue():gsub("[^%w_ ]", "")
			if changed > 0 then
				self.FileName:SetText(new)
				self.FileName:SetCaretPos(#new)
			end
		end
	end

	self.Desc = vgui.Create("DTextEntry", self)
	self.Desc.OnEnter = self.Submit.DoClick
	self.Desc:SetText("Description...")
	self.Desc.OnMousePressed = function()
		self.Desc:OnGetFocus()
		if (self.Desc:GetValue() == "Description...") then
			self.Desc:SelectAllOnFocus(true)
		end
	end

	self.Info = vgui.Create("DLabel", self)
	self.Info:SetVisible(false)

end

function PANEL:Slide(expand)
	if (expand) then
		if (self.Expanded) then
			self:SetTall(self:GetTall() - 40)
			self.Expanded = false
		else
			self:SetTall(self:GetTall() + 5)
		end
	else
		if (not self.Expanded) then
			self:SetTall(self:GetTall() + 40)
			self.Expanded = true
		else
			self:SetTall(self:GetTall() - 5)
		end
	end
	count = count + 1
	if (count < 9) then
		timer.Simple(0.01, function() self:Slide(expand) end)
	else
		if (expand) then
			self.Expanded = true
		else
			self.Expanded = false
		end
		self.Expanding = false
		count = 0
	end
end

function PANEL:GetFullPath(node)
	return GetFullPath(node)
end

function PANEL:GetNodePath(node)
	return GetNodePath(node)
end

if (game.SinglePlayer()) then
	net.Receive("AdvDupe2_AddFile", function()
		local asvNode = AdvDupe2.FileBrowser.AutoSaveNode
		local actNode = AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode
		if (net.ReadBool()) then
			if (IsValid(asvNode)) then
				local name = net.ReadString()
				for iD = 1, #asvNode.Files do
					if (name == asvNode.Files[i]) then return end
				end
				asvNode:AddFile(name)
				asvNode.Control:Sort(asvNode)
			end
		else
			actNode:AddFile(net.ReadString())
			actNode.Control:Sort(actNode)
		end
	end)
end

vgui.Register("advdupe2_browser", PANEL, "Panel")

--addons/tool_duplicator/lua/advdupe2/sh_codec.lua:
--[[
	Title: Adv. Dupe 2 Codec

	Desc: Dupe encoder/decoder.

	Author: emspike

	Version: 2.0
]]

local REVISION = 5
AdvDupe2.CodecRevision = REVISION
AdvDupe2.MaxDupeSize = 32e6 -- 32 MB

include( "sh_codec_legacy.lua" )
AddCSLuaFile( "sh_codec_legacy.lua" )

local pairs = pairs
local type = type
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat
local compress = util.Compress
local decompress = util.Decompress

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local function makeInfo(tbl)
	local info = ""
	for k, v in pairs(tbl) do
		info = concat{info,k,"\1",v,"\1"}
	end
	return info.."\2"
end

local AD2FF = "AD2F%s\n%s\n%s"

local tables, buff

local function noserializer() end

local enc = {}
for i = 1, 255 do enc[i] = noserializer end

local function isArray(tbl)
	local ret = true
	local m = 0

	for k, v in pairs(tbl) do
		m = m + 1
		if k ~= m or enc[TypeID(v)] == noserializer then
			ret = false
			break
		end
	end

	return ret
end

local function write(obj)
	enc[TypeID(obj)](obj)
end

local len, tables, tablesLookup

enc[TYPE_TABLE] = function(obj) --table
	if not tablesLookup[obj] then
		tables = tables + 1
		tablesLookup[obj] = tables
	else
		buff:WriteByte(247)
		buff:WriteShort(tablesLookup[obj])
		return
	end

	if isArray(obj) then
		buff:WriteByte(254)
		for i, v in pairs(obj) do
			write(v)
		end
	else
		buff:WriteByte(255)
		for k, v in pairs(obj) do
			if(enc[TypeID(k)] ~= noserializer and enc[TypeID(v)] ~= noserializer) then
				write(k)
				write(v)
			end
		end
	end
	buff:WriteByte(246)
end

enc[TYPE_BOOL] = function(obj) --boolean
	buff:WriteByte(obj and 253 or 252)
end

enc[TYPE_NUMBER] = function(obj) --number
	buff:WriteByte(251)
	buff:WriteDouble(obj)
end

enc[TYPE_VECTOR] = function(obj) --vector
	buff:WriteByte(250)
	buff:WriteDouble(obj.x)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.z)
end

enc[TYPE_ANGLE] = function(obj) --angle
	buff:WriteByte(249)
	buff:WriteDouble(obj.p)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.r)
end

enc[TYPE_STRING] = function(obj) --string
	len = #obj
	if len < 246 then
		buff:WriteByte(len)
		buff:Write(obj)
	else
		buff:WriteByte(248)
		buff:WriteULong(len)
		buff:Write(obj)
	end
end

local function error_nodeserializer()
	buff:Seek(buff:Tell()-1)
	error(format("Couldn't find deserializer for type {typeid:%d}!", buff:ReadByte()))
end

local reference = 0
local read4, read5

do --Version 4
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		if tt == 0 then
			return nil
		end
		return dec[tt]()
	end
	read4 = read

	dec[255] = function() --table
		local t = {}
		local k
		reference = reference + 1
		local ref = reference
		repeat
			k = read()
			if k ~= nil then
				t[k] = read()
			end
		until (k == nil)
		tables[ref] = t
		return t
	end

	dec[254] = function() --array
		local t = {}
		local k = 0
		local v
		reference = reference + 1
		local ref = reference
		repeat
			k = k + 1
			v = read()
			if(v ~= nil) then
				t[k] = v
			end

		until (v == nil)
		tables[ref] = t
		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() --null-terminated string
		local start = buff:Tell()
		local slen = 0

		while buff:ReadByte() ~= 0 do
			slen = slen + 1
		end

		buff:Seek(start)

		local retv = buff:Read(slen)
		if(not retv) then retv="" end
		buff:ReadByte()

		return retv
	end
	dec[247] = function() --table reference
		reference = reference + 1
		return tables[buff:ReadShort()]
	end

	for i = 1, 246 do dec[i] = function() return buff:Read(i) end end
end

do --Version 5
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		return dec[tt]()
	end
	read5 = read

	dec[255] = function() --table
		local t = {}
		reference = reference + 1
		tables[reference] = t

		for k in read do
			t[k] = read()
		end

		return t
	end

	dec[254] = function() --array
		local t = {}
		reference = reference + 1
		tables[reference] = t

		local k = 1
		for v in read do
			t[k] = v
			k = k + 1
		end

		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() -- Length>246 string
		local slen = buff:ReadULong()
		local retv = buff:Read(slen)
		if(not retv) then retv = "" end
		return retv
	end
	dec[247] = function() --table reference
		return tables[buff:ReadShort()]
	end
	dec[246] = function() --nil
		return
	end

	for i = 1, 245 do dec[i] = function() return buff:Read(i) end end

	dec[0] = function() return "" end
end

local function serialize(tbl)
	tables = 0
	tablesLookup = {}

	buff = file.Open("ad2temp.txt", "wb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	write(tbl)
	buff:Close()

	buff = file.Open("ad2temp.txt","rb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local ret = buff:Read(buff:Size())
	buff:Close()
	return ret
end


local function deserialize(str, read)

	if(str == nil) then
		error("File could not be decompressed!")
		return {}
	end

	tables = {}
	reference = 0
	buff = file.Open("ad2temp.txt","wb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	buff:Write(str)
	buff:Flush()
	buff:Close()

	buff = file.Open("ad2temp.txt","rb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local success, tbl = pcall(read)
	buff:Close()

	if success then
		return tbl
	else
		error(tbl)
	end
end

--[[
	Name:	Encode
	Desc:	Generates the string for a dupe file with the given data.
	Params:	<table> dupe, <table> info, <function> callback, <...> args
	Return:	runs callback(<string> encoded_dupe, <...> args)
]]
function AdvDupe2.Encode(dupe, info, callback, ...)
	local encodedTable = compress(serialize(dupe))
	info.check = "\r\n\t\n"
	info.size = #encodedTable

	callback(AD2FF:format(char(REVISION), makeInfo(info), encodedTable),...)
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("Attempt to read AD2 file with malformed info block!")
	end
	local info = {}
	local ss = str:sub(1, last - 1)
	for k, v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end

	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("Detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)!")
		else
			error("Attempt to read AD2 file with malformed info block!")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[1] = AdvDupe2.LegacyDecoders[1]
versions[2] = AdvDupe2.LegacyDecoders[2]

versions[3] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	return versions[4](encodedDupe)
end

versions[4] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read4), info
end

versions[5] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read5), info
end

function AdvDupe2.CheckValidDupe(dupe, info)
	if not dupe.HeadEnt then return false, "Missing HeadEnt table" end
	if not dupe.Entities then return false, "Missing Entities table" end
	if not dupe.Constraints then return false, "Missing Constraints table" end
	if not dupe.HeadEnt.Z then return false, "Missing HeadEnt.Z" end
	if not dupe.HeadEnt.Pos then return false, "Missing HeadEnt.Pos" end
	if not dupe.HeadEnt.Index then return false, "Missing HeadEnt.Index" end
	if not dupe.Entities[dupe.HeadEnt.Index] then return false, "Missing HeadEnt index ["..dupe.HeadEnt.Index.."] from Entities table" end
	for key, data in pairs(dupe.Entities) do
		if not data.PhysicsObjects then return false, "Missing PhysicsObject table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if not data.PhysicsObjects[0] then return false, "Missing PhysicsObject[0] table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if info.ad1 then -- Advanced Duplicator 1
			if not data.PhysicsObjects[0].LocalPos then return false, "Missing PhysicsObject[0].LocalPos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].LocalAngle then return false, "Missing PhysicsObject[0].LocalAngle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		else -- Advanced Duplicator 2
			if not data.PhysicsObjects[0].Pos then return false, "Missing PhysicsObject[0].Pos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].Angle then return false, "Missing PhysicsObject[0].Angle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		end
	end
	return true, dupe
end

--[[
	Name:	Decode
	Desc:	Generates the table for a dupe from the given string. Inverse of Encode
	Params:	<string> encodedDupe, <function> callback, <...> args
	Return:	runs callback(<boolean> success, <table/string> tbl, <table> info)
]]
function AdvDupe2.Decode(encodedDupe)

	local sig, rev = encodedDupe:match("^(....)(.)")

	if not rev then
		return false, "Malformed dupe (wtf <5 chars long)!"
	end

	rev = rev:byte()

	if sig ~= "AD2F" then
		if sig == "[Inf" then --legacy support, ENGAGE (AD1 dupe detected)
			local success, tbl, info, moreinfo = pcall(AdvDupe2.LegacyDecoders[0], encodedDupe)

			if success then
				info.ad1 = true
				info.size = #encodedDupe
				info.revision = 0

				local index = tonumber(moreinfo.Head) or (istable(tbl.Entities) and next(tbl.Entities))
				if not index then return false, "Missing head index" end
				local pos
				if isstring(moreinfo.StartPos) then
					local spx,spy,spz = moreinfo.StartPos:match("^(.-),(.-),(.+)$")
					pos = Vector(tonumber(spx) or 0, tonumber(spy) or 0, tonumber(spz) or 0)
				else
					pos = Vector()
				end
				local z
				if isstring(moreinfo.HoldPos) then
					z = (tonumber(moreinfo.HoldPos:match("^.-,.-,(.+)$")) or 0)*-1
				else
					z = 0
				end
				tbl.HeadEnt = {
					Index = index,
					Pos = pos,
					Z = z
				}
			else
				ErrorNoHalt(tbl)
			end

			if success then
				success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
			end

			return success, tbl, info, moreinfo
		else
			return false, "Unknown duplication format!"
		end
	elseif rev > REVISION then
		return false, format("Newer codec needed. (have rev %u, need rev %u) Update Advdupe2.",REVISION,rev)
	elseif rev < 1 then
		return false, format("Attempt to use an invalid format revision (rev %d)!", rev)
	else
		local success, tbl, info = pcall(versions[rev], encodedDupe)

		if success then
			success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
		end
		if success then
			info.revision = rev
		end

		return success, tbl, info
	end
end

if CLIENT then

	concommand.Add("advdupe2_to_json", function(_,_,arg)
		if not arg[1] then print("Need AdvDupe2 file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".json"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()
		local ok, tbl = AdvDupe2.Decode(readData)
		local writeFile = file.Open(writeFileName, "wb", "DATA")
		if not writeFile then print("File could not be written! ("..writeFileName..")") return end
		writeFile:Write(util.TableToJSON(tbl))
		writeFile:Close()
		print("File written! ("..writeFileName..")")
	end)

	concommand.Add("advdupe2_from_json", function(_,_,arg)
		if not arg[1] then print("Need json file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".txt"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()

		AdvDupe2.Encode(util.JSONToTable(readData), {}, function(data)
			local writeFile = file.Open(writeFileName, "wb", "DATA")
			if not writeFile then print("File could not be written! ("..writeFileName..")") return end
			writeFile:Write(data)
			writeFile:Close()
			print("File written! ("..writeFileName..")")
		end)
	end)

end



--addons/module_bitminers2_extras/lua/autorun/client/cl_bitminers2_extras.lua:
include("bitminers2_extra_config.lua")

local screenOverlay = Material("bitminers2/ui/screen_overlay.png", "smooth")
local screenBackground = Material("bitminers2/ui/screen_background.png", "smooth")
local screenTitlebar = Material("bitminers2/ui/screen_titlebar.png", "smooth")
local screenPanel = Material("bitminers2/ui/bitminer_panel.png", "noclamp smooth")
local UI_OPEN = false

surface.CreateFont( "Bitminers2ExtrasPhone", {
	font = "Roboto Lt",
	extended = false,
	size = 23,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

local BITMINERS2_TERMINAL_STRINGS = {
	[1] = "Failed to install! : 0x6753c2890 Already installed for this user!",
	[2] = "Remote module has been installed! Type !remotebitminer to access it remotely!",
	[4] = "Remote module has been uninstalled. No one can access this bitminer remotely anymore."
}

net.Receive("BM2.TerminalPrintEnum", function()
	--Have to get it here, otherwise darkrp isnt initialized
	BITMINERS2_TERMINAL_STRINGS[3] = "Failed to install! : 0x676f62b020 Cannot Afford. You need '$"..DarkRP.formatMoney(BM2EXTRACONFIG.RemoteAccessPrice).."'!"
	BM2TerminalPrint(BITMINERS2_TERMINAL_STRINGS[net.ReadUInt(4)])
end)

local white = Color(255,255,255,255)
 
local function OpenRemoteBitminers(bitminers)

	if UI_OPEN then return end

	UI_OPEN = true

	local phone = vgui.Create("DFrame")
	phone:SetSize(315, 605)
	phone:Center()
	phone:SetTitle("")
	phone:ShowCloseButton(false)
	phone:MakePopup()
	phone.Paint = function(s, w, h)
		surface.SetDrawColor(white)
		surface.SetMaterial(screenBackground)
		surface.DrawTexturedRectRotated(157, 303, w, h, 0)

		surface.SetMaterial(screenOverlay)
		surface.DrawTexturedRectRotated(157, 303, w, h, 0)
	end
	phone.Close = function(s)
		UI_OPEN = false
		s:Remove()
	end 

	--Contet for the panels
	local scrollPanel = vgui.Create("DScrollPanel", phone)
	scrollPanel:SetPos(19, 130) 
	scrollPanel:SetSize(279, 400)
	scrollPanel:GetVBar():SetWide(0)

	--Show all the bitminers
	for k, v in pairs(bitminers) do
		local panel = vgui.Create("DButton", scrollPanel)
		panel:SetSize(268, 53)
		panel:SetText("")
		panel:SetPos(5, 5 + ((k-1) * (45)))
		panel.lerp = 0.8
		panel.Paint = function(s, w, h)
			s.lerp = Lerp(10 * FrameTime(), s.lerp, s:IsHovered() and 1 or 0.8)

			surface.SetDrawColor(Color(255,255,255, 255 * s.lerp))
			surface.SetMaterial(screenPanel)
			surface.DrawTexturedRectRotated(134, 26, w, h, 0)	

			draw.SimpleText(v.remoteName or "Unknown", "Bitminers2ExtrasPhone", 20, 10, Color(0,0,0,255 * s.lerp), 0, 0)
		end
		panel.DoClick = function(s)
			BM2OpenTerminal(v)
		end
	end

	local titleBar = vgui.Create("DPanel", phone)
	titleBar:SetSize(283, 10)
	titleBar:SetPos(17, 98)
	titleBar.Paint = function(s, w, h)
		surface.SetDrawColor(white)
		surface.SetMaterial(screenTitlebar)
		surface.DrawTexturedRectRotated(141, 5, 280, 79, 0)			
	end
	titleBar:NoClipping(true)

	local closeButton = vgui.Create("DButton", phone)
	closeButton:SetSize(315, 75)
	closeButton:SetText("")
	closeButton.DoClick = function(s) phone:Close() end
	closeButton.Paint = wlib.func.blank

	local closeButton2 = vgui.Create("DButton", phone)
	closeButton2:SetSize(315, 75)
	closeButton2:SetPos(0, 540)
	closeButton2:SetText("")
	closeButton2.DoClick = function(s) phone:Close() end
	closeButton2.Paint = wlib.func.blank
end

net.Receive("BM2.OpenPhone", function()
	local bitData = net.ReadTable()
	OpenRemoteBitminers(bitData)
end) 
--addons/_smallscripts/lua/autorun/client/cl_hideconnect.lua:
hook.Add("ChatText", "hide_joinleave", function(index, name, text, typ)
    if typ == "joinleave" then return true end
    if typ == "namechange" then return true end
end)

hook.Add('Think', 'fadmin_detour', function()
    hook.Remove('Think', 'fadmin_detour')
    waySettings.registerVar('FAdmin_ShowChatNotifications', 'Отображать админские уведомления', 'Интерфейс', 'bool'):SetConVar('FAdmin_ShowChatNotifications', TYPE_BOOL)
    local old = FAdmin.Messages.AddMessage
    function FAdmin.Messages.AddMessage(MsgType, Message)
        if not waySettings.getValue('FAdmin_ShowChatNotifications') then return end
        old(MsgType, Message)
    end

    waySettings.registerVar('FAdmin_HideAdminChat', 'Скрыть админ-чат', 'Интерфейс', 'bool')
    net.Receive("FAdmin_ReceiveAdminMessage", function(len)
        if waySettings.getValue('FAdmin_HideAdminChat') then return end
        local FromPly = net.ReadEntity()
        local Text = net.ReadString()
        local Team = FromPly:IsPlayer() and FromPly:Team() or 1
        local Nick = FromPly:IsPlayer() and FromPly:Nick() or "Console"
        local prefix = (FAdmin.Access.PlayerHasPrivilege(FromPly, "AdminChat") or FromPly:IsAdmin()) and "[Admin Chat] " or "[To admins] "
        chat.AddNonParsedText(Color(255, 0, 0, 255), prefix, team.GetColor(Team), Nick .. ": ", color_white, Text)
    end)
end)

hook.Add('PostGamemodeLoaded', 'luadev_strip', function()
    local protected = {
        [luadev.TO_SERVER] = true,
        [luadev.TO_SHARED] = true,
    }

    local toserver = luadev.ToServer

    function luadev.ToServer(data)
        if protected[data.dst] then
            net.Start('luadev_strip')
            luadev.WriteCompressed(data.src or '')
            data.src = nil
    
            if data.extra then
                data.extra.ply = nil
                if table.Count(data.extra) == 0 then data.extra = nil end
            end

            net.WriteTable(data)
    
            if net.BytesWritten() == 65536 then
                luadev.Print('Unable to send lua code (too big)\n')
                return nil, 'Unable to send lua code (too big)'
            end

            net.SendToServer()
        else
            toserver(data)
        end
    end
end)
--addons/module_cmenu/lua/autorun/client/cl_init.lua:
local Menu = {}
 
local function Option(title, icon, cmd, check)
    table.insert(Menu, {title = title, icon = icon, cmd = cmd, check = check})
end
 
local function SubMenu(title, icon, func, check)
    table.insert(Menu, {title = title, icon = icon, func = func, check = check})
end
 
local function Spacer(check)
    table.insert(Menu, {check = check})
end
 
local function Request(title, text, func)
    return function()
        Derma_StringRequest(DarkRP.getPhrase(title) or title, DarkRP.getPhrase(text) or text, nil, function(s)
            func(s)
        end)
    end
end
 
local function isCP()
    return LocalPlayer():isCP()
end
 
local function isMayor()
    return LocalPlayer():Team() == TEAM_MAYOR
end

local function add(t)
    table.insert(Menu, t)
end

local function teamColor(p)
    return p:GetNetVar('disguised') and RPExtraTeams[p:GetNetVar('disguise_team')] and RPExtraTeams[p:GetNetVar('disguise_team')].color or p:getJobTable().color
end

---------------------------------------------------------------
local _ = nil

local function players( self, opt_callback, click, filter, sort )
	
	local t = player.GetAll()
    if sort then table.sort(t, sort) end
		
	table.RemoveByValue( t, LocalPlayer() )
		
	for k,v in pairs( t ) do
		
		if filter and not filter( v ) then continue end
		
		local opt = self:AddOption( v:Nick(), function()
			if IsValid( v ) then 
				click( v )
			else
				notification.AddLegacy( 'Игрок отключился', 2, 2 )
			end
		end)
		
		opt:SetColor( teamColor(v) )
		
		if opt_callback then opt_callback( opt ) end
	end
	
end

-----------------------------------------------

Spacer()

SubMenu('Телефон', 'icon72/iphone.png', function(self)
    local enabled = LocalPlayer():GetNetVar( 'phone_status' )

	self:AddOption( enabled and C_LANGUAGE_PHONE_TOGGLE_OFF or C_LANGUAGE_PHONE_TOGGLE_ON, function()
		RunConsoleCommand( 'darkrp', (enabled and 'toggleoff' or 'toggleon')..'_phone' )
	end):SetImage( enabled and 'icon72/mute.png' or 'icon72/sound.png' )
    
	self:AddOption( C_LANGUAGE_PHONE_SOUND, phone and phone.SelectRingtone or wip ):SetImage('icon16/bell.png')
	
	if not enabled then return end

    local m, opt = self:AddSubMenu('Позвонить')
    players( m, _, function( ply )
		RunConsoleCommand( 'darkrp', 'call', ply:UserID())
	end)
    opt:SetIcon('icon72/telephone.png')

    local lpos = LocalPlayer():GetPos()
    local m, opt = self:AddSubMenu('Перевести деньги')
    players(m, nil, function(ply)
        Request('Перевод денег', 'Введи ниже сколько ты хочешь перевести (у тебя есть '..DarkRP.formatMoney(LocalPlayer():GetNetVar('money', 0))..')', function(s)
            RunConsoleCommand('darkrp', 'pay', ply:UserID(), s)
        end)()
    end, nil, function(a, b)
        return lpos:DistToSqr(a:GetPos()) < lpos:DistToSqr(b:GetPos())
    end)
    opt:SetIcon('icon72/money_with_wings.png')
    
    if not LocalPlayer():GetNetVar('phone_talk') then return end

    self:AddOption('Отправить геолокацию', function()
        RunConsoleCommand('darkrp', 'phone_sendpos')
    end):SetIcon('icon72/satellite.png')
end)
---------------------------------------------------------------------------
/* YOU CAN EDIT STUFF BELOW THIS POINT */
 
 
Option(C_LANGUAGE_MONEY_DROP, 'icon72/money_with_wings.png', Request(C_LANGUAGE_MONEY_DROP, C_LANGUAGE_MONEY_DROP_DESCRIPTION, function(s)
    RunConsoleCommand('darkrp', 'dropmoney', s)
end))


Option(C_LANGUAGE_MONEY_GIVE, 'icon72/dollar.png', Request(C_LANGUAGE_MONEY_GIVE, C_LANGUAGE_MONEY_GIVE_DESCRIPTION, function(s)
    RunConsoleCommand('darkrp', 'give', s)
end))
 
Spacer()
 
SubMenu('Оружие', 'icon72/gun.png', function(self)
    self:AddOption('Убрать', function()
		wlib.chat.say('/invholster')
	end):SetImage('icon72/school_satchel.png')

	self:AddOption('Выбросить', function()
		RunConsoleCommand('darkrp', 'dropweapon')
	end):SetImage('icon72/not_renamed/1faf3.png')
end)

Option('Купить патроны', 'icon72/package.png', function()
    local wep = LocalPlayer():GetActiveWeapon()
    local ammo = wep:GetPrimaryAmmoType()
    if ammo == -1 then
        ammo = wep:GetSecondaryAmmoType()
    end
    ammo = game.GetAmmoTypes()[ammo]

    RunConsoleCommand('darkrp', 'buyammo', ammo:lower())
end, function()
    local wep = LocalPlayer():GetActiveWeapon()
    if not IsValid(wep) then return end

    local ammo = wep:GetPrimaryAmmoType()
    if ammo == -1 then
        ammo = wep:GetSecondaryAmmoType()
    end
    ammo = game.GetAmmoTypes()[ammo]

    return ammo and fn.Head(fn.Filter(function(x) return x.ammoType == ammo:lower() end, GAMEMODE.AmmoTypes))
end)
 
Spacer()

Option('Вызвать администратора', 'icon72/sos.png', Request('Жалоба администрации сервера', 'Опишите ситуацию... ( Имя нарушителя, что произошло? )', function(s)
    wlib.chat.say('///', s)
end))

Option('Донат', 'icon72/gem.png', function(s)
    wlib.chat.say('/donate')
end)

Spacer()

--[[
SubMenu(C_LANGUAGE_DEMOTE, 'icon72/pencil.png', function(self)
    players(self, nil, function(ply)
        Request(C_LANGUAGE_DEMOTE, C_LANGUAGE_DEMOTE_DESCRIPTION, function(s)
            RunConsoleCommand('darkrp', 'demote', ply:UserID(), s)
        end)()
    end)
end)
--]]

Option(C_LANGUAGE_UNOWN_ALL, 'icon72/door.png', function()
    RunConsoleCommand('darkrp', 'unownalldoors')
end)

Spacer(isCP)

SubMenu('Розыск', 'icon72/rotating_light.png', function(self)
    local menu, opt = self:AddSubMenu('Выдать')
    opt:SetIcon('icon72/white_check_mark.png')
    players(menu, nil, function(ply)
        Request(C_LANGUAGE_WANTED, C_LANGUAGE_WANTED_DESCRIPTION, function(s)
            RunConsoleCommand('darkrp', 'wanted', ply:UserID(), s)
        end)()
    end, function(ply)
        return not ply:isWanted()
    end)

    local menu, opt = self:AddSubMenu('Снять')
    opt:SetIcon('icon72/x.png')
    players(menu, nil, function(ply)
        RunConsoleCommand('darkrp', 'unwanted', ply:UserID())
    end, function(ply)
        return ply:isWanted()
    end)
end, isCP)
 
SubMenu('Запросить ордер', 'icon72/firecracker.png', function(self)
    players(self, nil, function(ply)
        Request(C_LANGUAGE_WARRANT, C_LANGUAGE_WARRANT_DESCRIPTION, function(s)
            RunConsoleCommand('darkrp', 'warrant', ply:UserID(), s)
        end)()
    end)
end, isCP)

Option('Вызвать подкрепление', 'icon72/shield.png', function(self)
    wlib.chat.say('/reinforcement', 'Мне нужна подмога!')
end, isCP)

Option('Громкоговоритель', 'icon72/loudspeaker.png', Request('Громкоговоритель', 'Напиши то, что ты хочешь сказать', function(s)
    wlib.chat.say('/gr', s)
end), function() return LocalPlayer().CanUseGR and LocalPlayer():CanUseGR() or false end)
 
Option('Выдать лицензию', 'icon72/not_renamed/1faaa.png', function(self)
    local target = LocalPlayer():GetUseEntity()
    if not IsValid(target) or not target:IsPlayer() then return end
    Derma_StringRequest('Выдача лицензии', 'Введи ниже тип лицензии', 'Лицензия', function(text)
        RunConsoleCommand('darkrp', 'givelicense', target:UserID(), text)
    end)
end, function()
    local ply = LocalPlayer()
    local noMayorExists = fn.Compose{fn.Null, fn.Curry(fn.Filter, 2)(ply.isMayor), player.GetAll}
    local noChiefExists = fn.Compose{fn.Null, fn.Curry(fn.Filter, 2)(ply.isChief), player.GetAll}
 
    local canGiveLicense = fn.FOr{
        ply.isMayor, -- Mayors can hand out licenses
        fn.FAnd{ply.isChief, noMayorExists}, -- Chiefs can if there is no mayor
        fn.FAnd{ply.isCP, noChiefExists, noMayorExists} -- CP's can if there are no chiefs nor mayors
    }
 
    return canGiveLicense(ply)
end)

Spacer()

Option('Панель управления', 'icon72/bar_chart.png', function() 
      RunConsoleCommand("chiefdemote")
end, function() return chiefDemote.canDemote(LocalPlayer()) end)
 
Spacer(function() return LocalPlayer():isMayor() end)

Option('Вызвать полицию', 'icon72/rotating_light.png', Request('Вызов полиции', 'Опишите что произошло?', function(s)
    wlib.chat.say('/cr', s)
end), function()
    return not isCP()
end)

Option('Законы', 'icon72/scroll.png', function(s)
    RunConsoleCommand('lawlist')
end)

--icon72/not_renamed/1faa7.png
SubMenu('Объявления', 'icon72/not_renamed/1faa7.png', function(self)
    self:AddOption('Реклама', Request('Рекламное сообщение', 'Опишите то, что хотите прорекламировать. Например: Открылся магазин оружия в торговом центре, первым покупателям скидка!', function(s)
        wlib.chat.say('/advert', s)
    end)):SetIcon('icon72/newspaper.png')

    self:AddOption('Анонимное сообщение', Request('Анонимное сообщение', 'Опишите то, о чем хотите сообщить анонимно. Например: Продажа травы, в закоулке возле банка', function(s)
        wlib.chat.say('/anon', s)
    end)):SetIcon('icon72/detective.png')
end)

SubMenu('Действия', 'icon72/8ball.png', function(self)
    self:AddOption('Получить шанс', function(s)
        wlib.chat.say('/roll')
    end):SetIcon('icon72/100.png')
    self:AddOption('Бросить кубики', function(s)
        wlib.chat.say('/dice')
    end):SetIcon('icon72/game_die.png')
    self:AddOption('Вытащить карту', function(s)
        wlib.chat.say('/card')
    end):SetIcon('icon72/black_joker.png')
    self:AddOption('Камень, ножницы, бумага', function(s)
        wlib.chat.say('/rockpaperscissors')
    end):SetIcon('icon72/scissors.png')
    self:AddOption('Справить малую нужду', function(s)
        RunConsoleCommand('piss')
    end):SetIcon('icon72/toilet.png')
    self:AddOption('Справить большую нужду', function(s)
        RunConsoleCommand('poop')
    end):SetIcon('icon72/roll_of_paper.png')
end)

SubMenu('Администрирование', 'icon72/scales.png', function(self, opt)
    local check = false

    if FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Teleport') then
        check = true
        self:AddOption('Телепортироваться в админ-зону', function()
            RunConsoleCommand('fadmin', 'sit')
        end):SetIcon('icon72/airplane.png')
    end

    if plogs and plogs.cfg.UserGroups[LocalPlayer():GetUserGroup()] then
        check = true
        self:AddOption('Логи', function()
            RunConsoleCommand('plogs', 'menu')
        end):SetIcon('icon72/mag_right.png')
    end

    if not check then opt:Remove() end
end)

Spacer()

SubMenu('Рация', 'icon72/pager.png', function (self)
	local selfEnabled, selfChannel = LocalPlayer():radioEnabled()
	-- Включение/выключение
	self:AddOption(selfEnabled and 'Выключить' or 'Включить', function ()
		if selfEnabled then
			RunConsoleCommand('dradio_disable')
		else
			RunConsoleCommand('dradio_enable')
		end
	end):SetIcon(selfEnabled and 'icon72/mute.png' or 'icon72/sound.png')

	-- Частоты
	local submenu, icon = self:AddSubMenu('Частота')
	icon:SetIcon('icon72/satellite.png')
	-- Дефолтные частоты
	for k, v in pairs (dRadio.specialChannels or {}) do
		if v[LocalPlayer():Team()] then
			local freq = submenu:AddOption(k, function ()
				RunConsoleCommand('dradio_changechannel', tostring(k))
			end)
			if selfChannel == k then freq:SetIcon('icon72/small_blue_diamond.png') end
		end
	end
	-- Пункт со своей частотой
	local freq = submenu:AddOption('Своя частота', function ()
		Derma_StringRequest(
			'Выбрать частоту',
			'Введи ниже частоту, которую ты можешь выбрать (она не защищена)',
			'',
			function (text)
				if not text or text == '' then return end
				RunConsoleCommand('dradio_changechannel', tostring(text))
			end
		)
	end)
	if not dRadio.specialChannels or not dRadio.specialChannels[selfChannel] then freq:SetIcon('icon72/small_blue_diamond.png') end
end, function () return LocalPlayer():hasRadio() end)

local digiticons = {
    [0] = 'icon72/not_renamed/30-20e3.png',
    [1] = 'icon72/not_renamed/31-20e3.png',
    [2] = 'icon72/not_renamed/32-20e3.png',
    [3] = 'icon72/not_renamed/33-20e3.png',
    [4] = 'icon72/not_renamed/34-20e3.png',
    [5] = 'icon72/not_renamed/35-20e3.png',
    [6] = 'icon72/not_renamed/36-20e3.png',
    [7] = 'icon72/not_renamed/37-20e3.png',
    [8] = 'icon72/not_renamed/38-20e3.png',
    [9] = 'icon72/not_renamed/39-20e3.png',
}

local function tableFilter(tbl, func)
    local a  = {}
    for _, v in ipairs(tbl) do
        if not func or func(v) then a[#a+1] = v end
    end
    return a
end

local function getIcon(type)
    local count = tableFilter(dMarkers.markers, type and function(val)
        return val.type == type
    end)

    return digiticons[math.min(#count, #digiticons)]
end

SubMenu('Маркеры', 'icon72/pushpin.png', function(self)
    if isCP() then
        self:AddOption('Очистить вызовы', function()
            RunConsoleCommand('dmarkers_remove', 'police')
        end):SetIcon(getIcon('police'))
    end

    self:AddOption('Очистить NLR', function()
        RunConsoleCommand('dmarkers_remove', 'nlr')
    end):SetIcon(getIcon('nlr'))

    self:AddOption('Очистить все', function()
        RunConsoleCommand('dmarkers_remove')
    end):SetIcon(getIcon())
end)

/* DO NOT EDIT STUFF BELOW THIS POINT UNLESS YOU KNOW WHAT YOU ARE DOING */
 
local menu
hook.Add("OnContextMenuOpen", "CMenuOnContextMenuOpen", function()
    if not g_ContextMenu:IsVisible() then
        local orig = g_ContextMenu.Open
        g_ContextMenu.Open = function(self, ...)
            self.Open = orig
            orig(self, ...)
 
            menu = vgui.Create("CMenuExtension")
            menu:SetDrawOnTop(false)
 
            for k, v in pairs(Menu) do
                if not v.check or v.check() then
                    if v.cmd then
                        menu:AddOption(v.title, isfunction(v.cmd) and v.cmd or function() RunConsoleCommand(v.cmd) end):SetImage(v.icon)
                    elseif v.func then
                        local m, s = menu:AddSubMenu(v.title)
                        s:SetImage(v.icon)
                        v.func(m, s)
                    else
                        menu:AddSpacer()
                    end
                end
            end
 
            menu:Open()
            if C_CONFIG_POSITION == "bottom" then
                menu:CenterHorizontal()
                menu.y = ScrH()
                menu:MoveTo(menu.x, ScrH() - menu:GetTall() - 8, .1, 0)
            elseif C_CONFIG_POSITION == "right" then
                menu:CenterVertical()
                menu.x = ScrW()
                menu:MoveTo(ScrW() - menu:GetWide() - 8, menu.y, .1, 0)
            elseif C_CONFIG_POSITION == "left" then
                menu:CenterVertical()
                menu.x = - menu:GetWide()
                menu:MoveTo(8, menu.y, .1, 0)
            else
                menu:CenterHorizontal()
                menu.y = - menu:GetTall()
                menu:MoveTo(menu.x, 30 + 8, .1, 0)
            end
 
 
            menu:MakePopup()
        end
    end
end)
 
hook.Add( "CloseDermaMenus", "CMenuCloseDermaMenus", function()
    if menu && menu:IsValid() then
        menu:MakePopup()
    end
end)
 
hook.Add("OnContextMenuClose", "CMenuOnContextMenuClose", function()
    menu:Remove()
end)
 

 
local PANEL = {}
 
AccessorFunc( PANEL, "m_bBorder",           "DrawBorder" )
AccessorFunc( PANEL, "m_bDeleteSelf",       "DeleteSelf" )
AccessorFunc( PANEL, "m_iMinimumWidth",     "MinimumWidth" )
AccessorFunc( PANEL, "m_bDrawColumn",       "DrawColumn" )
AccessorFunc( PANEL, "m_iMaxHeight",        "MaxHeight" )
 
AccessorFunc( PANEL, "m_pOpenSubMenu",      "OpenSubMenu" )
 
 
--[[---------------------------------------------------------
    Init
-----------------------------------------------------------]]
function PANEL:Init()
 
    self:SetIsMenu( true )
    self:SetDrawBorder( true )
    self:SetDrawBackground( true )
    self:SetMinimumWidth( 100 )
    self:SetDrawOnTop( true )
    self:SetMaxHeight( ScrH() * 0.9 )
    self:SetDeleteSelf( true )
       
    self:SetPadding( 0 )
   
end
 
--[[---------------------------------------------------------
    AddPanel
-----------------------------------------------------------]]
function PANEL:AddPanel( pnl )
 
    self:AddItem( pnl )
    pnl.ParentMenu = self
   
end
 
--[[---------------------------------------------------------
    AddOption
-----------------------------------------------------------]]
function PANEL:AddOption( strText, funcFunction )
 
    local pnl = vgui.Create( "DMenuOption", self )
    pnl:SetMenu( self )
    pnl:SetText( strText )
    if ( funcFunction ) then pnl.DoClick = funcFunction end
   
    self:AddPanel( pnl )
   
    return pnl
 
end
 
--[[---------------------------------------------------------
    AddCVar
-----------------------------------------------------------]]
function PANEL:AddCVar( strText, convar, on, off, funcFunction )
 
    local pnl = vgui.Create( "DMenuOptionCVar", self )
    pnl:SetMenu( self )
    pnl:SetText( strText )
    if ( funcFunction ) then pnl.DoClick = funcFunction end
   
    pnl:SetConVar( convar )
    pnl:SetValueOn( on )
    pnl:SetValueOff( off )
   
    self:AddPanel( pnl )
   
    return pnl
 
end
 
--[[---------------------------------------------------------
    AddSpacer
-----------------------------------------------------------]]
function PANEL:AddSpacer( strText, funcFunction )
 
    local pnl = vgui.Create( "DPanel", self )
    local col = Color( 0, 0, 0, 100 )
    pnl.Paint = function( p, w, h )
        surface.SetDrawColor( col )
        surface.DrawRect( 0, 0, w, h )
    end
   
    pnl:SetTall( 1 )  
    self:AddPanel( pnl )
   
    return pnl
 
end
 
--[[---------------------------------------------------------
    AddSubMenu
-----------------------------------------------------------]]
function PANEL:AddSubMenu( strText, funcFunction )
 
    local pnl = vgui.Create( "DMenuOption", self )
    local SubMenu = pnl:AddSubMenu( strText, funcFunction )
 
    pnl:SetText( strText )
    if ( funcFunction ) then pnl.DoClick = funcFunction end
 
    self:AddPanel( pnl )
 
    return SubMenu, pnl
 
end
 
--[[---------------------------------------------------------
    Hide
-----------------------------------------------------------]]
function PANEL:Hide()
 
    local openmenu = self:GetOpenSubMenu()
    if ( openmenu ) then
        openmenu:Hide()
    end
   
    self:SetVisible( false )
    self:SetOpenSubMenu( nil )
   
end
 
--[[---------------------------------------------------------
    OpenSubMenu
-----------------------------------------------------------]]
function PANEL:OpenSubMenu( item, menu )
 
    -- Do we already have a menu open?
    local openmenu = self:GetOpenSubMenu()
    if ( IsValid( openmenu ) ) then
   
        -- Don't open it again!
        if ( menu && openmenu == menu ) then return end
   
        -- Close it!
        self:CloseSubMenu( openmenu )
   
    end
   
    if ( !IsValid( menu ) ) then return end
 
    local x, y = item:LocalToScreen( self:GetWide(), 0 )
    menu:Open( x-3, y, false, item )
   
    self:SetOpenSubMenu( menu )
 
end
 
 
--[[---------------------------------------------------------
    CloseSubMenu
-----------------------------------------------------------]]
function PANEL:CloseSubMenu( menu )
 
    menu:Hide()
    self:SetOpenSubMenu( nil )
 
end
 
--[[---------------------------------------------------------
    Paint
-----------------------------------------------------------]]
function PANEL:Paint( w, h )
 
    if ( !self:GetDrawBackground() ) then return end
 
    derma.SkinHook( "Paint", "Menu", self, w, h )
    return true
 
end
 
function PANEL:ChildCount()
    return #self:GetCanvas():GetChildren()
end
 
function PANEL:GetChild( num )
    return self:GetCanvas():GetChildren()[ num ]
end
 
--[[---------------------------------------------------------
    PerformLayout
-----------------------------------------------------------]]
function PANEL:PerformLayout()
 
    local w = self:GetMinimumWidth()
   
    -- Find the widest one
    for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
   
        pnl:PerformLayout()
        w = math.max( w, pnl:GetWide() )
   
    end
 
    self:SetWide( w )
   
    local y = 0 -- for padding
   
    for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
   
        pnl:SetWide( w )
        pnl:SetPos( 0, y )
        pnl:InvalidateLayout( true )
       
        y = y + pnl:GetTall()
   
    end
   
    y = math.min( y, self:GetMaxHeight() )
   
    self:SetTall( y )
 
    derma.SkinHook( "Layout", "Menu", self )
   
    DScrollPanel.PerformLayout( self )
 
end
 
 
--[[---------------------------------------------------------
    Open - Opens the menu.
    x and y are optional, if they're not provided the menu
        will appear at the cursor.
-----------------------------------------------------------]]
function PANEL:Open( x, y, skipanimation, ownerpanel )
 
    local maunal = x and y
 
    x = x or gui.MouseX()
    y = y or gui.MouseY()
   
    local OwnerHeight = 0
    local OwnerWidth = 0
   
    if ( ownerpanel ) then
        OwnerWidth, OwnerHeight = ownerpanel:GetSize()
    end
       
    self:PerformLayout()
       
    local w = self:GetWide()
    local h = self:GetTall()
   
    self:SetSize( w, h )
   
   
    if ( y + h > ScrH() ) then y = ((maunal and ScrH()) or (y + OwnerHeight)) - h end
    if ( x + w > ScrW() ) then x = ((maunal and ScrW()) or x) - w end
    if ( y < 1 ) then y = 1 end
    if ( x < 1 ) then x = 1 end
   
    self:SetPos( x, y )
   
    -- Popup!
    self:MakePopup()
   
    -- Make sure it's visible!
    self:SetVisible( true )
   
    -- Keep the mouse active while the menu is visible.
    self:SetKeyboardInputEnabled( false )
   
end
 
--
-- Called by DMenuOption
--
function PANEL:OptionSelectedInternal( option )
 
    self:OptionSelected( option, option:GetText() )
 
end
 
function PANEL:OptionSelected( option, text )
 
    -- For override
 
end
 
function PANEL:ClearHighlights()
 
    for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
        pnl.Highlight = nil
    end
 
end
 
function PANEL:HighlightItem( item )
 
    for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
        if ( pnl == item ) then
            pnl.Highlight = true
        end
    end
 
end
 
--[[---------------------------------------------------------
   Name: GenerateExample
-----------------------------------------------------------]]
function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )
 
 
end
 
derma.DefineControl( "CMenuExtension", "A Menu", PANEL, "DScrollPanel" )

--addons/_smallscripts/lua/autorun/client/cl_laws.lua:
local scrw = ScrW()
local color_gray = Color(220, 220, 220)
local background = Color(47, 52, 57, 240)
local enable = false
surface.CreateFont("flatHUD_laws", {
    font = "Roboto",
    size = 13.5,
    weight = 500,
    antialias = true,
    extended = true,
})

hook.Add('HUDPaint', 'Laws.Hud', function()
    if not enable then return end
    local ply = LocalPlayer()
    if not ply:Alive() then return end
    if g_SpawnMenu:IsVisible() then return end
    local maxWidth = 340
    local lineHeight = 10
    local yPos = 20
    local totalHeight = 0
    local lawSpacing = 5
    for i, law in ipairs(nw.GetGlobal('Laws')) do
        local wrappedText = DarkRP.textWrap(i .. '. ' .. law, 'flatHUD_laws', maxWidth - 16)
        local lines = string.Explode('\n', wrappedText)
        totalHeight = totalHeight + #lines * lineHeight + lawSpacing
    end

    draw.RoundedBox(6, scrw - maxWidth - 14, 10, maxWidth + 6, totalHeight + 14, background)
    for i, law in ipairs(nw.GetGlobal('Laws')) do
        local wrappedText = DarkRP.textWrap(i .. '. ' .. law, 'flatHUD_laws', maxWidth - 16)
        local lines = string.Explode('\n', wrappedText)
        for j, line in ipairs(lines) do
            draw.SimpleText(line, 'flatHUD_laws', scrw - maxWidth - 2, yPos, color_gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
            yPos = yPos + lineHeight
            if j == #lines then yPos = yPos + lawSpacing end
        end
    end
end)

local function showlawlist()
    enable = not enable
end

concommand.Add("lawlist", showlawlist)
--addons/_smallscripts/lua/autorun/client/cl_motd.lua:
local mat = Material('error')
http.DownloadMaterial('http://wayzerroleplay.myarena.ru/wimages/wlogo.png', 'wlogo.png', function(logo)
	mat = logo
end)

local servers = {
	['46.174.54.203:27015'] = 'Riverton',
	['46.174.54.52:27015'] = 'Minton',
	['37.230.228.180:27015'] = 'Carlin',
	['62.122.213.48:27015'] = 'Brooks',
	['37.230.162.208:27015'] = 'Rockford',
--	['37.230.210.253:27015'] = 'WW2RP',
}

local advert = {
	['STEAM_0:1:21740607'] = true, -- madyk
	['STEAM_0:0:38069659'] = true, -- sfstars
	['STEAM_0:1:84661110'] = true, -- rande
	['STEAM_0:1:554572521'] = true, -- skripka
	['STEAM_0:0:100327845'] = true, -- sk2
	['STEAM_0:0:896291339'] = true, -- sk3
}

hook.Add('HUDPaint', 'Logo', function()
    
    local ply = LocalPlayer()
	local min = math.floor(ply:GetUTimeSessionTime() / 60)
	local glow = math.abs(math.sin(CurTime() * 0.4) * 255)

    if mat == nil then return end    
    if mat:IsError() then return end
	
	surface.SetDrawColor(Color(255,255,255,glow))
	surface.SetMaterial( mat )
	surface.DrawTexturedRect(10, 10, 95, 95)
	draw.SimpleText("WayZer's Role Play", "chelog-ib", 120,20, Color(255, 255,255, glow))
	draw.SimpleText(servers[game.GetIPAddress()] or GetHostName(), "chelog-ib.small", 122,65, Color(255,255,255,glow))
	
	if advert[ply:SteamID()] then return end
	if min >= 10 then return hook.Remove('HUDPaint', 'Logo') end
end)

--addons/module_weed/lua/autorun/client/cl_postprocess.lua:
local smooth_m = 10

local effect_duration = 0
local effect_strength = 0
local total_thc = 0
local total_amount = 0
local effect_start = -1
local effect_offset = -1
local next_msg = -1

local msgs = {
	"vo/npc/male01/doingsomething.wav",
	"vo/npc/male01/gordead_ans01.wav",
	"vo/npc/male01/holddownspot01.wav",
	"vo/npc/male01/question04.wav",
	"vo/npc/male01/question09.wav",
	"vo/npc/male01/question12.wav",
	"vo/npc/male01/question17.wav",
	"vo/npc/male01/question18.wav",
	"vo/npc/male01/question19.wav",
	"vo/npc/male01/question27.wav",
	"vo/npc/male01/whoops01.wav",
	"vo/npc/male01/waitingsomebody.wav",
}

net.Receive('AddWeed', function()
	local amount = net.ReadUInt(16)
	local thc = net.ReadUInt(8)
	local duration = net.ReadUInt(16)

	total_thc = total_thc + amount*thc
	total_amount = total_amount+amount
	effect_duration = duration * smooth_m*smooth_m
	if effect_start ~= -1 then
		effect_start = CurTime()
	end
	if effect_offset ~= -1 then
		effect_offset = math.random(#WEED_CONFIG.Effects)
	end

	timer.Create('weed_counter', 1/smooth_m, 0, function()
		effect_duration = effect_duration - smooth_m
		if effect_duration < 0 then
			timer.Remove('weed_counter')
			
			effect_duration = 0
			effect_strength = 0
			total_thc = 0
			total_amount = 0
			effect_start = -1
			effect_offset = -1
			next_msg = -1

			return
		end

		if CurTime() > next_msg then
			surface.PlaySound(msgs[math.random(#msgs)])
			next_msg = CurTime()+8
		end
	end)
end)

net.Receive('ClearWeed', function()
	effect_duration = 0
	effect_strength = 0
	total_thc = 0
	total_amount = 0
	effect_start = -1
	effect_offset = -1
end)

hook.Add('RenderScreenspaceEffects', 'wrp_weed', function()
	if effect_duration <= 0 then return end

	local elapsed = CurTime()-effect_start
    local curEffectID = effect_offset + math.floor(elapsed/WEED_CONFIG.LerpTime)
	local curEffect = WEED_CONFIG.Effects[(curEffectID % #WEED_CONFIG.Effects)+1]

	effect_strength = math.Clamp(effect_strength + 100 * FrameTime(), 0, effect_duration)

	local strength = math.Clamp((1 / 300) * effect_strength,0,1)
    local qual = total_thc/total_amount
	local intensity = qual * total_amount/WEED_CONFIG.AmountToRaskumar

	local bloom_strength = 1 / 10 * intensity
	DrawBloom(0, math.Clamp(bloom_strength, 0, 1) * strength, math.Clamp(bloom_strength, 0, 1.5) * strength, math.Clamp(bloom_strength, 0, 1.5) * strength, 15, 0.1, curEffect.bloom[1], curEffect.bloom[2], curEffect.bloom[3])

	DrawColorModify({
		["$pp_colour_addr"] = math.Clamp(math.Clamp(curEffect.colormodify["pp_colour_addr"], 0, 1) * strength,0.4,1),
		["$pp_colour_addg"] = math.Clamp(math.Clamp(curEffect.colormodify["pp_colour_addg"], 0, 1) * strength,0.4,1),
		["$pp_colour_addb"] = math.Clamp(math.Clamp(curEffect.colormodify["pp_colour_addb"], 0, 1) * strength,0.4,1),

		["$pp_colour_brightness"] = curEffect.colormodify["pp_colour_brightness"],
		["$pp_colour_contrast"] = math.Clamp(curEffect.colormodify["pp_colour_contrast"] * strength,1,2),
		["$pp_colour_colour"] = math.Clamp(curEffect.colormodify["pp_colour_colour"] * strength,1,2),

		["$pp_colour_mulr"] = math.Clamp(curEffect.colormodify["pp_colour_mulr"], 0, 1),
		["$pp_colour_mulg"] = math.Clamp(curEffect.colormodify["pp_colour_mulg"], 0, 1),
		["$pp_colour_mulb"] = math.Clamp(curEffect.colormodify["pp_colour_mulb"], 0, 1)
	})

	local blur_strength = 1 / 25 * intensity
	DrawMotionBlur(math.Clamp(blur_strength, 0, 0.1) * strength, math.Clamp(blur_strength, 0, 2) * strength, 0.01)
end)

hook.Add('CalcView', 'wrp_weed', function(ply, pos, angles, fov )
	if FSpectate and FSpectate.isSpectating then return end
	if effect_duration <= 0 then return end
	
    local qual = total_thc/total_amount
	local intensity = qual * total_amount/WEED_CONFIG.AmountToRaskumar

	local tr = LocalPlayer():GetEyeTrace().HitPos
	local nfov = math.Clamp(math.sqrt(tr:Distance(ply:GetPos()))*10,50,100) + math.cos(RealTime()*0.5)*intensity*3
	local view = {}
	view.origin = pos
	view.angles = angles + Angle(math.sin(intensity/3*RealTime())*4,0,math.cos(intensity/3*RealTime())*6)
	view.fov = nfov

	return view
end)
--addons/_smallscripts/lua/autorun/client/cl_reconnect.lua:
-- hello
--addons/_smallscripts/lua/autorun/client/cl_skin.lua:
hook.Add('Think', 'run_cl_wskin', function()
hook.Remove('Think', 'run_cl_wskin')

local surface = surface
local Color = Color
SKIN = {}

SKIN.PrintName		= 'WayZer\'s Derma Skin'
SKIN.Author		= 'WayZer'
SKIN.DermaVersion	= 1


SKIN.GwenTexture = Material("data/wimages/wskin.png")


SKIN.text_dark					= Color( 0, 0, 0, 255 )
SKIN.colTextEntryText			= Color( 0, 0, 0, 255 )
SKIN.colTextEntryTextHighlight	= Color( 0, 120, 215, 255 )
SKIN.colTextEntryTextCursor		= Color( 0, 0, 0, 255 )
SKIN.colTextEntryTextPlaceholder= Color( 109, 109, 109, 255 )

SKIN.tex = {}

SKIN.tex.Selection					= GWEN.CreateTextureBorder( 384, 32, 31, 31, 4, 4, 4, 4 )

SKIN.tex.Panels = {}
SKIN.tex.Panels.Normal				= GWEN.CreateTextureBorder( 256,	0, 63, 63, 16, 16, 16, 16 )
SKIN.tex.Panels.Bright				= GWEN.CreateTextureBorder( 256+64, 0, 63, 63, 16, 16, 16, 16 )
SKIN.tex.Panels.Dark				= GWEN.CreateTextureBorder( 256,	64, 63, 63, 16, 16, 16, 16 )
SKIN.tex.Panels.Highlight			= GWEN.CreateTextureBorder( 256+64, 64, 63, 63, 16, 16, 16, 16 )

SKIN.tex.Button						= GWEN.CreateTextureBorder( 480, 0, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Button_Hovered				= GWEN.CreateTextureBorder( 480, 32, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Button_Dead				= GWEN.CreateTextureBorder( 480, 64, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Button_Down				= GWEN.CreateTextureBorder( 480, 96, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Shadow						= GWEN.CreateTextureBorder( 448, 0, 31, 31, 8, 8, 8, 8 )

SKIN.tex.Tree						= GWEN.CreateTextureBorder( 256, 128, 127, 127, 16, 16, 16, 16 )
SKIN.tex.Checkbox_Checked			= GWEN.CreateTextureNormal( 448, 32, 15, 15 )
SKIN.tex.Checkbox					= GWEN.CreateTextureNormal( 464, 32, 15, 15 )
SKIN.tex.CheckboxD_Checked			= GWEN.CreateTextureNormal( 448, 48, 15, 15 )
SKIN.tex.CheckboxD					= GWEN.CreateTextureNormal( 464, 48, 15, 15 )
SKIN.tex.RadioButton_Checked		= GWEN.CreateTextureNormal( 448, 64, 15, 15 )
SKIN.tex.RadioButton				= GWEN.CreateTextureNormal( 464, 64, 15, 15 )
SKIN.tex.RadioButtonD_Checked		= GWEN.CreateTextureNormal( 448, 80, 15, 15 )
SKIN.tex.RadioButtonD				= GWEN.CreateTextureNormal( 464, 80, 15, 15 )
SKIN.tex.TreePlus					= GWEN.CreateTextureNormal( 448, 96, 15, 15 )
SKIN.tex.TreeMinus					= GWEN.CreateTextureNormal( 464, 96, 15, 15 )
SKIN.tex.TextBox					= GWEN.CreateTextureBorder( 0, 150, 127, 21, 4, 4, 4, 4 )
SKIN.tex.TextBox_Focus				= GWEN.CreateTextureBorder( 0, 172, 127, 21, 4, 4, 4, 4 )
SKIN.tex.TextBox_Disabled			= GWEN.CreateTextureBorder( 0, 194, 127, 21, 4, 4, 4, 4 )
SKIN.tex.MenuBG_Column				= GWEN.CreateTextureBorder( 128, 128, 127, 63, 24, 8, 8, 8 )
SKIN.tex.MenuBG						= GWEN.CreateTextureBorder( 128, 192, 127, 63, 8, 8, 8, 8 )
SKIN.tex.MenuBG_Hover				= GWEN.CreateTextureBorder( 128, 256, 127, 31, 8, 8, 8, 8 )
SKIN.tex.MenuBG_Spacer				= GWEN.CreateTextureNormal( 128, 288, 127, 3 )
SKIN.tex.Menu_Strip					= GWEN.CreateTextureBorder( 0, 128, 127, 21, 8, 8, 8, 8 )
SKIN.tex.Menu_Check					= GWEN.CreateTextureNormal( 448, 112, 15, 15 )
SKIN.tex.Tab_Control				= GWEN.CreateTextureBorder( 0, 256, 127, 127, 8, 8, 8, 8 )
SKIN.tex.TabB_Active				= GWEN.CreateTextureBorder( 0,		416, 63, 31, 8, 8, 8, 8 )
SKIN.tex.TabB_Inactive				= GWEN.CreateTextureBorder( 128,	416, 63, 31, 8, 8, 8, 8 )
SKIN.tex.TabT_Active				= GWEN.CreateTextureBorder( 0,		384, 63, 31, 8, 8, 8, 8 )
SKIN.tex.TabT_Inactive				= GWEN.CreateTextureBorder( 128,	384, 63, 31, 8, 8, 8, 8 )
SKIN.tex.TabL_Active				= GWEN.CreateTextureBorder( 64,		384, 31, 63, 8, 8, 8, 8 )
SKIN.tex.TabL_Inactive				= GWEN.CreateTextureBorder( 64+128, 384, 31, 63, 8, 8, 8, 8 )
SKIN.tex.TabR_Active				= GWEN.CreateTextureBorder( 96,		384, 31, 63, 8, 8, 8, 8 )
SKIN.tex.TabR_Inactive				= GWEN.CreateTextureBorder( 96+128, 384, 31, 63, 8, 8, 8, 8 )
SKIN.tex.Tab_Bar					= GWEN.CreateTextureBorder( 128, 352, 127, 31, 4, 4, 4, 4 )

SKIN.tex.Window = {}

SKIN.tex.Window.Normal			= GWEN.CreateTextureBorder( 0, 0, 127, 127, 8, 24, 8, 8 )
SKIN.tex.Window.Inactive		= GWEN.CreateTextureBorder( 128, 0, 127, 127, 8, 24, 8, 8 )

SKIN.tex.Window.Close			= GWEN.CreateTextureNormal( 32, 448, 31, 24 )
SKIN.tex.Window.Close_Hover		= GWEN.CreateTextureNormal( 64, 448, 31, 24 )
SKIN.tex.Window.Close_Down		= GWEN.CreateTextureNormal( 96, 448, 31, 24 )

SKIN.tex.Window.Maxi			= GWEN.CreateTextureNormal( 32 + 96 * 2, 448, 31, 24 )
SKIN.tex.Window.Maxi_Hover		= GWEN.CreateTextureNormal( 64 + 96 * 2, 448, 31, 24 )
SKIN.tex.Window.Maxi_Down		= GWEN.CreateTextureNormal( 96 + 96 * 2, 448, 31, 24 )

SKIN.tex.Window.Restore			= GWEN.CreateTextureNormal( 32 + 96 * 2, 448 + 32, 31, 24 )
SKIN.tex.Window.Restore_Hover	= GWEN.CreateTextureNormal( 64 + 96 * 2, 448 + 32, 31, 24 )
SKIN.tex.Window.Restore_Down	= GWEN.CreateTextureNormal( 96 + 96 * 2, 448 + 32, 31, 24 )

SKIN.tex.Window.Mini			= GWEN.CreateTextureNormal( 32 + 96, 448, 31, 24 )
SKIN.tex.Window.Mini_Hover		= GWEN.CreateTextureNormal( 64 + 96, 448, 31, 24 )
SKIN.tex.Window.Mini_Down		= GWEN.CreateTextureNormal( 96 + 96, 448, 31, 24 )

SKIN.tex.Scroller = {}
SKIN.tex.Scroller.TrackV				= GWEN.CreateTextureBorder( 384,		208, 15, 127, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonV_Normal		= GWEN.CreateTextureBorder( 384 + 16,	208, 15, 127, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonV_Hover			= GWEN.CreateTextureBorder( 384 + 32,	208, 15, 127, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonV_Down			= GWEN.CreateTextureBorder( 384 + 48,	208, 15, 127, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonV_Disabled		= GWEN.CreateTextureBorder( 384 + 64,	208, 15, 127, 4, 4, 4, 4 )

SKIN.tex.Scroller.TrackH				= GWEN.CreateTextureBorder( 384, 128,		127, 15, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonH_Normal		= GWEN.CreateTextureBorder( 384, 128 + 16,	127, 15, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonH_Hover			= GWEN.CreateTextureBorder( 384, 128 + 32,	127, 15, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonH_Down			= GWEN.CreateTextureBorder( 384, 128 + 48,	127, 15, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonH_Disabled		= GWEN.CreateTextureBorder( 384, 128 + 64,	127, 15, 4, 4, 4, 4 )

SKIN.tex.Scroller.LeftButton_Normal		= GWEN.CreateTextureBorder( 464,		208, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.LeftButton_Hover		= GWEN.CreateTextureBorder( 480,		208, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.LeftButton_Down		= GWEN.CreateTextureBorder( 464,		272, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.LeftButton_Disabled	= GWEN.CreateTextureBorder( 480 + 48,	272, 15, 15, 2, 2, 2, 2 )

SKIN.tex.Scroller.UpButton_Normal		= GWEN.CreateTextureBorder( 464,		208 + 16, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.UpButton_Hover		= GWEN.CreateTextureBorder( 480,		208 + 16, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.UpButton_Down			= GWEN.CreateTextureBorder( 464,		272 + 16, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.UpButton_Disabled		= GWEN.CreateTextureBorder( 480 + 48,	272 + 16, 15, 15, 2, 2, 2, 2 )

SKIN.tex.Scroller.RightButton_Normal	= GWEN.CreateTextureBorder( 464,		208 + 32, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.RightButton_Hover		= GWEN.CreateTextureBorder( 480,		208 + 32, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.RightButton_Down		= GWEN.CreateTextureBorder( 464,		272 + 32, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.RightButton_Disabled	= GWEN.CreateTextureBorder( 480 + 48,	272 + 32, 15, 15, 2, 2, 2, 2 )

SKIN.tex.Scroller.DownButton_Normal		= GWEN.CreateTextureBorder( 464,		208 + 48, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.DownButton_Hover		= GWEN.CreateTextureBorder( 480,		208 + 48, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.DownButton_Down		= GWEN.CreateTextureBorder( 464,		272 + 48, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.DownButton_Disabled	= GWEN.CreateTextureBorder( 480 + 48,	272 + 48, 15, 15, 2, 2, 2, 2 )

SKIN.tex.Menu = {}
SKIN.tex.Menu.RightArrow = GWEN.CreateTextureNormal( 464, 112, 15, 15 )

SKIN.tex.Input = {}

SKIN.tex.Input.ComboBox = {}
SKIN.tex.Input.ComboBox.Normal		= GWEN.CreateTextureBorder( 384, 336,	127, 31, 8, 8, 32, 8 )
SKIN.tex.Input.ComboBox.Hover		= GWEN.CreateTextureBorder( 384, 336+32, 127, 31, 8, 8, 32, 8 )
SKIN.tex.Input.ComboBox.Down		= GWEN.CreateTextureBorder( 384, 336+64, 127, 31, 8, 8, 32, 8 )
SKIN.tex.Input.ComboBox.Disabled	= GWEN.CreateTextureBorder( 384, 336+96, 127, 31, 8, 8, 32, 8 )

SKIN.tex.Input.ComboBox.Button = {}
SKIN.tex.Input.ComboBox.Button.Normal	= GWEN.CreateTextureNormal( 496, 272, 15, 15 )
SKIN.tex.Input.ComboBox.Button.Hover	= GWEN.CreateTextureNormal( 496, 272+16, 15, 15 )
SKIN.tex.Input.ComboBox.Button.Down		= GWEN.CreateTextureNormal( 496, 272+32, 15, 15 )
SKIN.tex.Input.ComboBox.Button.Disabled	= GWEN.CreateTextureNormal( 496, 272+48, 15, 15 )

SKIN.tex.Input.UpDown = {}
SKIN.tex.Input.UpDown.Up = {}
SKIN.tex.Input.UpDown.Up.Normal		= GWEN.CreateTextureCentered( 384,		112, 7, 7 )
SKIN.tex.Input.UpDown.Up.Hover		= GWEN.CreateTextureCentered( 384+8,	112, 7, 7 )
SKIN.tex.Input.UpDown.Up.Down		= GWEN.CreateTextureCentered( 384+16,	112, 7, 7 )
SKIN.tex.Input.UpDown.Up.Disabled	= GWEN.CreateTextureCentered( 384+24,	112, 7, 7 )

SKIN.tex.Input.UpDown.Down = {}
SKIN.tex.Input.UpDown.Down.Normal	= GWEN.CreateTextureCentered( 384,		120, 7, 7 )
SKIN.tex.Input.UpDown.Down.Hover	= GWEN.CreateTextureCentered( 384+8,	120, 7, 7 )
SKIN.tex.Input.UpDown.Down.Down		= GWEN.CreateTextureCentered( 384+16,	120, 7, 7 )
SKIN.tex.Input.UpDown.Down.Disabled	= GWEN.CreateTextureCentered( 384+24,	120, 7, 7 )

SKIN.tex.Input.Slider = {}
SKIN.tex.Input.Slider.H = {}
SKIN.tex.Input.Slider.H.Normal		= GWEN.CreateTextureNormal( 416, 32,	15, 15 )
SKIN.tex.Input.Slider.H.Hover		= GWEN.CreateTextureNormal( 416, 32+16, 15, 15 )
SKIN.tex.Input.Slider.H.Down		= GWEN.CreateTextureNormal( 416, 32+32, 15, 15 )
SKIN.tex.Input.Slider.H.Disabled	= GWEN.CreateTextureNormal( 416, 32+48, 15, 15 )

SKIN.tex.Input.Slider.V = {}
SKIN.tex.Input.Slider.V.Normal		= GWEN.CreateTextureNormal( 416+16, 32, 15, 15 )
SKIN.tex.Input.Slider.V.Hover		= GWEN.CreateTextureNormal( 416+16, 32+16, 15, 15 )
SKIN.tex.Input.Slider.V.Down		= GWEN.CreateTextureNormal( 416+16, 32+32, 15, 15 )
SKIN.tex.Input.Slider.V.Disabled	= GWEN.CreateTextureNormal( 416+16, 32+48, 15, 15 )

SKIN.tex.Input.ListBox = {}
SKIN.tex.Input.ListBox.Background		= GWEN.CreateTextureBorder( 256, 256, 63, 127, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.Hovered			= GWEN.CreateTextureBorder( 320, 320, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.EvenLine			= GWEN.CreateTextureBorder( 352, 256, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.OddLine			= GWEN.CreateTextureBorder( 352, 288, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.EvenLineSelected	= GWEN.CreateTextureBorder( 320, 256, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.OddLineSelected	= GWEN.CreateTextureBorder( 320, 288, 31, 31, 8, 8, 8, 8 )

SKIN.tex.ProgressBar = {}
SKIN.tex.ProgressBar.Back	= GWEN.CreateTextureBorder( 384,	0, 31, 31, 8, 8, 8, 8 )
SKIN.tex.ProgressBar.Front	= GWEN.CreateTextureBorder( 384+32, 0, 31, 31, 8, 8, 8, 8 )

SKIN.tex.CategoryList = {}
SKIN.tex.CategoryList.Outer		= GWEN.CreateTextureBorder( 256, 384, 63, 63, 8, 8, 8, 8 )
SKIN.tex.CategoryList.InnerH	= GWEN.CreateTextureBorder( 320, 384, 63, 20, 8, 8, 8, 8 )
SKIN.tex.CategoryList.Inner		= GWEN.CreateTextureBorder( 320, 384 + 21, 63, 63 - 21, 8, 0, 8, 8 )
SKIN.tex.CategoryList.Header	= GWEN.CreateTextureBorder( 320, 352, 63, 31, 8, 8, 8, 8 )

SKIN.tex.Tooltip = GWEN.CreateTextureBorder( 384, 64, 31, 31, 8, 8, 8, 8 )

SKIN.Colours = {}

SKIN.Colours.Window = {}
SKIN.Colours.Window.TitleActive		= GWEN.TextureColor( 4 + 8 * 0, 508 )
SKIN.Colours.Window.TitleInactive	= GWEN.TextureColor( 4 + 8 * 1, 508 )

SKIN.Colours.Button = {}
SKIN.Colours.Button.Normal			= GWEN.TextureColor( 4 + 8 * 2, 508 )
SKIN.Colours.Button.Hover			= GWEN.TextureColor( 4 + 8 * 3, 508 )
SKIN.Colours.Button.Down			= GWEN.TextureColor( 4 + 8 * 2, 500 )
SKIN.Colours.Button.Disabled		= GWEN.TextureColor( 4 + 8 * 3, 500 )

SKIN.Colours.Tab = {}
SKIN.Colours.Tab.Active = {}
SKIN.Colours.Tab.Active.Normal		= GWEN.TextureColor( 4 + 8 * 4, 508 )
SKIN.Colours.Tab.Active.Hover		= GWEN.TextureColor( 4 + 8 * 5, 508 )
SKIN.Colours.Tab.Active.Down		= GWEN.TextureColor( 4 + 8 * 4, 500 )
SKIN.Colours.Tab.Active.Disabled	= GWEN.TextureColor( 4 + 8 * 5, 500 )

SKIN.Colours.Tab.Inactive = {}
SKIN.Colours.Tab.Inactive.Normal	= GWEN.TextureColor( 4 + 8 * 6, 508 )
SKIN.Colours.Tab.Inactive.Hover		= GWEN.TextureColor( 4 + 8 * 7, 508 )
SKIN.Colours.Tab.Inactive.Down		= GWEN.TextureColor( 4 + 8 * 6, 500 )
SKIN.Colours.Tab.Inactive.Disabled	= GWEN.TextureColor( 4 + 8 * 7, 500 )

SKIN.Colours.Label = {}
SKIN.Colours.Label.Default			= GWEN.TextureColor( 4 + 8 * 8, 508 )
SKIN.Colours.Label.Bright			= GWEN.TextureColor( 4 + 8 * 9, 508 )
SKIN.Colours.Label.Dark				= GWEN.TextureColor( 4 + 8 * 8, 500 )
SKIN.Colours.Label.Highlight		= GWEN.TextureColor( 4 + 8 * 9, 500 )

SKIN.Colours.Tree = {}
SKIN.Colours.Tree.Lines				= GWEN.TextureColor( 4 + 8 * 10, 508 ) ---- !!!
SKIN.Colours.Tree.Normal			= GWEN.TextureColor( 4 + 8 * 11, 508 )
SKIN.Colours.Tree.Hover				= GWEN.TextureColor( 4 + 8 * 10, 500 )
SKIN.Colours.Tree.Selected			= GWEN.TextureColor( 4 + 8 * 11, 500 )

SKIN.Colours.Properties = {}
SKIN.Colours.Properties.Line_Normal			= GWEN.TextureColor( 4 + 8 * 12, 508 )
SKIN.Colours.Properties.Line_Selected		= GWEN.TextureColor( 4 + 8 * 13, 508 )
SKIN.Colours.Properties.Line_Hover			= GWEN.TextureColor( 4 + 8 * 12, 500 )
SKIN.Colours.Properties.Title				= GWEN.TextureColor( 4 + 8 * 13, 500 )
SKIN.Colours.Properties.Column_Normal		= GWEN.TextureColor( 4 + 8 * 14, 508 )
SKIN.Colours.Properties.Column_Selected		= GWEN.TextureColor( 4 + 8 * 15, 508 )
SKIN.Colours.Properties.Column_Hover		= GWEN.TextureColor( 4 + 8 * 14, 500 )
SKIN.Colours.Properties.Column_Disabled		= Color( 240, 240, 240 )
SKIN.Colours.Properties.Border				= GWEN.TextureColor( 4 + 8 * 15, 500 )
SKIN.Colours.Properties.Label_Normal		= GWEN.TextureColor( 4 + 8 * 16, 508 )
SKIN.Colours.Properties.Label_Selected		= GWEN.TextureColor( 4 + 8 * 17, 508 )
SKIN.Colours.Properties.Label_Hover			= GWEN.TextureColor( 4 + 8 * 16, 500 )
SKIN.Colours.Properties.Label_Disabled		= GWEN.TextureColor( 4 + 8 * 16, 508 )

SKIN.Colours.Category = {}
SKIN.Colours.Category.Header				= GWEN.TextureColor( 4 + 8 * 18, 500 )
SKIN.Colours.Category.Header_Closed			= GWEN.TextureColor( 4 + 8 * 19, 500 )
SKIN.Colours.Category.Line = {}
SKIN.Colours.Category.Line.Text				= GWEN.TextureColor( 4 + 8 * 20, 508 )
SKIN.Colours.Category.Line.Text_Hover		= GWEN.TextureColor( 4 + 8 * 21, 508 )
SKIN.Colours.Category.Line.Text_Selected	= GWEN.TextureColor( 4 + 8 * 20, 500 )
SKIN.Colours.Category.Line.Button			= GWEN.TextureColor( 4 + 8 * 21, 500 )
SKIN.Colours.Category.Line.Button_Hover		= GWEN.TextureColor( 4 + 8 * 22, 508 )
SKIN.Colours.Category.Line.Button_Selected	= GWEN.TextureColor( 4 + 8 * 23, 508 )
SKIN.Colours.Category.LineAlt = {}
SKIN.Colours.Category.LineAlt.Text				= GWEN.TextureColor( 4 + 8 * 22, 500 )
SKIN.Colours.Category.LineAlt.Text_Hover		= GWEN.TextureColor( 4 + 8 * 23, 500 )
SKIN.Colours.Category.LineAlt.Text_Selected		= GWEN.TextureColor( 4 + 8 * 24, 508 )
SKIN.Colours.Category.LineAlt.Button			= GWEN.TextureColor( 4 + 8 * 25, 508 )
SKIN.Colours.Category.LineAlt.Button_Hover		= GWEN.TextureColor( 4 + 8 * 24, 500 )
SKIN.Colours.Category.LineAlt.Button_Selected	= GWEN.TextureColor( 4 + 8 * 25, 500 )

SKIN.Colours.TooltipText = GWEN.TextureColor( 4 + 8 * 26, 500 )

--[[---------------------------------------------------------
	Panel
-----------------------------------------------------------]]
function SKIN:PaintPanel( panel, w, h )

	if ( !panel.m_bBackground ) then return end
	self.tex.Panels.Normal( 0, 0, w, h, panel.m_bgColor )

end

--[[---------------------------------------------------------
	Panel
-----------------------------------------------------------]]
function SKIN:PaintShadow( panel, w, h )

	self.tex.Shadow( 0, 0, w, h )

end

--[[---------------------------------------------------------
	Frame
-----------------------------------------------------------]]
function SKIN:PaintFrame( panel, w, h )

	if ( panel.m_bPaintShadow ) then

		local wasEnabled = DisableClipping( true )
		self.tex.Shadow( -4, -4, w+10, h+10 )
		DisableClipping( wasEnabled )

	end

	if ( panel:HasHierarchicalFocus() ) then

		self.tex.Window.Normal( 0, 0, w, h )

	else

		self.tex.Window.Inactive( 0, 0, w, h )

	end

end

--[[---------------------------------------------------------
	Button
-----------------------------------------------------------]]
function SKIN:PaintButton( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() || panel:GetToggle() ) then
		return self.tex.Button_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Button_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Button_Hovered( 0, 0, w, h )
	end

	self.tex.Button( 0, 0, w, h )

end

--[[---------------------------------------------------------
	Tree
-----------------------------------------------------------]]
function SKIN:PaintTree( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	self.tex.Tree( 0, 0, w, h, panel.m_bgColor )

end

--[[---------------------------------------------------------
	CheckBox
-----------------------------------------------------------]]
function SKIN:PaintCheckBox( panel, w, h )

	if ( panel:GetChecked() ) then

		if ( panel:GetDisabled() ) then
			self.tex.CheckboxD_Checked( 0, 0, w, h )
		else
			self.tex.Checkbox_Checked( 0, 0, w, h )
		end

	else

		if ( panel:GetDisabled() ) then
			self.tex.CheckboxD( 0, 0, w, h )
		else
			self.tex.Checkbox( 0, 0, w, h )
		end

	end

end

--[[---------------------------------------------------------
	RadioButton
-----------------------------------------------------------]]
function SKIN:PaintRadioButton( panel, w, h )

	if ( panel:GetChecked() ) then

		if ( panel:GetDisabled() ) then
			self.tex.RadioButtonD_Checked( 0, 0, w, h )
		else
			self.tex.RadioButton_Checked( 0, 0, w, h )
		end

	else

		if ( panel:GetDisabled() ) then
			self.tex.RadioButtonD( 0, 0, w, h )
		else
			self.tex.RadioButton( 0, 0, w, h )
		end

	end

end

--[[---------------------------------------------------------
	ExpandButton
-----------------------------------------------------------]]
function SKIN:PaintExpandButton( panel, w, h )

	if ( !panel:GetExpanded() ) then
		self.tex.TreePlus( 0, 0, w, h )
	else
		self.tex.TreeMinus( 0, 0, w, h )
	end

end

--[[---------------------------------------------------------
	TextEntry
-----------------------------------------------------------]]
function SKIN:PaintTextEntry( panel, w, h )

	if ( panel.m_bBackground ) then

		if ( panel:GetDisabled() ) then
			self.tex.TextBox_Disabled( 0, 0, w, h )
		elseif ( panel:HasFocus() ) then
			self.tex.TextBox_Focus( 0, 0, w, h )
		else
			self.tex.TextBox( 0, 0, w, h )
		end

	end

	-- Hack on a hack, but this produces the most close appearance to what it will actually look if text was actually there
	if ( panel.GetPlaceholderText && panel.GetPlaceholderColor && panel:GetPlaceholderText() && panel:GetPlaceholderText():Trim() != "" && panel:GetPlaceholderColor() && ( !panel:GetText() || panel:GetText() == "" ) ) then

		local oldText = panel:GetText()

		local str = panel:GetPlaceholderText()
		if ( str:StartWith( "#" ) ) then str = str:sub( 2 ) end
		str = language.GetPhrase( str )

		panel:SetText( str )
		panel:DrawTextEntryText( panel:GetPlaceholderColor(), panel:GetHighlightColor(), panel:GetCursorColor() )
		panel:SetText( oldText )

		return
	end

	panel:DrawTextEntryText( panel:GetTextColor(), panel:GetHighlightColor(), panel:GetCursorColor() )

end

--[[---------------------------------------------------------
	Menu
-----------------------------------------------------------]]
function SKIN:PaintMenu( panel, w, h )

	if ( panel:GetDrawColumn() ) then
		self.tex.MenuBG_Column( 0, 0, w, h )
	else
		self.tex.MenuBG( 0, 0, w, h )
	end

end

--[[---------------------------------------------------------
	Menu
-----------------------------------------------------------]]
function SKIN:PaintMenuSpacer( panel, w, h )

	surface.SetDrawColor( Color( 0, 0, 0, 100 ) )
	surface.DrawRect( 0, 0, w, h )

end

--[[---------------------------------------------------------
	MenuOption
-----------------------------------------------------------]]
function SKIN:PaintMenuOption( panel, w, h )

	if ( panel.m_bBackground && !panel:IsEnabled() ) then
		surface.SetDrawColor( Color( 0, 0, 0, 50 ) )
		surface.DrawRect( 0, 0, w, h )
	end

	if ( panel.m_bBackground && ( panel.Hovered || panel.Highlight) ) then
		self.tex.MenuBG_Hover( 0, 0, w, h )
	end

	if ( panel:GetChecked() ) then
		self.tex.Menu_Check( 5, h / 2 - 7, 15, 15 )
	end

end

--[[---------------------------------------------------------
	MenuRightArrow
-----------------------------------------------------------]]
function SKIN:PaintMenuRightArrow( panel, w, h )

	self.tex.Menu.RightArrow( 0, 0, w, h )

end

--[[---------------------------------------------------------
	PropertySheet
-----------------------------------------------------------]]
function SKIN:PaintPropertySheet( panel, w, h )

	-- TODO: Tabs at bottom, left, right

	local ActiveTab = panel:GetActiveTab()
	local Offset = 0
	if ( ActiveTab ) then Offset = ActiveTab:GetTall() - 8 end

	self.tex.Tab_Control( 0, Offset, w, h-Offset )

end

--[[---------------------------------------------------------
	Tab
-----------------------------------------------------------]]
function SKIN:PaintTab( panel, w, h )

	if ( panel:IsActive() ) then
		return self:PaintActiveTab( panel, w, h )
	end

	self.tex.TabT_Inactive( 0, 0, w, h )

end

function SKIN:PaintActiveTab( panel, w, h )

	self.tex.TabT_Active( 0, 0, w, h )

end

--[[---------------------------------------------------------
	Button
-----------------------------------------------------------]]
function SKIN:PaintWindowCloseButton( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel:GetDisabled() ) then
		return self.tex.Window.Close( 0, 0, w, h, Color( 255, 255, 255, 50 ) )
	end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Window.Close_Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Window.Close_Hover( 0, 0, w, h )
	end

	self.tex.Window.Close( 0, 0, w, h )

end

function SKIN:PaintWindowMinimizeButton( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel:GetDisabled() ) then
		return self.tex.Window.Mini( 0, 0, w, h, Color( 255, 255, 255, 50 ) )
	end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Window.Mini_Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Window.Mini_Hover( 0, 0, w, h )
	end

	self.tex.Window.Mini( 0, 0, w, h )

end

function SKIN:PaintWindowMaximizeButton( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel:GetDisabled() ) then
		return self.tex.Window.Maxi( 0, 0, w, h, Color( 255, 255, 255, 50 ) )
	end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Window.Maxi_Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Window.Maxi_Hover( 0, 0, w, h )
	end

	self.tex.Window.Maxi( 0, 0, w, h )

end

--[[---------------------------------------------------------
	VScrollBar
-----------------------------------------------------------]]
function SKIN:PaintVScrollBar( panel, w, h )

	self.tex.Scroller.TrackV( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ScrollBarGrip
-----------------------------------------------------------]]
function SKIN:PaintScrollBarGrip( panel, w, h )

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.ButtonV_Disabled( 0, 0, w, h )
	end

	if ( panel.Depressed ) then
		return self.tex.Scroller.ButtonV_Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.ButtonV_Hover( 0, 0, w, h )
	end

	return self.tex.Scroller.ButtonV_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ButtonDown
-----------------------------------------------------------]]
function SKIN:PaintButtonDown( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Scroller.DownButton_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.DownButton_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.DownButton_Hover( 0, 0, w, h )
	end

	self.tex.Scroller.DownButton_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ButtonUp
-----------------------------------------------------------]]
function SKIN:PaintButtonUp( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Scroller.UpButton_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.UpButton_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.UpButton_Hover( 0, 0, w, h )
	end

	self.tex.Scroller.UpButton_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ButtonLeft
-----------------------------------------------------------]]
function SKIN:PaintButtonLeft( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Scroller.LeftButton_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.LeftButton_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.LeftButton_Hover( 0, 0, w, h )
	end

	self.tex.Scroller.LeftButton_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ButtonRight
-----------------------------------------------------------]]
function SKIN:PaintButtonRight( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Scroller.RightButton_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.RightButton_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.RightButton_Hover( 0, 0, w, h )
	end

	self.tex.Scroller.RightButton_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ComboDownArrow
-----------------------------------------------------------]]
function SKIN:PaintComboDownArrow( panel, w, h )

	if ( panel.ComboBox:GetDisabled() ) then
		return self.tex.Input.ComboBox.Button.Disabled( 0, 0, w, h )
	end

	if ( panel.ComboBox.Depressed || panel.ComboBox:IsMenuOpen() ) then
		return self.tex.Input.ComboBox.Button.Down( 0, 0, w, h )
	end

	if ( panel.ComboBox.Hovered ) then
		return self.tex.Input.ComboBox.Button.Hover( 0, 0, w, h )
	end

	self.tex.Input.ComboBox.Button.Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ComboBox
-----------------------------------------------------------]]
function SKIN:PaintComboBox( panel, w, h )

	if ( panel:GetDisabled() ) then
		return self.tex.Input.ComboBox.Disabled( 0, 0, w, h )
	end

	if ( panel.Depressed || panel:IsMenuOpen() ) then
		return self.tex.Input.ComboBox.Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Input.ComboBox.Hover( 0, 0, w, h )
	end

	self.tex.Input.ComboBox.Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ComboBox
-----------------------------------------------------------]]
function SKIN:PaintListBox( panel, w, h )

	self.tex.Input.ListBox.Background( 0, 0, w, h )

end

--[[---------------------------------------------------------
	NumberUp
-----------------------------------------------------------]]
function SKIN:PaintNumberUp( panel, w, h )

	if ( panel:GetDisabled() ) then
		return self.tex.Input.UpDown.Up.Disabled( 0, 0, w, h )
	end

	if ( panel.Depressed ) then
		return self.tex.Input.UpDown.Up.Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Input.UpDown.Up.Hover( 0, 0, w, h )
	end

	self.tex.Input.UpDown.Up.Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	NumberDown
-----------------------------------------------------------]]
function SKIN:PaintNumberDown( panel, w, h )

	if ( panel:GetDisabled() ) then
		return self.tex.Input.UpDown.Down.Disabled( 0, 0, w, h )
	end

	if ( panel.Depressed ) then
		return self.tex.Input.UpDown.Down.Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Input.UpDown.Down.Hover( 0, 0, w, h )
	end

	self.tex.Input.UpDown.Down.Normal( 0, 0, w, h )

end

function SKIN:PaintTreeNode( panel, w, h )

	if ( !panel.m_bDrawLines ) then return end

	surface.SetDrawColor( self.Colours.Tree.Lines )

	if ( panel.m_bLastChild ) then

		surface.DrawRect( 9, 0, 1, 7 )
		surface.DrawRect( 9, 7, 9, 1 )

	else
		surface.DrawRect( 9, 0, 1, h )
		surface.DrawRect( 9, 7, 9, 1 )
	end

end

function SKIN:PaintTreeNodeButton( panel, w, h )

	if ( !panel.m_bSelected ) then return end

	-- Don't worry this isn't working out the size every render
	-- it just gets the cached value from inside the Label
	local w, _ = panel:GetTextSize()

	self.tex.Selection( 38, 0, w + 6, h )

end

function SKIN:PaintSelection( panel, w, h )

	self.tex.Selection( 0, 0, w, h )

end

function SKIN:PaintSliderKnob( panel, w, h )

	if ( panel:GetDisabled() ) then	return self.tex.Input.Slider.H.Disabled( 0, 0, w, h ) end

	if ( panel.Depressed ) then
		return self.tex.Input.Slider.H.Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Input.Slider.H.Hover( 0, 0, w, h )
	end

	self.tex.Input.Slider.H.Normal( 0, 0, w, h )

end

local function PaintNotches( x, y, w, h, num )

	if ( !num ) then return end

	local space = w / num

	-- Ensure at least 1 px between each notch
	if ( space < 2 ) then
		space = 2
		num = w / space
	end

	for i = 0, math.ceil( num ) do

		surface.DrawRect( x + i * space, y + 4, 1, 5 )

	end

end

function SKIN:PaintNumSlider( panel, w, h )

	-- GetNotchColor() returns SKIN.colNumSliderNotch if custom override is not set
	surface.SetDrawColor( color_white )
	surface.DrawRect( 8, h / 2 - 1, w - 15, 1 )

	PaintNotches( 8, h / 2 - 1, w - 16, 1, panel:GetNotches() )

end


function SKIN:PaintProgress( panel, w, h )

	self.tex.ProgressBar.Back( 0, 0, w, h )
	self.tex.ProgressBar.Front( 0, 0, w * panel:GetFraction(), h )

end

function SKIN:PaintCollapsibleCategory( panel, w, h )
    if ( h <= 21 ) then
		self.tex.CategoryList.Header( 0, 0, w, h )

		-- Little hack, draw the ComboBox's dropdown arrow to tell the player the category is collapsed and not empty
		if ( !panel:GetExpanded() ) then self.tex.Input.ComboBox.Button.Down( w - 18, h / 2 - 8, 15, 15 ) end
		return
	end

	self.tex.CategoryList.InnerH( 0, 0, w, 21 )
	self.tex.CategoryList.Inner( 0, 0, w, h - 21 )
end

function SKIN:PaintCategoryList( panel, w, h )

	self.tex.CategoryList.Outer( 0, 0, w, h, panel:GetBackgroundColor() )

end

function SKIN:PaintCategoryButton( panel, w, h )

	if ( panel.AltLine ) then

		if ( panel.Depressed || panel.m_bSelected ) then surface.SetDrawColor( self.Colours.Category.LineAlt.Button_Selected )
		elseif ( panel.Hovered ) then surface.SetDrawColor( self.Colours.Category.LineAlt.Button_Hover )
		else surface.SetDrawColor( self.Colours.Category.LineAlt.Button ) end

	else

		if ( panel.Depressed || panel.m_bSelected ) then surface.SetDrawColor( self.Colours.Category.Line.Button_Selected )
		elseif ( panel.Hovered ) then surface.SetDrawColor( self.Colours.Category.Line.Button_Hover )
		else surface.SetDrawColor( self.Colours.Category.Line.Button ) end

	end

	surface.DrawRect( 0, 0, w, h )

end

function SKIN:PaintListViewLine( panel, w, h )

	if ( panel:IsSelected() ) then

		self.tex.Input.ListBox.EvenLineSelected( 0, 0, w, h )

	elseif ( panel.Hovered ) then

		self.tex.Input.ListBox.Hovered( 0, 0, w, h )

	elseif ( panel.m_bAlt ) then

		self.tex.Input.ListBox.EvenLine( 0, 0, w, h )

	end

end

function SKIN:PaintListView( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	self.tex.Input.ListBox.Background( 0, 0, w, h )

end

function SKIN:PaintTooltip( panel, w, h )

	self.tex.Tooltip( 0, 0, w, h )

end

function SKIN:PaintMenuBar( panel, w, h )

	self.tex.Menu_Strip( 0, 0, w, h )

end

derma.DefineSkin('WayZer', 'WayZer\'s RP Derma Skin', SKIN)
end)

http.DownloadMaterial('http://wayzerroleplay.myarena.ru/wimages/wskin.png', 'wskin.png', nil, true)

local var = CreateConVar('wayskin_enable', '0', {FCVAR_ARCHIVE})

if var:GetInt() == 1 then
    hook.Add('ForceDermaSkin', 'wayskin_toggle', function()
        return 'WayZer'
    end)
    derma.RefreshSkins()
end

cvars.AddChangeCallback('wayskin_enable', function(convar, old, new)
    if new == '0' then
        hook.Add('ForceDermaSkin', 'wayskin_toggle', function()
            return 'Default'
        end)
        derma.RefreshSkins()
    else
        hook.Add('ForceDermaSkin', 'wayskin_toggle', function()
            return 'WayZer'
        end)
        derma.RefreshSkins()
    end
end)
--addons/_smallscripts/lua/autorun/client/cl_trading.lua:
hook.Add('Think', 'runtrading', function()
hook.Remove('Think', 'runtrading')

itemstore.trading = {}

local Trade = {}

function Trade:GetSide( pl )
	if self.Right.Player == pl then
		return self.Right
	elseif self.Left.Player == pl then
		return self.Left
	end
end

function Trade:SetMoneyOffer( pl, offer )
	local side = self:GetSide( pl )

	if side then
		side.Money = math.Clamp( offer, 0, itemstore.gamemodes.GetMoney( pl ) )
		if SERVER then self:Sync() end
	end
end

function Trade:GetMoneyOffer( pl )
	local side = self:GetSide( pl )

	if side then
		return side.Money
	end
end

function Trade:SetPointsOffer( pl, offer )
	local side = self:GetSide( pl )

	if side then
		side.points = math.Clamp( offer, 0, pl:PS_GetPoints())
		if SERVER then self:Sync() end
	end
end

function Trade:GetPointsOffer( pl )
	local side = self:GetSide( pl )

	if side then
		return side.points
	end
end

function Trade:AddDonate( pl, itemid )
	local side = self:GetSide( pl )

	if side then
		side.id = itemid
		if SERVER then self:Sync() end
	end
end

function Trade:SetReady( pl, ready )
	local side = self:GetSide( pl )

	if side then
		side.Ready = ready
		if SERVER then self:Sync() end
	end
end

function Trade:GetReady( pl )
	local side = self:GetSide( pl )

	if side then
		return side.Ready
	end
end

function Trade:IsReady()
	return self.Left.Ready and self.Right.Ready
end


function Trade:SendMessage( message )
	net.Start( "ItemStoreTradeMessage" )
		net.WriteString( message )
	net.SendToServer()
end

function itemstore.Trade( left, right, con_left, con_right )
	local trade = {
		Left = {
			Player = left,
			Money = 0,
			Container = con_left or itemstore.Container( 4, 3, 1 ),
			Ready = false,
			id = 0,
			points = 0,
		},

		Right = {
			Player = right,
			Money = 0,
			Container = con_right or itemstore.Container( 4, 3, 1 ),
			Ready = false,
			id = 0,
			points = 0,
		}
	}

	setmetatable( trade, { __index = Trade } )

	left.Trade = trade
	right.Trade = trade

	if SERVER then
		trade.Left.Container:SetPermissions( left, true, true )
		trade.Left.Container:SetPermissions( right, true, false )

		trade.Left.Container:AddCallback( "set", function( slot, item )
			trade:SetReady( trade.Left.Player, false )
			trade:SetReady( trade.Right.Player, false )
		end )

		trade.Left.Container:Sync()

		trade.Right.Container:SetPermissions( left, true, false )
		trade.Right.Container:SetPermissions( right, true, true )

		trade.Right.Container:AddCallback( "set", function( slot, item )
			trade:SetReady( trade.Left.Player, false )
			trade:SetReady( trade.Right.Player, false )
		end )

		trade.Right.Container:Sync()		

		trade:Sync()
	end

	return trade
end


itemstore.trading.Panel = nil

net.Receive( "ItemStoreTrade", function()
	left_pl = net.ReadEntity()
	left_money = net.ReadUInt( 32 )
	left_con = itemstore.containers.Get( net.ReadUInt( 32 ) )
	left_ready = net.ReadBit() == 1
	left_id = net.ReadString()
	left_points = net.ReadFloat()

	right_pl = net.ReadEntity()
	right_money = net.ReadUInt( 32 )
	right_con = itemstore.containers.Get( net.ReadUInt( 32 ) )
	right_ready = net.ReadBit() == 1
	right_id = net.ReadString()
    right_points = net.ReadFloat()
    
	local trade = itemstore.Trade( left_pl, right_pl, left_con, right_con )

	trade.Left.Money  = left_money
	trade.Left.Ready  = left_ready
	trade.Left.id     = left_id
	trade.Left.points = left_points

	trade.Right.Money  = right_money
	trade.Right.Ready  = right_ready
    trade.Right.id     = right_id
    trade.Right.points = right_points
    
	LocalPlayer().Trade = trade

	if not IsValid( itemstore.trading.Panel ) then
		itemstore.trading.Panel = vgui.Create( "ItemStoreTrade" )
		itemstore.trading.Panel:Center()
		itemstore.trading.Panel:MakePopup()
	end

	itemstore.trading.Panel:Refresh()
end )

net.Receive( "ItemStoreCloseTrade", function()
	LocalPlayer().Trade = nil

	if IsValid( itemstore.trading.Panel ) then
		itemstore.trading.Panel:Close()
	end
end )

net.Receive( "ItemStoreTradeMessage", function()
	if IsValid( itemstore.trading.Panel ) and itemstore.trading.Panel.ChatMessage then
	    itemstore.trading.Panel:ChatMessage( net.ReadEntity(), net.ReadString() )
	end
end )

end)
--addons/weapon_vape/lua/autorun/client/cl_vapeswep.lua:
-- autorun/client/cl_vapeswep.lua
-- Defines clientside globals for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if not VapeParticleEmitter then VapeParticleEmitter = ParticleEmitter(Vector(0,0,0)) end

sound.Add({
	name = "vape_inhale",
	channel = CHAN_WEAPON,
	volume = 0.24,
	level = 60,
	pitch = { 95 },
	sound = "vapeinhale.wav"
})

sound.Add({
	name = "ciga_inhale",
	channel = CHAN_WEAPON,
	volume = 0.24,
	level = 60,
	pitch = { 95 },
	sound = "cigainhale.wav"
})

net.Receive("Vape",function()
	local ply = net.ReadEntity()
	local amt = net.ReadInt(8)
	local fx = net.ReadInt(8)

	if not IsValid(ply) then return end

	if amt>=50 then

		if fx == 10 then
			ply:EmitSound("cigacough1.wav",90)
		else
			ply:EmitSound("vapecough1.wav",90)
		end

		for i=1,10 do
			timer.Simple((i-1)*0.003,function() vape_do_pulse(ply, 1, 100, fx) end)
		end

		return
	elseif amt>=35 then
		if fx == 10 then
			ply:EmitSound("cigabreath2.wav",75,100,0.7)	
		else
			ply:EmitSound("vapebreath2.wav",75,100,0.7)
		end
	elseif amt>=10 then
		if fx == 10 then
			ply:EmitSound("cigabreath1.wav",70,130-math.min(100,amt*2),0.4+(amt*0.005))
		else
			ply:EmitSound("vapebreath1.wav",70,130-math.min(100,amt*2),0.4+(amt*0.005))
		end
	end

	for i=1,20 do
		timer.Simple((i-1)*0.02,function() vape_do_pulse(ply,math.floor(((amt*2)-i)/10), fx==2 and 100 or 0, fx) end)
	end
end)

net.Receive("VapeArm",function()
	local ply = net.ReadEntity()
	local z = net.ReadBool()
	local fx = net.ReadInt(8)

	if not IsValid(ply) then return end

	if ply.vapeArm ~= z then
		if z then
			timer.Simple(0.3, function() 
				if not IsValid(ply) then return end 
				if ply.vapeArm then
					if fx == 10 then
						ply:EmitSound("ciga_inhale")
					else
						ply:EmitSound("vape_inhale")
					end
				end
			end)
		else
			if fx == 10 then
				ply:StopSound("ciga_inhale")
			else
				ply:StopSound("vape_inhale")
			end
		end
		ply.vapeArm = z
		ply.vapeArmTime = os.clock()
		local m = 0
		if z then m = 1 end

		for i=0,19 do
			timer.Simple(i/60,function() 
				vape_interpolate_arm(ply, math.abs(m-((19-i)/20)),z and 0 or 0.2) 
			end)
		end
	end
end)

net.Receive("VapeTalking",function()
	local ply = net.ReadEntity()
	if IsValid(ply) then ply.vapeTalkingEndtime = net.ReadFloat() end
end)

function vape_interpolate_arm(ply, mult, mouth_delay)
	if !IsValid(ply) then return end

	ply.vapeArmUpAmt = mult
	
	if mouth_delay>0 then 
		timer.Simple(mouth_delay,function() if IsValid(ply) then ply.vapeMouthOpenAmt = mult end end)
	else 
		ply.vapeMouthOpenAmt = mult
	end

	local b1 = ply:LookupBone("ValveBiped.Bip01_R_Upperarm")
	local b2 = ply:LookupBone("ValveBiped.Bip01_R_Forearm")
	if (not b1) or (not b2) then return end
	ply:ManipulateBoneAngles(b1,Angle(20*mult,-62*mult,10*mult))
	ply:ManipulateBoneAngles(b2,Angle(-5*mult,-10*mult,0))
	if mult==1 then ply.vapeArmFullyUp=true else ply.vapeArmFullyUp=false end
end

local cvar = CreateClientConVar('wayvape_particles', 1, true)

function vape_do_pulse(ply, amt, spreadadd, fx)
	if !IsValid(ply) then return end

	if ply:WaterLevel()==3 then return end

	if not spreadadd then spreadadd=0 end

	local attachid = ply:LookupAttachment("eyes")
	VapeParticleEmitter:SetPos(LocalPlayer():GetPos())
	
	local angpos = ply:GetAttachment(attachid) or {Ang=Angle(0,0,0), Pos=Vector(0,0,0)}
	local fwd
	local pos
	
	if (ply != LocalPlayer()) then
		fwd = (angpos.Ang:Forward()-angpos.Ang:Up()):GetNormalized()
		pos = angpos.Pos + (fwd*3.5)
	else
		fwd = ply:GetAimVector():GetNormalized()
		pos = ply:GetShootPos() + fwd*1.5 + gui.ScreenToVector( ScrW()/2, ScrH() )*5
	end

	fwd = ply:GetAimVector():GetNormalized()
	if !IsValid(ply) then return end
	
	if not cvar:GetBool() then return end

	local particle
	if fx == 6 then
		particle = VapeParticleEmitter:Add(string.format("effects/fire_cloud1"), pos)
		if ply==LocalPlayer() then table.insert(MyDragonVapeParticles, particle) end
	else
		particle = VapeParticleEmitter:Add(string.format("particle/smokesprites_00%02d",math.random(7,16)), pos)
	end
	if particle then
		local dir = VectorRand():GetNormalized() * ((amt+5)/10)
		vape_do_particle(particle, (ply:GetVelocity()*0.25)+(((fwd*9)+dir):GetNormalized() * math.Rand(50,80) * (amt + 1) * 0.2), fx)
	end
end

local mat = Material("data/wimages/wlogo.png")
http.DownloadMaterial('http://wayzerroleplay.myarena.ru/wimages/wlogo.png', 'wlogo.png', function(img)
	mat = img
end, true)
local armorvape = Material("icon72/alien.png")
local hpvape = Material("icon72/avocado.png")

function vape_do_particle(particle, vel, fx)
	particle:SetColor(255,255,255,255)
	if fx == 3 then particle:SetColor(0,255,0,255) end
	if fx == 5 then particle:SetColor(math.random(60,255),math.random(60,255),math.random(60,255),255) end
	if fx == 4 then particle:SetColor(220,230,255,255) end

	if fx >= 20 then 
		local c = JuicyVapeJuices[fx-19].color
		if c == nil then c = HSVToColor(math.random(0,359),1,1) end
		particle:SetColor(c.r, c.g, c.b, 255)
	end
	local mega = 1
	
	
	particle:SetVelocity( vel * mega * (fx==6 and 2 or 1))
	particle:SetGravity( Vector(0,0,fx == 4 and 15 or 1.5) )
	particle:SetLifeTime(0)

	particle:SetDieTime(math.Rand(80,100)*0.11*mega)
	if fx == 10 then particle:SetColor(200,200,200,255) mega = 0.2 end
	if fx==6 then particle:SetDieTime(math.Rand(80,100)*0.03) end
	if fx == 2 then particle:SetMaterial(mat) mega = 0.2 end
	if fx == 11 then particle:SetMaterial(armorvape) mega = 0.3 end
	if fx == 12 then particle:SetMaterial(hpvape) mega = 0.3 end
	particle:SetStartSize(2*mega)
	if fx==6 then particle:SetStartSize(3) end
	particle:SetEndSize(40*mega*mega)
	if fx==6 then particle:SetEndSize(20) end
	particle:SetStartAlpha(fx == 4 and 20 or 150)
	particle:SetEndAlpha(0)
	particle:SetCollide(true)
	particle:SetBounce(0.25)
	particle:SetRoll(math.Rand(0,360))
	particle:SetRollDelta(0.01*math.Rand(-40,40))
	particle:SetAirResistance(50)
	if fx==6 then particle:SetAirResistance(20) end
end

function vape_red_white_blue_chooser(lerp)
	lerp = 3*lerp

	local v = nil

	local r = Vector(255,0,0)
	local w = Vector(255,255,255)
	local b = Vector(0,0,255)

	if lerp >= 2 then
		v = LerpVector(lerp-2,b,r)
	elseif lerp >= 1 then
		v = LerpVector(lerp-1,w,b)
	else
		v = LerpVector(lerp,r,w)
	end

	--particle:SetColor takes seperate parameters per channel
	return v.x,v.y,v.z,255
end
--addons/module_weed/lua/autorun/client/fonts.lua:
surface.CreateFont( "BeeperText", {
  font = "Fixedsys",
  size = 32
} )

surface.CreateFont( "DealerText", {
  font = "Fixedsys",
  size = 42
} )

surface.CreateFont( "MainWeedFont", {
  font = "Akbar",
  size = 64
} )

surface.CreateFont( "MainWeedFont_med", {
  font = "Akbar",
  size = 48
} )

surface.CreateFont( "MainWeedFont_min", {
  font = "Akbar",
  size = 34
} )

surface.CreateFont( "RobotText_beeper", {
	font = "Fixedsys",
	size = 30,
	weight = 1,
} )
surface.CreateFont( "RobotText_hud", {
	font = "Fixedsys",
	size = 18,
	weight = 1,
} )


function draw.TextRotated( text, x, y, color, font, ang,scl )
	render.PushFilterMag( TEXFILTER.ANISOTROPIC )
	render.PushFilterMin( TEXFILTER.ANISOTROPIC )
	surface.SetFont( font )
	surface.SetTextColor( color )
	surface.SetTextPos( 0, 0 )
	local textWidth, textHeight = surface.GetTextSize( text )
	local rad = -math.rad( ang )
	x = x - ( math.cos( rad ) * textWidth / 2 + math.sin( rad ) * textHeight / 2 )
	y = y + ( math.sin( rad ) * textWidth / 2 + math.cos( rad ) * textHeight / 2 )
	local m = Matrix()
	m:SetAngles( Angle( 0, ang, 0 ) )
  m:SetScale(Vector(scl or 1,scl or 1,scl or 1))
	m:SetTranslation( Vector( x, y, 0 ) )
	cam.PushModelMatrix( m )
		surface.DrawText( text )
	cam.PopModelMatrix()
	render.PopFilterMag()
	render.PopFilterMin()
end

--gamemodes/darkrp/gamemode/cl_init.lua:
hook.Run("DarkRPStartedLoading")

GM.Version = "2.7.0"
GM.Name = "DarkRP"
GM.Author = "By FPtje Falco et al."

--DeriveGamemode("base")
--DEFINE_BASECLASS("gamemode_base")
--GM.Sandbox = BaseClass


local function LoadModules()
    local root = GM.FolderName .. "/gamemode/modules/"
    local _, folders = file.Find(root .. "*", "LUA")

    for _, folder in SortedPairs(folders, true) do
        if DarkRP.disabledDefaults["modules"][folder] then continue end

        for _, File in SortedPairs(file.Find(root .. folder .. "/sh_*.lua", "LUA"), true) do
            if File == "sh_interface.lua" then continue end
            include(root .. folder .. "/" .. File)
        end

        for _, File in SortedPairs(file.Find(root .. folder .. "/cl_*.lua", "LUA"), true) do
            if File == "cl_interface.lua" then continue end
            include(root .. folder .. "/" .. File)
        end
    end
end

GM.Config = {} -- config table
GM.NoLicense = GM.NoLicense or {}

local function loadAll()
    include("config/config.lua")
    
    include("libraries/sh_cami.lua")
    include("libraries/simplerr.lua")
    include("libraries/tablecheck.lua")
    include("libraries/interfaceloader.lua")
    include("libraries/disjointset.lua")

    include("libraries/modificationloader.lua")
    LoadModules()

    DarkRP.DARKRP_LOADING = true
    include("config/jobrelated.lua")
    include("config/addentities.lua")
    include("config/ammotypes.lua")

    local mapCFG = "config/"..game.GetMap()..".lua"
    if file.Exists(GM.FolderName.."/gamemode/"..mapCFG, 'LUA') then
        include(mapCFG)
    end
    DarkRP.DARKRP_LOADING = nil

    DarkRP.finish()

    hook.Call("DarkRPFinishedLoading", GM)
end

if GM.Loaded then
    timer.Create("DarkRP_AutoRefresh", 5, 1, loadAll)
else
    loadAll()
    GM.Loaded = true
end
--gamemodes/darkrp/gamemode/libraries/simplerr.lua:
local CompileFile = CompileFile
local CompileString = CompileString
local debug = debug
local error = error
local file = file
local hook = hook
local include = include
local isfunction = isfunction
local isstring = isstring
local math = math
local os = os
local string = string
local table = table
local tonumber = tonumber
local unpack = unpack
local xpcall = xpcall

-- Template for syntax errors
-- The [ERROR] start of it cannot be removed, because that would make the
-- error mechanism remove all square brackets. Only Garry can make that bullshit up.
local synErrTranslation = [=[[ERROR] Lua is unable to understand file "%s" because its author made a mistake around line number %i.
The best help I can give you is this:

%s

Hints:
%s

------- End of Simplerr error -------
]=] -- The end is a special string by which simplerr errors are internally recognised

-- Template for runtime errors
local runErrTranslation = [=[[ERROR] A runtime error has occurred in "%s" on line %i.
The best help I can give you is this:

%s

Hints:
%s

The responsibility for the error above lies with (the authors of) one (or more) of these files:
%s
------- End of Simplerr error -------
]=]

-- Structure that contains syntax errors and their translations. Catches only the most common errors.
-- Order is important: the structure with the first match is taken.
local synErrs = {
    {
        match = "'=' expected near '(.*)'",
        text = "Right before the '%s', Lua expected to read an '='-sign, but it didn't.",
        format = function(m) return m[1] end,
        hints = {
            "Did you simply forget the '='-sign?",
            "Did you forget a comma?",
            "Is this supposed to be a local variable?"
        }
    },
    {
        match = "'.' expected [(]to close '([{[(])' at line ([0-9-]+)[)] near '(.*)'",
        text = "There is an opening '%s' bracket at line %i, but this bracket is never closed or not closed in time. It was expected to be closed before the '%s' at line %i.",
        format = function(m, l) return m[1], m[2], m[3], l end,
        hints = {
            "Did you forget a comma?",
            "All open brackets ({, (, [) must have a matching closing bracket. Are you sure it's there?",
            "Brackets must be opened and closed in the right order. This will work: ({}), but this won't: ({)}."
        }
    },
    {
        match = "'end' expected [(]to close '(.*)' at line ([0-9-]+)[)] near '(.*)'",
        text = "An '%s' was started on line %i, but it was never ended or not ended in time. It was expected to be ended before the '%s' at line %i",
        format = function(m, l) return m[1], m[2], m[3], l end,
        hints = {
            "For every if/for/do/while/function there must be an 'end' that closes it."
        }
    },
    {
        match = "unfinished string near '(.*)'",
        text = "The string '%s' at line %i is opened, but not closed.",
        format = function(m, l) return m[1], l end,
        hints = {
            "A string is a different word for literal text.",
            "Strings must be in single or double quotation marks (e.g. 'example', \"example\")",
            "A third option for strings is for them to be in double square brackets.",
            "Whatever you use (quotations or square brackets), you must not forget that strings are enclosed within a pair of quotation marks/square brackets."
        }
    },
    {
        match = "unfinished long string near '(.*)'",
        text = "Lua expected to see the end of a multiline string somewhere before the '%s' at line %i.",
        format = function(m, l) return m[1], l end,
        hints = {
            "A string is a different word for literal text.",
            "Multiline strings are strings that span over multiple lines.",
            "Multiline strings must be enclosed by double square brackets.",
            "Whatever you use (quotations or square brackets), you must not forget that strings are enclosed within a pair of quotation marks/square brackets.",
            "If you used brackets, the source of the mistake may be somewhere above the reported line."
        }
    },
    {
        match = "unfinished long comment near '(.*)'",
        text = "Lua expected to see the end of a multiline comment somewhere before the '%s' at line %i.",
        format = function(m, l) return m[1], l end,
        hints = {
            "A comment is text ignored by Lua.",
            "Multiline comments are ones that span multiple lines.",
            "Multiline comments must be enclosed by either /* and */ or double square brackets.",
            "Whatever you use (/**/ or square brackets), you must not forget that once you start a comment, you must end it.",
            "The source of the mistake may be somewhere above the reported line."
        }
    },
    -- Generic error messages
    {
        match = "function arguments expected near '(.*)'",
        text = "A function is being called right before '%s', but its arguments are not given.",
        format = function(m) return m[1] end,
        hints = {
            "Did you write 'something:otherthing'? Try changing it to 'something:otherthing()'"
        }
    },
    {
        match = "unexpected symbol near '(.*)'",
        text = "Right before the '%s', Lua encountered something it could not make sense of.",
        format = function(m) return m[1] end,
        hints = {"Did you forget something here? (Perhaps a closing bracket)", "Is it a typo?"}
    },
    {
        match = "'(.*)' expected near '(.*)'",
        text = "Right before the '%s', Lua expected to read a '%s', but it didn't.",
        format = function(m) return m[2], m[1] end,
        hints = {"Did you forget a keyword?", "Did you forget a comma?"}
    },
    {
        match = "malformed number near '(.*)'",
        text = "Lua attempted to read '%s' as a number, but failed to do so.",
        format = function(m) return m[1] end,
        hints = {
            "Numbers starting with '0x' are hexidecimal.",
            "Lua can get confused when doing '<number>..\"some text\"'. Try inserting a space between the number and the '..'."
        }
    },
}

-- Similar structure for runtime errors. Catches only the most common errors.
-- Order is important: the structure with the first match is taken
local runErrs = {
    {
        match = "table index is nil",
        text = "A table is being indexed by something that does not exist (table index is nil).", -- Requires improvement
        format = wlib.func.blank,
        hints = {
            "The thing between square brackets does not exist (is nil)."
        }
    },
    {
        match = "table index is NaN",
        text = "A table is being indexed by something that is not really a number (table index is NaN).",
        format = wlib.func.blank,
        hints = {
            "Did you divide zero by zero thinking it would be funny?"
        }
    },
    {
        match = "attempt to index global '(.*)' [(]a nil value[)]",
        text = "'%s' is being indexed like it is a table, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You either have 'something.somethingElse', 'something[somethingElse]' or 'something:somethingElse(more)'. The 'something' here does not exist."
        }
    },
    {
        match = "attempt to index global '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being indexed like it is a table, but in reality it is a %s value.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You either have 'something.somethingElse' or 'something:somethingElse(more)'. The 'something' here is not a table."
        }
    },
    {
        match = "attempt to index a nil value",
        text = "Something is being indexed like it is a table, but in reality does not exist (is nil).",
        format = wlib.func.blank,
        hints = {
            "You either have 'something.somethingElse', 'something[somethingElse]' or 'something:somethingElse(more)'. The 'something' here does not exist."
        }
    },
    {
        match = "attempt to index a (.*) value",
        text = "Something is being indexed like it is a table, but in reality it is a %s value.",
        format = function(m) return m[1] end,
        hints = {
            "You either have 'something.somethingElse', 'something[somethingElse]' or 'something:somethingElse(more)'. The 'something' here is not a table."
        }
    },
    {
        match = "attempt to call global '(.*)' [(]a nil value[)]",
        text = "'%s' is being called like it is a function, but in reality does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here does not exist."
        }
    },
    {
        match = "attempt to call a nil value",
        text = "Something is being called like it is a function, but in reality it does not exist (is nil).",
        format = wlib.func.blank,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here does not exist."
        }
    },
    {
        match = "attempt to call global '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being called like it is a function, but in reality it is a %s.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here is not a function."
        }
    },
    {
        match = "attempt to call a (.*) value",
        text = "Something is being called like it is a function, but in reality it is a %s.",
        format = function(m) return m[1] end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here is not a function."
        }
    },
    {
        match = "attempt to call field '(.*)' [(]a nil value[)]",
        text = "'%s' is being called like it is a function, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing either stuff.something(<otherstuff>) or stuff:something(<otherstuff>). The 'something' here does not exist."
        }
    },
    {
        match = "attempt to call field '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being called like it is a function, but in reality it is a %s.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You are doing either stuff.something(<otherstuff>) or stuff:something(<otherstuff>). The 'something' here is not a function."
        }
    },
    {
        match = "attempt to concatenate global '(.*)' [(]a nil value[)]",
        text = "'%s' is being concatenated to something else, but '%s' does not exist (is nil).",
        format = function(m) return m[1], m[1] end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing does not exist."
        }
    },
    {
        match = "attempt to concatenate global '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being concatenated to something else, but %s values cannot be concatenated.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing is neither string nor number."
        }
    },
    {
        match = "attempt to concatenate a nil value",
        text = "Two (or more) things are being concatenated and one of them does not exist (is nil).",
        format = wlib.func.blank,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing does not exist."
        }
    },
    {
        match = "attempt to concatenate a (.*) value",
        text = "Two (or more) things are being concatenated and one of them is neither string nor number, but a %s.",
        format = function(m) return m[1] end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing is neither string nor number."
        }
    },
    {
        match = "stack overflow",
        text = "The stack of function calls has overflowed",
        format = wlib.func.blank,
        hints = {
            "Most likely infinite recursion.",
            "Do you have a function calling itself?"
        }
    },
    {
        match = "attempt to compare two (.*) values",
        text = "A comparison is being made between two %s values. They cannot be compared.",
        format = function(m) return m[1] end,
        hints = {
            "This error usually occurs when two incompatible things are being compared.",
            "'comparison' in this context means one of <, >, <=, >= (smaller than, greater than, etc.)"
        }
    },
    {
        match = "attempt to compare (.*) with (.*)",
        text = "A comparison is being made between a %s and a %s. This is not possible.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "This error usually occurs when two incompatible things are being compared.",
            "'Comparison' in this context means one of <, >, <=, >= (smaller than, greater than, etc.)"
        }
    },
    {
        match = "attempt to perform arithmetic on a (.*) value",
        text = "Arithmetic operations are being performed on a %s. This is not possible.",
        format = function(m) return m[1] end,
        hints = {
            "'Arithmetic' in this context means adding, multiplying, dividing, etc."
        }
    },
    {
        match = "attempt to get length of global '(.*)' [(]a nil value[)]",
        text = "The length of '%s' is requested as if it is a table, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing #something. The 'something' here is does not exist."
        }
    },
    {
        match = "attempt to get length of global '(.*)' [(]a (.*) value[)]",
        text = "The length of '%s' is requested as if it is a table, but in reality it is a %s.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You are doing #something. The 'something' here is not a table."
        }
    },
    {
        match = "attempt to get length of a nil value",
        text = "The length of something is requested as if it is a table, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing #something. The 'something' here is does not exist."
        }
    },
    {
        match = "attempt to get length of a (.*) value",
        text = "The length of something is requested as if it is a table, but in reality it is a %s.",
        format = function(m) return m[1] end,
        hints = {
            "You are doing #something. The 'something' here is not a table."
        }
    },
}

module("simplerr")

-- Get a nicely formatted stack trace. Start is where to start numbering
-- stackMod allows the caller to modify the stack before it is numbered
local function getStack(i, start, stackMod)
    i = i or 1
    start = start or 1
    local stack = {}

    -- Invariant: stack level (i + count) >= 2 and <= last stack item
    for count = 1, math.huge do -- user visible count
        local info = debug.getinfo(i + count, "Sln")
        if not info then break end

        local line = info.currentline or "unknown"
        if line == -1 and info.name then
            table.insert(stack, string.format("function '%s'", info.name))
        else
            table.insert(stack, string.format("%s on line %s", info.short_src, line))
        end
    end

    -- Allow modification of the stack
    if stackMod then stack = stackMod(stack) end

    -- add the numbering
    for count = 1, #stack do
        local stackLevel = start + count - 1
        stack[count] = string.format("\t%i. %s", stackLevel, stack[count])
    end

    return table.concat(stack, "\n")
end

-- Translate a runtime error to simplerr format.
-- Decorate with e.g. wrapError to have it actually throw the error.
function runError(msg, stackNr, hints, path, line, stack)
    stackNr = stackNr or 1
    hints = hints or {"No hints, sorry."}
    hints = "\t- " .. table.concat(hints, "\n\t- ")

    if not path and not line then
        local info = debug.getinfo(stackNr + 1, "Sln") or debug.getinfo(stackNr, "Sln")
        path = info.short_src
        line = info.currentline
    end

    return false, string.format(runErrTranslation, path, line, msg, hints, stack or getStack(stackNr + 1))
end

-- Translate the message of an error
local function translateMsg(msg, path, line, errs)
    local res
    local hints = {"No hints, sorry."}

    for i = 1, #errs do
        local trans = errs[i]
        if not string.find(msg, trans.match) then continue end

        -- translate <eof>
        msg = string.Replace(msg, "<eof>", "end of the file")

        res = string.format(trans.text, trans.format({string.match(msg, trans.match)}, line, path))
        hints = trans.hints

        break
    end

    return res or msg, "\t- " .. table.concat(hints, "\n\t- ")
end

-- Translate an error into a language understandable by non-programmers
local function translateError(path, line, err, translation, errs, stack)
    -- Using .* instead of path because path may be wrong when error is called
    local msg = string.match(err, ".*:[0-9-]+: (.*)")

    local msg, hints = translateMsg(msg, path, line, errs)
    local res = string.format(translation, path, line, msg, hints, stack)
    return res
end


-- Trims the [C] functions at the beginning of the stack
local function trimStart(stack)
    while true do
        if string.StartWith(stack[1], "function ") then
            table.remove(stack, 1)
        else
            break
        end
    end

    return stack
end

-- safeCall uses xpcall, which has the downside that both xpcall and
-- the safeCall function itself end up in the stack trace.
-- This function removes them from the stack trace
local function removeXpcall(stack)
    for i = #stack - 1, 1, -1 do
        if stack[i] == "function 'xpcall'" and string.find(stack[i + 1], "simplerr") then
            table.remove(stack, i)
            table.remove(stack, i) -- also remove the simplerr safeCall call

            return stack
        end
    end

    return stack
end

-- Combines the two above functions
local function stackModAggregate(stack)
    stack = trimStart(stack)
    return removeXpcall(stack)
end

-- Used as the error handler in safeCall
local function errorHandler(err, func)
    -- Investigate the stack. Not using err matching because calls to error can give a different path and line
    local stack = getStack(func and 1 or 2, 1, stackModAggregate) -- add called func to stack

    -- Fetch the path and line number from the top of the stack
    local firstLine = string.sub(stack, 1, string.match(stack, "()\n") - 1)
    local path, line = string.match(firstLine, "\t[0-9-]+%. (.*) on line ([0-9-]+)")
    line = tonumber(line)

    return {err, path, line, stack}
end

-- Call a function and catch immediate runtime errors
function safeCall(f, ...)
    -- Use xpcall so fetching of debug info is in the stack of the error rather than after it is unwound
    local res = {xpcall(f, errorHandler, ...)}

    local succ, errInfo = res[1], res[2]

    if succ then return unpack(res) end

    -- This will only happen if the error is "not enough memory" or "error in error handling".
    -- The former tends to crash the game and the latter will mean it'll probably error in the next line.
    -- But we will try anyway.
    -- Note: stack trace will be less accurate.
    if isstring(errInfo) then errInfo = errorHandler(errInfo, f) end

    -- Skip translation if the error is already a simplerr error
    -- This prevents nested simplerr errors when runError is called by a file loaded by runFile
    local mustTranslate = not string.find(errInfo[1], "------- End of Simplerr error -------")
    return false, mustTranslate and translateError(errInfo[2], errInfo[3], errInfo[1], runErrTranslation, runErrs, errInfo[4]) or errInfo[1]
end

-- Run a file or explain its syntax errors in layman's terms
-- Returns bool succeed, [string error]
-- Do NOT use this on clientside files.
-- Clientside files sent by the server cannot be read using file.Read unless you're the host of a listen server
function runFile(path)
    if not file.Exists(path, "LUA") then error(string.format("Could not run file '%s' (file not found)", path)) end
    local contents = file.Read(path, "LUA")

    -- Files can make a comment containing #NoSimplerr# to disable simplerr (and thus enable autorefresh)
    if string.find(contents, "#NoSimplerr#") then include(path) return true end

    -- Catch syntax errors with CompileString
    local err = CompileString(contents, path, false)

    -- CompileString returns the following string whenever a file is empty: Invalid script - or too short.
    -- It also prints: Not running script <path> - it's too short.
    -- If so, do nothing.
    if err == "Invalid script - or too short." then return true end

    -- No syntax errors, check for immediate runtime errors using CompileFile
    -- Using the function CompileString returned leads to relative path trouble
    if isfunction(err) then return safeCall(CompileFile(path), path) end

    -- Fetch the line number from the error
    local line = string.match(err, ".*:([0-9-]+): .*")
    line = tonumber(line)

    return false, translateError(path, line, err, synErrTranslation, synErrs)
end

-- Error wrapper: decorator for runFile and safeCall that throws an error on failure.
-- Breaks execution. Must be the last decorator.
function wrapError(succ, err, ...)
    if succ then return succ, err, ... end

    error(err)
end

-- Hook wrapper: Calls a hook on error
function wrapHook(succ, err, ...)
    if not succ then hook.Call("onSimplerrError", nil, err) end

    return succ, err, ...
end

-- Logging wrapper: decorator for runFile and safeCall that logs failures.
local log = {}
function wrapLog(succ, err, ...)
    if succ then return succ, err, ... end

    local data = {
        err = err,
        time = os.time()
    }

    table.insert(log, data)

    return succ, err, ...
end

-- Retrieve the log
function getLog() return log end

-- Clear the log
function clearLog() log = {} end

--gamemodes/darkrp/gamemode/libraries/interfaceloader.lua:
module("DarkRP", package.seeall)

MetaName = "DarkRP"

-- Variables that maintain the existing stubs and hooks
local stubs = {}
local hookStubs = {}

-- Contains the functions that the hooks call by default
hooks = {}

-- Delay the calling of methods until the functions are implemented
local delayedCalls = {}

local returnsLayout, isreturns
local parameterLayout, isparameters
local isdeprecated
local checkStub

local hookLayout

local realm -- State variable to manage the realm of the stubs

--[[---------------------------------------------------------------------------
Methods that check whether certain fields are valid
---------------------------------------------------------------------------]]
isreturns = function(tbl)
    if not istable(tbl) then return false end
    for k,v in pairs(tbl) do
        if not checkStub(v, returnsLayout) then return false end
    end
    return true
end

isparameters = function(tbl)
    if not istable(tbl) then return false end
    for k,v in pairs(tbl) do
        if not checkStub(v, parameterLayout) then return false end
    end
    return true
end

isdeprecated = function(val)
    return val == nil or isstring(val)
end

--[[---------------------------------------------------------------------------
The layouts of stubs
---------------------------------------------------------------------------]]
local stubLayout = {
    name = isstring,
    description = isstring,
    deprecated = isdeprecated,
    parameters = isparameters, -- the parameters of a method
    returns = isreturns, -- the return values of a method
    metatable = istable -- DarkRP, Player, Entity, Vector, ...
}

hookLayout = {
    name = isstring,
    description = isstring,
    deprecated = isdeprecated,
    parameters = isreturns, -- doesn't have the 'optional' field
    returns = isreturns,
}

returnsLayout = {
    name = isstring,
    description = isstring,
    type = isstring
}

parameterLayout = {
    name = isstring,
    description = isstring,
    type = isstring,
    optional = isbool
}

--[[---------------------------------------------------------------------------
Check the validity of a stub
---------------------------------------------------------------------------]]
checkStub = function(tbl, stub)
    if not istable(tbl) then return false, "table" end

    for name, check in pairs(stub) do
        if not check(tbl[name]) then
            return false, name
        end
    end

    return true
end

--[[---------------------------------------------------------------------------
When a stub is called, the calling of the method is delayed
---------------------------------------------------------------------------]]
local function notImplemented(name, args, thisFunc)
    if stubs[name] and stubs[name].metatable[name] ~= thisFunc then -- when calling the not implemented function after the function was implemented
        return stubs[name].metatable[name](unpack(args))
    end
    table.insert(delayedCalls, {name = name, args = args})

    return nil -- no return value because the method is not implemented
end

--[[---------------------------------------------------------------------------
Generate a stub
---------------------------------------------------------------------------]]
function stub(tbl)
    local isStub, field = checkStub(tbl, stubLayout)
    if not isStub then
        error("Invalid DarkRP method stub! Field \"" .. field .. "\" is invalid!", 2)
    end

    tbl.realm = tbl.realm or realm
    stubs[tbl.name] = tbl

    local function retNotImpl(...)
        return notImplemented(tbl.name, {...}, retNotImpl)
    end

    return retNotImpl
end

--[[---------------------------------------------------------------------------
Generate a hook stub
---------------------------------------------------------------------------]]
function hookStub(tbl)
    local isStub, field = checkStub(tbl, hookLayout)
    if not isStub then
        error("Invalid DarkRP hook! Field \"" .. field .. "\" is invalid!", 2)
    end

    tbl.realm = tbl.realm or realm
    hookStubs[tbl.name] = tbl
end

--[[---------------------------------------------------------------------------
Retrieve the stubs
---------------------------------------------------------------------------]]
function getStubs()
    return table.Copy(stubs)
end

--[[---------------------------------------------------------------------------
Retrieve the hooks
---------------------------------------------------------------------------]]
function getHooks()
    return table.Copy(hookStubs)
end

--[[---------------------------------------------------------------------------
Call the cached methods
---------------------------------------------------------------------------]]
function finish()
    local calls = table.Copy(delayedCalls) -- Loop through a copy, so the notImplemented function doesn't get called again
    for _, tbl in ipairs(calls) do
        local name = tbl.name

        if not stubs[name] then ErrorNoHalt("Calling non-existing stub \"" .. name .. "\"") continue end

        stubs[name].metatable[name](unpack(tbl.args))
    end

    delayedCalls = {}
end

--[[---------------------------------------------------------------------------
Load the interface files
---------------------------------------------------------------------------]]
local function loadInterfaces()
    local root = GM.FolderName .. "/gamemode/modules"

    local _, folders = file.Find(root .. "/*", "LUA")

    ENTITY = FindMetaTable("Entity")
    PLAYER = FindMetaTable("Player")
    VECTOR = FindMetaTable("Vector")

    for _, folder in SortedPairs(folders, true) do
        local interfacefile = string.format("%s/%s/%s_interface.lua", root, folder, "%s")
        local client = string.format(interfacefile, "cl")
        local shared = string.format(interfacefile, "sh")
        local server = string.format(interfacefile, "sv")

        if file.Exists(shared, "LUA") then
            if SERVER then AddCSLuaFile(shared) end
            realm = "Shared"
            include(shared)
        end

        if SERVER and file.Exists(client, "LUA") then
            AddCSLuaFile(client)
        end

        if SERVER and file.Exists(server, "LUA") then
            realm = "Server"
            include(server)
        end

        if CLIENT and file.Exists(client, "LUA") then
            realm = "Client"
            include(client)
        end
    end

    ENTITY, PLAYER, VECTOR = nil, nil, nil
end
loadInterfaces()

--gamemodes/darkrp/gamemode/modules/jobs/sh_interface.lua:
DarkRP.hookStub{
    name = "OnPlayerChangedTeam",
    description = "When your team (job) is changed.",
    parameters = {
        {
            name = "ply",
            description = "The player that changed team. Clientside this hook is only called for the LocalPlayer.",
            type = "Player"
        },
        {
            name = "before",
            description = "The team before the change.",
            type = "number"
        },
        {
            name = "after",
            description = "The team after the change.",
            type = "number"
        }
    },
    returns = {

    }
}

--gamemodes/darkrp/gamemode/modules/base/cl_interface.lua:
DarkRP.deLocalise = DarkRP.stub{
    name = "deLocalise",
    description = "Makes sure the string will not be localised when drawn or printed.",
    parameters = {
        {
            name = "text",
            description = "The text to delocalise.",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "text",
            description = "The delocalised text.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.textWrap = DarkRP.stub{
    name = "textWrap",
    description = "Wrap a text around when reaching a certain width.",
    parameters = {},
    returns = {
        {
            name = "text",
            description = "The text to wrap.",
            type = "string"
        },
        {
            name = "font",
            description = "The font of the text.",
            type = "string"
        },
        {
            name = "width",
            description = "The maximum width in pixels.",
            type = "number"
        }
    },
    metatable = DarkRP
}

DarkRP.setPreferredJobModel = DarkRP.stub{
    name = "setPreferredJobModel",
    description = "Set the model preferred by the player (if the job allows multiple models).",
    parameters = {
        {
            name = "teamNr",
            description = "The team number of the job.",
            type = "number",
            optional = false
        },
        {
            name = "model",
            description = "The preferred model for the job.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getPreferredJobModel = DarkRP.stub{
    name = "getPreferredJobModel",
    description = "Get the model preferred by the player (if the job allows multiple models).",
    parameters = {
        {
            name = "teamNr",
            description = "The team number of the job.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "model",
            description = "The preferred model for the job.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "teamChanged",
    description = "When your team is changed.",
    deprecated = "Use the OnPlayerChangedTeam hook instead.",
    parameters = {
        {
            name = "before",
            description = "The team before the change.",
            type = "number"
        },
        {
            name = "after",
            description = "The team after the change.",
            type = "number"
        }
    },
    returns = {

    }
}
--gamemodes/darkrp/gamemode/modules/voting/cl_voting.lua:
local QuestionVGUI = {}
local PanelNum = 0
local VoteVGUI = {}
local function BuildVoteFrame(question, voteid, timeleft, choices)
    local _, chatY = chat.GetChatBoxPos()

    if not IsValid(LocalPlayer()) then return end

    if timeleft == 0 then
        timeleft = 100
    end
    local start = CurTime()

    LocalPlayer():EmitSound("Town.d1_town_02_elevbell1", 100, 100)
    local panel = vgui.Create("DFrame")
    panel:SetPos(3 + PanelNum, chatY - 145)
    panel:SetTitle('')
    panel:SetSize(140, 140)
    panel:SetSizable(false)
    panel.btnClose:SetVisible(false)
    panel.btnMaxim:SetVisible(false)
    panel.btnMinim:SetVisible(false)
    panel:SetDraggable(false)
    function panel:Close()
        PanelNum = PanelNum - 140
        VoteVGUI[voteid .. "vote"] = nil

        local num = 0
        for _, v in SortedPairs(VoteVGUI) do
            v:SetPos(num, ScrH() / 2 - 50)
            num = num + 140
        end

        for _, v in SortedPairs(QuestionVGUI) do
            v:SetPos(num, ScrH() / 2 - 50)
            num = num + 300
        end
        self:Remove()
    end

    panel.OldPaint = panel.Paint
    function panel:Paint(w,h)
        self:OldPaint(w,h)

        draw.RoundedBox(2, 0, 0, w * ((timeleft - (CurTime() - start))/timeleft), 8, Color(236,113,71))
        if CurTime() - start > timeleft then
            self:Close()
        end
    end

    panel:SetKeyboardInputEnabled(false)
    panel:SetMouseInputEnabled(true)
    panel:SetVisible(true)

    local label = vgui.Create("DLabel")
    label:SetParent(panel)
    label:SetPos(5, 25)
    label:SetText(DarkRP.textWrap(DarkRP.deLocalise(question), "DermaDefault", 130))
    label:SizeToContents()
    label:SetVisible(true)

    local nextHeight = label:GetTall() > 78 and label:GetTall() - 78 or 0 -- Make panel taller for divider and buttons
    nextHeight = nextHeight + #choices * 25
    panel:SetTall(panel:GetTall() + nextHeight)

    if #choices == 2 and choices[1].id == 'yes' then
        local btnspnl = vgui.Create('DPanel', panel)
        btnspnl:Dock(BOTTOM)
        btnspnl:SetTall(25)
        btnspnl:SetPaintBackground(false)
        btnspnl:InvalidateParent(true)

        for _, v in ipairs(choices) do
            local btn = vgui.Create('DButton', btnspnl)
            btn:Dock(LEFT)
            btn:SetWide(btnspnl:GetWide()/2)
            btn:SetText(v.text)
            btn.DoClick = function()
                RunConsoleCommand('vote', voteid, v.id)
                panel:Close()
            end
        end
    else
        for k, v in ipairs(table.Reverse(choices)) do
            local btn = vgui.Create('DButton', panel)
            btn:Dock(BOTTOM)
            btn:SetTall(25)
            btn:SetText(v.text)
            btn.DoClick = function()
                RunConsoleCommand('vote', voteid, v.id)
                panel:Close()
            end
        end
    end

    PanelNum = PanelNum + 140
    VoteVGUI[voteid .. 'vote'] = panel
    panel:SetSkin(GAMEMODE.Config.DarkRPSkin)
end

net.Receive('DarkRP_vote', function()
    local text = net.ReadString()
    local id = net.ReadUInt(16)
    local time = net.ReadFloat()
    local choices = net.ReadTable()

    BuildVoteFrame(text, id, time, choices)
end)

local function KillVoteVGUI(id)
    if VoteVGUI[id .. 'vote'] and IsValid(VoteVGUI[id .. 'vote']) then
        VoteVGUI[id .. 'vote']:Close()
    end
end
net.Receive('DarkRP_killVote', function()
    local id = net.ReadString()
    KillVoteVGUI(id)
end)

local function BuildQuestionFrame(msg)
    if not IsValid(LocalPlayer()) then return end

    local question = net.ReadString()
    local quesid = net.ReadString()
    local timeleft = net.ReadFloat()
    if timeleft == 0 then
        timeleft = 100
    end
    local start = CurTime()

    LocalPlayer():EmitSound("Town.d1_town_02_elevbell1", 100, 100)

    local panel = vgui.Create("DFrame")
    panel:SetPos(3 + PanelNum, ScrH() / 2 - 50) -- Times 140 because if the question is the second screen, the first screen is always a vote screen.
    panel:SetSize(250, 140)
    panel:SetTitle('')
    panel:SetSizable(false)
    panel.btnClose:SetVisible(false)
    panel.btnMaxim:SetVisible(false)
    panel.btnMinim:SetVisible(false)
    panel:SetKeyboardInputEnabled(false)
    panel:SetMouseInputEnabled(true)
    panel:SetVisible(true)

    function panel:Close()
        PanelNum = PanelNum - 300
        QuestionVGUI[quesid .. 'ques'] = nil
        local num = 0
        for _, v in SortedPairs(VoteVGUI) do
            v:SetPos(num, ScrH() / 2 - 50)
            num = num + 140
        end

        for _, v in SortedPairs(QuestionVGUI) do
            v:SetPos(num, ScrH() / 2 - 50)
            num = num + 300
        end

        self:Remove()
    end

    panel.OldPaint = panel.Paint
    function panel:Paint(w,h)
        self:OldPaint(w,h)

        draw.RoundedBox(2, 0, 0, w * ((timeleft - (CurTime() - start))/timeleft), 8, Color(236,113,71))
        if CurTime() - start > timeleft then
            self:Close()
        end
    end

    local label = vgui.Create("DLabel", panel)
    label:Dock(TOP)
    label:DockMargin(4,4,4,0)
    label:SetText(DarkRP.deLocalise(question))
    label:SetVisible(true)
    label:SetWrap(true)
    label:SetAutoStretchVertical(true)

    local btnspnl = vgui.Create('DPanel', panel)
    btnspnl:Dock(BOTTOM)
    btnspnl:SetTall(25)
    btnspnl:SetPaintBackground(false)
    btnspnl:InvalidateParent(true)

    local yes = vgui.Create('DButton', btnspnl)
    yes:Dock(LEFT)
    yes:SetWide(btnspnl:GetWide()/2)
    yes:SetText('Да')
    yes.DoClick = function()
        RunConsoleCommand('ans', quesid, '1')
        panel:Close()
    end

    local no = vgui.Create('DButton', btnspnl)
    no:Dock(LEFT)
    no:SetWide(btnspnl:GetWide()/2)
    no:SetText('Нет')
    no.DoClick = function()
        RunConsoleCommand('ans', quesid, '2')
        panel:Close()
    end

    PanelNum = PanelNum + 300
    QuestionVGUI[quesid .. "ques"] = panel

    panel:SetSkin(GAMEMODE.Config.DarkRPSkin)
end
net.Receive("DoQuestion", BuildQuestionFrame)

local function KillQuestionVGUI(msg)
    local id = net.ReadString()

    if QuestionVGUI[id .. "ques"] and QuestionVGUI[id .. "ques"]:IsValid() then
        QuestionVGUI[id .. "ques"]:Close()
    end
end
net.Receive("KillQuestionVGUI", KillQuestionVGUI)

local function DoVoteAnswerQuestion(ply, cmd, args)
    if not args[1] then return end

    local vote = 0
    if tonumber(args[1]) == 1 or string.lower(args[1]) == "yes" or string.lower(args[1]) == "true" then vote = 1 end

    for k, v in pairs(VoteVGUI) do
        if IsValid(v) then
            local ID = string.sub(k, 1, -5)
            VoteVGUI[k]:Close()
            RunConsoleCommand("vote", ID, vote)
            return
        end
    end

    for k, v in pairs(QuestionVGUI) do
        if IsValid(v) then
            local ID = string.sub(k, 1, -5)
            QuestionVGUI[k]:Close()
            RunConsoleCommand("ans", ID, vote)
            return
        end
    end
end
concommand.Add("rp_vote", DoVoteAnswerQuestion)
--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/controls/ropematerial.lua:

list.Set( "RopeMaterials", "#ropematerial.rope",		"cable/rope" )
list.Set( "RopeMaterials", "#ropematerial.cable",		"cable/cable2" )
list.Set( "RopeMaterials", "#ropematerial.xbeam",		"cable/xbeam" )
list.Set( "RopeMaterials", "#ropematerial.laser",		"cable/redlaser" )
list.Set( "RopeMaterials", "#ropematerial.electric",	"cable/blue_elec" )
list.Set( "RopeMaterials", "#ropematerial.physbeam",	"cable/physbeam" )
list.Set( "RopeMaterials", "#ropematerial.hydra",		"cable/hydra" )

local PANEL = {}

--[[---------------------------------------------------------
	Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()

	self:SetItemWidth( 0.14 )
	self:SetItemHeight( 0.3 )
	self:SetAutoHeight( true )

	local mats = list.Get( "RopeMaterials" )
	for k, v in pairs( mats ) do

		self:AddMaterial( k, v )

	end

end

function PANEL:Paint( w, h )

	draw.RoundedBox( 4, 0, 0, w, h, Color( 128, 128, 128, 255 ) )

end

vgui.Register( "RopeMaterial", PANEL, "MatSelect" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu.lua:

include( "creationmenu/manifest.lua" )

local PANEL = {}

function PANEL:Init()

	self.CreationTabs = {}

	self:SetFadeTime( 0 )
	self:Populate()

end

function PANEL:GetCreationTab( id )

	return self.CreationTabs[ id ]

end

function PANEL:GetCreationTabs()

	return self.CreationTabs

end

function PANEL:Populate()

	local tabs = spawnmenu.GetCreationTabs()

	for k, v in SortedPairsByMemberValue( tabs, "Order" ) do

		--
		-- Here we create a panel and populate it on the first paint
		-- that way everything is created on the first view instead of
		-- being created on load.
		--
		local pnl = vgui.Create( "Panel" )

		local tab = self:AddSheet( k, pnl, v.Icon, nil, nil, v.Tooltip )
		self.CreationTabs[ k ] = tab

		-- Populate the panel
		-- We have to add the timer to make sure g_Spawnmenu is available
		-- in case some addon needs it ready when populating the creation tab.
		timer.Simple( 0, function()
			local childpnl = v.Function()
			childpnl:SetParent( pnl )
			childpnl:Dock( FILL )
		end )

	end

end

vgui.Register( "CreationMenu", PANEL, "DPropertySheet" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/postprocessicon.lua:

local PANEL = {}

--[[---------------------------------------------------------
	Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()

	self:SetPaintBackground( false )
	self:SetSize( 128, 128 )
	self:SetText( "" )

end

function PANEL:OnDepressionChanged( b )

	if ( IsValid( self.checkbox ) ) then
		self.checkbox:SetVisible( !b )
	end

end

function PANEL:Setup( name, icon, label )

	self.label = label
	self.name = name
	self.icon = icon

	self:SetMaterial( icon )
	self:SetName( label or name )

	self.PP = list.Get( "PostProcess" )[ name ]
	if ( !self.PP ) then return end

	self.DoClick = function()

		if ( self.PP.onclick ) then
			return self.PP.onclick()
		end

		if ( !self.PP.cpanel ) then return end

		if ( !IsValid(self.cp) ) then

			self.cp = vgui.Create( "ControlPanel" )
			self.cp:SetName( name )
			self.cp:FillViaFunction( self.PP.cpanel )

		end

		spawnmenu.ActivateToolPanel( 1, self.cp )

	end

	if ( self.PP.convar ) then

		self.checkbox = self:Add( "DCheckBox" )
		self.checkbox:SetConVar( self.PP.convar )
		self.checkbox:SetSize( 20, 20 )
		self.checkbox:SetPos( self:GetWide() - 20 - 8, 8 )

		self.Enabled = function() return self.checkbox:GetChecked() end

	elseif ( self.ConVars ) then

		self.checkbox = self:Add( "DCheckBox" )
		self.checkbox:SetSize( 20, 20 )
		self.checkbox:SetPos( self:GetWide() - 20 - 8, 8 )

		self.checkbox.OnChange = function( pnl, on )

			for k, v in pairs( self.ConVars ) do

				if ( on ) then
					RunConsoleCommand( k, v.on )
				else
					RunConsoleCommand( k, v.off or "" )
				end

			end

		end

		self.checkbox.Think = function( pnl, on )

			local good = true

			for k, v in pairs( self.ConVars ) do

				if ( GetConVarString( k ) != v.on ) then
					good = false
				end

			end

			pnl:SetChecked( good )

		end

		self.Enabled = function() return checkbox:GetChecked() end

	end

end

function PANEL:DoRightClick()

	local pCanvas = self:GetSelectionCanvas()
	if ( IsValid( pCanvas ) && pCanvas:NumSelectedChildren() > 0 && self:IsSelected() ) then
		return hook.Run( "SpawnlistOpenGenericMenu", pCanvas )
	end

	self:OpenMenu()

end

function PANEL:DoClick()
end

function PANEL:OpenMenu()

	-- Do not allow removal from read only panels
	if ( IsValid( self:GetParent() ) && self:GetParent().GetReadOnly && self:GetParent():GetReadOnly() ) then return end

	local menu = DermaMenu()
		menu:AddOption( "#spawnmenu.menu.delete", function()
			self:Remove()
			hook.Run( "SpawnlistContentChanged" )
		end ):SetIcon( "icon16/bin_closed.png" )
	menu:Open()

end

function PANEL:Enabled()
	return false
end

function PANEL:ToTable( bigtable )

	local tab = {}

	tab.type	= "postprocess"
	tab.name	= self.name
	tab.label	= self.label
	tab.icon	= self.icon
	tab.convars	= self.ConVars

	table.insert( bigtable, tab )

end

function PANEL:Copy()

	local copy = vgui.Create( "PostProcessIcon", self:GetParent() )
	copy:CopyBounds( self )
	copy.ConVars = self.ConVars
	copy:Setup( self.name, self.icon, self.label )

	return copy

end

vgui.Register( "PostProcessIcon", PANEL, "ContentIcon" )

spawnmenu.AddContentType( "postprocess", function( container, obj )

	if ( !obj.name ) then return end
	if ( !obj.icon ) then return end

	local icon = vgui.Create( "PostProcessIcon", container )

	if ( obj.convars ) then
		icon.ConVars = obj.convars
	end

	icon:Setup( obj.name, obj.icon, obj.label )

	container:Add( icon )

end )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/weapons.lua:

hook.Add( "PopulateWeapons", "AddWeaponContent", function( pnlContent, tree, node )

	-- Loop through the weapons and add them to the menu
	local Weapons = list.Get( "Weapon" )
	local Categorised = {}

	-- Build into categories
	for k, weapon in pairs( Weapons ) do

		if ( !weapon.Spawnable ) then continue end

		local Category = weapon.Category or "Other2"
		if ( !isstring( Category ) ) then Category = tostring( Category ) end

		Categorised[ Category ] = Categorised[ Category ] or {}
		table.insert( Categorised[ Category ], weapon )

	end

	Weapons = nil

	local fav_list = wlib.vars.get("spawnmenu_favorite_weapons", {})
	local fav_keys = {}
	for _, v in ipairs(fav_list) do
		fav_keys[v.class] = true
	end

	local favorite = tree:AddNode("Избранное", "icon16/star.png")

	favorite.DoPopulate = function( self )
		local fav_list = wlib.vars.get("spawnmenu_favorite_weapons", {})
		
		if not self.PropPanel then
			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			self.PropPanel.IconList:SetReadOnly(false)
			self.PropPanel.IconList.OnModified = function(s)
				fav_list = wlib.array.map(s:GetChildren(), function(icon, k)
					return {
						class = icon.class,
						order = k,
					}
				end)
				wlib.vars.set("spawnmenu_favorite_weapons", fav_list)
			end
		end

		self.PropPanel.IconList:Clear()
		for _, v in SortedPairsByMemberValue(fav_list, "order") do
			local ent = weapons.GetStored(v.class)
			if not ent then continue end

			local icon = spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", self.PropPanel, {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= ent.IconOverride or "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			})
			icon.class = ent.ClassName
			
			icon.favorite = vgui.Create('DImageButton', icon)
			icon.favorite:SetImage('icon16/star.png')
			icon.favorite:SetSize(16, 16)
			icon.favorite:SetPos(icon:GetWide()-9-16, 9)
			icon.favorite.DoClick = function(s)
				fav_keys[icon.class] = nil

				local _, index = wlib.array.find(fav_list, function(i) return i.class == icon.class end)
				if index then table.remove(fav_list, index) end
				wlib.vars.set("spawnmenu_favorite_weapons", fav_list)

				icon:Remove()
			end
		end

	end

	favorite.DoClick = function( self )
		self:DoPopulate()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	-- Loop through each category
	for CategoryName, v in SortedPairs( Categorised ) do

		-- Add a node to the tree
		local node = tree:AddNode( CategoryName, "icon16/gun.png" )

		-- When we click on the node - populate it using this function
		node.DoPopulate = function( self )

			if not self.PropPanel then
				-- Create the container panel
				self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
				self.PropPanel:SetVisible( false )
				self.PropPanel:SetTriggerSpawnlistChange( false )

				for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
					local class = ent.ClassName
					local icon = spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", self.PropPanel, {
						nicename	= ent.PrintName or class,
						spawnname	= class,
						material	= ent.IconOverride or "entities/" .. class .. ".png",
						admin		= ent.AdminOnly
					} )
					icon.class = class

					icon.favorite = vgui.Create('DImageButton', icon)
					icon.favorite:SetImage('icon16/star.png')
					icon.favorite:SetSize(16, 16)
					icon.favorite:SetPos(icon:GetWide()-9-16, 9)
					icon.favorite.DoClick = function(s)
						if fav_keys[class] then
							fav_keys[class] = nil

							local _, index = wlib.array.find(fav_list, function(i) return i.class == class end)
							if index then table.remove(fav_list, index) end
							wlib.vars.set("spawnmenu_favorite_weapons", fav_list)

							s:SetColor(Color(150, 150, 150))
						else
							fav_keys[class] = true

							table.insert(fav_list, {
								class = class,
								order = #fav_list,
							})
							wlib.vars.set("spawnmenu_favorite_weapons", fav_list)

							s:SetColor(color_white)
						end
					end
				end
			end

			for _, icon in ipairs(self.PropPanel.IconList:GetChildren()) do
				if fav_keys[icon.class] then
					icon.favorite:SetColor(color_white)
				else
					icon.favorite:SetColor(Color(150, 150, 150))
				end
			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function( self )

			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )

		end

	end

	-- Select the first node
	local FirstNode = tree:Root():GetChildNode( 0 )
	if ( IsValid( FirstNode ) ) then
		FirstNode:InternalDoClick()
	end

end )

spawnmenu.AddCreationTab( "#spawnmenu.category.weapons", function()

	local ctrl = vgui.Create( "SpawnmenuContentPanel" )
	ctrl:EnableSearch( "weapons", "PopulateWeapons" )
	ctrl:CallPopulateHook( "PopulateWeapons" )
	return ctrl

end, "icon16/gun.png", 10 )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/dupes.lua:

local HTML				= nil
local DupeInClipboard	= false

spawnmenu.AddCreationTab( "#spawnmenu.category.dupes", function()

	HTML = vgui.Create( "DHTML" )
	JS_Language( HTML )
	JS_Workshop( HTML )

	ws_dupe = WorkshopFileBase( "dupe", { "dupe" } )
	ws_dupe.HTML = HTML

	function ws_dupe:FetchLocal( offset, perpage )

		local f = file.Find( "dupes/*.dupe", "MOD", "datedesc" )

		local saves = {}

		for k, v in pairs( f ) do

			if ( k <= offset ) then continue end
			if ( k > offset + perpage ) then break end

			local entry = {
				file	= "dupes/" .. v,
				name	= v:StripExtension(),
				preview	= "dupes/" .. v:StripExtension() .. ".jpg",
				description	= "Local duplication stored on your computer. Local content can be deleted in the main menu."
			}

			table.insert( saves, entry )

		end

		local results = {
			totalresults	= #f,
			results			= saves
		}

		local json = util.TableToJSON( results, false )
		HTML:Call( "dupe.ReceiveLocal( " .. json .. " )" )

	end

	function ws_dupe:Arm( filename )

		RunConsoleCommand( "dupe_arm", filename )

	end

	function ws_dupe:DownloadAndArm( id )

		-- Server doesn't allow us to arm dupes, don't even try to download anything
		local res = hook.Run( "CanArmDupe", LocalPlayer() )
		if ( res == false ) then LocalPlayer():ChatPrint( "Refusing to download Workshop dupe, server has blocked usage of the Duplicator tool!" ) return end

		MsgN( "Downloading Dupe..." )
		steamworks.DownloadUGC( id, function( name )

			MsgN( "Finished - arming!" )
			ws_dupe:Arm( name )

		end )

	end

	function ws_dupe:Publish( filename, imagename )

		RunConsoleCommand( "dupe_publish", filename, imagename )

	end

	HTML:OpenURL( "asset://garrysmod/html/dupes.html" )
	HTML:Call( "SetDupeSaveState( " .. tostring( DupeInClipboard ) .. " );" )

	return HTML

end, "icon16/control_repeat_blue.png", 200 )

hook.Add( "DupeSaveAvailable", "UpdateDupeSpawnmenuAvailable", function()

	DupeInClipboard = true

	if ( !IsValid( HTML ) ) then return end

	HTML:Call( "SetDupeSaveState( true );" )

end )

hook.Add( "DupeSaveUnavailable", "UpdateDupeSpawnmenuUnavailable", function()

	DupeInClipboard = false

	if ( !IsValid( HTML ) ) then return end

	HTML:Call( "SetDupeSaveState( false );" )

end )

hook.Add( "DupeSaved", "DuplicationSavedSpawnMenu", function()

	if ( !IsValid( HTML ) ) then return end

	HTML:Call( "ShowLocalDupes();" )

end )

concommand.Add( "dupe_show", function()

	g_SpawnMenu:OpenCreationMenuTab( "#spawnmenu.category.dupes" )

	timer.Simple( 1.0, function() if ( !IsValid( HTML ) ) then return end HTML:Call( "ShowLocalDupes();" ) end )

end, nil, "", { FCVAR_DONTRECORD } )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/addonprops.lua:

local function AddRecursive( pnl, folder, path, wildcard )

	local files, folders = file.Find( folder .. "*", path )
	if ( !files ) then MsgN( "Warning! Not opening '" .. folder .. "' because we cannot search in it!"  ) return false end

	local added = false

	for k, v in pairs( files ) do

		if ( !string.EndsWith( v, ".mdl" ) ) then continue end

		local cp = spawnmenu.GetContentType( "model" )
		if ( cp ) then
			cp( pnl, { model = folder .. v } )
			added = true
		end

	end

	for k, v in pairs( folders ) do

		local added_rec = AddRecursive( pnl, folder .. v .. "/", path, wildcard )
		added = added or added_rec

	end

	return added

end

local function AddonsRightClick( self )

	if ( !IsValid( self ) || !self.wsid || self.wsid == "0" ) then return end

	local menu = DermaMenu()
	menu:AddOption( "#spawnmenu.openaddononworkshop", function()
		steamworks.ViewFile( self.wsid )
	end ):SetIcon( "icon16/link_go.png" )

	menu:Open()

end

local function RefreshAddons( MyNode )

	local ViewPanel = MyNode.ViewPanel

	for _, addon in SortedPairsByMemberValue( engine.GetAddons(), "title" ) do

		if ( !addon.downloaded || !addon.mounted ) then continue end
		if ( addon.models <= 0 ) then continue end

		local models = MyNode:AddNode( addon.title .. " (" .. addon.models .. ")", "icon16/bricks.png" )
		models.DoClick = function()

			ViewPanel:Clear( true )

			local anyAdded = AddRecursive( ViewPanel, "models/", addon.title, "*.mdl" )
			if ( !anyAdded ) then
				local cp = spawnmenu.GetContentType( "header" )
				if ( cp ) then cp( ViewPanel, { text = "#spawnmenu.failedtofindmodels" } ) end

				-- For debugging
				local cp = spawnmenu.GetContentType( "header" )
				if ( cp ) then cp( ViewPanel, { text = tostring( addon.title ) .. " (ID: " .. tostring( addon.wsid ) .. ")" } ) end
			end

			MyNode.pnlContent:SwitchPanel( ViewPanel )

		end
		models.DoRightClick = AddonsRightClick
		models.wsid = addon.wsid

	end

end

local myAddonsNode
hook.Add( "PopulateContent", "AddonProps", function( pnlContent, tree, node )

	local myViewPanel = vgui.Create( "ContentContainer", pnlContent )
	myViewPanel:SetVisible( false )
	myViewPanel.IconList:SetReadOnly( true )

	myAddonsNode = node:AddNode( "#spawnmenu.category.addons", "icon16/folder_database.png" )
	myAddonsNode.ViewPanel = myViewPanel
	myAddonsNode.pnlContent = pnlContent

	RefreshAddons( myAddonsNode )

end )

hook.Add( "GameContentChanged", "RefreshSpawnmenuAddons", function()

	if ( !IsValid( myAddonsNode ) ) then return end

	-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
	myAddonsNode:Clear()
	myAddonsNode.ViewPanel:Clear( true )

	RefreshAddons( myAddonsNode )

end )

--gamemodes/darkrp/gamemode/modules/sandbox/cl_notify.lua:
function GM:AddNotify(...)
	notification.AddLegacy(...)
end
--gamemodes/darkrp/gamemode/modules/police/sh_modules.lua:
wlib.include.module(GM.FolderName..'/gamemode/modules/police/license')
--gamemodes/darkrp/gamemode/modules/money/sh_commands.lua:
DarkRP.declareChatCommand{
    command = "give",
    description = "Give money to the player you're looking at.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "dropmoney",
    description = "Drop money on the floor.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "moneydrop",
    description = "Drop money on the floor.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "pay",
    description = "Pay player",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "cheque",
    description = "Write a cheque for a specific person.",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "check",
    description = "Write a cheque for a specific person.",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "setmoney",
    description = "Set a player's wallet value.",
    delay = 0.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "addmoney",
    description = "Add money to a player's wallet.",
    delay = 0.5,
    tableArgs = true
}
--gamemodes/darkrp/gamemode/modules/mayor/sh_laws.lua:
nw.Register('Laws')
    :Read(function()
        local a = {}
        for i=1, net.ReadUInt(8) do
            a[#a+1] = net.ReadString()
        end
        return a
    end)
    :Write(function(d)
        net.WriteUInt(#d, 8)
        for _, law in ipairs(d) do
            net.WriteString(law)
        end
    end)
    :SetHook('LawsChanged')
    :SetGlobal()

function DarkRP.getLaws()
    return nw.GetGlobal('Laws')
end

local plyMeta = FindMetaTable("Player")
DarkRP.declareChatCommand{
    command = "addlaw",
    description = "Add a law to the laws board.",
    delay = 1.5,
    condition = plyMeta.isMayor,
}

DarkRP.declareChatCommand{
    command = "removelaw",
    description = "Remove a law from the laws board.",
    delay = 1.5,
    condition = plyMeta.isMayor,
}

DarkRP.declareChatCommand{
    command = "resetlaws",
    description = "Reset all laws.",
    delay = 1.5,
}

DarkRP.declareChatCommand{
    command = "editlaw",
    description = "Edit law.",
    delay = 1.5,
    condition = plyMeta.isMayor,
}
--gamemodes/darkrp/gamemode/modules/language/sh_english.lua:
--[[-----------------------------------------------------------------------
English (example) language file
---------------------------------------------------------------------------

This is the english language file. The things on the left side of the equals sign are the things you should leave alone
The parts between the quotes are the parts you should translate. You can also copy this file and create a new language.

= Warning =
Sometimes when DarkRP is updated, new phrases are added.
If you don't translate these phrases to your language, it will use the English sentence.
To fix this, join your server, open your console and enter darkp_getphrases yourlanguage
For English the command would be:
    darkrp_getphrases "en"
because "en" is the language code for English.

You can copy the missing phrases to this file and translate them.

= Note =
Make sure the language code is right at the bottom of this file

= Using a language =
Make sure the convar gmod_language is set to your language code. You can do that in a server CFG file.
---------------------------------------------------------------------------]]
local my_language = {
    -- Admin things
    need_admin = "Вы должны иметь привилегии администратора, чтобы %s",
    need_sadmin = "Вы должны иметь привилегии СА, чтобы %s",
    no_privilege = "У вас недостаточно прав для совершения этого действия",
    no_jail_pos = "Тюрьмы нет",
    invalid_x = "Некорретный %s! %s",

    -- F1 menu
    f1ChatCommandTitle = "Комманды чата",
    f1Search = "Поиск...",

    -- Money things:
    price = "Цена: %s%d",
    priceTag = "Стоимость: %s",
    reset_money = "%s сбросил деньги всех игроков!",
    has_given = "%s дал вам %s",
    you_gave = "Вы выдали %s %s",
    npc_killpay = "%s за убийство НПС!",
    profit = "выручка",
    loss = "потеряно",

    -- backwards compatibility
    deducted_x = "Потрачено %s%d",
    need_x = "Нужно %s%d",

    deducted_money = "Потрачено %s",
    need_money = "Нужно %s",

    payday_message = "Зарплата! Получено %s!",
    payday_unemployed = "Вы не получили зарплату, так как у вас ее нет!",
    payday_missed = "Зарплата пропущена! (Вы арестованы)",

    property_tax = "Налог за имущество! %s",
    property_tax_cant_afford = "Вы не способны заплатить налог. Ваше имущество конфисковано!",
    taxday = "День выплаты налогов! %s%% вашего дохода было забрано!",

    found_cheque = "Вы нашли %s%s в чекке, выписанном вам от %s.",
    cheque_details = "Этот чек выписан для %s.",
    cheque_torn = "Вы разорвали чек.",
    cheque_pay = "Заплачено: %s",
    signed = "Подпись: %s",

    found_cash = "Вы нашли %s%d!", -- backwards compatibility
    found_money = "Вы нашли %s!",

    owner_poor = "Владелец %s слишком занят для обработки покупки!",

    -- Police
    Wanted_text = "РАЗЫСКИВАЕТСЯ!",
    wanted = "Разыскивается полицией!\nПричина: %s",
    youre_arrested = "Вы были арестованы на %d секунд!",
    youre_arrested_by = "%s арестовал вас",
    youre_unarrested_by = "%s освободил вас.",
    hes_arrested = "%s был арестован на %d секунд!",
    hes_unarrested = "%s отсидел срок!",
    warrant_ordered = "%s выдал ордер на обыск для %s. Причина: %s",
    warrant_request = "%s запросил ордер на обыск для %s\nПричина: %s",
    warrant_request2 = "Запрос на выдачу ордера был отправлен мэру %s!",
    warrant_approved = "Ордер на обыск подписан %s!\nПричина: %s\nЗаказчик: %s",
    warrant_approved2 = "Теперь вы можете искать его дом.",
    warrant_denied = "Мэр %s отклонил ордер на обыск.",
    warrant_expired = "Ордер на обыск для %s истек!",
    warrant_required = "У вас нет ордера для открытия этой двери.",
    warrant_required_unfreeze = "Вы должны иметь ордер, чтобы разбить этот проп.",
    warrant_required_unweld = "Вы должны иметь ордер, чтобы уничтожить сварку на этом пропе.",
    wanted_by_police = "%s разыскивается полицией!\nПричина: %s\nЗапрошено: %s",
    wanted_by_police_print = "%s has made %s wanted, причина: %s",
    wanted_expired = "%s больше не разыскивается.",
    wanted_revoked = "%s больше не разыскивается.\nОтменено: %s",
    cant_arrest_other_cp = "Вы не можете арестовать других ГО!",
    must_be_wanted_for_arrest = "Игрок должен разыскиваться, чтобы арестовать его.",
    cant_arrest_fadmin_jailed = "Вы не можете арестовать игрока, который был арестован админом.",
    cant_arrest_no_jail_pos = "Вы не можете арестовать людей, пока тюрьма не будет определена!",
    cant_arrest_spawning_players = "Вы не можете арестовать тех, кто спавнится.",

    suspect_doesnt_exist = "Подозреваемого не существует. Лол.",
    actor_doesnt_exist = "Actor не существует.",
    get_a_warrant = "получить ордер",
    make_someone_wanted = "подать в розыск",
    remove_wanted_status = "убрать розыск",
    already_a_warrant = "Ордер на обыск этого подозреваемого уже существует.",
    already_wanted = "Подозреваемый уже в розыске",
    not_wanted = "Подозреваемоый не в розыске.",
    need_to_be_cp = "Вы должны быть полицейским.",
    suspect_must_be_alive_to_do_x = "Подозреваемый должен быть жив, чтобы %s.",
    suspect_already_arrested = "Подозреваемый уже арестован.",

    -- Players
    health = "Здоровье: %s",
    job = "Работа: %s",
    salary = "Зарплата: %s%s",
    wallet = "Наличка: %s%s",
    weapon = "Оружие: %s",
    kills = "Убийств: %s",
    deaths = "Смертей: %s",
    rpname_changed = "%s сменил имя на: %s",
    disconnected_player = "Отключившийся игрок",

    -- Teams
    need_to_be_before = "Вы сначала должны быть %s чтобы стать %s",
    need_to_make_vote = "Вы должны создать голосование ,чтобы стать %s!",
    team_limit_reached = "Сейчас нельзя стать %s. Достигнут лимит",
    wants_to_be = "%s\nхочет стать\n%s",
    has_not_been_made_team = "%s не стал %s!",
    job_has_become = "%s стал %s!",

    -- Disasters
    meteor_approaching = "ВНИМАНИЕ: Метеоритный дождь приближается!",
    meteor_passing = "Идет метеоритный дождь. Штожмда",
    meteor_enabled = "Метеоритный дождь включен.",
    meteor_disabled = "Метеоритный дождь отключен.",
    earthquake_report = "Землетрясение сообщило величины %sMw",
    earthtremor_report = "Землетрясение сообщило величины %sMw",

    -- Keys, vehicles and doors
    keys_allowed_to_coown = "Вам разрешено совладель этим\n(Нажмите R с ключами в руках или F2)\n",
    keys_other_allowed = "Разрешено владеть:",
    keys_allow_ownership = "(Нажмите R с ключем в руках или F2, чтобы стать совладельцем)",
    keys_disallow_ownership = "(Нажмите R с ключем в руках или F2, чтобы отменить совладение)",
    keys_owned_by = "Принадлежит:",
    keys_unowned = "Не приобретено\n(Нажмите R с ключами или F2 для покупки)",
    keys_everyone = "(Нажмите R с ключами или F2 чтобы разрешить всем)",
    door_unown_arrested = "Вы не можете купить это, пока арестованы!",
    door_unownable = "Эта дверь не может быть приобретена или продана!",
    door_sold = "Вы продали хату за %s",
    door_already_owned = "Это уже чья-то собственность",
    door_cannot_afford = "Вы не можете позволить себе эту дверь!",
    door_hobo_unable = "Вы не можете купит дверь, так как вы бомжара!",
    vehicle_cannot_afford = "Вы не можете позволить себе эту машину!",
    door_bought = "Вы купили эту дверь за %s%s",
    vehicle_bought = "Вы купили эту машину за %s%s",
    door_need_to_own = "Вы должны быть владельцем двери, чтобы %s",
    door_rem_owners_unownable = "Вы не можете удалить владельца, когда дверь его не имеет!",
    door_add_owners_unownable = "Вы не можете добавить к этой двери владельца!",
    rp_addowner_already_owns_door = "%s уже купил (или совладелец) эту дверь!",
    add_owner = "Добавить владельца",
    remove_owner = "Удалить владельца",
    coown_x = "Со-владеть %s",
    allow_ownership = "Разрешить покупку",
    disallow_ownership = "Запретить покупку",
    edit_door_group = "Изменить группу",
    door_groups = "Группы дверей",
    door_group_doesnt_exist = "Группы не существует!",
    door_group_set = "Группа успешно установлена",
    sold_x_doors_for_y = "Вы продали %d двер. за %s%d!", -- backwards compatibility
    sold_x_doors = "Вы продали %d двер. за %s!",

    -- Entities
    drugs = "Наркота",
    drug_lab = "Нарколаба",
    gun_lab = "Оружейка",
    gun = "ствол",
    microwave = "Микроволновка",
    food = "Еда",
    money_printer = "Маник",

    sign_this_letter = "Подписать письмо",
    signed_yours = "Ваш",

    money_printer_exploded = "Ваш маник взорвался!",
    money_printer_overheating = "Ваш маник перегрелся!",

    contents = "Содержимое: ",
    amount = "Количество: ",

    picking_lock = "Взлом..",

    cannot_pocket_x = "Вы не можете положить это в карман!",
    object_too_heavy = "Эта вещь слишком тяжелая.",
    pocket_full = "Ваш карман полон!",
    pocket_no_items = "В вашем кармане пусто.",
    drop_item = "Выбросить",

    bonus_destroying_entity = "уничтожение этого нелегала.",

    switched_burst = "Переключено на burst-fire режим.",
    switched_fully_auto = "Переключено на автоматический режим.",
    switched_semi_auto = "Переключено в полу-автомат. режим.",

    keypad_checker_shoot_keypad = "Кликните на кейпад, чтобы узнать, что он контролирует.",
    keypad_checker_shoot_entity = "Нажмите на предмет, чтобы увидить управляющие кейпады",
    keypad_checker_click_to_clear = "ПКМ для очистки.",
    keypad_checker_entering_right_pass = "Ввод правильного пароля",
    keypad_checker_entering_wrong_pass = "Ввод ошибочного пароля",
    keypad_checker_after_right_pass = "после ввода верного пароля",
    keypad_checker_after_wrong_pass = "после ввода неверного пароля",
    keypad_checker_right_pass_entered = "Правильный пароль введен",
    keypad_checker_wrong_pass_entered = "Ошибочный пароль введен",
    keypad_checker_controls_x_entities = "Этот кейпад управляет %d предметами",
    keypad_checker_controlled_by_x_keypads = "Этот предмет управляется %d кейпадами",
    keypad_on = "ВКЛ",
    keypad_off = "ВЫКЛ",
    seconds = "секунд",

    persons_weapons = "Нелегальное оружие гражданина %s:",
    returned_persons_weapons = "Вернул %s конфискованное оружие",
    no_weapons_confiscated = "%s не имеет изъятого оружия!",
    no_illegal_weapons = "%s не имеет незаконного оружия.",
    confiscated_these_weapons = "Оружие конфисковано:",
    checking_weapons = "Проверка на оружие",

    shipment_antispam_wait = "Пожалуйста, подождите перед спавном нового ящика.",

    -- Talking
    hear_noone = "Вас никто не слышит %s!",
    hear_everyone = "Вас все слышат!",
    hear_certain_persons = "Вас слышит: %s: ",

    whisper = "шепот",
    yell = "крик",
    advert = "[Объявление]",
    broadcast = "[Вещание!]",
    radio = "радио",
    request = "(ВЫЗОВ!)",
    group = "(группа)",
    demote = "(ПОНИЖЕНИЕ)",
    ooc = "OOC",
    radio_x = "Радио %d",

    talk = "в локальном чате",
    speak = "",

    speak_in_ooc = "в OOC",
    perform_your_action = "выполните свое действие",
    talk_to_your_group = "сказать в группу",

    channel_set_to_x = "Канал установлен на %s!",

    -- Notifies
    disabled = "%s отключен! %s",
    gm_spawnvehicle = "Спавн машины",
    gm_spawnsent = "Спавн скрипт. энтити (SENTs)",
    gm_spawnnpc = "Спавн НПС",
    see_settings = "Посмотрите настройки DarkRp.",
    limit = "Вы превысили лимит в %s штук!",
    have_to_wait = "Вы должны подождать еще %d сек. перед использованием %s!",
    must_be_looking_at = "Вы должны смотреть на %s!",
    incorrect_job = "У вас не та профессия, чтобы %s",
    unavailable = "Этот %s недоступен",
    unable = "Вы не можете %s. %s",
    cant_afford = "Вы не можете себе позволить %s",
    created_x = "%s создал %s",
    cleaned_up = "Ваш %s был очищен.",
    you_bought_x = "Вы купили %s за %s%d.", -- backwards compatibility
    you_bought = "Вы купили %s за %s.",
    you_received_x = "Вы получили %s для %s.",
    you_received = "Вы получили %s для %s.",

    created_first_jailpos = "Вы создали первую тюремную позицию!",
    added_jailpos = "Вы добавили экстра позицию тюрьмы!",
    reset_add_jailpos = "Вы удалили все тюремные позиции.",
    created_spawnpos = "%s's спавн позиция создана.",
    updated_spawnpos = "%s's спавн позиция обновлена.",
    do_not_own_ent = "Это не вы владелец этого предмета!",
    cannot_drop_weapon = "Эту пушку нельзя бросить!",
    job_switch = "Работа успешно изменена!",
    job_switch_question = "Сменить работу с %s?",
    job_switch_requested = "Запрошена смены профессии",

    cooks_only = "Только повары",

    -- Misc
    unknown = "Неизвестно",
    arguments = "аргументы",
    no_one = "нечто", -- это отображается в письме после "Подпись". Нечто звучит лучше, чем "никто"
    door = "Дверь",
    vehicle = "транспорт",
    door_or_vehicle = "дверь/тачка",
    driver = "Водитель: %s",
    name = "Имя: %s",
    locked = "Закрыто.",
    unlocked = "Открыто.",
    player_doesnt_exist = "Игрок не существует.",
    job_doesnt_exist = "Работа не существует!",
    must_be_alive_to_do_x = "Вы должны быть живы, чтобы %s.",
    banned_or_demoted = "Забанен/уволен",
    wait_with_that = "Не спешите с этим",
    could_not_find = "%s не найден...",
    f3tovote = "Нажмите F3 для управление курсором",
    listen_up = "Внимание:", -- In rp_tell or rp_tellall
    nlr = "NLR: Нельзя возвращаться на место смерти 5 минут.",
    reset_settings = "Вы сбросили все настройки!",
    must_be_x = "Вы должны быть %s чтобы %s.",
    agenda_updated = "Оповещания были обновлены",
    job_set = "%s занял профессию: '%s'",
    demoted = "%s уволен",
    demoted_not = "%s не был уволен",
    demote_vote_started = "%s начал голосование на понижение %s",
    demote_vote_text = "Причина понижения:\n%s", -- '%s' is the reason here
    cant_demote_self = "Вы не можете понизить самого себя.",
    i_want_to_demote_you = "Я хочу уволить вас. Причина: %s",
    tried_to_avoid_demotion = "Вы попытались избежать понижения. У вас не вышло и вы были понижены.", -- при попытке смены тимы
    lockdown_started = "Мэр огласил ком. час. Идите домой!",
    lockdown_ended = "Ком. час закончен",
    gunlicense_requested = "%s запросил у %s лицензию на оружие",
    gunlicense_granted = "%s выдал %s лицензию на оружие",
    gunlicense_denied = "%s отказался выдавать лицензию %s",
    gunlicense_question_text = "Выдать %s лицензию на оружие?",
    gunlicense_remove_vote_text = "%s начал голосование на лишение %s лицензии",
    gunlicense_remove_vote_text2 = "Отмена лицензии. Причина:\n%s", -- Where %s is the reason
    gunlicense_removed = "%s's лицензия была отклонена!",
    gunlicense_not_removed = "%s's не лишился лицензии!",
    vote_specify_reason = "Вы должны указать корректную причину!",
    vote_started = "Голосование создано",
    vote_alone = "Вы не можете выиграть в голосовании, так как вы один на сервере.",
    you_cannot_vote = "Вы не можете голосовать!",
    x_cancelled_vote = "%s отменил последний голос.",
    cant_cancel_vote = "Не удалось отменить последнее голосование, так как оно не было создано!",
    jail_punishment = "Наказание за лив! Арестован на: %d секунд.",
    admin_only = "Это только для админов!", -- When doing /addjailpos
    chief_or = "Шеф или ",-- When doing /addjailpos
    frozen = "Заморожен.",

    dead_in_jail = "Вы умерли до того, как вышли с тюрьмы!",
    died_in_jail = "%s сдох в тюрьме!",

    credits_for = "АВТОРЫ %s\n",
    credits_see_console = "Авторы DarkRP показаны в консоле.",

    rp_getvehicles = "Свободные для кастомизации машины:",

    data_not_loaded_one = "Ваши данные не были загружены. Ждите.",
    data_not_loaded_two = "Если не получаеся, то попробуйте переподключиться или напишите одному из СуперАдминов.",

    cant_spawn_weapons = "Вы не можете спавнить оружие.",
    drive_disabled = "Сейчас управление отключено.",
    property_disabled = "В данный момент свойство отключено.",

    not_allowed_to_purchase = "У вас нет прав для покупки этого.",

    rp_teamban_hint = "rp_teamban [имя игрока/ID] [имя команды/id]. Используйте это для бана игрока в комманде.",
    rp_teamunban_hint = "rp_teamunban [имя игрока/ID] [имя команды/id]. Используйте это для разбана игрока в комманде.",
    x_teambanned_y = "%s забанен %s в связи с %s.",
    x_teamunbanned_y = "%s разбанен %s в связи с %s.",

    -- Backwards compatibility:
    you_set_x_salary_to_y = "Вы установили для %s's зарплату в %s%d.",
    x_set_your_salary_to_y = "%s установил вам зарплату в %s%d.",
    you_set_x_money_to_y = "Вы дали %s's %s%d валюты.",
    x_set_your_money_to_y = "%s сделал вам %s%d тригов",

    you_set_x_salary = "Вы сделали для %s заплату в %s валюты.",
    x_set_your_salary = "%s установил вашу зарплату в %s.",
    you_set_x_money = "Вы установили для %s %s валюты.",
    x_set_your_money = "%s сделал вам %s денег.",
    you_set_x_name = "Вы переименовали %s в %s",
    x_set_your_name = "%s сменил ваше имя на %s",

    someone_stole_steam_name = "У кого-то такое же имя, как у вас. К вашему имени приставлена цифра 1.", -- Uh oh
    already_taken = "Занят.",

    job_doesnt_require_vote_currently = "Эта работа не требует голосования!",

    x_made_you_a_y = "%s сделал вас %s!",

    cmd_cant_be_run_server_console = "Эта команда не может быть запущеной с серверной консоли.",

    -- The lottery
    lottery_started = "Лотерея! Учавствовать за %s%d?", -- backwards compatibility
    lottery_has_started = "Лотерея! Учавствовать за %s?",
    lottery_entered = "Вы учавствуете в лотерее за %s",
    lottery_not_entered = "%s не учавствует в лотерее",
    lottery_noone_entered = "Никто не хочет учавствовать в лотерее",
    lottery_won = "%s выиграл в лотрее! Его выигрыш %s",

    -- Animations
    custom_animation = "Кастомная анимация!",
    bow = "Поклониться",
    dance = "Танцевать",
    follow_me = "За мной!",
    laugh = "Угарать",
    lion_pose = "Львиная поза",
    nonverbal_no = "Нет",
    thumbs_up = "Недурно",
    wave = "Волна",

    -- Hungermod
    starving = "Голодание!",

    -- AFK
    afk_mode = "Режим АФК",
    salary_frozen = "Ваша зарплата заморожена.",
    salary_restored = "Добро пожаловать назад. Ваша зарплата восстановлена.",
    no_auto_demote = "Вы не были автоматически понижены.",
    youre_afk_demoted = "Вы были понижены за долгое отсутствие. В следующий раз используйте /afk.",
    hes_afk_demoted = "%s был понижен за долгое отсутствие.",
    afk_cmd_to_exit = "Введите /afk опять, чтобы выйти из АФК режима.",
    player_now_afk = "%s отошел.",
    player_no_longer_afk = "%s вернулся.",

    -- Hitmenu
    hit = "убийство",
    hitman = "Убийца",
    current_hit = "Цель: %s",
    cannot_request_hit = "Нельзя заказать убийство! %s",
    hitmenu_request = "Запрос",
    player_not_hitman = "Этот игрок не убийца!",
    distance_too_big = "Дистанция слишком большая.",
    hitman_no_suicide = "Убийца хочет убить себя.",
    hitman_no_self_order = "Убийца не может заказать сам себя.",
    hitman_already_has_hit = "Убийца занят.",
    price_too_low = "Цена слишком малая!",
    hit_target_recently_killed_by_hit = "The target was recently killed by a hit,",
    customer_recently_bought_hit = "The customer has recently requested a hit.",
    accept_hit_question = "Принять запрос от %s\nна%s за %s%d?", -- backwards compatibility
    accept_hit_request = "Accept hit from %s\nregarding %s for %s?",
    hit_requested = "Убийство запрошено!",
    hit_aborted = "Убийство отменено! %s",
    hit_accepted = "Запрос на убийство принят!",
    hit_declined = "Убийца отказал в запросе!",
    hitman_left_server = "Убийца покинул сервер!",
    customer_left_server = "Заказчик покинул сервер!",
    target_left_server = "Цель покинула сервер!",
    hit_price_set_to_x = "Цена за убийство изменена на %s%d.", -- backwards compatibility
    hit_price_set = "Цена за убийство установлена в %s.",
    hit_complete = "Убийца %s выполнил свою задачу!",
    hitman_died = "Убийца лоханулся и умер!",
    target_died = "Цель убийства умерла!",
    hitman_arrested = "Убийца лоханулся и попал на зону!",
    hitman_changed_team = "Убийца решил измениться и сменил профу!",
    x_had_hit_ordered_by_y = "%s имеет активный заказ от %s",

    -- Vote Restrictions
    hobos_no_rights = "Бомжи не могут голосовать!",
    gangsters_cant_vote_for_government = "Гангстеры не могут стать ГО!",
    government_cant_vote_for_gangsters = "ГО не могут стать напрямую гангстерами!",

    -- VGUI and some more doors/vehicles
    vote = "Опрос",
    time = "Время: %d",
    yes = "Да",
    no = "Нет",
    ok = "ОК",
    cancel = "Отмена",
    add = "Добавить",
    remove = "Удалить",
    none = "ничо",

    x_options = "%s опции",
    sell_x = "Продать %s",
    set_x_title = "Уст. заголовок: %s",
    set_x_title_long = "Установите название %s на которую смотрите.",
    jobs = "Работы",
    buy_x = "Купить %s",

    -- F4menu
    no_extra_weapons = "У этой работы нету доп. оружия.",
    become_job = "Приступить",
    create_vote_for_job = "Голосование",
    shipments = "Внутри",
    F4guns = "Оружие",
    F4entities = "Разное",
    F4ammo = "Патроны",
    F4vehicles = "Транспорт",


    -- Tab 1
    give_money = "Дать денег человеку, на которого смотрите",
    drop_money = "Бросить денег",
    change_name = "Сменить РП имя",
    go_to_sleep = "Лечь спать/проснуться",
    drop_weapon = "Выбросить оружие",
    buy_health = "Купить ХП(%s)",
    request_gunlicense = "Запросить лицензию на оружие",
    demote_player_menu = "Понизить жителя",


    searchwarrantbutton = "Подать человека в розыск",
    unwarrantbutton = "Убрать розыск с человека",
    noone_available = "Ни один не доступен",
    request_warrant = "Запросить ордер на обыск игрока",
    make_wanted = "Подать на кого-то в розыск",
    make_unwanted = "Снять с кого-то розыск",
    set_jailpos = "Установить позицию для тюрьмы",
    add_jailpos = "Добавить тюремную позицию",

    set_custom_job = "Получить уникальную работу",

    set_agenda = "Отдать приказ",

    initiate_lockdown = "Объявить ком. час",
    stop_lockdown = "Отменить ком. час",
    start_lottery = "Начать лотерею",
    give_license_lookingat = "Дать <lookingat> лицензию на оружие",

    laws_of_the_land = "ЗАКОНЫ ГОРОДА",
    law_added = "Закон добавлен.",
    law_removed = "Удалено %s законов.",
    law_edited = "Закон изменен.",
    law_reset = "Законы сброшены.",
    law_too_short = "Закон слишком короткий.",
    law_too_long = "Закон слишком длинный.",
    laws_full = "Максимум законов.",
    default_law_change_denied = "Вы не можете изменить стандартные законы.",

    -- Second tab
    job_name = "Имя: ",
    job_description = "Описание: ",
    job_weapons = "Оружия: ",

    -- Entities tab
    buy_a = "Купить %s: %s",

    -- Licenseweaponstab
    license_tab = [[License weapons

    Tick the weapons people should be able to get WITHOUT a license!
    ]],
    license_tab_other_weapons = "Другое оружие:",
    zombie_spawn_removed = "Вы удлалили этот спавн зомби.",     
    zombie_spawn = "Спавн зомби",       
    zombie_disabled = "Зомби отключены.",       
    zombie_enabled = "Зомби включены.",     
    zombie_maxset = "Макс. кол-во зомби изменено на %s",        
    zombie_spawn_added = "Вы добавили спавн зомби.",        
    zombie_spawn_not_exist = "Спавн %s не существует.",     
    zombie_leaving = "Zombies are leaving.",        
    zombie_approaching = "WARNING: Zombies are approaching!",       
    zombie_toggled = "Zombies toggled.",
}

DarkRP.addLanguage("en", my_language)
--gamemodes/darkrp/gamemode/modules/jobs/cl_vars.lua:
-- comment
--gamemodes/darkrp/gamemode/modules/fpp/pp/sh_cppi.lua:
CPPI = CPPI or {}
CPPI.CPPI_DEFER = 102112 --\102\112 = fp
CPPI.CPPI_NOTIMPLEMENTED = 7080 --\70\80 = FP

function CPPI:GetName()
	return "Falco's prop protection"
end

function CPPI:GetVersion()
	return "universal.1"
end

function CPPI:GetInterfaceVersion()
	return 1.3
end

function CPPI:GetNameFromUID(uid)
	return CPPI.CPPI_NOTIMPLEMENTED
end

local PLAYER = FindMetaTable("Player")
function PLAYER:CPPIGetFriends()
	if not self.Buddies then return CPPI.CPPI_DEFER end
	local FriendsTable = {}

	for k, v in pairs(self.Buddies) do
		if not table.HasValue(v, true) then continue end -- not buddies in anything
		table.insert(FriendsTable, k)
	end

	return FriendsTable
end

local ENTITY = FindMetaTable("Entity")
function ENTITY:CPPIGetOwner()
	local Owner = FPP.entGetOwner(self)
	if not IsValid(Owner) or not Owner:IsPlayer() then return SERVER and Owner or nil, self.FPPOwnerID end
	return Owner, Owner:UniqueID()
end

if SERVER then
	function ENTITY:CPPISetOwner(ply)
		if ply == self.FPPOwner then return end

		local valid = IsValid(ply) and ply:IsPlayer()
		local steamId = valid and ply:SteamID() or nil
		local canSetOwner = hook.Run("CPPIAssignOwnership", ply, self, valid and ply:UniqueID() or ply)

		if canSetOwner == false then return false end
		ply = canSetOwner ~= nil and canSetOwner ~= true and canSetOwner or ply
		self.FPPOwner = ply
		self.FPPOwnerID = steamId

		self.FPPOwnerChanged = true
		FPP.recalculateCanTouch(player.GetAll(), {self})
		self.FPPOwnerChanged = nil

		return true
	end

	function ENTITY:CPPISetOwnerUID(UID)
		local ply = UID and player.GetByUniqueID(tostring(UID)) or nil
		if UID and not IsValid(ply) then return false end
		return self:CPPISetOwner(ply)
	end

	function ENTITY:CPPICanTool(ply, tool)
		local Value = FPP.Protect.CanTool(ply, nil, tool, self)
		if Value ~= false and Value ~= true then Value = true end
		return Value
	end

	function ENTITY:CPPICanPhysgun(ply)
		return FPP.plyCanTouchEnt(ply, self, "Physgun")
	end

	function ENTITY:CPPICanPickup(ply)
		return FPP.plyCanTouchEnt(ply, self, "Gravgun")
	end

	function ENTITY:CPPICanPunt(ply)
		return FPP.plyCanTouchEnt(ply, self, "Gravgun")
	end

	function ENTITY:CPPICanUse(ply)
		return FPP.plyCanTouchEnt(ply, self, "PlayerUse")
	end

	function ENTITY:CPPICanDamage(ply)
		return FPP.plyCanTouchEnt(ply,  self, "EntityDamage")
	end

	function ENTITY:CPPIDrive(ply)
		local Value = FPP.Protect.CanDrive(ply, self)
		if Value ~= false and Value ~= true then Value = true end
		return Value
	end

	function ENTITY:CPPICanProperty(ply, property)
		local Value = FPP.Protect.CanProperty(ply, property, self)
		if Value ~= false and Value ~= true then Value = true end
		return Value
	end

	function ENTITY:CPPICanEditVariable(ply, key, val, editTbl)
		return self:CPPICanProperty(ply, "editentity")
	end
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/cleanup/cl_init.lua:
FAdmin.StartHooks["CleanUp"] = function()
    FAdmin.Access.AddPrivilege("CleanUp", 2)
    FAdmin.Commands.AddCommand("ClearDecals", nil)
    FAdmin.Commands.AddCommand("StopSounds", nil)
    FAdmin.Commands.AddCommand("CleanUp", nil)

    FAdmin.ScoreBoard.Server:AddServerAction("Clear decals", "fadmin/icons/cleanup", Color(155, 0, 0, 255), function(ply) return FAdmin.Access.PlayerHasPrivilege(ply, "CleanUp") end, function(ply, button)
        RunConsoleCommand("_FAdmin", "ClearDecals")
    end)

    FAdmin.ScoreBoard.Server:AddServerAction("Stop all sounds", "fadmin/icons/cleanup", Color(155, 0, 0, 255), function(ply) return FAdmin.Access.PlayerHasPrivilege(ply, "CleanUp") end, function(ply, button)
        RunConsoleCommand("_FAdmin", "StopSounds")
    end)

    net.Receive("FAdmin_StopSounds", function()
        RunConsoleCommand("stopsound") -- bypass for ConCommand blocking it
    end)

    FAdmin.ScoreBoard.Server:AddServerAction("Clean up server", "fadmin/icons/cleanup", Color(155, 0, 0, 255), function(ply) return FAdmin.Access.PlayerHasPrivilege(ply, "CleanUp") end, function(ply, button)
        RunConsoleCommand("_FAdmin", "CleanUp")
    end)
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/cl_interface/cl_scoreboardmain.lua:
local Sorted, SortDown = CreateClientConVar("FAdmin_SortPlayerList", "Team", true), CreateClientConVar("FAdmin_SortPlayerListDown", 1, true)
local allowedSorts = {
    ["Name"] = true,
    ["Team"] = true,
    ["Frags"] = true,
    ["Deaths"] = true,
    ["Ping"] = true
}

function FAdmin.ScoreBoard.Main.Show()
    local Sort = {}
    local ScreenWidth, ScreenHeight = ScrW(), ScrH()

    FAdmin.ScoreBoard.X = ScreenWidth * 0.05
    FAdmin.ScoreBoard.Y = ScreenHeight * 0.025
    FAdmin.ScoreBoard.Width = ScreenWidth * 0.9
    FAdmin.ScoreBoard.Height = ScreenHeight * 0.95

    FAdmin.ScoreBoard.ChangeView("Main")

    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList = FAdmin.ScoreBoard.Main.Controls.FAdminPanelList or vgui.Create("DPanelList")
    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:SetVisible(true)
    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:Clear(true)
    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList.Padding = 3
    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:EnableVerticalScrollbar(true)


    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:Clear(true)

    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:SetPos(FAdmin.ScoreBoard.X + 20, FAdmin.ScoreBoard.Y + 90 + 30 + 20)
    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:SetSize(FAdmin.ScoreBoard.Width - 40, FAdmin.ScoreBoard.Height - 90 - 30 - 20 - 20)

    Sort.Name = Sort.Name or vgui.Create("DLabel")
    Sort.Name:SetText("Sort by:     Name")
    Sort.Name:SetPos(FAdmin.ScoreBoard.X + 20, FAdmin.ScoreBoard.Y + 90 + 30)
    Sort.Name.Type = "Name"
    Sort.Name:SetVisible(true)

    Sort.Team = Sort.Team or vgui.Create("DLabel")
    Sort.Team:SetText("Team")
    Sort.Team:SetPos(ScreenWidth * 0.5 - 30, FAdmin.ScoreBoard.Y + 90 + 30)
    Sort.Team.Type = "Team"
    Sort.Team:SetVisible(true)

    Sort.Frags = Sort.Frags or vgui.Create("DLabel")
    Sort.Frags:SetText("Kills")
    Sort.Frags:SetPos(FAdmin.ScoreBoard.X + FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:GetWide() - 200,  FAdmin.ScoreBoard.Y + 90 + 30)
    Sort.Frags.Type = "Frags"
    Sort.Frags:SetVisible(true)

    Sort.Deaths = Sort.Deaths or vgui.Create("DLabel")
    Sort.Deaths:SetText("Deaths")
    Sort.Deaths:SetPos(FAdmin.ScoreBoard.X + FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:GetWide() - 140, FAdmin.ScoreBoard.Y + 90 + 30)
    Sort.Deaths.Type = "Deaths"
    Sort.Deaths:SetVisible(true)

    Sort.Ping = Sort.Ping or vgui.Create("DLabel")
    Sort.Ping:SetText("Ping")
    Sort.Ping:SetPos(FAdmin.ScoreBoard.X + FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:GetWide() - 50, FAdmin.ScoreBoard.Y + 90 + 30)
    Sort.Ping.Type = "Ping"
    Sort.Ping:SetVisible(true)

    local sortBy = Sorted:GetString()
    sortBy = allowedSorts[sortBy] and sortBy or "Team"

    FAdmin.ScoreBoard.Main.PlayerListView(sortBy, SortDown:GetBool())

    for k,v in pairs(Sort) do
        v:SetFont("Trebuchet20")
        v:SizeToContents()

        local X, Y = v:GetPos()

        v.BtnSort = vgui.Create("DButton")
        v.BtnSort:SetText("")
        v.BtnSort.Type = "Down"
        v.BtnSort.Paint = function( panel, w, h ) derma.SkinHook("Paint", "ButtonDown", panel, w, h ) end
        v.BtnSort:SetSkin(GAMEMODE.Config.DarkRPSkin)
        if Sorted:GetString() == v.Type then
            v.BtnSort.Depressed = true
            v.BtnSort.Type = (SortDown:GetBool() and "Down") or "Up"
        end
        v.BtnSort:SetSize(16, 16)
        v.BtnSort:SetPos(X + v:GetWide() + 5, Y + 4)
        function v.BtnSort.DoClick()
            for a,b in pairs(Sort) do
                b.BtnSort.Depressed = b.BtnSort == v.BtnSort
            end
            v.BtnSort.Type = (v.BtnSort.Type == "Down" and "Up") or "Down"
            v.BtnSort.Paint = function(panel, w, h)
                derma.SkinHook("Paint", "Button" .. v.BtnSort.Type, panel, w, h)
            end

            RunConsoleCommand("FAdmin_SortPlayerList", v.Type)
            RunConsoleCommand("FAdmin_SortPlayerListDown", (v.BtnSort.Type == "Down" and "1") or "0")
            FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:Clear(true)
            FAdmin.ScoreBoard.Main.PlayerListView(v.Type, v.BtnSort.Type == "Down")
        end
        table.insert(FAdmin.ScoreBoard.Main.Controls, v) -- Add them to the table so they get removed when you close the scoreboard
        table.insert(FAdmin.ScoreBoard.Main.Controls, v.BtnSort)
    end
end

function FAdmin.ScoreBoard.Main.AddPlayerRightClick(Name, func)
    FAdmin.PlayerIcon.RightClickOptions[Name] = func
end

FAdmin.StartHooks["CopySteamID"] = function()
    FAdmin.ScoreBoard.Main.AddPlayerRightClick("Скопировать SteamID", function(ply) SetClipboardText(ply:SteamID()) end)
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/cl_interface/cl_scoreboard.lua:
local OverrideScoreboard = CreateClientConVar("FAdmin_OverrideScoreboard", 0, true, false) -- Set if it's a scoreboard or not

function FAdmin.ScoreBoard.ChangeView(newView, ...)
    if FAdmin.ScoreBoard.CurrentView == newView or not FAdmin.ScoreBoard.Visible then return end

    for k,v in pairs(FAdmin.ScoreBoard[FAdmin.ScoreBoard.CurrentView].Controls) do
        v:SetVisible(false)
    end

    FAdmin.ScoreBoard.CurrentView = newView
    FAdmin.ScoreBoard[newView].Show(...)
    FAdmin.ScoreBoard.ChangeGmodLogo(FAdmin.ScoreBoard[newView].Logo)

    FAdmin.ScoreBoard.Controls.BackButton = FAdmin.ScoreBoard.Controls.BackButton or vgui.Create("DButton")
    FAdmin.ScoreBoard.Controls.BackButton:SetVisible(true)
    FAdmin.ScoreBoard.Controls.BackButton:SetPos(FAdmin.ScoreBoard.X, FAdmin.ScoreBoard.Y)
    FAdmin.ScoreBoard.Controls.BackButton:SetText("")
    FAdmin.ScoreBoard.Controls.BackButton:SetTooltip("Click me to go back!")
    FAdmin.ScoreBoard.Controls.BackButton:SetCursor("hand")
    FAdmin.ScoreBoard.Controls.BackButton:SetSize(100,90)
    FAdmin.ScoreBoard.Controls.BackButton:SetZPos(999)

    function FAdmin.ScoreBoard.Controls.BackButton:DoClick()
        FAdmin.ScoreBoard.ChangeView("Main")
    end
    FAdmin.ScoreBoard.Controls.BackButton.Paint = wlib.func.blank
end

--"fadmin/back", gui/gmod_tool gui/gmod_logo
local GmodLogo, TempGmodLogo, GmodLogoColor = surface.GetTextureID("gui/gmod_logo"), surface.GetTextureID("gui/gmod_logo"), Color(255, 255, 255, 255)
function FAdmin.ScoreBoard.ChangeGmodLogo(new)
    if surface.GetTextureID(new) == TempGmodLogo then return end
    TempGmodLogo = surface.GetTextureID(new)
    for i = 0, 0.5, 0.01 do
        timer.Simple(i, function() GmodLogoColor = Color(255,255,255,GmodLogoColor.a-5.1) end)
    end
    timer.Simple(0.5, function() GmodLogo = surface.GetTextureID(new) end)
    for i = 0.5, 1, 0.01 do
        timer.Simple(i, function()
            GmodLogoColor = Color(255, 255, 255, GmodLogoColor.a + 5.1)
        end)
    end
end

function FAdmin.ScoreBoard.Background()
    surface.SetDrawColor(0,0,0,200)
    surface.DrawRect(FAdmin.ScoreBoard.X, FAdmin.ScoreBoard.Y, FAdmin.ScoreBoard.Width, FAdmin.ScoreBoard.Height)

    surface.SetTexture(GmodLogo)
    surface.SetDrawColor(255,255,255,GmodLogoColor.a)
    surface.DrawTexturedRect(FAdmin.ScoreBoard.X - 20, FAdmin.ScoreBoard.Y, 128, 128)
end


function FAdmin.ScoreBoard.DrawScoreBoard()
    if (input.IsMouseDown(MOUSE_4) or input.IsKeyDown(KEY_BACKSPACE)) and not FAdmin.ScoreBoard.DontGoBack then
        FAdmin.ScoreBoard.ChangeView("Main")
    elseif FAdmin.ScoreBoard.DontGoBack then
        FAdmin.ScoreBoard.DontGoBack = input.IsMouseDown(MOUSE_4) or input.IsKeyDown(KEY_BACKSPACE)
    end
    FAdmin.ScoreBoard.Background()
end

function FAdmin.ScoreBoard.ShowScoreBoard()
    FAdmin.ScoreBoard.Visible = true
    FAdmin.ScoreBoard.DontGoBack = input.IsMouseDown(MOUSE_4) or input.IsKeyDown(KEY_BACKSPACE)

    FAdmin.ScoreBoard.Controls.Hostname = FAdmin.ScoreBoard.Controls.Hostname or vgui.Create("DLabel")
    FAdmin.ScoreBoard.Controls.Hostname:SetText(DarkRP.deLocalise(GetHostName()))
    FAdmin.ScoreBoard.Controls.Hostname:SetFont("ScoreboardHeader")
    FAdmin.ScoreBoard.Controls.Hostname:SetColor(Color(200,200,200,200))
    FAdmin.ScoreBoard.Controls.Hostname:SetPos(FAdmin.ScoreBoard.X + 90, FAdmin.ScoreBoard.Y + 20)
    FAdmin.ScoreBoard.Controls.Hostname:SizeToContents()
    FAdmin.ScoreBoard.Controls.Hostname:SetVisible(true)

    FAdmin.ScoreBoard.Controls.Description = FAdmin.ScoreBoard.Controls.Description or vgui.Create("DLabel")
    FAdmin.ScoreBoard.Controls.Description:SetText(string.format("%s %s\n%s", GAMEMODE.Name, GAMEMODE.Version, GAMEMODE.Author))
    FAdmin.ScoreBoard.Controls.Description:SetFont("ScoreboardSubtitle")
    FAdmin.ScoreBoard.Controls.Description:SetColor(Color(200,200,200,200))
    FAdmin.ScoreBoard.Controls.Description:SetPos(FAdmin.ScoreBoard.X + 90, FAdmin.ScoreBoard.Y + 50)
    FAdmin.ScoreBoard.Controls.Description:SizeToContents()
    if FAdmin.ScoreBoard.X + FAdmin.ScoreBoard.Width / 9.5 + FAdmin.ScoreBoard.Controls.Description:GetWide() > FAdmin.ScoreBoard.Width - 150 then
        FAdmin.ScoreBoard.Controls.Description:SetFont("Trebuchet18")
        FAdmin.ScoreBoard.Controls.Description:SetPos(FAdmin.ScoreBoard.X + 90, FAdmin.ScoreBoard.Y + 50)
    end
    FAdmin.ScoreBoard.Controls.Description:SetVisible(true)

    FAdmin.ScoreBoard.Controls.ServerSettingsLabel = FAdmin.ScoreBoard.Controls.ServerSettingsLabel or vgui.Create("DLabel")
    FAdmin.ScoreBoard.Controls.ServerSettingsLabel:SetFont("ScoreboardSubtitle")
    FAdmin.ScoreBoard.Controls.ServerSettingsLabel:SetText("Server settings")
    FAdmin.ScoreBoard.Controls.ServerSettingsLabel:SetColor(Color(200,200,200,200))
    FAdmin.ScoreBoard.Controls.ServerSettingsLabel:SizeToContents()
    FAdmin.ScoreBoard.Controls.ServerSettingsLabel:SetPos(FAdmin.ScoreBoard.Width-150, FAdmin.ScoreBoard.Y + 68)
    FAdmin.ScoreBoard.Controls.ServerSettingsLabel:SetVisible(true)

    FAdmin.ScoreBoard.Controls.ServerSettings = FAdmin.ScoreBoard.Controls.ServerSettings or vgui.Create("DImageButton")
    FAdmin.ScoreBoard.Controls.ServerSettings:SetMaterial("vgui/gmod_tool")
    FAdmin.ScoreBoard.Controls.ServerSettings:SetPos(FAdmin.ScoreBoard.Width-200, FAdmin.ScoreBoard.Y - 20)
    FAdmin.ScoreBoard.Controls.ServerSettings:SizeToContents()
    FAdmin.ScoreBoard.Controls.ServerSettings:SetVisible(true)

    function FAdmin.ScoreBoard.Controls.ServerSettings:DoClick()
        FAdmin.ScoreBoard.ChangeView("Server")
    end

    if FAdmin.ScoreBoard.Controls.BackButton then FAdmin.ScoreBoard.Controls.BackButton:SetVisible(true) end

    FAdmin.ScoreBoard[FAdmin.ScoreBoard.CurrentView].Show()

    gui.EnableScreenClicker(true)
    hook.Add("HUDPaint", "FAdmin_ScoreBoard", FAdmin.ScoreBoard.DrawScoreBoard)
    hook.Call("FAdmin_ShowFAdminMenu")
    return true
end
concommand.Add("+FAdmin_menu", FAdmin.ScoreBoard.ShowScoreBoard)

--[[
hook.Add("ScoreboardShow", "FAdmin_scoreboard", function()
    if FAdmin.GlobalSetting.FAdmin or OverrideScoreboard:GetBool() then -- Don't show scoreboard when FAdmin is not installed on server
        return FAdmin.ScoreBoard.ShowScoreBoard()
    end
end)
]]

function FAdmin.ScoreBoard.HideScoreBoard()
    if not FAdmin.GlobalSetting.FAdmin then return end
    FAdmin.ScoreBoard.Visible = false
    CloseDermaMenus()

    gui.EnableScreenClicker(false)
    hook.Remove("HUDPaint", "FAdmin_ScoreBoard")

    for k,v in pairs(FAdmin.ScoreBoard[FAdmin.ScoreBoard.CurrentView].Controls) do
        v:SetVisible(false)
    end

    for k,v in pairs(FAdmin.ScoreBoard.Controls) do
        v:SetVisible(false)
    end
    return true
end
concommand.Add("-FAdmin_menu", FAdmin.ScoreBoard.HideScoreBoard)

--[[
hook.Add("ScoreboardHide", "FAdmin_scoreboard", function()
    if FAdmin.GlobalSetting.FAdmin or OverrideScoreboard:GetBool() then -- Don't show scoreboard when FAdmin is not installed on server
        return FAdmin.ScoreBoard.HideScoreBoard()
    end
end)
]]
--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/adminchat/cl_init.lua:

net.Receive("FAdmin_ReceiveAdminMessage", function(len)
    local FromPly = net.ReadEntity()
    local Text = net.ReadString()
    local Team = FromPly:IsPlayer() and FromPly:Team() or 1
    local Nick = FromPly:IsPlayer() and FromPly:Nick() or "Console"
    local prefix = (FAdmin.Access.PlayerHasPrivilege(FromPly, "AdminChat") or FromPly:IsAdmin()) and "[Admin Chat] " or "[To admins] "

    chat.AddNonParsedText(Color(255, 0, 0, 255), prefix, team.GetColor(Team), Nick .. ": ", Color(255, 255, 255, 255), Text)
end)

FAdmin.StartHooks["Chatting"] = function()
    FAdmin.Commands.AddCommand("adminhelp", nil, "<text>")
    FAdmin.Commands.AddCommand("//", nil, "<text>")

    FAdmin.Access.AddPrivilege("AdminChat", 2)
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/police/sh_init.lua:
FAdmin.StartHooks["police_sh"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "arrest",
        hasTarget = true,
        message = {"instigator", " арестовал ", "targets", " на ", "extraInfo.1"},
        receivers = "involved+admins",
        writeExtraInfo = function(info) net.WriteUInt(info[1], 16) end,
        readExtraInfo = function()
            local time = wlib.string.formatPlural({"секунду", "секунды", "секунд"}, net.ReadUInt(16))
            return {time}
        end,
    }

    FAdmin.Messages.RegisterNotification{
        name = "unarrest",
        hasTarget = true,
        message = {"instigator", " разарестовал ", "targets"},
        receivers = "involved+admins",
    }
end
--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/kickban/cl_init.lua:
--[[
WHEN GETTING KICKED
]]
local KickText = ""

local BanText = "No reason"
local BanTimeText = "permanent"

net.Receive("FAdmin_ban_start", function()
    -- hook.Add("HUDPaint", "FAdmin_ban", function()
    --     draw.RoundedBox(0,0,0, ScrW(), ScrH(), Color(0,0,0,255))
    --     draw.DrawNonParsedText("You are getting banned\nReason: " .. BanText .. "\nTime: " .. " " .. BanTimeText .. "\nLeaving voluntarily or rejoining will not prevent banning.", "HUDNumber5", ScrW() / 2, ScrH() / 2, Color(0, 0, 255, 255), TEXT_ALIGN_CENTER)
    -- end)
end)

--[[---------------------------------------------------------------------------
Show the window for banning
---------------------------------------------------------------------------]]
local function showBanWindow(SteamID, NICK, time, reason)
    local BanTime = time or 60
    NICK = NICK or ""
    reason = reason or "No reason"
    local M,H,D,W,Y = BanTime % 60,
        math.floor(BanTime / 60) % 24,
        math.floor(BanTime / 1440) % 7,
        math.floor(BanTime / 10080) % 53,
        math.floor(BanTime / 525948)

    RunConsoleCommand("_FAdmin", "ban", SteamID, "start")

    local Window = vgui.Create("DFrame")
    Window:SetTitle("Детали бана")
    Window:SetDraggable( false )
    Window:ShowCloseButton(false)
    Window:SetBackgroundBlur( true )
    Window:SetDrawOnTop( true )

    local InnerPanel = vgui.Create("DPanel", Window)
    InnerPanel:SetPaintBackground(false)

    local Text = vgui.Create("DLabel", InnerPanel)
        Text:SetText("Бан " .. NICK .. "")
        Text:SizeToContents()
        Text:SetContentAlignment( 5 )


    local TimePanel = vgui.Create("DPanel", Window)
    TimePanel:SetPaintBackground(false)

    local TextEntry = vgui.Create("DTextEntry", TimePanel)
        function TextEntry:OnTextChanged()
            RunConsoleCommand("_FAdmin", "ban", SteamID, "update", BanTime, self:GetValue())
        end
        TextEntry:SetText(DarkRP.deLocalise(reason))
        TextEntry.OnEnter = function() Window:Close() RunConsoleCommand("_FAdmin", "ban", SteamID, "execute", BanTime, TextEntry:GetValue()) end
        function TextEntry:OnFocusChanged(changed)
            self:RequestFocus()
            self:SelectAllText(true)
        end

    local Minutes = vgui.Create("DNumberWang", TimePanel)
    Minutes:SetMinMax(0, 59)
    Minutes:SetDecimals(0)
    Minutes:SetValue(M)

    local Hours = vgui.Create("DNumberWang", TimePanel)
    Hours:SetMinMax(0, 23)
    Hours:SetValue(H)
    Hours:SetDecimals(0)

    local Days = vgui.Create("DNumberWang", TimePanel)
    Days:SetMinMax(0, 6)
    Days:SetValue(D)
    Days:SetDecimals(0)

    local Weeks = vgui.Create("DNumberWang", TimePanel)
    Weeks:SetMinMax(0, 53)
    Weeks:SetValue(W)
    Weeks:SetDecimals(0)

    local Years = vgui.Create("DNumberWang", TimePanel)
    Years:SetMinMax(0, 3)
    Years:SetValue(Y)
    Years:SetDecimals(0)

    local MinLabel, HourLabel, DayLabel, WeekLabel, YearLabel = vgui.Create("DLabel", TimePanel), vgui.Create("DLabel", TimePanel),
    vgui.Create("DLabel", TimePanel), vgui.Create("DLabel", TimePanel), vgui.Create("DLabel", TimePanel)
    MinLabel:SetText("Минуты:")
    HourLabel:SetText("Часы:")
    DayLabel:SetText("Дни:")
    WeekLabel:SetText("Недели:")
    YearLabel:SetText("Года:")


    MinLabel:SetPos(370, 0)
    HourLabel:SetPos(280, 0)
    DayLabel:SetPos(190, 0)
    WeekLabel:SetPos(100, 0)
    YearLabel:SetPos(10, 0)

    local function update()
        BanTime = M + H * 60 + D * 1440 + W * 10080 + Y * 525948
        --RunConsoleCommand("_FAdmin", "ban", SteamID, "update", BanTime, TextEntry:GetValue())
    end

    function Minutes:OnValueChanged(val) if val == M then return end M = val update() end
    function Hours:OnValueChanged(val) if val == H then return end H = val update() end
    function Days:OnValueChanged(val) if val == D then return end D = val update() end
    function Weeks:OnValueChanged(val) if val == W then return end W = val update() end
    function Years:OnValueChanged(val) if val == Y then return end Y = val update() end

    local ButtonPanel = vgui.Create("DPanel", Window)
    ButtonPanel:SetTall(25)
    ButtonPanel:SetPaintBackground(false)

    local Button = vgui.Create("DButton", ButtonPanel)
        Button:SetText("OK")
        Button:SizeToContents()
        Button:SetTall( 20 )
        Button:SetWide( Button:GetWide() + 20 )
        Button:SetPos(5, 3)
        Button.DoClick = function()
            Window:Close()
            M, H, D, W, Y = Minutes:GetValue(), Hours:GetValue(), Days:GetValue(), Weeks:GetValue(), Years:GetValue()
            update()
            RunConsoleCommand("_FAdmin", "ban", SteamID, BanTime, (TextEntry and TextEntry:GetValue()) or "")
        end

    local ButtonCancel = vgui.Create("DButton", ButtonPanel )
        ButtonCancel:SetText("Отмена")
        ButtonCancel:SizeToContents()
        ButtonCancel:SetTall( 20 )
        ButtonCancel:SetWide( Button:GetWide() + 20 )
        ButtonCancel:SetPos(5, 3)
        ButtonCancel.DoClick = function() Window:Close() end
        ButtonCancel:MoveRightOf( Button, 5 )

    ButtonPanel:SetWide( Button:GetWide() + 5 + ButtonCancel:GetWide() + 10 )

    Window:SetSize( 450, 111 + 75 + 20 )
    Window:Center()

    InnerPanel:StretchToParent( 5, 25, 5, 125 )
    TimePanel:StretchToParent(5, 83, 5, 37)

    Minutes:SetPos(370, 20)
    Hours:SetPos(280, 20)
    Days:SetPos(190, 20)
    Weeks:SetPos(100, 20)
    Years:SetPos(10, 20)

    Text:StretchToParent( 5, 5, 5, nil )

    TextEntry:StretchToParent( 5, nil, 5, nil )
    TextEntry:AlignBottom( 5 )

    TextEntry:RequestFocus()

    ButtonPanel:CenterHorizontal()
    ButtonPanel:AlignBottom(7)

    Window:MakePopup()
    Window:DoModal()
end

--[[
ADD BUTTONS ETC. TO MENU
]]
FAdmin.StartHooks["CL_KickBan"] = function()
    FAdmin.Access.AddPrivilege("Kick", 2)
    FAdmin.Access.AddPrivilege("Ban", 2)
    FAdmin.Access.AddPrivilege("UnBan", 2)

    FAdmin.Commands.AddCommand("kick", nil, "<Player>", "[Reason]")
    FAdmin.Commands.AddCommand("ban", nil, "<Player>", "<Time (minutes)>", "[Reason]")
    FAdmin.Commands.AddCommand("unban", "<SteamID>")

    FAdmin.ScoreBoard.Main.AddPlayerRightClick("Забанить", function(ply, Panel)
        showBanWindow(ply:SteamID(), ply:Nick())
        if IsValid(Panel) then Panel:Remove() end
    end)

    wayscore.AddActionButton('checkban', {
        name = 'Информация о бане',
        icon = 'icon72/mag.png',
        category = 'Администрирование',
        order = 2500,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Ban') and ply:IsBanned() end,
        callback = function(ply)
            RunConsoleCommand('fadmin', 'checkban', ply:SteamID())
        end,
    })

    wayscore.AddActionButton('kick', {
        name = 'Кикнуть',
        icon = 'fadmin/icons/kick',
        category = 'Администрирование',
        order = 3000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Kick', ply) end,
        callback = function(ply)
            if not IsValid(ply) then return end
            local UserID = ply:UserID()
            local NICK = ply:Nick()
    
            --RunConsoleCommand("FAdmin", "kick", UserID, "start")
            local Window = vgui.Create("DFrame")
            Window:SetTitle("Reason for kicking")
            Window:SetDraggable( false )
            Window:ShowCloseButton( false )
            Window:SetBackgroundBlur( true )
            Window:SetDrawOnTop( true )
    
            local InnerPanel = vgui.Create("DPanel", Window)
            InnerPanel:SetPaintBackground(false)
    
            local Text = vgui.Create("DLabel", InnerPanel)
                Text:SetText(NICK .. " knows he is getting kicked\nTake all your time entering the reason, he can't do anything anymore")
                Text:SizeToContents()
                Text:SetContentAlignment( 5 )
                Text:SetTextColor( color_white )
    
            local TextEntry = vgui.Create("DTextEntry", InnerPanel )
                function TextEntry:OnTextChanged()
                    --RunConsoleCommand("_FAdmin", "kick", UserID, "update", self:GetValue())
                end
                TextEntry:SetText("Enter reason here")
                TextEntry.OnEnter = function() Window:Close() RunConsoleCommand("_FAdmin", "kick", UserID, TextEntry:GetValue()) end
                function TextEntry:OnFocusChanged(changed)
                    self:RequestFocus()
                    self:SelectAllText(true)
                end
    
    
    
            local ButtonPanel = vgui.Create("DPanel", Window)
            ButtonPanel:SetTall(30)
            ButtonPanel:SetPaintBackground(false)
    
            local Button = vgui.Create("DButton", ButtonPanel)
                Button:SetText("OK")
                Button:SizeToContents()
                Button:SetTall( 20 )
                Button:SetWide( Button:GetWide() + 20 )
                Button:SetPos( 5, 5 )
                Button.DoClick = function() Window:Close() RunConsoleCommand("_FAdmin", "kick", UserID, TextEntry:GetValue()) end
    
            local ButtonCancel = vgui.Create("DButton", ButtonPanel )
                ButtonCancel:SetText("Cancel")
                ButtonCancel:SizeToContents()
                ButtonCancel:SetTall( 20 )
                ButtonCancel:SetWide( Button:GetWide() + 20 )
                ButtonCancel:SetPos( 5, 5 )
                ButtonCancel.DoClick = function() Window:Close() end
                ButtonCancel:MoveRightOf( Button, 5 )
    
            ButtonPanel:SetWide( Button:GetWide() + 5 + ButtonCancel:GetWide() + 10 )
    
            local w, h = Text:GetSize()
            w = math.max( w, 400 )
    
            Window:SetSize( w + 50, h + 25 + 75 + 10 )
            Window:Center()
    
            InnerPanel:StretchToParent( 5, 25, 5, 45 )
    
            Text:StretchToParent( 5, 5, 5, 35 )
    
            TextEntry:StretchToParent( 5, nil, 5, nil )
            TextEntry:AlignBottom( 5 )
    
            TextEntry:RequestFocus()
    
            ButtonPanel:CenterHorizontal()
            ButtonPanel:AlignBottom( 8 )
    
            Window:MakePopup()
            Window:DoModal()
        end,
    })

    wayscore.AddActionButton('ban', {
        name = 'Забанить',
        icon = 'fadmin/icons/ban',
        category = 'Администрирование',
        order = 5000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Ban', ply) end,
        callback = function(ply)
            local SteamID = ply:SteamID()
            local NICK = ply:Nick()
    
            if ply:IsBot() then SteamID = 'BOT' end
            showBanWindow(SteamID, NICK)
        end,
    })

    concommand.Add('fadmin_banlist', function()
        if not FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'UnBan') then return end
        local selectedLine

        local Frame = vgui.Create("DFrame")
        Frame:SetSize(740, 600)
        Frame:SetTitle("Unban Details")
        Frame:SetDraggable(true)
        Frame:ShowCloseButton(true)
        Frame:SetBackgroundBlur(true)
        Frame:SetDrawOnTop(true)

        local BanList = vgui.Create("DListView", Frame)
        BanList:StretchToParent(5, 55, 5, 5)
        BanList:AddColumn("SteamID")
        BanList:AddColumn("Name")
        BanList:AddColumn("Time")
        BanList:AddColumn("Reason")
        BanList:AddColumn("Banned by")
        BanList:AddColumn("Banned by SteamID")

        local unban = vgui.Create("DButton", Frame)
        unban:SetText("Unban")
        unban:SetPos(695, 25)
        unban:SetSize(40, 25)

        function unban:DoClick()
            if IsValid(selectedLine) then
                RunConsoleCommand("_FAdmin", "Unban", string.upper(selectedLine:GetValue(1)))
                BanList:RemoveLine(selectedLine:GetID())
            end
        end

        local edit = vgui.Create("DButton", Frame)
        edit:SetText("Edit")
        edit:SetPos(650, 25)
        edit:SetSize(40, 25)
        function edit:DoClick()
            if not selectedLine then return end
            showBanWindow(selectedLine:GetValue(1), selectedLine.name, selectedLine.time > os.time() and (selectedLine.time - os.time()) / 60 or 0, selectedLine.reason)
            Frame:Close()
        end

        local function RetrieveBans(len)
            local banCount = net.ReadUInt(32)

            for i = 1, banCount do
                local steamid = net.ReadString()
                local time = net.ReadUInt(32)
                local name = net.ReadString()
                local reason = net.ReadString()
                local adminname = net.ReadString()
                local adminsteam = net.ReadString()


                local Line = BanList:AddLine(
                        steamid,
                        name or "N/A",
                        (tonumber(time or "") and FAdmin.PlayerActions.ConvertBanTime((tonumber(time) - os.time()) / 60)) or "N/A",
                        reason or "",
                        adminname or "",
                        adminsteam or "")
                Line.name = name
                Line.time = time
                Line.reason = reason

                function Line:OnSelect()
                    selectedLine = self
                end
            end
        end
        net.Receive("FAdmin_retrievebans", RetrieveBans)
        RunConsoleCommand("_FAdmin", "RequestBans")

        Frame:Center()
        Frame:MakePopup()
        Frame:DoModal()
    end)
end

-- IB

local function playTime(time)

    local h, m, s
    h = math.floor(time / 60 / 60)
    m = math.floor(time / 60) % 60
    s = math.floor(time) % 60

    return string.format("%02i:%02i:%02i", h, m, s)

end

surface.CreateFont("chelog-ib", {
	font = "Roboto Bold",
	size = 48,
	weight = 500,
	extended = true,
})

surface.CreateFont("chelog-ib-shadow", {
	font = "Roboto Bold",
	size = 48,
	weight = 500,
    extended = true,
    blursize = 7,
})

surface.CreateFont("chelog-ib.small", {
	font = "Roboto",
	size = 22,
	weight = 500,
	extended = true,
})

hook.Add("HUDPaint", "chelog-ib", function()

    if not IsValid(LocalPlayer()) or not (LocalPlayer():GetNetVar("IsBanned")) then return end

    local time = LocalPlayer():GetNetVar("UnBanTime") or 0
    local text = time ~= 0 and ("Бан: " .. playTime(time - CurTime())) or "Пермабан"
    draw.SimpleText( text, "chelog-ib-shadow", ScrW() / 2, ScrH() - 70, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw.SimpleText( text, "chelog-ib", ScrW() / 2, ScrH() - 70, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw.SimpleText( LocalPlayer():GetNetVar('BanText'), "chelog-ib.small", ScrW() / 2, ScrH() - 40, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

end)
--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/changeteam/cl_init.lua:
FAdmin.StartHooks["zzSetTeam"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "setteam",
        hasTarget = true,
        message = {"instigator", " изменил профессию ", "targets", " на ", "extraInfo.1"},
        readExtraInfo = function()
            return {team.GetName(net.ReadUInt(16))}
        end,
        extraInfoColors = {Color(160, 171, 189)}
    }

    FAdmin.Access.AddPrivilege("SetTeam", 2)
    FAdmin.Commands.AddCommand("SetTeam", nil, "<Player>", "<Team>")

    wayscore.AddActionButton('setteam', {
        name = 'Изменить профессию',
        icon = 'fadmin/icons/changeteam',
        color = Color(0,200,0),
        category = 'Администрирование',
        order = 20000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'SetTeam', ply) end,
        callback = function(ply, button)
            local menu = DermaMenu()
    
            local Padding = vgui.Create("DPanel")
            Padding:SetPaintBackgroundEnabled(false)
            Padding:SetSize(1,5)
            menu:AddPanel(Padding)
    
            local Title = vgui.Create("DLabel")
            Title:SetText("  Teams:\n")
            Title:SetFont("UiBold")
            Title:SizeToContents()
            Title:SetTextColor(color_black)
    
            menu:AddPanel(Title)
            for k,v in SortedPairsByMemberValue(team.GetAllTeams(), "Name") do
                local uid = ply:UserID()
                menu:AddOption(v.Name, function() RunConsoleCommand("_FAdmin", "setteam", uid, k) end)
            end
            menu:Open()
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/doors/sh_init.lua:
local ENTITY = FindMetaTable('Entity')
local PLAYER = FindMetaTable('Player')

local doorClasses = {
	['func_door'] = true,
	['func_door_rotating'] = true,
	['prop_door_rotating'] = true,
	--['prop_dynamic'] = true,
}

function ENTITY:IsDoor()
	return (doorClasses[self:GetClass()] or false)
end

function ENTITY:DoorIsOwnable()
	return self:GetNetVar('Door.Config', {}).Ownable
end

function ENTITY:DoorIsEntrance()
	return self:GetNetVar('Door.Config', {}).Entrance
end

function ENTITY:DoorIsLocked()
	return self:GetNetVar('Door.Locked', false)
end

function ENTITY:DoorOwnedBy(ply)
	return self:GetNetVar('Door.Owner') == ply
end

function ENTITY:DoorCoOwnedBy(ply)
	local teams = self:DoorGetTeams() or {}
	local owners = self:DoorGetCoOwners()

	return teams[ply:Team()] or owners[ply]
end

function ENTITY:DoorGetTitle()
	return self:GetNetVar('Door.Title') or self:GetNetVar('Door.Config', {}).Title
end

function ENTITY:DoorGetOwner()
	return self:GetNetVar('Door.Owner')
end

function ENTITY:DoorGetCoOwners()
	return self:GetNetVar('Door.CoOwners', {})
end

function ENTITY:DoorGetTeams()
	return self:GetNetVar('Door.Config', {}).Teams
end

function ENTITY:DoorGetGroupID()
	return self:GetNetVar('Door.Config', {}).GroupID
end

function ENTITY:DoorGetGroup()
	return GAMEMODE.Config.Doors[self:DoorGetGroupID() or -1]
end

function PLAYER:GetOwnedDoors()
	local res = {}
	for gid, v in ipairs(GAMEMODE.Config.Doors) do
		for _, mapid in ipairs(v.MapIDs) do
			local ent = ents.GetMapCreatedEntity(mapid)
			if not IsValid(ent) then continue end

			if ent:DoorOwnedBy(self) or ent:DoorCoOwnedBy(self) then
				table.insert(res, gid)
				break
			end
		end
	end
	return res
end

nw.Register('Door.Config')
	:Write(function(d)
		net.WriteUInt(table.Count(d.Teams), 7)
		for k, _ in pairs(d.Teams) do
			net.WriteUInt(k, 7)
		end

		net.WriteString(d.Title or '')
		net.WriteUInt(d.GroupID, 8)
		net.WriteBool(d.Ownable)
		net.WriteBool(d.Entrance)
	end)
	:Read(function()
		local d = {
			Teams = {},
		}
		for i=1, net.ReadUInt(7) do
			d.Teams[net.ReadUInt(7)] = true
		end

		d.Title = net.ReadString()
		d.GroupID = net.ReadUInt(8)
		d.Ownable = net.ReadBool()
		d.Entrance = net.ReadBool()

		return d
	end)

nw.Register('Door.Title')
	:Write(net.WriteString)
	:Read(net.ReadString)

nw.Register('Door.Locked')
	:Write(net.WriteBool)
	:Read(net.ReadBool)

nw.Register('Door.Owner')
	:Write(net.WritePlayer)
	:Read(net.ReadPlayer)

nw.Register('Door.CoOwners')
	:Write(function(d)
		local t = {}
		for ply, _ in pairs(d) do
			if IsValid(ply) then table.insert(t, ply) end
		end

		net.WriteUInt(#t, 7)
		for _, v in ipairs(t) do
			net.WritePlayer(v)
		end
	end)
	:Read(function()
		local d = {}
		for i=1, net.ReadUInt(7) do
			d[net.ReadPlayer()] = true
		end

		return d
	end)
--gamemodes/darkrp/gamemode/modules/base/sh_commands.lua:
DarkRP.declareChatCommand{
    command = "rpname",
    description = "Set your RP name",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "name",
    description = "Set your RP name",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "nick",
    description = "Set your RP name",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "buy",
    description = "Buy a pistol",
    delay = 1.5,
    condition = fn.FAnd {
        fn.Compose{fn.Curry(fn.GetValue, 2)("enablebuypistol"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode},
        fn.Compose{fn.Not, fn.Curry(fn.GetValue, 2)("noguns"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
    }
}

DarkRP.declareChatCommand{
    command = "buyshipment",
    description = "Buy a shipment",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "buyvehicle",
    description = "Buy a vehicle",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "buyammo",
    description = "Purchase ammo",
    delay = 1.5,
    condition = fn.Compose{fn.Not, fn.Curry(fn.GetValue, 2)("noguns"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
}

DarkRP.declareChatCommand{
    command = "price",
    description = "Set the price of the microwave or gunlab you're looking at",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "setprice",
    description = "Set the price of the microwave or gunlab you're looking at",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "forcerpname",
    description = "Forcefully change a player's RP name",
    delay = 0.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "freerpname",
    description = "Remove a RP name from the database so a player can use it",
    delay = 1.5
}

--gamemodes/darkrp/gamemode/modules/base/sh_checkitems.lua:
--[[
The base elements are shared by every custom item
]]
local baseSchema = tc.checkTable{
    buttonColor =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber)),
            "The buttonColor must be a Color value."
        ),

    category =
        tc.addHint(
            tc.optional(isstring),
            "The category must be the name of an existing category!"
        ),

    customCheck =
        tc.addHint(
            tc.optional(isfunction),
            "The customCheck must be a function."
        ),

    CustomCheckFailMsg =
        tc.addHint(
            tc.optional(isstring, isfunction),
            "The CustomCheckFailMsg must be either a string or a function."
        ),

    sortOrder =
        tc.addHint(
            tc.optional(isnumber),
            "The sortOrder must be a number."
        ),

    label =
        tc.addHint(
            tc.optional(isstring),
            "The label must be a valid string."
        ),
}

--[[
Properties shared by anything buyable
]]
local buyableSchema = fn.FAnd{baseSchema, tc.checkTable{
    allowed =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber), isnumber),
            "The allowed field must be either an existing team or a table of existing teams.",
            {"Is there a job here that doesn't exist (anymore)?"}
        ),

    getPrice =
        tc.addHint(
            tc.optional(isfunction),
            "The getPrice must be a function."
        ),

    model =
        tc.addHint(
            isstring,
            "The model must be valid."
        ),

    price =
        tc.addHint(
            function(v, tbl) return isnumber(v) or isfunction(tbl.getPrice) end,
            "The price must be an existing number or (for advanced users) the getPrice field must be a function."
        ),

    spawn =
        tc.addHint(
            tc.optional(isfunction),
            "The spawn must be a function."
        ),
}}

-- The command of an entity must be unique
local uniqueEntity = function(cmd, tbl)
    for k, v in pairs(DarkRPEntities) do
        if v.cmd ~= cmd then continue end

        return
            false,
            "This entity does not have a unique command.",
            {
                "There must be some other entity that has the same thing for 'cmd'.",
                "Fix this by changing the 'cmd' field of your entity to something else."
            }
    end

    return true
end

-- The command of a job must be unique
local uniqueJob = function(v, tbl)
    local job = DarkRP.getJobByCommand(v)

    if not job then return true end

    return
        false,
        "This job does not have a unique command.",
        {
            "There must be some other job that has the same command.",
            "Fix this by changing the 'command' of your job to something else."
        }
end

--[[
Validate jobs
]]
DarkRP.validateJob = fn.FAnd{baseSchema, tc.checkTable{
    color =
        tc.addHint(
            tc.tableOf(isnumber),
            "The color must be a Color value.",
            {"Color values look like this: Color(r, g, b, a), where r, g, b and a are numbers between 0 and 255."}
        ),

    model =
        tc.addHint(
            fn.FOr{isstring, tc.nonEmpty(tc.tableOf(isstring))},
            "The model must either be a table of correct model strings or a single correct model string.",
            {
                "This error could happens when the model does not exist on the server.",
                "Are you sure the model path is right?",
                "Is the model from an addon that is not properly installed?"
            }
        ),

    description =
        tc.addHint(
            isstring,
            "The description must be a string."
        ),

    weapons =
        tc.addHint(
            tc.optional(tc.tableOf(isstring)),
            "The weapons must be a valid table of strings.",
            {"Example: weapons = {\"med_kit\", \"weapon_bugbait\"},"}
        ),

    command =
        fn.FAnd
        {
            tc.addHint(
                isstring,
                "The command must be a string."
            ),
            uniqueJob
        },

    max =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}},
            "The max must be a number greater than or equal to zero.",
            {
                "Zero means infinite.",
                "A decimal between 0 and 1 is seen as a percentage."
            }
        ),

    salary =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}},
            "The salary must be a number and it must be greater than zero."
        ),

    admin =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}, fp{fn.Gte, 2}},
            "The admin value must be a number and it must be greater than or equal to zero and smaller than three."
        ),

    vote =
        tc.addHint(
            tc.optional(isbool),
            "The vote must be either true or false."
        ),

    ammo =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber)),
            "The ammo must be a table containing numbers.",
            {"See example on http://wiki.darkrp.com/index.php/DarkRP:CustomJobFields"}
        ),

    hasLicense =
        tc.addHint(
            tc.optional(isbool),
            "The hasLicense must be either true or false."
        ),

    NeedToChangeFrom =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber), isnumber),
            "The NeedToChangeFrom must be either an existing team or a table of existing teams",
            {"Is there a job here that doesn't exist (anymore)?"}
        ),

    modelScale =
        tc.addHint(
            tc.optional(isnumber),
            "The modelScale must be a number."
        ),

    maxpocket =
        tc.addHint(
            tc.optional(isnumber),
            "The maxPocket must be a number."
        ),

    maps =
        tc.addHint(
            tc.optional(tc.tableOf(isstring)),
            "The maps value must be a table of valid map names."
        ),

    candemote =
        tc.default(true,
            tc.addHint(
                isbool,
                "The candemote value must be either true or false."
            )
        ),

    mayor =
        tc.addHint(
            tc.optional(isbool),
            "The mayor value must be either true or false."
        ),

    chief =
        tc.addHint(
            tc.optional(isbool),
            "The chief value must be either true or false."
        ),

    medic =
        tc.addHint(
            tc.optional(isbool),
            "The medic value must be either true or false."
        ),

    cook =
        tc.addHint(
            tc.optional(isbool),
            "The cook value must be either true or false."
        ),

    hobo =
        tc.addHint(
            tc.optional(isbool),
            "The hobo value must be either true or false."
        ),

    playerClass =
        tc.addHint(
            tc.optional(isstring),
            "The playerClass must be a valid string."
        ),

    CanPlayerSuicide =
        tc.addHint(
            tc.optional(isfunction),
            "The CanPlayerSuicide must be a function."
        ),

    PlayerCanPickupWeapon =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerCanPickupWeapon must be a function."
        ),

    PlayerDeath =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerDeath must be a function."
        ),

    PlayerLoadout =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerLoadout must be a function."
        ),

    PlayerSelectSpawn =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSelectSpawn must be a function."
        ),

    PlayerSetModel =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSetModel must be a function."
        ),

    PlayerSpawn =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSpawn must be a function."
        ),

    PlayerSpawnProp =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSpawnProp must be a function."
        ),

    RequiresVote =
        tc.addHint(
            tc.optional(isfunction),
            "The RequiresVote must be a function."
        ),

    ShowSpare1 =
        tc.addHint(
            tc.optional(isfunction),
            "The ShowSpare1 must be a function."
        ),

    ShowSpare2 =
        tc.addHint(
            tc.optional(isfunction),
            "The ShowSpare2 must be a function."
        ),

    canStartVote =
        tc.addHint(
            tc.optional(isfunction),
            "The canStartVote must be a function."
        ),

    canStartVoteReason =
        tc.addHint(
            tc.optional(isstring, isfunction),
            "The canStartVoteReason must be either a string or a function."
        ),
}}

--[[
Validate shipments
]]
DarkRP.validateShipment = fn.FAnd{buyableSchema, tc.checkTable{
    entity =
        tc.addHint(
            isstring, "The entity of the shipment must be a string."
        ),

    amount =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}}, "The amount must be a number and it must be greater than zero."
        ),

    separate =
        tc.addHint(
            tc.optional(isbool), "the separate field must be either true or false."
        ),

    pricesep =
        tc.addHint(
            function(v, tbl) return not tbl.separate or isnumber(v) and v >= 0 end,
            "The pricesep must be a number and it must be greater than or equal to zero."
        ),

    noship =
        tc.addHint(
            tc.optional(isbool),
            "The noship must be either true or false."
        ),

    shipmodel =
        tc.addHint(
            tc.optional(isstring),
            "The shipmodel must be a valid model."
        ),

    weight =
        tc.addHint(
            tc.optional(isnumber),
            "The weight must be a number."
        ),

    spareammo =
        tc.addHint(
            tc.optional(isnumber),
            "The spareammo must be a number."
        ),

    clip1 =
        tc.addHint(
            tc.optional(isnumber),
            "The clip1 must be a number."
        ),

    clip2 =
        tc.addHint(
            tc.optional(isnumber),
            "The clip2 must be a number."
        ),

    shipmentClass =
        tc.addHint(
            tc.optional(isstring),
            "The shipmentClass must be a string."
        ),

    onBought =
        tc.addHint(
            tc.optional(isfunction),
            "The onBought must be a function."
        ),

}}

--[[
Validate vehicles
]]
DarkRP.validateVehicle = fn.FAnd{buyableSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name of the vehicle must be a string."
        ),

    distance =
        tc.addHint(
            tc.optional(isnumber),
            "The distance must be a number."
        ),

    angle =
        tc.addHint(
            tc.optional(isangle),
            "The distance must be a valid Angle."
        ),
}}

--[[
Validate Entities
]]
DarkRP.validateEntity = fn.FAnd{buyableSchema, tc.checkTable{
    ent =
        tc.addHint(
            isstring,
            "The name of the entity must be a string."
        ),

    max =
        tc.addHint(
            function(v, tbl) return isnumber(v) or isfunction(tbl.getMax) end,
            "The max must be an existing number or (for advanced users) the getMax field must be a function."
        ),

    cmd =
        fn.FAnd
        {
            tc.addHint(isstring, "The cmd must be a valid string."),
            uniqueEntity
        },

    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),
}}


-- Checks whether a team already has an agenda assigned.
-- Jobs cannot have multiple agendas.

local overlappingAgendaCheck = function(t, tbl)
    local agenda = DarkRP.getAgendas()[t]

    -- Team being -1 means the job is disabled
    if agenda == nil or t == -1 then return true end

    local teamName = team.GetName(t)
    local err = "At least one job has multiple agendas assigned to them"
    local hints = {
        string.format([[The problem lies with the job called "%s"]], teamName),
        string.format([[It is assigned to agendas "%s" and "%s"]], agenda.Title or "unknown", tbl.Title or "unknown"),
        [[A job can only have ONE agenda. Otherwise things would become confusing, since only ONE agenda is always drawn on the screen.]]
    }

    if agenda.Title == tbl.Title then
        table.insert(hints, "The titles of the two agendas are the same. It looks like perhaps you've made the same agenda more than once.")
        table.insert(hints, "Removing one of them should get rid of this error.")
    end

    return false, err, hints
end

--[[
Validate Agendas
]]
local managerNumberCheck = tc.addHint(
    isnumber,
    "The Manager must either be a single team or a non-empty table of existing teams.",
    {"Is there a job here that doesn't exist (anymore)?"}
)

DarkRP.validateAgenda = tc.checkTable{
    Title =
        tc.addHint(
            isstring,
            "The title must be a string."
        ),

    -- Custom function to ensure the right error message is thrown
    Manager = function(manager, tbl)
            -- Check whether the manager is an existing team
            -- that does not already have an agenda assigned
            if isnumber(manager) then
                return fn.FAnd{overlappingAgendaCheck}(manager, tbl)

            -- Check whether the manager is a table of existing teams
            -- and that none of the teams already have agendas assigned
            elseif istable(manager) then
                return tc.nonEmpty(
                    tc.tableOf(
                        fn.FAnd{managerNumberCheck, overlappingAgendaCheck}
                    )
                )(manager, tbl)
            end

            return managerNumberCheck(manager, tbl)
        end,
    Listeners =
        tc.default({}, -- Default to empty table
            fn.FAnd{ -- Checks for a table of valid teams that do not already have an agenda assigned
                tc.addHint(
                    tc.tableOf(isnumber),
                    "The Listeners must be a table of existing teams.",
                    {
                        "Is there a job here that doesn't exist (anymore)?",
                        "Are you trying to have multiple manager jobs in this agenda? In that case you must put the list of manager jobs in curly braces.",
                        [[Like so: DarkRP.createAgenda("Some agenda", {TEAM_MANAGER1, TEAM_MANAGER2}, {TEAM_LISTENER1, TEAM_LISTENER2})]]
                    }
                ),
                tc.tableOf(overlappingAgendaCheck)
            }
        )
}

--[[
Validate Categories
]]
DarkRP.validateCategory = tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a string."
        ),

    categorises =
        tc.addHint(
            tc.oneOf{"jobs", "entities", "shipments", "weapons", "vehicles", "ammo"},
            [[The categorises must be one of "jobs", "entities", "shipments", "weapons", "vehicles", "ammo"]],
            {
                "Mind that this is case sensitive.",
                "Also mind the quotation marks."
            }
        ),

    startExpanded =
        tc.addHint(
            isbool,
            "The startExpanded must be either true or false."
        ),

    color =
        tc.addHint(
            tc.tableOf(isnumber),
            "The color must be a Color value."
        ),

    canSee =
        tc.addHint(
            tc.optional(isfunction),
            "The canSee must be a function."
        ),

    sortOrder =
        tc.addHint(
            tc.optional(isnumber),
            "The sortOrder must be a number."
        ),
}

--gamemodes/darkrp/gamemode/modules/base/cl_gamemode_functions.lua:
DEFINE_BASECLASS("gamemode_base")

local GUIToggled = false
local mouseX, mouseY = ScrW() / 2, ScrH() / 2

function GM:ShowSpare1()
    local jobTable = LocalPlayer():getJobTable()

    if jobTable.ShowSpare1 then
        return jobTable.ShowSpare1(LocalPlayer())
    end

    GUIToggled = not GUIToggled

    if GUIToggled then
        gui.SetMousePos(mouseX, mouseY)
    else
        mouseX, mouseY = gui.MousePos()
    end
    gui.EnableScreenClicker(GUIToggled)
end

function GM:ShowSpare2()
    local jobTable = LocalPlayer():getJobTable()

    if jobTable.ShowSpare2 then
        return jobTable.ShowSpare2(LocalPlayer())
    end

    DarkRP.toggleF4Menu()
end

function GM:PlayerStartVoice(ply)
    if ply == LocalPlayer() then
        ply.DRPIsTalking = true
        return -- Not the original rectangle for yourself! ugh!
    end
    
    BaseClass.PlayerStartVoice(self, ply)
end

function GM:PlayerEndVoice(ply)
    if ply == LocalPlayer() then
        ply.DRPIsTalking = false
        return
    end

    BaseClass.PlayerEndVoice(self, ply)
end

function GM:OnPlayerChat()
end

function GM:CanTool( ply, trace, mode, tool, button )
    return true
end


local FKeyBinds = {
    ["gm_showhelp"] = "ShowHelp",
    ["gm_showteam"] = "ShowTeam",
    ["gm_showspare1"] = "ShowSpare1",
    ["gm_showspare2"] = "ShowSpare2"
}

function GM:PlayerBindPress(ply, bind, pressed)
    --BaseClass.PlayerBindPress(self, ply, bind, pressed)

    local bnd = string.match(string.lower(bind), "gm_[a-z]+[12]?")
    if bnd and FKeyBinds[bnd] then
        hook.Call(FKeyBinds[bnd], GAMEMODE)
    end

    if not self.Config.deadvoice and not ply:Alive() and string.find(string.lower(bind), "voicerecord") then return true end
end

function GM:InitPostEntity()
    hook.Call("teamChanged", GAMEMODE, GAMEMODE.DefaultTeam, GAMEMODE.DefaultTeam)
end

function GM:teamChanged(before, after)
end

local function OnChangedTeam(um)
    local oldTeam, newTeam = net.ReadUInt(16), net.ReadUInt(16)
    hook.Call("teamChanged", GAMEMODE, oldTeam, newTeam) -- backwards compatibility
    hook.Call("OnPlayerChangedTeam", GAMEMODE, LocalPlayer(), oldTeam, newTeam)
end
net.Receive("OnChangedTeam", OnChangedTeam)

timer.Simple(0, function() GAMEMODE.ShowTeam = DarkRP.openKeysMenu end)

timer.Simple(0.5, function() 
    local GM = GAMEMODE
    GM.PrePlayerDraw = nil
    GM.PostPlayerDraw = nil
    GM.HUDPaint = nil
    GM.FinishMove = nil
    GM.Move = nil
end)

--gamemodes/darkrp/gamemode/modules/base/cl_fonts.lua:
--[[---------------------------------------------------------------------------
The fonts that DarkRP uses
---------------------------------------------------------------------------]]
local function loadFonts()
    local tahoma = system.IsLinux() and "DejaVu Sans" or "Tahoma"
    local tahomaSize = system.IsLinux() and fp{fn.Flip(fn.Add), 1} or fn.Id

    surface.CreateFont("DarkRPHUD1", {
        size = tahomaSize(16),
        weight = 600,
        antialias = true,
        shadow = true,
        font = tahoma})

    surface.CreateFont("DarkRPHUD2", {
        size = 25,
        weight = 400,
        antialias = true,
        shadow = false,
        font = tahoma})
    
    surface.CreateFont("Trebuchet18", {
        size = 18,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS"})

    surface.CreateFont("Trebuchet20", {
        size = 20,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS"})

    surface.CreateFont("Trebuchet24", {
        size = 24,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS"})

    surface.CreateFont("Trebuchet48", {
        size = 48,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS"})

    surface.CreateFont("UiBold", {
        size = 16,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Default"})

    surface.CreateFont("HUDNumber5", {
        size = 30,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Default"})

    surface.CreateFont("ScoreboardHeader", {
        size = 32,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("ScoreboardSubtitle", {
        size = 22,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("ScoreboardPlayerName", {
        size = 19,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("ScoreboardPlayerName2", {
        size = 15,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("ScoreboardPlayerNameBig", {
        size = 22,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("AckBarWriting", {
        size = 20,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Akbar"})
end
loadFonts()
-- Load twice because apparently once is not enough
hook.Add("InitPostEntity", "DarkRP_LoadFonts", loadFonts)

--gamemodes/darkrp/gamemode/modules/animations/sh_animations.lua:
hook.Add("KeyPress", "darkrp_animations", function(ply, key)
    local Team = ply:Team()

    if Team ~= TEAM_HOBO then return end
    if key ~= IN_ATTACK then return end

    local weapon = ply:GetActiveWeapon()

    if weapon:IsValid() then
        local class = weapon:GetClass()

        if class == "weapon_bugbait" then
            ply:DoAnimationEvent(ACT_GMOD_GESTURE_ITEM_THROW)
        end
    end
end)

local function KeysAnims(um)
    local ply = net.ReadEntity()
    local act = net.ReadString()
    
    if not IsValid(ply) then return end
    
    ply:AnimRestartGesture(GESTURE_SLOT_CUSTOM, act == "usekeys" and ACT_GMOD_GESTURE_ITEM_PLACE or ACT_HL2MP_GESTURE_RANGE_ATTACK_FIST, true)
end
net.Receive("anim_keys", KeysAnims)
--addons/module_wayban/lua/darkrp_modules/wayban_perma/sh_shared.lua:
FAdmin.Messages.RegisterNotification({
    name = "wayban_ban",
    hasTarget = false,
    message = {"instigator", " выдал перманентный бан ", "extraInfo.1", " (", "extraInfo.2", ')'},
    receivers = "everyone",
    writeExtraInfo = function(info)
        local Data = {}
        Data.steamid = info[1]
        Data.reason = info[2]
        net.WriteString(Data.steamid)
        net.WriteString(Data.reason)
    end,
    readExtraInfo = function()
        return {net.ReadString(), net.ReadString()}
    end,
    extraInfoColors = {Color(160, 171, 189), Color(160, 171, 189)}
})

FAdmin.Messages.RegisterNotification({
    name = "wayban_unban",
    hasTarget = false,
    message = {"instigator", " снял перманентный бан с ", "extraInfo.1"},
    receivers = "everyone",
    writeExtraInfo = function(info)
        local Data = {}
        Data.steamid = info[1]
        net.WriteString(Data.steamid)
    end,
    readExtraInfo = function()
        return {net.ReadString(), net.ReadString()}
    end,
    extraInfoColors = {Color(160, 171, 189), Color(160, 171, 189)}
})
--addons/module_policeradio/lua/darkrp_modules/dradio/cl_init.lua:
local bindVar = CreateClientConVar('dradio_bind_key', 17, true, false)

dRadio.sounds = {
    on = {
        'npc/combine_soldier/vo/on1.wav',
        'npc/combine_soldier/vo/on2.wav',
    },

    off = {
        'npc/combine_soldier/vo/off1.wav',
        'npc/combine_soldier/vo/off2.wav',
    }
}

dRadio.radioAnim = {
    crouching = {
		Bip01_L_Hand = { ang = Angle(6, -30, -20) },
		Bip01_L_Forearm = { ang = Angle(0, 15, -40) },
		Bip01_L_Clavicle = { ang = Angle(5, 20, 0)},
		Bip01_L_UpperArm = { ang = Angle(30, -65, -5) },

		Bip01_L_Finger0 = { ang = Angle(-30, 0, 0) },
		Bip01_L_Finger02 = { ang = Angle(0, -15, 0) },
		Bip01_L_Finger1 = { ang = Angle(17, 23, 0) },
		Bip01_L_Finger12 = { ang = Angle(-10, 25, 0) },
		Bip01_L_Finger2 = { ang = Angle(15, 20, -10) },
		Bip01_L_Finger22 = { ang = Angle(0, 80, 30) },

		Bip01_Head1 = { ang = Angle(0,-10,0) },
	},

    normal = {
        Bip01_L_Hand = { ang = Angle(0, 0, -30) },
        Bip01_L_Forearm = { ang = Angle(-5, -90, -8) },
        Bip01_L_Clavicle = { ang = Angle(0, 0, 0) },
        Bip01_L_UpperArm = { ang = Angle(-20, -40, 0) },
    
        Bip01_L_Finger0 = { ang = Angle(0, 0, 0) },
        Bip01_L_Finger02 = { ang = Angle(0, 0, 0) },
        Bip01_L_Finger1 = { ang = Angle(8, 55, 0) },
        Bip01_L_Finger12 = { ang = Angle(-8, 1, 0) },
        Bip01_L_Finger2 = { ang = Angle(0, 49, 0) },
        Bip01_L_Finger21 = { ang = Angle(0, -15, 0) },
        Bip01_L_Finger22 = { ang = Angle(0, -5, -15) },
    
        Bip01_Head1 = { ang = Angle(0,-10,0) },
    },

    crouching_passive = {
        Bip01_L_Hand = { ang = Angle(0, 0, 80) },
		Bip01_L_Forearm = { ang = Angle(-5, -65, -8) },
		Bip01_L_Clavicle = { ang = Angle(0, 0, 0) },
		Bip01_L_UpperArm = { ang = Angle(0, 0, 0) },

		Bip01_L_Finger0 = { ang = Angle(0, 0, 0) },
		Bip01_L_Finger02 = { ang = Angle(0, 0, 0) },
		Bip01_L_Finger1 = { ang = Angle(8, 65, 0) },
		Bip01_L_Finger12 = { ang = Angle(-8, 1, 0) },
		Bip01_L_Finger2 = { ang = Angle(0, 49, 0) },
		Bip01_L_Finger21 = { ang = Angle(0, -15, 0) },
		Bip01_L_Finger22 = { ang = Angle(0, -5, -25) },

		Bip01_Head1 = { ang = Angle(0,-10,0) },
    }
}

hook.Add('PlayerButtonDown', 'dRadio_startVoice', function (ply, btn)
    if btn == bindVar:GetInt() and ply:hasRadio() and ply:radioEnabled() then
        RunConsoleCommand('+dradio')
        if permissions.EnableVoiceChat then 
            permissions.EnableVoiceChat(true) 
        else 
            RunConsoleCommand ('+voicerecord') 
        end
        surface.PlaySound(dRadio.sounds.on[math.random(1, #dRadio.sounds.on)])
    end
end)

hook.Add('PlayerButtonUp', 'dRadio_endVoice', function (ply, btn)
    if btn == bindVar:GetInt() and ply:hasRadio() and ply:radioEnabled() then
        RunConsoleCommand('-dradio')
        if permissions.EnableVoiceChat then 
            permissions.EnableVoiceChat(false) 
        else 
            RunConsoleCommand ('-voicerecord') 
        end
        surface.PlaySound(dRadio.sounds.off[math.random(1, #dRadio.sounds.off)])
    end
end)
--[[ 
function dRadio.getCurrentAnim(ply)
    local car = ply:GetVehicle()
	local weapon = ply:GetActiveWeapon()

    local fuckedHoldTypes = {
        [''] = true, -- В PTP у некоторых стволов такой холдтайп
        physgun = true,
        melee = true,
        fist = true,
        knife = true,
        melee2 = true,
        duel = true,
        camera = true,
    }

    if IsValid(car) then
        return false
    elseif IsValid(weapon) and fuckedHoldTypes[weapon:GetHoldType()] then
        return false
    elseif IsValid(weapon) and weapon:GetHoldType() == 'passive' then
        return ply:Crouching() and dRadio.radioAnim.crouching_passive or dRadio.radioAnim.normal
    elseif ply:Crouching() then
        return dRadio.radioAnim.crouching
    else
        return dRadio.radioAnim.normal
    end
end
local dist = 250000

hook.Add('UpdateAnimation', 'dRadio', function (ply, vel)
    if not IsValid(ply) then return end
    if ply:GetPos():DistToSqr( LocalPlayer():GetPos() ) > dist then return end
	if ply:GetModel() == 'models/error.mdl' then return end
	if ply:InVehicle() then return end
    
    if ply:hasRadio() and ply:radioEnabled() then

        ply.radioAnimWeight = math.Approach(
            ply.radioAnimWeight or 0,
            (ply:isTalkingToRadio() and ply:OnGround()) and (1 - vel:LengthSqr() / 50000) or 0,
            FrameTime() * 5
        )

        local weight = ply.radioAnimWeight or 0

        local anim = dRadio.getCurrentAnim(ply)

        for bone, data in pairs(anim or {}) do
            local id = ply:LookupBone('ValveBiped.' .. bone)
            if not id then continue end

            if data.pos then ply:ManipulateBonePosition(id, weight > 0 and (data.pos * weight) or Vector()) end
            if data.ang then ply:ManipulateBoneAngles(id, weight > 0 and (data.ang * weight) or Angle()) end
        end
    end
end)

local radioModel = ClientsideModel('models/alyx_emptool_prop.mdl') --('models/radio/w_radio.mdl')
radioModel:SetNoDraw(true)

hook.Add('PostPlayerDraw', 'dRadio', function(ply)
    if not IsValid(ply) or not ply:Alive() then return end
    if not ply:hasRadio() or not ply:radioEnabled() or not ply:isTalkingToRadio() then return end

	local attach_id = ply:LookupAttachment('anim_attachment_LH')
	if not attach_id then return end
			
	local attach = ply:GetAttachment(attach_id)
			
	if not attach then return end
			
	local pos = attach.Pos
    local ang = attach.Ang + Angle(-220, 50, 0)
	--local ang = attach.Ang + Angle(-30, 40, 0)
		
    radioModel:SetModelScale(1.5)
		
	radioModel:SetPos(pos)
	radioModel:SetAngles(ang)

	radioModel:SetRenderOrigin(pos)
	radioModel:SetRenderAngles(ang)
	radioModel:SetupBones()
	radioModel:DrawModel()
	radioModel:SetRenderOrigin()
	radioModel:SetRenderAngles()
end)
--]] 
hook.Add('InitPostEntity', 'dRadio.createMainPanel', function()
	if IsValid(dRadio.mainPanel) then dRadio.mainPanel:Remove() end

	dRadio.mainPanel = vgui.Create('DPanel')
	dRadio.mainPanel:ParentToHUD()
	dRadio.mainPanel:SetPos(25, 120)
	dRadio.mainPanel:SetSize(250, ScrH() - 300)
	dRadio.mainPanel:SetPaintBackground(false)
end)

dRadio.voicePanels = {}

local function removeVoice(ply)
	local pnl = dRadio.voicePanels[ply]
	if not IsValid(pnl) or pnl.fadeAnim then return end

	pnl.fadeAnim = Derma_Anim('FadeOut', pnl, pnl.FadeOut)
	pnl.fadeAnim:Start(2)
end

timer.Create('VoiceClean', 10, 0, function()
    for ply, _ in pairs(dRadio.voicePanels) do
		if not IsValid(ply) then removeVoice(ply) end
	end
end)

hook.Add('PlayerStartVoice', 'dRadio', function(ply)
    if ply == LocalPlayer() then return end
    local lpEnabled, lpChannel = LocalPlayer():radioEnabled()
    local plEnabled, plChannel = ply:radioEnabled()
    if not LocalPlayer():hasRadio() or not lpEnabled then return end
    if not ply:hasRadio() or not plEnabled or not ply:isTalkingToRadio() then return end
    if lpChannel ~= plChannel then return end

    local root = dRadio.mainPanel
    if not IsValid(root) then return end

    removeVoice(ply)

    local plyPnl = dRadio.voicePanels[ply]
    if IsValid(plyPnl) then
        if plyPnl.fadeAnim then
            plyPnl.fadeAnim:Stop()
            plyPnl.fadeAnim = nil
        end
        plyPnl:SetAlpha(255)
        return true
    end

    if not IsValid(ply) then return end

    local newPanel = root:Add('dradio_notify')
    newPanel:SetPlayer(ply)
    newPanel:Dock(TOP)

    dRadio.voicePanels[ply] = newPanel

    surface.PlaySound(dRadio.sounds.on[math.random(1, #dRadio.sounds.on)])
    return true
end)

hook.Add('PlayerEndVoice', 'dRadio', function(ply)
    local vp = dRadio.voicePanels[ply]
    if not vp or not IsValid(vp) then return end

    removeVoice(ply)
    surface.PlaySound(dRadio.sounds.off[math.random(1, #dRadio.sounds.off)])
end)
--lua/weapons/banvac.lua:
local SWEP = {}
SWEP.Primary = {}
SWEP.Secondary = {}
if CLIENT then
    SWEP.PrintName = "VAC Ban"
    SWEP.Slot = 1
    SWEP.SlotPos = 3
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

SWEP.Author = ""
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IconLetter = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "stunstick"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Запрещено"

SWEP.NextStrike = 0

SWEP.ViewModel = Model("models/weapons/v_stunbaton.mdl")
SWEP.WorldModel = Model("models/weapons/w_stunbaton.mdl")

SWEP.Sound = Sound("weapons/stunstick/stunstick_swing1.wav")

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

if SERVER then
    util.AddNetworkString("fun_vac")
end

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:Deploy()
    if SERVER then
        self:SetColor(Color(255,128,0,255))
        self:SetMaterial("models/shiny")
        local vm = self.Owner:GetViewModel()
        if not IsValid(vm) then return end
        vm:ResetSequence(vm:LookupSequence("idle01"))
    end
    return true
end

function SWEP:PreDrawViewModel()
    if SERVER or not IsValid(self.Owner) or not IsValid(self.Owner:GetViewModel()) then return end
    self.Owner:GetViewModel():SetColor(Color(255,128,0,255))
    self.Owner:GetViewModel():SetMaterial("models/shiny")
end

function SWEP:Holster()
    if SERVER then
        self:SetColor(Color(255,255,255,255))
        self:SetMaterial("")
        timer.Stop(self:GetClass() .. "_idle" .. self:EntIndex())
    elseif CLIENT and IsValid(self.Owner) and IsValid(self.Owner:GetViewModel()) then
        self.Owner:GetViewModel():SetColor(Color(255,255,255,255))
        self.Owner:GetViewModel():SetMaterial("")
    end
    return true
end

function SWEP:OnRemove()
    if SERVER then
        self:SetColor(Color(255,255,255,255))
        self:SetMaterial("")
        timer.Stop(self:GetClass() .. "_idle" .. self:EntIndex())
    elseif CLIENT and IsValid(self.Owner) and IsValid(self.Owner:GetViewModel()) then
        self.Owner:GetViewModel():SetColor(Color(255,255,255,255))
        self.Owner:GetViewModel():SetMaterial("")
    end
end

function SWEP:PrimaryAttack()
    self:SetHoldType("melee")
    timer.Simple(0.3, function() if self:IsValid() then self:SetHoldType("normal") end end)

    if CLIENT then return end

    if CurTime() < self.NextStrike then
        DarkRP.notify(self.Owner, 0, 4, "Палка перезарядится через " .. math.Round(self.NextStrike - CurTime()) .. " секунд")
        return
    end

    self.NextStrike = CurTime() + 30 -- Actual delay is set later

    timer.Stop(self:GetClass() .. "_idle" .. self:EntIndex())
    local vm = self.Owner:GetViewModel()
    if IsValid(vm) then
        vm:ResetSequence(vm:LookupSequence("idle01"))
        timer.Simple(0, function()
            if not IsValid(self) or not IsValid(self.Owner) or not IsValid(self.Owner:GetActiveWeapon()) or self.Owner:GetActiveWeapon() ~= self then return end
            self.Owner:SetAnimation(PLAYER_ATTACK1)

            if IsValid(self.Weapon) then
                self.Weapon:EmitSound(self.Sound)
            end

            local vm = self.Owner:GetViewModel()
            if not IsValid(vm) then return end
            vm:ResetSequence(vm:LookupSequence("attackch"))
            vm:SetPlaybackRate(1 + 1/3)
            local duration = vm:SequenceDuration() / vm:GetPlaybackRate()
            timer.Create(self:GetClass() .. "_idle" .. self:EntIndex(), duration, 1, function()
                if not IsValid(self) or not IsValid(self.Owner) then return end
                local vm = self.Owner:GetViewModel()
                if not IsValid(vm) then return end
                vm:ResetSequence(vm:LookupSequence("idle01"))
            end)
        end)
    end

    local ent = self.Owner:getEyeSightHitEntity()
    if not ent then return end

    self.NextStrike = CurTime() + 30

    net.Start("fun_vac")
    net.Send(ent)

    DarkRP.notify(self.Owner, 0, 8, ent:Name() .. " получил VAC")
    DarkRP.notify(self.Owner, 0, 8, "Палка перезарядится через 30 секунд")
end

function SWEP:SecondaryAttack()
    if CLIENT then return end
    net.Start("fun_vac")
    net.Send(self.Owner)
end

function SWEP:DrawHUD()
    draw.SimpleText("ПКМ - попробовать на себе", "TargetID", ScrW() / 2, ScrH() - 40, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    draw.SimpleText("ЛКМ - забанить неудачника через VAC (охлаждение 30 секунд)", "TargetID", ScrW() / 2, ScrH() - 20, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
end

if CLIENT then
    net.Receive("fun_vac", function()
        if IsValid(VACBg) then
            VACBg:Remove()
        end

        if IsValid(VACPanel) then
            VACPanel:Remove()
        end

        timer.Simple(30, function()
            if IsValid(VACBg) then
                VACBg:Remove()
            end

            if IsValid(VACPanel) then
                VACPanel:Remove()
            end
        end)

        VACBg = vgui.Create("HTML")
        VACBg:SetSize(ScrW(), ScrH())
        VACBg:OpenURL[[asset://garrysmod/html/loading.html]]
        VACBg:MakePopup()
        VACBg:SetMouseInputEnabled(false)

        gui.HideGameUI()

        local frame = vgui.Create("DPanel")
        VACPanel = frame
        frame:SetSize(400, 180)
        frame:Center()
        frame:MakePopup()

        frame.Paint = function(self, w, h)
            surface.SetDrawColor(Color(108, 111, 114, 250))
            surface.DrawRect(0, 0, w, h)
            surface.SetDrawColor(Color(40, 40, 40, 255))
            surface.DrawOutlinedRect(0, 0, w, h)
        end

        frame:SetKeyBoardInputEnabled(true)
        frame.OnKeyCodePressed = function(key)
            gui.HideGameUI()
            return false
        end

        frame.Think = function()
            gui.HideGameUI()
        end

        local cancel = frame:Add("DButton")
        cancel:SetText("#GameUI_Close")
        cancel:SetPos(300, 136)
        cancel:SetSize(72, 24)
        cancel:SetCursor("arrow")
        cancel.Paint = function(self, w, h)
            surface.SetDrawColor(Color(227, 227, 227, 255))
            surface.DrawRect(0, 0, w, h)
            surface.SetDrawColor(Color(40, 40, 40, 255))
            surface.DrawOutlinedRect(0, 0, w, h)
        end

        local counter = 1
        cancel.DoClick = function()
            counter = counter + 1
            if counter > 4 then
                if IsValid(VACBg) then
                    VACBg:Remove()
                end

                if IsValid(VACPanel) then
                    VACPanel:Remove()
                end
            end
        end

        local infolbl = frame:Add("DLabel")
        infolbl:SetWrap(true)
        infolbl:SetPos(80, 24)
        infolbl:SetSize(300, 120)
        infolbl:SetText("#VAC_ConnectionRefusedDetail")

        local ttl = vgui.Create("DLabel", frame)
        ttl:SetPos(10, 10)
        ttl:SetText("#VAC_ConnectionRefusedTitle")
        ttl:SizeToContents()

        local img = frame:Add("DImage")
        img:SetPos(30, 42)
        img:SetSize(64, 64)
        img:SetImage("vgui/resource/icon_vac")
    end)
end
weapons.Register(SWEP,"vacban")
--addons/ent_bitcoinpc/lua/weapons/bit_usb/shared.lua:
SWEP.Author				 = "Mikael #"
SWEP.Spawnable			 = true
SWEP.AdminSpawnable		 = false
SWEP.PrintName			 = "Bitcoin USB"
SWEP.Category            = "Запрещено"
SWEP.ViewModel			 = "models/customhq/usb_v.mdl"
SWEP.WorldModel			 = "models/customhq/usb_w.mdl"
SWEP.UseHands 		     = true
SWEP.HoldType 			 = "melee2"
SWEP.DrawAmmo 			 = false
SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Ammo 		 = "none"
SWEP.Primary.AmmoType    = "none"
SWEP.Secondary.Ammo      = "none"
SWEP.DrawCrosshair       = true
SWEP.UseHands 			 = true
SWEP.ViewModelFOV 		 = 53

SWEP.Offset = {
	Pos = {
		Up = -1,
		Right = 0,
		Forward = 1,
	},
	Ang = {
		Up = 350,
		Right = 60,
		Forward = -15,
	}
}
 
function SWEP:DrawWorldModel()
	local hand, offset, rotate
	if !IsValid( self:GetOwner() ) then
		self:DrawModel( )
		return
	end
 
	if !self.Hand then
		self.Hand = self:GetOwner():LookupAttachment( "anim_attachment_rh" )
	end
 
	hand = self:GetOwner():GetAttachment( self.Hand )
 
	if !hand then
		self:DrawModel( )
		return
	end
 
	offset = hand.Ang:Right( ) * self.Offset.Pos.Right + hand.Ang:Forward( ) * self.Offset.Pos.Forward + hand.Ang:Up( ) * self.Offset.Pos.Up
	hand.Ang:RotateAroundAxis( hand.Ang:Right( ), self.Offset.Ang.Right )
	hand.Ang:RotateAroundAxis( hand.Ang:Forward( ), self.Offset.Ang.Forward )
	hand.Ang:RotateAroundAxis( hand.Ang:Up( ), self.Offset.Ang.Up )
	self:SetRenderOrigin( hand.Pos + offset )
	self:SetRenderAngles( hand.Ang )
	self:DrawModel( )
end

function SWEP:PrimaryAttack() 
	if CLIENT then return end
	
	local ply = self:GetOwner()
	local trace = ply:GetEyeTrace()
	local ent = trace.Entity
	local class = ent:GetClass()
	
	if !( ply:GetPos():DistToSqr(ent:GetPos()) <= 40000) then
		return
	end
	
	if class == "bit_case" then
		self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		timer.Simple( 3, function()
			if !IsValid(self) && !IsValid(ent) then return end
			self:SendWeaponAnim(ACT_VM_IDLE)
			if (ent:GetHarddisk() >= 500) then
				if !(ent:GetBitCoin() <= 0) then	
					self.bitcoin = ((self.bitcoin || 0) + ent:GetBitCoin())
					ent:SetGBused(0)
					ent:SetBitCoin(0)	
				end
			end
		end)
	end
end

function SWEP:SecondaryAttack() 
	if ( CLIENT ) || (self.bitcoin == nil) then return end
	local ply = self:GetOwner()
	DarkRP.notify(ply, 0, 5, "На флешке: "..self.bitcoin.." биткоинов")
end

function SWEP:Reload()
  if self.bitcoin == nil or self.bitcoin == 0 then return end
  local ply = self:GetOwner()
  ply:addMoney(self.bitcoin * 50)
  DarkRP.notify(ply, 0, 5, "Биткоины проданы! Ты заработал: "..DarkRP.formatMoney(self.bitcoin * 50))
  self.bitcoin = 0
end
--addons/weapon_knifecsgo/lua/weapons/csgo_butterfly.lua:
if not file.Exists( "weapons/csgo_baseknife.lua", "LUA" ) then
  SWEP.Spawnable = false
  print( "csgo_butterfly failed to initialize: csgo_baseknife.lua not found. Did you install the main part?" )
  return
end

local TTT = ( GAMEMODE_NAME == "terrortown" or cvars.Bool("csgo_knives_force_ttt", false) )

DEFINE_BASECLASS( "csgo_baseknife" )

if ( SERVER ) then
  SWEP.Weight         = 5
  SWEP.AutoSwitchTo   = false
  SWEP.AutoSwitchFrom = false

  if TTT then
    SWEP.EquipMenuData = nil
  end
end

if ( CLIENT ) then
  SWEP.Slot         = TTT and 6 or 2
  SWEP.SlotPos      = 0
end

SWEP.PrintName      = "Нож Бабочка"
SWEP.Category       = "Запрещено"

SWEP.Spawnable      = false
SWEP.AdminSpawnable = true

SWEP.ViewModel      = "models/weapons/v_csgo_butterfly.mdl"
SWEP.WorldModel     = "models/weapons/w_csgo_butterfly.mdl"

SWEP.SkinIndex      = 0
SWEP.PaintMaterial  = nil
SWEP.AreDaggers     = false

util.PrecacheModel( SWEP.ViewModel )
util.PrecacheModel( SWEP.WorldModel )

-- TTT config values

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- The AmmoEnt is the ammo entity that can be picked up when carrying this gun.
-- SWEP.AmmoEnt = "item_ammo_smg1_ttt"

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = nil

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = true

-- If IsSilent is true, victims will not scream upon death.
SWEP.IsSilent = true

-- If NoSights is true, the weapon won't have ironsights
SWEP.NoSights = true

-- This sets the icon shown for the weapon in the DNA sampler, search window,
-- equipment menu (if buyable), etc.
SWEP.Icon = "vgui/entities/csgo_butterfly.vmt"

--addons/weapon_knifecsgo/lua/weapons/csgo_karambit.lua:
if not file.Exists( "weapons/csgo_baseknife.lua", "LUA" ) then
  SWEP.Spawnable = false
  print( "csgo_karambit failed to initialize: csgo_baseknife.lua not found. Did you install the main part?" )
  return
end

local TTT = ( GAMEMODE_NAME == "terrortown" or cvars.Bool("csgo_knives_force_ttt", false) )

DEFINE_BASECLASS( "csgo_baseknife" )

if ( SERVER ) then
  SWEP.Weight         = 5
  SWEP.AutoSwitchTo   = false
  SWEP.AutoSwitchFrom = false

  if TTT then
    SWEP.EquipMenuData = nil
  end
end

if ( CLIENT ) then
  SWEP.Slot         = TTT and 6 or 2
  SWEP.SlotPos      = 0
end

SWEP.PrintName      = "Нож Karambit"
SWEP.Category       = "Запрещено"

SWEP.Spawnable      = false
SWEP.AdminSpawnable = true

SWEP.ViewModel      = "models/weapons/v_csgo_karambit.mdl"
SWEP.WorldModel     = "models/weapons/w_csgo_karambit.mdl"

SWEP.SkinIndex      = 0
SWEP.PaintMaterial  = nil
SWEP.AreDaggers     = false

util.PrecacheModel( SWEP.ViewModel )
util.PrecacheModel( SWEP.WorldModel )

-- TTT config values

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- The AmmoEnt is the ammo entity that can be picked up when carrying this gun.
-- SWEP.AmmoEnt = "item_ammo_smg1_ttt"

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = nil

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = true

-- If IsSilent is true, victims will not scream upon death.
SWEP.IsSilent = true

-- If NoSights is true, the weapon won't have ironsights
SWEP.NoSights = true

-- This sets the icon shown for the weapon in the DNA sampler, search window,
-- equipment menu (if buyable), etc.
SWEP.Icon = "vgui/entities/csgo_karambit.vmt"

--gamemodes/darkrp/entities/weapons/door_ram/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.PrintName = "Battering Ram"
    SWEP.Slot = 5
    SWEP.SlotPos = 1
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

-- Variables that are used on both client and server
DEFINE_BASECLASS("weapon_cs_base2")

SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click to break open doors/unfreeze props or get people out of their vehicles\nRight click to raise"
SWEP.Controls = {
    {
        key = MOUSE_LEFT,
        desc = "Использовать таран",
        check = function(wep)
            return wep:GetIronsights()
        end,
    },
    {
        key = MOUSE_RIGHT,
        desc = function(wep)
            return wep:GetIronsights() and "Опустить таран" or "Поднять таран"
        end,
    },
}
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPDoorRam = true

SWEP.IconLetter = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/c_rpg.mdl")
SWEP.WorldModel = Model("models/weapons/w_rocket_launcher.mdl")
SWEP.AnimPrefix = "rpg"

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Запрещено"

SWEP.Sound = Sound("physics/wood/wood_box_impact_hard3.wav")

SWEP.Primary.ClipSize = -1      -- Size of a clip
SWEP.Primary.DefaultClip = 0        -- Default number of bullets in a clip
SWEP.Primary.Automatic = false      -- Automatic/Semi Auto
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1        -- Size of a clip
SWEP.Secondary.DefaultClip = 0     -- Default number of bullets in a clip
SWEP.Secondary.Automatic = false     -- Automatic/Semi Auto
SWEP.Secondary.Ammo = ""

--[[---------------------------------------------------------
Name: SWEP:Initialize()
Desc: Called when the weapon is first loaded
---------------------------------------------------------]]
function SWEP:Initialize()
    if CLIENT then self.LastIron = CurTime() end
    self:SetHoldType("normal")
end

function SWEP:Holster()
    self.dt.Ironsights = false

    return true
end

-- Check whether an object of this player can be rammed
local function canRam(ply)
    return IsValid(ply) and (ply.warranted == true or ply:isWanted() or ply:isArrested())
end

-- Ram action when ramming a door
local function ramDoor(ply, trace, ent)
    if ply:EyePos():DistToSqr(trace.HitPos) > 2025 or (not GAMEMODE.Config.canforcedooropen and not ent:DoorIsOwnable()) then return false end

    local allowed = false

    -- if we need a warrant to get in
    if GAMEMODE.Config.doorwarrants and IsValid(ent:DoorGetOwner()) and not ent:DoorOwnedBy(ply) then
        allowed = canRam(ent:DoorGetOwner())
    else
        -- door warrants not needed, allow warrantless entry
        allowed = true
    end

    -- Be able to open the door if any member of the door group is warranted
    --[[
    local teams = ent:DoorGetTeams()
    if GAMEMODE.Config.doorwarrants and teams then
        allowed = false
        for _, v in player.Iterator() do
            if table.HasValue(teams, v:Team()) and canRam(v) then
                allowed = true
                break
            end
        end
    end
    ]]

    if CLIENT then return allowed end

    -- Do we have a warrant for this player?
    if not allowed then
        DarkRP.notify(ply, 1, 5, DarkRP.getPhrase("warrant_required"))

        return false
    end

    ent:DoorLock(false)
    ent:Fire("open", "", .6)
    ent:Fire("setanimation", "open", .6)

    return true
end

-- Ram action when ramming a vehicle
local function ramVehicle(ply, trace, ent)
    if ply:EyePos():DistToSqr(trace.HitPos) > 10000 then return false end

    if CLIENT then return false end -- Ideally this would return true after ent:GetDriver() check

    local driver = ent:GetDriver()
    if not IsValid(driver) or not driver.ExitVehicle then return false end

    driver:ExitVehicle()
    ent:VehicleLock()

    return true
end

-- Ram action when ramming a fading door
local function ramFadingDoor(ply, trace, ent)
    if ply:EyePos():DistToSqr(trace.HitPos) > 10000 then return false end

    local Owner = ent:CPPIGetOwner()

    if CLIENT then return canRam(Owner) end

    if not canRam(Owner) then
        DarkRP.notify(ply, 1, 5, DarkRP.getPhrase("warrant_required"))
        return false
    end

    if not ent.fadeActive then
        ent:fadeActivate()
        timer.Simple(5, function() if IsValid(ent) and ent.fadeActive then ent:fadeDeactivate() end end)
    end

    return true
end

-- Ram action when ramming a frozen prop
local function ramProp(ply, trace, ent)
    if ply:EyePos():DistToSqr(trace.HitPos) > 10000 then return false end
    if ent:GetClass() ~= "prop_physics" then return false end

    local Owner = ent:CPPIGetOwner()

    if CLIENT then return canRam(Owner) end

    if not canRam(Owner) then
        DarkRP.notify(ply, 1, 5, DarkRP.getPhrase(GAMEMODE.Config.copscanunweld and "warrant_required_unweld" or "warrant_required_unfreeze"))
        return false
    end

    if GAMEMODE.Config.copscanunweld then
        constraint.RemoveConstraints(ent, "Weld")
    end

    if GAMEMODE.Config.copscanunfreeze then
        local c = ent:GetColor()
        ent:SetColor(Color(c.r, c.g, c.b, 0))
        ent:SetRenderMode(RENDERMODE_TRANSCOLOR)
        ent:SetNotSolid(true)
        
        timer.Create('ram_'..ent:EntIndex(), 10, 1, function()
            if not IsValid(ent) then return end
            ent:SetColor(Color(c.r, c.g, c.b, 100))

            timer.Create('ram_'..ent:EntIndex(), 200, 1, function()
                if not IsValid(ent) then return end
                ent:SetColor(Color(c.r, c.g, c.b, 255))
                ent:SetRenderMode(RENDERMODE_NORMAL)
                ent:SetNotSolid(false)
            end)
        end)
    end

    return true
end

-- Decides the behaviour of the ram function for the given entity
local function getRamFunction(ply, trace)
    local ent = trace.Entity

    if not IsValid(ent) then return fp{fn.Id, false} end

    local override = hook.Call("canDoorRam", nil, ply, trace, ent)

    return
        override ~= nil     and fp{fn.Id, override}                                 or
        ent:IsDoor()        and fp{ramDoor, ply, trace, ent}                        or
        ent:IsVehicle()     and fp{ramVehicle, ply, trace, ent}                     or
        ent.fadeActivate    and fp{ramFadingDoor, ply, trace, ent}                  or
        ent.onBatteringRamUsed and fp{ent.onBatteringRamUsed, ent, ply, trace, ent} or
        ent:GetPhysicsObject():IsValid() and not ent:GetPhysicsObject():IsMoveable()
                                         and fp{ramProp, ply, trace, ent}           or
        fp{fn.Id, false} -- no ramming was performed
end

--[[---------------------------------------------------------
Name: SWEP:PrimaryAttack()
Desc: +attack1 has been pressed
---------------------------------------------------------]]
function SWEP:PrimaryAttack()
    if not self:GetIronsights() then return end

    self:SetNextPrimaryFire(CurTime() + 2.5)

    self:GetOwner():LagCompensation(true)
    local trace = self:GetOwner():GetEyeTrace()
    self:GetOwner():LagCompensation(false)

    local hasRammed = getRamFunction(self:GetOwner(), trace)()

    if SERVER then
        hook.Call("onDoorRamUsed", GAMEMODE, hasRammed, self:GetOwner(), trace)
    end

    if not hasRammed then return end

    self:SetTotalUsedMagCount(self:GetTotalUsedMagCount() + 1)

    self:GetOwner():SetAnimation(PLAYER_ATTACK1)
    self:GetOwner():EmitSound(self.Sound)
    self:GetOwner():ViewPunch(Angle(-10, math.Round(util.SharedRandom("DarkRP_DoorRam" .. self:EntIndex() .. "_" .. self:GetTotalUsedMagCount(), -5, 5)), 0))
end

function SWEP:SecondaryAttack()
    if CLIENT then self.LastIron = CurTime() end
    self:SetNextSecondaryFire(CurTime() + 0.30)
    self:SetIronsights(not self:GetIronsights())
    if self:GetIronsights() then
        self:SetHoldType("rpg")
    else
        self:SetHoldType("normal")
    end
end

function SWEP:GetViewModelPosition(pos, ang)
    local Mul = 1

    if self.LastIron > CurTime() - 0.25 then
        Mul = math.Clamp((CurTime() - self.LastIron) / 0.25, 0, 1)
    end

    if self:GetIronsights() then
        Mul = 1-Mul
    end

    ang:RotateAroundAxis(ang:Right(), - 15 * Mul)
    return pos,ang
end

DarkRP.hookStub{
    name = "canDoorRam",
    description = "Called when a player attempts to ram something. Use this to override ram behaviour or to disallow ramming.",
    parameters = {
        {
            name = "ply",
            description = "The player using the door ram.",
            type = "Player"
        },
        {
            name = "trace",
            description = "The trace containing information about the hit position and ram entity.",
            type = "table"
        },
        {
            name = "ent",
            description = "Short for the entity that is about to be hit by the door ram.",
            type = "Entity"
        }
    },
    returns = {
        {
            name = "override",
            description = "Return true to override behaviour, false to disallow ramming and nil (or no value) to defer the decision.",
            type = "boolean"
        }
    },
    realm = "Shared"
}

if SERVER then
    DarkRP.hookStub{
        name = "onDoorRamUsed",
        description = "Called when the door ram has been used.",
        parameters = {
            {
                name = "success",
                description = "Whether the door ram has been successful in ramming.",
                type = "boolean"
            },
            {
                name = "ply",
                description = "The player that used the door ram.",
                type = "Player"
            },
            {
                name = "trace",
                description = "The trace containing information about the hit position and ram entity.",
                type = "table"
            }
        },
        returns = {

        }
    }
end
--addons/weapon_shield/lua/weapons/fridge_shield/cl_init.lua:
include('shared.lua')

function SWEP:DrawWorldModel()
	self:SetNoDraw(true) 
end

function SWEP:SetupDataTables()
    self:NetworkVar( "Entity", 0, "Shield" )
end

local icon = Material( "icon72/adhesive_bandage.png" )

function SWEP:DrawHUD()
	local shield = self:GetShield()

	if not IsValid(shield) then return end
	
    draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
	draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*shield:Health(), 20, Color( 233, 133, 110, 255 ) )
	draw.DrawText("Состояние", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )

    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
    surface.SetMaterial( icon ) -- Use our cached material
    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
end
--gamemodes/darkrp/entities/weapons/gmod_camera.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = Model( "models/MaxOfS2D/camera.mdl" )

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"


SWEP.PrintName	= "#GMOD_Camera"

SWEP.Slot		= 5
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true

SWEP.ShootSound = Sound( "NPC_CScanner.TakePhoto" )

if ( SERVER ) then

	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false

	--
	-- A concommand to quickly switch to the camera
	--
	concommand.Add( "gmod_camera", function( player, command, arguments )

		player:SelectWeapon( "gmod_camera" )

	end )

end

--
-- Network/Data Tables
--
function SWEP:SetupDataTables()

	self:NetworkVar( "Float", 0, "Zoom" )
	self:NetworkVar( "Float", 1, "Roll" )

	if ( SERVER ) then
		self:SetZoom( 70 )
		self:SetRoll( 0 )
	end

end

--
-- Initialize Stuff
--
function SWEP:Initialize()

	self:SetHoldType( "camera" )

end

--
-- Reload resets the FOV and Roll
--
function SWEP:Reload()

	local owner = self:GetOwner()

	if ( !owner:KeyDown( IN_ATTACK2 ) ) then self:SetZoom( owner:IsBot() && 75 || owner:GetInfoNum( "fov_desired", 75 ) ) end
	self:SetRoll( 0 )

end

--
-- PrimaryAttack - make a screenshot
--
function SWEP:PrimaryAttack()

	-- If we're multiplayer this can be done totally clientside
	if ( !game.SinglePlayer() && SERVER ) then return end
	if ( CLIENT && !IsFirstTimePredicted() ) then return end

	self:GetOwner():ConCommand( "jpeg" )

end

--
-- SecondaryAttack - Nothing. See Tick for zooming.
--
function SWEP:SecondaryAttack()
end

--
-- Mouse 2 action
--
function SWEP:Tick()

	local owner = self:GetOwner()

	if ( CLIENT && owner != LocalPlayer() ) then return end -- If someone is spectating a player holding this weapon, bail

	local cmd = owner:GetCurrentCommand()

	if ( !cmd:KeyDown( IN_ATTACK2 ) ) then return end -- Not holding Mouse 2, bail

	self:SetZoom( math.Clamp( self:GetZoom() + cmd:GetMouseY() * FrameTime() * 6.6, 0.1, 175 ) ) -- Handles zooming
	self:SetRoll( self:GetRoll() + cmd:GetMouseX() * FrameTime() * 1.65 ) -- Handles rotation

end

--
-- Override players Field Of View
--
function SWEP:TranslateFOV( current_fov )

	return self:GetZoom()

end

--
-- Deploy - Allow lastinv
--
function SWEP:Deploy()

	if CLIENT then
		hook.Add('HUDShouldDraw', 'gmod_camera_hidehud', function()
			return false
		end)
	end

	return true

end

--
-- Set FOV to players desired FOV
--
function SWEP:Equip()

	local owner = self:GetOwner()

	if ( self:GetZoom() == 70 && owner:IsPlayer() && !owner:IsBot() ) then
		self:SetZoom( owner:GetInfoNum( "fov_desired", 75 ) )
	end

end

function SWEP:ShouldDropOnDie() return false end

if ( SERVER ) then return end -- Only clientside lua after this line

SWEP.WepSelectIcon = surface.GetTextureID( "vgui/gmod_camera" )

function SWEP:Holster()
	hook.Remove('HUDShouldDraw', 'gmod_camera_hidehud')
	return true
end

-- Don't draw the weapon info on the weapon selection thing
function SWEP:DrawHUD() end
function SWEP:PrintWeaponInfo( x, y, alpha ) end

function SWEP:FreezeMovement()

	local owner = self:GetOwner()

	-- Don't aim if we're holding the right mouse button
	if ( owner:KeyDown( IN_ATTACK2 ) || owner:KeyReleased( IN_ATTACK2 ) ) then
		return true
	end

	return false

end

function SWEP:CalcView( ply, origin, angles, fov )

	if ( self:GetRoll() != 0 ) then
		angles.Roll = self:GetRoll()
	end

	return origin, angles, fov

end

function SWEP:AdjustMouseSensitivity()

	if ( self:GetOwner():KeyDown( IN_ATTACK2 ) ) then return 1 end

	return self:GetZoom() / 80

end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/editentity.lua:

--
-- This works - but I'm not certain that it's the way to go about it.
-- better instead to use the right click properties?
--

TOOL.AddToMenu = false

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.editentity.name"

function TOOL:LeftClick( trace )

	if ( !trace.Hit ) then return false end

	self:GetWeapon():SetTargetEntity1( trace.Entity )

	return true

end

function TOOL:RightClick( trace )

	return self:LeftClick( trace )

end

function TOOL:Think()

	local CurrentEditing = self:GetWeapon():GetTargetEntity1()

	if ( CLIENT && self.LastEditing != CurrentEditing ) then

		self.LastEditing = CurrentEditing

		local CPanel = controlpanel.Get( "editentity" )
		if ( !CPanel ) then return end

		CPanel:ClearControls()
		self.BuildCPanel( CPanel, CurrentEditing )

	end

end

function TOOL.BuildCPanel( CPanel, ent )

	local control = vgui.Create( "DEntityProperties" )
	control:SetEntity( ent )
	control:SetSize( 10, 500 )

	CPanel:AddPanel( control )

end

--addons/tool_faidingdoor/lua/weapons/gmod_tool/stools/fading_door.lua:
--[[
	STool: Fading Doors
	Version: 2.1.1
	Author: http://www.steamcommunity.com/id/zapk
--]]

--[[
	New in 2.1.0:
	-	Fixed "No Effect" not working.
	-	Cleaned up code.
--]]

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.fading_door.name"

TOOL.ClientConVar["key"] = "5"
TOOL.ClientConVar["toggle"] = "0"
TOOL.ClientConVar["reversed"] = "0"
--TOOL.ClientConVar["noeffect"] = "0"

local function checkTrace(tr)
	-- edgy, yes, but easy to read

	return tr.Entity
		and tr.Entity:IsValid()
		and not (
			tr.Entity:IsPlayer()
			or tr.Entity:IsNPC()
			or tr.Entity:IsVehicle()
			or tr.HitWorld
			or tr.Entity:GetClass() == "sammyservers_textscreen"
		)
end

if CLIENT then
	-- handle languages
	language.Add( "tool.fading_door.name", "Fading Door" )
	language.Add( "tool.fading_door.desc", "Заставляет объект исчезать при активации." )
	language.Add( "tool.fading_door.0", "Нажми на объект чтобы установить на него Fading Door" )
	language.Add( "Undone_fading_door", "Отмена Fading Door" )

	-- handle tool panel
	function TOOL:BuildCPanel()
		self:AddControl( "Header", { Text = "#tool.fading_door.name", Description = "#tool.fading_door.desc" } )
		self:AddControl( "CheckBox", { Label = "Активировать сразу", Command = "fading_door_reversed" } )
		self:AddControl( "CheckBox", { Label = "Режим переключения", Command = "fading_door_toggle" } )
		--self:AddControl( "CheckBox", { Label = "No Effect", Command = "fading_door_noeffect" } )
		self:AddControl( "Numpad", { Label = "Активация", ButtonSize = "22", Command = "fading_door_key" } )
	end

	-- leftclick trace function
	TOOL.LeftClick = checkTrace

	return
end

local function fadeActivate(self)
	self.fadeActive = true

	self.fadeMaterial = self:GetMaterial()
	self.fadeColor = self:GetColor()

	--if self.noEffect then
		self:SetColor(Color(255, 255, 255, 0))
		self:SetMaterial("Models/effects/vol_light001")
	--else
	--	self:SetMaterial("sprites/heatwave")
	--end

	self:DrawShadow(false)
	self:SetNotSolid(true)

	local phys = self:GetPhysicsObject()

	if IsValid(phys) then
		self.fadeMoveable = phys:IsMoveable()
		phys:EnableMotion(false)
	end
end

local function fadeDeactivate(self)
	self.fadeActive = false

	self:SetMaterial(self.fadeMaterial or "")
	self:SetColor(self.fadeColor or color_white)

	self:DrawShadow(true)
	self:SetNotSolid(false)

	local phys = self:GetPhysicsObject()

	if IsValid(phys) then
		phys:EnableMotion(false)
	end
end

local function fadeToggleActive(self, ply)
	if not numpad.FromButton() and ( ply:Team() ~= TEAM_ADMIN and ply:InPVP() ) then
		ply:Notify(1, 5, "Нельзя активировать Fading Door с клавиатуры во время PVP.")
		ply:Notify(1, 5, "Используй кейпад или кнопку для его активации.")
		return
	end

	if self.fadeActive then
		self:fadeDeactivate()
	else
		self:fadeActivate()
	end
end

local function onUp(ply, ent)
	if not (ent:IsValid() and ent.fadeToggleActive and not ent.fadeToggle) then
		return
	end

	ent:fadeToggleActive(ply)
end

numpad.Register("Fading Door onUp", onUp)

local function onDown(ply, ent)
	if not (ent:IsValid() and ent.fadeToggleActive) then
		return
	end

	ent:fadeToggleActive(ply)
end

numpad.Register("Fading Door onDown", onDown)

-- I hate wire.
local function getWireInputs(ent)
	local inputs = ent.Inputs
	local names, types, descs = {}, {}, {}

	if inputs then
		local num
		for _, data in pairs(inputs) do
			num = data.Num
			names[num] = data.Name
			types[num] = data.Type
			descs[num] = data.Desc
		end
	end

	return names, types, descs
end

local function doWireInputs(ent)
	local inputs = ent.Inputs

	if not inputs then
		Wire_CreateInputs(ent, {"Fade"})
		return
	end

	local names, types, descs = {}, {}, {}
	local num

	for _, data in pairs(inputs) do
		num = data.Num
		names[num] = data.Name
		types[num] = data.Type
		descs[num] = data.Desc
	end

	table.insert(names, "Fade")

	WireLib.AdjustSpecialInputs(ent, names, types, descs)
end

local function doWireOutputs(ent)
	local outputs = ent.Outputs

	if not outputs then
		Wire_CreateOutputs(ent, {"FadeActive"})
		return;
	end

	local names, types, descs = {}, {}, {}
	local num

	for _, data in pairs(outputs) do
		num = data.Num
		names[num] = data.Name
		types[num] = data.Type
		descs[num] = data.Desc
	end

	table.insert(names, "FadeActive")

	WireLib.AdjustSpecialOutputs(ent, names, types, descs)
end

local function TriggerInput(self, name, value, ...)
	if name == "Fade" then
		if value == 0 and self.fadePrevWireOn then
			self.fadePrevWireOn = false

			if not self.fadeToggle then
				self:fadeToggleActive()
			end
		else
			if not self.fadePrevWireOn then
				self.fadePrevWireOn = true
				self:fadeToggleActive()
			end
		end
	elseif self.fadeTriggerInput then
		return self:fadeTriggerInput(name, value, ...)
	end
end

local function PreEntityCopy(self)
	local info = WireLib.BuildDupeInfo(self)

	if info then
		duplicator.StoreEntityModifier(self, "WireDupeInfo", info)
	end

	if self.fadePreEntityCopy then
		self:fadePreEntityCopy()
	end
end

local function PostEntityPaste(self, ply, ent, ents)
	if self.EntityMods and self.EntityMods.WireDupeInfo then
		WireLib.ApplyDupeInfo(ply, self, self.EntityMods.WireDupeInfo, function(id) return ents[id] end)
	end

	if self.fadePostEntityPaste then
		self:fadePostEntityPaste(ply, ent, ents)
	end
end


local function onRemove(self)
	numpad.Remove(self.fadeUpNum)
	numpad.Remove(self.fadeDownNum)
end

local function dooEet(ply, ent, stuff)
	if ent.isFadingDoor then
		ent:fadeDeactivate()
		onRemove(ent)
	else
		ent.isFadingDoor = true

		ent.fadeActivate = fadeActivate
		ent.fadeDeactivate = fadeDeactivate
		ent.fadeToggleActive = fadeToggleActive

		ent:CallOnRemove("Fading Door", onRemove)
	end

	ent.fadeUpNum = numpad.OnUp(ply, stuff.key, "Fading Door onUp", ent)
	ent.fadeDownNum = numpad.OnDown(ply, stuff.key, "Fading Door onDown", ent)
	ent.fadeToggle = stuff.toggle
	--ent.noEffect = stuff.noEffect

	if stuff.reversed then
		ent:fadeActivate()
	end

	duplicator.StoreEntityModifier(ent, "Fading Door", stuff)

	return true
end

duplicator.RegisterEntityModifier("Fading Door", dooEet)

if not FadingDoor then
	local function legacy(ply, ent, data)
		return dooEet(ply, ent, {
			key      = data.Key,
			toggle   = data.Toggle,
			reversed = data.Inverse,
		--	noEffect = data.NoEffect
		})
	end

	duplicator.RegisterEntityModifier("FadingDoor", legacy)
end

local function doUndo(undoData, ent)
	if IsValid(ent) then
		onRemove(ent)
		ent:fadeDeactivate()

		ent.isFadingDoor = false

		if WireLib then
			ent.TriggerInput = ent.fadeTriggerInput

			if ent.Inputs then
				Wire_Link_Clear(ent, "Fade")
				ent.Inputs['Fade'] = nil
				WireLib._SetInputs(ent)
			end if ent.Outputs then
				local port = ent.Outputs['FadeActive']

				if port then
					for i,inp in ipairs(port.Connected) do
						if (inp.Entity:IsValid()) then
							Wire_Link_Clear(inp.Entity, inp.Name)
						end
					end
				end

				ent.Outputs['FadeActive'] = nil
				WireLib._SetOutputs(ent)
			end
		end
	end
end

function TOOL:LeftClick(tr)
	if not checkTrace(tr) then
		return false
	end

	local ent = tr.Entity
	local ply = self:GetOwner()
	
    if ent:GetClass() ~= 'prop_physics' then return false end
    
	dooEet(ply, ent, {
		key      = self:GetClientNumber("key"),
		toggle   = self:GetClientNumber("toggle") == 1,
		reversed = self:GetClientNumber("reversed") == 1,
	--	noEffect = self:GetClientNumber("noeffect") == 1
	})

	undo.Create("Fading_Door")
		undo.AddFunction(doUndo, ent)
		undo.SetPlayer(ply)
	undo.Finish()

	return true
end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/light.lua:

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.light.name"

TOOL.ClientConVar[ "ropelength" ] = "64"
TOOL.ClientConVar[ "ropematerial" ] = "cable/rope"
TOOL.ClientConVar[ "r" ] = "255"
TOOL.ClientConVar[ "g" ] = "255"
TOOL.ClientConVar[ "b" ] = "255"
TOOL.ClientConVar[ "brightness" ] = "2"
TOOL.ClientConVar[ "size" ] = "256"
TOOL.ClientConVar[ "key" ] = "37"
TOOL.ClientConVar[ "toggle" ] = "1"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" }
}

cleanup.Register( "lights" )

function TOOL:LeftClick( trace, attach )

	if ( IsValid( trace.Entity ) && trace.Entity:IsPlayer() ) then return false end
	if ( CLIENT ) then return true end
	if ( attach == nil ) then attach = true end

	-- If there's no physics object then we can't constraint it!
	if ( SERVER && attach && !util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) ) then return false end

	local ply = self:GetOwner()

	local pos, ang = trace.HitPos + trace.HitNormal * 8, trace.HitNormal:Angle() - Angle( 90, 0, 0 )

	local r = math.Clamp( self:GetClientNumber( "r" ), 0, 255 )
	local g = math.Clamp( self:GetClientNumber( "g" ), 0, 255 )
	local b = math.Clamp( self:GetClientNumber( "b" ), 0, 255 )
	local brght = math.Clamp(self:GetClientNumber("brightness"), 0, 1)
	local size = math.Clamp(self:GetClientNumber("size"), 0, 512)
	local toggle = self:GetClientNumber( "toggle" ) != 1

	local key = self:GetClientNumber( "key" )

	if ( IsValid( trace.Entity ) && trace.Entity:GetClass() == "gmod_light" && trace.Entity:CPPIGetOwner() == ply ) then

		trace.Entity:SetColor( Color( r, g, b, 255 ) )
		trace.Entity.r = r
		trace.Entity.g = g
		trace.Entity.b = b
		trace.Entity.Brightness = brght
		trace.Entity.Size = size

		trace.Entity:SetBrightness( brght )
		trace.Entity:SetLightSize( size )
		trace.Entity:SetToggle( !toggle )

		trace.Entity.KeyDown = key

		numpad.Remove( trace.Entity.NumDown )
		numpad.Remove( trace.Entity.NumUp )

		trace.Entity.NumDown = numpad.OnDown( ply, key, "LightToggle", trace.Entity, 1 )
		trace.Entity.NumUp = numpad.OnUp( ply, key, "LightToggle", trace.Entity, 0 )

		return true

	end

	if ( !self:GetWeapon():CheckLimit( "lights" ) ) then return false end

	local light = MakeLight( ply, r, g, b, brght, size, toggle, !toggle, key, { Pos = pos, Angle = ang } )
	if ( !IsValid( light ) ) then return false end

	undo.Create( "Light" )
		undo.AddEntity( light )

		if ( attach ) then

			local length = math.Clamp( self:GetClientNumber( "ropelength" ), 4, 1024 )
			local material = self:GetClientInfo( "ropematerial" )

			local LPos1 = Vector( 0, 0, 6.5 )
			local LPos2 = trace.Entity:WorldToLocal( trace.HitPos )

			if ( IsValid( trace.Entity ) ) then

				local phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )
				if ( IsValid( phys ) ) then
					LPos2 = phys:WorldToLocal( trace.HitPos )
				end

			end

			local constr, rope = constraint.Rope( light, trace.Entity, 0, trace.PhysicsBone, LPos1, LPos2, 0, length, 0, 1, material )
			if ( IsValid( constr ) ) then
				undo.AddEntity( constr )
				ply:AddCleanup( "lights", constr )
			end
			if ( IsValid( rope ) ) then
				undo.AddEntity( rope )
				ply:AddCleanup( "lights", rope )
			end

		end

		undo.SetPlayer( ply )
	undo.Finish()

	return true

end

function TOOL:RightClick( trace )

	return self:LeftClick( trace, false )

end

if ( SERVER ) then

	function MakeLight( ply, r, g, b, brght, size, toggle, on, KeyDown, Data )

		if ( IsValid( ply ) && !ply:CheckLimit( "lights" ) ) then return false end

		local light = ents.Create( "gmod_light" )
		if ( !IsValid( light ) ) then return end

		duplicator.DoGeneric( light, Data )

		light:SetColor( Color( r, g, b, 255 ) )
		light:SetBrightness( brght )
		light:SetLightSize( size )
		light:SetToggle( !toggle )
		light:SetOn( on )

		light:Spawn()

		duplicator.DoGenericPhysics( light, ply, Data )

		light:CPPISetOwner( ply )

		light.lightr = r
		light.lightg = g
		light.lightb = b
		light.Brightness = brght
		light.Size = size
		light.KeyDown = KeyDown
		light.on = on

		light.NumDown = numpad.OnDown( ply, KeyDown, "LightToggle", light, 1 )
		light.NumUp = numpad.OnUp( ply, KeyDown, "LightToggle", light, 0 )

		if ( IsValid( ply ) ) then
			ply:AddCount( "lights", light )
			ply:AddCleanup( "lights", light )
		end

		return light

	end
	duplicator.RegisterEntityClass( "gmod_light", MakeLight, "lightr", "lightg", "lightb", "Brightness", "Size", "Toggle", "on", "KeyDown", "Data" )

	local function Toggle( ply, ent, onoff )

		if ( !IsValid( ent ) ) then return false end
		if ( !ent:GetToggle() ) then ent:SetOn( onoff == 1 ) return end

		if ( numpad.FromButton() ) then

			ent:SetOn( onoff == 1 )
			return

		end

		if ( onoff == 0 ) then return end

		return ent:Toggle()

	end
	numpad.Register( "LightToggle", Toggle )

end

function TOOL:UpdateGhostLight( ent, ply )

	if ( !IsValid( ent ) ) then return end

	local trace = ply:GetEyeTrace()
	if ( !trace.Hit || IsValid( trace.Entity ) && ( trace.Entity:IsPlayer() || trace.Entity:GetClass() == "gmod_light" ) ) then

		ent:SetNoDraw( true )
		return

	end

	ent:SetPos( trace.HitPos + trace.HitNormal * 8 )
	ent:SetAngles( trace.HitNormal:Angle() - Angle( 90, 0, 0 ) )

	ent:SetNoDraw( false )

end

function TOOL:Think()

	if ( !IsValid( self.GhostEntity ) || self.GhostEntity:GetModel() != "models/maxofs2d/light_tubular.mdl" ) then
		self:MakeGhostEntity( "models/maxofs2d/light_tubular.mdl", vector_origin, angle_zero )
	end

	self:UpdateGhostLight( self.GhostEntity, self:GetOwner() )

end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.light.desc" } )

	CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "light", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

	CPanel:AddControl( "Numpad", { Label = "#tool.light.key", Command = "light_key", ButtonSize = 22 } )

	CPanel:AddControl( "Slider", { Label = "#tool.light.ropelength", Command = "light_ropelength", Type = "Float", Min = 0, Max = 256 } )
	CPanel:AddControl( "Slider", { Label = "#tool.light.brightness", Command = "light_brightness", Type = "Int", Min = -6, Max = 6 } )
	CPanel:AddControl( "Slider", { Label = "#tool.light.size", Command = "light_size", Type = "Float", Min = 0, Max = 1024 } )

	CPanel:AddControl( "Checkbox", { Label = "#tool.light.toggle", Command = "light_toggle" } )

	CPanel:AddControl( "Color", { Label = "#tool.light.color", Red = "light_r", Green = "light_g", Blue = "light_b" } )

end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/material.lua:

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.material.name"

TOOL.ClientConVar[ "override" ] = "debug/env_cubemap_model"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" }
}

--
-- Duplicator function
--
local function SetMaterial( Player, Entity, Data )

	if ( SERVER ) then

		--
		-- Make sure this is in the 'allowed' list in multiplayer - to stop people using exploits
		--
		if ( !game.SinglePlayer() && !list.Contains( "OverrideMaterials", Data.MaterialOverride ) && Data.MaterialOverride != "" ) then return end

		Entity:SetMaterial( Data.MaterialOverride )
		duplicator.StoreEntityModifier( Entity, "material", Data )
	end

	return true

end
if ( SERVER ) then
	duplicator.RegisterEntityModifier( "material", SetMaterial )
end

-- Left click applies the current material
function TOOL:LeftClick( trace )

	local ent = trace.Entity
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent ) ) then return false end -- The entity is valid and isn't worldspawn
	if ( CLIENT ) then return true end

	local mat = self:GetClientInfo( "override" )
	SetMaterial( self:GetOwner(), ent, { MaterialOverride = mat } )
	return true

end

-- Right click copies the material
function TOOL:RightClick( trace )

	local ent = trace.Entity
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent ) ) then return false end -- The entity is valid and isn't worldspawn
	if ( CLIENT ) then return true end

	self:GetOwner():ConCommand( "material_override " .. ent:GetMaterial() )

	return true

end

-- Reload reverts the material
function TOOL:Reload( trace )

	local ent = trace.Entity
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent ) ) then return false end -- The entity is valid and isn't worldspawn
	if ( CLIENT ) then return true end

	SetMaterial( self:GetOwner(), ent, { MaterialOverride = "" } )
	return true

end

list.Add( "OverrideMaterials", "models/wireframe" )
list.Add( "OverrideMaterials", "debug/env_cubemap_model" )
list.Add( "OverrideMaterials", "models/shadertest/shader3" )
list.Add( "OverrideMaterials", "models/shadertest/shader4" )
list.Add( "OverrideMaterials", "models/shadertest/shader5" )
list.Add( "OverrideMaterials", "models/shiny" )
list.Add( "OverrideMaterials", "models/debug/debugwhite" )
list.Add( "OverrideMaterials", "Models/effects/comball_sphere" )
list.Add( "OverrideMaterials", "Models/effects/comball_tape" )
list.Add( "OverrideMaterials", "Models/effects/splodearc_sheet" )
list.Add( "OverrideMaterials", "Models/effects/vol_light001" )
list.Add( "OverrideMaterials", "models/props_combine/stasisshield_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/portalball001_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/com_shield001a" )
list.Add( "OverrideMaterials", "models/props_c17/frostedglass_01a" )
list.Add( "OverrideMaterials", "models/props_lab/Tank_Glass001" )
list.Add( "OverrideMaterials", "models/props_combine/tprings_globe" )
list.Add( "OverrideMaterials", "models/rendertarget" )
list.Add( "OverrideMaterials", "models/screenspace" )
list.Add( "OverrideMaterials", "brick/brick_model" )
list.Add( "OverrideMaterials", "models/props_pipes/GutterMetal01a" )
list.Add( "OverrideMaterials", "models/props_pipes/Pipesystem01a_skin3" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a" )
list.Add( "OverrideMaterials", "models/props_foliage/tree_deciduous_01a_trunk" )
list.Add( "OverrideMaterials", "models/props_c17/FurnitureFabric003a" )
list.Add( "OverrideMaterials", "models/props_c17/FurnitureMetal001a" )
list.Add( "OverrideMaterials", "models/props_c17/paper01" )
list.Add( "OverrideMaterials", "models/flesh" )

-- phx
list.Add( "OverrideMaterials", "phoenix_storms/metalset_1-2" )
list.Add( "OverrideMaterials", "phoenix_storms/metalfloor_2-3" )
list.Add( "OverrideMaterials", "phoenix_storms/plastic" )
list.Add( "OverrideMaterials", "phoenix_storms/wood" )
list.Add( "OverrideMaterials", "phoenix_storms/bluemetal" )
list.Add( "OverrideMaterials", "phoenix_storms/cube" )
list.Add( "OverrideMaterials", "phoenix_storms/dome" )
list.Add( "OverrideMaterials", "phoenix_storms/gear" )
list.Add( "OverrideMaterials", "phoenix_storms/stripes" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_green" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_red" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_blue" )

list.Add( "OverrideMaterials", "hunter/myplastic" )
list.Add( "OverrideMaterials", "models/XQM/LightLinesRed_tool" )

if ( IsMounted( "tf" ) ) then
	list.Add( "OverrideMaterials", "models/player/shared/gold_player" )
	list.Add( "OverrideMaterials", "models/player/shared/ice_player" )
end

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.material.help" } )

	local filter = CPanel:AddControl( "TextBox", { Label = "#spawnmenu.quick_filter_tool" } )
	filter:SetUpdateOnType( true )

	-- Remove duplicate materials. table.HasValue is used to preserve material order
	local materials = {}
	for id, str in ipairs( list.Get( "OverrideMaterials" ) ) do
		if ( !table.HasValue( materials, str ) ) then
			table.insert( materials, str )
		end
	end

	local matlist = CPanel:MatSelect( "material_override", materials, true, 0.25, 0.25 )

	filter.OnValueChange = function( s, txt )
		for id, pnl in ipairs( matlist.Controls ) do
			if ( !pnl.Value:lower():find( txt:lower(), nil, true ) ) then
				pnl:SetVisible( false )
			else
				pnl:SetVisible( true )
			end
		end
		matlist:InvalidateChildren()
		CPanel:InvalidateChildren()
	end
end

--addons/tool_stacker/lua/weapons/gmod_tool/stools/stacker.lua:
TOOL.Category		= "WayZer's Role Play"
TOOL.Name			= "#Tool.stacker.name"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "mode" ] 		= "1"
TOOL.ClientConVar[ "dir" ] 		= "1"
TOOL.ClientConVar[ "count" ] 		= "1"
TOOL.ClientConVar[ "model" ] 		= ""
TOOL.ClientConVar[ "offsetx" ] 		= "0"
TOOL.ClientConVar[ "offsety" ] 		= "0"
TOOL.ClientConVar[ "offsetz" ] 		= "0"
TOOL.ClientConVar[ "rotp" ] 		= "0"
TOOL.ClientConVar[ "roty" ] 		= "0"
TOOL.ClientConVar[ "rotr" ] 		= "0"
TOOL.ClientConVar[ "recalc" ] 		= "0"
TOOL.ClientConVar[ "ghostall" ]		= "1"
TOOL.ClientConVar[ "halo" ]			= "0"

if SERVER then
	util.AddNetworkString("StackGhost")
	util.AddNetworkString("UnstackGhost")
end

if ( CLIENT ) then
	language.Add( "Tool.stacker.name", "Stacker" )
	language.Add( "Tool.stacker.desc", "Stacks Props Easily" )
	language.Add( "Tool.stacker.0", "Click To Stack The Prop You're Pointing At." )
	language.Add( "Undone_stacker", "Undone Stacked Prop(s)" )
end

function TOOL:Holster()
	self:ReleaseGhostStack()
end

function TOOL:Deploy()
end

function TOOL:LeftClick(trace)
	if !trace.Entity || !trace.Entity:IsValid() || trace.Entity:GetClass() != "prop_physics" then return false end
	if CLIENT then return true end

	local Mode		= self:GetClientNumber( "mode" )
	local Dir		= self:GetClientNumber( "dir" )
	local Count		= self:GetClientNumber( "count" )
	local OffsetX		= self:GetClientNumber( "offsetx" )
	local OffsetY		= self:GetClientNumber( "offsety" )
	local OffsetZ		= self:GetClientNumber( "offsetz" )
	local RotP		= self:GetClientNumber( "rotp" )
	local RotY		= self:GetClientNumber( "roty" )
	local RotR		= self:GetClientNumber( "rotr" )
	local Recalc		= self:GetClientNumber( "recalc" ) == 1
	local Offset		= Vector(OffsetX, OffsetY, OffsetZ)
	local Rot		= Angle(RotP, RotY, RotR)
	local ply = self:GetOwner()
	local Ent = trace.Entity

	local NewVec = Ent:GetPos()
	local NewAng = Ent:GetAngles()
	local LastEnt = Ent
	//SimpleAdmin:Broadcast("COUNT IS " .. Count)
	if Count <= 0 then return false end
	undo.Create("stacker")
	for i=1, Count, 1 do
		if (!self:GetSWEP():CheckLimit("props")) then break end
		if i == 1 || (Mode == 2 && Recalc == true) then
			StackDir, Height, ThisOffset = self:StackerCalcPos(LastEnt, Mode, Dir, Offset)
		end
		NewVec = NewVec + StackDir * Height + ThisOffset
		NewAng = NewAng + Rot
		if !Ent:IsInWorld() then
			return false //Who put just break here? Seriously? Giving the player no hint he/she's not supposed to do that?
		end

	//	local EntList = ents.FindInSphere(NewVec, .2) //Searching in a sphere and find props
	//	local PropValid = true						//Flag if prop is found or not
	//	for k, v in pairs(EntList) do				//For loop
	//		if (v:IsValid() && v:GetClass() == "prop_physics" && (v == LastEnt )) then//|| v:GetPos() == NewVec)) then
	//			if (self:IsInGhostStack(v)) then continue end
	//			PropValid = false
	//		end
	//	end
	//	if !PropValid then return false end
		NewEnt = ents.Create("prop_physics")
			NewEnt:SetModel(Ent:GetModel())
			NewEnt:SetColor(Ent:GetColor())
			NewEnt:SetPos(NewVec)
			NewEnt:SetAngles(NewAng)
			NewEnt:Spawn()
			ply:AddFrozenPhysicsObject(NewEnt, NewEnt:GetPhysicsObject()) //Fix so you can mass-unfreeze
			NewEnt:GetPhysicsObject():EnableMotion(false)

		LastEnt = NewEnt
		undo.AddEntity(NewEnt)
		ply:AddCount("props", NewEnt)
		ply:AddCleanup("props", NewEnt)
		if PropDefender && PropDefender.Player && PropDefender.Player.Give then
			PropDefender.Player.Give(ply, NewEnt, false)
		end
		//table.insert(self.StackedEnts, NewEnt)
	end
	undo.SetPlayer(ply)
	undo.Finish()
	return true
end

function TOOL:StackerCalcPos(lastent, mode, dir, offset)
	local forward = Vector(1,0,0):Angle()
	local pos = lastent:GetPos()
	local ang = lastent:GetAngles()
	local lower, upper = lastent:WorldSpaceAABB( )
	local glower = lastent:OBBMins()
	local gupper = lastent:OBBMaxs()

	local stackdir = Vector(0,0,1)
	local height = math.abs(upper.z - lower.z)

	if mode == 1 then // Relative to world
		if dir == 1 then
			stackdir = forward:Up()
			height = math.abs(upper.z - lower.z)
		elseif dir == 2 then
			stackdir = forward:Up() * -1
			height = math.abs(upper.z - lower.z)
		elseif dir == 3 then
			stackdir = forward:Forward()
			height = math.abs(upper.x - lower.x)
		elseif dir == 4 then
			stackdir = forward:Forward() * -1
			height = math.abs(upper.x - lower.x)
		elseif dir == 5 then
			stackdir = forward:Right()
			height = math.abs(upper.y - lower.y)
		elseif dir == 6 then
			stackdir = forward:Right() * -1
			height = math.abs(upper.y - lower.y)
		end
	elseif mode == 2 then // Relative to prop
		forward = ang
		if dir == 1 then
			stackdir = forward:Up()
			offset = forward:Up() * offset.X + forward:Forward() * -1 * offset.Z + forward:Right() * offset.Y
			height = math.abs(gupper.z - glower.z)
		elseif dir == 2 then
			stackdir = forward:Up() * -1
			offset = forward:Up() * -1 * offset.X + forward:Forward() * offset.Z + forward:Right() * offset.Y
			height = math.abs(gupper.z - glower.z)
		elseif dir == 3 then
			stackdir = forward:Forward()
			offset = forward:Forward() * offset.X + forward:Up() * offset.Z + forward:Right() * offset.Y
			height = math.abs(gupper.x - glower.x)
		elseif dir == 4 then
			stackdir = forward:Forward() * -1
			offset = forward:Forward() * -1 * offset.X + forward:Up() * offset.Z + forward:Right() * -1 * offset.Y
			height = math.abs(gupper.x - glower.x)
		elseif dir == 5 then
			stackdir = forward:Right()
			offset = forward:Right() * offset.X + forward:Up() * offset.Z + forward:Forward() * -1 * offset.Y
			height = math.abs(gupper.y - glower.y)
		elseif dir == 6 then
			stackdir = forward:Right() * -1
			offset = forward:Right() * -1 * offset.X + forward:Up() * offset.Z + forward:Forward() * offset.Y
			height = math.abs(gupper.y - glower.y)
		end
	end //offset = (stackdir:Angle():Up() * offset.Z) + (stackdir:Angle():Forward() * offset.X) + (stackdir:Angle():Right() * offset.Y)

	return stackdir, height, offset
end

function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl("Header", { Text = "#Tool.stacker.name", Description	= "#Tool.stacker.desc" })

	local params = {Label = "Relative To:", MenuButton = "0", Options = {}}
	params.Options["World"] = {stacker_mode = "1"}
	params.Options["Prop"] = {stacker_mode = "2"}
	CPanel:AddControl( "ComboBox", params )

	local params = {Label = "Stack Direction", MenuButton = "0", Options = {}}
	params.Options["Up"] = {stacker_dir = "1"}
	params.Options["Down"] = {stacker_dir = "2"}
	params.Options["Front"] = {stacker_dir = "3"}
	params.Options["Behind"] = {stacker_dir = "4"}
	params.Options["Right"] = {stacker_dir = "5"}
	params.Options["Left"] = {stacker_dir = "6"}
	CPanel:AddControl( "ComboBox", params )

	CPanel:AddControl( "Slider",  { Label	= "Count",
					Type	= "Integer",
					Min		= 1,
					Max		= 3,
					Command = "stacker_count",
					Description = "How many props to stack."}	 )

	CPanel:AddControl( "Header", { Text = "Advanced Options", Description	= "These options are for advanced users. Leave them all default (0) if you don't understand what they do." }  )
	CPanel:AddControl( "Button",  { Label	= "Reset Advanced Options",
					Command = "stacker_resetoffsets",
					Text = "Reset"}	 )
	CPanel:AddControl( "Slider",  { Label	= "Offset X (forward/back)",
					Type	= "Float",
					Min		= -1000,
					Max		= 1000,
					Value	= 0,
					Command = "stacker_offsetx"}	 )
	CPanel:AddControl( "Slider",  { Label	= "Offset Y (right/left)",
					Type	= "Float",
					Min		= -1000,
					Max		= 1000,
					Value	= 0,
					Command = "stacker_offsety"}	 )
	CPanel:AddControl( "Slider",  { Label	= "Offset Z (up/down)",
					Type	= "Float",
					Min		= -1000,
					Max		= 1000,
					Value	= 0,
					Command = "stacker_offsetz"}	 )
	CPanel:AddControl( "Slider",  { Label	= "Rotate Pitch",
					Type	= "Float",
					Min		= -360,
					Max		= 360,
					Value	= 0,
					Command = "stacker_rotp"}	 )
	CPanel:AddControl( "Slider",  { Label	= "Rotate Yaw",
					Type	= "Float",
					Min		= -360,
					Max		= 360,
					Value	= 0,
					Command = "stacker_roty"}	 )
	CPanel:AddControl( "Slider",  { Label	= "Rotate Roll",
					Type	= "Float",
					Min		= -360,
					Max		= 360,
					Value	= 0,
					Command = "stacker_rotr"}	 )
	CPanel:AddControl( "Checkbox", { Label = "Stack relative to new rotation", Command = "stacker_recalc", Description = "If this is checked, each item in the stack will be stacked relative to the previous item in the stack. This allows you to create curved stacks." } )
	CPanel:AddControl("Checkbox", {Label = "Ghost ALL of the props?", Command = "stacker_ghostall", Description = "Ghost all of the props specified by count"})
	CPanel:AddControl("Checkbox", {Label = "Give ghosted props halos?", Command = "stacker_halo", Description = "Give the ghost a halo"})
end

if (CLIENT) then
	local function ResetOffsets(ply, command, arguments)
		-- Reset all of the offset options to 0
		LocalPlayer():ConCommand("stacker_offsetx 0\n")
		LocalPlayer():ConCommand("stacker_offsety 0\n")
		LocalPlayer():ConCommand("stacker_offsetz 0\n")
		LocalPlayer():ConCommand("stacker_rotp 0\n")
		LocalPlayer():ConCommand("stacker_roty 0\n")
		LocalPlayer():ConCommand("stacker_rotr 0\n")
		LocalPlayer():ConCommand("stacker_recalc 0\n")
	end
	
	concommand.Add( "stacker_resetoffsets", ResetOffsets )
end

function TOOL:UpdateGhostStack(ent)
	if (!ent || !ent:IsValid() || !self:CheckGhostStack()) then return end

	local mode		= self:GetClientNumber( "mode" )
	local dir		= self:GetClientNumber( "dir" )
	local offsetx		= self:GetClientNumber( "offsetx" )
	local offsety		= self:GetClientNumber( "offsety" )
	local offsetz		= self:GetClientNumber( "offsetz" )
	local rotp		= self:GetClientNumber( "rotp" )
	local roty		= self:GetClientNumber( "roty" )
	local rotr		= self:GetClientNumber( "rotr" )
	local offset		= Vector(offsetx, offsety, offsetz)
	local rot		= Angle(rotp, roty, rotr)
	local count = self:GetClientNumber("count")
	local recalc		= self:GetClientNumber( "recalc" ) == 1

	local NewEnt = ent
	local NewVec = NewEnt:GetPos()
	local NewAng = NewEnt:GetAngles()

	local stackdir, height, thisoffset

	for k,v in pairs(self.GhostStack) do
		if k == 1 || (mode == 2 && recalc == true) then
			stackdir, height, thisoffset = self:StackerCalcPos(NewEnt, mode, dir, offset)
		end

		NewVec = NewVec + stackdir * height + thisoffset
		NewAng = NewAng + rot

		v:SetAngles(NewAng)
		v:SetPos(NewVec)
		v:SetNoDraw(false)
		NewEnt = v
		//SimpleAdmin:Broadcast(k .. ": " .. tostring(NewAng) .. " : " .. tostring(NewVec) .. " : " .. tostring(v) .. ".")
	end
end

function TOOL:CheckGhostStack() //Returns if stack is ok
	if !self.GhostStack then return false end
	local count = self:GetClientNumber("count")
	if count > 3 then count = 3 end
	for k,v in pairs(self.GhostStack) do
		if (!v || !v:IsValid()) then //if something in the table doesn't exist or it's a null entity tell em it's not ok
			return false
		end
	end
	if (table.Count(self.GhostStack) != count && (self:GetClientNumber("ghostall") == 1)) then
		return false
	elseif (table.Count(self.GhostStack) != 1 && (self:GetClientNumber("ghostall") == 0)) then
		return false
	end
	return true
end

function TOOL:IsInGhostStack(ent)
	if !self.GhostStack then return false end
	for k,v in pairs(self.GhostStack) do
		if (ent == v) then
			return true
		end
	end
	return false
end

function TOOL:CreateGhostStack(prop, pos, ang)
	if(self.GhostStack) then self:ReleaseGhostStack() end
	self.GhostStack = {}
	if (SERVER && !game.SinglePlayer()) then return false end
	if (CLIENT && game.SinglePlayer()) then return false end

	local Halo = self:GetClientNumber("halo") == 1
	local Count = self:GetClientNumber("count")
	if Count > 3 then Count = 3 end
	local GhostAll = (self:GetClientNumber("ghostall") == 1)
	if (!GhostAll && Count != 0) then
		Count = 1
	end

	for i = 1, Count, 1 do
		local Ghost
		if ( CLIENT ) then
			Ghost = ents.CreateClientProp(prop)
		else
			Ghost = ents.Create("prop_physics")
		end

		if (!Ghost:IsValid()) then
			Ghost = nil
			return
		end

		Ghost:SetModel(prop)
		Ghost:SetPos(pos)
		Ghost:SetAngles(ang)
		Ghost:Spawn()

		Ghost:SetSolid(SOLID_VPHYSICS)
		Ghost:SetMoveType(MOVETYPE_NONE)
		Ghost:SetNotSolid(true)
		Ghost:SetRenderMode(RENDERMODE_TRANSALPHA)
		Ghost:SetColor(Color(255, 255, 255, 150))

		table.insert(self.GhostStack, Ghost)
		if SERVER && Halo then
		net.Start("StackGhost")
			net.WriteTable({self.GhostStack})
		net.Send(self:GetOwner())
		end
	end
	return true
end

function TOOL:ReleaseGhostStack()
	if !self.GhostStack then return end
	for k,v in pairs(self.GhostStack) do
		if !v || !v:IsValid() then continue end
		v:Remove()
	end
	if SERVER then 
	net.Start("UnstackGhost")
		net.WriteDouble(1)
	net.Send(self:GetOwner())
	end
	table.Empty(self.GhostStack)
end

function TOOL:Think()
	local ply = self:GetOwner()
	local trace = ply:GetEyeTrace()
	local stacked = false
	if (IsValid(trace.Entity) && trace.Hit && trace.Entity:GetClass() == "prop_physics") then
		self.NewEnt = trace.Entity
		if (self.NewEnt:IsValid() && self.NewEnt != self.LastEnt) then
			//SimpleAdmin:Broadcast("Creating new stack.")
			stacked = self:CreateGhostStack(self.NewEnt:GetModel(), Vector(0,0,0), Angle(0,0,0))
			if stacked then self.LastEnt = self.NewEnt end
		end
		if (!self:CheckGhostStack()) then
			//SimpleAdmin:Broadcast("Releasing old stack.")
			self:ReleaseGhostStack()
			self.LastEnt = nil
		end
	elseif ((IsValid(trace.Entity) && trace.Entity:GetClass() != "prop_physics" && self.LastEnt != nil) || !IsValid(trace.Entity)) then
		//SimpleAdmin:Broadcast("Releasing old stack.")
		self:ReleaseGhostStack()
		self.LastEnt = nil
	end
	if (self.LastEnt != nil && self.LastEnt:IsValid()) then
		//SimpleAdmin:Broadcast("Updating old stack.")
		self:UpdateGhostStack(self.LastEnt)
	end
	if CLIENT then
		//MsgN(tostring(table.Count(self.GhostStack)) .. " : " .. tostring(table.Count(self)))
		if (!GhostStack || table.Count(GhostStack) <= 0) then return end
		for k, v in pairs(GhostStack) do
			halo.Add({v}, Color(181, 0, 217))
		end
	end
end

function StackGhost(_, ply)
	if not ply:TriggerCooldown('stackghost', 0.3) then return end

	local tbl = net.ReadTable()
	GhostStack = tbl[1]
end
net.Receive("StackGhost", StackGhost)

function UnstackGhost()
	if !GhostStack then return end
	table.Empty(GhostStack)
end
net.Receive("UnstackGhost", UnstackGhost)

--gamemodes/darkrp/entities/weapons/gmod_tool/cl_viewscreen.lua:

local matScreen = Material( "models/weapons/v_toolgun/screen" )
local txBackground = surface.GetTextureID( "models/weapons/v_toolgun/screen_bg" )
local toolmode = GetConVar( "gmod_toolmode" )
local TEX_SIZE = 256

-- GetRenderTarget returns the texture if it exists, or creates it if it doesn't
local RTTexture = GetRenderTarget( "GModToolgunScreen", TEX_SIZE, TEX_SIZE )

surface.CreateFont( "GModToolScreen", {
	font	= "Helvetica",
	size	= 60,
	weight	= 900
} )

local function DrawScrollingText( text, y, texwide )

	local w, h = surface.GetTextSize( text )
	w = w + 64

	y = y - h / 2 -- Center text to y position

	local x = RealTime() * 250 % w * -1

	while ( x < texwide ) do

		surface.SetTextColor( 0, 0, 0, 255 )
		surface.SetTextPos( x + 3, y + 3 )
		surface.DrawText( text )

		surface.SetTextColor( 255, 255, 255, 255 )
		surface.SetTextPos( x, y )
		surface.DrawText( text )

		x = x + w

	end

end

--[[---------------------------------------------------------
	We use this opportunity to draw to the toolmode
		screen's rendertarget texture.
-----------------------------------------------------------]]
function SWEP:RenderScreen()

	-- Set the material of the screen to our render target
	matScreen:SetTexture( "$basetexture", RTTexture )

	-- Set up our view for drawing to the texture
	render.PushRenderTarget( RTTexture )
	cam.Start2D()

		-- Background
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetTexture( txBackground )
		surface.DrawTexturedRect( 0, 0, TEX_SIZE, TEX_SIZE )

		-- Give our toolmode the opportunity to override the drawing
		if ( self:GetToolObject() && self:GetToolObject().DrawToolScreen ) then

			self:GetToolObject():DrawToolScreen( TEX_SIZE, TEX_SIZE )

		else

			surface.SetFont( "GModToolScreen" )
			DrawScrollingText( "#tool." .. toolmode:GetString() .. ".name", 104, TEX_SIZE )

		end

	cam.End2D()
	render.PopRenderTarget()

end

--gamemodes/darkrp/entities/weapons/lockpick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.PrintName = "Отмычка"
    SWEP.Slot = 5
    SWEP.SlotPos = 1
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

-- Variables that are used on both client and server

SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left or right click to pick a lock"
SWEP.Controls = {
    {key = MOUSE_LEFT, desc = "Взломать дверь"},
}
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPLockpick = true

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/c_crowbar.mdl")
SWEP.WorldModel = Model("models/weapons/w_crowbar.mdl")

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Запрещено"

SWEP.Sound = Sound("physics/wood/wood_box_impact_hard3.wav")

SWEP.Primary.ClipSize = -1      -- Size of a clip
SWEP.Primary.DefaultClip = 0        -- Default number of bullets in a clip
SWEP.Primary.Automatic = false      -- Automatic/Semi Auto
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1        -- Size of a clip
SWEP.Secondary.DefaultClip = -1     -- Default number of bullets in a clip
SWEP.Secondary.Automatic = false        -- Automatic/Semi Auto
SWEP.Secondary.Ammo = ""

--[[-------------------------------------------------------
Name: SWEP:Initialize()
Desc: Called when the weapon is first loaded
---------------------------------------------------------]]
function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:SetupDataTables()
    self:NetworkVar("Bool", 0, "IsLockpicking")
    self:NetworkVar("Float", 0, "LockpickStartTime")
    self:NetworkVar("Float", 1, "LockpickEndTime")
    self:NetworkVar("Float", 2, "NextSoundTime")
    self:NetworkVar("Int", 0, "TotalLockpicks")
    self:NetworkVar("Entity", 0, "LockpickEnt")
end

--[[-------------------------------------------------------
Name: SWEP:PrimaryAttack()
Desc: +attack1 has been pressed
---------------------------------------------------------]]
function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + 2)
    if self:GetIsLockpicking() then return end

    self:GetOwner():LagCompensation(true)
    local trace = self:GetOwner():GetEyeTrace()
    self:GetOwner():LagCompensation(false)
    local ent = trace.Entity

    if not IsValid(ent) or ent.DarkRPCanLockpick == false then return end
    local canLockpick = hook.Call("canLockpick", nil, self:GetOwner(), ent, trace)

    if canLockpick == false then return end
    if canLockpick ~= true and (
            trace.HitPos:DistToSqr(self:GetOwner():GetShootPos()) > 10000 or
            (not GAMEMODE.Config.canforcedooropen and ent:DoorIsOwnable()) or
            (not ent:IsDoor() and not ent:IsVehicle() and not string.find(string.lower(ent:GetClass()), "vehicle") and (not GAMEMODE.Config.lockpickfading or not ent.isFadingDoor))
        ) then
        return
    end

    self:SetHoldType("pistol")

    self:SetIsLockpicking(true)
    self:SetLockpickEnt(ent)
    self:SetLockpickStartTime(CurTime())
    local endDelta = hook.Call("lockpickTime", nil, self:GetOwner(), ent) or util.SharedRandom("DarkRP_Lockpick" .. self:EntIndex() .. "_" .. self:GetTotalLockpicks(), 10, 30)
    self:SetLockpickEndTime(CurTime() + endDelta)
    self:SetTotalLockpicks(self:GetTotalLockpicks() + 1)


    if IsFirstTimePredicted() then
        hook.Call("lockpickStarted", nil, self:GetOwner(), ent, trace)
    end

    if SERVER then
        self:GetOwner():StartDelay('lockpick', 'Взлом', endDelta, function(s, ply)
            self:Succeed()
        end, function(s, ply)
            if not IsValid(self) then return false end
            if ply:GetActiveWeapon() ~= self then return false end
            if not self:GetIsLockpicking() then return false end
        end, function()
            if IsValid(self) then
                self:Fail()
            else
                hook.Call("onLockpickCompleted", nil, ply, false, ent)
            end
        end, {
            targetEnt = ent,
        })
    end

    local onFail = function(ply) if ply == self:GetOwner() then hook.Call("onLockpickCompleted", nil, ply, false, ent) end end

    -- Lockpick fails when dying or disconnecting
    hook.Add("PlayerDeath", self, fc{onFail, fn.Flip(fn.Const)})
    hook.Add("PlayerDisconnected", self, fc{onFail, fn.Flip(fn.Const)})
    -- Remove hooks when finished
    hook.Add("onLockpickCompleted", self, fc{fp{hook.Remove, "PlayerDisconnected", self}, fp{hook.Remove, "PlayerDeath", self}})
end

function SWEP:Holster()
    self:SetIsLockpicking(false)
    self:SetLockpickEnt(nil)
    return true
end

function SWEP:Succeed()
    self:SetHoldType("normal")

    local ent = self:GetLockpickEnt()
    self:SetIsLockpicking(false)
    self:SetLockpickEnt(nil)

    if not IsValid(ent) then return end

    local override = hook.Call("onLockpickCompleted", nil, self:GetOwner(), true, ent)

    if override then return end

    if ent.isFadingDoor and ent.fadeActivate and not ent.fadeActive then
        ent:fadeActivate()
        if IsFirstTimePredicted() then timer.Simple(5, function() if IsValid(ent) and ent.fadeActive then ent:fadeDeactivate() end end) end
    elseif ent.Fire then
        if ent:IsDoor() then
            ent:DoorLock(false)
        elseif ent:IsVehicle() then
            ent:VehicleLock(false)
        end
        ent:Fire("open", "", .6)
        ent:Fire("setanimation", "open", .6)
    end
end

function SWEP:Fail()
    self:SetIsLockpicking(false)
    self:SetHoldType("normal")

    hook.Call("onLockpickCompleted", nil, self:GetOwner(), false, self:GetLockpickEnt())
    self:SetLockpickEnt(nil)
end

function SWEP:Think()
    if not self:GetIsLockpicking() or self:GetLockpickEndTime() == 0 then return end

    if CurTime() >= self:GetNextSoundTime() then
        self:SetNextSoundTime(CurTime() + 1)
        local snd = {1,3,4}
        self:EmitSound("weapons/357/357_reload" .. tostring(snd[math.Round(util.SharedRandom("DarkRP_LockpickSnd" .. CurTime(), 1, #snd))]) .. ".wav", 50, 100)
    end
end

function SWEP:SecondaryAttack()
    self:PrimaryAttack()
end


DarkRP.hookStub{
    name = "canLockpick",
    description = "Whether an entity can be lockpicked.",
    parameters = {
        {
            name = "ply",
            description = "The player attempting to lockpick an entity.",
            type = "Player"
        },
        {
            name = "ent",
            description = "The entity being lockpicked.",
            type = "Entity"
        },
        {
            name = "trace",
            description = "The trace result.",
            type = "table"
        }
    },
    returns = {
        {
            name = "allowed",
            description = "Whether the entity can be lockpicked",
            type = "boolean"
        }
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "lockpickStarted",
    description = "Called when a player is about to pick a lock.",
    parameters = {
        {
            name = "ply",
            description = "The player that is about to pick a lock.",
            type = "Player"
        },
        {
            name = "ent",
            description = "The entity being lockpicked.",
            type = "Entity"
        },
        {
            name = "trace",
            description = "The trace result.",
            type = "table"
        }
    },
    returns = {},
    realm = "Shared"
}

DarkRP.hookStub{
    name = "onLockpickCompleted",
    description = "Result of a player attempting to lockpick an entity.",
    parameters = {
        {
            name = "ply",
            description = "The player attempting to lockpick the entity.",
            type = "Player"
        },
        {
            name = "success",
            description = "Whether the player succeeded in lockpicking the entity.",
            type = "boolean"
        },
        {
            name = "ent",
            description = "The entity that was lockpicked.",
            type = "Entity"
        },
    },
    returns = {
        {
            name = "override",
            description = "Return true to override default behaviour, which is opening the (fading) door.",
            type = "boolean"
        }
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "lockpickTime",
    description = "The length of time, in seconds, it takes to lockpick an entity.",
    parameters = {
        {
            name = "ply",
            description = "The player attempting to lockpick an entity.",
            type = "Player"
        },
        {
            name = "ent",
            description = "The entity being lockpicked.",
            type = "Entity"
        },
    },
    returns = {
        {
            name = "time",
            description = "Seconds in which it takes a player to lockpick an entity",
            type = "number"
        }
    },
    realm = "Shared"
}

--gamemodes/darkrp/entities/weapons/med_kit/shared.lua:
if SERVER then
    AddCSLuaFile("shared.lua")
end

SWEP.PrintName = "Аптечка"
SWEP.Author = "DarkRP Developers"
SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.Description = "Heals the wounded."
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = "Left click to heal someone\nRight click to heal yourself"
SWEP.Controls = {
    {key = MOUSE_LEFT, desc = "Лечить"},
    {key = MOUSE_RIGHT, desc = "Лечить себя"},
}
SWEP.IsDarkRPMedKit = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Запрещено"

SWEP.ViewModel = "models/weapons/c_medkit.mdl"
SWEP.WorldModel = "models/weapons/w_medkit.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 0
SWEP.Primary.ClipSize  = -1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic  = true
SWEP.Primary.Delay = 0.1
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Recoil = 0
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Delay = 0.3
SWEP.Secondary.Ammo = "none"

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)

    local found
    local lastDot = -1 -- the opposite of what you're looking at
    self:GetOwner():LagCompensation(true)
    local aimVec = self:GetOwner():GetAimVector()

    for k,v in player.Iterator() do
        local maxhealth = v:GetMaxHealth() or 100
        if v == self:GetOwner() or v:GetShootPos():DistToSqr(self:GetOwner():GetShootPos()) > 7225 or v:Health() >= maxhealth or not v:Alive() then continue end

        local direction = v:GetShootPos() - self:GetOwner():GetShootPos()
        direction:Normalize()
        local dot = direction:Dot(aimVec)

        -- Looking more in the direction of this player
        if dot > lastDot then
            lastDot = dot
            found = v
        end
    end
    self:GetOwner():LagCompensation(false)

    if found then
        found:SetHealth(found:Health() + 1)
        self:EmitSound("hl1/fvox/boop.wav", 150, found:Health() / found:GetMaxHealth() * 100, 1, CHAN_AUTO)
    end
end

function SWEP:SecondaryAttack()
    self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
    local ply = self:GetOwner()
    local maxhealth = self:GetOwner():GetMaxHealth() or 100
    if ply:Health() < maxhealth then
        ply:SetHealth(ply:Health() + 1)
        self:EmitSound("hl1/fvox/boop.wav", 150, ply:Health() / ply:GetMaxHealth() * 100, 1, CHAN_AUTO)
    end
end

--addons/module_css2/lua/weapons/ptp_cs_autoshotgun/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "XM1014"
	SWEP.CSMuzzleFlashes = true

	SWEP.AimPos = Vector(-6.886, -8.721, 2.691)
	SWEP.AimAng = Vector(-0.213, -0.787, -1.463)
		
	SWEP.SprintPos = Vector(3.957, -4.112, 1.013)
	SWEP.SprintAng = Vector(-8.613, 32.743, 0)

	SWEP.ZoomAmount = 30
	SWEP.ViewModelMovementScale = 0.3
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "B"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5
SWEP.CaseLength = 10

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_box_buckshot_ttt"

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_shot_xm1014.mdl"
SWEP.WorldModel = "models/weapons/w_shot_xm1014.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 6
SWEP.Primary.DefaultClip = 18
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "buckshot"

SWEP.FireDelay = 0.3
SWEP.FireSound = Sound("Weapon_XM1014.Single")
SWEP.Recoil = 2
SWEP.ShotgunReload = true
SWEP.ReloadStartWait = 0.6
SWEP.ReloadFinishWait = 0.7
SWEP.ReloadShellInsertWait = 0.6
SWEP.Chamberable = false

SWEP.HipSpread = 0.01
SWEP.AimSpread = 0.001
SWEP.ClumpSpread = 0.04
SWEP.VelocitySensitivity = 4
SWEP.MaxSpreadInc = 0.001
SWEP.SpreadPerShot = 0.001
SWEP.SpreadCooldown = 0.5
SWEP.Shots = 8
SWEP.Damage = 15
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_awp/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "AWP"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-8, 1, 0)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	
	SWEP.ViewModelMovementScale = 0.3
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 40
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 40
	SWEP.MaxZoom = 85
	
	SWEP.IconLetter = "z"
	
	SWEP.MuzzleEffect = false
	SWEP.InvertShellEjectAngle = true

end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 40
SWEP.BulletDiameter = 8.58
SWEP.CaseLength = 69.20

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"bolt"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_snip_awp.mdl"
SWEP.WorldModel = "models/weapons/w_snip_awp.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 5
SWEP.Primary.DefaultClip = 15
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 1.5
SWEP.FireSound = Sound("Weapon_AWP.Single")
SWEP.Recoil = 4

SWEP.HipSpread = 0.06
SWEP.AimSpread = 0.0001
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 150
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_g3sg1/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "G3SG1"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-7.921, -7, 2.559)
	SWEP.AimAng = Vector(0, 0, 0)
		
	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 25
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 25
	SWEP.MaxZoom = 65
	
	SWEP.IconLetter = "z"
	
	SWEP.MuzzleEffect = false

	SWEP.InvertShellEjectAngle = true

end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 20
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_snip_g3sg1.mdl"
SWEP.WorldModel = "models/weapons/w_snip_g3sg1.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = false

SWEP.Primary.ClipSize = 15
SWEP.Primary.DefaultClip = 45
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.28
SWEP.FireSound = Sound("Weapon_G3SG1.Single")
SWEP.Recoil = 1

SWEP.HipSpread = 0.06
SWEP.AimSpread = 0.001
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 90
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_scout/shared.lua:
AddCSLuaFile()

if CLIENT then
   
    SWEP.DrawCrosshair = false
	SWEP.PrintName = "Steyr Scout"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos =  Vector(-8, -7, 0.639)
	SWEP.AimAng = Vector(1.1, -1.3, 0)
		
	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 35
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 35
	SWEP.MaxZoom = 75
	
	SWEP.IconLetter = "z"
	
	SWEP.MuzzleEffect = false

	SWEP.InvertShellEjectAngle = true

end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 25
SWEP.BulletDiameter = 7.62
SWEP.CaseLength = 51

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"bolt"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_snip_scout.mdl"
SWEP.WorldModel	= "models/weapons/w_snip_scout.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 10
SWEP.Primary.DefaultClip = 30
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 1.3
SWEP.FireSound = Sound("Weapon_Scout.Single")
SWEP.Recoil = 3.5

SWEP.HipSpread = 0.02
SWEP.AimSpread = 0.00015
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 110
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_ump45/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "HK UMP"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-8.75, -5, 4.15)
	SWEP.AimAng = Vector(-1.331, -0.281, -2.579)
	
	SWEP.SprintPos = Vector(0.736, -3.971, 3)
	SWEP.SprintAng = Vector(-13.205, 37.048, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"

	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 20
SWEP.BulletDiameter = 11.5
SWEP.CaseLength = 22.8

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "smg"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_smg_ump45.mdl"
SWEP.WorldModel = "models/weapons/w_smg_ump45.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 25
SWEP.Primary.DefaultClip = 75
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_UMP45.Single")
SWEP.Recoil = 0.8

SWEP.HipSpread = 0.025
SWEP.AimSpread = 0.01
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 40
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--addons/module_css2/lua/weapons/ptp_cs_usp/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "HK USP"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5.9, -2.747, 2.539)
	SWEP.AimAng = Vector(0.209, 0, 0)
	
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.CanPenetrate = false
SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 10
SWEP.BulletDiameter = 11.5
SWEP.CaseLength = 22.8

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_pist_usp.mdl"
SWEP.WorldModel = "models/weapons/w_pist_usp.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 12
SWEP.Primary.DefaultClip = 36
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"

SWEP.FireDelay = 0.18
SWEP.FireSound = Sound("Weapon_USP.Single")
SWEP.FireSoundSuppressed = Sound("Weapon_USP.SilencedShot")
SWEP.Recoil = 0.8
SWEP.DryFire = true

SWEP.Suppressable = true

SWEP.HipSpread = 0.02
SWEP.AimSpread = 0.008
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 50
SWEP.DeployTime = 1
--addons/weapon_hatshook/lua/weapons/realistic_hook.lua:
// A more realistic grappling hook

if SERVER then
	AddCSLuaFile()
	util.AddNetworkString( "realistic_hook BreakFree" )
end

SWEP.Base = "weapon_base"

SWEP.PrintName = "Крюк кошка"
SWEP.Category = "Разрешено"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Fire to launch the hook"

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 3
SWEP.SlotPos = 1

SWEP.ViewModelFOV = 80
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.ViewModelFlip   = false

SWEP.WorldModel = "models/weapons/w_alyx_gun.mdl"
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true
SWEP.CanDrop = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 0.05

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "hatshook_ammo"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = 8
SWEP.Secondary.DefaultClip = 32
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = 32
SWEP.Secondary.Delay = 0.5

SWEP.DeploySpeed = 1.5

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "pistol"

---- For TTT
SWEP.Kind = WEAPON_EQUIP
SWEP.AutoSpawnable      = false
SWEP.AmmoEnt = "none"
SWEP.NoSights = true
SWEP.EquipMenuData = {
	type = "item_weapon",
	desc = "A grappling hook.\n\nScale walls or grab things from afar."
};

SWEP.Icon = "entities/realistic_hook"
if SERVER then resource.AddFile( "materials/"..SWEP.Icon..".vmt" ) end
----

--Standard swep functions--
---------------------------
function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "Hook" )
	
	self:NetworkVar( "Int", 0, "Cooldown" )
end

function SWEP:Initialize()
	hook.Add( "SetupMove", self, self.PlayerMove )
	--hook.Add( "Tick", self, self.Tick )
	
	if CLIENT then
		self.VElements = table.FullCopy( self.VElements )
		self:CreateModels(self.VElements) // create viewmodels
		
		hook.Add( "PostDrawOpaqueRenderables", self, self.VMDraw )
	end
	
	if SERVER then
		local timerName = tostring(self).." Hook Broken Cooldown"
		timer.Create( timerName, 0.1, 0, function()
			if not IsValid(self) then timer.Destroy(timerName) return end
			self:SetCooldown( math.Approach(self:GetCooldown(), 0, 2) )
		end)
	end
	
	self.Primary.DefaultClip = cvars.Number("hatshook_ammo")
	self.Primary.ClipSize = cvars.Number("hatshook_ammo")
	self:SetClip1( cvars.Number("hatshook_ammo") )
	self:SetHoldType(self.HoldType)
end
function SWEP:PrimaryAttack()
	if self:GetCooldown()>0 then return end
	
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	
	if CLIENT and (not IsFirstTimePredicted()) then return end
	
	if IsValid( self:GetHook() ) then
		local hk = self:GetHook()
		if not (hk.GetHasHit and hk:GetHasHit()) then return end
		
		if SERVER then hk:SetDist( math.Approach( hk:GetDist(), 0, 10 ) ) end
		self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
		self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	elseif SERVER then
		self:LaunchHook()
	end
end
function SWEP:SecondaryAttack()
	if self:GetCooldown()>0 then return end
	
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	
	if IsValid( self:GetHook() ) then
		local hk = self:GetHook()
		if not (hk.GetHasHit and hk:GetHasHit()) then return end
		
		if SERVER then hk:SetDist( hk:GetDist() + 10 ) end
		self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
		self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	elseif SERVER then
		self:LaunchHook()
	end
end
function SWEP:Reload()
	if SERVER and IsValid(self:GetHook()) then
		if self:GetHook():GetDurability()>0 then
			self:SetCooldown( self:GetHook():GetDurability()+20 )
		else
			self:SetCooldown(10)
		end
		self:GetHook():Remove()
		
		if self:Clip1()==0 then
			self:Remove()
			return
		end
	end
end

-- Handling the hook entity --
------------------------------
function SWEP:LaunchHook()
	if not cvars.Bool( "hatshook_physics" ) then return self:LaunchInstant() end
	if not IsValid( self:GetOwner() ) then return end
	
	if self:Clip1()>0 then
		self:SetClip1(math.max(self:Clip1()-1, 0))
	elseif self:Clip1()==0 then
		return
	end
	
	//self:EmitSound( "physics/metal/metal_box_impact_bullet"..math.random(1,3)..".wav" )
	sound.Play( "physics/metal/metal_canister_impact_soft"..math.random(1,3)..".wav", self:GetOwner():GetShootPos(), 75, 100, 0.5 )
	self:GetOwner():ViewPunch( Angle( math.Rand(-5,-2.5), math.Rand(-2,2), 0 ) )
	
	local hk = ents.Create( "ent_realistic_hook" )
	if not IsValid(hk) then return end // Shouldn't happen
	hk:SetPos( self:GetOwner():GetShootPos() - self:GetOwner():GetAimVector()*10 )
	local ang = self:GetOwner():EyeAngles()
	ang:RotateAroundAxis( ang:Up(), 90 )
	hk:SetAngles( ang )
	hk.FireVelocity = self:GetOwner():GetAimVector() * 500
	hk:SetOwner( self:GetOwner() )
	hk:Spawn()
	
	self:SetHook( hk )
	hk:SetWep( self )
end
function SWEP:Holster()
	if SERVER and self:Clip1() == 0 then self:Remove() end
	
	return true
end

function SWEP:GetFilter()
	return cvars.Bool( "hatshook_hookplayers" ) and {self:GetOwner()} or player.GetAll()
end
function SWEP:LaunchInstant()
	local ply = self:GetOwner()
	if not IsValid( ply ) then return end
	
	local shootPos = ply:GetShootPos()
	
	local tr = util.TraceLine({
		start=shootPos,
		endpos=shootPos+(ply:GetAimVector()*cvars.Number("hatshook_speed")),
		filter=self:GetFilter()
	})
	if tr.HitSky or not tr.Hit then return end
	
	sound.Play( "physics/metal/metal_canister_impact_soft"..math.random(1,3)..".wav", shootPos, 75, 100, 0.5 )
	ply:ViewPunch( Angle( math.Rand(-10,-5), math.Rand(-4,4), 0 ) )
	
	local hk = ents.Create( "ent_realistic_hook" )
	if not IsValid(hk) then return end // Shouldn't happen
	hk:SetPos( tr.HitPos )
	hk:SetAngles( tr.Normal:Angle() )
	hk.FireVelocity = Vector(0,0,0)
	hk:SetOwner( ply )
	hk:Spawn()
	
	self:SetHook( hk )
	hk:SetWep( self )
	
	hk:PhysicsCollide( {HitEntity=tr.Entity, HitPos=tr.HitPos, HitNormal=tr.Normal} )
end

local HookCable = Material( "cable/cable2" )
function SWEP:DrawRope( attPos )
	if not attPos then return end
	
	
	local hk = self:GetHook()
	if not IsValid(hk) then return end
	
	if self:GetOwner()~=LocalPlayer() or hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self:GetOwner()) then return hk:Draw() end
	
	if IsValid( hk:GetTargetEnt() ) then
		local bpos, bang = hk:GetTargetEnt():GetBonePosition( hk:GetFollowBone() )
		local npos, nang = hk:GetFollowOffset(), hk:GetFollowAngle()
		if npos and nang and bpos and bang then
			npos:Rotate( nang )
			nang = nang+bang
			
			npos = bpos+npos
			
			hk:SetPos( npos )
			hk:SetAngles( nang )
		end
	end
	
	render.SetMaterial( HookCable )
	render.DrawBeam( hk:GetPos(), attPos, 1, 0, 2, Color(255,255,255,255) )
end
function SWEP:DrawWorldModel()
	self:DrawModel()
	local att = self:GetAttachment( 1 )
	self:DrawRope( att.Pos )
end
function SWEP:VMDraw()
	if not (self:GetOwner()==LocalPlayer() and self:GetOwner():GetActiveWeapon()==self and hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self:GetOwner())~=false) then return end
	
	local vm = IsValid( self:GetOwner() ) and self:GetOwner():GetViewModel()
	local pos = self:GetPos()
	if IsValid(vm) and vm:GetAttachment( 1 ) then pos = vm:GetAttachment( 1 ).Pos end
	
	self:DrawRope( pos )
end

-- HUD Stuff --
---------------
if CLIENT then
	surface.CreateFont( "hatshook_small", {size=15} )
	surface.CreateFont( "hatshook_large", {size=25, weight=1000} )
end
local function ShadowText( txt, font, x, y )
	draw.DrawText( txt, font, x+1, y+1, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	draw.DrawText( txt, font, x, y, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
end
local ChargeBarCol = { White = Color(255,255,255), DefCol1 = Color(255,50,50), DefCol2 = Color(50,255,50) }
local Gradient = Material( "gui/gradient" )
local function DrawChargeBar( xpos, ypos, width, height, charge, col1, col2 )
	draw.NoTexture()
	
	surface.SetDrawColor( ChargeBarCol.White )
	surface.DrawOutlinedRect( xpos, ypos, width, height )
	
	charge = math.Clamp( charge or 50, 0, 100)
	barLen = (width-2)*(charge/100)
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, true )
		surface.SetDrawColor( col2 or ChargeBarCol.DefCol2 )
		surface.DrawRect( xpos+1, ypos+1, width-1, height-2 )
		
		surface.SetMaterial( Gradient )
		surface.SetDrawColor( col1 or ChargeBarCol.DefCol1 )
		surface.DrawTexturedRect( xpos+1, ypos+1, width-1, height-2 )
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, false )
	
	draw.NoTexture()
end
function SWEP:DrawHUD()
	if IsValid( self:GetHook() ) and self:GetHook():GetHasHit() then
		ShadowText( "Rope length: "..tostring(self:GetHook():GetDist()), "hatshook_small", ScrW()/2, ScrH()/2+40 )
		ShadowText( (input.LookupBinding("+attack") or "[PRIMARY FIRE]"):upper() .. " - Retract rope", "hatshook_small", ScrW()/2, ScrH()/2+70 )
		ShadowText( (input.LookupBinding("+attack2") or "[SECONDARY FIRE]"):upper() .. " - Extend rope", "hatshook_small", ScrW()/2, ScrH()/2+85 )
		ShadowText( (input.LookupBinding("+reload") or "[RELOAD]"):upper() .. " - Break rope", "hatshook_small", ScrW()/2, ScrH()/2+100 )
		
		if IsValid( self:GetHook():GetTargetEnt() ) and self:GetHook():GetTargetEnt():IsPlayer() then
			DrawChargeBar( (ScrW()/2)-70, (ScrH()/2)+20, 140, 15, self:GetHook():GetDurability() )
		else
			ShadowText( (input.LookupBinding("+use") or "[USE]"):upper() .. " - Jump off", "hatshook_small", ScrW()/2, ScrH()/2+115 )
		end
	elseif self:GetCooldown()>0 then
		DrawChargeBar( (ScrW()/2)-70, (ScrH()/2)+20, 140, 15, self:GetCooldown() )
	end
	
	if self:Clip1()>=0 then
		ShadowText( "Hooks Remaining: " .. tostring(self:Clip1()), "hatshook_large", ScrW()/2, ScrH()-50 )
	end
end

-- Movement Handling --
-----------------------
local function ValidPullEnt(ent)
	if (not IsValid(ent)) or ent:IsPlayer() then return false end
	local phys = ent:GetPhysicsObject()
	
	return (not IsValid(phys)) or ((not phys:HasGameFlag(FVPHYSICS_NO_PLAYER_PICKUP)) and (phys:GetMass()<=50) and (ent.CanPickup!=false) and phys:IsMotionEnabled())
end

function SWEP:PlayerMove(ply, mv, cmd)
	if not IsValid(ply) then return end
	if not ply:Alive() then return end
	
	local owner = self:GetOwner()
	if not IsValid(owner) then return end
	if not owner:Alive() then return end
	
	local hk = self:GetHook()
	if not IsValid(hk) then return end
	if not hk.GetHasHit then return end
	if not hk:GetHasHit() then return end

	if (owner:InVehicle()) then
		if SERVER then
			self:SetCooldown(10)
			hk:Remove()
		end
		return
	end

	local targetEnt = hk:GetTargetEnt()
	local isValidTarget = IsValid(targetEnt) and (targetEnt:IsPlayer() or ValidPullEnt(targetEnt))

	if isValidTarget and targetEnt ~= self and ply ~= targetEnt then return end
	
	if (targetEnt == hk or not isValidTarget) and ply ~= owner then return end

	if ply ~= owner then
		--ply.was_pushed = { t = CurTime(), att = owner }
		if SERVER then
			self:SetCooldown(10)
			hk:Remove()
		end
		return
	end
	
	if ply:KeyPressed(IN_USE) and ply == owner then
		if hk:GetPos()[3] > ply:GetShootPos()[3] then
			mv:SetVelocity(mv:GetVelocity() + Vector(0, 0, 300))
		end
		if SERVER then
			self:SetCooldown(10)
			hk:Remove()
		end
	end

	local TargetPoint = hk:GetPos()
	local ShootPos = owner:GetShootPos() + Vector(0, 0, (owner:Crouching() and 0 or (hk:GetUp()[1] > 0.9 and -45 or 0)))
	local Distance = hk:GetDist()

	local DistFromTarget = ShootPos:Distance(TargetPoint)
	if DistFromTarget < (Distance + 5) then return end

	local ApproachDir = (TargetPoint - ply:GetPos()):GetNormal()
	local TargetPos = TargetPoint - (ApproachDir * Distance)

	local xDif, yDif, zDif = math.abs(ShootPos[1] - TargetPos[1]), math.abs(ShootPos[2] - TargetPos[2]), math.abs(ShootPos[3] - TargetPos[3])
	local speedMult = 3 + ((xDif + yDif) * 0.5)^1.01
	local vertMult = math.max((math.Max(300 - (xDif + yDif), -10) * 0.08)^1.01 + (zDif / 2), 0)

	if ply ~= owner and owner:GetGroundEntity() == ply then vertMult = -vertMult end

	local TargetVel = (TargetPos - ShootPos):GetNormal() * 10
	TargetVel[1], TargetVel[2] = TargetVel[1] * speedMult, TargetVel[2] * speedMult
	TargetVel[3] = TargetVel[3] * vertMult

	local dir = mv:GetVelocity()
	local clamp, vclamp, accel, vaccel = 50, 20, 200, 30 * (vertMult / 50)

	dir[1] = math.Approach(dir[1], TargetVel[1], accel)
	dir[2] = math.Approach(dir[2], TargetVel[2], accel)
	if ShootPos[3] < TargetPos[3] then
		dir[3] = math.Approach(dir[3], TargetVel[3], vaccel)
		if vertMult > 0 then self.ForceJump = ply end
	end

	mv:SetVelocity(dir)
end


local function ForceJump( ply )
	if not (IsValid(ply) and ply:IsPlayer()) then return end
	if not ply:OnGround() then return end
	
	local tr = util.TraceLine( {start = ply:GetPos(), endpos = ply:GetPos()+Vector(0,0,20), filter = ply} )
	if tr.Hit then return end
	
	ply:SetPos(ply:GetPos()+Vector(0,0,5) )
end
function SWEP:Think()
	
	if self.ForceJump then
		local owner = self:GetOwner()
		local hk = self:GetHook()

		if IsValid(owner) and self.ForceJump==owner then
			ForceJump( owner )
		elseif IsValid( hk ) and IsValid( hk:GetTargetEnt() ) and self.ForceJump == hk:GetTargetEnt() then
			ForceJump( self.ForceJump )
		end
		self.ForceJump = nil
	end
	if SERVER then
		self:EntityPull()

		if self:Clip1()==0 and not IsValid(self:GetHook()) then
			self:Remove()
		end
	end
end

function SWEP:EntityPull() -- For pulling entities
    
    local owner = self:GetOwner()
    if not IsValid(owner) then return end 
    
    local hk = self:GetHook()
    if not IsValid(hk) then return end
    if not hk.GetTargetEnt then return end
    
    local targetEnt = hk:GetTargetEnt()
    if not IsValid(targetEnt) then return end
    if not ValidPullEnt(targetEnt) then return end
    
    local phys = targetEnt:GetPhysicsObject()
    if targetEnt:IsPlayer() or not IsValid(phys) then return end
    
    local targetPoint = owner:GetShootPos()
    local shootPos = targetEnt:GetPos()
    local approachDir = (targetPoint - shootPos):GetNormal()
    local distance = hk:GetDist()
    
    local distFromTarget = shootPos:Distance(targetPoint)
    if distFromTarget < (distance + 5) then return end
    
    local targetPos = targetPoint - (approachDir * distance)
    
    local xDif = math.abs(shootPos[1] - targetPos[1])
    local yDif = math.abs(shootPos[2] - targetPos[2])
    local zDif = math.abs(shootPos[3] - targetPos[3])
    
    local speedMult = 3 + ((xDif + yDif) * 0.5) ^ 1.01
    local vertMult = math.max((math.Max(100 - (xDif + yDif), -10) * 0.1) ^ 1.01 + (zDif / 2), 0)
    
    if owner:GetGroundEntity() == targetEnt then vertMult = -vertMult end
    
    local massFactor = 1 - (phys:GetMass() / 50)
    local targetVel = (targetPos - shootPos):GetNormal() * 6 * massFactor
    targetVel[1] = targetVel[1] * speedMult
    targetVel[2] = targetVel[2] * speedMult
    targetVel[3] = targetVel[3] * vertMult
    
    local dir = targetEnt:GetVelocity()
    local clamp = 50
    local vclamp = 20
    local accel = 200
    local vaccel = 40 * (vertMult / 50)
    
    dir[1] = math.Approach(dir[1], targetVel[1], accel)
    dir[2] = math.Approach(dir[2], targetVel[2], accel)
    
    if shootPos[3] < targetPos[3] and vertMult ~= 0 then
        dir[3] = math.Approach(dir[3], targetVel[3], vaccel)
    end
    
    phys:SetVelocity(dir)
end


SWEP.VElements = {
	["gun"] = { type = "Model", model = "models/weapons/w_alyx_gun.mdl", bone = "ValveBiped.square", rel = "", pos = Vector(1.1, -1.1, -1.4), angle = Angle(-100, 146, 68), size = Vector(1,1,1), color = Color(255, 255, 255, 255) }
}
-- SWEP Construction Kit code by Clavus, removed everything I don't need. http://facepunch.com/threads/1032378 --
-----------------------------------------------------------------------------------------------------------------
function SWEP:ViewModelDrawn()
	if not IsValid( self:GetOwner() ) then return end
	local vm = self:GetOwner():GetViewModel()
	if !IsValid(vm) then return end
	
	if (!self.VElements) then return end
	for k, v in pairs( self.VElements ) do
		if not file.Exists( v.model, "GAME" ) then continue end
		local model = v.modelEnt
		
		if (!v.bone) then continue end
		
		local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
		if (!pos) then continue end
		
		if IsValid(model) then
			model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
			model:SetAngles(ang)
			local matrix = Matrix()
			matrix:Scale(v.size)
			model:EnableMatrix( "RenderMultiply", matrix )
			
			model:SetMaterial("")
			
			render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
			render.SetBlend(v.color.a/255)
			model:DrawModel()
			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)
		end
	end
end

function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
	local bone, pos, ang
	bone = ent:LookupBone(bone_override or tab.bone)
	
	if (!bone) then return end
	
	pos, ang = Vector(0,0,0), Angle(0,0,0)
	local m = ent:GetBoneMatrix(bone)
	if (m) then pos, ang = m:GetTranslation(), m:GetAngles() end
	
	if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
		ang.r = -ang.r // Fixes mirrored models
	end
	
	return pos, ang
end

function SWEP:CreateModels( tab )
	if (!tab) then return end
	for k, v in pairs( tab ) do
		if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and  string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
			v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
			if (IsValid(v.modelEnt)) then
				v.modelEnt:SetPos(self:GetPos())
				v.modelEnt:SetAngles(self:GetAngles())
				v.modelEnt:SetParent(self)
				v.modelEnt:SetNoDraw(true)
				v.createdModel = v.model
			else
				v.modelEnt = nil
			end
		end
	end
end

function table.FullCopy( tab )
	if (!tab) then return nil end
	local res = {}
	for k, v in pairs( tab ) do
		if (type(v) == "table") then res[k] = table.FullCopy(v)
		elseif (type(v) == "Vector") then res[k] = Vector(v.x, v.y, v.z)
		elseif (type(v) == "Angle") then res[k] = Angle(v.p, v.y, v.r)
		else res[k] = v end
	end
	return res
end

--addons/module_weed/lua/weapons/sent_messure.lua:

AddCSLuaFile()

SWEP.PrintName				= "Измеритель"
SWEP.Author					= "Gonzalolog"
SWEP.Purpose				= "Use to check dank"

SWEP.Slot					= 2
SWEP.SlotPos				= 1
SWEP.Category 				= "Drugs"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.ViewModel				= Model( "models/weapons/c_messure.mdl" )
SWEP.WorldModel				= Model( "models/weapons/w_messure.mdl" )
SWEP.ViewModelFOV			= 54
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= 0
SWEP.Primary.DefaultClip	= 0
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= 1
SWEP.Secondary.DefaultClip	= 1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

if SERVER then
	util.AddNetworkString("OpenTablet")
end

function SWEP:Initialize()

	self:SetHoldType( "slam" )

end

SWEP.Offset = {
	Pos = {
		Up = -4,
		Right = -3,
		Forward = 1,
	},
	Ang = {
		Up = 0,
		Right = 5,
		Forward = 0,
	}
}


function SWEP:DrawWorldModel( )
	local hand, offset

	if not IsValid( self:GetOwner() ) then
		self:DrawModel( )
		return
	end

	if not self.Hand then
		self.Hand = self:GetOwner():LookupAttachment( "anim_attachment_rh" )
	end

	hand = self:GetOwner():GetAttachment( self.Hand )

	if not hand then
		self:DrawModel( )
		return
	end

	offset = hand.Ang:Right( ) * self.Offset.Pos.Right + hand.Ang:Forward( ) * self.Offset.Pos.Forward + hand.Ang:Up( ) * self.Offset.Pos.Up

	hand.Ang:RotateAroundAxis( hand.Ang:Right( ), self.Offset.Ang.Right )
	hand.Ang:RotateAroundAxis( hand.Ang:Forward( ), self.Offset.Ang.Forward )
	hand.Ang:RotateAroundAxis( hand.Ang:Up( ), self.Offset.Ang.Up )

	self:SetRenderOrigin( hand.Pos + offset )
	self:SetRenderAngles( hand.Ang )

	self:DrawModel( )
end

function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
end

function SWEP:PrimaryAttack()

	return
end

function SWEP:SecondaryAttack()

	return

end

function SWEP:Think()
	if(IsValid(self:GetOwner():GetEyeTrace().Entity) && self:GetOwner():GetEyeTrace().Entity:GetClass() == "sent_pot") then
		self:GetOwner():GetViewModel(0):SetPoseParameter("health_nail",self:GetOwner():GetEyeTrace().Entity:Health()/100)
		self:GetOwner():GetViewModel(0):SetPoseParameter("water_nail",self:GetOwner():GetEyeTrace().Entity:GetWaterAmount()/self:GetOwner():GetEyeTrace().Entity:GetMaxWater())
	else
		self:GetOwner():GetViewModel(0):SetPoseParameter("health_nail",0)
		self:GetOwner():GetViewModel(0):SetPoseParameter("water_nail",0)
	end
end

--addons/module_stungun/lua/weapons/stungun/cl_init.lua:

--[[
Stungun SWEP Created by Donkie (http://steamcommunity.com/id/Donkie/)
For personal/server usage only, do not resell or distribute!
]]

include("shared.lua")

SWEP.PrintName = "Тайзер"
SWEP.Slot = 1
SWEP.SlotPos = 1
SWEP.DrawAmmo = (not SWEP.InfiniteAmmo)
SWEP.DrawCrosshair = false

--[[
IN-HEAD VIEW
]]
net.Receive("tazestartview", function()
	local rag = net.ReadEntity()
	LocalPlayer().viewrag = rag
end)
net.Receive("tazeendview", function()
	LocalPlayer().viewrag = nil
end)

hook.Add("PlayerBindPress", "Tazer", function(ply,bind,pressed)
	if IsValid(ply:GetNWEntity("tazerviewrag")) and STUNGUN.Thirdperson and STUNGUN.AllowSwitchFromToThirdperson then
		if bind == "+duck" then
			if ply.thirdpersonview == nil then
				ply.thirdpersonview = false
			end

			ply.thirdpersonview = not ply.thirdpersonview
		end
	end
end)

local dist = 200
local view = {}
hook.Add("CalcView", "Tazer", function(ply, origin, angles, fov)
	local rag = ply:GetNWEntity("tazerviewrag")
	if IsValid(rag) then
		local bid = rag:LookupBone("ValveBiped.Bip01_Head1")
		if bid then
			local dothirdperson = false
			if STUNGUN.Thirdperson then
				if STUNGUN.AllowSwitchFromToThirdperson then
					dothirdperson = ply.thirdpersonview
				else
					dothirdperson = true
				end
			end

			if dothirdperson then
				local ragpos = rag:GetBonePosition(bid)

				local pos = ragpos - (ply:GetAimVector() * dist)
				local ang = (ragpos - pos):Angle()

				-- Do a traceline so he can't see through walls
				local trdata = {}
				trdata.start = ragpos
				trdata.endpos = pos
				trdata.filter = rag
				local trres = util.TraceLine(trdata)
				if trres.Hit then
					pos = trres.HitPos + (trres.HitWorld and trres.HitNormal * 3 or vector_origin)
				end

				view.origin = pos
				view.angles = ang
			else
				local pos,ang = rag:GetBonePosition(bid)
				pos = pos + ang:Forward() * 7
				ang:RotateAroundAxis(ang:Up(), -90)
				ang:RotateAroundAxis(ang:Forward(), -90)
				pos = pos + ang:Forward() * 1

				view.origin = pos
				view.angles = ang
			end

			view.drawviewer = false

			return view
		end
	end
end)

hook.Add("PreDrawViewModel", "Stungun", function(vm, ply, wep)
	if not IsValid(ply:GetNWEntity("tazerviewrag")) then return end
	
	return true
end)

--[[
Effects
]]
hook.Add("OnEntityCreated", "StungunRagdoll", function(ent)
	if ent:IsRagdoll() then
		local ply = ent:GetDTEntity(1)

		if IsValid(ply) and ply:IsPlayer() then
			-- Only copy any decals if this ragdoll was recently created
			if ent:GetCreationTime() > CurTime() - 1 then
				ent:SnatchModelInstance(ply)
			end

			-- Copy the color for the PlayerColor matproxy
			local playerColor = ply:GetPlayerColor()
			ent.GetPlayerColor = function()
				return playerColor
			end
		end
	end
end)

hook.Add("EntityRemoved", "StungunRagdoll", function(ent)
	if ent:IsRagdoll() then
		local ply = ent:GetDTEntity(1)

		if IsValid(ply) and ply:IsPlayer() then
			ply:SnatchModelInstance(ent)
		end
	end
end)

--[[
CROSSHAIR
]]

local col1 = Color(0,150,0,255)
local col2 = Color(150,0,0,255)
local w,h = ScrW(), ScrH()
local w2,h2 = w / 2, h / 2

local bolt1 = Material("icon72/zap.png")

function SWEP:DrawHUD()
	if LocalPlayer() != self:GetOwner() then return end -- Not sure why this would happen but you never know.
	-- Small delay so we don't spam the shit out of the player.
	if not self.trres or self.nexttr < CurTime() then
		self.trres = util.TraceLine(util.GetPlayerTrace(LocalPlayer()))
		self.nexttr = CurTime() + .05
	end

	local hit = self.trres.HitPos:Distance(LocalPlayer():GetShootPos()) <= self.Range and (IsValid(self.trres.Entity) and self.trres.Entity:IsPlayer())

	surface.SetDrawColor(hit and col1 or col2)

	local gap = (hit and 0 or 10) + 5
	local length = 10

	surface.DrawLine( w2 - length, h2, w2 - gap, h2 )
	surface.DrawLine( w2 + length, h2, w2 + gap, h2 )
	surface.DrawLine( w2, h2 - length, w2, h2 - gap )
	surface.DrawLine( w2, h2 + length, w2, h2 + gap )
	
    if self.Charge or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self.Charge, 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Заряд", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( bolt1 ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

function SWEP:Holster()
	return true
end

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)

	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:OnDrop()
	self:Holster()
end

net.Receive("tazerondrop",function()
	local swep = net.ReadEntity()
	if swep.OnDrop then swep:OnDrop() end
end)
--addons/module_css2/lua/weapons/swb_base/sh_move.lua:
--[[ 
local reg = debug.getregistry()
local GetActiveWeapon = reg.Player.GetActiveWeapon
local GetDTFloat = reg.Entity.GetDTFloat
local GetRunSpeed = reg.Player.GetRunSpeed
local GetWalkSpeed = reg.Player.GetWalkSpeed
local GetCrouchedWalkSpeed = reg.Player.GetCrouchedWalkSpeed
local Crouching = reg.Player.Crouching

local wep

function SWB_Move(ply, m)
	if Crouching(ply) then
		m:SetMaxSpeed(GetWalkSpeed(ply) * GetCrouchedWalkSpeed(ply))
	else
		wep = GetActiveWeapon(ply)
		
		if IsValid(wep) and wep.SWBWeapon then
			if wep.dt and wep.dt.State == SWB_AIMING then
				m:SetMaxSpeed(GetWalkSpeed(ply) * 0.75)
			else
				m:SetMaxSpeed((GetRunSpeed(ply) - wep.SpeedDec))
			end
		else
			m:SetMaxSpeed(GetRunSpeed(ply))
		end
	end
end

//hook.Add("Move", "SWB_Move", SWB_Move)
--]] 
--addons/module_css2/lua/weapons/swb_base/cl_calcview.lua:
local FT, CT, cos1, cos2, ws, vel, att, ang
local Ang0, curang, curviewbob = Angle(0, 0, 0), Angle(0, 0, 0), Angle(0, 0, 0)
local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local Right = reg.Angle.Right
local Up = reg.Angle.Up
local Forward = reg.Angle.Forward
local RotateAroundAxis = reg.Angle.RotateAroundAxis

SWEP.LerpBackSpeed = 10

function SWEP:CalcView(ply, pos, ang, fov)
	FT, CT = FrameTime(), CurTime()
	
	if self.ReloadViewBobEnabled then
		if self.IsReloading and self.Cycle <= 0.9 then
			att = self:GetOwner():GetAttachment(1)
			
			if att then
				ang = ang * 1
				
				self.LerpBackSpeed = 1
				curang = LerpAngle(FT * 10, curang, (ang - att.Ang) * 0.1)
			else
				self.LerpBackSpeed = math.Approach(self.LerpBackSpeed, 10, FT * 50)
				curang = LerpAngle(FT * self.LerpBackSpeed, curang, Ang0)
			end
		else
			self.LerpBackSpeed = math.Approach(self.LerpBackSpeed, 10, FT * 50)
			curang = LerpAngle(FT * self.LerpBackSpeed, curang, Ang0)
		end
		
		RotateAroundAxis(ang, Right(ang), curang.p * self.RVBPitchMod)
		RotateAroundAxis(ang, Up(ang), curang.r * self.RVBYawMod)
		RotateAroundAxis(ang, Forward(ang), (curang.p + curang.r) * 0.15 * self.RVBRollMod)
	end
	
	if self.dt.State == SWB_AIMING then
		if self.DelayedZoom then
			if CT > self.AimTime then
				if self.SnapZoom then
					self.CurFOVMod = self.ZoomAmount
				else
					self.CurFOVMod = Lerp(FT * 10, self.CurFOVMod, self.ZoomAmount)
				end
			else
				self.CurFOVMod = Lerp(FT * 10, self.CurFOVMod, 0)
			end
		else
			if self.SnapZoom then
				self.CurFOVMod = self.ZoomAmount
			else
				self.CurFOVMod = Lerp(FT * 10, self.CurFOVMod, self.ZoomAmount)
			end
		end
	else
		self.CurFOVMod = Lerp(FT * 10, self.CurFOVMod, 0)
	end
	
	fov = math.Clamp(fov - self.CurFOVMod, 5, 100)
	
	if self:GetOwner() then
		if self.ViewbobEnabled then
			ws = self:GetOwner():GetWalkSpeed()
			vel = Length(GetVelocity(self:GetOwner()))
			
			if self:GetOwner():OnGround() and vel > ws * 0.3 then
				if vel < ws * 1.2 then
					cos1 = math.cos(CT * 15)
					cos2 = math.cos(CT * 12)
					curviewbob.p = cos1 * 0.15
					curviewbob.y = cos2 * 0.1
				else
					cos1 = math.cos(CT * 20)
					cos2 = math.cos(CT * 15)
					curviewbob.p = cos1 * 0.25
					curviewbob.y = cos2 * 0.15
				end
			else
				curviewbob = LerpAngle(FT * 10, curviewbob, Ang0)
			end
		end
	end
	
	return pos, ang + curviewbob * self.ViewbobIntensity, fov
end

function SWEP.CreateMove(move)
	ply = LocalPlayer()
	wep = ply:GetActiveWeapon()
	
	if IsValid(wep) and wep.SWBWeapon then
		if wep.dt and wep.dt.State == SWB_AIMING and wep.AimBreathingEnabled then
			CT = CurTime()
			ang = move:GetViewAngles()
			ang.p = ang.p - math.cos(CT * 1.25) * 0.003
			
			move:SetViewAngles(ang)
		end
	end
end

hook.Add("CreateMove", "SWEP.CreateMove (SWB)", SWEP.CreateMove)

function SWEP:AdjustMouseSensitivity()
	if self.dt.State == SWB_RUNNING then
		if self.RunMouseSensMod then
			return self.RunMouseSensMod
		end
	end
	
	if self.dt.State == SWB_AIMING then
		if self.OverrideAimMouseSens then
			return self.OverrideAimMouseSens
		end
		
		return 1 - math.Clamp(self.ZoomAmount / 100, 0.1, 1)
	end
	
	return 1
end
--gamemodes/darkrp/entities/weapons/weapon_keypadchecker/cl_init.lua:
include("shared.lua")

local DrawData = {}
local KeypadCheckerHalos

net.Receive("DarkRP_keypadData", function(len)
    DrawData = net.ReadTable()
    hook.Add("PreDrawHalos", "KeypadCheckerHalos", KeypadCheckerHalos)
end)

local lineMat = Material("cable/chain")

function SWEP:DrawHUD()
    draw.WordBox(2, 10, ScrH() / 2, DarkRP.getPhrase("keypad_checker_shoot_keypad"), "UiBold", Color(0,0,0,120), Color(255, 255, 255, 255))
    draw.WordBox(2, 10, ScrH() / 2 + 20, DarkRP.getPhrase("keypad_checker_shoot_entity"), "UiBold", Color(0,0,0,120), Color(255, 255, 255, 255))
    draw.WordBox(2, 10, ScrH() / 2 + 40, DarkRP.getPhrase("keypad_checker_click_to_clear"), "UiBold", Color(0,0,0,120), Color(255, 255, 255, 255))

    local entMessages = {}
    for k,v in pairs(DrawData or {}) do
        if not IsValid(v.ent) or not IsValid(v.original) then continue end
        entMessages[v.ent] = (entMessages[v.ent] or 0) + 1
        local pos = v.ent:LocalToWorld(v.ent:OBBCenter()):ToScreen()

        local name = v.name and ": " .. v.name:gsub("onDown", DarkRP.getPhrase("keypad_on")):gsub("onUp", DarkRP.getPhrase("keypad_off")) or ""

        draw.WordBox(2, pos.x, pos.y + entMessages[v.ent] * 16, (v.delay and v.delay .. " " .. DarkRP.getPhrase("seconds") .. " " or "") .. v.type .. name, "UiBold", Color(0,0,0,120), Color(255, 255, 255, 255))

        cam.Start3D(EyePos(), EyeAngles())
            render.SetMaterial(lineMat)
            render.DrawBeam(v.original:GetPos(), v.ent:GetPos(), 2, 0.01, 20, Color(0, 255, 0, 255))
        cam.End3D()
    end
end

KeypadCheckerHalos = function()
    local drawEnts = {}
    for k,v in pairs(DrawData) do
        if not IsValid(v.ent) then continue end

        table.insert(drawEnts, v.ent)
    end

    if #drawEnts == 0 then return end
    halo.Add(drawEnts, Color(0, 255, 0, 255), 5, 5, 5, nil, true)
end

function SWEP:SecondaryAttack()
    DrawData = {}
    hook.Remove("PreDrawHalos", "KeypadCheckerHalos")
end

--addons/weapon_paint/lua/weapons/weapon_spraypaint/cl_init.lua:
include("shared.lua")
SWEP.DrawCrosshair = false
SWEP.WepSelectIcon = Material("mhstextures/selection_spraymhs.png")

local GraffitiColors = {'000000', 'FFFFFF', 'FF0000', '00FF00', '0000FF', 'FFFF00', 'FF00FF', '00FFFF', 'FFC800', 'FF9600', 'FF5000', '960096', '6400C8', '5000FF', '9BFF00'}

local tocolor = function(s)
    s = s:gsub("#", "")
    local r, g, b = tonumber("0x" .. s:sub(1, 2)), tonumber("0x" .. s:sub(3, 4)), tonumber("0x" .. s:sub(5, 6))
    if r and g and b then return Color(r, g, b) end
end

SWEP.VElements = {
    {
        type = "Model",
        model = "models/props_junk/propane_tank001a.mdl",
        bone = "ValveBiped.Bip01_L_Hand",
        rel = "",
        pos = Vector(-1.558, -4.676, 1.5),
        angle = Angle(66.623, 66.623, 87.662),
        size = Vector(0.4, 0.4, 0.4),
        color = Color(255, 255, 255, 255),
        material = "",
        skin = 0,
        bodygroup = {}
    }
}

SWEP.WElements = {
    {
        type = "Model",
        model = "models/props_junk/propane_tank001a.mdl",
        bone = "ValveBiped.Bip01_R_Hand",
        rel = "",
        pos = Vector(3.635, 1.5, 2.596),
        angle = Angle(0, -100, 180),
        size = Vector(0.36, 0.36, 0.36),
        color = Color(255, 255, 255, 255),
        material = "",
        skin = 0,
        bodygroup = {}
    }
}

SWEP.ViewModelBoneMods = {
    ["ValveBiped.Bip01_L_Finger1"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, 21.111, 0)
    },
    ["ValveBiped.Bip01_L_Finger11"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, 45.555, 0)
    },
    ["ValveBiped.base"] = {
        scale = Vector(0.009, 0.009, 0.009),
        pos = Vector(2.036, -6.853, 11.666),
        angle = Angle(0, 0, 0)
    },
    ["ValveBiped.Bip01_L_Finger02"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, -14.445, 0)
    },
    ["ValveBiped.Bip01_L_Forearm"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(-6.853, 6.48, 5.369),
        angle = Angle(-23.334, -1.111, 43.333)
    },
    ["ValveBiped.Bip01_L_Finger0"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, -30, -47.778)
    },
    ["ValveBiped.Bip01_L_Finger4"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(7.777, -23.334, -12.223)
    },
    ["ValveBiped.Bip01_L_Finger3"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, -12.223, -3.333)
    },
    ["ValveBiped.Bip01_L_Hand"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(-50, -56.667, 81.111)
    }
}

SWEP.Tooltips = {
    R = 'Place a new canvas',
    LeftClick = 'Paint',
    RightClick = 'Cycle paint color',
    Info = 'Hold \'Shift\' while painting to erase'
}

local a

function SWEP:InitCL()
    self.CurrentColor = 1
    self.VElements = a(self.VElements)
    self.WElements = a(self.WElements)
    self.ViewModelBoneMods = a(self.ViewModelBoneMods)
    self:CreateModels(self.VElements)
    self:CreateModels(self.WElements)
    local b = self:GetOwner()

    if IsValid(b) then
        local c = b:GetViewModel()

        if IsValid(c) then
            self:ResetBonePositions(c)
            c:SetColor(Color(255, 255, 255, 255))
        end
    end
end

function SWEP:ViewModelDrawn()
    self:CheckGraffiti()
    local c = self:GetOwner():GetViewModel()
    if not IsValid(c) then return end
    if not self.VElements then return end
    self:UpdateBonePositions(c)

    for d, e in ipairs(self.VElements) do
        local f = e.modelEnt
        local g = e.spriteMaterial
        if not e.bone then continue end
        if not IsValid(f) then continue end
        local h, i = self:GetBoneOrientation(self.VElements, e, c)
        if not h then continue end
        f:SetPos(h + i:Forward() * e.pos.x + i:Right() * e.pos.y + i:Up() * e.pos.z)
        i:RotateAroundAxis(i:Up(), e.angle.y)
        i:RotateAroundAxis(i:Right(), e.angle.p)
        i:RotateAroundAxis(i:Forward(), e.angle.r)
        f:SetAngles(i)
        local j = Matrix()
        j:Scale(e.size)
        f:EnableMatrix("RenderMultiply", j)

        if e.material == "" then
            f:SetMaterial("")
        elseif f:GetMaterial() ~= e.material then
            f:SetMaterial(e.material)
        end

        if e.skin and e.skin ~= f:GetSkin() then
            f:SetSkin(e.skin)
        end

        if e.bodygroup then
            for d, e in pairs(e.bodygroup) do
                if f:GetBodygroup(d) ~= e then
                    f:SetBodygroup(d, e)
                end
            end
        end

        render.SetColorModulation(e.color.r / 255, e.color.g / 255, e.color.b / 255)
        render.SetBlend(e.color.a / 255)
        f:DrawModel()
        render.SetBlend(1)
        render.SetColorModulation(1, 1, 1)
    end
end

function SWEP:DrawWorldModel()
    if not self.WElements then return end
    local b = self:GetOwner()

    if IsValid(b) then
        bone_ent = b
    else
        bone_ent = self
    end

    for d, e in ipairs(self.WElements) do
        local f = e.modelEnt
        local g = e.spriteMaterial
        if not IsValid(f) then continue end
        local h, i = self:GetBoneOrientation(self.WElements, e, bone_ent, e.bone and nil or "ValveBiped.Bip01_R_Hand")
        if not h then continue end
        f:SetPos(h + i:Forward() * e.pos.x + i:Right() * e.pos.y + i:Up() * e.pos.z)
        i:RotateAroundAxis(i:Up(), e.angle.y)
        i:RotateAroundAxis(i:Right(), e.angle.p)
        i:RotateAroundAxis(i:Forward(), e.angle.r)
        f:SetAngles(i)
        local j = Matrix()
        j:Scale(e.size)
        f:EnableMatrix("RenderMultiply", j)

        if e.material == "" then
            f:SetMaterial("")
        elseif f:GetMaterial() ~= e.material then
            f:SetMaterial(e.material)
        end

        if e.skin and e.skin ~= f:GetSkin() then
            f:SetSkin(e.skin)
        end

        if e.bodygroup then
            for d, e in pairs(e.bodygroup) do
                if f:GetBodygroup(d) ~= e then
                    f:SetBodygroup(d, e)
                end
            end
        end

        render.SetColorModulation(e.color.r / 255, e.color.g / 255, e.color.b / 255)
        render.SetBlend(e.color.a / 255)
        f:DrawModel()
        render.SetBlend(1)
        render.SetColorModulation(1, 1, 1)
    end
end

function SWEP:GetBoneOrientation(k, l, m, n)
    local o, h, i

    if l.rel and l.rel ~= "" then
        local e = k[l.rel]
        if not e then return end
        h, i = self:GetBoneOrientation(k, e, m)
        if not h then return end
        h = h + i:Forward() * e.pos.x + i:Right() * e.pos.y + i:Up() * e.pos.z
        i:RotateAroundAxis(i:Up(), e.angle.y)
        i:RotateAroundAxis(i:Right(), e.angle.p)
        i:RotateAroundAxis(i:Forward(), e.angle.r)
    else
        o = m:LookupBone(n or l.bone)
        if not o then return end
        h, i = Vector(0, 0, 0), Angle(0, 0, 0)
        local p = m:GetBoneMatrix(o)

        if p then
            h, i = p:GetTranslation(), p:GetAngles()
        end

        local b = self:GetOwner()

        if IsValid(b) and b:IsPlayer() and m == b:GetViewModel() and self.ViewModelFlip then
            i.r = -i.r
        end
    end

    return h, i
end

function SWEP:CreateModels(l)
    if not l then return end

    for d, e in ipairs(l) do
        if IsValid(e.modelEnt) then
            e.modelEnt:Remove()
        end

        if e.model and e.model ~= "" and (not IsValid(e.modelEnt) or e.createdModel ~= e.model) and string.find(e.model, ".mdl") and file.Exists(e.model, "GAME") then
            e.modelEnt = ClientsideModel(e.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)

            if IsValid(e.modelEnt) then
                e.modelEnt:SetPos(self:GetPos())
                e.modelEnt:SetAngles(self:GetAngles())
                e.modelEnt:SetParent(self)
                e.modelEnt:SetNoDraw(true)
                e.createdModel = e.model
            else
                e.modelEnt = nil
            end
        end
    end
end

function SWEP:RemoveModels(l)
    for d, e in ipairs(l) do
        if IsValid(e.modelEnt) then
            e.modelEnt:Remove()
        end
    end
end

local q
local r = false

function SWEP:UpdateBonePositions(c)
    if self.ViewModelBoneMods then
        if not c:GetBoneCount() then return end
        local s = self.ViewModelBoneMods

        if not r then
            q = {}

            for t = 0, c:GetBoneCount() do
                local u = c:GetBoneName(t)

                if self.ViewModelBoneMods[u] then
                    q[u] = self.ViewModelBoneMods[u]
                else
                    q[u] = {
                        scale = Vector(1, 1, 1),
                        pos = Vector(0, 0, 0),
                        angle = Angle(0, 0, 0)
                    }
                end
            end

            s = q
        end

        for d, e in pairs(s) do
            local o = c:LookupBone(d)
            if not o then continue end
            local v = Vector(e.scale.x, e.scale.y, e.scale.z)
            local w = Vector(e.pos.x, e.pos.y, e.pos.z)
            local x = Vector(1, 1, 1)

            if not r then
                local y = c:GetBoneParent(o)

                while y >= 0 do
                    local z = s[c:GetBoneName(y)].scale
                    x = x * z
                    y = c:GetBoneParent(y)
                end
            end

            v = v * x

            if c:GetManipulateBoneScale(o) ~= v then
                c:ManipulateBoneScale(o, v)
            end

            if c:GetManipulateBoneAngles(o) ~= e.angle then
                c:ManipulateBoneAngles(o, e.angle)
            end

            if c:GetManipulateBonePosition(o) ~= w then
                c:ManipulateBonePosition(o, w)
            end
        end
    else
        self:ResetBonePositions(c)
    end
end

function SWEP:ResetBonePositions(c)
    if not c:GetBoneCount() then return end

    for t = 0, c:GetBoneCount() do
        c:ManipulateBoneScale(t, Vector(1, 1, 1))
        c:ManipulateBoneAngles(t, Angle(0, 0, 0))
        c:ManipulateBonePosition(t, Vector(0, 0, 0))
    end
end

local A = Material("color")

function SWEP:CheckGraffiti()
    local B = LocalPlayer():GetEyeTrace()
    local b = self:GetOwner()

    if not IsValid(B.Entity) or B.Entity:GetClass() ~= "ent_graffiti" or not B.Entity.LocalPlayerOwned or B.Entity:GetPos():DistToSqr(LocalPlayer():GetShootPos()) > 40000 then
        b.HoveredGraffiti = nil
        b.HoveredGraffitiTrace = nil

        return
    end

    b.HoveredGraffiti = B.Entity
    b.HoveredGraffitiTrace = B
    b.HoveredGraffiti.CurrentColor = GraffitiColors[self.CurrentColor]

    if self.Painting then
        self:DrawGraffiti()
    end
end

function SWEP:PlaceCanvas()
    self.Placing = nil
    LocalPlayer().Placing = false
    local h, C = self:GetValidPlacement()

    if h then
        RunConsoleCommand("createGraffiti")
    end
end

function SWEP:DrawGraffiti()
    local b = self:GetOwner()
    if not IsValid(b.HoveredGraffiti) then return end
    local B = b.HoveredGraffitiTrace
    local D = 96
    local E = 256
    local F = b.HoveredGraffiti:WorldToLocal(B.HitPos)
    local G = -F.x + D * 0.5
    local H = -F.y + D * 0.5
    G = math.Round(G / D * E)
    H = math.Round(H / D * E)

    if G == 0 then
        G = 1
    end

    if H == 0 then
        H = 1
    end

    if G == E then
        G = E - 1
    end

    if H == E then
        H = E - 1
    end

    if b:KeyDown(IN_SPEED) then
        b.HoveredGraffiti:Erase(G, H)
    else
        b.HoveredGraffiti:Paint(G, H, GraffitiColors[self.CurrentColor])
    end
end

function SWEP:CreatePlacementHook()
    self.placementHook = true

    hook.Add("PostDrawTranslucentRenderables", "GraffitiPlacement", function()
        if not IsValid(self) then
            hook.Remove("PostDrawTranslucentRenderables", "GraffitiPlacement")
        end

        render.SetMaterial(A)
        self:GetValidPlacement()
    end)
end

function SWEP:RemovePlacementHook()
    if not self.placementHook then return end
    self.placementHook = nil
    hook.Remove("PostDrawTranslucentRenderables", "GraffitiPlacement")
end

local I = {
    {
        x = 100,
        y = 200
    },
    {
        x = 150,
        y = 100
    },
    {
        x = 200,
        y = 200
    },
    {
        x = 0,
        y = 0
    }
}

local J = math.pi / 15 * 2 * -1
local K = J * 0.5
local L = 150

local function M(t, N)
    t = t - 6.5
    local O = (ScrW() + math.sin((t - 1) * J - K) * L) * 0.5
    local P = (ScrH() + math.cos((t - 1) * J - K) * L) * 0.5
    local Q = (ScrW() + math.sin((t - 1) * J + K) * L) * 0.5
    local R = (ScrH() + math.cos((t - 1) * J + K) * L) * 0.5
    local S = (ScrW() + math.sin((t - 1) * J - K) * L * N) * 0.5
    local T = (ScrW() + math.sin((t - 1) * J + K) * L * N) * 0.5
    local U = (ScrH() + math.cos((t - 1) * J - K) * L * N) * 0.5
    local V = (ScrH() + math.cos((t - 1) * J + K) * L * N) * 0.5
    I[1].x = O
    I[1].y = P
    I[4].x = Q
    I[4].y = R
    I[2].x = S
    I[2].y = U
    I[3].x = T
    I[3].y = V
end

function SWEP:DrawHUD()
    if not self.CurrentColorSelectedTime or self.CurrentColorSelectedTime < SysTime() - 1 then return end
    local W = self.isSelectingColor and 0 or SysTime() - self.CurrentColorSelectedTime
    surface.SetAlphaMultiplier(1 - W / 1)
    draw.NoTexture()
    local X

    for t = 1, 15 do
        if t == self.CurrentColor then
            X = t - 1
            continue
        end

        M(t - 1, 1.75)
        surface.SetDrawColor(tocolor(GraffitiColors[t]))
        surface.DrawPoly(I)
    end

    M(X, 1.9)
    surface.SetDrawColor(tocolor(GraffitiColors[self.CurrentColor]))
    surface.DrawPoly(I)
    surface.SetAlphaMultiplier(1)

    if self.isSelectingColor then
        local Y, Z = input.GetCursorPos()
        surface.SetDrawColor(0, 0, 0)
        surface.DrawLine(ScrW() * 0.5, ScrH() * 0.5, Y, Z)
    end
end

function SWEP:PrimaryAttack()
    if not IsFirstTimePredicted() then return end
    self:SetNextPrimaryFire(CurTime() + 0.01)

    if not self.Placing then
        self.Painting = true
        LocalPlayer().Placing = true
    else
        self:PlaceCanvas()
        self:RemovePlacementHook()
    end
end

local function ColorToCMYK(col)
    local K = math.max(col.r, col.g, col.b)
    local k = 255 - K

    return (K - col.r) / K, (K - col.g) / K, (K - col.b) / K, k
end

local color_formats = {
    ["rgb"] = {
        tostring = function(c)
            return string.format("%s, %s, %s", c.r, c.g, c.b)
        end,
        tocolor = function(s)
            local r, g, b = s:match("([x.%x]+)[ ,]+([x.%x]+)[ ,]+([x.%x]+)")
            if r and g and b then return Color(r, g, b) end
        end
    },
    ["hex"] = {
        tostring = function(c)
            local col = string.format("%x", (c.r * 0x10000) + (c.g * 0x100) + c.b):upper()

            if string.len(col) ~= 6 then
                for k = 1, 6 - string.len(col) do
                    col = col .. '0'
                end
            end

            return col
        end,
        tocolor = function(s)
            s = s:gsub("#", "")
            local r, g, b = tonumber("0x" .. s:sub(1, 2)), tonumber("0x" .. s:sub(3, 4)), tonumber("0x" .. s:sub(5, 6))
            if r and g and b then return Color(r, g, b) end
        end
    },
    ["hsl"] = {
        tostring = function(c)
            local h, s, l = ColorToHSL(c)

            return string.format("%s, %s, %s", math.Round(h, 2), math.Round(s, 2), math.Round(l, 2))
        end,
        tocolor = function(s)
            local h, s, l = s:match("([x.%x]+)[ ,]+([x.%x]+)[ ,]+([x.%x]+)")
            if h and s and l then return HSLToColor(h, s, l) end
        end
    },
    ["hsv"] = {
        tostring = function(c)
            local h, s, v = ColorToHSV(c)

            return string.format("%s, %s, %s", math.Round(h, 2), math.Round(s, 2), math.Round(v, 2))
        end,
        tocolor = function(s)
            local h, s, v = s:match("([x.%x]+)[ ,]+([x.%x]+)[ ,]+([x.%x]+)")
            if h and s and v then return HSVToColor(h, s, v) end
        end
    },
    ["cmyk"] = {
        tostring = function(c)
            local c, m, y, k = ColorToCMYK(c)

            return string.format("%s, %s, %s, %s", math.Round(c, 1), math.Round(m, 1), math.Round(y, 1), math.Round(k, 1))
        end,
        tocolor = function(s)
            local c, m, y, k = s:match("([x.%x]+)[ ,]+([x.%x]+)[ ,]+([x.%x]+)[ ,]+([-x.%x]+)")
            if not (c and m and y and k) then return end
            local mk = 1 - k
            local r = 255 * (1 - c) * mk
            local g = 255 * (1 - m) * mk
            local b = 255 * (1 - y) * mk

            return Color(r, g, b)
        end
    }
}

function SWEP:SecondaryAttack()
    if not IsFirstTimePredicted() then return end
    self.isSelectingColor = true
    gui.EnableScreenClicker(true)
end

function SWEP:Think()
    if not IsFirstTimePredicted() then return end

    if self:GetOwner():KeyReleased(IN_ATTACK) or LocalPlayer().HoveredGraffiti == nil then
        self.Painting = nil
    end

    if self.isSelectingColor then
        if not input.IsMouseDown(MOUSE_RIGHT) then
            self.isSelectingColor = false
            gui.EnableScreenClicker(false)

            return
        end

        local Y, Z = input.GetCursorPos()
        local _ = Y - ScrW() * 0.5
        local a0 = Z - ScrH() * 0.5
        local a1 = math.atan2(_, a0) + math.pi * -1 + K
        local a2 = math.ceil(a1 / J)

        if a2 > 15 then
            a2 = 1
        end

        if input.IsMouseDown(MOUSE_LEFT) and a2 then
            self:OpenSettings(a2)
            self.isSelectingColor = false
            gui.EnableScreenClicker(false)

            return
        end

        self.CurrentColor = a2
        self.CurrentColorSelectedTime = SysTime()
    end
end

function SWEP:OpenSettings(colorid)
    local frame = vgui.Create('DFrame')
    frame:SetSize(400, 230)
    frame:Center()
    frame:SetTitle('Выбор цвета')
    frame:MakePopup()
    local fill = vgui.Create('Panel', frame)
    local cur = 'hex'
    fill:Dock(TOP)
    fill:SetTall(200)
    local cube = vgui.Create('DColorCube', fill)
    cube:Dock(FILL)
    cube:DockMargin(0, 0, 0, 6)
    local pann = vgui.Create('Panel', fill)
    pann:Dock(BOTTOM)
    local text = vgui.Create('DTextEntry', pann)
    text:Dock(FILL)
    local btns = {}

    for k, v in pairs(color_formats) do
        local btn = vgui.Create('DButton', pann)
        btn:Dock(LEFT)
        btn:SetText(string.upper(k))
        btn:DockMargin(0, 0, 6, 0)
        btn:SetWide(40)

        function btn:DoClick()
            cur = k
            text:SetValue(color_formats[k].tostring(cube:GetRGB()))

            for k, v in pairs(btns) do
                v:SetEnabled(cur ~= k)
            end
        end

        btns[k] = btn
    end

    local pip = vgui.Create('DImageButton', pann)
    pip:Dock(RIGHT)
    pip:DockMargin(4,0,0,0)
    pip:SetWide(22)
    pip:SetImage('icon72/round_pushpin.png')
    pip.DoClick = function()
        local b = self:GetOwner()
        if not IsValid(b.HoveredGraffiti) then return end
        local B = b.HoveredGraffitiTrace
        local D = 96
        local E = 256
        local F = b.HoveredGraffiti:WorldToLocal(B.HitPos)
        local G = -F.x + D * 0.5
        local H = -F.y + D * 0.5
        G = math.Round(G / D * E)
        H = math.Round(H / D * E)
    
        if G == 0 then
            G = 1
        end
    
        if H == 0 then
            H = 1
        end
    
        if G == E then
            G = E - 1
        end
    
        if H == E then
            H = E - 1
        end

        local pixel = b.HoveredGraffiti.Pixels[H*256+G]
        if not pixel then return end

        local col = color_formats['hex'].tocolor(pixel)
        cube:SetColor(col)
        cube:OnUserChanged(col)
    end

    timer.Simple(0, function()
        local col = color_formats['hex'].tocolor(GraffitiColors[colorid])
        cube:SetColor(col)
        cube:OnUserChanged(col)
        btns['hex']:DoClick()
    end)

    function cube:OnUserChanged(col)
        text:SetValue(color_formats[cur].tostring(col))
        GraffitiColors[colorid] = color_formats['hex'].tostring(col)
    end

    function text:OnEnter()
        local col = color_formats[cur].tocolor(self:GetValue())
        cube:SetColor(col)
        cube:OnUserChanged(col)
    end

    local picker = vgui.Create('DRGBPicker', fill)
    picker:Dock(LEFT)
    picker:SetWide(24)
    picker:DockMargin(0, 0, 6, 6)

    function picker:OnChange(col)
        local h = ColorToHSV(col)
        local _, s, v = ColorToHSV(cube:GetRGB())
        col = HSVToColor(h, s, v)
        cube:SetColor(col)
        cube:OnUserChanged(col)
    end
end

function SWEP:Reload()
    if not IsFirstTimePredicted() then return end
    self.Painting = nil
    self.Placing = true
    LocalPlayer().Placing = true
    self:CreatePlacementHook()
end

a = function(l)
    if not l then return nil end
    local a3 = {}

    for d, e in pairs(l) do
        if type(e) == "table" then
            a3[d] = a(e)
        elseif type(e) == "Vector" then
            a3[d] = e * 1
        elseif type(e) == "Angle" then
            a3[d] = e * 1
        else
            a3[d] = e
        end
    end

    return a3
end
--addons/weapon_vape/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onionstest"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Разрешено"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.ObjectPos = Vector(-8.5, -2.401, 27.377)
SWEP.ObjectAng = Angle(-160, 10.519, 0)

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.Unbreakable = false

SWEP.VapeID = 1

function SWEP:SetupDataTables()
	if self.Unbreakable then return end

	self:NetworkVar( "Int", 0, "Energy" )

	if SERVER then
		self:SetEnergy(100)
	end

end

local icon = Material( "icon72/dash.png" )

function SWEP:DrawHUD()
	if self.Unbreakable then return end

    if self:GetEnergy() or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self:GetEnergy(), 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Состояние", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( icon ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:Initialize()

	if !self.HandInitialize then
		self.HandInitialize = true
		self.VElements = {
			["object"] = { type = "Model", model = self.ViewModel, bone = "ValveBiped.Bip01_Spine4", rel = "", pos = self.ObjectPos, angle = self.ObjectAng, size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		self.ViewModel = "models/weapons/c_slam.mdl"
		self.UseHands = true
		self.ViewModelFlip = true
		self.ShowViewModel = true
		self.ShowWorldModel = true
		self.ViewModelBoneMods = {
			["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-23.334, -12.223, -32.223) },
			["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -21.112, 0) },
			["ValveBiped.Bip01_L_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -65.556, 0) },
			["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 72.222, -41.112) },
			["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(10, 1.11, -1.111) },
			["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-27.778, 1.11, -7.778) },
			["Slam_panel"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -47.778, 0) },
			["ValveBiped.Bip01_L_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -43.334, 0) },
			["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_R_Hand"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
		}
		
	end

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	if self.Initialize2 then self:Initialize2() end
end

function SWEP:PrimaryAttack()

	if SERVER then
		
		if not self.Unbreakable then

			if self:GetEnergy() < 1 then 
				if self.BreakCallback then self:BreakCallback() end
				self:Remove()
				return 
			end

			self:SetEnergy(self:GetEnergy() - 1)
		end

		VapeUpdate(self:GetOwner(), self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SetBreakCallback(f)
	self.BreakCallback = f
end

function SWEP:Holster()
	if SERVER and IsValid(self:GetOwner()) then
		ReleaseVape(self:GetOwner())
	end
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/weapon_wowozela/lua/weapons/wowozela.lua:
local SWEP = _G.SWEP or {
    Primary = {},
    Secondary = {}
}

if SERVER then
    AddCSLuaFile()
end

-- easylua.StartWeapon("wowozela")
SWEP.Base = "weapon_base"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Играть первый семпл"},
	{key = MOUSE_RIGHT, desc = "Играть второй семпл"},
	{key = KEY_R, desc = "Выбрать семплы"},
}
SWEP.PrintName = "Wowozela"
SWEP.Category = "Премиум"

SWEP.SlotPos = 1
SWEP.Slot = 1

SWEP.Spawnable = true

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = true
SWEP.HoldType = "normal"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.ViewModel = "models/weapons/v_hands.mdl"
SWEP.WorldModel = "models/weapons/w_bugbait.mdl"
SWEP.DrawWeaponInfoBox = true
SWEP.RenderGroup = RENDERGROUP_BOTH

function SWEP:SetupDataTables()
    self:NetworkVar("Int", 0, "NoteIndexLeft")
    self:NetworkVar("Int", 1, "NoteIndexRight")

    self:NetworkVar("Bool", 0, "Looping")
end

function SWEP:PrintWeaponInfo()
end

local mat = Material("particle/fire")

function SWEP:DrawWeaponSelection(x,y,w,h,a)
    surface.SetDrawColor(HSVToColor(RealTime() * 10, 1, 1))
    surface.SetMaterial(mat)
    surface.DrawTexturedRect(x,y-w / 6,w,w)
end

function SWEP:CanPrimaryAttack()
    return false
end

function SWEP:CanSecondaryAttack()
    return false
end

function SWEP:ShouldDropOnDie()
    return false
end

function SWEP:Reload()
    return false
end

function SWEP:Initialize()
    if self.SetWeaponHoldType then
        self:SetWeaponHoldType("normal")
    end

    self.CurrentPageIndex = 1
    self:SetNoteIndexLeft(1)
    self:SetNoteIndexRight(1)
    self:SetLooping(true)
end

if SERVER then
    function SWEP:OnDrop()
        self:Remove()
    end

    util.AddNetworkString("wowozela_pitch")

    net.Receive("wowozela_pitch", function(len, ply)
        ply.net_incoming_rate_count = nil
        ply.net_incoming_rate_count = nil

        local pitch = net.ReadFloat()

        ply.wowozela_real_pitch = pitch

        net.Start("wowozela_pitch", true)
            net.WriteEntity(ply)
            net.WriteFloat(pitch)
        net.SendOmit(ply)
    end)
end

if CLIENT then
    net.Receive("wowozela_pitch", function(len)
        local ply = net.ReadEntity()
        if not ply:IsValid() then return end
        local pitch = net.ReadFloat()

        ply.wowozela_real_pitch = pitch
    end)
end

local DisableUnlimitedPitch
local EnableUnlimitedPitch

if CLIENT then
    function DisableUnlimitedPitch(ply)

        if ply.wowozela_head_cb then
            ply:RemoveCallback("BuildBonePositions", ply.wowozela_head_cb)
            ply.wowozela_head_cb = nil
        end
    end

    function EnableUnlimitedPitch(ply)
        local sampler = wowozela.GetSampler(ply)
        if not sampler then return end

        if ply.wowozela_head_cb then return end

        ply.wowozela_head_cb = ply:AddCallback("BuildBonePositions", function(oply)
            local head = oply:LookupBone("ValveBiped.Bip01_Head1")

            if head then
                local m = oply:GetBoneMatrix(head)
                if m then
                    local pitch = math.NormalizeAngle(sampler:GetPlayerPitch() * -89)
                    local yaw = oply:EyeAngles().y

                    local vec = Angle(pitch, yaw):Forward() * 100

                    local ang = vec:AngleEx(Vector(0,0,-1)) + Angle(-90,0,-90)

                    if pitch > 90 then
                        ang.y = ang.y - 180
                        ang.p = -ang.p
                    elseif pitch < -90 then
                        ang.y = ang.y - 180
                        ang.p = -ang.p
                    end


                    m:SetAngles(ang)
                    ply:SetBoneMatrix(head, m)
                end
            end
        end)

    end
end

function SWEP:Deploy()
    self.Think = self._Think
    if CLIENT then
        self:LoadPages()
    end

    return true
end

function SWEP:Holster()
    if CLIENT then
        local ply = self:GetOwner()

        if ply.wowozela_head_cb then
            ply:RemoveCallback("BuildBonePositions", ply.wowozela_head_cb)
            ply.wowozela_head_cb = nil
        end
    end

    if not self:GetOwner():KeyDown(IN_RELOAD) then
        return true
    end
    return false
end


function SWEP:OnKeyEvent(key, press)
    if self.GetLooping == nil then return end
    if SERVER and key == IN_USE and press then
        if CurTime() - (self.LastUse or 0) <= 0.25 then return end
        self.LastUse = CurTime()

        local trace = self:GetOwner():GetEyeTrace()
        if trace.StartPos:DistToSqr(trace.HitPos) < 2500 then return end

        self:SetLooping(not self:GetLooping())
        self:GetOwner():ChatPrint(("Looping is now %s."):format(self:GetLooping() and "enabled" or "disabled"))
    end
end

function SWEP:_Think()
    if self:GetOwner() and self:GetOwner():IsValid() and self:GetOwner():GetViewModel():IsValid() then
        self:GetOwner():GetViewModel():SetNoDraw(true)
        self.Think = nil
    end
end

function SWEP:GetViewModelPosition(pos, ang)
    pos.x = 35575
    pos.y = 35575
    pos.z = 35575

    return pos, ang
end

/*
hook.Add("PlayerSwitchWeapon", "WowozelaDontSwap", function(ply, wep, newwep)
    if IsValid(wep) and wep:GetClass() == "wowozela" and
        (ply:KeyDown(IN_RELOAD) or ply:KeyDown(IN_ATTACK) or ply:KeyDown(IN_ATTACK2)) then
        return true
    end
end)
*/

if CLIENT then
    surface.CreateFont("WowozelaFont", {
        font = "Roboto Bk",
        size = 35,
        weight = 1000
    })

    surface.CreateFont("WowozelaFont2", {
        font = "Roboto Bk",
        size = 17,
        weight = 1000
    })

    surface.CreateFont("WowozelaTutorial", {
        font = "Roboto Bk",
        size = 24,
        weight = 1000
    })

    surface.CreateFont("WowozelaNoteSmall", {
        font = "Roboto Bk",
        size = 12,
        weight = 100
    })

    local left_mouse_button_tex = Material("gui/lmb.png")
    local right_mouse_button_tex = Material("gui/rmb.png")



    local function drawCircle(x, y, radius, seg)
        local cir = {}

        table.insert(cir, {
            x = x,
            y = y,
            u = 0.5,
            v = 0.5
        })
        for i = 0, seg do
            local a = math.rad((i / seg) * -360)
            table.insert(cir, {
                x = x + math.sin(a) * radius,
                y = y + math.cos(a) * radius,
                u = math.sin(a) / 2 + 0.5,
                v = math.cos(a) / 2 + 0.5
            })
        end

        local a = math.rad(0) -- This is needed for non absolute segment counts
        table.insert(cir, {
            x = x + math.sin(a) * radius,
            y = y + math.cos(a) * radius,
            u = math.sin(a) / 2 + 0.5,
            v = math.cos(a) / 2 + 0.5
        })

        surface.DrawPoly(cir)
    end

    local function drawWedge(cx, cy, inner_radius, outer_radius, start_angle, stop_angle, text, text_color)
        local cir = {}

        local a = math.rad(start_angle)
        table.insert(cir, {
            x = cx + math.sin(a) * inner_radius,
            y = cy + math.cos(a) * inner_radius,
            u = math.sin(a) / 2 + 0.5,
            v = math.cos(a) / 2 + 0.5
        })

        a = math.rad(start_angle)
        table.insert(cir, {
            x = cx + math.sin(a) * outer_radius,
            y = cy + math.cos(a) * outer_radius,
            u = math.sin(a) / 2 + 0.5,
            v = math.cos(a) / 2 + 0.5
        })

        a = math.rad(stop_angle)
        table.insert(cir, {
            x = cx + math.sin(a) * outer_radius,
            y = cy + math.cos(a) * outer_radius,
            u = math.sin(a) / 2 + 0.5,
            v = math.cos(a) / 2 + 0.5
        })

        a = math.rad(stop_angle)
        table.insert(cir, {
            x = cx + math.sin(a) * inner_radius,
            y = cy + math.cos(a) * inner_radius,
            u = math.sin(a) / 2 + 0.5,
            v = math.cos(a) / 2 + 0.5
        })

        local center_angle = (stop_angle + start_angle) / 2
        a = math.rad(center_angle)

        surface.SetTexture(0)
        surface.DrawPoly(cir)
        local radius = (outer_radius + inner_radius) / 2 - 7

        local align = TEXT_ALIGN_CENTER

        if center_angle > 15 and center_angle < 165 then
            align = TEXT_ALIGN_LEFT
        elseif center_angle > 195 and center_angle < 345 then
            align = TEXT_ALIGN_RIGHT
        end

        draw.TextShadow({
            text = text,
            color = text_color,
            pos = {cx + math.sin(a) * outer_radius * 1.05, cy + math.cos(a) * outer_radius * 1.05},
            xalign = align,
            yalign = TEXT_ALIGN_CENTER,
            font = "WowozelaFont2"
        }, 2)

        return cx + math.sin(a) * radius, cy + math.cos(a) * radius
    end

    function SWEP:LoadCustoms()
        local customsamples = {}

        for i, v in ipairs(self.Categories) do
            if v == "custom" then
                for k, sample in pairs(self.Pages[i]) do
                    if sample.custom then
                        customsamples[k] = {
                            sample.path,
                            sample.name
                        }
                    end
                end
            end
        end

        local cID = 4500 + LocalPlayer():EntIndex() * 15
        local missingOne = false
        for k, newsample in next, customsamples do
            if not wowozela.GetSamples()[cID + k] or wowozela.GetSamples()[cID + k].path ~= newsample[1]  or wowozela.GetSamples()[cID + k].path ~= newsample[2] then
                missingOne = true
            end
        end

        if missingOne then
            wowozela.RequestCustomSamplesIndexes(customsamples)
        end
    end
    function SWEP:LoadPages()

        if not wowozela.GetSample(1) then
            return
        end

        self.Categories = {"solo", "guitar", "voices", "bass", "drums", "horn", "animals", "polyphonic", "custom"}

        for k, v in ipairs(wowozela.GetSamples()) do
            if not table.HasValue(self.Categories, v.category) then
                table.insert(self.Categories, v.category)
            end
        end

        local defaultPage = wowozela.defaultpage and wowozela.defaultpage:GetString()
        if defaultPage and defaultPage ~= "" then
            for i, v in ipairs(self.Categories) do
                if defaultPage == v then
                    self.CurrentPageIndex = i
                end
            end
        end

        self.Pages = {}

        for i, category in ipairs(self.Categories) do
            self.Pages[i] = {}
            if category == "custom" then
                for i2 = 1, 10 do self.Pages[i][i2] = {} end
            end

            for k, v in ipairs(wowozela.GetSamples()) do
                if v.category == category then
                    table.insert(self.Pages[i], v)
                end
            end
        end

        if file.Exists("wowozela_custom_page.txt", "DATA") then
            for i, v in ipairs(self.Categories) do
                if v == "custom" then
                    self.Pages[i] = util.JSONToTable(file.Read("wowozela_custom_page.txt", "DATA"))

                    for i2 = 1, 10 do
                        if not self.Pages[i][i2] then
                            self.Pages[i][i2] = {}
                        end
                    end
                    self:LoadCustoms()
                    break
                end
            end
        end
    end

    concommand.Add("wowozela_reset_custom_page", function()
        file.Delete("wowozela_custom_page.txt", "DATA")
    end)

    function SWEP:GetNoteNameRight()
        local sample = wowozela.GetSample(self:GetNoteIndexRight())

        return sample and sample.name
    end

    function SWEP:GetNoteNameLeft()
        local sample = wowozela.GetSample(self:GetNoteIndexLeft())

        return sample and sample.name
    end

    function SWEP:GetPageNoteIndexLeft()
        local sample = wowozela.GetSample(self:GetNoteIndexLeft())
        if not sample then
            return
        end

        for i, v in pairs(self.Pages[self.CurrentPageIndex]) do
            if sample.path == v.path and sample.name == v.name then
                return i
            end
        end
    end

    function SWEP:GetPageNoteIndexRight()
        local sample = wowozela.GetSample(self:GetNoteIndexRight())
        if not sample then
            return
        end

        for i, v in pairs(self.Pages[self.CurrentPageIndex]) do
            if sample.path == v.path and sample.name == v.name  then
                return i
            end
        end
    end

    function SWEP:PageIndexToWowozelaIndex(page_index)

        local sample = self.Pages[self.CurrentPageIndex][page_index]

        if not sample then
            return
        end

        for i, v in pairs(wowozela.GetSamples()) do
            if sample.path == v.path and sample.name == v.name then
                if v.custom and v.owner ~= LocalPlayer():EntIndex() then continue end
                return i
            end
        end
    end

    local arrow_left_tex = Material("vgui/cursors/arrow")
    local circle_tex = Material("particle/particle_glow_02")

    local lastHttp
    local function play_non_looping_sound(self, isHttp, path)
        if isHttp then
            if IsValid(lastHttp) then
                lastHttp:Stop()
                lastHttp = nil
            end
            wowozela.PlayURL(path, "noplay", function(snd, _, err)
                if not snd or err then return end
                lastHttp = snd
                snd:SetVolume(wowozela.intvolume or 0.25)
                snd:Play()

                timer.Simple(1.5, function()
                    if IsValid(snd) then
                        snd:Stop()
                    end
                end)
            end)
            return
        end

        if self.preview_csp then
            self.preview_csp:Stop()
        end
        self.preview_csp = CreateSound(LocalPlayer(), path)
        self.preview_csp:PlayEx(0.1, 100)

        timer.Create("wowozela_preview", 1, 1, function()
            self.preview_csp:Stop()
        end)
    end

    local function draw_hud_text(x, y, hue, text, xalign)
        surface.SetFont("WowozelaFont")
        local w, h = surface.GetTextSize(text)

        do
            local s = 400
            local c = HSVToColor(hue, 1, 1)
            c.a = 50
            surface.SetMaterial(circle_tex)
            surface.SetDrawColor(c)

            surface.DrawTexturedRect(x - s / 2, y - s / 2, s, s)
        end

        draw.TextShadow({
            text = text,
            color = HSVToColor(hue, 0.75, 1),
            pos = {x - w / 2, y - h / 2},
            font = "WowozelaFont"
        }, 2, 200)
    end
    local function draw_lines(x, y, lines)
        local _, h = 0, 0
        for i = #lines, 1, -1 do
            local line = lines[i]
            w, h = draw.TextShadow({
                text = line,
                pos = {x, y - i * h - 64},
                xalign = TEXT_ALIGN_CENTER,
                yalign = TEXT_ALIGN_BOTTOM,
                font = "WowozelaTutorial",
                color = Color(255, 255, 255, 255)
            }, 2)
        end
    end

    local function draw_shadow(x, y, size)
        surface.SetMaterial(circle_tex)
        surface.SetDrawColor(0, 0, 0, 150)
        surface.DrawTexturedRect(x - size / 2, y - size / 2, size, size)
    end

    local function draw_mouse_icon(x, y, pressed, offset, tex)
        local icon_size = pressed and 32 or 16
        local w2, h2 = icon_size, icon_size

        offset = offset * (w2 / 4)

        x, y = x - w2 / 2, y - h2 / 2
        surface.SetMaterial(tex)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawTexturedRect(x - offset, y, w2, h2)
    end

    local left_down, right_down
    local show_help_text = true
    local freeze_mouse

    function SWEP:DrawHelp(center_x)
        if wowozela.help and not wowozela.help:GetBool() then return end
        local keyName = input.LookupBinding("+menu", true) or "<+menu not bound>"

        draw_lines(center_x, ScrH(),
            {"select a voice with your left or right mouse button", "find more samples by clicking < or >",
             self.Categories[self.CurrentPageIndex] == "custom" and
                ("press " .. keyName .. " while hovering over a sample to reassign it") or nil})
    end

    local function getHue(index)
        if wowozela.GetSamples()[index].custom then
            return util.CRC(wowozela.GetSamples()[index].path) % 360
        end
        return index / #wowozela.GetSamples() * 360
    end

    function SWEP:DrawWorldModel()
        return true
    end

    function SWEP:DrawWorldModelTranslucent()
        if IsValid(self:GetOwner()) then return true end
        local ang = (LocalPlayer():EyePos() - self:GetPos()):Angle()
        ang:RotateAroundAxis(ang:Right(), 90)

        local col = HSVToColor((CurTime() * 80) % 360, 1, 1)

        local size = 256 + math.sin(CurTime() * 2) * 48
        cam.Start3D2D(self:GetPos(), ang, 0.1)
            surface.SetMaterial(circle_tex)
            surface.SetDrawColor(col.r, col.g, col.b, 150)
            surface.DrawTexturedRect(size * -0.5, size * -0.5, size, size)
        cam.End3D2D()
    end

    local function get_selection(self)
        if self.Categories[self.CurrentPageIndex] ~= "custom" then return end
        local mouse_x, mouse_y = gui.MouseX(), gui.MouseY()
        local center_x, center_y = ScrW() / 2, ScrH() / 2

        local max = #self.Pages[self.CurrentPageIndex]

        local radians = math.atan2(mouse_y - center_y, center_x - mouse_x)
        local degrees = (math.deg(radians) - 90) % 360
        local wedge_step = 360 / max
        local mouse_far_enough = (Vector(center_x, center_y) - Vector(mouse_x, mouse_y)):Length2D()

        if mouse_far_enough < 32 or mouse_far_enough > 175 then
            mouse_far_enough = nil
        end

        for i = 1, max do
            local wedge_size = ((i - 1) / max)
            local wedge_angle = wedge_size * 360
            if degrees >= wedge_angle and degrees <= (wedge_angle + wedge_step) and mouse_far_enough then
                return {
                    left_pressed = left_down,
                    right_pressed = right_down,
                    index = i,
                    page = self.CurrentPageIndex,
                    name = self.Pages[self.CurrentPageIndex][i] and
                        self.Pages[self.CurrentPageIndex][i].name
                }
            end
        end
    end


    local col_white = Color(255, 255, 255, 255)
    local col_red = Color(255, 0, 0, 255)
    function SWEP:DrawHUD()
        if not self.Pages then
            self:LoadPages()
            return
        end

        local mouse_x, mouse_y = gui.MouseX(), gui.MouseY()
        local center_x, center_y = ScrW() / 2, ScrH() / 2

        if freeze_mouse and freeze_mouse.ref:IsValid() then
            mouse_x = freeze_mouse.x
            mouse_y = freeze_mouse.y
        end

        local time = RealTime()

        if input.IsMouseDown(MOUSE_LEFT) then
            left_down = left_down or time
        else
            left_down = nil
        end

        if input.IsMouseDown(MOUSE_RIGHT) then
            right_down = right_down or time
        else
            right_down = nil
        end

        local left_pressed = left_down == time
        local right_pressed = right_down == time

        local in_menu = self:GetOwner():KeyDown(IN_RELOAD)

        if show_help_text and (not wowozela.help or wowozela.help:GetBool()) then
            draw_lines(center_x, ScrH(), {"to select different sounds, hold " ..
                (input.LookupBinding("+reload", true) or "<+reload not bound>")})
        end

        if in_menu then
            show_help_text = false

            if not self.mouse_shown then
                input.SetCursorPos(center_x, center_y)
                gui.EnableScreenClicker(true)
                self.mouse_shown = true
            end

            local max = #self.Pages[self.CurrentPageIndex]

            local radians = math.atan2(mouse_y - center_y, center_x - mouse_x)
            local degrees = (math.deg(radians) - 90) % 360
            local wedge_step = 360 / max
            local hovered_wedge_index = nil
            local mouse_far_enough = (Vector(center_x, center_y) - Vector(mouse_x, mouse_y)):Length2D()

            if mouse_far_enough < 32 or mouse_far_enough > 175 then
                mouse_far_enough = nil
            end

            draw.NoTexture()
            surface.SetDrawColor(Color(100, 100, 100, 75))
            drawCircle(center_x, center_y, 36, max)

            draw.TextShadow({
                text = self.Categories[self.CurrentPageIndex],
                pos = {center_x, center_y},
                xalign = TEXT_ALIGN_CENTER,
                yalign = TEXT_ALIGN_CENTER,
                font = "WowozelaFont2",
                color = Color(255, 255, 255, 255)
            }, 2)

            self:DrawHelp(center_x)

            if self.Categories[self.CurrentPageIndex] == "custom" then
                max = 10
            end

            for index = 1, max do
                local sound_index = self:PageIndexToWowozelaIndex(index)
                local wedge_size = ((index - 1) / max)
                local wedge_angle = wedge_size * 360
                local col = sound_index and HSVToColor(getHue(sound_index), 0.75, 1) or Color(255, 255, 255, 255)
                local is_hovering = false

                if degrees >= wedge_angle and degrees <= (wedge_angle + wedge_step) and mouse_far_enough then
                    hovered_wedge_index = index
                    is_hovering = true
                end

                local left_selected = self:GetPageNoteIndexLeft() == index
                local right_selected = self:GetPageNoteIndexRight() == index

                if left_selected or right_selected then
                    is_hovering = true
                end

                local wedge_name = tostring(self.Pages[self.CurrentPageIndex][index] and
                                                self.Pages[self.CurrentPageIndex][index].name or "(unassigned)")

                surface.SetDrawColor(col)
                local x, y = drawWedge(center_x, center_y, 130, is_hovering and 150 or 140, wedge_angle,
                                 wedge_angle + wedge_step, wedge_name, is_hovering and col or nil)

                col.a = 50
                surface.SetDrawColor(col)
                drawWedge(center_x, center_y, 36, 130, wedge_angle, wedge_angle + wedge_step, "")

                if left_selected or right_selected then
                    draw_shadow(x, y, 64)
                end

                if left_selected then
                    draw_mouse_icon(x, y, left_down, not (left_selected and right_selected) and 0 or 1,
                        left_mouse_button_tex)
                end

                if right_selected then
                    draw_mouse_icon(x, y, right_down, not (left_selected and right_selected) and 0 or -1,
                        right_mouse_button_tex)
                end
            end

            if left_down or right_down then
                local sample_index = self:PageIndexToWowozelaIndex(hovered_wedge_index)
                if sample_index then
                    if left_pressed then
                        play_non_looping_sound(self, wowozela.GetSample(sample_index).custom, wowozela.GetSample(sample_index).path)
                        wowozela.SetSampleIndexLeft(sample_index)
                    end

                    if right_pressed then
                        play_non_looping_sound(self, wowozela.GetSample(sample_index).custom, wowozela.GetSample(sample_index).path)
                        wowozela.SetSampleIndexRight(sample_index)
                    end
                end
            end

            surface.SetDrawColor(255, 255, 255, 255)
            surface.SetMaterial(arrow_left_tex)

            local s = 32
            local distance = 275

            local left_x = center_x - distance
            local right_x = center_x + distance

            local hover_left = mouse_x < left_x + s / 2
            local hover_right = mouse_x > right_x - s / 2

            surface.SetMaterial(arrow_left_tex)

            do
                local s2 = hover_left and s * 1.5 or s
                if hover_left and left_down then
                    s2 = s2 * 1.5
                end
                surface.DrawTexturedRectRotated(left_x, center_y, s2, s2, 45)
            end

            do
                local s2 = hover_right and s * 1.5 or s
                if hover_right and left_down then
                    s2 = s2 * 1.5
                end
                surface.DrawTexturedRectRotated(right_x, center_y, s2, s2, 45 + 180)
            end

            -- surface.DrawTexturedRectRotated(left_x, center_y, w, h, 0)
            -- surface.DrawTexturedRectRotated(right_x, center_y, w, h, 180)

            if hover_left and left_pressed then
                self.CurrentPageIndex = self.CurrentPageIndex - 1
            end

            if hover_right and left_pressed then
                self.CurrentPageIndex = self.CurrentPageIndex + 1
            end

            if self.CurrentPageIndex <= 0 then
                self.CurrentPageIndex = #self.Pages
            end

            if self.CurrentPageIndex > #self.Pages then
                self.CurrentPageIndex = 1
            end

        else
            if self.mouse_shown then
                gui.EnableScreenClicker(false)
                self.mouse_shown = false
            end
        end

        if not LocalPlayer():ShouldDrawLocalPlayer() and (not wowozela.hudtext or wowozela.hudtext:GetBool()) then

            local hud_distance = 128

            local left_hue = getHue(self:GetNoteIndexLeft())
            local right_hue = getHue(self:GetNoteIndexRight())

            if left_down and not in_menu then

                local offset = 0

                if right_down and left_down then
                    offset = -hud_distance
                end

                draw_hud_text(ScrW() / 2 + offset, ScrH() / 2, left_hue, tostring(self:GetNoteNameLeft()))
            end

            if right_down and not in_menu then

                local offset = 0

                if right_down and left_down then
                    offset = hud_distance
                end

                draw_hud_text(ScrW() / 2 + offset, ScrH() / 2, right_hue, tostring(self:GetNoteNameRight()),
                    TEXT_ALIGN_RIGHT)
            end
        end

--[[
        local vol = GetConVar("wowozela_volume")
         if vol and vol:GetFloat() <= 0.01 then
            draw.SimpleText("Warning your wowozela_volume is set to 0!", "WowozelaFont", center_x, ScrH() - 10,
                Color(255, 255, 255, 150), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
        end--]] 

        if wowozela.pitchbar and wowozela.pitchbar:GetBool() then
            local perSeg = 15
            local scale = (ScrH() / 3) / 10

            surface.SetDrawColor(0, 0, 0, 100)
            surface.DrawRect(ScrW() - 18, ScrH() * 1 / 3 + 12, 18, ScrH() * 1 / 3 - 24)
            local curr_pitch = (LocalPlayer().wowozela_real_pitch or 0) * -1
            local offset = (curr_pitch % perSeg)
            local offsetScale = offset / perSeg
            local currOctave = (curr_pitch - offset) / perSeg
            for I = -5, 4, 0.5 do
                local lineY = center_y + (I + offsetScale) * scale
                col_white.a = 255 * (1 - math.min(math.abs(I + offsetScale) / 4.5, 1))
                col_red.a = col_white.a

                surface.SetDrawColor((currOctave - I) % (90 / perSeg) == 0 and col_red or col_white)
                surface.DrawLine(ScrW() - (I % 1 == 0.5 and 7.5 or 15), lineY, ScrW(), lineY)
            end

            surface.SetDrawColor(Color(0, 255, 55, 120))
            surface.DrawLine(ScrW() - 18, center_y, ScrW(), center_y)
            draw.TextShadow({
                text = ("%0.01f"):format(curr_pitch),
                color = Color(255, 255, 255, 255),
                pos = {ScrW() - 19, center_y},
                xalign = TEXT_ALIGN_RIGHT,
                yalign = TEXT_ALIGN_CENTER,
                font = "WowozelaNoteSmall"
            }, 1)
        end
    end

    timer.Create("wowozela_head_turn", 0.5, 0, function()
        for _, ply in player.Iterator() do
            local wep = ply:GetActiveWeapon()
            if not IsValid(wep) or wep:GetClass() ~= "wowozela" then
                DisableUnlimitedPitch(ply)
            else
                EnableUnlimitedPitch(ply)
            end
        end
    end)

    local cx, cy = 0, 0
    local upsidedown = false

    hook.Add("InputMouseApply", "wowozela_unlocked_pitch", function(cmd, x, y, ang)
        local ply = LocalPlayer()
        local wep = ply:GetActiveWeapon()
        if not wep:IsValid() or wep:GetClass() ~= "wowozela" then
            DisableUnlimitedPitch(ply)
            return
        end

        EnableUnlimitedPitch(ply)

        local m_pitch = GetConVar("m_pitch") and GetConVar("m_pitch"):GetFloat() or 0.022
        local m_yaw = GetConVar("m_yaw") and GetConVar("m_yaw"):GetFloat() or 0.022

        if upsidedown then
            x = -x
        end

        cx = cx + x * m_yaw
        cy = cy + y * m_pitch

        local rcy = cy
        if ply:KeyDown(IN_SPEED) then
            rcy = rcy / 90 -- -1 to 1
            rcy = (rcy + 1) / 2 -- 0 to 1
            rcy = rcy * 12 -- 0 to 12
            rcy = math.Round(rcy * 2) / 2 -- rounded
            rcy = rcy / 12
            rcy = (rcy * 2) - 1

            rcy = rcy * 90
        end


        ang = Angle(rcy, -cx, ang.r)
        ang.p = math.NormalizeAngle(ang.p)

        local max = GetConVar("cl_pitchup") and GetConVar("cl_pitchup"):GetFloat() or 89
        local min = GetConVar("cl_pitchdown") and GetConVar("cl_pitchdown"):GetFloat() or 89

        if ang.p >= max then
            upsidedown = true
        elseif ang.p <= -min then
            upsidedown = true
        else
            upsidedown = false
        end

        local pitch_offset = Angle(0,0,0)

        if upsidedown then
            ang.p = math.NormalizeAngle(ang.p + 180)
            pitch_offset.p = -180
            pitch_offset.y = 0
        end

        cmd:SetViewAngles(ang + pitch_offset)

        if ply.wowozela_real_pitch ~= rcy then
            net.Start("wowozela_pitch", true)
            net.WriteFloat(rcy)
            net.SendToServer()
            --print("sending")
            ply.wowozela_real_pitch = rcy
        end

        return true
    end)
    local function getFileName(inputURL)
        local parts = string.Split(inputURL, "/")
        local filename = string.Split(parts[#parts], ".")[1]
        return filename:gsub("%%([A-Fa-f0-9][A-Fa-f0-9])", function(m)
            local n = tonumber(m, 16)
            if not n then return "" end
            return string.char(n)
        end)
    end

    local searchForName
    searchForName = function(pageTbl, currentSlot, filename)
        local found = false
        for k,v in pairs(pageTbl) do
            if v.name == filename and k ~= currentSlot then
                filename = filename .. "2"
                found = true
            end
        end
        if found then
            return searchForName(pageTbl, currentSlot, filename)
        else
            return filename
        end
    end


    local function openSoundSelector(wep, selection2)
        if not selection2 then return end

        local Menu = DermaMenu()
        local submenus = {}
        for _, data in ipairs(wowozela.GetSamples()) do
            local category = data.category

            submenus[category] = submenus[category] or Menu:AddSubMenu(category)
        end

        for _, data2 in ipairs(wowozela.GetSamples()) do
            submenus[data2.category]:AddOption(data2.name, function()
                wep.Pages[selection2.page][selection2.index] = data2
                file.Write("wowozela_custom_page.txt",
                    util.TableToJSON(wep.Pages[selection2.page], true))
                wep:LoadPages()
                play_non_looping_sound(wep, false, data2.path)
            end)
        end

        local function soundError(reason)
            LocalPlayer():ChatPrint(("Unable to load sound: %s"):format(reason))
        end
        Menu:AddOption("custom...", function()
            Derma_StringRequest("Sound (Mp3/Ogg)", "Insert a web-hosted ogg or mp3.\n(GitHub, Vocaroo, Dropbox, Puush, Google Drive or similar sites)", "", function(text)
                local subtext = nil
                text, subtext = wowozela.ProcessURL(text)
                if text:sub(1, 4) ~= "http" then return end

                if text:sub(1, 19) == "https://github.com/" and text:sub(-9) ~= "?raw=true" then
                    text = text .. "?raw=true"
                end

                text = text:gsub(" ", "%%20")
                local filename = getFileName(subtext or text)
                wowozela.PlayURL(text, "noplay", function(snd, _, err)
                    if not snd or err then soundError("Invalid Ogg/Mp3!") return end
                    lastHttp = snd
                    snd:SetVolume(wowozela.intvolume or 0.25)
                    snd:Play()

                    timer.Simple(1.5, function()
                        if not IsValid(snd) then return end
                        snd:Stop()
                    end)

                    filename = searchForName(wep.Pages[selection2.page], selection2.index, filename)
                    wep.Pages[selection2.page][selection2.index] = {
                        category = "",
                        custom = "true",
                        name = filename,
                        path = text
                    }
                    file.Write("wowozela_custom_page.txt", util.TableToJSON(wep.Pages[selection2.page], true))
                    wep:LoadPages()
                end, function(reason)
                    soundError(reason)
                end)
            end)
        end)

        if wep.Pages[selection2.page][selection2.index] and wep.Pages[selection2.page][selection2.index].custom then
            Menu:AddSpacer()
            Menu:AddOption("rename...", function()
                Derma_StringRequest("New Name?", "", wep.Pages[selection2.page][selection2.index].name, function(text)
                    wep.Pages[selection2.page][selection2.index].name = text
                    file.Write("wowozela_custom_page.txt", util.TableToJSON(wep.Pages[selection2.page], true))
                    wep:LoadCustoms()
                end)
            end)
        end
        Menu:Open()

        freeze_mouse = {
            ref = Menu,
            x = gui.MouseX(),
            y = gui.MouseY()
        }
    end
    hook.Add("PlayerBindPress", "WowozelaBindPress", function(ply, bind, pressed)
        local wep = ply:GetActiveWeapon()
        if IsValid(wep) and wep:GetClass() == "wowozela" then
            local num = tonumber(bind:match("slot(%d+)"))
            if num == 0 then
                num = 10
            end

            if ply:KeyDown(IN_RELOAD) then
                if bind:find("+menu") and pressed then
                    openSoundSelector(wep, get_selection(wep))
                end

                if num and pressed and wep.Pages and wep.Pages[num] then
                    wep.CurrentPageIndex = num
                end
                return true
            elseif (ply:KeyDown(IN_ATTACK) or ply:KeyDown(IN_ATTACK2)) and num and pressed then
                local sample_index = wep:PageIndexToWowozelaIndex(num)
                if sample_index and ply:KeyDown(IN_ATTACK) then
                    wowozela.SetSampleIndexLeft(sample_index)
                end
                if sample_index and ply:KeyDown(IN_ATTACK2) then
                    wowozela.SetSampleIndexRight(sample_index)
                end

                return true
            end
        end
    end)
end

if not _G.SWEP then
    weapons.Register(SWEP, "wowozela")
end

--addons/module_css2/lua/weapons/wrp_weapon_fal/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-3.54, -6, 2.22)
	SWEP.AimAng = Vector(1.24, 0.04, 0.4)
	
	SWEP.SprintPos = Vector(0, 0, -0.7)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "FN Fal"

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 7.62
SWEP.CaseLength = 39

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"3burst", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/tak/f3/c_r91.mdl"
SWEP.WorldModel = "models/tak/f3/w_r91.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 20
SWEP.Primary.DefaultClip = 60
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.11
SWEP.FireSound = Sound("tak/weapons/fallout/r91/fire_mono.wav")
SWEP.Recoil = 0.45

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.0005
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 70
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/wrp_weapon_mosin/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-4.494, -4, 2.5)
	SWEP.AimAng = Vector(0, 0, 0)

	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "Винтовка Мосина"


SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 40
SWEP.BulletDiameter = 8.58
SWEP.CaseLength = 69.20

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.CanPenetrate = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Премиум"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/c_mosin.mdl"
SWEP.WorldModel = "models/weapons/w_mosin.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 5
SWEP.Primary.DefaultClip = 15
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 1.5
SWEP.FireSound = Sound("weapons/l4d2_rocky_mosin/gunfire/scout_fire-1.wav")
SWEP.Recoil = 4

SWEP.HipSpread = 0.06
SWEP.AimSpread = 0.0001
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 150
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/wrp_weapon_outbreak/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.CrosshairEnabled = true
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector (-4.68, -2.0031, 1)
	SWEP.AimAng = Vector (-0.3, 0.02, 0)
	
	SWEP.SprintPos = Vector(9.071, 0, 1.6418)
	SWEP.SprintAng = Vector(-12.9765, 26.8708, 0)
	
	SWEP.IconLetter = "a"
	SWEP.IconFont = "WeaponIcons"
	
	SWEP.MuzzleEffect = "swb_rifle_med"
end

SWEP.PrintName = "Outbreak"

SWEP.FadeCrosshairOnAim = true

SWEP.Base = 'swb_base'
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 15
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.BulletDisplay = 0

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "3burst", "semi", "safe"}
SWEP.Category = "Премиум"

SWEP.Author			= "kenzou power"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 60
SWEP.ViewModel			= "models/weapons/outbreak/c_outbreak.mdl"
SWEP.WorldModel			= "models/weapons/outbreak/w_outbreak.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 36
SWEP.Primary.Reload 		= Sound("Weapon_Outbreak.Reload")
SWEP.Primary.DefaultClip	= 108
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.06
SWEP.FireSound = Sound("Weapon_Outbreak.Single")
SWEP.Recoil = 0.65

SWEP.HipSpread = 0.01
SWEP.AimSpread = 0.004
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 28
SWEP.DeployTime = 1

sound.Add( {
    name = "Weapon_Outbreak.Single",
    channel = CHAN_AUTO,
    volume = 1,
    level = SNDLVL_NORM,
    sound =  "weapons/outbreak_semi.wav"
} )

sound.Add( {
    name = "Weapon_Outbreak.Reload",
    channel = CHAN_AUTO,
    volume = 1,
    level = SNDLVL_NORM,
    sound =  "outbreakreload.wav"
} )

game.AddParticles( "particles/Outbreak_siva3.pcf" )
game.AddParticles( "particles/Outbreak_siva.pcf" )
game.AddParticles( "particles/Outbreak_siva2.pcf" )
game.AddParticles( "particles/Outbreak_muzzle.pcf" )
game.AddParticles( "particles/Outbreak_nanite.pcf" )
--addons/module_bank/lua/entities/bank_car/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.PrintName = 'Машина для денег'
ENT.Author = 'WayZer\'s Role Play'
ENT.Category = 'Запрещено'
ENT.Spawnable = true
ENT.AdminSpawnable = true
--addons/ent_bitcoinpc/lua/entities/bit_cornet/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/ent_bitcoinpc/lua/entities/bit_graphiccard/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Graphic Card"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Point" )
end
--addons/ent_bitcoinpc/lua/entities/bit_harddisk/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Harddisk"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Point" )
end

--addons/module_bitminers2/lua/entities/bm2_bitminer_2/cl_init.lua:
include("shared.lua")

local function __round(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end

//Animate fan(s)
function ENT:Think()
	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then 
    self:SetNextClientThink( CurTime() + 1 )
    return true
	end

	if self:GetIsMining() then
		self.fanAng = self.fanAng + (FrameTime() * 400)
		for i = 0 , self:GetBoneCount() - 1 do
			if string.match( self:GetBoneName(i), "fan" ) ~= nil then
				self:ManipulateBoneAngles(i,Angle(self.fanAng,0,0))
			end
		end
	end 

	if self.prev ~= self:GetIsMining() then
		self:DestroyShadow()
		self:CreateShadow()
	end

	self.prev = self:GetIsMining()
	self:SetNextClientThink(CurTime() + 0.3)
	return true
end 

//Yuck I know but its to much effort to re-write the entire system
function ENT:Initialize()
	self.fanAng = 0
	self.prev = false

	//So each bitminer can have its own set of unique instructions. This is how we will do that
	self.customInstructions = {
		status = { //Outputs usefull runtime infomation
			command = "STATUS",
			description = "Выводит полезную информацию о текущем устройстве.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				consoleDisplay.history = consoleDisplay.history.."\n------------------STATUS------------------\n"
				local firstPart = "Работает                               "
				local secondPart = string.upper(tostring(ent:GetIsMining()))
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				firstPart = "Питание подключено                                 "
				secondPart = string.upper(tostring(ent:GetHasPower()))
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				consoleDisplay.history = consoleDisplay.history.."------------------------------------------\n\n"
			end
		},
		info = {
			command = "INFO",
			description = "Выводит дополнительную информацию о текущем устройстве.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				consoleDisplay.history = consoleDisplay.history.."\n-------------------INFO------------------\n"
				local firstPart = "ТАКТОВАЯ ЧАСТОТА                             "
				local secondPart = tostring(__round(ent:GetClockSpeed(), 3)).."Ghz"
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				local firstPart = "ЯДРА                                    "
				local secondPart = ent:GetCoreCount()
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				consoleDisplay.history = consoleDisplay.history.."ТРЕБУЕТ МОЩНОСТЬ                    100W\n"
				consoleDisplay.history = consoleDisplay.history.."НАЗВАНИЕ                    Bitminer S1\n"
				local playerName = self:Getowning_ent()
				if playerName ~= NULL then playerName = playerName:Name() else playerName = "Unknown" end
				consoleDisplay.history = consoleDisplay.history..string.sub("ВЛАДЕЛЕЦ                                    ", 1, string.len("ВЛАДЕЛЕЦ                                    ") - string.len(playerName))..playerName.."\n"
				consoleDisplay.history = consoleDisplay.history.."-----------------------------------------\n\n"
			end
		},
		mining = {
			command = "MINING",
			description = "Начинает или останавливает добычу.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == nil then
					consoleDisplay.history = consoleDisplay.history.."Для использования этой команды, пожалуйста, введите один из следующих аргументов: 'mining start' или 'mining stop'\n"
				elseif arg1 == "start" then
					net.Start("BM2.Command.Mining")
						net.WriteEntity(ent)
						net.WriteBool(true)
					net.SendToServer()
				elseif arg1 == "stop" then
					net.Start("BM2.Command.Mining")
						net.WriteEntity(ent)
						net.WriteBool(false)
					net.SendToServer()
				else
					consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' не является допустимой опцией, введите 'mining start' или 'mining stop'\n"
				end
			end
		},
		bitcoin = { //Used for selling or getting info about bitcoins
			command = "BITCOIN",
			description = "Позволяет вам продавать или видеть информацию о сохраненных биткойнах.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == "info" then
					consoleDisplay.history = consoleDisplay.history.."\n-------------------BITCOIN------------------\n"
					local firstPart = "Количество Биткойнов                              "
					local secondPart = comma_value(__round(ent:GetBitcoinAmount(), 2)).."btc"
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					firstPart =	"Значение Биткойнов ($)                           "
					secondPart = tostring(comma_value(__round(ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2)))
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					consoleDisplay.history = consoleDisplay.history.."--------------------------------------------\n\n"
				elseif arg1 == "sell" then
					net.Start("BM2.Command.SellBitcoins")
						net.WriteEntity(ent)
					net.SendToServer()
					local firstPart =	"Из                                        "
					local secondPart = tostring(comma_value(__round(ent:GetBitcoinAmount(), 2))).."btc"
					consoleDisplay.history = consoleDisplay.history.."\n-------------------RECEIPT------------------\n"
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					firstPart =	"Конвертировано в                               "
					secondPart = "$"..tostring(comma_value(__round(ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2)))
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					consoleDisplay.history = consoleDisplay.history.."Деньги были переведены на ваш кошелек\n"
					consoleDisplay.history = consoleDisplay.history.."--------------------------------------------\n\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history.."Чтобы использовать эту команду, пожалуйста, укажите один из следующих аргументов: 'bitcoin info' или 'bitcoin sell'\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' не является допустимой опцией, введите 'bitcoin info' или 'bticoin sell'\n"
					end
				end
			end
		},
		upgrade = { //Used for selling or getting info about bitcoins
			command = "UPGRADE",
			description = "Показывает доступные обновления и позволяет их приобрести.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == "1" then //CPU
					net.Start("BM2.Command.Upgrade")
					net.WriteEntity(ent)
					net.WriteBool(false)
					net.SendToServer()
				elseif arg1 == "2" then //Cores
					net.Start("BM2.Command.Upgrade")
					net.WriteEntity(ent)
					net.WriteBool(true)
					net.SendToServer()
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history.."\n-------------------UPGRADES------------------\n"
						local i = 0

						if self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1] ~= nil then
							i = i + 1
							firstPart =	"[1] "..self.upgrades.CPU.name.."                                                              "
							secondPart = "                                             "
							thirdtPart = "$"..comma_value(self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1])
							local str = string.sub(firstPart, 0, string.len(secondPart))
							consoleDisplay.history = consoleDisplay.history..string.sub(str, 1, string.len(str) - string.len(thirdtPart))..thirdtPart.."\n"
						end

						if self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1] ~= nil then
							i = i + 1 
							firstPart =	"[2] "..self.upgrades.CORES.name.."                                                              "
							secondPart = "                                             "
							thirdtPart = "$"..comma_value(self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1])
							local str = string.sub(firstPart, 0, string.len(secondPart))
							consoleDisplay.history = consoleDisplay.history..string.sub(str, 1, string.len(str) - string.len(thirdtPart))..thirdtPart.."\n"
						end

						if i == 0 then
							consoleDisplay.history = consoleDisplay.history.."Это устройство больше не нуждается в обновлениях\n"
						end

						consoleDisplay.history = consoleDisplay.history.."---------------------------------------------\nНаберите 'upgrade 1' или 'upgrade 2', чтобы выбрать обновление.\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' является не допустимой опцией, введите 'upgrade 1' или 'upgrade 2'\n"
					end
				end
			end
		},
	} 


	--Only add if DLC is loaded
	if BITMINERS_2_EXTRAS_DLC then
		self.customInstructions.remote = {
			command = "REMOTE",
			description = "Позволяет вам устанавливать, удалять и изменять имя модуля удаленного доступа, который позволит вам получить удаленный доступ к битминеру, используя "..BM2EXTRACONFIG.RemoteAccessCommand..". Установка его стоит $"..string.Comma(BM2EXTRACONFIG.RemoteAccessPrice)..".",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == "install" then
					net.Start("BM2.Command.RemoteInstall")
					net.WriteEntity(ent)
					net.WriteBool(true)
					net.SendToServer()
					ent.remoteName = math.random(10,99).."."..math.random(100,800).."."..math.random(10,99).."."..math.random(100,800)
				elseif arg1 == "remove" then
					net.Start("BM2.Command.RemoteInstall")
					net.WriteEntity(ent)
					net.WriteBool(false)
					net.SendToServer()
				elseif arg1 == "setname" then
					local _string = arg2 or math.random(10,99).."."..math.random(100,800).."."..math.random(10,99).."."..math.random(100,800)
					ent.remoteName = _string
					consoleDisplay.history = consoleDisplay.history.."Удаленное имя изменено на '".._string.."'\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history.."---------------------------------------------\nВведите 'REMOTE INSTALL' для установки удаленного модуля. Установка стоит $"..string.Comma(BM2EXTRACONFIG.RemoteAccessPrice).." и позволяет работать с битмайнером по удаленному доступу используя "..BM2EXTRACONFIG.RemoteAccessCommand.."\nВведите 'REMOTE REMOVE' для удаления удаленного доступа.\nВведите 'REMOTE SETNAME ExampleName' чтобы изменить удаленное имя битмайнера. Имя не должно содержать пробелов!\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' не является допустимой, опциями являются 'install', 'setname' или 'remove'\n"
					end
				end
			end
		}
	end
end

function ENT:Draw()
	self:DrawModel()
end
--addons/module_bitminers2/lua/entities/bm2_bitminer_2/shared.lua:
ENT.Type = "anim"

ENT.PrintName = "Bitminer 2"
ENT.Spawnable = true
ENT.Category = "Запрещено"

ENT.upgrades = {
	CPU = {name = "CPU Speed +256MHz", cost = {2000,4000,8000,16000,320000, 64000, 128000}, amountPerUpgrade = 0.256},
	CORES = {name = "Adds an extra core", cost = {50000, 10000, 175000}}
}

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "HasPower" )
	self:NetworkVar( "Bool", 2, "IsOn")
	self:NetworkVar( "Bool", 3, "IsMining")
	self:NetworkVar( "Float", 1, "BitcoinAmount")
	self:NetworkVar( "Int", 1, "CPUUpgrade")
	self:NetworkVar( "Int", 2, "CoreUpgrade")  
	self:NetworkVar( "Float", 3, "ClockSpeed")
	self:NetworkVar( "Int", 4, "CoreCount")
	//A string table of all the updates that have been purchased.
	self:NetworkVar( "String", 1, "Updates") 
	self:NetworkVar("Entity", 0, "owning_ent")
end


--addons/module_bitminers2/lua/entities/bm2_bitminer_rack/cl_init.lua:
include("shared.lua")

local function __round(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end

//Animate fan(s)
function ENT:Think()
	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then 
    self:SetNextClientThink( CurTime() + 1 )
    return true
	end
	
	if self:GetIsMining() then
		self.fanAng = self.fanAng + (FrameTime() * 400)
		for i = 0 , self:GetBoneCount() - 1 do
			if string.match( self:GetBoneName(i), "fan" ) ~= nil then
				self:ManipulateBoneAngles(i,Angle(self.fanAng,0,0))
			end
		end
	end 

	if self.prev ~= self:GetIsMining() then
		self:DestroyShadow()
		self:CreateShadow()
	end

	self.prev = self:GetIsMining()
	self:SetNextClientThink(CurTime() + 0.3)
	return true
end 

//Yuck I know but its to much effort to re-write the entire system
function ENT:Initialize()
	self.fanAng = 0

	//So each bitminer can have its own set of unique instructions. This is how we will do that
	self.customInstructions = {
		status = { //Outputs usefull runtime infomation
			command = "STATUS",
			description = "Выводит полезную информацию о текущем устройстве.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				consoleDisplay.history = consoleDisplay.history.."\n------------------STATUS------------------\n"
				local firstPart = "Работает                                 "
				local secondPart = string.upper(tostring(ent:GetIsMining()))
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				firstPart = "Питание подключено                                 "
				secondPart = string.upper(tostring(ent:GetHasPower()))
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				consoleDisplay.history = consoleDisplay.history.."------------------------------------------\n\n"
			end
		},
		info = {
			command = "INFO",
			description = "Выводит дополнительную информацию о текущем устройстве.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				consoleDisplay.history = consoleDisplay.history.."\n-------------------INFO------------------\n"
				local serverTable = util.JSONToTable(self:GetConnectedServers())
				local serverCount = 0
				for i = 1 , 8 do
					if serverTable[i] == true then
						serverCount = serverCount + 1
					end
				end
				consoleDisplay.history = consoleDisplay.history.."СЕРВЕРНЫЙ СЧЕТЧИК                            "..serverCount.."\n"
				local firstPart = "ТАКТОВАЯ ЧАСТОТА                              "
				local secondPart = tostring(__round(ent:GetClockSpeed(), 3)).."Ghz"
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				local firstPart = "ЯДРА                                    "
				local secondPart = ent:GetCoreCount()
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				consoleDisplay.history = consoleDisplay.history.."ТРЕБУЕТ МОЩНОСТЬ          100-800W (MAX)\n"
				consoleDisplay.history = consoleDisplay.history.."НАЗВАНИЕ                 Bitminer Rack\n"
				local playerName = self:Getowning_ent()
				if playerName ~= NULL then playerName = playerName:Name() else playerName = "Unknown" end
				consoleDisplay.history = consoleDisplay.history..string.sub("ВЛАДЕЛЕЦ                                    ", 1, string.len("OWNER                                    ") - string.len(playerName))..playerName.."\n"
				consoleDisplay.history = consoleDisplay.history.."-----------------------------------------\n\n"
			end
		},
		mining = {
			command = "MINING",
			description = "Начинает или останавливает добычу.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == nil then 
					consoleDisplay.history = consoleDisplay.history.."Для использования этой команды, пожалуйста, введите один из следующих аргументов: 'mining start' или 'mining stop'\n"
				elseif arg1 == "start" then
					net.Start("BM2.Command.Mining")
						net.WriteEntity(ent)
						net.WriteBool(true)
					net.SendToServer()
				elseif arg1 == "stop" then
					net.Start("BM2.Command.Mining")
						net.WriteEntity(ent)
						net.WriteBool(false)
					net.SendToServer()
				else
					consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' не является допустимой опцией, введите 'mining start' или 'mining stop'\n"
				end
			end
		},
		bitcoin = { //Used for selling or getting info about bitcoins
			command = "BITCOIN",
			description = "Позволяет вам продавать или видеть информацию о сохраненных биткойнах.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == "info" then
					consoleDisplay.history = consoleDisplay.history.."\n-------------------BITCOIN------------------\n"
					local firstPart = "Количество Биткойнов                              "
					local secondPart = comma_value(__round(ent:GetBitcoinAmount(), 2)).."btc"
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					firstPart =	"Значение Биткойнов ($)                           "
					secondPart = tostring(comma_value(__round(ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2)))
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					consoleDisplay.history = consoleDisplay.history.."--------------------------------------------\n\n"
				elseif arg1 == "sell" then
					net.Start("BM2.Command.SellBitcoins")
						net.WriteEntity(ent)
					net.SendToServer()
					local firstPart =	"Из                                        "
					local secondPart = tostring(comma_value(__round(ent:GetBitcoinAmount(), 2))).."btc"
					consoleDisplay.history = consoleDisplay.history.."\n-------------------RECEIPT------------------\n"
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					firstPart =	"Конвертировано в                               "
					secondPart = "$"..tostring(comma_value(__round(ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2)))
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					consoleDisplay.history = consoleDisplay.history.."Деньги были переведены на ваш кошелек\n"
					consoleDisplay.history = consoleDisplay.history.."--------------------------------------------\n\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history.."Чтобы использовать эту команду, пожалуйста, укажите один из следующих аргументов: 'bitcoin info' или 'bitcoin sell'\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' не является допустимой опцией, введите 'bitcoin info' или 'bticoin sell'\n"
					end
				end
			end
		},
		upgrade = { //Used for selling or getting info about bitcoins
			command = "UPGRADE",
			description = "Показывает доступные обновления и позволяет их приобрести.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == "1" then //CPU
					net.Start("BM2.Command.Upgrade")
					net.WriteEntity(ent)
					net.WriteBool(false)
					net.SendToServer()
				elseif arg1 == "2" then //Cores
					net.Start("BM2.Command.Upgrade")
					net.WriteEntity(ent)
					net.WriteBool(true)
					net.SendToServer()
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history.."\n-------------------UPGRADES------------------\n"
						local i = 0

						if self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1] ~= nil then
							i = i + 1
							firstPart =	"[1] "..self.upgrades.CPU.name.."                                                              "
							secondPart = "                                             "
							thirdtPart = "$"..comma_value(self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1])
							local str = string.sub(firstPart, 0, string.len(secondPart))
							consoleDisplay.history = consoleDisplay.history..string.sub(str, 1, string.len(str) - string.len(thirdtPart))..thirdtPart.."\n"
						end

						if self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1] ~= nil then
							i = i + 1 
							firstPart =	"[2] "..self.upgrades.CORES.name.."                                                              "
							secondPart = "                                             "
							thirdtPart = "$"..comma_value(self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1])
							local str = string.sub(firstPart, 0, string.len(secondPart))
							consoleDisplay.history = consoleDisplay.history..string.sub(str, 1, string.len(str) - string.len(thirdtPart))..thirdtPart.."\n"
						end

						if i == 0 then
							consoleDisplay.history = consoleDisplay.history.."Это устройство больше не нуждается в обновлениях\n"
						end

						consoleDisplay.history = consoleDisplay.history.."---------------------------------------------\nНаберите 'upgrade 1' или 'upgrade 2', чтобы выбрать обновление.\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' является не допустимой опцией, введите 'upgrade 1' или 'upgrade 2'\n"
					end
				end
			end
		},
		eject = {
			command = "EJECT",
			description = "Извлекает сервер из стойки",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == nil then
					consoleDisplay.history = consoleDisplay.history.."Чтобы использовать эту команду, пожалуйста, поставьте сервер для извлечения, например, 'eject 4'\n"
				elseif isnumber(tonumber(arg1)) then
					net.Start("BM2.Command.Eject")
						net.WriteEntity(ent)
						net.WriteInt(tonumber(arg1), 8)
					net.SendToServer()
				else
					consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' является не допустимой опцией, введите: 'eject 1-8'\n"
				end
			end
		},
		servers = { 
			command = "SERVERS",
			description = "Выводит список серверов в стойке.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				local servers = util.JSONToTable(self:GetConnectedServers())
				consoleDisplay.history = consoleDisplay.history.."\n-------------------SERVERS------------------\n"
				for i = 1 , 8 do
					local firstPart =	"#"..i.."                                          "
					secondPart = "ПУСТО"
					if servers[i] then 
						secondPart = "ВСТАВЛЕН"
					end
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				end
				consoleDisplay.history = consoleDisplay.history.."--------------------------------------------\n"
			end
		},
	}  
	--Only add if DLC is loaded
	if BITMINERS_2_EXTRAS_DLC then
		self.customInstructions.remote = {
			command = "REMOTE",
			description = "Позволяет вам устанавливать, удалять и изменять имя модуля удаленного доступа, который позволит вам получить удаленный доступ к битминеру, используя "..BM2EXTRACONFIG.RemoteAccessCommand..". Установка его стоит $"..string.Comma(BM2EXTRACONFIG.RemoteAccessPrice)..".",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == "install" then
					net.Start("BM2.Command.RemoteInstall")
					net.WriteEntity(ent)
					net.WriteBool(true)
					net.SendToServer()
					ent.remoteName = math.random(10,99).."."..math.random(100,800).."."..math.random(10,99).."."..math.random(100,800)
				elseif arg1 == "remove" then
					net.Start("BM2.Command.RemoteInstall")
					net.WriteEntity(ent)
					net.WriteBool(false)
					net.SendToServer()
				elseif arg1 == "setname" then
					local _string = arg2 or math.random(10,99).."."..math.random(100,800).."."..math.random(10,99).."."..math.random(100,800)
					ent.remoteName = _string
					consoleDisplay.history = consoleDisplay.history.."Удаленное имя изменено на '".._string.."'\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history.."---------------------------------------------\nВведите 'REMOTE INSTALL' для установки удаленного модуля. Установка стоит $"..string.Comma(BM2EXTRACONFIG.RemoteAccessPrice).." и позволяет работать с битмайнером по удаленному доступу используя "..BM2EXTRACONFIG.RemoteAccessCommand.."\nВведите 'REMOTE REMOVE' для удаления удаленного доступа.\nВведите 'REMOTE SETNAME ExampleName' чтобы изменить удаленное имя битмайнера. Имя не должно содержать пробелов!\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' не является допустимой, опциями являются 'install', 'setname' или 'remove'\n"
					end
				end
			end
		}
	end
end
function ENT:Draw()
	self:DrawModel()
end
--addons/module_bitminers2/lua/entities/bm2_fuel/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/module_bitminers2_extras/lua/entities/bm2_solar_cable/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"

ENT.PrintName = "Solar Cable"
ENT.Spawnable = true
ENT.Category = "Запрещено"

function ENT:SetupDataTables()

end
--addons/module_bitminers2_extras/lua/entities/bm2_solar_panel/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"

ENT.PrintName = "Solar Panel"
ENT.Spawnable = true
ENT.Category = "Запрещено"

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "HasLight")
end
--addons/module_bitminers2_extras/lua/entities/bm2_solarconverter/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"

ENT.PrintName = "Solar Converter"
ENT.Spawnable = true
ENT.Category = "Запрещено"

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "IsOn" )
	self:NetworkVar( "Bool", 2, "ShowToMuchPowerWarning")
	self:NetworkVar( "Bool", 3, "ShowNoPowerWarning")
	self:NetworkVar( "Bool", 4, "ShowNoConnectedSolarWarning")
	self:NetworkVar( "Float", 2, "PowerConsumpsion")
	self:NetworkVar( "Float", 3, "MaxPowerConsumpsion")
	self:NetworkVar( "Int", 1, "ConnectedPanels")
end 
--addons/ent_ammobox/lua/entities/box_ammo/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Ammobox"
ENT.Category = "Разрешено"

ENT.Spawnable = true
--addons/ent_ammobox/lua/entities/box_armor/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "ArmorBox"
ENT.Category = "Запрещено"

ENT.Spawnable = true
--addons/module_bank/lua/entities/clicker_safe/cl_init.lua:
include('shared.lua')

local color_bright = Color(236, 113, 71)
local color_dark = Color(43, 49, 54)
local color_other = Color(77, 75, 77, 70)

local vec = Vector(21,0,37.5)
local ang = Angle(0,90,90)

local mat_green = Material('icon72/green_circle.png')
local mat_red = Material('icon72/red_circle.png')
local mat_white = Material('icon72/white_circle.png')
local csize = 25

function ENT:Draw()
    self:DrawModel()

    if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 90000 then return end
    if self:IsOpened() then return end
    
    cam.Start3D2D(self:LocalToWorld(vec), self:LocalToWorldAngles(ang) , 0.1)
        draw.RoundedBox(0,-145,0,290,135, color_dark)
    
        surface.SetDrawColor(color_white)
        local clickers = self:GetClickers()
        for i=1, 3 do
            local ent = clickers[4-i]
            
            if ent and ent.GetBroken then
                surface.SetMaterial(ent:GetBroken() and mat_red or mat_green)
            else
                surface.SetMaterial(mat_white)
            end
            
            surface.DrawTexturedRect(-135, 15 + (csize+15)*(i-1), csize, csize)

            local str = 'Пусто'
            if ent and ent.GetClickerName then
                str = ('%s - %s'):format(string.Explode(' ', ent:GetClickerName())[1], DarkRP.formatMoney(ent:GetMoney()))
            end
            draw.SimpleText(str, 'Trebuchet24', -125 + csize, 15 + (csize+15)*(i-1) + csize/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
    cam.End3D2D()
end
--addons/weapon_laser/lua/entities/dark_egon_beam/shared.lua:
ENT.Type = "anim"


/*---------------------------------------------------------
---------------------------------------------------------*/
function ENT:SetEndPos( endpos )

	self.Entity:SetNetworkedVector( 0, endpos )	
	self.Entity:SetCollisionBoundsWS( self.Entity:GetPos(), endpos, Vector() * 0.25 )
	
end


/*---------------------------------------------------------
---------------------------------------------------------*/
function ENT:GetEndPos()
	return self.Entity:GetNetworkedVector( 0 )
end

--addons/module_poopandpee/lua/entities/ddv_poop.lua:
--[[
	Script: Poo & Pee
	Version: 1.0
	Created by DidVaitel (http://steamcommunity.com/profiles/76561198108670811)
]]

AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

ENT.PrintName = "Poop"
ENT.Category = 'Запрещено'
ENT.Author = "DidVaitel"
ENT.Contact = "contact@gmodhub.com"
ENT.Category = "DidVaitel Entities"

ENT.Editable = true
ENT.Spawnable = true
ENT.AdminOnly = false
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

-- We do NOT want to execute anything below on CLIENT
if ( CLIENT ) then return end

function ENT:Initialize()
	
	self:SetModel("models/Gibs/HGIBS_spine.mdl")
	
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetUseType(SIMPLE_USE)
	self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	self:PhysWake()

	local size = math.random(1, 6)
	self:SetCollisionBounds( Vector( -size, -size, -size ), Vector( size, size, size ) )
	self:SetModelScale(size)
	self:GetPhysicsObject():SetMass(1)

	self:SetMaterial('phoenix_storms/potato')
	self:Activate()
end

function ENT:Use(activator, caller)

	self:Remove()

	if ( activator:IsPlayer() ) then

	--	activator:EmitSound("vo/sandwicheat09.ogg", 100, 100)

		-- Give the collecting player some free health || Takes the collecting player health
		local health = activator:Health()

		if ( math.random(1, 4) == 2 ) then
			if health <= 10 then
				activator:Kill()
			else
				activator:SetHealth(health - 10)
			end
			return
		end

		activator:SetHealth( health + 5 )

	end

end

function ENT:PhysicsCollide( data, physobj )

	-- Play sound on bounce
	if ( data.Speed > 60 && data.DeltaTime > 0.2 ) then

		local pitch = 160
		sound.Play( "player/footsteps/mud" .. math.random( 1, 4 ) .. ".wav", self:GetPos(), 75, math.random( pitch - 10, pitch + 10 ), math.Clamp( data.Speed / 150, 0, 1 ) )

	end

	-- More realistic bounce
	local LastSpeed = math.max( data.OurOldVelocity:Length(), data.Speed )
	local NewVelocity = physobj:GetVelocity()
	NewVelocity:Normalize()

	LastSpeed = math.max( NewVelocity:Length(), LastSpeed )
	local TargetVelocity = NewVelocity * LastSpeed * 0.2
	physobj:SetVelocity( TargetVelocity )

	-- Shit Decal
	local spos = self:GetPos()
    local trs = util.TraceLine({start=spos + Vector(0,0,64), endpos=spos + Vector(0,0,-128), filter=self})
	util.Decal("BeerSplash", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)     

	local effectdata = EffectData()
	effectdata:SetOrigin( self:GetPos() )
	util.Effect( "WheelDust", effectdata ) 
end

function ENT:OnTakeDamage( dmginfo )

	self:TakePhysicsDamage( dmginfo )

end
--addons/_smallscripts/lua/entities/donation_box/shared.lua:

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Author = "Matrix"

ENT.PrintName = "Hobo Donation Chest"
ENT.Category = "DarkRP Entities"
ENT.Spawnable = false

function ENT:SetupDataTables()
    -- The owner of the Entity
    self:NetworkVar("Entity", 0, "owning_ent")
    -- How much money the Entity is holding
    self:NetworkVar("Int", 1, "Money")
end
--addons/ent_drugz/lua/entities/durgz_alcohol/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "RedBull"
ENT.Category = "Запрещено"
ENT.Model = "models/props_junk/PopCan01a.mdl"
--addons/ent_drugz/lua/entities/durgz_aspirin/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Aspirin"
ENT.Information	 = "Gets rid of headaches" 
ENT.Category = "Запрещено"
ENT.Model = "models/jaanus/aspbtl.mdl"
ENT.UseTime = 10
--addons/ent_drugz/lua/entities/durgz_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Author = "WayZer\'s RP"
ENT.Spawnable = false
ENT.AdminSpawnable = false 
ENT.Information	 = "Наркотики - зло"
ENT.UseTime = 3
--addons/ent_drugz/lua/entities/durgz_meth/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Метамфетамин"
ENT.Category = "Запрещено"
ENT.Model = "models/katharsmodels/contraband/metasync/blue_sky.mdl"
--addons/module_meth/lua/entities/eml_ciodine/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Кристализированный йод";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
end
--addons/module_meth/lua/entities/eml_iodine/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

local dist = 90000

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ply = LocalPlayer()

	if ply:GetPos():DistToSqr(pos) > dist then return end

	local ang = self:GetAngles()

	local iodineColor = EML_Iodine_Color;
	
	if (self:GetMethAmount()>0) then
		iodineColor = EML_Iodine_Color;
	else
		iodineColor = Color(100, 100, 100, 255);
	end;
	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos+ang:Up()*3.35, ang, 0.07)
			draw.SimpleTextOutlined("Жидкий", "methFont", 0, -14, iodineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Йод", "methFont", 0, 10, iodineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined(""..self:GetMethAmount().." литра", "methFont", 0, 34, iodineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), -90);
	ang:RotateAroundAxis(ang:Right(), 90);		
		cam.Start3D2D(pos+ang:Up()*3.35, ang, 0.1)
			surface.SetDrawColor(0, 0, 0, 200);
			surface.DrawRect(-40, -8, 64, 16);
			
			surface.SetDrawColor(EML_Iodine_Color);
			surface.DrawRect(-38, -6, math.Round((self:GetMethAmount()*60)/self:GetMaxAmount()), 12);				
		cam.End3D2D();
	end;
end;

-- maxAmount = 60
-- amount = x


--addons/module_meth/lua/entities/eml_jar/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});


function ENT:Initialize()	

end;

local dist = 90000

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ply = LocalPlayer()
	
	if ply:GetPos():DistToSqr(pos) > dist then return end

	local ang = self:GetAngles()
	local macidColor = Color(160, 221, 99, 255);
	local iodineColor = Color(137, 69, 54, 255);
	local waterColor = Color(133, 202, 219, 255);
	
	local potTime = "Прогресс: "..self:GetProgress().."% (Взбалтывайте!)";
	
	if (self:GetIntStatus() == 0) then
		potTime = "Прогресс: "..self:GetProgress().."% (Взбалтывайте!)";
	elseif (self:GetIntStatus() == 1) then	
		potTime = "Готово!";
	end;
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos + ang:Up()*5, ang, 0.10)
			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-64, -38, 128, 96);		
		cam.End3D2D();
		cam.Start3D2D(pos + ang:Up()*5, ang, 0.055)
			draw.SimpleTextOutlined("Кристализированный йод", "methFont", 0, -56, Color(220, 134, 159, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("______________", "methFont", 0, -54, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-104, -32, 204, 24);			
			surface.SetDrawColor(Color(220, 134, 159, 255));
			surface.DrawRect(-101.5, -30, math.Round((self:GetProgress()*198)/100), 20);		
			
			draw.SimpleTextOutlined("Ингридиенты", "methFont", -101, 8, Color(220, 134, 159, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("______________", "methFont", 0, 10, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			if (self:GetMacid()==0) then
				macidColor = Color(100, 100, 100, 255);
			else
				macidColor = Color(160, 221, 99, 255);
			end;
			
			if (self:GetIodine()==0) then
				iodineColor = Color(100, 100, 100, 255);
			else
				iodineColor = Color(137, 69, 54, 255);
			end;

			if (self:GetWater()==0) then
				waterColor = Color(100, 100, 100, 255);
			else
				waterColor = Color(133, 202, 219, 255);
			end;											
		cam.End3D2D();	
		
		cam.Start3D2D(pos + ang:Up()*5, ang, 0.045)		
			draw.SimpleTextOutlined("Соляная кислота ("..self:GetMacid()..")", "methFont", -121, 44, macidColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Жидкий йод ("..self:GetIodine()..")", "methFont", -121, 74, iodineColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));	
			draw.SimpleTextOutlined("Вода ("..self:GetWater()..")", "methFont", -121, 104, waterColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));			
		cam.End3D2D();			
		cam.Start3D2D(pos + ang:Up()*5, ang, 0.035)		
			draw.SimpleTextOutlined(potTime, "methFont", -152, -32, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));		
		cam.End3D2D();		
		
	end;
end;


--addons/module_meth/lua/entities/eml_redp/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

local dist = 90000

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ply = LocalPlayer()

	if ply:GetPos():DistToSqr(pos) > dist then return end
	
	local ang = self:GetAngles()

	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.1)
				draw.SimpleTextOutlined("Красный фосфор ("..self:GetMethAmount().." lbs)", "methFont", 32, -96, Color(175, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));			
		cam.End3D2D()	
	end;
end;

-- maxAmount = 60
-- amount = x


--addons/module_meth/lua/entities/eml_redp/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Красный фосфор";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
end
--addons/module_meth/lua/entities/eml_spot/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});


function ENT:Initialize()	

end;

local dist = 90000

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ply = LocalPlayer()

	if ply:GetPos():DistToSqr(pos) > dist then return end
	
	local ang = self:GetAngles()
	local redpColor = Color(175, 0, 0, 255);
	local ciodineColor = Color(220, 134, 159, 255);
	
	local potTime = "Время: "..self:GetTime().."сек";
	
	if (self:GetIntStatus() == 0) then
		potTime = "Время: "..self:GetTime().."сек";
	elseif (self:GetIntStatus() == 1) then	
		potTime = "Готово!";
	end;
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.10)
			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-64, -38, 128, 96);		
		cam.End3D2D();
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.055)
			draw.SimpleTextOutlined("Кристализированный мет", "methFont", 0, -56, Color(1, 241, 249, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("______________", "methFont", 0, -54, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-104, -32, 204, 24);			
			surface.SetDrawColor(Color(1, 201, 209, 255));
			surface.DrawRect(-101.5, -30, math.Round((self:GetTime()*198)/self:GetMaxTime()), 20);		
			
			draw.SimpleTextOutlined("Ингридиенты", "methFont", -101, 8, Color(1, 241, 249, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("______________", "methFont", 0, 10, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			if (self:GetRedP()==0) then
				redpColor = Color(100, 100, 100, 255);
			else
				redpColor = Color(175, 0, 0, 255);
			end;
			
			if (self:GetCiodine()==0) then
				ciodineColor = Color(100, 100, 100, 255);
			else
				ciodineColor = Color(220, 134, 159, 255);
			end;							
		cam.End3D2D();	
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.040)		
			draw.SimpleTextOutlined("Красный фосфор ("..self:GetRedP()..")", "methFont", -138, 50, redpColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Кристализированный йод ("..self:GetCiodine()..")", "methFont", -138, 80, ciodineColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));		
		cam.End3D2D();			
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.035)		
			draw.SimpleTextOutlined(potTime, "methFont", -152, -32, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));		
		cam.End3D2D();		
		
	end;
end;


--addons/module_meth/lua/entities/eml_spot/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Специальная Кастрюля";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
   	self:NetworkVar("Int", 0, "RedP")
   	self:NetworkVar("Int", 1, "Ciodine")
   	self:NetworkVar("Int", 2, "Time")
   	self:NetworkVar("Int", 3, "MaxTime")
   	self:NetworkVar("Int", 4, "IntStatus")
end
--addons/weapon_shield/lua/entities/ent_fridge_shield_unbreakable/cl_init.lua:
include('shared.lua')
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()  
    self:DrawModel()
end
--addons/module_css2/lua/entities/ent_smokegrenade/cl_init.lua:
include('shared.lua')

/*---------------------------------------------------------
Initialize
---------------------------------------------------------*/
function ENT:Initialize()

	self.timer = CurTime() + 3
end

/*---------------------------------------------------------
Think
---------------------------------------------------------*/
function ENT:Think()

	local vPos = Vector(math.Rand(-100, 100), math.Rand(-100, 100), 0);

	local vOffset = self.Entity:LocalToWorld( Vector(0, 0, self.Entity:OBBMins().z) )

	local emitter = ParticleEmitter( vOffset )
	
	if self.timer < CurTime() then
		local smoke = emitter:Add( "particle/particle_smokegrenade", vOffset + vPos )
		smoke:SetVelocity(VectorRand() * math.Rand(100, 350))
		smoke:SetGravity(Vector((math.Rand(-100, 100)),(math.Rand(-100, 100)),(math.Rand(0, 100))))
		smoke:SetDieTime(30)
		smoke:SetStartAlpha(math.Rand(245, 255))
		smoke:SetEndAlpha(0)
		smoke:SetStartSize(math.Rand(100, 300))
		smoke:SetEndSize(700)
		smoke:SetRoll(math.Rand(-180, 180))
		smoke:SetRollDelta(math.Rand(-0.2,0.2))
		smoke:SetColor(120, 120, 120)
		smoke:SetAirResistance(550)
	end

	emitter:Finish()

	self:SetNextClientThink(CurTime() + 1)
	return true
end

/*---------------------------------------------------------
Draw
---------------------------------------------------------*/
function ENT:Draw()
	self.Entity:DrawModel()
end


/*---------------------------------------------------------
IsTransluent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end



--addons/weapon_shield/lua/entities/ent_swat_shield/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.PrintName = 'Molot Shield'
ENT.Category = ''

ENT.Spawnable = false
ENT.DisableDuplicator = true
--addons/_smallscripts/lua/entities/entity_rachia/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	if self:GetPos():DistToSqr(EyePos()) > 160000 then return end
    self:DrawModel()
end

--addons/weapon_cracker/lua/entities/keypad_cracker_ent/cl_init.lua:
include("shared.lua")
--addons/tool_keypad/lua/entities/keypad_pattern/cl_init.lua:
include("shared.lua")

local function createFont(name, size)
    surface.CreateFont(name, {
        font = "Roboto",
        antialias = true,
        size = size,
        weight = 500,
    })
end

createFont("PatternKeypadWindow", 72)

local matWhite = CreateMaterial( "PatternKeypadMaterial", "UnlitGeneric", {
    ["$basetexture"] = "white",
    ["$vertexcolor"] = 1,
} )


local iconOpen = Material('icon72/door.png', 'smooth')
local iconSettings = Material('icon72/wrench.png', 'smooth')
local iconMoney = Material('icon72/moneybag.png', 'smooth')

function ENT:Initialize()
    self:InitializeShared()

    local boxSize = self.boxMax - self.boxMin

    self.guiScale = 0.02
    self.guiWidth = math.floor(boxSize.y / self.guiScale)
    self.guiHeight = math.floor(boxSize.z / self.guiScale)

    self.guiPos = Vector(self.boxMax.x + 0.02, self.boxMin.y, self.boxMax.z)
    self.guiAng = Angle(0, 90, 90)

    self.guiWorldPos = Vector()
    self.guiWorldAng = Angle()

    self.colPrimary = Color(59, 73, 84)
    self.colSecondary = Color(211, 47, 47)
    self.colAccessGranted = Color(100, 255, 50)
    self.colAccessDenied = Color(255, 40, 20)

    self.circleRadiusHover = 24
    self.circleRadiusChecked = 32
    self.circleRadius = 16

    self.buttonsY = 134
    self.buttonHeight = 80
    self.space = 4

    self.confirmation = nil

    self.buttons = {
        {
            hovered = false,
            size = 64,
            icon = iconOpen,
            check = function()
                return self:CanOpen(LocalPlayer())
            end,
            doClick = function()
                net.Start('keypad_open')
                net.WriteEntity(self)
                net.SendToServer()
            end,
        },
        {
            hovered = false,
            size = 64,
            icon = iconSettings,
            check = function()
                return FPP.entGetOwner(self) == LocalPlayer()
            end,
            doClick = function()
                self:OpenSettings()
            end,
        },
        {
            hovered = false,
            size = 64,
            icon = iconMoney,
            check = function()
                return self:GetPrice() ~= 0
            end,
            doClick = function()
                local price = self:GetPrice()
                    if IsValid(self.confirmation) then return end
                    self.confirmation = Derma_Query('Стоимость открытия этого кейпада - '..DarkRP.formatMoney(price)..'. Ты уверен?', 'Открыть кейпад', 'Открыть', function()
                        net.Start('keypad_pay')
                        net.WriteEntity(self)
                        net.SendToServer()
                    end, 'Отмена')
            end,
        },
    }
    
    self:CreateGrid()
end

function ENT:UpdateColors()
    local colorArr = string.Explode("-", self:GetColors())
    self.colPrimary = ColorAlpha(PatternKeypad.parseColor(colorArr[1]), 255)
    self.colSecondary = ColorAlpha(PatternKeypad.parseColor(colorArr[2]), 255)
    self.colAccessGranted = ColorAlpha(PatternKeypad.parseColor(colorArr[3]), 255)
    self.colAccessDenied = ColorAlpha(PatternKeypad.parseColor(colorArr[4]), 255)
end

function ENT:RefreshButtons()
    self.availableButtons = {}
    for _, v in ipairs(self.buttons) do
        if not v.check or v.check() ~= false then table.insert(self.availableButtons, v) end
    end
end

function ENT:CreateGrid()
    self.grid = {}
    self.path = {}

    local w, h = self.guiWidth, self.guiHeight
    local gridW, gridH = self:GetGridWidth(), self:GetGridHeight()

    local offsetX = w / (gridW + 1)
    local offsetY = w / (gridH + 1)
    local rad = 16

    for x = 1, gridW do
        for y = 1, gridH do
            local entry = self.grid[x + y * gridW]
            if not entry then
                entry = {
                    radius = 0,
                    color = Color(0, 0, 0, 80),
                    x = 0,
                    y = 0,
                }
                self.grid[x + y * gridW] = entry
            end

            entry.x = offsetX * x
            entry.y = h - offsetY * gridH + (y - 1) * offsetY
        end
    end
end

function ENT:GetCursorPosition()
    local rayVec = util.IntersectRayWithPlane(LocalPlayer():GetShootPos(), LocalPlayer():GetAimVector(), self.guiWorldPos, self.guiWorldAng:Up())
    if not rayVec then return 0, 0 end

    local dist = LocalPlayer():GetShootPos():DistToSqr(rayVec)
    if dist > PatternKeypad.clickRange * PatternKeypad.clickRange then return 0, 0 end

    local localRayVec = WorldToLocal(rayVec, Angle(), self.guiWorldPos, self.guiWorldAng)
    local boxSize = self.boxMax - self.boxMin

    local cursorFractX = localRayVec.x / boxSize.y
    local cursorFractY = -localRayVec.y / boxSize.z

    if cursorFractX < 0 or cursorFractX > 1 or cursorFractY < 0 or cursorFractY > 1 then
        return -1, -1
    end

    return cursorFractX * self.guiWidth, cursorFractY * self.guiHeight
end

function ENT:SendCombination(combination)
    net.Start("keypad_pattern_com")
        net.WriteEntity(self)
        net.WriteInt(#combination, 8)
        for i = 1, #combination do
            net.WriteInt(combination[i], 8)
        end
    net.SendToServer()
end

hook.Add('KeyPress', 'pattern_keypad_buttons', function(ply, key)
    if key ~= IN_USE then return end

    local keypad = LocalPlayer():GetUseEntity()
    if not IsValid(keypad) or keypad:GetClass() ~= 'keypad_pattern' then return end

    keypad.buttons = keypad.buttons or {}
    keypad:RefreshButtons()

    for _, v in ipairs(keypad.availableButtons) do
        if v.hovered then
            v.doClick()
            return
        end
    end
end)

function ENT:Think()
    local lp = LocalPlayer()
    local distSqr = 10000
    
    if lp:GetPos():DistToSqr( self:GetPos() ) > distSqr then 
        self:SetNextClientThink( CurTime() + 1 )
        return true
    end


    if lp:KeyDown(IN_USE) and self:GetStatus() == self.STATUS_NONE then
        local cursorX, cursorY = self:GetCursorPosition()
        local gridW, gridH = self:GetGridWidth(), self:GetGridHeight()

        for cx = 1, gridW do
            for cy = 1, gridH do
                local entry = self.grid[cx + cy * gridW]
                if not istable(entry) then return end
                if entry.hovered then
                    if not entry.checked then
                        surface.PlaySound(PatternKeypad.soundClick)

                        self.path[#self.path + 1] = {
                            id = cx + cy * gridW,
                            time = 0,
                        }
                    end

                    entry.checked = true
                end
            end
        end
    else
        if #self.path > 0 then
            local combination = {}

            for i = 1, #self.path do
                local dat = self.path[i]
                self.grid[dat.id].checked = false

                combination[#combination + 1] = dat.id
            end

            if #combination > 1 then
                self:SendCombination(combination)
            end

            self.path = {}
        end
    end


    local colorStr = self:GetColors()
    if colorStr ~= self.oldColorStr then
        self:UpdateColors()
    end
    self.oldColorStr = colorStr
    self:SetNextClientThink(CurTime() + 0.1)
    return true
end
local startTime = CurTime()
local startTime2 = CurTime()

function ENT:DrawOverlay()
    local lp = LocalPlayer()
    local distSqr = 10000
    
    if lp:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end
    local elapsed = FrameTime()

    local w, h = self.guiWidth, self.guiHeight

    local cursorX, cursorY = self:GetCursorPosition()

    self.guiWorldPos = self:LocalToWorld(self.guiPos)
    self.guiWorldAng = self:LocalToWorldAngles(self.guiAng)
    cam.Start3D2D(self.guiWorldPos, self.guiWorldAng, self.guiScale)
        draw.NoTexture()

        surface.SetDrawColor(self.colPrimary)
        surface.DrawRect(0, 0, w, h)

        surface.SetDrawColor(Color(0, 0, 0, 80))
        surface.DrawRect(40, 40, w - 80, 80)

        if self:GetStatus() == self.STATUS_GRANTED then
            draw.DrawText(PatternKeypad.language.textGranted, "PatternKeypadWindow", w / 2, 40, self.colAccessGranted, TEXT_ALIGN_CENTER)
        elseif self:GetStatus() == self.STATUS_DENIED then
            draw.DrawText(PatternKeypad.language.textDenied, "PatternKeypadWindow", w / 2, 40, self.colAccessDenied, TEXT_ALIGN_CENTER)
        elseif self:GetPrice() ~= 0 then
            draw.DrawText(DarkRP.formatMoney(self:GetPrice()), "PatternKeypadWindow", w / 2, 40, self.colAccessGranted, TEXT_ALIGN_CENTER)
        end

        for i = 1, #self.path - 1 do
            local dat = self.path[i]
            dat.time = dat.time + (1 - dat.time) * 12 * elapsed

            local entry = self.grid[dat.id]
            local nextEntry = self.grid[self.path[i + 1].id]

            local dx = nextEntry.x - entry.x
            local dy = nextEntry.y - entry.y
            local ang = math.deg(math.atan2(-dy, dx))

            local mx = (nextEntry.x + entry.x) / 2
            local my = (nextEntry.y + entry.y) / 2
            local dist = math.sqrt(dx * dx + dy * dy)
            surface.SetDrawColor(ColorAlpha(self.colSecondary, dat.time * 255))
            surface.DrawTexturedRectRotated(mx, my, dist, dat.time * 20, ang)
        end


        local gridW, gridH = self:GetGridWidth(), self:GetGridHeight()
        if #self.grid - gridW ~= gridW * gridH then
            self:CreateGrid()
        end

        for cx = 1, gridW do
            for cy = 1, gridH do
                local entry = self.grid[cx + cy * gridW]

                local dx = cursorX - entry.x
                local dy = cursorY - entry.y
                local dist = math.sqrt(dx * dx + dy * dy)

                local hovered = dist < self.circleRadiusChecked
                if not entry.checked and not entry.hovered and hovered then
                    surface.PlaySound(PatternKeypad.soundHover)
                end
                entry.hovered = hovered

                if entry.checked then
                    entry.radius = entry.radius + (self.circleRadiusChecked - entry.radius) * 12 * elapsed
                    entry.color = PatternKeypad.lerpColor(entry.color, self.colSecondary, 12 * elapsed)
                else
                    if hovered then
                        entry.radius = entry.radius + (self.circleRadiusHover - entry.radius) * 12 * elapsed
                    else
                        entry.radius = entry.radius + (self.circleRadius - entry.radius) * 8 * elapsed
                    end
                    entry.color = PatternKeypad.lerpColor(entry.color, Color(0, 0, 0, 80), 12 * elapsed)
                end

                PatternKeypad.drawCircle(entry.x, entry.y, entry.radius, 24, entry.color)
            end
        end

        self:RefreshButtons()
        for i, v in ipairs(self.availableButtons) do

            local bgW = (self.guiWidth - 80) / #self.availableButtons - math.floor(#self.availableButtons/2) * self.space
            local bgH = self.buttonHeight

            local x = (40 + bgW * i) - bgW/2 - v.size / 2 + self.space * (i-1)
            local y = self.buttonsY

            local dx = cursorX - (x + v.size/2)
            local dy = cursorY - (y + v.size/2)
            local dist = math.sqrt(dx * dx + dy * dy)

            local hovered = dist < v.size/2
            if not v.hovered and hovered then
                surface.PlaySound(PatternKeypad.soundHover)
            end
            v.hovered = hovered

            surface.SetDrawColor(Color(0, 0, 0, 80))
            surface.DrawRect((x + v.size/2) - bgW/2, y + v.size/2 - bgH/2, bgW, bgH)

            surface.SetMaterial(v.icon)
            surface.SetDrawColor(Color(255, 255, 255))
            if hovered then
                surface.DrawTexturedRect(x - 4, y - 4, v.size + 8, v.size + 8)
            else
                surface.DrawTexturedRect(x, y, v.size, v.size)
            end
        end

    cam.End3D2D()
end

function ENT:Draw()
    local lp = LocalPlayer()
    local distSqr = 250000
    
    if lp:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end
    render.SuppressEngineLighting(true)
    render.SetMaterial(matWhite)
    render.DrawBox(self:GetPos(), self:GetAngles(), self.boxMin, self.boxMax, self.colPrimary, false)

    local lp = LocalPlayer()

    local dist = LocalPlayer():GetPos():Distance(self:GetPos())
    if dist > 150 then
        render.SuppressEngineLighting(false)
        surface.SetAlphaMultiplier(1)
        return
    end

    surface.SetAlphaMultiplier(1 - math.Clamp((dist - 125) / 25, 0, 1))

    local dot = (lp:GetShootPos() - self:GetPos()):Dot(self:GetForward())
    if dot > 0 then
        self:DrawOverlay()
    end
    render.SuppressEngineLighting(false)
    surface.SetAlphaMultiplier(1)
end

function ENT:OpenSettings()
    if IsValid(self.settingsFrame) then self.settingsFrame:Remove() end

    local settings = self:GetWhitelist()

    local jobs = settings.teams
    local players = settings.players

    local frame = vgui.Create('DFrame')
    frame:SetSize(400, 600)
    frame:MakePopup()
    frame:Center()
    frame:SetTitle('Настройки')
    frame:SetDraggable(false)
    frame:SetSizable(false)
    frame:SetIcon('icon16/wrench.png')

    local guide = vgui.Create('DLabel', frame)
    guide:Dock(TOP)
    guide:SetText('Цена за проход. Укажи 0 чтобы запретить проход за деньги')
    guide:SetAutoStretchVertical(true)
    guide:DockMargin(0,5,0,5)

    local price = vgui.Create('DTextEntry', frame)
    price:Dock(TOP)
    price:DockMargin(0,0,0,5)
    price:SetValue(self:GetPrice())
    price.AllowInput = function(self, char)
        return not ('0123456789'):match(char)
    end

    local confirm = vgui.Create('DButton', frame)
    confirm:Dock(BOTTOM)
    confirm:SetTall(25)
    confirm:SetText('Подтвердить')
    confirm:SetIcon('icon16/accept.png')

    confirm.DoClick = function()
        net.Start('keypad_updatesettings')
        net.WriteEntity(self)
        net.WriteUInt(price:GetValue(), 32)

        net.WriteUInt(table.Count(jobs), 7)
        for job, _ in pairs(jobs) do
            net.WriteUInt(job, 7)
        end

        net.WriteUInt(table.Count(players), 8)
        for ply, _ in pairs(players) do
            net.WriteEntity(ply)
        end

        net.SendToServer()

        frame:Close()
    end
    
    local sheet = vgui.Create('DPropertySheet', frame)
    sheet:Dock(FILL)

    local jList = vgui.Create('DCategoryList', sheet)
    jList:Dock(FILL)

    for _, cat in pairs(DarkRP.getCategories().jobs) do
        local collapsible = jList:Add(cat.name)

        local main = vgui.Create('DListLayout')
        collapsible:SetContents(main)

        for _, job in pairs(cat.members) do
            local id = job.team
            
            local pan = vgui.Create('DButton')
            pan:SetText('')
            pan.Paint = function(s,w,h)
                if s.selected then
                    draw.RoundedBox(2,0,0,w,h,Color(0,150,0))
                end
            end
            pan:SetTall(40)

            if jobs[id] then
                pan.selected = true
            end

            pan.DoClick = function()
                if pan.selected then
                    jobs[id] = nil
                    pan.selected = false
                else
                    jobs[id] = true
                    pan.selected = true
                end
            end

            local icon = vgui.Create('SpawnIcon', pan)
            icon:Dock(LEFT)
            icon:SetWide(40)
            icon:SetModel(istable(job.model) and job.model[1] or job.model)

            icon.DoClick = pan.DoClick

            local label = vgui.Create('DLabel', pan)
            label:Dock(FILL)
            label:SetFont('Trebuchet24')
            label:SetText(job.name)
            
            main:Add(pan)
        end
    end

    sheet:AddSheet('Профессии', jList, 'icon16/user_gray.png')

    local pList = vgui.Create('DCategoryList', sheet)
    pList:Dock(FILL)

    local plys = {}
    for _, v in player.Iterator() do
        local t = v:GetNetVar('disguised') and v:GetNetVar('disguise_team') or v:Team()
        plys[t] = plys[t] or {}
        table.insert(plys[t], v)
    end

    for _, cat in pairs(DarkRP.getCategories().jobs) do
        for _, job in pairs(cat.members) do
            local id = job.team
            if not plys[id] then continue end

            local collapsible = pList:Add(job.name)

            local main = vgui.Create('DListLayout')
            collapsible:SetContents(main)

            for _, ply in ipairs(plys[id]) do
                if ply == LocalPlayer() then continue end

                local pan = vgui.Create('DButton')
                pan:SetText('')
                pan.Paint = function(s,w,h)
                    if s.selected then
                        draw.RoundedBox(2,0,0,w,h,Color(0,150,0))
                    end
                end
                pan:SetTall(40)

                if players[ply] then
                    pan.selected = true
                end
    
                pan.DoClick = function()
                    if pan.selected then
                        players[ply] = nil
                        pan.selected = false
                    else
                        players[ply] = true
                        pan.selected = true
                    end
                end
    
                local icon = vgui.Create('SpawnIcon', pan)
                icon:Dock(LEFT)
                icon:SetWide(40)
                icon:SetModel(ply:GetModel())
    
                icon.DoClick = pan.DoClick
    
                local label = vgui.Create('DLabel', pan)
                label:Dock(FILL)
                label:SetFont('Trebuchet24')
                label:SetText(ply:Name())
                
                main:Add(pan)
            end
        end
    end

    sheet:AddSheet('Игроки', pList, 'icon16/user.png')

    local clan = dOrgs.orgs[ply:GetMainOrgID()]
    if clan then
        local cList = vgui.Create('DCategoryList', sheet)
        cList:Dock(FILL)

        local plys = {}
        for _, v in pairs(clan:GetMembers()) do
            local ply = v:GetPlayer()
            if not IsValid(ply) then continue end

            local t = ply:GetNetVar('disguised') and ply:GetNetVar('disguise_team') or ply:Team()
            plys[t] = plys[t] or {}
            table.insert(plys[t], v.player)
        end

        for _, cat in pairs(DarkRP.getCategories().jobs) do
            for _, job in pairs(cat.members) do
                local id = job.team
                if not plys[id] then continue end
                
                local collapsible = cList:Add(job.name)

    
                local main = vgui.Create('DListLayout')
                collapsible:SetContents(main)
    
                for _, ply in ipairs(plys[id]) do
                    if ply == LocalPlayer() then continue end
    
                    local pan = vgui.Create('DButton')
                    pan:SetText('')
                    pan.Paint = function(s,w,h)
                        if s.selected then
                            draw.RoundedBox(2,0,0,w,h,Color(0,150,0))
                        end
                    end
                    pan:SetTall(40)
    
                    if players[ply] then
                        pan.selected = true
                    end
        
                    pan.DoClick = function()
                        if pan.selected then
                            players[ply] = nil
                            pan.selected = false
                        else
                            players[ply] = true
                            pan.selected = true
                        end
                    end
        
                    local icon = vgui.Create('SpawnIcon', pan)
                    icon:Dock(LEFT)
                    icon:SetWide(40)
                    icon:SetModel(ply:GetModel())
        
                    icon.DoClick = pan.DoClick
        
                    local label = vgui.Create('DLabel', pan)
                    label:Dock(FILL)
                    label:SetFont('Trebuchet24')
                    label:SetText(ply:Name())
                    
                    main:Add(pan)
                end
            end
        end
        
        sheet:AddSheet('Организация', cList, 'icon16/building.png')
    end


    if not table.IsEmpty(FPP.Buddies) then
        local fList = vgui.Create('DCategoryList', sheet)
        fList:Dock(FILL)
    
        local plys = {}
        for id, v in pairs(FPP.Buddies) do
            local ply = player.GetBySteamID(id)

            if not IsValid(ply) then continue end

            local t = ply:GetNetVar('disguised') and ply:GetNetVar('disguise_team') or ply:Team()
            plys[t] = plys[t] or {}
            table.insert(plys[t], ply)
        end
        
        
        for _, cat in pairs(DarkRP.getCategories().jobs) do
            for _, job in pairs(cat.members) do
                local id = job.team
                if not plys[id] then continue end
    
                local collapsible = fList:Add(job.name)
    
                local main = vgui.Create('DListLayout')
                collapsible:SetContents(main)
                
                for _, ply in ipairs(plys[id]) do
                    if ply == LocalPlayer() then continue end
                
                    local pan = vgui.Create('DButton')
                    pan:SetText('')
                    pan.Paint = function(s,w,h)
                        if s.selected then
                            draw.RoundedBox(2,0,0,w,h,Color(0,150,0))
                        end
                    end
                    pan:SetTall(40)
    
                    if players[ply] then
                        pan.selected = true
                    end
        
                    pan.DoClick = function()
                        if pan.selected then
                            players[ply] = nil
                            pan.selected = false
                        else
                            players[ply] = true
                            pan.selected = true
                        end
                    end
        
                    local icon = vgui.Create('SpawnIcon', pan)
                    icon:Dock(LEFT)
                    icon:SetWide(40)
                    icon:SetModel(ply:GetModel())
        
                    icon.DoClick = pan.DoClick
        
                    local label = vgui.Create('DLabel', pan)
                    label:Dock(FILL)
                    label:SetFont('Trebuchet24')
                    label:SetText(ply:Name())
                    
                    main:Add(pan)
                end
            end
        end
        
        sheet:AddSheet('Друзья', fList, 'icon16/heart.png')
    end


    self.settingsFrame = frame
end

-- These functions are only here so no errors occur when used with willox's keypad,
-- because this addon aims to be compatible with the keypad cracker.
function ENT:GetHoveredElement()
end

function ENT:SendCommand()
end


--addons/module_phone/lua/entities/krede_wd_battery/cl_init.lua:
include('shared.lua')

/*---------------------------------------------------------
Draw
---------------------------------------------------------*/
function ENT:Draw()
	self.Entity:DrawModel()
end


/*---------------------------------------------------------
IsTranslucent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end



--addons/module_chocolate/lua/entities/lucid_choc_stove.lua:
--Made by ThatCatGuy
--https://github.com/ThatCatGuy
--https://steamcommunity.com/sharedfiles/filedetails/?id=2195413561
--Stupidly rewritten by OverlordAkise (has alzheimers)

AddCSLuaFile()
ENT.Type = 'anim'
ENT.Base = "base_anim"
 
ENT.PrintName = "Chocolate Stove"
ENT.Category = "Chocolate Maker"
ENT.Author = "OverlordAkise"
ENT.Purpose = "Make Chocolate"
ENT.Instructions = "N/A"
ENT.Model = "models/props_c17/furnitureStove001a.mdl"

ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.MaxTime = 180
ENT.HP = 200

function ENT:SetupDataTables()
    self:NetworkVar("Int", 1, "Cocoa")
    self:NetworkVar("Int", 2, "Sugar")
    self:NetworkVar("Int", 3, "Milk")
    self:NetworkVar("Int", 5, "CookStartTime")    
    self:NetworkVar("Entity", 0, "owning_ent")
end

if CLIENT then

  function ENT:OnRemove()
    self:StopSound("ambient/machines/engine1.wav")
  end

  function ENT:Draw()
    self:DrawModel() 
    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    local dist = Pos:DistToSqr(LocalPlayer():GetPos())
    
    if (dist > 100000) then return end
    local owner = self:CPPIGetOwner()
    local Cocoa = self:GetCocoa()
    local Sugar = self:GetSugar()
    local Milk = self:GetMilk()
    local cookStartTime = self:GetCookStartTime()

    Ang:RotateAroundAxis(Ang:Right(),-90)
    Ang:RotateAroundAxis(Ang:Up(),90)
    cam.Start3D2D(Pos + (Ang:Up() * 15),Ang,0.10)
      local w = 130
	  draw.RoundedBox(0,-160,-130,320,w,Color( 43, 49, 54, 255 )) 
	  draw.RoundedBox(0,-160,-130,320,30, Color(236, 113, 71, 255) ) --Color( 43, 49, 54, 255 )
      
      if IsValid(owner) then
        draw.SimpleText(owner:Nick(),"Trebuchet24",0,-125,Color(255,255,255),TEXT_ALIGN_CENTER,0,2,Color(0,0,0,255))
      end
      draw.SimpleText("Необходимо:","Trebuchet24",0,-100,Color(255,255,255),TEXT_ALIGN_CENTER,0,2,Color(0,0,0,255))
      draw.SimpleText("Какао " .. Cocoa .. "/2","Trebuchet24",0,-75,(Cocoa == 2 and Color(0,255,0) ) or Color(255,255,255),TEXT_ALIGN_CENTER,0,2,Color(0,0,0,255))
      draw.SimpleText("Сахар " .. Sugar .. "/1","Trebuchet24",0,-55,(Sugar == 1 and Color(0,255,0) ) or Color(255,255,255),TEXT_ALIGN_CENTER,0,2,Color(0,0,0,255))
      draw.SimpleText("Молоко " .. Milk .. "/1","Trebuchet24",0,-35,(Milk == 1 and Color(0,255,0) ) or Color(255,255,255),TEXT_ALIGN_CENTER,0,2,Color(0,0,0,255))

      if cookStartTime > 0 then
        local current = ((os.time()-self:GetCookStartTime())*100)/self.MaxTime
        self.tt = (current * 296)/100
        if self.tt <= 295 then
          if not self.Sound then
            self.Sound = true
            self:EmitSound("ambient/machines/engine1.wav", 75, 100, 0.2, CHAN_AUTO)
          end
        end
        draw.RoundedBox(0,-150,20,300,30,Color( 43, 49, 54, 255 ))
        draw.RoundedBox(0,-150,20,self.tt,30,Color(236, 113, 71, 255))
        draw.SimpleText("Готовка...","Trebuchet24",0,20,Color(255,255,255),TEXT_ALIGN_CENTER,0,2,Color(0,0,0,255))
        
      else
        if self.Sound then 
          self.Sound = false
          self:StopSound("ambient/machines/engine1.wav")
          self:EmitSound("items/ammocrate_open.wav",75,100,0.7,CHAN_AUTO)
        end
      end
    cam.End3D2D() 
  end
end

if SERVER then
  
  function ENT:OnTakeDamage(cDamage)
    self.HP = self.HP - cDamage:GetDamage()
    if self.HP <= 0 then
      local vPoint = self:GetPos()
      local effectdata = EffectData()
      effectdata:SetStart(vPoint)
      effectdata:SetOrigin(vPoint)
      effectdata:SetScale(1)
      util.Effect("Explosion", effectdata)
      self:Remove()
    end
  end
  
  function ENT:Initialize()
    self:SetModel(self.Model)
    self:PhysicsInit( SOLID_VPHYSICS )
    self:SetMoveType( MOVETYPE_VPHYSICS )
    self:SetSolid( SOLID_VPHYSICS )
    self:GetPhysicsObject():SetMass(105) -- to make the gravitygun work
    local phys = self:GetPhysicsObject()
    if (phys:IsValid()) then
      phys:Wake()
    end

    self:CPPISetOwner(self:Getowning_ent())
  end
   
  function ENT:Use( activator, caller )
      return
  end
   
  function ENT:Think()
  end
 
  --ENT:TakeDamage(amount,ent_attacker,ent_inflictor)
  function ENT:StartTouch(entity)
    if entity:GetClass() == "lucid_choc_milk" then
      if self:GetMilk() >= 1 then return end
      self:SetMilk(self:GetMilk()+1)
      entity:Remove()
    end
    if entity:GetClass() == "lucid_choc_sugar" then
      if self:GetSugar() >= 1 then return end
      self:SetSugar(self:GetSugar()+1)
      entity:Remove()
    end
    if entity:GetClass() == "lucid_choc_cocoa" then
      if self:GetCocoa() >= 2 then return end
      self:SetCocoa(self:GetCocoa()+1)
      entity:Remove()
    end
    if self:GetCocoa() < 2 or self:GetMilk() < 1 or self:GetSugar() < 1 then return end
    if self:GetCookStartTime() ~= 0 then return end
    --Start work
    self:SetCookStartTime(os.time())
    timer.Simple(self.MaxTime,function()
      if not IsValid(self) then return end
      self:SetCookStartTime(0)
      self:SetMilk(0)
      self:SetCocoa(0)
      self:SetSugar(0)
      DarkRP.notify(self:CPPIGetOwner(), 0, 5, "Твой шоколад закончил готовится")
      local chocolate = ents.Create("lucid_choc_chocolate")
      chocolate:SetPos(self:GetPos()+Vector(0,0,30))
      chocolate:SetAngles(self:GetAngles())
      chocolate:Spawn()
      chocolate:Activate()
    end)
  end
end
--addons/module_samogon/lua/entities/mn_barrel/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_bucket/cl_init.lua:

include("shared.lua")

surface.CreateFont( "dist_font_28", {
	font = "Lato",
	size = 45,
	weight = 500,
	antialias = true
} )

local load1 = Material("materials/dist_ui/water.jpg")
local load2 = Material("materials/dist_ui/front/Borders Above the Ins.png")
local load3 = Material("materials/dist_ui/front/First In.png")
local load4 = Material("materials/dist_ui/front/Second In.png")
local load5 = Material("materials/dist_ui/front/First Barrel.png")
local load6 = Material("materials/dist_ui/front/Second Barrel.png")
local load7 = Material("materials/dist_ui/front/Third Barrel.png")
local load8 = Material("materials/dist_ui/front/Fourth Barrel.png")

function ENT:Draw()

	self:DrawModel()
	
	local dist_pos = self:GetPos()
	local ply = LocalPlayer()

	if dist_pos:DistToSqr(ply:GetPos()) > 90000 then return end
	
	local dist_ang = self:GetAngles()
	local dist_cou = self:Getdist_barrel()
	
	dist_ang:RotateAroundAxis(self:GetAngles():Up(), 450)
	dist_ang:RotateAroundAxis(self:GetAngles():Right(), 360)
	dist_ang:RotateAroundAxis(self:GetAngles():Up(), 90)
	
	cam.Start3D2D(dist_pos + dist_ang:Up() * 10, dist_ang, 0.11)	
				
		surface.SetDrawColor( 255,255,255 )
		surface.SetMaterial( load1	) 
		surface.DrawTexturedRect( -350,-350,700,700 )	

	cam.End3D2D()
	
	dist_ang:RotateAroundAxis(self:GetAngles():Up(), 270)
	dist_ang:RotateAroundAxis(self:GetAngles():Right(), 270)
	dist_ang:RotateAroundAxis(self:GetAngles():Up(), 0)
	
	cam.Start3D2D(dist_pos + dist_ang:Up() * 51, dist_ang, 0.11)	
				
		surface.SetDrawColor( 255,255,255 )
		surface.SetMaterial( load3	) 
		surface.DrawTexturedRect( -315,-60,630,126 )
		surface.SetMaterial( load4	) 
		surface.DrawTexturedRect( -315,-60,630,126 )
		
		-- Display barrels at same time.
		if ( dist_cou >= 1 ) then
			surface.SetMaterial( load5	) 
			surface.DrawTexturedRect( -315,-60,630,126 )
		end
		
		if ( dist_cou >= 2 ) then
			surface.SetMaterial( load6	) 
			surface.DrawTexturedRect( -315,-60,630,126 )
		end
		
		if ( dist_cou >= 3 ) then		
			surface.SetMaterial( load7	) 
			surface.DrawTexturedRect( -315,-60,630,126 )
		end
		
		if ( dist_cou >= 4 ) then
			surface.SetMaterial( load8	) 
			surface.DrawTexturedRect( -315,-60,630,126 )
		end
	
		surface.SetMaterial( load2	) 
		surface.DrawTexturedRect( -315,-60,630,126 )
		
		draw.SimpleText(dist_cou, "dist_font_28", 0, -10, Color(255,255,255),1,1)
		
	cam.End3D2D()
		
end	



--addons/module_samogon/lua/entities/mn_corn/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Кукуруза"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/module_samogon/lua/entities/mn_gseed/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_pot/cl_init.lua:
include("shared.lua")

local dist_load1 = Material("materials/dist_ui/grainpanel.png")	
local dist_load2 = Material("materials/dist_ui/panelcorn.png")	

function ENT:Draw()
	self:DrawModel()
	
	local dist_pos = self:GetPos()
	local ply = LocalPlayer()

	if dist_pos:DistToSqr(ply:GetPos()) > 90000 then return end
	
	local dist_ang = self:GetAngles()
	
	dist_ang:RotateAroundAxis(self:GetAngles():Up(), 450)
	dist_ang:RotateAroundAxis(self:GetAngles():Right(), 270)
	dist_ang:RotateAroundAxis(self:GetAngles():Up(), 180)
	
	cam.Start3D2D(dist_pos + dist_ang:Up() * 6.5, dist_ang, 0.04)	
	
		if self:Getdist_harvest() then
			draw.RoundedBox(0,-78,-204,161,161,Color(0,100,0))
		else	
			draw.RoundedBox(0,-78,-204,161,161,Color(100,0,0))
		end
		
		if ( self:Getdist_crop() == 1 ) then
			surface.SetDrawColor( 216, 216, 216, 255 )	
			surface.SetMaterial( dist_load2	) 
			surface.DrawTexturedRect( -78,-204,161,161 )		
		elseif ( self:Getdist_crop() == 2 ) then
			surface.SetDrawColor( 216, 216, 216, 255 )	
			surface.SetMaterial( dist_load1	) 
			surface.DrawTexturedRect( -78,-204,161,161 )
		end
	
	cam.End3D2D()	
end	
--addons/weapon_hover/lua/entities/modulus_hoverboard/shared.lua:

ENT.Type = "vehicle"
ENT.Base = "base_anim"
ENT.PrintName = "Hoverboard"
ENT.Spawnable = false

ENT.ThrusterPoints = {
	{ Pos = Vector( -24, 13, 24 ) },
	{ Pos = Vector( 24, 13, 20 ) }, -- was 24 on z
	{ Pos = Vector( -24, -13, 24 ) },
	{ Pos = Vector( 24, -13, 20 ) }, -- was 24 on z

	{ Pos = Vector( -48, 0, 24 ), Diff = 24, Spring = 3 }, -- was 0 on z
}

function ENT:SetupDataTables()

	self:NetworkVar( "Float", 0, "BoostShake" )
	self:NetworkVar( "Float", 1, "BoardVelocity" )
	self:NetworkVar( "Float", 2, "MaxLength" )
	self:NetworkVar( "Float", 3, "TrailScale" )
	self:NetworkVar( "Float", 4, "BoardRotation" )

	self:NetworkVar( "String", 0, "HoverHeight" ) -- Stupid limits!
	self:NetworkVar( "String", 1, "ViewDistance" )
	self:NetworkVar( "String", 2, "EffectCount" )

	self:NetworkVar( "Bool", 0, "DarkInner" )

	self:NetworkVar( "Vector", 0, "TrailColor" )
	self:NetworkVar( "Vector", 1, "TrailBoostColor" )
	self:NetworkVar( "Vector", 2, "TrailRechargeColor" )

	self:NetworkVar( "Entity", 0, "ScriptedVehicle" )

end

function ENT:GetDriver()
	return self:GetOwner()
end

hook.Add( "ShouldDrawLocalPlayer", "hoverboards_draw", function()
	if ( IsValid( LocalPlayer():GetNWEntity( "ScriptedVehicle" ) ) ) then return false end
end )

hook.Add( "CalcView", "__111hoverboards_calcview", function( pl, pos, ang, fov )

	local ent = pl:GetNWEntity( "ScriptedVehicle" )

	pl.ShouldDisableLegs = false
	if ( !IsValid( ent ) || ent:GetClass() != "modulus_hoverboard" ) then return end
	if ( pl:InVehicle() || !pl:Alive() || pl:GetViewEntity() != pl ) then return end
	pl.ShouldDisableLegs = true

	--ang:RotateAroundAxis( Vector( 0, 0, 1 ), ent:GetBoardRotation() )
	local dir = ang:Forward()

	local pos = ent:GetPos() + Vector( 0, 0, 64 ) - ( dir * tonumber( ent:GetViewDistance() ) )
	local speed = ent:GetVelocity():Length() - 500

	-- shake their view
	if ( ent:IsBoosting() && speed > 0 && ent:GetBoostShake() == 1 ) then

		local power = 14 * ( speed / 700 )

		local x = math.Rand( -power, power ) * 0.1
		local y = math.Rand( -power, power ) * 0.1
		local z = math.Rand( -power, power ) * 0.1

		pos = pos + Vector( x, y, z )

	end

	-- trace to keep it out of the walls
	local tr = util.TraceHull( {
		start = ent:GetPos() + Vector( 0, 0, 64 ),
		endpos = pos,
		filter = { ent, pl, ent:GetNWEntity( "Avatar", NULL ) },
		mask = MASK_NPCWORLDSTATIC,
		mins = Vector( -4, -4, -4 ),
		maxs = Vector( 4, 4, 4 )
	} )

	-- setup view
	local view = {
		origin = tr.HitPos,
		angles = dir:Angle(),
		fov = fov,
	}

	return view

end )

function ENT:IsGrinding()

	return self:GetNWBool( "Grinding", false )

end

function ENT:Boost()

	return self:GetNWInt( "Boost", 0 )

end

function ENT:IsBoosting()

	return self:GetNWBool( "Boosting", false )

end

function ENT:GetThruster( index )

	local pos = self:LocalToWorld( self.ThrusterPoints[ index ].Pos )

	-- get distance and dir
	local dist = ( self:GetPos() - pos ):Length()
	local dir = ( pos - self:GetPos() ):GetNormalized()

	-- rotate
	dir = dir:Angle()
	dir:RotateAroundAxis( self:GetUp(), self:GetBoardRotation() )
	dir = dir:Forward()

	-- return
	return self:GetPos() + dir * dist

end

hook.Remove( "Move", "Hoverboard_Move")

/*
hook.Add( "Move", "Hoverboard_Move", function( pl, mv )

	-- get the scripted vehicle
	local board = pl:GetNWEntity( "ScriptedVehicle" )

	-- make sure they are using the hoverboard
	if ( !IsValid( board ) || board:GetClass() != "modulus_hoverboard" ) then return end

	-- set their origin
	mv:SetOrigin( board:GetPos() )

	-- prevent their movement
	return true

end )

hook.Remove( "UpdateAnimation", "Hoverboard_UpdateAnimation")

hook.Add( "UpdateAnimation", "Hoverboard_UpdateAnimation", function( pl )

	local board = pl:GetNWEntity( "ScriptedVehicle" ) -- get the scripted vehicle

	-- make sure they are using the hoverboard
	if ( !IsValid( board ) || board:GetClass() != "modulus_hoverboard" ) then return end

	-- copy pose parameters
	local pose_params = { "head_pitch", "head_yaw", "body_yaw", "aim_yaw", "aim_pitch" }
	for _, param in pairs( pose_params ) do

		if ( IsValid( board.Avatar ) ) then

			local val = pl:GetPoseParameter( param )
			board.Avatar:SetPoseParameter( param, val )

		end

	end

end )
*/
--addons/weapon_hover/lua/entities/modulus_hoverboard/effects/plasma_thruster_middle.lua:

local plasma = Material( "effects/strider_muzzle" )
local refract = Material( "sprites/heatwave" )

function EFFECT:Init( pos, normal, scale )

	self.Position = pos
	self.Scale = scale
	self.Normal = normal:Angle()

	self.Emitter = ParticleEmitter( self.Board:GetPos() )

end

function EFFECT:ShouldRender( )

	if( self.Board:IsGrinding() || self.Board:GetUp().z < 0.33 || self.Board:WaterLevel() > 0 ) then return false end

	return true

end

function EFFECT:Think( )

end

function EFFECT:Render( )

	if( !self:ShouldRender() ) then return end

	local anchor = self.Board:LocalToWorld( self.Position )

	local normal = self.Board:LocalToWorldAngles( self.Normal ):Forward()
	anchor = anchor + normal * 2.5

	render.SetMaterial( refract )
	render.DrawSprite( anchor, 4 * math.Rand( 1, 1.5 ), 4 * math.Rand( 1, 1.5 ), Color( 128, 200, 255, 255 ) )

	local scroll = UnPredictedCurTime() * -20

	render.SetMaterial( plasma )

	scroll = scroll * 0.9
	render.StartBeam( 3 )
		render.AddBeam( anchor, 3, scroll, Color( 0, 255, 255, 255 ) )
		render.AddBeam( anchor + normal * 8, 3, scroll + 0.01, Color( 255, 255, 255, 255 ) )
		render.AddBeam( anchor + normal * 12, 3, scroll + 0.02, Color( 0, 255, 255, 0) )
	render.EndBeam()

	scroll = scroll * 0.9
	render.StartBeam( 3 )
		render.AddBeam( anchor, 3, scroll, Color( 0, 255, 255, 255 ) )
		render.AddBeam( anchor + normal * 3, 3, scroll + 0.01, Color( 255, 255, 255, 255 ) )
		render.AddBeam( anchor + normal * 6, 3, scroll + 0.02, Color( 0, 255, 255, 0) )
	render.EndBeam()

	scroll = scroll * 0.9
	render.StartBeam( 3 )
		render.AddBeam( anchor, 3, scroll, Color( 0, 255, 255, 255) )
		render.AddBeam( anchor + normal * 3, 3, scroll + 0.01, Color( 255, 255, 255, 255) )
		render.AddBeam( anchor + normal * 6, 3, scroll + 0.02, Color( 0, 255, 255, 0) )
	render.EndBeam()

end

--addons/weapon_hover/lua/entities/modulus_hoverboard_avatar/shared.lua:

ENT.Type = "anim"
ENT.Spawnable = false
ENT.AutomaticFrameAdvance = true
ENT.Model = "models/humans/group03/male_02.mdl"

util.PrecacheModel( ENT.Model )

--addons/ent_top/lua/entities/score_base/cl_init.lua:
include("shared.lua")

surface.CreateFont( "score_title", {
	font = "Roboto",
	size = 21,
	weight = 400,
	antialias = true
} )

surface.CreateFont( "score_row_header", {
	font = "Roboto",
	size = 19,
	weight = 400,
	antialias = true
} )

surface.CreateFont( "score_row_text", {
	font = "Roboto",
	size = 16,
	weight = 400,
	antialias = true
} )

local logo = Material('data/wimages/wlogo.png')
http.DownloadMaterial('http://wayzerroleplay.myarena.ru/wimages/wlogo.png', 'wlogo.png', function(img)
	logo = img
end)

local color_dark = Color( 43, 49, 54, 255 )
local color_bright = Color(236, 113, 71, 255)
local color_logo = Color(150, 150, 150, 60)
local color_other = Color(77, 75, 77 , 255)

function ENT:Draw()
    local ply = LocalPlayer()
    local distSqr = 1000000
    
    if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end
	self:DrawModel()
	local Pos = self:GetPos()
	local Ang = self:GetAngles()

	Ang:RotateAroundAxis( Ang:Forward(), 270)
	Ang:RotateAroundAxis( Ang:Up(), 180 )
	Ang:RotateAroundAxis( Ang:Right(), 90 )
	
	cam.Start3D2D(Pos - ( Ang:Forward() * 110 ) + ( Ang:Up() * 3 ) - ( Ang:Right() * 70 ), Ang, .5)
		draw.RoundedBox(0,-16,10,470,255,color_dark) 
		draw.RoundedBox( 0,-16,10,470,28, color_bright ) --color_dark
		surface.SetDrawColor( color_logo )
		surface.SetMaterial( logo ) 
		surface.DrawTexturedRect( 140, 70, 150, 150 )	
		surface.SetDrawColor( color_other )
		surface.DrawOutlinedRect( -16,10,470,255 )
		
		draw.SimpleText( self.TitleName, "Trebuchet24", 220, 25, color_white, 1, 1 )
	cam.End3D2D()
	
	cam.Start3D2D(Pos - ( Ang:Forward() * 110 ) + ( Ang:Up() * 3 ) - ( Ang:Right() * 60 ), Ang, .5)
		self:DrawFunc( self.score_data )
	cam.End3D2D()
end

function ENT:Initialize()
	self.score_data = {}

	net.Start( "get_score_data" )
		net.WriteEntity( self )
	net.SendToServer()
end

net.Receive( "stream_score", function()
	local sheet = net.ReadEntity()
	local tab = net.ReadTable()
	
	if ( IsValid( sheet ) ) then
		sheet.score_data = tab

		if sheet:GetClass() == "score_clans" then
			for k,v in pairs(sheet.score_data) do
				if v.avatar and v.avatar ~= '' then
			        http.DownloadMaterial(v.avatar, nil, function(mat)
			            v.AvatarMaterial = mat and not mat:IsError() and mat
			        end)
				end
			end
		end
	end
end )
--addons/module_weed/lua/entities/sent_base_gonzo.lua:

AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

ENT.PrintName		= "Drug"
ENT.Author			= "Gonzo"
ENT.Category		= "Drugs"

ENT.Spawnable 		= false
ENT.AdminOnly 		= false

ENT.Size = Vector(0,30,30)

ENT.RenderGroup                 = RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance = true;

ENT.Quality = 50

function ENT:SpawnFunction( ply, tr, ClassName )

        if ( !tr.Hit ) then return end

        local SpawnPos = tr.HitPos

        local ent = ents.Create( ClassName )
        ent:SetPos( SpawnPos + tr.HitNormal * 4 )
        ent:Spawn()
        ent:Activate()

        return ent
end

function ENT:OnTakeDamage(dmg)
    if(WEED_CONFIG.ItemsHealth > 0 && dmg:IsExplosionDamage() || dmg:IsBulletDamage()) then
        self.SHealth = (self.SHealth or WEED_CONFIG.ItemsHealth) - dmg:GetDamage()
        if(self.SHealth <= 0) then
            self:Remove()
        end
    end
end

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/gonzo/weed/pot.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
		self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
		self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
        self:SetUseType(SIMPLE_USE)
	    
        local phys = self:GetPhysicsObject()
		
        if (phys:IsValid()) then
			phys:Wake()
		end


		self:SetTrigger(true)
	end
end

function ENT:Use( activator, caller )
    return
end

local rope = Material("gui/rope")
function ENT:Draw()
    self:DrawModel()
    if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
        return
    end

	if(LocalPlayer():GetEyeTrace().Entity == self) then
        render.SetMaterial(rope)
		render.DrawBeam(self:GetPos()+self:GetUp()*self.Size.x,self:GetPos()+Vector(0,0,self.Size.z)+LocalPlayer():GetRight()*self.Size.y*1.05,1,0,3,Color(255,255,255))

    	local eyeAng = EyeAngles()
    	eyeAng.p = 0
    	eyeAng.y = eyeAng.y - 90 - 18
    	eyeAng.r = 90

    	cam.Start3D2D(self:GetPos() + Vector(0,0,self.Size.z)+LocalPlayer():GetRight()*self.Size.y, eyeAng, 0.1)
        cam.IgnoreZ(true)
        self:DoInfo(self:GetPos())
        cam.IgnoreZ(false)
    	cam.End3D2D()
	end
    
    if(isfunction(self.PostDraw)) then
      self:PostDraw()
    end
end

local w,h = 0,0

function ENT:DoInfo()
  surface.SetDrawColor(50,50,50,150)
  surface.DrawRect(12,-h/2,w+40,h+16)
  w,h = draw.SimpleTextOutlined(self.PrintName,"MainWeedFont",32,0,Color(255,255,255),TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER,1,Color(75,75,75))

  surface.SetMaterial(rope)
  surface.SetDrawColor(255,255,255,255)
  surface.DrawTexturedRectUV( 12, -32, 4, h+16, 0, 0, 1, 1 )
  surface.DrawTexturedRectUVRotated(12+w+40, 8, 4, h+16, 0, 0, 1, 1 ,180)
  surface.DrawTexturedRectUVRotated((w+40)/2+12, -32, 4, (w+40), 0, 0, 1, 2 ,90)
  surface.DrawTexturedRectUVRotated((w+40)/2+12, -32+h+16, 4, (w+40), 0, 0, 1, 2 ,90)

end
--addons/module_weed/lua/entities/sent_water_loader.lua:

AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"
ENT.PrintName		= "Балон с водой"
ENT.Author			= "Gonzo"
ENT.Spawnable 		= false
ENT.Category		= "Drugs"
ENT.AdminOnly 		= true
ENT.Size = Vector(20,30,30)

ENT.Soil = 1;

function ENT:SpawnFunction( ply, tr, ClassName )

	if ( !tr.Hit ) then return end

	local SpawnPos = tr.HitPos

	local ent = ents.Create( ClassName )
	ent:SetPos( SpawnPos )
	ent:Spawn()
	ent:Activate()
	ent.Owner = ply

	return ent

end

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/props_c17/canister01a.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCharges(3)

	  local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
	end
end

function ENT:Touch(entity)
	if(entity:GetClass() == "sent_water_pot" && entity:GetWaterAmount() < 250 && entity:GetShower()) then
		entity:SetWaterAmount(300)
		entity:EmitSound("buttons/button1.wav")
		self:SetCharges(self:GetCharges()-1)
		if(self:GetCharges() <= 0) then
			self:Remove()
		end
	end
end


function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "Charges")
end
--addons/module_slotmachine/lua/entities/slot_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Base"
ENT.Spawnable = false
ENT.Category = "WaySlots"

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar('Bool', 10, 'InService')
    self:NetworkVar('Int', 10, 'Price')
end
--addons/module_slotmachine/lua/entities/slot_roulette/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
    self.Rotate = 0
    self.Seed = 0
    -- History
    --[[
    self.History = util.Stack()
    ]]
end

local back = Material('slot_roulette_1.png')
local wheel = Material('slot_roulette_2.png')

function ENT:DrawScreen(x, y)
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(wheel)
    surface.DrawTexturedRectRotated(1, y + 212, 230, 230, self.Rotate)
    surface.SetMaterial(back)
    surface.DrawTexturedRect(x, y + 2, 500, 380)
    draw.SimpleText(string.Comma(self:GetPrice(), '.') .. '$', 'Trebuchet24', 0, -938, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    -- History
    --[[
    local q = 0

    for k = #self.History, 1, -1 do
        draw.SimpleText(self.History[k], 'Trebuchet24', 210, y + 250 + q, color_white)
        q = q + 20
    end
    ]]
end

function ENT:Update(_, _, n)
    self.Rotate = -360 * 360
    self.Seed = n
    -- History
    --[[
    timer.Simple(.3, function()
        if self.History[0] >= 5 then
            for k, v in ipairs(self.History) do
                if k == 1 then continue end
                self.History[k - 1] = v
            end

            self.History[0] = 4
        end

        self.History:Push(self.Seeds[math.Round(n)])
    end)
    ]]
end

function ENT:Think()
    if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 36000 then 
      self:SetNextClientThink( CurTime() + 1 )
      return true
    end

    self.Rotate = math.Round(Lerp(.5, self.Rotate, 360 * (self.Seed / 8)), 8)

    self:SetNextClientThink( CurTime() )
    return true
end


--addons/module_slotmachine/lua/entities/slot_roulette/shared.lua:
ENT.Type = "anim"
ENT.Base = "slot_base"
ENT.PrintName = "Рулетка"
ENT.Spawnable = true
ENT.Category = "WaySlots"

ENT.Seeds = {
    [1] = -2,
    [2] = 2,
    [3] = -3,
    [4] = 3,
    [5] = -4,
    [6] = 4,
    [7] = -5,
    [8] = 5,
}

function ENT:SetupDataTables()
    self.BaseClass.SetupDataTables(self)
    self:NetworkVar('Float', 0, 'Seed')

    if CLIENT then
        self:NetworkVarNotify('Seed', self.Update)
    end
end
--gamemodes/darkrp/entities/entities/spawned_weapon/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    local ret = hook.Call("onDrawSpawnedWeapon", nil, self)
    if ret ~= nil then return end
    self:DrawModel()

    if self.dt.amount == 1 then return end

    local Pos = self:GetPos()
    local Ang = self:GetAngles()
    local text = DarkRP.getPhrase("amount") .. self.dt.amount

    surface.SetFont("HUDNumber5")
    local TextWidth = surface.GetTextSize(text)

    Ang:RotateAroundAxis(Ang:Forward(), 90)

    cam.Start3D2D(Pos + Ang:Up(), Ang, 0.11)
        draw.WordBox(2, 0, -40, text, "HUDNumber5", Color(140, 0, 0, 100), Color(255,255,255,255))
    cam.End3D2D()

    Ang:RotateAroundAxis(Ang:Right(), 180)

    cam.Start3D2D(Pos + Ang:Up() * 3, Ang, 0.11)
        draw.WordBox(2, -TextWidth, -40, text, "HUDNumber5", Color(140, 0, 0, 100), Color(255,255,255,255))
    cam.End3D2D()
end

--[[---------------------------------------------------------------------------
Create a shipment from a spawned_weapon
---------------------------------------------------------------------------]]
properties.Add("createShipment",
{
    MenuLabel   =   "Create a shipment",
    Order       =   2002,
    MenuIcon    =   "icon16/add.png",

    Filter      =   function(self, ent, ply)
                        if not IsValid(ent) then return false end
                        return ent.IsSpawnedWeapon
                    end,

    Action      =   function(self, ent)
                        if not IsValid(ent) then return end
                        RunConsoleCommand("darkrp", "makeshipment", ent:EntIndex())
                    end
})

--[[---------------------------------------------------------------------------
Interface
---------------------------------------------------------------------------]]
DarkRP.hookStub{
    name = "onDrawSpawnedWeapon",
    description = "Draw spawned weapons.",
    realm = "Client",
    parameters = {
        {
            name = "weapon",
            description = "The weapon to perform drawing operations on.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "value",
            description = "Return a value to completely override drawing",
            type = "any"
        }
    }
}

--addons/module_tech/lua/entities/technician_powerpanel.lua:
AddCSLuaFile()
ENT.Type = 'anim'
ENT.Base = "technician_base"

ENT.Name = "Powerpanel"
ENT.PrintName = "Powerpanel"
ENT.Author = "OverlordAkise"
ENT.Category = "Запрещено"
ENT.Purpose = "Press E to repair!"
ENT.Instructions = "N/A"
ENT.Model = "models/props/de_nuke/equipment1.mdl"

ENT.Spawnable = true

--addons/module_media/lua/entities/tv.lua:
AddCSLuaFile()
ENT.Base = "media_base"
ENT.Type = "anim"
ENT.PrintName = "Телевизор"
ENT.Category = "Запрещено"
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Model = 'models/props/cs_office/TV_plasma.mdl'

if CLIENT then
    local c = Vector(6, 0, 19)
    local d = Angle(0, 90, 90)

    local logo = Material('data/wimages/wlogo.png')
    local color_dark = Color( 43, 49, 54, 255 )
    local color_bright = Color(236, 113, 71, 255)

    function ENT:Draw()
        self:DrawModel()
        if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 262144 then return end
        cam.Start3D2D(self:LocalToWorld(c), self:LocalToWorldAngles(d), 0.065)

        if IsValid(self.Sound) then
            draw.RoundedBox( 0,-450,-250,900,500, color_dark ) -- color_dark 
            draw.RoundedBox(5,-145,125,300,35,color_bright) -- color_bright
            surface.SetDrawColor( color_white )
            surface.SetMaterial( logo ) 
            surface.DrawTexturedRect( -125, -200, 256, 256 )    
            draw.SimpleText( "Доступно с GMOD Chromium", "DermaLarge", -170, 100, color_white, 0, 1 )
            draw.SimpleText( "Загрузка видео...", "DermaLarge", -110, 140, color_white, 0, 1 )
            self.Sound:draw(-860 * .5, -256, 860, 512)
        else
            draw.RoundedBox( 0,-450,-250,900,500, color_dark ) -- color_dark 
            draw.RoundedBox(5,-145,125,300,35,color_bright) -- color_bright
            surface.SetDrawColor( color_white )
            surface.SetMaterial( logo ) 
            surface.DrawTexturedRect( -125, -200, 256, 256 )    
            draw.SimpleText( "Доступно с GMOD Chromium", "DermaLarge", -170, 100, color_white, 0, 1 )
            draw.SimpleText( "Видео отсутствует", "DermaLarge", -115, 140, color_white, 0, 1 )
        end

        cam.End3D2D()
    end
end
--addons/module_media/lua/entities/tv_large.lua:
AddCSLuaFile()
ENT.Base = "media_base"
ENT.Type = "anim"
ENT.PrintName = "Большой телевизор"
ENT.Category = "Запрещено"
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Model = 'models/hunter/plates/plate4x6.mdl'
ENT.Material = 'phoenix_storms/black_chrome'

if CLIENT then
    surface.CreateFont('Trebuchet128', {
        font = 'Trebuchet MS',
        size = 128
    })

    local c = Vector(0, 0, 1.8)
    local d = Angle(0, 90, 0)

    local logo = Material('data/wimages/wlogo.png')
    local color_bright = Color(236, 113, 71, 255)

    function ENT:Draw()
        self:DrawModel()
        if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 262144 then return end
        cam.Start3D2D(self:LocalToWorld(c), self:LocalToWorldAngles(d), 0.065)

        if IsValid(self.Sound) then
            draw.RoundedBox(10,-450,540,1000,135,color_bright) -- color_bright
            surface.SetDrawColor( color_white )
            surface.SetMaterial( logo ) 
            surface.DrawTexturedRect( -450, -700, 1024, 1024 )    
            draw.SimpleText( "Доступно с GMOD Chromium", "Trebuchet128", -600, 450, color_white, 0, 1 )
            draw.SimpleText( "Загрузка видео...", "Trebuchet128", -400, 600, color_white, 0, 1 )        
            self.Sound:draw(-2190, -1460, 4380, 2920)
        else
            draw.RoundedBox(10,-450,540,1000,135,color_bright) -- color_bright
            surface.SetDrawColor( color_white )
            surface.SetMaterial( logo ) 
            surface.DrawTexturedRect( -450, -700, 1024, 1024 )    
            draw.SimpleText( "Доступно с GMOD Chromium", "Trebuchet128", -600, 450, color_white, 0, 1 )
            draw.SimpleText( "Видео отсутствует", "Trebuchet128", -400, 600, color_white, 0, 1 )        
        end

        cam.End3D2D()
    end
end
--addons/ent_ammobox/lua/entities/unarrest_wood/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "UnArrest Wood"
ENT.Category = "Запрещено"
ENT.Author = "WayZer"
ENT.Spawnable = true
ENT.Price = 750000
--addons/module_itemstore/lua/itemstore/shared.lua:
itemstore.Version = "3.0"
itemstore.About = string.format( [[ItemStore v%s

Authored solely by UselessGhost
http://steamcommunity.com/id/uselessghost
]], itemstore.Version )

MsgC( color_white, "ItemStore", Color( 100, 200, 255 ), " ", itemstore.Version, " ", Color( 200, 200, 200 ), "coded by ", Color( 255, 150, 150 ), "UselessGhost", "\n" )

concommand.Add( "itemstore_about", function()
	MsgC( color_white, itemstore.About )
end )

itemstore.config = {}

function itemstore.config.Verify( setting, correct_type )
	if type( itemstore.config[ setting ] ) ~= correct_type then
		ErrorNoHalt( string.format( "[ItemStore] Configuration error: %s is %s, should be %s.", setting, var_type, correct_type ) )
		--include( "config_default.lua" )

		return false
	end

	return true
end

include( "config.lua" )

itemstore.config.Verify( "MaxStack", "number" )
itemstore.config.Verify( "DataProvider", "string" )
itemstore.config.Verify( "GamemodeProvider", "string" )
itemstore.config.Verify( "Language", "string" )
itemstore.config.Verify( "ContextInventory", "boolean" )
itemstore.config.Verify( "ContextInventoryPosition", "string" )
itemstore.config.Verify( "InvholsterTakesAmmo", "boolean" )
itemstore.config.Verify( "PickupsGotoBank", "boolean" )
itemstore.config.Verify( "AntiDupe", "boolean" )
itemstore.config.Verify( "InventorySizes", "table" )
itemstore.config.Verify( "BankSizes", "table" )
itemstore.config.Verify( "PickupDistance", "number" )
itemstore.config.Verify( "PickupKey", "number" )
itemstore.config.Verify( "Colours", "table" )
itemstore.config.Verify( "DisabledItems", "table" )
itemstore.config.Verify( "CustomItems", "table" )
itemstore.config.Verify( "IgnoreOwner", "boolean" )
itemstore.config.Verify( "Skin", "string" )
itemstore.config.Verify( "SplitWeaponAmmo", "boolean" )
itemstore.config.Verify( "MigrateOldData", "boolean" )
itemstore.config.Verify( "EnableInvholster", "boolean" )
itemstore.config.Verify( "LimitToJobs", "table" )
itemstore.config.Verify( "HighlightStyle", "string" )
itemstore.config.Verify( "HighlightColours", "table" )

include( "language.lua" )
include( "gamemodes.lua" )
include( "items.lua" )
include( "crafts.lua" )
include( "containers.lua" )
include( "trading.lua" )
include( "admin.lua" )

local _, dirs = file.Find( "itemstore/modules/*", "LUA" )
for _, mod in ipairs( dirs ) do
	MsgC( color_white, string.format( "Loading ItemStore module: %s\n", mod ) )

	local path = "itemstore/modules/" .. mod

	for _, filename in ipairs( file.Find( path .. "/*.lua", "LUA" ) ) do
		if not string.match( filename, "^sv_.+%.lua$" ) then
			AddCSLuaFile( path .. "/" .. filename )
		end
	end

	local sv_init = path .. "/sv_init.lua"
	local cl_init = path .. "/cl_init.lua"
	local shared = path .. "/shared.lua"

	if file.Exists( shared, "LUA" ) then
		include( shared )
	end

	if SERVER and file.Exists( sv_init, "LUA" ) then
		include( sv_init )
	end

	if CLIENT and file.Exists( cl_init, "LUA" ) then
		include( cl_init )
	end
end

local teams = nil
local meta = FindMetaTable( "Player" )

function meta:CanUseInventory()
	--if self:IsAdmin() then return true end -- always allow admins to access their inventories
	if not self:Alive() then return false end -- using your inventory while dead can be a bit exploitable
	if self:GetNetVar('IsBanned') then return false end

	if hook.Run('CanUseInventory', self) == false then return false end

	if #itemstore.config.LimitToJobs > 0 then
		-- process this into an associative table for faster lookups
		if not teams then
			teams = {}

			for k, v in pairs( itemstore.config.LimitToJobs ) do
				teams[ v ] = true
			end
		end

		if not teams[ self:Team() ] then
			return false
		end
	end

	return true
end
--addons/module_itemstore/lua/itemstore/language.lua:
itemstore.Language = {}

LANGUAGE = {}
include( "languages/" .. itemstore.config.Language .. ".lua" )
if SERVER then AddCSLuaFile( "languages/" .. itemstore.config.Language .. ".lua" ) end
itemstore.Language = LANGUAGE
LANGUAGE = nil

assert( itemstore.Language, "[ItemStore] Language not found" )

function itemstore.Translate( trans, ... )
	return string.format( itemstore.Language[ trans ] or trans, ... )
end
--addons/module_itemstore/lua/itemstore/languages/ru.lua:
-- Thank you for this Russian translation, Horo!
-- http://steamcommunity.com/id/HoroRu/

LANGUAGE.ok = "OK"
LANGUAGE.cancel = "Отмена"

LANGUAGE.not_permitted = "У вас нет доступа к этому действию."
LANGUAGE.file_not_found = "Файл не найден"
LANGUAGE.player_not_found = "Игрок не найден"
LANGUAGE.invalid_data = "Неправильные данные"
LANGUAGE.invalid_args = "Неправильные аргументы"
LANGUAGE.cant_fit = "Это не поместится в ваш инвентарь!"

LANGUAGE.page = "Страница %d"
LANGUAGE.inventory = "Инвентарь"
LANGUAGE.bank = "Банк"
LANGUAGE.players_inventory = "Инвентарь %s"
LANGUAGE.players_bank = "Банк %s"
LANGUAGE.admin_title = "ItemStore Админ"

LANGUAGE.move = "Переместить"
LANGUAGE.use = "Использовать"
LANGUAGE.usewith = "Использовать с..."
LANGUAGE.drop = "Бросить"
LANGUAGE.destroy = "Уничтожить"
LANGUAGE.merge = "Совместить"
LANGUAGE.split = "Разделить"
LANGUAGE.split_half = "Поделить пополам (%d)"

LANGUAGE.dragtomove = "ЛКМ для перемещения"
LANGUAGE.shiftclicktomove = "Shift+ЛКМ для быстрого перемещения"
LANGUAGE.mclicktodrop = "Колесо мыши чтобы выбросить"
LANGUAGE.rclickforoptions = "ПКМ для взаимодействия"
LANGUAGE.dclicktouse = "Двойной клик для использования"

LANGUAGE.picked_up = "Вы подняли (n) %s."

LANGUAGE.destroy_title = "Уничтожить предмет"
LANGUAGE.destroy_confirmation = "Вы уверены что хотите удалить предмет? Это действие необратимо!"

LANGUAGE.ready = "Готов"
LANGUAGE.not_ready = "Не готов"
LANGUAGE.accept = "Принять"
LANGUAGE.deny = "Отказаться"
LANGUAGE.trading_with = "Обмен с %s"
LANGUAGE.trade_request = "Запрос обмена"
LANGUAGE.wants_to_trade = "%s хочет обменятся"
LANGUAGE.too_far_away = "Вы слишком далеко чтобы обениваться."
LANGUAGE.trading_cooldown = "Вы должны немного подождать чтобы обмениваться снова."

LANGUAGE.trade_failed = "Обмен не заверешен. Вы или ваш партнер затребовали больше денег чем у вас/у него есть!"

LANGUAGE.shipment_name = "Ящик с оружием"
LANGUAGE.weapon_name = "Оружие"
LANGUAGE.shipment_desc = "Содержимое: %%s"
LANGUAGE.weapon_desc = "Патронов в магазине: %%d\nПатронов в запасе: %%d"

LANGUAGE.money_name = "Деньги"
LANGUAGE.money_desc = ""
--addons/module_itemstore/lua/itemstore/gamemodes.lua:
itemstore.gamemodes = {}

PROVIDER = {}
include( "gamemodeproviders/" .. itemstore.config.GamemodeProvider .. ".lua" )
if SERVER then AddCSLuaFile( "gamemodeproviders/" .. itemstore.config.GamemodeProvider .. ".lua" ) end
itemstore.gamemodes.Provider = PROVIDER
PROVIDER = nil

assert( itemstore.gamemodes.Provider, "[ItemStore] Gamemode provider not found" )

function itemstore.gamemodes.Run( func_name, ... )
	local func = itemstore.gamemodes.Provider[ func_name ]
	if not func then return end

	return func( itemstore.gamemodes.Provider, ... )
end

function itemstore.gamemodes.GetMoney( pl )
	return itemstore.gamemodes.Run( "GetMoney", pl )
end

if SERVER then
	function itemstore.gamemodes.SetMoney( pl, money )
		return itemstore.gamemodes.Run( "SetMoney", pl, money )
	end

	function itemstore.gamemodes.GiveMoney( pl, money )
		return itemstore.gamemodes.SetMoney( pl, itemstore.gamemodes.GetMoney( pl ) + money )
	end

	function itemstore.gamemodes.AddCommand( command, info, func )
		return itemstore.gamemodes.Run( "AddCommand", command, info, func )
	end

	itemstore.AddCommand( "trade", function( pl, args )
		args = table.concat( args, " " )

		if not pl:CanUseInventory() then
			pl:ChatPrint( itemstore.Translate( "cant_access_inventory" ) )
			return
		end

		if not itemstore.config.TradingEnabled then
			return
		end

		if hook.Run('CanTrade', pl) == false then return end

		if pl.TradingCooldown and pl.TradingCooldown > CurTime() then
			pl:ChatPrint( itemstore.Translate( "trading_cooldown" ) )
			return
		end

		local target = pl:GetEyeTrace().Entity

		if args ~= "" then
			for _, pl in player.Iterator() do
				if string.find( string.lower( pl:Name() ), string.lower( args ), 1, true ) then
					target = pl
				end
			end
		end

		if not IsValid( target ) or not target:IsPlayer() then
			pl:ChatPrint( itemstore.Translate( "player_not_found" ) )
			return
		end

		if not target:CanUseInventory() then
			pl:ChatPrint( itemstore.Translate( "partner_cant_access_inventory" ) )
			return
		end

		if pl.Trade then
			pl:ChatPrint( itemstore.Translate( "already_in_trade" ) )
			return
		end

		if target.Trade then
			pl:ChatPrint( itemstore.Translate( "partner_is_in_trade" ) )
			return
		end

		if itemstore.config.TradeDistance ~= 0 and pl:GetPos():Distance( target:GetPos() ) > itemstore.config.TradeDistance then
			pl:ChatPrint( itemstore.Translate( "too_far_away" ) )
			return
		end

		itemstore.Trade( pl, target )

		pl.TradingCooldown = CurTime() + itemstore.config.TradeCooldown
	end )

	itemstore.AddCommand( "inv", function( pl )
		pl:OpenContainer( pl.Inventory:GetID(), itemstore.Translate( "inventory" ), true )
	end )

	itemstore.AddCommand( "pickup", function( pl )
		pl:PickupItem()
	end )
end

hook.Add( "PostGamemodeLoaded", "ItemStoreGamemodeLoad", function()
	itemstore.gamemodes.Run( "Load" )
end )

--addons/module_itemstore/lua/itemstore/gamemodeproviders/darkrp.lua:
function PROVIDER:GetMoney( pl )
	return pl:GetNetVar( "money" )
end

if SERVER then
	function PROVIDER:SetMoney( pl, money )
		pl:SetNetVar( "money", money )
		if DarkRP.storeMoney then DarkRP.storeMoney( pl, money ) end
	end

	if itemstore.config.EnableInvholster then
		itemstore.AddCommand( "invholster", function( pl, args )
			if not pl:CanUseInventory() then return end

			local wep = pl:GetActiveWeapon()

			-- This code is not mine, I'm simply copypasting DarkRP stuff right here.
			if not IsValid(wep) or not wep:GetModel() or wep:GetModel() == "" then
				DarkRP.notify(pl, 1, 4, DarkRP.getPhrase("cannot_drop_weapon"))
				return
			end

			if itemstore.config.DisabledItems[ wep:GetClass() ] then
				DarkRP.notify(pl, 1, 4, DarkRP.getPhrase("cannot_drop_weapon"))
				return
			end

			if GAMEMODE.Config.restrictdrop then
				local found = false
				for k,v in pairs(CustomShipments) do
					if v.entity == wep:GetClass() then
						found = true
						break
					end
				end

				if not found then return end
			end

			local canDrop = hook.Call("canDropWeapon", GAMEMODE, pl, wep)
			if not canDrop then
				DarkRP.notify(pl, 1, 4, DarkRP.getPhrase("cannot_drop_weapon"))
				return
			end
			-- and back to our regularly scheduled coding

			pl:StartDelay('invholster', 'Убирание оружия', 1, function(s, pl)
				local item = itemstore.Item( "spawned_weapon" )

				item:SetData( "Class", wep:GetClass() )
				item:SetData( "Amount", 1 )
				item:SetData( "Model", wep:GetModel() )
				item:SetData( "Clip1", wep:Clip1() )
				item:SetData( "Clip2", wep:Clip2() )

				if not pl.Inventory:CanFit(item) then return end

				if itemstore.config.InvholsterTakesAmmo then
					local ammotype = wep:GetPrimaryAmmoType()

					if ammotype and ammotype ~= "none" then -- to be entirely honest I'm not sure if it returns nil or "none"
						local ammo = pl:GetAmmoCount( ammotype )

						item:SetData( "Ammo", ammo )
						pl:RemoveAmmo( ammo, ammotype )
					end
				end

				local swep = weapons.Get(wep:GetClass())
				if swep and swep.ItemStoreInvholster then
					swep:ItemStoreInvholster(item, pl, wep)
				end

				pl:StripWeapon( wep:GetClass() )
				pl.Inventory:AddItem( item )
			end, function(s, pl)
				if pl:GetActiveWeapon() ~= wep then return false end
			end, nil, {stopOnHurt = true})
		end)
	end
end
--addons/module_itemstore/lua/itemstore/items/base_auto.lua:
ITEM.Name = "Auto Item Base"
ITEM.Model = "models/error.mdl"
ITEM.Base = "base_entity"

ITEM.DontNetwork = {
	EntityData = true
}

function ITEM:SaveData( ent )
	self:SetModel( ent:GetModel() )
	self:SetData( "EntityData", duplicator.CopyEntTable( ent ) )
end

function ITEM:LoadData( ent )
	local data = self:GetData( "EntityData", {} )
	data.Pos = nil
	data.Angle = nil

	duplicator.DoGeneric( ent, data )

	if data.DT then
		timer.Simple( 0, function()
			for k, v in pairs( data.DT ) do
				ent.dt[ k ] = v
			end
		end )
	end
end

--addons/module_itemstore/lua/itemstore/items/base_entity.lua:
ITEM.Name = "Entity Item Base"
ITEM.Model = "models/error.mdl"

function ITEM:Load()
	self:RegisterPickup( self.Class )
end

function ITEM:CreateEntity( pos )
	local ent = ents.Create( self.Class )
	ent:SetPos( pos )
	self:LoadData(ent)
	ent:Spawn()
	ent:Activate()

	return ent
end

function ITEM:SaveData()
end

function ITEM:LoadData()
end

local multiplier = 0.35 -- Процент от цены за который предметы будет скупать барыга

local cached = {}
function ITEM:GetPrice()
	local class = self:GetData('Class') or self.Class
	local ent = cached[class]

	if not ent then
		for _, v in pairs(DarkRP.getCategories().entities) do
			for _, eTbl in pairs(v.members) do
				if eTbl.ent == class then
					ent = eTbl
					cached[class] = ent
				end
			end
		end
	end

	if not ent then return end

	local cost = ent.getPrice and ent.getPrice(ply, ent.price) or ent.price
	
	return math.floor((cost or 0) * multiplier)
end

function ITEM:Use(ply, con_id, slot)
	local pos = util.QuickTrace(ply:GetShootPos(), Vector(0,0,-1) * itemstore.config.DropDistance, ply).HitPos
	ply:DropItem(con_id, slot, pos)

	return false
end
--addons/module_itemstore/lua/itemstore/items/spawned_weapon.lua:
ITEM.Name = itemstore.Translate( "weapon_name" )
ITEM.Description = itemstore.Translate( "weapon_desc" )
ITEM.Model = "models/weapons/w_pistol.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Weapons
ITEM.Base = "base_darkrp"
ITEM.Stackable = true

ITEM.Weapons = {
	weapon_physgun = itemstore.Translate( "weapon_physgun" ),
	weapon_physcannon = itemstore.Translate( "weapon_physcannon" ),
	weapon_crowbar = itemstore.Translate( "weapon_crowbar" ),
	weapon_stunstick = itemstore.Translate( "weapon_stunstick" ),
	weapon_pistol = itemstore.Translate( "weapon_pistol" ),
	weapon_357 = itemstore.Translate( "weapon_357" ),
	weapon_smg1 = itemstore.Translate( "weapon_smg1" ),
	weapon_ar2 = itemstore.Translate( "weapon_ar2" ),
	weapon_annabelle = itemstore.Translate( "weapon_annabelle" ),
	weapon_shotgun = itemstore.Translate( "weapon_shotgun" ),
	weapon_crossbow = itemstore.Translate( "weapon_crossbow" ),
	weapon_frag = itemstore.Translate( "weapon_frag" ),
	weapon_rpg = itemstore.Translate( "weapon_rpg" ),
	weapon_slam = itemstore.Translate( "weapon_slam" ),
	weapon_bugbait = itemstore.Translate( "weapon_bugbait" )
}

function ITEM:IsValid()
	return self.Weapons[ self:GetData( "Class" ) ] or weapons.Get( self:GetData( "Class" ) )
end

function ITEM:GetWeaponClass( wep )
	return wep.GetWeaponClass and wep:GetWeaponClass() or wep.weaponclass
end

local multiplier = 0.35 -- Процент от цены за который предметы будет скупать барыга

local cached = {}
function ITEM:GetPrice()
	if self:GetData('Price') then return self:GetData('Price') end
	
	local class = self:GetData('Class')
	local shipment = cached[class]

	if not shipment then
		for _, v in pairs(DarkRP.getCategories().weapons) do
			for _, ship in pairs(v.members) do
				if ship.entity == class then
					shipment = ship
					cached[class] = shipment
				end
			end
		end

		for _, v in pairs(DarkRP.getCategories().shipments) do
			for _, ship in pairs(v.members) do
				if ship.entity == class then
					shipment = ship
					cached[class] = shipment
				end
			end
		end
	end

	if not shipment then return end

	local cost
	if shipment.seperate then
		cost = shipment.getPrice and shipment.getPrice(ply, shipment.pricesep) or shipment.pricesep
	else
		cost = shipment.getPrice and shipment.getPrice(ply, shipment.price)/shipment.amount or shipment.price/shipment.amount
	end
	
	return math.floor((cost or 0) * multiplier)
end

function ITEM:GetName()
	local name = self.Name

	if self.Weapons[ self:GetData( "Class" ) ] then
		name = self.Weapons[ self:GetData( "Class"  ) ]
	end

	local wep_class = weapons.Get( self:GetData( "Class" ) )
	if wep_class and wep_class.PrintName then
		name = wep_class.PrintName
	end

	return self:GetData( "Name", name )
end

function ITEM:GetDescription()
	local swep = weapons.Get(self:GetData("Class"))
	if swep and swep.ItemStoreGetDescription then
		local desc = swep:ItemStoreGetDescription(self)
		if desc then return desc end
	end

	local desc = self.Description

	local clip = self:GetData( "Clip1", 0 )
	local reserve = self:GetData( "Ammo", 0 )

	return self:GetData( "Description", string.format( desc, clip, reserve ) )
end

function ITEM:CanPickup( pl, ent )
	if self.MaxStack < ent:Getamount() then return false end
	if ent.PlayerUse then return false end
	if not weapons.Get( self:GetData( "Class" ) ) and
		not self.Weapons[ self:GetData( "Class" ) ] then return false end
	if itemstore.config.DisabledItems[ self:GetData( "Class" ) ] then return false end

	return true
end

function ITEM:CanMerge( item )
	local swep = weapons.Get(self:GetData("Class"))
	if swep and swep.ItemStoreCanMerge and swep:ItemStoreCanMerge(self, item) == false then
		return false
	end

	return self.Stackable and item:GetClass() == self:GetClass() and
		item:GetData( "Class" ) == self:GetData( "Class" ) and
		self.MaxStack >= self:GetAmount() + item:GetAmount()
end

function ITEM:Merge( item )
	self:SetAmount( self:GetAmount() + item:GetAmount() )

	self:SetData( "Clip2", item:GetData( "Clip2", 0 ) + self:GetData( "Clip2", 0 ) )
	self:SetData( "Ammo", item:GetData( "Ammo", 0 ) + self:GetData( "Ammo", 0 )
		+ item:GetData( "Clip1", 0 ) )
end

-- 76561198136465722

function ITEM:Split( amount )
	self:SetAmount( self:GetAmount() - amount )

	local item = self:Copy()
	item:SetAmount( amount )

	self:SetData( "Clip1", 0 )
	self:SetData( "Clip2", 0 )
	self:SetData( "Ammo", 0 )

	return item
end

function ITEM:SaveData( ent )
	self:SetData( "Class", self:GetWeaponClass( ent ) )
	self:SetData( "Amount", ent:Getamount() )
	self:SetData( "Model", ent:GetModel() )

	if ent.clip1 then self:SetData( "Clip1", ent.clip1 ) end
	if ent.clip2 then self:SetData( "Clip2", ent.clip2 ) end

	local reserve = 0
	if ent.clip1 and ent:Getamount() > 1 then
		reserve = reserve + ent.clip1 * ( ent:Getamount() - 1 )
	end

	if ent.ammoadd then
		reserve = reserve + ent.ammoadd * ent:Getamount()
	end

	self:SetData( "Ammo", reserve )

	local swep = weapons.Get(self:GetData("Class"))
	if swep and swep.ItemStoreSaveData then
		swep:ItemStoreSaveData(self, ent)
	end
end

function ITEM:LoadData( ent )
	ent:SetModel( self:GetData( "Model" ) )
	ent:Setamount( 1 )

	if ent.GetWeaponClass then
		ent:SetWeaponClass( self:GetData( "Class" ) )
	else
		ent.weaponclass = self:GetData( "Class" )
	end

	ent.clip1 = math.floor( self:GetData( "Clip1", 0 ) / ent:Getamount() )
	ent.clip2 = math.floor( self:GetData( "Clip2", 0 ) / ent:Getamount() )
	ent.ammoadd = math.floor( self:GetData( "Ammo", 0 ) / ent:Getamount() )

	self:SetData( "Clip1", 0 )
	self:SetData( "Clip2", 0 )
	self:SetData( "Ammo", 0 )

	function ent:Initialize()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
		self:GetPhysicsObject():Wake()

		self:SetCollisionGroup( COLLISION_GROUP_INTERACTIVE_DEBRIS )
	end

	local swep = weapons.Get(self:GetData("Class"))
	if swep and swep.ItemStoreLoadData then
		swep:ItemStoreLoadData(self, ent)
	end
end

local hl2_ammo = {
	weapon_pistol = 3,
	weapon_357 = 5,
	weapon_smg1 = 4,
	weapon_ar2 = 1,
	weapon_annabelle = 7,
	weapon_shotgun = 7,
	weapon_crossbow = 6,
	weapon_frag = 10,
	weapon_rpg = 8,
}

function ITEM:Use( pl )
	if pl:isArrested() then return false end

	local class = self:GetData( "Class" )

	if not self.Weapons[ class ] and not weapons.Get( class ) then return false end

	local has_weapon = pl:HasWeapon( class )

	local wep_table = weapons.Get( class )
	local ammo, ammo_type

	if wep_table then
		ammo_type = wep_table.Primary.Ammo
	else
		ammo_type = hl2_ammo[ class ]
	end

	if ammo_type then
		ammo = pl:GetAmmoCount( ammo_type )
	end

	pl:Give( class )

	if ammo and ammo_type then
		pl:SetAmmo( ammo, ammo_type )
	end
	
	local wep = pl:GetWeapon( class )

	-- make sure we actually gave the weapon before we start deducting stuff
	if not IsValid( wep ) then return end

	if self:GetData( "Clip1" ) then
		if has_weapon then
			pl:GiveAmmo( self:GetData( "Clip1" ), wep:GetPrimaryAmmoType() )
		else
			wep:SetClip1( self:GetData( "Clip1" ) )
		end
	end

	if self:GetData( "Clip2" ) then
		if has_weapon then
			pl:GiveAmmo( self:GetData( "Clip2" ), wep:GetPrimaryAmmoType() )
		else
			wep:SetClip2( self:GetData( "Clip2" ) )
		end
	end

	self:SetData( "Clip1", 0 )
	self:SetData( "Clip2", 0 )

	if itemstore.config.SplitWeaponAmmo then
		if self:GetData( "Ammo" ) then
			local reserve = self:GetData( "Ammo" )
			local amount = self:GetAmount()

			local ammo = math.min( math.ceil( reserve / amount ), reserve )

			pl:GiveAmmo( ammo, wep:GetPrimaryAmmoType() )
			self:SetData( "Ammo", reserve - ammo )
		end
	else
		pl:GiveAmmo( self:GetData( "Ammo", 0 ), wep:GetPrimaryAmmoType() )
		self:SetData( "Ammo", 0 )
	end

	local swep = weapons.Get(self:GetData("Class"))
	if swep and swep.ItemStoreUse then
		swep:ItemStoreUse(self, pl, wep)
	end

	return self:TakeOne()
end

function ITEM:GenerateHoboTrash(data)
	local swep = weapons.Get(data.class)
	if not swep then return end

    local item = itemstore.Item(self:GetClass())

	item:SetData('Class', data.class)
	item:SetData('Amount', 1)
	item:SetData('Model', swep.WorldModel)
	item:SetData('Price', data.price)
	item.Stackable = false

    return item
end
--addons/module_itemstore/lua/itemstore/trading.lua:
--
--addons/module_itemstore/lua/itemstore/vgui/admin.lua:
local PANEL = {}

function PANEL:Init()
	self:SetTitle( itemstore.Translate( "admin_title" ) )
	self:SetSkin( "itemstore" )

	self.Scroll = vgui.Create( "DScrollPanel", self )
	self.Scroll:Dock( FILL )

	self.List = vgui.Create( "DListLayout", self.Scroll )
	self.List:Dock( FILL )
	for _, pl in player.Iterator() do
		local b = self.List:Add( "DButton" )
		b:SetText( pl:Name() )
		b:DockMargin( 0, 0, 0, 2 )

		function b.DoClick()
			local menu = DermaMenu()

			menu:AddOption( itemstore.Translate( "inventory" ), function()
				net.Start( "ItemStoreAdminInventory" )
				 	net.WriteEntity( pl )
				net.SendToServer()
			end )

			menu:AddOption( itemstore.Translate( "bank" ), function()
				net.Start( "ItemStoreAdminBank" )
					net.WriteEntity( pl )
				net.SendToServer()
			end )

			menu:Open()
		end
	end
end

vgui.Register( "ItemStoreAdmin", PANEL, "DFrame" )

--addons/module_itemstore/lua/itemstore/vgui/container.lua:
local color_green = Color(0,200,0)
local color_btn = Color(0, 0, 0, 150)

local PANEL = {}

function PANEL:Init()
	self.Pages = {}
	self.Slots = {}

	self.Craft = self.tabScroller:Add('DButton')
	self.Craft:SetSkin('WayZer')
	self.Craft:SetIcon('icon72/tools.png')
	self.Craft:SetWide(65)
	self.Craft:DockMargin(0,0,0,8)
	self.Craft:SetText('')
	self.Craft:Dock(RIGHT)
	self.Craft.Paint = function(s,w,h)
		draw.RoundedBoxEx(2, 0, 0, w, h, color_btn, true, true, false, false)
		local img_wide = s.m_Image:GetWide()
		draw.SimpleText('Крафт', 'DermaDefault', img_wide+(w-img_wide)/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	self.Craft.DoClick = function()
		local con = itemstore.containers.Get(self:GetContainerID())
		if not con then return end

		local menu = DermaMenu()

		local byClass = {}

		for craft_id, craft in pairs(itemstore.crafts.list) do
			byClass[craft.class] = byClass[craft.class] or {}
			table.insert(byClass[craft.class], craft)
		end

		for class, v in pairs(byClass) do
			local sub = menu:AddSubMenu(itemstore.Item(class):GetName())

			table.sort(v, function(a,b)
				if a.containers and not table.HasValue(a.containers, con:GetName()) then 
					return false
				end
				if b.containers and not table.HasValue(b.containers, con:GetName()) then 
					return true
				end
				return itemstore.crafts.GetProgress(con,a) > itemstore.crafts.GetProgress(con,b)
			end)

			for _, craft in ipairs(v) do
				local progress = itemstore.crafts.GetProgress(con, craft)

				local opt = sub:AddOption(craft.menu_name or craft.name or craft.item:GetName(), function()
					itemstore.OpenCraftUI(self:GetContainerID(), craft, self:GetParent())
				end)
				opt.Paint = function(s,w,h)
					derma.SkinHook('Paint', 'MenuOption', s, w, h)
	
					draw.RoundedBox(0, 0, 0, w*progress, h, color_green)
	
					return false
				end

				if craft.containers and not table.HasValue(craft.containers, con:GetName()) then 
					opt:SetEnabled(false)
				end
			end
		end

		if table.IsEmpty(byClass) then menu:AddOption('Нет крафтов :(') end

		menu:Open()
	end

	table.insert( itemstore.containers.Panels, self )
end

function PANEL:SetContainerID( id )
	self.ContainerID = id
	self:Refresh()
end

function PANEL:GetContainerID()
	return self.ContainerID
end

function PANEL:Refresh()
	local id = self:GetContainerID()
	local con = itemstore.containers.Get( id )

	if con then
		for i = 1, con:GetSize() do
			local page_id = con:GetPageFromSlot( i )
			local page = self.Pages[ page_id ]

			if not page then
				page = vgui.Create( "DIconLayout" )
				page:SetSpaceX( 1 )
				page:SetSpaceY( 1 )

				self.Pages[ page_id ] = page

				self:AddSheet( itemstore.Translate( "page", page_id ), page )
			end

			local slot = self.Slots[ i ]

			if not slot then
				slot = page:Add( "ItemStoreSlot" )
				slot:SetSize( 40, 40 )
				slot:SetContainerID( self:GetContainerID() )
				slot:SetSlot( i )

				self.Slots[ i ] = slot
			end

			slot:SetItem( con:GetItem( i ) )
			slot:Refresh()
		end
	end

	self.Craft:SetVisible(not table.IsEmpty(itemstore.crafts.list))

	self:SizeToContents()
end

function PANEL:SizeToContents()
	local id = self:GetContainerID()
	local con = itemstore.containers.Get( id )

	if con then
		local w = con:GetWidth() * 41 + 15
		local h = con:GetHeight() * 41 + 35

		self:SetSize( w, h )
	
		self.Craft:SetPos(w-self.Craft:GetWide(), 0)
	end
end

vgui.Register( "ItemStoreContainer", PANEL, "DPropertySheet" )
--addons/module_itemstore/lua/itemstore/vgui/slot.lua:
local PANEL = {}

surface.CreateFont( "ItemStoreAmount", {
	font = system.IsLinux() and "DejaVu Sans" or "Tahoma",
	size = 11,
	weight = 500
} )

local GradientUp = Material( "gui/gradient_up" )
local GradientDown = Material( "gui/gradient_down" )

AccessorFunc( PANEL, "Item", "Item" )
AccessorFunc( PANEL, "ContainerID", "ContainerID", FORCE_NUMBER )
AccessorFunc( PANEL, "Slot", "Slot", FORCE_NUMBER )
AccessorFunc( PANEL, "HighlightColor", "HighlightColor" )

function PANEL:Init()
	self.BaseClass.Init( self )

	self:Droppable( "ItemStore" )
	self:Receiver( "ItemStore", function( receiver, droptable, dropped )
		local droppable = droptable[ 1 ]

		if not dropped then return end

		local droppable = droptable[ 1 ]

		local from_con = droppable:GetContainerID()
		local to_con = droppable:GetContainerID()

		if not from_con then return end
		if not to_con then return end

		local from_slot = droppable:GetSlot()
		local to_slot = receiver:GetSlot()

		if not from_slot then return end
		if not to_slot then return end

		local from_item = droppable:GetItem()
		local to_item = receiver:GetItem()

		if from_item and to_item and ( from_item:CanMerge( to_item ) or
			from_item:CanUseWith( to_item ) ) then
			local menu = DermaMenu()

			if from_item:CanUseWith( to_item ) then
				menu:AddOption( itemstore.Translate( "usewith" ), function()
					LocalPlayer():UseItemWith( droppable:GetContainerID(), droppable:GetSlot(),
						receiver:GetContainerID(), receiver:GetSlot() )
				end ):SetIcon( "icon16/wrench_orange.png" )

				menu:AddSpacer()
			end

			menu:AddOption( itemstore.Translate( "move" ), function()
				LocalPlayer():MoveItem( droppable:GetContainerID(), droppable:GetSlot(),
					receiver:GetContainerID(), receiver:GetSlot() )
			end ):SetIcon( "icon16/arrow_switch.png" )

			if from_item:CanMerge( to_item ) then
				menu:AddOption( itemstore.Translate( "merge" ), function()
					LocalPlayer():MergeItem( droppable:GetContainerID(), droppable:GetSlot(),
						receiver:GetContainerID(), receiver:GetSlot() )
				end ):SetIcon( "icon16/arrow_join.png" )
			end

			menu:Open()
		else
			LocalPlayer():MoveItem( droppable:GetContainerID(), droppable:GetSlot(),
				receiver:GetContainerID(), receiver:GetSlot() )
		end
	end )
end

function PANEL:Paint( w, h )
	if itemstore.config.HighlightStyle == "old" or itemstore.config.HighlightStyle == "border" then
		surface.SetDrawColor( self.Hovered and itemstore.config.Colours.HoveredSlot or itemstore.config.Colours.Slot )
	else
		surface.SetDrawColor( itemstore.config.Colours.Slot )
	end

	surface.DrawRect( 0, 0, w, h )

	local item = self:GetItem()

	if item and item.HighlightColor then
		local highlightColor = self:GetHighlightColor() or item.HighlightColor

		local col = Color( highlightColor.r, highlightColor.g, highlightColor.b )
		local bright = Color( col.r * 1.25, col.g * 1.25, col.b * 1.25 )
		local dark = Color( bright.r / 2, bright.g / 2, bright.b / 2 )

		if itemstore.config.HighlightStyle == "full" then
			surface.SetDrawColor( dark )
			surface.DrawRect( 0, 0, w, h )

			surface.SetMaterial( GradientDown )
			surface.SetDrawColor( self.Hovered and bright or col )
			surface.DrawTexturedRect( 0, 0, w, h )
		elseif itemstore.config.HighlightStyle == "subtle" then
			surface.SetMaterial( GradientUp )
			surface.SetDrawColor( self.Hovered and bright or col )
			surface.DrawTexturedRect( 0, 0, w, h )
		elseif itemstore.config.HighlightStyle == "corner" then
			surface.SetMaterial( GradientUp )
			surface.SetDrawColor( self.Hovered and bright or col )
			surface.DrawTexturedRectRotated( w, h, w * 1.25, h * 1.25, 45 )
		elseif itemstore.config.HighlightStyle == "border" then
			surface.SetDrawColor( col )
			surface.DrawOutlinedRect( 0, 0, w, h )
		end
	end

	if not itemstore.config.HighlightStyle ~= "border" or not item then
		surface.SetDrawColor( itemstore.config.Colours.OuterBorder )
		surface.DrawOutlinedRect( 0, 0, w, h )
	end

	surface.SetDrawColor( itemstore.config.Colours.InnerBorder )
	surface.DrawOutlinedRect( 1, 1, w - 2, h - 2 )

	self.BaseClass.Paint( self, w, h )

	local item = self:GetItem()
	if item and item:GetAmount() > 1 then
		draw.SimpleTextOutlined( item:FormatAmount(), "ItemStoreAmount", 4, 
			h - 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM, 1, color_black )
	end
end

function PANEL:Refresh()
	local item = self:GetItem()

	if item then
		self:SetModel( item:GetModel() )
		self:SetColor( item:GetColor() or color_white )

		if IsValid( self.Entity ) then
			self.Entity:SetMaterial( item:GetMaterial() )

			local min, max = self.Entity:GetRenderBounds()

			self:SetCamPos( Vector( 0.55, 0.55, 0.55 ) * min:Distance( max ) )
			self:SetLookAt( ( min + max ) / 2 )
		end
	else
		self.Entity = nil
		self:SetTooltip( nil )
	end
end

function PANEL:DoDoubleClick()
	local con_id = self:GetContainerID()
	local slot = self:GetSlot()
	local item = self:GetItem()

	if not con_id then return end
	if not slot then return end
	if not item then return end
	if not item.Use then return end

	LocalPlayer():UseItem( con_id, slot )
end

function PANEL:DoMiddleClick()
	local con_id = self:GetContainerID()
	local slot = self:GetSlot()
	local item = self:GetItem()

	if not con_id then return end
	if not slot then return end
	if not item then return end

	LocalPlayer():DropItem( con_id, slot )
end

function PANEL:DoRightClick()
	local con_id = self:GetContainerID()
	local slot = self:GetSlot()
	local item = self:GetItem()

	if not con_id then return end
	if not slot then return end
	if not item then return end

	local menu = DermaMenu()

	if item.Use then
		menu:AddOption( itemstore.Translate( "use" ), function()
			LocalPlayer():UseItem( con_id, slot )
		end ):SetIcon( "icon16/wrench.png" )

		menu:AddSpacer()
	end

	menu:AddOption( itemstore.Translate( "drop" ), function()
		LocalPlayer():DropItem( con_id, slot )
	end ):SetIcon( "icon16/arrow_out.png" )

	menu:AddOption( itemstore.Translate( "destroy" ), function()
		Derma_Query( itemstore.Translate( "destroy_confirmation" ), itemstore.Translate( "destroy_title" ), itemstore.Translate( "ok" ), function()
			LocalPlayer():DestroyItem( con_id, slot )
		end, itemstore.Translate( "cancel" ) ):SetSkin( "itemstore" )
	end ):SetIcon( "icon16/delete.png" )

	if item:CanSplit( 1 ) then
		menu:AddSpacer()

		local submenu, entry = menu:AddSubMenu( itemstore.Translate( "split" ) )
		entry:SetIcon( "icon16/arrow_divide.png" )

		local half = math.floor( item:GetAmount() / 2 )

		submenu:AddOption( itemstore.Translate( "split_half", half ), function()
			LocalPlayer():SplitItem( con_id, slot, half )
		end )

		submenu:AddSpacer()

		for _, amount in ipairs( { 1, 2, 5, 10, 25, 50, 100, 250, 1000 } ) do
			if item:CanSplit( amount ) then
				submenu:AddOption( amount, function()
					LocalPlayer():SplitItem( con_id, slot, amount )
				end )
			end
		end

		menu:Open()
	end

	item:Run( "PopulateMenu", menu )

	menu:Open()
end

local Tooltip

function PANEL:CreateTooltip()
	if IsValid( Tooltip ) then
		Tooltip:SetVisible( true )
		return
	end

	Tooltip = vgui.Create( "ItemStoreTooltip" )
	self:UpdateTooltip()
end

function PANEL:UpdateTooltip()
	if not IsValid( Tooltip ) then return end

	Tooltip:SetContainerID( self:GetContainerID() )
	Tooltip:SetSlot( self:GetSlot() )
	Tooltip:SetItem( self:GetItem() )
	Tooltip:Refresh()
end

function PANEL:HideTooltip()
	if IsValid( Tooltip ) then Tooltip:SetVisible( false ) end
end

function PANEL:OnCursorEntered()
	if not self:GetItem() then return end

	self:CreateTooltip()
	self:UpdateTooltip()
end

function PANEL:OnCursorMoved()
	if not IsValid( Tooltip ) then return end

	local x, y = gui.MousePos()
	Tooltip:SetPos( x, y - Tooltip:GetTall() )
end

function PANEL:OnCursorExited()
	self:HideTooltip()
end

vgui.Register( "ItemStoreSlot", PANEL, "DModelPanel" )

--addons/module_itemstore/lua/itemstore/cl_player.lua:
local meta = FindMetaTable( "Player" )

function meta:MoveItem( from_con_id, from_slot, to_con_id, to_slot )
	net.Start( "ItemStoreMove" )
		net.WriteUInt( from_con_id, 32 )
		net.WriteUInt( from_slot, 32 )
		net.WriteUInt( to_con_id, 32 )
		net.WriteUInt( to_slot, 32 )
	net.SendToServer()
end

function meta:UseItem( con_id, slot, ... )
	net.Start( "ItemStoreUse" )
		net.WriteUInt( con_id, 32 )
		net.WriteUInt( slot, 32 )
		net.WriteTable( { ... } )
	net.SendToServer()
end

function meta:UseItemWith( from_con_id, from_slot, to_con_id, to_slot )
	net.Start( "ItemStoreUseWith" )
		net.WriteUInt( from_con_id, 32 )
		net.WriteUInt( from_slot, 32 )
		net.WriteUInt( to_con_id, 32 )
		net.WriteUInt( to_slot, 32 )
	net.SendToServer()
end

function meta:DropItem( con_id, slot )
	net.Start( "ItemStoreDrop" )
		net.WriteUInt( con_id, 32 )
		net.WriteUInt( slot, 32 )
	net.SendToServer()
end

function meta:DestroyItem( con_id, slot )
	net.Start( "ItemStoreDestroy" )
		net.WriteUInt( con_id, 32 )
		net.WriteUInt( slot, 32 )
	net.SendToServer()
end

function meta:MergeItem( from_con_id, from_slot, to_con_id, to_slot )
	net.Start( "ItemStoreMerge" )
		net.WriteUInt( from_con_id, 32 )
		net.WriteUInt( from_slot, 32 )
		net.WriteUInt( to_con_id, 32 )
		net.WriteUInt( to_slot, 32 )
	net.SendToServer()
end

function meta:SplitItem( con_id, slot, amount )
	net.Start( "ItemStoreSplit" )
		net.WriteUInt( con_id, 32 )
		net.WriteUInt( slot, 32 )
		net.WriteUInt( amount, 16 )
	net.SendToServer()
end

hook.Add( "InitPostEntity", "ItemStoreRequestInventory", function()
	net.Start( "ItemStoreSyncInventory" ) 
	net.SendToServer()
end )

net.Receive( "ItemStoreSyncInventory", function()
	LocalPlayer().InventoryID = net.ReadUInt( 32 )
	itemstore.CreateContextInventory()
end )

local chuds = {}
local cuiw, cuih = 600, 300
function itemstore.OpenCraftUI(cid, craft, panel)
	local frame = vgui.Create('DFrame')
	frame:SetSkin('itemstore')
	frame:SetSize(600, 300)
	frame:SetTitle('Крафт')

	if IsValid(panel) then
		if IsValid(panel.CraftFrame) then panel.CraftFrame:Remove() end

		if panel == itemstore.ContextInventory then
			frame:SetParent(g_ContextMenu)
		else
			frame:MakePopup() -- почему-то ломается
		end

		local x, y = panel:LocalToScreen(0,0)
		frame:SetPos(x+panel:GetWide()/2 - cuiw/2, y-cuih)
		panel.CraftFrame = frame
	else
		frame:Center()
	end

	frame.Craft = vgui.Create('ItemStoreCraft', frame)
	frame.Craft:Dock(FILL)
	frame.Craft:SetContainerID(cid)
	frame.Craft:SetCraft(craft)
end

hook.Add('ItemStoreSync', 'crafts', function(id, panel)
	local frame = panel.CraftFrame or panel:GetParent().CraftFrame
	if not IsValid(frame) then return end

	frame.Craft:SetCraft(frame.Craft:GetCraft())
end)

net.Receive( "ItemStoreOpen", function()
	local id = net.ReadUInt( 32 )
	local name = net.ReadString()
	local hideinv = net.ReadBit() == 1

	local con = itemstore.containers.Get( id )
	if not con then return end

	local panel = vgui.Create( "ItemStoreContainerWindow" )

	panel:SetContainerID( id )
	panel:SetTitle( name )
	panel:SetIcon( "icon72/package.png" )
	panel:Center()

	panel:MakePopup()

	function panel:OnRemove()
		if IsValid(self.CraftFrame) then self.CraftFrame:Remove() end
	end

	if not hideinv then
		local inv = vgui.Create( "ItemStoreContainerWindow" )
		inv:SetContainerID( LocalPlayer().InventoryID )
		inv:SetTitle( itemstore.Translate( "inventory" ) )
		inv:SetIcon( "icon72/school_satchel.png" )
		inv:ShowCloseButton( false )
		inv:MakePopup()
		inv:InvalidateLayout( true )

		local think = inv.Think
		function inv:Think()
			think( self )

			local x, y = panel:GetPos()
			inv:SetPos( panel:GetPos() + ( panel:GetWide() / 2 - inv:GetWide() / 2 ),
				 y + panel:GetTall() + 10 )
		end

		function panel:OnClose()
			inv:Close()
		end

		for _, v in ipairs(panel.Container.Slots) do
			local old = v.DoClick or wlib.func.blank
			v.DoClick = function(self)
				if not input.IsKeyDown(KEY_LSHIFT) then return old(self) end

				local con_id = self:GetContainerID()
				local slot = self:GetSlot()
				local item = self:GetItem()
	
				if not con_id then return end
				if not slot then return end
				if not item then return end

				local inventory = itemstore.containers.Get(inv:GetContainerID())

				local psize = inventory:GetPageSize()
				local page
				for k, v in ipairs(inv.Container:GetItems()) do
					if v.Tab:IsActive() then page = k break end
				end

				local fempty
				for i=psize*(page-1)+1, psize*page do
					local merge_item = inventory:GetItem(i)

					if not merge_item then
						fempty = fempty or i
					elseif merge_item:CanMerge(item) then
						LocalPlayer():MergeItem(con_id, slot, inventory:GetID(), i)
						return
					end
				end

				LocalPlayer():MoveItem(con_id, slot, inventory:GetID(), fempty)
			end
		end

		for _, v in ipairs(inv.Container.Slots) do
			local old = v.DoClick or wlib.func.blank
			v.DoClick = function(self)
				if not input.IsKeyDown(KEY_LSHIFT) then return old(self) end

				local con_id = self:GetContainerID()
				local slot = self:GetSlot()
				local item = self:GetItem()
	
				if not con_id then return end
				if not slot then return end
				if not item then return end

				local storage = itemstore.containers.Get(panel:GetContainerID())

				local psize = storage:GetPageSize()
				local page
				for k, v in ipairs(panel.Container:GetItems()) do
					if v.Tab:IsActive() then page = k break end
				end

				local fempty
				for i=psize*(page-1)+1, psize*page do
					local merge_item = storage:GetItem(i)

					if not merge_item then
						fempty = fempty or i
					elseif merge_item:CanMerge(item) then
						LocalPlayer():MergeItem(con_id, slot, storage:GetID(), i)
						return
					end
				end

				LocalPlayer():MoveItem(con_id, slot, storage:GetID(), fempty)
			end
		end

	end
end )
--addons/module_logs/lua/plogs_hooks/events.lua:
plogs.Register('Events', false)

plogs.AddHook('Events', 'dEvents.commandExecuted', function (ply, cmd, targets, args)
    if #targets == 0 then return end
    local str
    local copy

    if #targets > 1 then
        copy = {
            ['Ник'] = ply:LogsName(),
            ['SteamID'] = ply:LogsSteamID(),
        }
        table.remove(args, 1)
        str = ('Ивентер %s использовал команду %s на %s с аргументами %s'):format(ply:NameID(), cmd, 'всех участниках', table.concat(args, ', '))
    else
        local target = targets[1]
        copy = {
            ['Ивентер: Ник'] = ply:LogsName(),
            ['Ивентер: SteamID'] = ply:LogsSteamID(),
            ['Цель: Ник'] = target:LogsName(),
            ['Цель: SteamID'] = target:LogsSteamID(),
        }
        table.remove(args, 1)
        str = ('Ивентер %s использовал команду %s на %s с аргументами %s'):format(ply:NameID(), cmd, target:NameID(), table.concat(args, ', '))
    end
    plogs.PlayerLog(ply, 'Events', str, copy)
end)

plogs.AddHook('Events', 'dEvents.eventEnd', function (ply)
    local copy = {
        ['Ник'] = ply:LogsName(),
        ['SteamID'] = ply:LogsSteamID(),
    }

    local str = ('Ивент от %s завершен'):format(ply:NameID())

    plogs.PlayerLog(ply, 'Events', str, copy)
end)

plogs.AddHook('Events', 'dEvents.eventStart', function (ply)
    local copy = {
        ['Ник'] = ply:LogsName(),
        ['SteamID'] = ply:LogsSteamID(),
    }

    local str = ('Ивент от %s запущен'):format(ply:NameID())

    plogs.PlayerLog(ply, 'Events', str, copy)
end)

plogs.cfg.CommandBlacklist['devents'] = true
plogs.cfg.CommandBlacklist['eventpanel'] = true
plogs.cfg.CommandBlacklist['devents_admin'] = true
plogs.cfg.CommandBlacklist['go'] = true
plogs.cfg.CommandBlacklist['leave'] = true
--addons/module_logs/lua/plogs_hooks/kills.lua:
plogs.Register('Kills', true, Color(255,0,0))

plogs.AddHook('Kills', 'PlayerDeath', function(pl, _, attacker)
	local copy = {
		['Жертва: Ник'] = pl:LogsName(),
		['Жертва: SteamID']	= pl:LogsSteamID(),
	}
	local positions = {
		{
			name = 'Жертва',
			pos = pl:GetPos(),
			ang = pl:GetAngles(),
		}
	}

	local weapon = ''
	local attackerstr = ''
	if IsValid(attacker) then
		table.insert(positions, {
			name = 'Убийца',
			pos = attacker:GetPos(),
			ang = attacker:GetAngles(),
		})
		
		if attacker:IsPlayer() then
			copy['Убийца: Ник'] = attacker:LogsName()
			copy['Убийца: SteamID'] = attacker:LogsSteamID()
			weapon = ' с помощью ' .. (IsValid(attacker:GetActiveWeapon()) and attacker:GetActiveWeapon():GetClass() or 'unknown')
			attackerstr = attacker:NameID()
		else
			if attacker.CPPIGetOwner and IsValid(attacker:CPPIGetOwner()) then
				weapon = ' с помощью ' .. attacker:GetClass()
				attackerstr = attacker:CPPIGetOwner():NameID()
			else
				attackerstr = attacker:GetClass()
			end
		end
	else
		attackerstr = tostring(attacker)
	end
	plogs.PlayerLog(IsValid(attacker) and attacker:IsPlayer() and attacker or pl, 'Kills', attackerstr .. ' убил ' .. pl:NameID() .. weapon, copy, positions)
end)

local ignoreDMG = {
	['entityflame'] = true,
}

plogs.Register('Damage', false)

plogs.AddHook('Damage', 'PostEntityTakeDamage', function(ent, dmginfo, took)
	if not took then return end
	if ent:IsPlayer() then
		local copy = {
	    	['Жертва: Ник'] = ent:LogsName(),
			['Жертва: SteamID']	= ent:LogsSteamID(),
	    }
		local positions = {
			{
				name = 'Жертва',
				pos = ent:GetPos(),
				ang = ent:GetAngles(),
			}
		}
	    local weapon = ''
		local attackerstr = ''
	    local attacker = dmginfo:GetAttacker()
		if IsValid(attacker) then
			table.insert(positions, {
				name = 'Напавший',
				pos = attacker:GetPos(),
				ang = attacker:GetAngles(),
			})
			if attacker:IsPlayer() then
				copy['Напавший: Ник'] = attacker:LogsName()
				copy['Напавший: SteamID'] = attacker:LogsSteamID()
				weapon = ' с помощью ' .. (IsValid(attacker:GetActiveWeapon()) and attacker:GetActiveWeapon():GetClass() or 'unknown')
				attackerstr = attacker:NameID()
			else
				if attacker.CPPIGetOwner and IsValid(attacker:CPPIGetOwner()) then
					weapon = ' с помощью ' .. attacker:GetClass()
					attackerstr = attacker:CPPIGetOwner():NameID()
				else
					if ignoreDMG[attacker:GetClass()] then return end
					attackerstr = attacker:GetClass()
				end
			end
		else
			attackerstr = tostring(attacker)
		end
		plogs.PlayerLog(IsValid(attacker) and attacker:IsPlayer() and attacker or ent, 'Damage', attackerstr .. ' нанес ' .. math.Round(dmginfo:GetDamage(), 0) .. ' урона ' .. ent:NameID() .. weapon, copy, positions)
	end
end)

plogs.Register('Respawns', false)

plogs.AddHook('Respawns', 'PlayerRespawned', function(ply, respawner)
	local copy = {
		['Игрок: Ник'] = ply:LogsName(),
		['Игрок: SteamID'] = ply:LogsSteamID(),
		['Воскресивший: Ник'] = respawner:LogsName(),
		['Воскресивший: SteamID'] = respawner:LogsSteamID(),
	}
	local positions = {
		{
			name = 'Игрок',
			pos = ply:GetPos(),
			ang = ply:GetAngles(),
		},
		{
			name = 'Воскресивший',
			pos = respawner:GetPos(),
			ang = respawner:GetAngles(),
		},
	}

	plogs.PlayerLog(respawner, 'Respawns', respawner:NameID()..' воскресил '..ply:NameID(), copy, positions)
end)
--addons/module_logs/lua/plogs_hooks/tools.lua:
plogs.Register('Tools', false)

local buttons = {
	'ЛКМ', 'ПКМ', 'R'
}

plogs.AddHook('Tools', 'CanTool', function(pl, trace, tool, tooltable, button) -- Shame there isn't a better hook
	if (not plogs.cfg.ToolBlacklist[tool]) then
		local entstr
		if IsValid(trace.Entity) and trace.Entity ~= Entity(0) then
			local entowner = FPP and FPP.entGetOwner(trace.Entity)
			entstr = (' смотря на %s ( %s )'):format(tostring(trace.Entity), IsValid(entowner) and entowner:NameID() or 'сервер')
		end
		local str = ('%s нажал %s инструментом %q'):format(pl:NameID(), buttons[button], tool)..(entstr or '')

		local positions = {
			{
				name = 'Игрок',
				pos = pl:GetPos(),
				ang = pl:GetAngles(),
			}
		}

		if IsValid(trace.Entity) then
			table.insert(positions, {
				name = 'Энтити',
				pos = trace.Entity:GetPos(),
				ang = trace.Entity:GetAngles(),
				model = trace.Entity:GetModel(),
			})
		end

		plogs.PlayerLog(pl, 'Tools', str, {
			['Ник'] 	= pl:LogsName(),
			['SteamID']	= pl:LogsSteamID()
		}, positions)
	end
end)

plogs.AddHook('Tools', 'CanProperty', function(pl, tool, ent)
	local entstr
	if IsValid(ent) and ent ~= Entity(0) then
		local entowner = FPP and FPP.entGetOwner(ent)
		entstr = (' на энтити %s ( %s )'):format(tostring(ent), IsValid(entowner) and entowner:NameID() or 'сервер')
	end
	local str = ('%s попытался использовать в C-меню опцию %q'):format(pl:NameID(), tool)..(entstr or '')

	local positions = {
		{
			name = 'Игрок',
			pos = pl:GetPos(),
			ang = pl:GetAngles(),
		}
	}

	if IsValid(ent) then
		table.insert(positions, {
			name = 'Энтити',
			pos = ent:GetPos(),
			ang = ent:GetAngles(),
			model = ent:GetModel(),
		})
	end

	plogs.PlayerLog(pl, 'Tools', str, {
		['Ник'] 	= pl:LogsName(),
		['SteamID']	= pl:LogsSteamID()
	}, positions)
end)
--addons/module_echat/lua/autorun/client/echat.lua:
----// eChat //----
-- Author: Exho (obviously), Tomelyr, LuaTenshi
-- Version: 4/12/15

eChat = eChat or {}

eChat.config = {
	timeStamps = true,
	position = 1,	
	fadeTime = 30,
}

surface.CreateFont( "eChat", {
	font = "Roboto Bt",
	size = 24,
	weight = 500,
	antialias = false,
	shadow = true,
	extended = true,
} )

--// Prevents errors if the script runs too early, which it will
if not GAMEMODE then
	hook.Add("Think", "chat_init", function()
		hook.Remove("Think", "chat_init")
		include("autorun/client/echat.lua")
		eChat.loadOptions()
		eChat.buildBox()
	end)
	return
end

local function addButton(icon, panel, dock, cb)
	local btn = vgui.Create('DImageButton', panel)
	btn:Dock(dock)

	btn:DockMargin(2,2,2,2)
	btn:SetSize(panel:GetTall()-4, panel:GetWide()-4)

	btn:SetIcon(icon)

	btn.DoClick = function(self)
		cb()
	end

	return btn
end

eChat.type = 1
eChat.types = {
	{
		cmd = '',
		btntext = 'Чат:',
	},
	{
		cmd = '/r ',
		btntext = 'Рация',
	},
	{
		cmd = '/ooc ',
		btntext = 'OOC',
	},
	{
		cmd = '/looc ',
		btntext = 'LOOC',
	},
}

eChat.options = eChat.options or {}
function eChat.setOption(key, value)
	if eChat.options[key] == value then return end

	eChat.options[key] = value
	eChat.saveOptions()
end

function eChat.saveOptions()
	if sql.TableExists('wrp_chat_options') then
		sql.Query('UPDATE wrp_chat_options SET data = '..SQLStr(util.TableToJSON(eChat.options)))
	else
		sql.Query('CREATE TABLE IF NOT EXISTS wrp_chat_options (id integer, data text)')
		sql.Query('INSERT INTO wrp_chat_options (id, data) VALUES (1, '..SQLStr(util.TableToJSON(eChat.options))..')')
	end
end

function eChat.loadOptions()
	if sql.TableExists('wrp_chat_options') then
		local d = sql.Query('SELECT * FROM wrp_chat_options')
		if d then
			eChat.options = util.JSONToTable(d[1].data) or {}
		else
			sql.Query('INSERT INTO wrp_chat_options (id, data) VALUES (1, '..SQLStr(util.TableToJSON(eChat.options))..')')
		end
	else
		eChat.saveOptions()
	end
end

eChat.settings = {
	{
		name = 'Шрифт',
		option = 'font',
		type = 'list',
		icon = 'icon16/font.png',
		list = {
			'eChat',
			'Trebuchet24',
			'ChatFont',
			'TargetID',
			'TargetIDSmall',
			'DefaultFixedDropShadow',
			'BudgetLabel',
			'Default',
			'DefaultFixed',
			'DermaDefault',
		},
		select = function(val)
			if IsValid(eChat.chatLog) then
				eChat.chatLog:SetFontInternal(val)
			end
		end,
	},
	{
		name = 'Дата сообщений',
		icon = 'icon16/clock.png',
		option = 'logging',
		type = 'bool',
	},
	{
		name = 'Оставлять открытым после отправки',
		icon = 'icon16/monitor.png',
		option = 'dont_close_on_enter',
		type = 'bool',
	},
	{
		name = 'Скрыть чат',
		icon = 'icon16/eye.png',
		option = 'hide_chat',
		type = 'bool',
		select = function(val)
			if val then
				eChat.chatLog:SetVisible(false)
			else
				eChat.chatLog:SetVisible(true)
			end
		end
	},
	{
		name = 'Очищать строку чата после закрытия',
		icon = 'icon16/textfield_delete.png',
		option = 'clear_on_close',
		type = 'bool',
	},
	{
		name = 'Открывать чат на Enter',
		icon = 'icon16/comment.png',
		option = 'open_on_enter',
		type = 'bool',
	},
}

hook.Add('Think', 'eChat.settings', function()
	hook.Remove('Think', 'eChat.settings')
	local elements = {
		bool = 'bool',
		list = 'combobox',
	}
	for _, v in ipairs(eChat.settings) do
		local var = waySettings.registerVar('chat_'..v.option, v.name, 'Чат', elements[v.type], nil, v.type == 'list' and v.list)
		var.SetValue = function(self, val)
			eChat.setOption(v.option, val)
			if IsValid(eChat.frame) and v.select then v.select(val) end
		end
		var.GetValue = function(self)
			return eChat.options[v.option]
		end
	end
end)

function eChat.buildSettings()
	local menu = DermaMenu()

	for i, data in pairs(eChat.settings) do
		if data.option then
			local submenu, option = menu:AddSubMenu(data.name)
			
			if data.icon then
				option:SetIcon(data.icon)
			end

			if data.type == 'list' then
				for _, choice in pairs(data.list or {}) do
					local opt = submenu:AddOption(choice, function()
						eChat.setOption(data.option, choice)
						if data.select then data.select(choice) end
					end)

					if eChat.options[data.option] == choice then
						opt:SetIcon('icon16/accept.png')
					end
				end
			elseif data.type == 'bool' then
				local on = submenu:AddOption('Включить', function()
					eChat.setOption(data.option, true)
					if data.select then data.select(true) end
				end)

				local off = submenu:AddOption('Выключить', function()
					eChat.setOption(data.option, false)
					if data.select then data.select(false) end
				end)

				if eChat.options[data.option] then
					on:SetIcon('icon16/accept.png')
				else
					off:SetIcon('icon16/accept.png')
				end
			end
		else
			local option = menu:AddOption(data.name, data.select)

			if data.icon then
				option:SetIcon(data.icon)
			end
		end
	end

	menu:Open()
end

function eChat.nextType(step)
	local newType = eChat.type and eChat.type + step or 1
	
	newType = (newType < 1 and #eChat.types) or (newType > #eChat.types and 1) or newType
	
	eChat.type = newType
end

function eChat.split(str, max)
	local a = {}
	if str:len() <= max then return {str} end

	local parts = string.Explode(' ', str)
	local cmd = parts and parts[1][1] == '/' and parts[1]..' ' or nil

	if cmd then
		str = table.concat(parts, ' ', 2)
		max = max - cmd:len()
	end

	local parts = math.ceil(str:len() / max)
	local last = 1
	for i=1, parts do
		local s = string.Trim(str:sub(last, math.Clamp(max*i, last, str:len())))
		table.insert(a, (cmd or '')..s)
		last = math.Clamp(max*i, last, str:len())
	end

	return a
end

local circlered = Material('icon72/red_circle.png')
local yellowcircle = Material('icon72/yellow_circle.png')
local greencircle = Material('icon72/green_circle.png')
local color_bright = Color( 47, 52, 57, 255 )
local color_bright2 = Color(52, 152, 219)
local color_dark = Color( 30, 30, 30, 200 )
local color_dark2 = Color( 30, 30, 30, 100 )

--// Builds the chatbox but doesn't display it
function eChat.buildBox()
	if IsValid(eChat.frame) then eChat.frame:Remove() end

	local width = eChat.options.w and eChat.options.w < ScrW() and eChat.options.w or ScrW()*0.375
	local height = eChat.options.h and eChat.options.h < ScrH() and eChat.options.h or ScrH()*0.3

	eChat.frame = vgui.Create("DFrame")
	eChat.frame:SetSize( width, height )
	eChat.frame:SetTitle("")
	eChat.frame:ShowCloseButton( false )
	eChat.frame:SetDraggable( true )
	eChat.frame:SetSizable( true )
	eChat.frame:SetMinWidth( 300 )
	eChat.frame:SetMinHeight( 200 )
	eChat.frame.Paint = function( self, w, h )
		--eChat.blur( self, 10, 20, 255 )
		draw.RoundedBox( 6, 0, 10, w, h, color_dark )
		
		draw.RoundedBox( 6, 0, 10, w, 25, color_bright )
		
        surface.SetDrawColor( color_white )
        surface.SetMaterial( circlered )
        surface.DrawTexturedRect( 10, 17, 12, 12 )
        surface.SetDrawColor( color_white )
        surface.SetMaterial( yellowcircle )
        surface.DrawTexturedRect( 25, 17, 12, 12 )
        surface.SetDrawColor( color_white )
        surface.SetMaterial( greencircle )
        surface.DrawTexturedRect( 40, 17, 12, 12 )
    end
	eChat.oldPaint = eChat.frame.Paint

	local posX = eChat.options.posX and eChat.options.posX < ScrW() and eChat.options.posX or ScrW()*0.0116
	local posY = eChat.options.posY and eChat.options.posY < ScrH() and eChat.options.posY or (ScrH() - eChat.frame:GetTall()) - ScrH()*0.177

	eChat.frame:SetPos( posX, posY)

	eChat.buttons = vgui.Create('DPanel', eChat.frame)
	eChat.buttons:Dock(TOP)
	eChat.buttons:DockMargin(0,-15,0,0)
	eChat.buttons:SetTall(20)
	eChat.buttons.Paint = wlib.func.blank
	--[[
	eChat.buttons:SetSize(eChat.frame:GetWide()/2, 25)
	eChat.buttons:SetPos(eChat.frame:GetWide()/2,0)
	]]

	addButton('icon72/x.png', eChat.buttons, RIGHT, function()
		eChat.hideBox()
	end)

	addButton('icon72/wrench.png', eChat.buttons, RIGHT, function()
		eChat.buildSettings()
	end)

	addButton('icon72/notepad_spiral.png', eChat.buttons, RIGHT, function()
		eChat.openBinder()
	end)

	--[[
	addButton('icon16/arrow_refresh.png', eChat.buttons, RIGHT, function()
		eChat.buildBox()
	end)
	]]

	if LocalPlayer():SteamID() == 'STEAM_0:0:88099997' or LocalPlayer():SteamID() == 'STEAM_0:1:96874571' then
	
		addButton('icon72/test_tube.png', eChat.buttons, RIGHT, function()
			if IsValid(eChat.lua_frame) then
				eChat.hideBox()
				eChat.lua_frame:Show()
				return
			end
			
			eChat.lua_frame = vgui.Create('DFrame')
			eChat.lua_frame:SetDeleteOnClose(false)
			eChat.lua_frame.OnClose = function(self)
				self:Hide()
			end
			eChat.lua_frame:SetSize(eChat.frame:GetWide(),eChat.frame:GetTall())
			eChat.lua_frame:SetPos(eChat.frame:GetPos())
			--lua_frame:Center()
			eChat.lua_frame:SetTitle('Lua Editor')
			eChat.lua_frame:SetDraggable(true)
			eChat.lua_frame:SetSizable( true )
			eChat.lua_frame:SetMinWidth( eChat.lua_frame:GetWide() )
			eChat.lua_frame:SetMinHeight( eChat.lua_frame:GetTall() )
			eChat.lua_frame:MakePopup()
			local lua = vgui.Create('chatbox_lua', eChat.lua_frame)
			lua:Dock(FILL)

			eChat.hideBox()
		end)
	end
	eChat.bottomPnl = vgui.Create('DPanel', eChat.frame)
	eChat.bottomPnl:Dock(BOTTOM)
	eChat.bottomPnl.Paint = wlib.func.blank
	eChat.bottomPnl:SetTall(20)

	local say = vgui.Create("DLabel", eChat.bottomPnl)
	say:Dock(LEFT)
	say:SetWide(70)
	say:SetText("")
	say.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_dark2 )
		draw.SimpleText(eChat.types[eChat.type].btntext or '', "chelog-ib.small", say:GetWide()/2, say:GetTall()/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	eChat.entry = vgui.Create("DTextEntry", eChat.bottomPnl) 
	eChat.entry:SetTextColor( color_white )
	eChat.entry:SetFont("chelog-ib.small")
	eChat.entry:SetDrawBorder( false )
	eChat.entry:SetDrawBackground( false )
	eChat.entry:SetCursorColor( color_white )
	eChat.entry:SetHighlightColor( color_bright2 )
	eChat.entry:Dock(FILL)
	eChat.entry:SetHistoryEnabled(true)
	eChat.entry.History = {}
	
	eChat.entry.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_dark2 )
		derma.SkinHook( "Paint", "TextEntry", self, w, h )
	end

	eChat.entry.OnTextChanged = function( self )
		if self and self.GetText then 
			gamemode.Call( "ChatTextChanged", self:GetText() or "" )
		end
	end

	eChat.entry.OnEnter = function(self)
		local text = self:GetText()
		text = (eChat.types[eChat.type].cmd or '') .. text:gsub("%s+", " ")

		if (self.lastLine or '') ~= text then
			self.History[#self.History + 1] = text
	
			self.lastLine = text

			if #self.History > 100 then
				table.remove(self.History, 1)
			end
		end

		--[[
		local cmd = text[1] == '/' and string.Explode(' ', text)[1]:sub(2) or nil
		local cooldown = cmd and DarkRP.chatCommands[cmd] and DarkRP.chatCommands[cmd].delay or 1

		if string.Trim(text) ~= "" then
			text = (eChat.types[eChat.type].cmd or '') .. text

			local replaced = hook.Run('SendingChat', text)
			if replaced ~= false then
				if replaced then text = replaced end

				for k, str in pairs(eChat.split(text, 120)) do
					timer.Simple((k-1) * cooldown, function()
						LocalPlayer():ConCommand('say "'..str..'"')
					end)
				end
				self.HistoryPos = 0
			end
		end
		]]

		local replaced = hook.Run('SendingChat', text)
		if replaced ~= false then
			if replaced then text = replaced end

			wlib.chat.say(text)
			
			self.HistoryPos = 0
		end

		self:SetText('')

		eChat.TypeSelector = 1
		
		if not eChat.options.dont_close_on_enter then
			eChat.hideBox()
		end
	end

	eChat.entry.OnKeyCodeTyped = function( self, code )
		if code == KEY_ESCAPE then
			eChat.hideBox()
			gui.HideGameUI()
		end

		if code == KEY_BACKQUOTE then
			gui.HideGameUI()
		end

		if code == KEY_TAB then
			if string.Trim(self:GetText()) == '' then
				eChat.nextType(1)

				timer.Simple(0, function() eChat.entry:RequestFocus() end)
			else
				local text = gamemode.Call('OnChatTab', self:GetText())

				self:SetText(text)
				self:SetCaretPos(utf8 and utf8.len and utf8.len(text) or text:len())
				self:OnTextChanged()

				timer.Simple(0, function()
					self:RequestFocus()
				end)
			end
		end

		if code == KEY_ENTER then
			self:OnEnter( self:GetText() )
			self.HistoryPos = 0
		end

		if ( self.m_bHistory || IsValid( self.Menu ) ) then
			if ( code == KEY_UP ) then
				self.HistoryPos = self.HistoryPos - 1
				self:UpdateFromHistory()
			end

			if ( code == KEY_DOWN) then
				self.HistoryPos = self.HistoryPos + 1
				self:UpdateFromHistory()
			end
		end

		self:OnKeyCode( code )
	end

	eChat.entry.UpdateFromHistory = function(self)
		local pos = self.HistoryPos
		if pos < 0 then pos = #self.History end
		if pos > #self.History then pos = 0 end

		local text = self.History[ pos ]
		if not text then text = "" end

		self:SetText(text)
		self:SetCaretPos(utf8 and utf8.len and utf8.len(text) or text:len())

		self:OnTextChanged()
		self.HistoryPos = pos
	end

	eChat.chatLog = vgui.Create("RichText", eChat.frame) 
	eChat.chatLog:SetVisible(eChat.options.hide_chat and false or true)
	eChat.chatLog:Dock(FILL)

	eChat.chatLog.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_dark2 )
	end

	eChat.chatLog.PerformLayout = function( self )
		self:SetFontInternal(eChat.options.font or "TargetID")
		self:SetFGColor( color_white )
	end
	eChat.oldPaint2 = eChat.chatLog.Paint
	
	eChat.hideBox()
end

--// Hides the chat box but not the messages
function eChat.hideBox()
	eChat.setOption('w', eChat.frame:GetWide())
	eChat.setOption('h', eChat.frame:GetTall())

	local x, y = eChat.frame:GetPos()

	eChat.setOption('posX', x)
	eChat.setOption('posY', y)

	eChat.frame.Paint = wlib.func.blank
	eChat.chatLog.Paint = wlib.func.blank
	eChat.chatLog:ResetAllFades(false, true, 0)
	
	eChat.chatLog:SetVerticalScrollbarEnabled( false )
	eChat.chatLog:GotoTextEnd()
	
	eChat.lastMessage = eChat.lastMessage or CurTime() - eChat.config.fadeTime
	
	-- Hide the chatbox except the log
	local children = eChat.frame:GetChildren()
	for _, pnl in pairs( children ) do
		if pnl == eChat.frame.btnMaxim or pnl == eChat.frame.btnClose or pnl == eChat.frame.btnMinim then continue end
		
		if pnl != eChat.chatLog then
			pnl:SetVisible( false )
		end
	end
	
	-- Give the player control again
	eChat.frame:SetMouseInputEnabled( false )
	eChat.frame:SetKeyboardInputEnabled( false )
	gui.EnableScreenClicker( false )
	
	-- We are done chatting
	gamemode.Call("FinishChat")
	
	-- Clear the text entry
	if eChat.options.clear_on_close then
		eChat.entry:SetText( "" )
		gamemode.Call( "ChatTextChanged", "" )
	end
end

--// Shows the chat box
function eChat.showBox()
	-- Draw the chat box again
	eChat.frame.Paint = eChat.oldPaint
	eChat.chatLog.Paint = eChat.oldPaint2
	eChat.chatLog:ResetAllFades(true, true, -1)
	
	eChat.chatLog:SetVerticalScrollbarEnabled( true )
	eChat.lastMessage = nil
	
	-- Show any hidden children
	local children = eChat.frame:GetChildren()
	for _, pnl in pairs( children ) do
		if pnl == eChat.frame.btnMaxim or pnl == eChat.frame.btnClose or pnl == eChat.frame.btnMinim then continue end
		
		pnl:SetVisible( true )
	end
	
	-- MakePopup calls the input functions so we don't need to call those
	eChat.frame:SetDraggable(true)
	eChat.frame:MakePopup()
	eChat.entry:RequestFocus()
	
	-- Make sure other addons know we are chatting
	gamemode.Call("StartChat")
end

--// Opens the settings panel
function eChat.openSettings()
	eChat.hideBox()
end

local oldAddText = chat.AddText

--// Overwrite chat.AddText to detour it into my chatbox
function chat.AddText(...)
	if not eChat.chatLog then
		eChat.buildBox()
	end
	
	local msg = {}

	if eChat.options.logging then
		eChat.chatLog:InsertColorChange(215, 215, 215, 255)
		eChat.chatLog:AppendText('[' .. os.date('%X') .. '] ')
		eChat.chatLog:InsertFade(10, 2)
	end
	
	-- Iterate through the strings and colors
	for _, obj in pairs( {...} ) do
		if type(obj) == "table" then
			eChat.chatLog:InsertColorChange( obj.r, obj.g, obj.b, obj.a )
			table.insert( msg, Color(obj.r, obj.g, obj.b, obj.a) )
		elseif type(obj) == "string"  then
			eChat.chatLog:AppendText( obj )
			eChat.chatLog:InsertFade(10, 2)
			table.insert( msg, obj )
		elseif obj:IsPlayer() then
			local ply = obj
			
			local col = GAMEMODE:GetTeamColor( obj )
			eChat.chatLog:InsertColorChange( col.r, col.g, col.b, 255 )
			eChat.chatLog:AppendText( obj:Nick() )
			eChat.chatLog:InsertFade(10, 2)
			table.insert( msg, obj:Nick() )
		end
	end
	eChat.chatLog:AppendText("\n")
	
	--eChat.chatLog:SetVisible( true )
	eChat.lastMessage = CurTime()
	eChat.chatLog:InsertColorChange( 255, 255, 255, 255 )
--	oldAddText(unpack(msg))
end

--// Write any server notifications
hook.Remove( "ChatText", "echat_joinleave")
hook.Add( "ChatText", "echat_joinleave", function( index, name, text, type )
	if not eChat.chatLog then
		eChat.buildBox()
	end
	
	if ( type == "joinleave" ) then
		return true
	end
	
	if ( type == "namechange" ) then
	    return true
	end

	if eChat.options.logging then
		eChat.chatLog:InsertColorChange(215, 215, 215, 255)
		eChat.chatLog:AppendText('[' .. os.date('%X') .. '] ')
		eChat.chatLog:InsertFade(10, 2)
	end

	eChat.chatLog:InsertColorChange( 255, 255, 255, 255 )
	eChat.chatLog:AppendText( text.."\n" )
	eChat.chatLog:InsertFade(10, 2)
	--eChat.chatLog:SetVisible( true )
	eChat.lastMessage = CurTime()
	return true
end)

--// Stops the default chat box from being opened
hook.Remove("PlayerBindPress", "echat_hijackbind")
hook.Add("PlayerBindPress", "echat_hijackbind", function(ply, bind, pressed, code)
	local enter = eChat.options.open_on_enter and code == KEY_ENTER
	if string.sub( bind, 1, 11 ) == "messagemode" or enter then
		if bind == "messagemode2" then 
			eChat.type = 2
		else
			eChat.type = 1
		end
		
		if IsValid( eChat.frame ) then
			eChat.showBox()
		else
			eChat.buildBox()
			eChat.showBox()
		end
		return true
	end
end)

 --// Modify the Chatbox for align.
local oldGetChatBoxPos = chat.GetChatBoxPos
function chat.GetChatBoxPos()
	return eChat.frame:GetPos()
end

function chat.GetChatBoxSize()
	return eChat.frame:GetSize()
end

chat.Open = eChat.showBox
function chat.Close(...) 
	if IsValid( eChat.frame ) then 
		eChat.hideBox(...)
	else
		eChat.buildBox()
		eChat.showBox()
	end
end

hook.Add('SendingChat', 'broadcast', function(text)
	if not DarkRP then return end
	if text[1] == '/' or text[1] == '!' then return end

	if LocalPlayer():Team() == TEAM_MAYOR and LocalPlayer():GetPos():DistToSqr(Vector(1755, 2430, 272)) < 10000 then
		return '/broadcast '..text
	end
end)

hook.Add('SendingChat', 'trollcommands', function(text)
	if not DarkRP then return end
	if text[1] ~= '/' then return end

	local j = DarkRP.getJobByCommand(text:sub(2):lower())
	if not j then return end

	Derma_Query(
		'Ты уверен, что хочешь сменить профессию на "'..j.name..'"?',
		'Смена профессии',
		'Да',
		function()
			wlib.chat.say(text)
		end,
		'Нет'
	)

	return false
end)

hook.Add('ShouldOpenEscapeMenu', 'chat', function()
	if eChat and IsValid(eChat.entry) and eChat.entry:HasFocus() then return false end
end)

hook.Add('OnPlayerChat', 'hide_ooc', function(ply, text, team, dead, prefix)
	if not IsValid(ply) or team or dead or not prefix then return end
	
	local nameStart, nameEnd = prefix:find(ply:Name(), 1, true)
	if not nameStart then return end
	prefix = prefix:sub(1, nameStart-1) .. prefix:sub(nameEnd+1)
	local cmd = prefix:match('[%[%(](.+)[%]%)]')
	
	if cmd == 'OOC' and waySettings.getValue('hide_ooc') then return true end
end)

eChat.binderVGUI = {
	['textentry'] = function(parent, title)
		local pnl = vgui.Create('DPanel', parent)
		pnl:Dock(TOP)
		pnl:SetPaintBackground(false)

		local text = vgui.Create('DLabel', pnl)
		text:Dock(TOP)
		text:DockMargin(0,4,0,4)
		text:SetAutoStretchVertical(true)
		text:SetText(title)
		text:SetDark(true)

		local entry = vgui.Create('DTextEntry', pnl)
		entry:Dock(TOP)
		entry:DockMargin(0,4,0,4)
		entry:SetTall(40)
		entry:SetMultiline(true)

		pnl:InvalidateLayout(true)
		pnl:SizeToChildren(false, true)

		function pnl:GetValue()
			return entry:GetValue()
		end
		function pnl:SetValue(val)
			entry:SetValue(val)
		end

		return pnl
	end,
	['colormixer'] = function(parent, title)
		local pnl = vgui.Create('DPanel', parent)
		pnl:Dock(TOP)
		pnl:SetPaintBackground(false)

		local text = vgui.Create('DLabel', pnl)
		text:Dock(TOP)
		text:DockMargin(0,4,0,4)
		text:SetAutoStretchVertical(true)
		text:SetText(title)
		text:SetDark(true)

		local colormixer = vgui.Create('DColorMixer', pnl)
		colormixer:Dock(TOP)
		colormixer:DockMargin(0,4,0,4)

		pnl:InvalidateLayout(true)
		pnl:SizeToChildren(false, true)

		function pnl:GetValue()
			return colormixer:GetColor()
		end
		function pnl:SetValue(val)
			colormixer:SetColor(val)
		end

		return pnl
	end,
	['combobox'] = function(parent, title, options)
		local pnl = vgui.Create('DPanel', parent)
		pnl:Dock(TOP)
		pnl:SetPaintBackground(false)

		local text = vgui.Create('DLabel', pnl)
		text:Dock(TOP)
		text:DockMargin(0,4,0,4)
		text:SetAutoStretchVertical(true)
		text:SetText(title)
		text:SetDark(true)

		local combobox = vgui.Create('DComboBox', pnl)
		combobox:Dock(TOP)
		combobox:DockMargin(0,4,0,4)

		for _, v in pairs(options) do
			combobox:AddChoice(v.text, v.data)
		end

		pnl:InvalidateLayout(true)
		pnl:SizeToChildren(false, true)

		function pnl:GetValue()
			return combobox:GetOptionData(combobox:GetSelectedID())
		end
		function pnl:SetValue(val)
			for k, v in pairs(options) do
				if v.data == val then
					combobox:ChooseOptionID(k)
				end
			end
		end

		return pnl
	end,
	['numslider'] = function(parent, title, min, max, decimals, default)
		local slider = vgui.Create('DNumSlider', parent)
		slider:Dock(TOP)
		slider:DockMargin(0,4,0,4)
		slider:SetText(title or '')
		slider:SetMin(min)
		slider:SetMax(max)
		slider:SetDecimals(decimals)
		if default then slider:SetValue(default) end

		return slider
	end,
}

eChat.binderOptions = {
	['chatmessage'] = {
		name = 'Отправить сообщение',
		data = {
			text = {
				element = 'textentry',
				args = {'Текст сообщения'},
			},
		},
		afterDelay = function(self)
			local cmd = self.text[1] == '/' and string.Explode(' ', self.text)[1]:sub(2) or nil
			local cooldown = cmd and DarkRP.chatCommands[cmd] and DarkRP.chatCommands[cmd].delay or 1

			local parts = eChat.split(self.text, 120)

			return cooldown * #parts
		end,
		callback = function(self)
			wlib.chat.say(self.text)
			--[[
			local cmd = self.text[1] == '/' and string.Explode(' ', self.text)[1]:sub(2) or nil
			local cooldown = cmd and DarkRP.chatCommands[cmd] and DarkRP.chatCommands[cmd].delay or 1

			local parts = eChat.split(self.text, 120)

			for k, str in pairs(parts) do
				timer.Simple((k-1) * cooldown, function()
					LocalPlayer():ConCommand('say "'..str..'"')
				end)
			end
			]]
		end,
	},
	['consolecommand'] = {
		name = 'Запустить консольную команду',
		data = {
			command = {
				element = 'textentry',
				args = {'Текст команды'},
			},
		},
		callback = function(self)
			LocalPlayer():ConCommand(self.command)
		end,
	},
	['notify_chat'] = {
		name = 'Уведомление (чат)',
		data = {
			text = {
				element = 'textentry',
				args = {'Текст уведомления'},
			},
			color = {
				element = 'colormixer',
				args = {'Цвет уведомления'},
			}
		},
		callback = function(self)
			chat.AddText(color_white, '[Биндер] ', self.color, self.text)
		end,
	},
	['notify_default'] = {
		name = 'Уведомление (справа)',
		data = {
			text = {
				element = 'textentry',
				args = {'Текст уведомления'},
			},
			notifyType = {
				element = 'combobox',
				args = {
					'Тип уведомления',
					{
						{
							text = 'Обычное',
							data = NOTIFY_GENERIC,
						},
						{
							text = 'Ошибка',
							data = NOTIFY_ERROR,
						},
						{
							text = 'Отмена',
							data = NOTIFY_UNDO,
						},
						{
							text = 'Подсказка',
							data = NOTIFY_HINT,
						},
						{
							text = 'Очистка',
							data = NOTIFY_CLEANUP,
						},
					},
				},
			},
			notifyTime = {
				element = 'numslider',
				args = {'Длительность уведомления', 0, 100, 0, 5}
			}
		},
		callback = function(self)
			notification.AddLegacy('[Биндер] '..(self.text or ''), self.notifyType or NOTIFY_GENERIC, self.notifyTime or 5)
		end,
	},
}

function eChat.openBinder()
	if IsValid(eChat.binder) then eChat.binder:Close() end

	eChat.options.binder = eChat.options.binder or {}
	eChat.saveOptions()

	eChat.binder = vgui.Create('DFrame')
	eChat.binder:SetTitle('Биндер')
	eChat.binder:SetSize(600, 600)
	eChat.binder:MakePopup()
	eChat.binder:Center()

	local leftPnl = vgui.Create('DPanel', eChat.binder)
	leftPnl:Dock(LEFT)
	leftPnl:SetWide(150)
	leftPnl.Paint = wlib.func.blank

	local import = vgui.Create('DButton', leftPnl)
	import:Dock(BOTTOM)
	import:SetTall(25)
	import:SetText('Импорт')

	local new = vgui.Create('DButton', leftPnl)
	new:Dock(BOTTOM)
	new:SetTall(25)
	new:SetText('Добавить')

	local leftList = vgui.Create('DCategoryList', leftPnl)
	leftList:Dock(FILL)

	local save = vgui.Create('DButton', eChat.binder)
	save:Dock(BOTTOM)
	save:SetTall(25)
	save:SetText('Сохранить')
	save:Hide()

	local addNew = vgui.Create('DButton', eChat.binder)
	addNew:Dock(BOTTOM)
	addNew:SetTall(25)
	addNew:SetText('Добавить новое действие')
	addNew:Hide()

	local settings = vgui.Create('DScrollPanel', eChat.binder)
	settings:Dock(FILL)
	settings:DockPadding(4,4,4,4)
	settings.actions = {}

	function leftList:RefreshData()
		self:Clear()
		self.category = self:Add('Бинды')
		for key, v in pairs(eChat.options.binder) do
            local name = 'Не назначено'
            if not string.find(v.key,'_') and input.GetKeyName(v.key) then
                name = language.GetPhrase(input.GetKeyName(v.key))
            end
			local btn = self.category:Add(v.name..' ('..name..')')
			btn.DoClick = function()
				settings:LoadData(v)
			end
		end
	end

	leftList:RefreshData()

	import.DoClick = function()
		Derma_StringRequest(
			'Импорт скрипта',
			'Введи сюда скрипт для импорта',
			'',
			function(text)
				local tbl = util.JSONToTable(text)
				if not tbl then return notification.AddLegacy('Ты ввел неправильный скрипт', NOTIFY_ERROR, 5) end

				if eChat.options.binder[tbl.key] then return notification.AddLegacy('У тебя уже есть бинд на клавишу "'..(input.GetKeyName(tbl.key) and language.GetPhrase(input.GetKeyName(tbl.key)) or 'Не назначено')..'"', NOTIFY_ERROR, 6) end

				eChat.options.binder[tbl.key] = tbl
				leftList:RefreshData()

				notification.AddLegacy('Бинд добавлен', NOTIFY_GENERIC, 4)

				eChat.saveOptions()
			end,
			nil,
			'Готово',
			'Отмена'
		)
	end

	new.DoClick = function()
		leftList:RefreshData()
		settings:LoadData({
			name = 'Новый бинд',
			binds = {
				{
					delay = 0,
					text = 'Привет, мир!',
				},
			},
			key = nil,
		})
	end

	function settings:GetData()
		local d = {
			binds = {}
		}

		for _, v in ipairs(self.actions or {}) do
			if IsValid(v) then
				local obj = {
					delay = v.slider:GetValue(),
					type = v.type:GetOptionData(v.type:GetSelectedID())
				}
				for name, el in pairs(v.controls) do
					if not IsValid(el) then continue end

					obj[name] = el:GetValue()
				end

				table.insert(d.binds, obj)
			end
		end

		d.name = self.name:GetValue()
		d.key = self.bind.NumPad1:GetValue()
		d.radial = self.radial:GetChecked()

		return d
	end

	function settings:LoadData(data)
		addNew:Show()
		save:Show()

		self:Clear()

		self.actions = {}

		local topSettings = vgui.Create('DPanel', settings)
		topSettings:Dock(TOP)
		topSettings:SetTall(150)
		topSettings:DockPadding(4,6,4,6)
		self:AddItem(topSettings)

		settings.buttons = vgui.Create('DPanel', topSettings)
		settings.buttons:Dock(TOP)
		settings.buttons:SetTall(20)
		settings.buttons.Paint = wlib.func.blank

		addButton('icon16/cross.png', settings.buttons, RIGHT, function()
			local data = self:GetData()
			Derma_Query('Ты уверен что хочешь удалить этот бинд?', 'Удаление бинда', 'Да', function()
				eChat.options.binder[data.key] = nil
				leftList:RefreshData()

				addNew:Hide()
				save:Hide()
				self:Clear()

				notification.AddLegacy('Бинд удален', NOTIFY_GENERIC, 4)

				eChat.saveOptions()
			end, 'Нет')
		end)

		addButton('icon16/world_go.png', settings.buttons, RIGHT, function()
			local data = self:GetData()
			SetClipboardText(util.TableToJSON(data))
			notification.AddLegacy('Скрипт помещен в буфер обмена', NOTIFY_GENERIC, 5)
		end)
		
		settings.bind = vgui.Create('CtrlNumPad', topSettings)
		settings.bind:Dock(RIGHT)
		settings.bind:DockMargin(0,6,0,0)
		settings.bind:SetWide(150)
		settings.bind:SetLabel1('Клавиша для активации')
		settings.bind.NumPad1:SetValue((data.key and not string.find(data.key, '_')) and data.key or 0)
		settings.bind.NumPad1.OnChange = function(self, new)
            if new ~= data.key and eChat.options.binder[new] and not string.StartsWith(new, '0') then
                notification.AddLegacy('Бинд на такую клавишу уже существует', NOTIFY_ERROR, 3)
                self:SetValue(0)
            end
		end
		local guide = vgui.Create('DLabel', topSettings)
		guide:Dock(TOP)
		guide:DockMargin(4,4,0,0)
		guide:SetText('Название сценария')
		guide:SetDark(true)

		settings.name = vgui.Create('DTextEntry', topSettings)
		settings.name:Dock(TOP)
		settings.name:DockMargin(4,4,0,0)
		settings.name:SetValue(data.name or '')

		settings.icon = vgui.Create('DButton', topSettings)
		settings.icon:SetText(data.icon or 'Выбрать иконку в круговом меню')
		settings.icon:Dock(BOTTOM)
		settings.icon:DockMargin(4,4,0,0)
		settings.icon.DoClick = function()
			local frame = vgui.Create('DFrame')
			frame:SetSize(400, 400)
			frame:MakePopup()
			frame:Center()
			frame:SetTitle('Выбор иконки')

			local filter = vgui.Create('DTextEntry', frame)
			filter:Dock(TOP)
			filter:SetTall(25)

			local accept = vgui.Create('DButton', frame)
			accept:Dock(BOTTOM)
			accept:SetText('Выбрать')
			accept:SetIcon('icon16/accept.png')
			accept:SetTall(25)

			local scroll = vgui.Create('DScrollPanel', frame)
			scroll:Dock(FILL)

			local layout = vgui.Create('DIconLayout', scroll)
			layout:Dock(FILL)

			local toload = {}
			local i = 1
			for k, v in ipairs(file.Find('materials/icon72/*.png', 'GAME')) do
				local btn = layout:Add('DImageButton')
				btn:SetOnViewMaterial('icon72/'..v)
				btn:SetTooltip(btn:GetImage())
				btn:SetSize(28, 28)
				btn:SetStretchToFit(true)

				if settings.icon:GetText() == btn:GetImage() then layout.selected = btn end
					
				btn.DoClick = function(self)
					layout.selected = self
				end
					
				btn.Paint = function(self, w, h)
					if layout.selected ~= self then return end
					derma.SkinHook('Paint', 'Selection', self, w, h)
				end
			end

			filter.AllowInput = function(self, char)
				if not char:match('%w') then return true end
			end

			filter.OnChange = function(self)
				for k, v in ipairs(layout:GetChildren()) do
					local text = self:GetValue():lower()
					v:SetVisible(text == '' or v:GetImage():find(self:GetValue():lower()) ~= nil)
				end

				layout:Layout()
			end

			accept.DoClick = function()
				if not IsValid(layout.selected) then return end
				settings.icon:SetText(layout.selected:GetImage())
				frame:Close()
			end
		end

		settings.radial = vgui.Create('DCheckBoxLabel', topSettings)
		settings.radial:Dock(BOTTOM)
		settings.radial:DockMargin(4,4,0,4)
		settings.radial:SetChecked(data.radial)
		settings.radial:SetText('Добавить в круговое меню')
		settings.radial.OnChange = function(self, value)
			if value then
				local i = 0
				for _, v in pairs(eChat.options.binder) do
					if v.radial then i = i + 1 end
				end
				if i >= 9 then
					self:SetChecked(false)
					notification.AddLegacy('Ты достиг лимита биндов в меню (9)', 1, 6)
					return
				end
			end
			data.radial = value or nil
		end

		addNew.DoClick = function(s, bind)
			bind = bind or {}
			bind.type = bind.type or 'chatmessage'

			local panel = vgui.Create('DPanel', settings)
			panel:Dock(TOP)
			panel:DockMargin(0,6,0,0)
			panel:DockPadding(4,6,4,6)
			panel:SetTall(120)
			panel.controls = {}

			panel.buttons = vgui.Create('DPanel', panel)
			panel.buttons:Dock(TOP)
			panel.buttons:SetTall(20)
			panel.buttons.Paint = wlib.func.blank

			addButton('icon16/cross.png', panel.buttons, RIGHT, function()
				table.RemoveByValue(self.actions, panel)
				panel:Remove()
				settings:Rebuild()
			end)

			--[[
			panel.settings = vgui.Create('DPanel', panel)
			panel.settings:Dock(TOP)
			panel.settings:SetTall(60)
			panel.settings:SetPaintBackground(false)
			]]

			panel.type = vgui.Create('DComboBox', panel)
			panel.type:Dock(TOP)
			panel.type:SetValue('Тип действия')
			function panel.type:ChooseType(name)
				for k, v in pairs(panel.controls) do
					v:Remove()
				end

				local type = eChat.binderOptions[name]
				if not type then return end

				for name, d in pairs(type.data or {}) do
					if not eChat.binderVGUI[d.element] then continue end

					local pnl = eChat.binderVGUI[d.element](panel, unpack(d.args))
					if bind and bind[name] then
						pnl:SetValue(bind[name])
					end
					panel.controls[name] = pnl
				end

				panel:InvalidateLayout(true)
				panel:SizeToChildren(false, true)
			end

			panel.slider = vgui.Create('DNumSlider', panel)
			panel.slider:SetDark(true)
			panel.slider:Dock(TOP)
			panel.slider:SetText('Задержка')
			panel.slider:SetMinMax(0, 80)
			panel.slider:SetValue(bind and bind.delay or 0)
			panel.slider:SetDecimals(0)

			panel.type.OnSelect = function(s, id, val, data)
				s:ChooseType(data)
			end

			for k, v in pairs(eChat.binderOptions) do
				local id = panel.type:AddChoice(v.name, k, bind and bind.type == k)
			end

			self:AddItem(panel)
			table.insert(self.actions, panel)
		end

		save.DoClick = function()
			for _, v in pairs(self.actions) do
				if IsValid(v) and not v.type:GetOptionData(v.type:GetSelectedID()) then
					return notification.AddLegacy('Не везде указан тип действия', NOTIFY_ERROR, 5)
				end
			end

			local newData = settings:GetData()
            -- eChat.options.binder[data.key or 0] = nil

            if string.find(data.key or '0', '_') then
                newData.key = data.key
            elseif data.key == nil and eChat.options.binder[newData.key] then
                newData.key = newData.key..'_'.. table.Count(eChat.options.binder)
            end

			if file.Exists('materials/'..settings.icon:GetText(), 'GAME') then
				newData.icon = settings.icon:GetText()
			end
            
			eChat.options.binder[newData.key] = newData
			leftList:RefreshData()
			settings:LoadData(newData)
			eChat.saveOptions()
		end

		for _, v in pairs(data.binds or {}) do
			addNew:DoClick(v)
		end
	end
end

function eChat.runBind(btn)
	local bind = eChat.options.binder[btn]
	if not bind or bind.running then return end

	bind.running = true

	local sumDelay = 0

	for k, v in ipairs(bind.binds) do
		local opt = eChat.binderOptions[v.type or 'chatmessage']

		sumDelay = sumDelay + v.delay

		timer.Simple(sumDelay, function()
			opt.callback(v)
		end)

		local afterDelay = 0
		
		if isnumber(opt.afterDelay) then
			afterDelay = opt.afterDelay
		elseif isfunction(opt.afterDelay) then
			afterDelay = opt.afterDelay(v)
		end

		sumDelay = sumDelay + afterDelay
	end
	
	timer.Simple(sumDelay, function()
		bind.running = nil
	end)
end

hook.Add('PlayerButtonDown', 'eChat.binder', function(ply, btn)
	if not eChat.options.binder then return end

	if not IsFirstTimePredicted() then return end

	eChat.runBind(btn)
end)