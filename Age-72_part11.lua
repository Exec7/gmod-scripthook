--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 11/12 - 06/04/2025


--PATH addons/arccw_base_modified/lua/arccw/shared/sh_loadatts.lua:
ArcCW = ArcCW or {}
ArcCW.AttachmentTable = {}
ArcCW.AttachmentIDTable = {}
ArcCW.AttachmentSlotTable = {}
ArcCW.AttachmentBlacklistTable = {}
ArcCW.NumAttachments = 1
ArcCW.GenerateAttEntities = true

ArcCW.AttachmentCachedLists = {}

local shortname = ""
local genAttCvar = ArcCW.ConVars["reloadatts_registerentities"]

function ArcCW.LoadAttachmentType(att, name)
    if name == "" then return end
    name = name or shortname

    if !att.Ignore or ArcCW.ConVars["reloadatts_showignored"]:GetBool() then
        ArcCW.AttachmentTable[name] = att
        ArcCW.AttachmentIDTable[ArcCW.NumAttachments] = name

        att.Blacklisted = false
        att.ShortName = name

        if !ArcCW.AttachmentSlotTable[att.Slot] then
            ArcCW.AttachmentSlotTable[att.Slot] = {}
        end
        table.insert(ArcCW.AttachmentSlotTable[att.Slot], ArcCW.NumAttachments)

        att.ID = ArcCW.NumAttachments

        if genAttCvar:GetBool() and !att.DoNotRegister and !att.InvAtt and !att.Free then
            local attent = {}
            attent.Base = "arccw_att_base"
            if CLIENT and att.Icon then
                attent.IconOverride = string.Replace( att.Icon:GetTexture( "$basetexture" ):GetName() .. ".png", "0001010", "" )
            end
            attent.PrintName = att.PrintName or name
            attent.Spawnable = att.Spawnable or true
            attent.AdminOnly = att.AdminOnly or false
            attent.Category = att.EntityCategory or "ArcCW - Attachments"
            attent.Model = att.DroppedModel or att.Model or "models/Items/BoxSRounds.mdl"
            attent.GiveAttachments = {
                [att.ShortName] = 1
            }

            if att.EntityCategory and !list.HasEntry("ContentCategoryIcons", att.EntityCategory) then
                list.Set("ContentCategoryIcons", att.EntityCategory, "arccw/icon_16.png")
            end

            scripted_ents.Register( attent, "acwatt_" .. name )
        end

        ArcCW.NumAttachments = ArcCW.NumAttachments + 1

        hook.Run("ArcCW_OnAttLoad", att)
    end
end

local function VerifyBlacklist()
    for attName, v in pairs(ArcCW.AttachmentBlacklistTable) do
        if !ArcCW.AttachmentTable[attName] then
            ArcCW.AttachmentBlacklistTable[attName] = nil
        end
    end
end

local function ArcCW_SendBlacklist(ply)
    if SERVER then
        -- Only load if table is empty, bruh
        if table.IsEmpty(ArcCW.AttachmentBlacklistTable) then
            ArcCW.AttachmentBlacklistTable = util.JSONToTable(file.Read("arccw_blacklist.txt") or "") or {}
            local curcount = table.Count(ArcCW.AttachmentBlacklistTable)
            VerifyBlacklist()
            print("Loaded " .. curcount .. " active (" .. curcount .. " total) blacklisted ArcCW attachments.")
        end
        if ArcCW.AttachmentBlacklistTable and player.GetCount() > 0 then
            timer.Simple(0, function()
                net.Start("arccw_blacklist")
                    net.WriteUInt(table.Count(ArcCW.AttachmentBlacklistTable), ArcCW.GetBitNecessity())
                    for attName, bStatus in pairs(ArcCW.AttachmentBlacklistTable) do
                        net.WriteUInt(ArcCW.AttachmentTable[attName].ID, ArcCW.GetBitNecessity())
                    end
                if ply then net.Send(ply) else net.Broadcast() end
            end)
        end
    elseif CLIENT and ArcCW.AttachmentBlacklistTable == nil then
        -- Actively request the table, this happens on player load into server once
        net.Start("arccw_blacklist")
            net.WriteBool(true)
        net.SendToServer()
    end
end


local attachments_path = "arccw/shared/attachments/"
local bulk_path = "arccw/shared/attachments_bulk/"

local function ArcCW_LoadAtt(att_file)
    att = {} -- Do not bleed over attributes from previous attachments
    --shortname = string.sub(att_file, 1, -5)
    local s = string.Explode("/", att_file)
    shortname = string.sub(s[#s], 1, -5)

    include(att_file)
    AddCSLuaFile(att_file)

    ArcCW.LoadAttachmentType(att)

end

local function ArcCW_LoadFolder(folder)
    folder = folder and (attachments_path .. folder .. "/") or attachments_path
    for k, v in pairs(file.Find(folder .. "*", "LUA")) do
        local yaya, yoyo = pcall(function() ArcCW_LoadAtt(folder .. v) end)
        if !yaya then
            print( "!!!! Attachment " .. v .. " has errors!", yoyo )
            -- Create a stub attachment to prevent customization UI freaking out
            ArcCW.AttachmentTable[shortname] = {
                PrintName = shortname or "ERROR",
                Description = "This attachment failed to load!\nIts file path is: " .. v
            }
        end
    end
end

local function ArcCW_LoadAtts()
    ArcCW.AttachmentTable = {}
    ArcCW.AttachmentIDTable = {}
    ArcCW.AttachmentSlotTable = {}
    ArcCW.NumAttachments = 1
    ArcCW.AttachmentBits = nil
    ArcCW.AttachmentCachedLists = {}

    ArcCW_LoadFolder()
    local _, folders = file.Find(attachments_path .. "/*", "LUA")
    if folders then
        for _, folder in pairs(folders) do
            ArcCW_LoadFolder(folder)
        end
    end

    local bulkfiles = file.Find(bulk_path .. "/*.lua", "LUA")
    for _, filename in pairs(bulkfiles) do
        if filename == "default.lua" then continue end
        local try = pcall(function()
            include(bulk_path .. filename)
            AddCSLuaFile(bulk_path .. filename)
        end)
        if !try then
            print("!!!! Bulk attachment file " .. filename .. " has errors!")
        end
    end

    print("Loaded " .. tostring(ArcCW.NumAttachments) .. " ArcCW attachments.")

    if !game.SinglePlayer() then
        ArcCW_SendBlacklist()
    else
        -- Simply read the file and do no networking, since both client/server has access to it
        ArcCW.AttachmentBlacklistTable = util.JSONToTable(file.Read("arccw_blacklist.txt") or "") or {}
        for i, v in pairs(ArcCW.AttachmentTable) do
            v.Blacklisted = ArcCW.AttachmentBlacklistTable[i]
        end
        print("Loaded blacklist with " .. table.Count(ArcCW.AttachmentBlacklistTable) .. " attachments.")
    end

    hook.Run("ArcCW_PostLoadAtts")
end

function ArcCW.GetBitNecessity()
    if !ArcCW.AttachmentBits then
        ArcCW.AttachmentBits = math.min(math.ceil(math.log(ArcCW.NumAttachments + 1, 2)), 32)
    end
    return ArcCW.AttachmentBits
end

if CLIENT then
    concommand.Add("arccw_reloadatts", function()
        if !LocalPlayer():IsSuperAdmin() then return end

        net.Start("arccw_reloadatts")
        net.SendToServer()
    end)

    net.Receive("arccw_reloadatts", function(len, ply)
        ArcCW_LoadAtts()
    end)

    spawnmenu.AddCreationTab( "#spawnmenu.category.entities", function()

        local ctrl = vgui.Create( "SpawnmenuContentPanel" )
        ctrl:EnableSearch( "entities", "PopulateEntities" )
        ctrl:CallPopulateHook( "PopulateEntities" )

        return ctrl

    end, "icon16/bricks.png", 20 )

    -- Client receives blacklist table from server and updates itself
    net.Receive("arccw_blacklist", function()
        ArcCW.AttachmentBlacklistTable = {}
        local amt = net.ReadUInt(ArcCW.GetBitNecessity())
        for i = 1, amt do
            local id = net.ReadUInt(ArcCW.GetBitNecessity())
            ArcCW.AttachmentBlacklistTable[ArcCW.AttachmentIDTable[id]] = true
        end
        for i, v in pairs(ArcCW.AttachmentTable) do
            v.Blacklisted = ArcCW.AttachmentBlacklistTable[i]
        end
        print("Received blacklist with " .. table.Count(ArcCW.AttachmentBlacklistTable) .. " attachments.")
    end)

    -- Gets around Listen server spawn issues
    hook.Add( "InitPostEntity", "Ready", function()
        if !game.SinglePlayer() then
            net.Start("arccw_blacklist")
                net.WriteBool(true)
            net.SendToServer()
        end
    end )
elseif SERVER then
    net.Receive("arccw_reloadatts", function(len, ply)
        if !ply:IsSuperAdmin() then return end

        ArcCW_LoadAtts()

        net.Start("arccw_reloadatts")
        net.Broadcast()
    end)

    local antiSpam = {}
    net.Receive("arccw_blacklist", function(len, ply)

        -- If this message is a request to get blacklist, send it and return
        local isRequest = net.ReadBool()
        if isRequest then
            if antiSpam[ply] and antiSpam[ply] > CurTime() then return end
            -- Debounce client request so they can't attempt to spam netmessages
            antiSpam[ply] = CurTime() + 10

            ArcCW_SendBlacklist(ply)
            return
        elseif !isRequest and !ply:IsAdmin() then
            return
        end

        -- Server receives admin's changes to blacklist table
        local amt = net.ReadUInt(ArcCW.GetBitNecessity())
        ArcCW.AttachmentBlacklistTable = {}
        for i = 1, amt do
            local id = net.ReadUInt(ArcCW.GetBitNecessity())
            local attName = ArcCW.AttachmentIDTable[id]
            if attName and ArcCW.AttachmentTable[attName] then
                ArcCW.AttachmentBlacklistTable[attName] = true
            end
        end
        for i, k in pairs(ArcCW.AttachmentTable) do
            k.Blacklisted = ArcCW.AttachmentBlacklistTable[i] or false
        end
        print("Received blacklist with " .. table.Count(ArcCW.AttachmentBlacklistTable) .. " attachments.")
        file.Write("arccw_blacklist.txt", util.TableToJSON(ArcCW.AttachmentBlacklistTable))
        ArcCW_SendBlacklist()
    end)
end

hook.Add("PostCleanupMap", "ArcCW_ReloadAttsDebug", function()
    if ArcCW.ConVars["reloadatts_mapcleanup"]:GetBool() then ArcCW_LoadAtts() end
end)

ArcCW_LoadAtts()

--addons/arccw_weapons/lua/arccw/shared/attachments/15a_foregrip.lua:
att.PrintName = "15a Foregrip"
att.Description = "Rubberized grip for the DC-15a. Improves recoil at the cost of aim time."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_e11_grip2.png")

att.AutoStats = true

att.Slot = "15a_foregrip"
att.ActivateElements = {"15a_foregrip"}

att.Mult_Recoil = 0.9
att.Mult_SightTime = 1.1
att.Mult_MoveSpeed = 0.95
--addons/arccw_weapons/lua/arccw/shared/attachments/a280cfe_stock_heavy.lua:
att.PrintName = "Heavy Stock"
att.Description = "Heavy stocK. Improves recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_stock"
att.ActivateElements = {"a280cfe_stock_heavy"}

att.Mult_SightTime = 1.25
att.Mult_Recoil = 0.7
att.Mult_MoveDispersion = 1.15
att.Free = true
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_gravity.lua:
att.PrintName = "Gravity Rocket"
att.Description = ""
att.Icon = Material("interfaz/iconos/jedi/2908166817_3227357796.png")

att.Desc_Pros = {
    "duds behave normally, falling to the ground",
}
att.Desc_Cons = {
    "missiles have a slight arc",
}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.Override_ShootEntity = "arccw_rocket_gravity"
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_slug.lua:
att.PrintName = "Slug-Blaster"
att.Icon = Material("interfaz/iconos/kraken/jedi comm assault specialist/2759850485_469778067.png")
att.Description = "Your shotgun now shoots a slug."
att.Override_MuzzleEffect = nil
att.Override_Tracer = nil
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.NotForNPCs = true
att.AutoStats = true
att.Slot = "shotgun_ammo"

att.Override_Num = 1

att.Mult_AccuracyMOA = 0.4
att.Mult_HipDispersion = 0.2
att.Mult_SightsDispersion = 0.1

att.Mult_Range = 2.3
att.Mult_Penetration = 1.4
att.Mult_ShootPitch = 0.6
att.Reload = 0.9
att.Mult_DamageMin = 0.74
att.Mult_Recoil = 2
att.Mult_SightTime = 1
att.Mult_RPM = 0.9
att.Mult_Damage = 1.7
att.Mult_MuzzleVelocity = 1.4
--addons/arccw_weapons/lua/arccw/shared/attachments/aocrp_training.lua:
att.PrintName = "Trainingsmunition"
att.AbbrevName = "Trainingsmunition"
att.Icon = Material("interfaz/iconos/dpsicon2.png")
att.Description = "Bei Trainings nutzen um dein Gegeünber nicht zu verletzen."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"aocrp_ammo"}

att.AutoStats = true
att.Override_Tracer = "tfa_tracer_orange"
att.Override_TracerCol = Color(255, 140, 0)
att.Override_MuzzleFlashColor = Color(255, 140, 0)
att.Free = true


--lua/arccw/shared/attachments/arccw_fullholo.lua:
att.PrintName = "Full Holographic (RDS)"
att.Icon = Material("entities/arccw_fullholo.png", "mips smooth")
att.Description = "For when you just need more sight picture and less sight."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/optic_fullholo.mdl"

att.AdditionalSights = {
    {
        Pos = Vector(0, 10, -1.28),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE,
        IgnoreExtra = false
    }
}

att.ModelScale = Vector(1.2, 1.2, 1.2)
att.ModelOffset = Vector(-1.8, 0, 0.1)

att.Holosight = true
att.HolosightReticle = Material("hud/holosight/go_aimpoint.png", "mips smooth")
att.HolosightSize = 0.25
att.HolosightBone = "holosight"

att.Mult_SightTime = 1.01

att.Colorable = true
--addons/arccw_weapons/lua/arccw/shared/attachments/arccw_heartsensor.lua:
att.PrintName = "Heartbeat Sensor"
att.Icon = Material("entities/arccw_heartsensor.png")
att.Description = "Sensor that is able to track targets through walls. It's somewhat bulky, but makes for a good scouting tool."
att.Desc_Pros = {
    "Displays people close to you"
}
att.Desc_Cons = {
    "Slow refresh rate"
}
att.Slot = "charm"

att.Model = "models/weapons/arccw/atts/heartsensor.mdl"
att.ModelScale = Vector(1, 1, 1)
att.ModelOffset = Vector(0, -2.25, 0)

att.Mult_SightTime = 1.2
att.Mult_ReloadTime = 1.1
att.Mult_ReloadTime = 1.1
att.Mult_SpeedMult = 0.9
att.IgnorePickX = false
att.AutoStats = true
att.Free = false


local sensorFade = 0

hook.Add("OnEntityCreated", "ArcCW_HeartbeatNPCs", function(ent)
	if !ArcCW.sensorNPCs then return end
    if !ent:IsValid() then return end

    if ent:IsNPC() or ent:IsNextBot() then
        ArcCW.sensorNPCs[#ArcCW.sensorNPCs + 1] = ent
	end

end)

hook.Add("EntityRemoved", "ArcCW_HeartbeatNPCs", function(ent)
	if !ArcCW.sensorNPCs then return end

    if ent:IsNPC() or ent:IsNextBot() then
        table.RemoveByValue(ArcCW.sensorNPCs, ent)
    end
end)


if CLIENT then
	ArcCW.sensorNPCs = ArcCW.sensorNPCs or {}
	local mainScreen = Material("models/arccw/mw2/mw2_sensor_screen_2")
	local sensorScreen = Material("models/arccw/mw2/mw2_sensor_screen_1")
	local sensorDot = Material("models/arccw/mw2/sensordot.png", "ignorez")
	local RTTexture = GetRenderTarget("ArcCWHeartSensor", 512, 512)
	local spotsound = false
	local sx, sy = 250, 326
	local colorNPC = Color(255, 0, 50, 255)
	local colorFriendly = Color(50, 175, 50, 255)
	local colorNeutral = Color(200, 175, 50, 255)
	local colorHostile = Color(200, 50, 50, 255)
	
	local function DrawSensor(v, plypos, updatepos)
		if IsValid(v) then
			if !v.ArcCW_SensorPos or updatepos then
				local pos = v:GetPos()
				local dist = pos:DistToSqr(plypos)
				if dist < 320000 then
					v.ArcCW_SensorPos = pos
				else
					v.ArcCW_SensorPos = vector_origin
				end
			end
			local pos = v.ArcCW_SensorPos
			if pos != vector_origin then
				pos.z = plypos.z
				
				pos = ( pos - plypos )*0.33
				pos:Rotate( Angle( 0, -LocalPlayer():EyeAngles().y+90, 0 ) )
				pos.y = -pos.y * 2 + ( (sy+25) * 0.78 )
				pos.x = pos.x + ( sx * 0.5 )
				
				if pos.x > 5 and pos.x < sx+25 and pos.y < sy and pos.y > -100 then
					local class = v:GetClass()
					colorNPC = (IsFriendEntityName(class) and colorFriendly) or (IsEnemyEntityName(class) and colorHostile) or colorNeutral
					colorNPC.a = sensorFade
					surface.SetDrawColor( colorNPC )
					surface.DrawTexturedRect( pos.x - 16, math.max(-32, pos.y - 16), 64, 128 )
					if !spotsound and updatepos and colorNPC != colorFriendly then
						LocalPlayer():EmitSound("arccw/heartsensor_spot.wav", 40, 100 + math.random(-2, 2))
						spotsound = true
					end
				end
			end
		end
	end
	
	att.DrawFunc = function(wep, element, wm)
		if wm then return end
		local sframe = mainScreen:GetInt("$frame")
		sensorScreen:SetTexture("$basetexture", RTTexture)
		render.PushRenderTarget( RTTexture, 0, 0, RTTexture:Width(), RTTexture:Height() )
		cam.Start2D()
		local ply = LocalPlayer()
		local plypos = ply:GetPos()
		local updatepos = sframe < 12 and sframe > 4
		
		local sensorNPCs = ArcCW.sensorNPCs

		if updatepos then
			sensorFade = 255
		else
			sensorFade = sensorFade-(50*FrameTime())
			spotsound = false
		end
		
		render.Clear(0,0,0,0)
		surface.SetMaterial(sensorDot)
		
		for k,v in ipairs(sensorNPCs) do
			DrawSensor(v, plypos, updatepos)
		end
		
		if !game.SinglePlayer() then
			surface.SetDrawColor( 200, 175, 50, sensorFade )
			
			for k,v in ipairs(player.GetAll()) do --not efficient, im lazy :[
				if v != ply and v:Alive() then
					if !v.ArcticMedShots_ActiveEffects or !v.ArcticMedShots_ActiveEffects["coldblooded"] then
						DrawSensor(v, plypos, updatepos)
					end
				end
			end
		end
		
		cam.End2D()
		render.PopRenderTarget()
	end

end
--addons/arccw_weapons/lua/arccw/shared/attachments/arccw_stattrak.lua:
att.PrintName = "StatTrak™ Kill Counter"
att.AbbrevName = "StatTrak™ Kill Counter"
-- att.Icon = Material("entities/stattrak_advert.png", "mips smooth")
att.Icon = Material("entities/arccw_stattrak.png", "mips smooth")
att.Description = "The StatTrak™ Kill Counter is a piece of technology that tracks the number of kills you've made with the weapon attached to it. There are two selectable modes, Global and Local. The former will track kills between sessions while the latter will only track kills for the current session."
att.SortOrder = 1


att.Model = "models/weapons/arccw/stattrack.mdl"
att.ModelScale = Vector(1, 1, 1)
-- att.OffsetAng  = Angle(-5, 0, 0)
att.ModelOffset  = Vector(0, -0.1, 0)
att.Slot = {"charm", "killcounter"}

att.ToggleLockDefault = true 
att.ToggleStats = {
    {
        PrintName = "Global weapon",
        AutoStatName = "Global weapon",
        GivesFlags = {"st_global"}
    },
    {
        PrintName = "Local weapon",
        AutoStatName = "Local",
        GivesFlags = {"st_local"}
    },
}


-- att.Ignore = true -- WIP

att.Hook_Think = function(wep) 
    -- why there s no hook for att equip?? if it ever going to happen copy function to it from deploy
    if SERVER or !wep:GetOwner():IsPlayer() then return end

    if !wep.FileKillsTable then -- same as below but here 
        wep.FileKillsTable = util.JSONToTable(file.Read("arccw_stattrack.json", "DATA") or "") or {}
        wep.FileKills = wep.FileKillsTable[wep:GetClass()] or 0

        wep:SetNWInt("STFileKills", wep.FileKills)

        net.Start("arrcwstattracksend")
        net.WriteUInt(wep.FileKills, 20)
        net.SendToServer()
    end
end

att.Hook_OnDeploy = function(wep) 
    if SERVER or !wep:GetOwner():IsPlayer() then return end
    -- load from file
    wep.FileKillsTable = util.JSONToTable(file.Read("arccw_stattrack.json", "DATA") or "") or {}
    wep.FileKills = wep.FileKillsTable[wep:GetClass()] or 0

    wep:SetNWInt("STFileKills", wep.FileKills)

    net.Start("arrcwstattracksend")
    net.WriteUInt(wep.FileKills, 20)
    net.SendToServer()

    -- wep:SetNWInt("STFileKills", wep.FileKills)
end

att.Hook_OnHolster = function(wep) 
    if CLIENT or !wep:GetOwner():IsPlayer() then return end
    -- save in file
    net.Start("arrcwstattracksave")
    net.WriteEntity(wep)
    net.Send(wep:GetOwner())
    

    -- local curtable = {[wep:GetClass()] = wep:GetNWInt("STFileKills") or 777}

    -- local content = util.TableToJSON(table.Merge(wep.FileKillsTable or {}, curtable))

    -- file.Write("arccw_stattrack.json", content)
    -- print("hi!!")
end

--addons/arccw_weapons/lua/arccw/shared/attachments/dc15a_range_finder.lua:
att.PrintName = "DC15a Range Finder"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Low Cost, High Quality scopes, for your conveinence."

att.SortOrder = 3

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Neutrals = {"uc.bus"}

att.AutoStats = true
att.Slot = {"dc15a_range_finder"}

att.Model = "models/atts/dc15a_range_finder_scope1.mdl"
att.ModelOffset = Vector(6.5, 2, 0.7)
att.ModelScale = Vector(1, 1, 1)
att.OffsetAng = Angle(0, 0, 0)

att.AdditionalSights = {
    {
        ---internal scope---
                    --x,y,z--
        Pos = Vector(-1.39, 1.2, -1.55),
        Ang = Angle(0, 0, -30),
        Magnification = 1.1,
        ZoomLevels = 4,
        ViewModelFOV = 38,
        IgnoreExtra = true,
        CrosshairInSights = false,
        HolosightBone = "holosight",
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("scope/star_ret.png", "smooth"),
            HolosightNoFlare = true,
            HolosightSize = 12,
            HolosightPiece = "models/atts/dc15a_rangefinder_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification =  5,
            Colorable = false,
        },
    },
    {
        ---ironsights---
        Pos = Vector(-0.02, 8, -2.29),
        Ang = Angle(0, 0, 0),
        Magnification = 1,
        IgnoreExtra = true,
        HolosightData = {
            Holosight = false,
            HolosightReticle = Material("scope/star_ret.png", "smooth"),
            HolosightSize = 2,
            Colorable = true,
        },
    },
}

att.Colorable = true
att.HolosightPiece = "models/atts/dc15a_rangefinder_hsp.mdl"

att.Mult_SightedSpeedMult = 0.75
att.Mult_SightTime = 1.1
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_a280cfe_scope.lua:
att.PrintName = "A280-CFE Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/a280cfe_default_scope2.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.03),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 7
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/a280cfe_default_scope2_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 44

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_iqa11_scope.lua:
att.PrintName = "IQA-11 Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/iqa11_default_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.2),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 6
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/iqa11_default_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 44

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_endurance.lua:
att.PrintName = "Endurance"
att.Icon = Material("interfaz/iconos/kraken/jedi guns dirty fighting/1626143083_2805137530.png")
att.Description = "Long courses of physical training allow you to bear more weight and control the recoil of your weapon."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true

att.Mult_MoveSpeed = 1.1
att.Mult_Recoil = 0.9
att.Mult_RecoilSide = 0.9

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_pointshooting.lua:
att.PrintName = "Point Shooting"

att.Icon = Material("interfaz/iconos/kraken/jedi juns sharpshooter/3136448382_2347094400.png")
att.Description = "Dedicated practice at shooting without using the sights has given you the ability to fire from the hip more effectively. If ARC Troopers can do it, so can you."
att.Desc_Pros = {
    "Better hip dispersion"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.SortOrder = 6

att.Mult_HipDispersion = 0.70

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_strafe.lua:
att.PrintName = "Strafe"

att.Icon = Material("interfaz/iconos/kraken/sith merc arsenal/2758039414_661058070.png")
att.Description = "Active experience in simulated combat drills has conditioned you to shoot while walking towards the enemy. When firing, you can walk at your normal speed."
att.Desc_Pros = {
    "Better shoot speed and less time to aim."
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true

att.Override_ShootSpeedMult = 1
att.Mult_SightedSpeedMult = 1.2

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_technician.lua:
att.PrintName = "Technician"

att.Icon = Material("interfaz/iconos/kraken/sith merc arsenal/3534684787_1254886694.png")
att.Description = "Life around this particular firearm has given you a solid understanding of its mechanism. When it malfunctions, you can clear the jam with enough speed to stay in the fight."
att.Desc_Pros = {
    "Jamming will fix faster"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.SortOrder = 1.5

att.Mult_MalfunctionFixTime = .65

att.Ignore = true

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/rps6_tracking.lua:
att.PrintName = "Hitzesuchend"
att.AbbrevName = "Hitzesuchend"
att.Icon = Material("interfaz/iconos/dpsicon2.png")
att.Description = "Replace the main-fire for stun rounds."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"aocrp_rps6"}

att.AutoStats = true
att.Override_AmmoPerShot = 5
att.Override_Tracer = "effect_sw_laser_blue_stun"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 5, 1, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/republic/stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_dc17m_60mag_v2.lua:
att.PrintName = "SW-Extended Magazine (v2)"
att.AbbrevName = "60-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc17m_ext_v2"

att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 90)
att.AutoStats = true
att.ModelBodygroups = "0000000000"

att.Add_ClipSize = 20

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--addons/arccw_weapons/lua/arccw/shared/attachments/sw_stock_e11b.lua:
att.PrintName = "SW-Stock E11b"
att.AbbrevName = "E11-b Stock"
att.SortOrder = 100
att.Icon = nil
att.Description = "Better control."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11b_stock"

att.Model = "models/arccw/sw_battlefront/props/e11b_stock/e11b_stock.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 0)
att.ModelOffset = Vector(-12.5, 0, -1)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true
att.Mult_Damage = 1.15

att.Override_ClipSize = 40

att.Mult_SightTime = 1.05
att.Mult_Sway = 1.1
att.Mult_RPM = 0.85

att.Mult_SpeedMult = 0.95

att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.05

att.Mult_HipDispersion = 1.05

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--lua/arccw/shared/attachments/uc_40mm_napalm.lua:
att.PrintName = "40mm Napalm Grenades"
att.AbbrevName = "Napalm"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Extremely illegal airburst grenades loaded with sticky napalm.\nWhile the napalm only disperses in a small radius, it will stick onto targets that come into contact with it, causing a gruesome and fiery death."
att.Desc_Pros = {
    "uc.40mm.napalm",
    "uc.40mm.proximity",
}
att.Desc_Cons = {
    "uc.40mm.nodmg",
    "uc.40mm.arm",
    "uc.40mm.drag.high",
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.AutoStats = true

att.Override_ShootEntity = "arccw_uc_40mm_napalm"

att.Mult_MuzzleVelocity = 0.75

att.Mult_ShootPitch = 0.95

att.ActivateElements = {"40mm_napalm"}
--lua/arccw/shared/attachments/uc_charm_urbancharm_renewal.lua:
att.PrintName = "Urban Charm - Renewal"
att.Description = "The icon of a Garry's Mod addon."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_urbancharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1.1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
att.CharmSkin = 2

--lua/arccw/shared/attachments/uc_choke_full.lua:
att.PrintName = "Full Choke"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "A very tight choke for shotguns, noticably tightening spread. However, it tends to offset aiming."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.disp.100"
}
att.Desc_Neutrals = {
}
att.Slot = {"choke","muzzle"}
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Recoil = 1.25
att.Mult_RecoilSide = 1.5
att.Mult_AccuracyMOA = .7
att.Add_HipDispersion = 100
att.Add_SightsDispersion = 100
--lua/arccw/shared/attachments/uc_fg_slamfire.lua:
att.PrintName = "Slamfire Kit"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "Reckless removal of trigger safety features allows shells to fire immediately upon being cycled while the trigger is held. This enables rapid \"rack and fire\" behavior similar to old trench guns, but impacts weapon performance."
att.Desc_Pros = {
    "uc.slam"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
    if wep:GetBuff_Override("Override_ManualAction", wep.ManualAction) then return end
    for i, v in pairs(wep.Firemodes) do
        if !v then continue end
        if v.Mode and v.Override_ManualAction then
            return
        end
    end
    return false
end

att.Mult_Recoil = 1.2
att.Mult_RecoilSide = 1.5

att.Override_Firemodes = {
    {
        Mode = 2,
        PrintName = "fcg.slam",
        Override_ManualAction = true,
    },
    {
        Mode = 0
    }
}
att.Override_Firemodes_Priority = 11 -- higher than spas-12 manual

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_grip_tdvfg.lua:
att.PrintName = "TangoDown Vertical Foregrip"
att.AbbrevName = "TangoDown Stubby Foregrip"
att.Icon = Material("entities/att/acwatt_uc_grip_tdvfg.png", "mips smooth")
att.Description = "Write me up, I dare you."

att.SortOrder = 1400

att.AutoStats = true
att.Slot = "foregrip"

att.LHIK = true

att.ModelOffset = Vector(0, 0, 0)
att.Model = "models/weapons/arccw/atts/uc_tdvfg1.mdl"

att.Mult_Recoil = 0.9
att.Mult_SightTime = 1.06
att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.1

att.Override_HoldtypeActive = "smg"
att.Override_HoldtypeActive_Priority = 2

att.Ignore = true
--lua/arccw/shared/attachments/uc_muzzle_supp_pbs4.lua:
att.PrintName = "PBS-4 Suppressor"

att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_pbs4.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nOriginally designed for carbine barrels, this suppressor compensates for inaccuracy, and can be mounted to other barrels with some gunsmithing work."
att.Desc_Neutrals = {"uc.exclusive.545", "uc.supptail"}

att.AutoStats = true
att.AutoStats = true
att.Slot = {"ur_ak_muzzle"}

att.SortOrder = 149

att.Model = "models/weapons/arccw/atts/uc_pbs4.mdl"
att.ModelOffset = Vector(2.9, 0, 0)
att.ModelScale = Vector(1.3, 1.3, 1.3)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_AccuracyMOA = 0.75

att.Add_BarrelLength = 5
att.Mult_SightTime = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep)
    if wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo) != "smg1" then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_optic_pso1.lua:
att.PrintName = "PSO-1 (4x)"
att.AbbrevName = "PSO-1 (4x)"
att.Icon = Material("entities/att/acwatt_uc_optic_pso1.png", "mips smooth")
att.Description = "Medium range combat scope for improved precision at longer ranges.\nExclusive to the \"Warsaw Pact\" optic mount, and is slightly more agile than rail mounted optics."

att.SortOrder = 300

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"ur_ak_optic"}

att.Model = "models/weapons/arccw/atts/ur_pso1.mdl"
att.ModelOffset = Vector(-2, 0, -4.55)

att.AdditionalSights = {
    {
        Pos = Vector(0, 13, -1.5),
        Ang = Angle(0, 0, 0),
        Magnification = 1.25,
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/scopes/uc_pso.png", "mips smooth"),
            HolosightNoFlare = true,
            HolosightSize = 10.5,
            HolosightPiece = "models/weapons/arccw/atts/ur_pso1_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification = UC_HalfScope( 4 ),
            Colorable = true,
        },
    }
}

-- att.Holosight = true
-- att.HolosightReticle = Material("mifl_tarkov_reticle/dot.png", "mips smooth")

att.HolosightPiece = "models/weapons/arccw/atts/ur_pso1_hsp.mdl"
-- att.HolosightNoFlare = true
-- att.HolosightSize = 1
-- att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .8
att.ExcludeFlags = {"ak_norail","cover_rail"}

--lua/arccw/shared/attachments/uc_powder_overpressure.lua:
att.PrintName = "Overpressured"

att.SortOrder = 20
att.Icon = Material("entities/att/acwatt_uc_powder_overpressure.png", "smooth mips")
att.Description = "Higher pressure ammunition allows for higher muzzle velocity at the cost of stronger knockback. Such immense pressure increases the likelihood of extraction failures."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_powder"

att.AutoStats = true

att.Mult_RecoilSide = 1.25
att.Mult_Recoil = 1.2
att.Mult_RangeMin = 1.25
att.Mult_Range = 1.3

att.Mult_RPM = 1.08
att.Mult_ShootVol = 1.25
--att.Mult_ShootPitch = 0.9 please don't

att.Mult_MalfunctionMean = 0.7
att.Mult_PhysBulletMuzzleVelocity = 1.25
--lua/arccw/shared/attachments/uc_powder_subsonic.lua:
att.PrintName = "Subsonic"

att.SortOrder = 17
att.Icon = Material("entities/att/acwatt_uc_powder_subsonic.png", "smooth mips")
att.Description = [[Powder load low enough to make the bullet travel slower than the speed of sound. This reduces range significantly, but makes gunfire very comfortable and quiet (comparatively speaking).
The sonic boom typical of the round is eliminated, rendering it even more silent than usual with a suppressed firearm.]]
att.Desc_Pros = {
    "pro.invistracers",
    -- "uc.subsonic"
}
att.Desc_Cons = {
    "uc.subsonic.vel"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_powder"

att.AutoStats = true

att.Mult_RecoilSide = 0.75
att.Mult_Recoil = 0.8
att.Mult_RangeMin = 0.75
att.Mult_Range = 0.7

att.Mult_RPM = 0.89
att.Mult_ShootVol = 0.8
--att.Mult_ShootPitch = 1.1 please don't

att.Override_PhysTracerProfile = 7
att.Override_TracerNum = 0

att.Mult_MalfunctionMean = 1.3
att.Override_PhysBulletMuzzleVelocity = 339
att.Override_PhysBulletMuzzleVelocity_Priority = 2

-- att.Hook_GetDistantShootSound = function(wep, distancesound)
--     if distancesound == wep.DistantShootSoundSilenced then
--         return false
--     end
-- end

att.GivesFlags = {"powder_subsonic"}
att.ExcludeFlags = {"cal_subsonic"}
--lua/arccw/shared/attachments/uc_stock_pistol.lua:
att.PrintName = "FAB Defense Collapsible Tactical Stock"
att.AbbrevName = "Pistol Stock"
att.Icon = Material("entities/att/acwatt_uc_stock_pistol.png", "mips smooth")
att.Description = "Mitigates the recoil disadvantage typical of most pistols, but extends the weapon's profile substantially.\n\nYou probably shouldn't let the feds know you have this."
att.Slot = "go_stock_pistol_bt"
att.AutoStats = true

att.Model = "models/weapons/arccw/atts/stock_fab.mdl"

att.Mult_Recoil = .70
att.Mult_RecoilSide = .5
att.Mult_Sway = .5
att.Mult_SightTime = 1.3
att.Mult_DrawTime = 1.4
att.Add_BarrelLength = 20
--lua/arccw/shared/attachments/uc_tac_anpeq16a.lua:
att.PrintName = "Insight Technologies MIPIM AN/PEQ-16A"
att.AbbrevName = "AN/PEQ-16A"
att.Icon = Material("entities/att/acwatt_uc_tac_anpeq16a.png", "mips smooth")
att.Description = "Low-profile flashlight and laser module for rifles. The laser increases accuracy without the use of sights.\nThe laser and flashlight can be toggled individually."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac"}
att.SortOrder = 20+4

att.Model = "models/weapons/arccw/atts/uc_anpeq16a.mdl"
att.ModelOffset = Vector(0, 0.1, 0.25)
att.OffsetAng = Angle(0, 0,180)
att.ModelScale = Vector(1.2, 1.2, 1.2)
att.ModelSkin = 1
att.Laser = false
att.LaserStrength = 2 / 5
att.LaserBone = "laser"

att.ColorOptionsTable = {Color(255, 0, 0, 150)}

att.Mult_SightTime = 1.05
att.Mult_SightedSpeedMult = 0.95
att.Mult_MoveSpeed = 1

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 512 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 235, 229)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 2
att.FlashlightBone = "laser"

att.ToggleStats = {
    {
        PrintName = "Laser",
        Laser = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8
    },
    {
        PrintName = "Both",
        Laser = true,
        Flashlight = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8
    },
    {
        PrintName = "Light",
        Flashlight = true,
    },
    {
        PrintName = "Off",
    }
}
--lua/arccw/shared/attachments/uc_tac_flashlight1.lua:
att.PrintName = "Civilian Rail-Mounted Flashlight"
att.AbbrevName = "Civilian Flashlight"
att.Icon = Material("entities/att/acwatt_uc_tac_flashlight1.png", "mips smooth")
att.Description = "Illuminates dark areas in front of the muzzle.\nCan be adjusted for a wide light."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac","tac_pistol"}
att.SortOrder = 30+1

att.Model = "models/weapons/arccw/atts/ud_flashlight_1.mdl"
att.ModelOffset = Vector(0,0,0)
att.OffsetAng = Angle(0,0,180)
att.ModelScale = Vector(1.2,1.2,1.2)

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 1024 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 242, 229)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 3
att.FlashlightBone = "light"

att.ToggleStats = {
    {
        PrintName = "On",
        Flashlight = true
    },
    {
        PrintName = "Wide",
        Flashlight = true,
        FlashlightFOV = 80,
        FlashlightFarZ = 768,
        FlashlightBrightness = 1
    },
    {
        PrintName = "Off",
        Flashlight = false,
    }
}
--lua/arccw/shared/attachments/uc_ubgl_hk79.lua:
att.PrintName = "HK79 Underbarrel Grenade Launcher"
att.AbbrevName = "HK79 Grenade Launcher"
att.Icon = Material("entities/att/acwatt_uc_ubgl_hk79.png", "mips smooth")
att.Description = "Single-shot long-barreled underbarrel grenade launcher designed for the G3. The trigger is on the side, and the barrel release is on the bottom. Fires specialized 40x46mm grenade types."
att.Ignore = true

att.SortOrder = -100000

att.AutoStats = true
att.Desc_Pros = {
}
att.Slot = "uc_ubgl"
att.ExcludeFlags = {"uc_noubgl"}

att.LHIK = true

att.ModelOffset = Vector(3.2, 0, -1.5)
att.Model = "models/weapons/arccw/atts/uc_ubgl_hk79_3.mdl"

att.SelectUBGLSound =  ""
att.ExitUBGLSound = ""

att.UBGL = true

att.UBGL_PrintName = "UBGL"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "muzzleflash_m79"
att.UBGL_Ammo = "smg1_grenade"
att.UBGL_RPM = 120
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.LHIK_GunDriver = 2
att.LHIK_CamDriver = 3

local pretty = GetConVar("arccw_uc_infiniteubwammo")

att.Hook_ModifyAttBodygroups = function(wep, data)
    if wep:GetBuff_Override("UC_UseClassicHK79Mount") then
        data.element.Model:SetBodygroup(1, 1)
    end
end

local function Ammo(wep)
    return (pretty:GetBool() and 9999 or wep:GetOwner():GetAmmoCount("smg1_grenade"))
end

att.Hook_LHIK_TranslateAnimation = function(wep, key)
    if key == "idle" then
        if wep:GetInUBGL() then
            return "idle_armed"
        else
            return "idle"
        end
    end
end

att.Hook_ShouldNotSight = function(wep)
    if wep:GetInUBGL() then
        return true
    end
end

att.Hook_OnSelectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_armed", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/raise.ogg", t = 0.2},
            {s = "arccw_uc/common/grab.ogg", t = 0.5},
        })
    end
end

att.Hook_OnDeselectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_idle", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/shoulder.ogg", t = 0.4},
        })
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    local owner = wep:GetOwner()
    local class = wep:GetBuff_Override("UBGL_Entity") or "arccw_uc_40mm_hv"

    local vel, dmg = 2500, 130

    -- hacky
    if class == "arccw_uc_40mm_hv" then
        vel = vel * 2
        dmg = dmg * 0.85
    elseif class == "arccw_uc_40mm_dp" then
        dmg = dmg * 0.6
    elseif class == "arccw_uc_40mm_airburst" then
        vel = vel * 0.75
    end

    local proj = wep:FireRocket(class, vel)
    if SERVER then
        proj.Damage = dmg -- lower than the m79 (200) for balance reasons
    end
    wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-0" .. math.random(1, 6) .. ".ogg", 100, 100, 1, CHAN_WEAPON)
    wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-dist-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_BODY)
    wep:MyEmitSound(")^/arccw_uc/common/40mm/mech-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_AUTO)

    if game.SinglePlayer() and SERVER or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoEffects()
        wep:DoLHIKAnimation("fire")
    end
    wep:SetClip2(wep:Clip2() - 1)
    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end
    if Ammo(wep) <= 0 then return end

    wep:SetNextSecondaryFire(CurTime() + 3)

    local holy = (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted())
    if holy then
        wep:DoLHIKAnimation("reload", 3)
        wep:PlaySoundTable({
            {s = { "arccw_uc/common/rattle1.ogg", "arccw_uc/common/rattle2.ogg", "arccw_uc/common/rattle3.ogg" }, t = 0},
            {s = "arccw_uc/common/40mm/203open.ogg", t = 0.2},
            {s = "arccw_uc/common/magpouch_replace_small.ogg", t = 0.9},
            {s = "arccw_uc/common/40mm/203insert.ogg", t = 1.7},
            {s = "arccw_uc/common/shoulder.ogg", t = 2.0},
            {s = "arccw_uc/common/40mm/203close.ogg", t = 2.2},
            {s = "arccw_uc/common/shoulder.ogg", t = 2.7},
        })
    end

    local reserve = Ammo(wep)
    reserve = reserve + wep:Clip2()
    local clip = 1
    local load = math.Clamp(clip, 0, reserve)
    if (!pretty:GetBool()) then
        wep:GetOwner():RemoveAmmo(1, "smg1_grenade")
    end
    wep:SetClip2(load)
end

att.Mult_SightTime = 1.2
att.Mult_SpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.85

att.ToggleLockDefault = true
att.ToggleStats = {
    {
        PrintName = "High Velocity",
        UBGL_Entity = "arccw_uc_40mm_hv"
    },
    {
        PrintName = "Dual Purpose",
        UBGL_Entity = "arccw_uc_40mm_dp"
    },
    {
        PrintName = "Airburst",
        UBGL_Entity = "arccw_uc_40mm_airburst"
    },
}
--addons/arccw_base_modified/lua/arccw/shared/languages/base_en.lua:
L = {}
STL = {}

-- not a translate string, but in case a language needs its own font
L["default_font"] = "Bahnschrift"

-- Attachment Slots
L["attslot.optic"] = "Optic"
L["attslot.bkoptic"] = "Backup Optic"
L["attslot.muzzle"] = "Muzzle"
L["attslot.barrel"] = "Barrel"
L["attslot.choke"] = "Choke"
L["attslot.underbarrel"] = "Underbarrel"
L["attslot.tactical"] = "Tactical"
L["attslot.grip"] = "Grip"
L["attslot.stock"] = "Stock"
L["attslot.fcg"] = "Fire Group"
L["attslot.ammo"] = "Ammo Type"
L["attslot.perk"] = "Perk"
L["attslot.charm"] = "Charm"
L["attslot.skin"] = "Skin"
L["attslot.noatt"] = "No Attachment"
L["attslot.optic.default"] = "Iron Sights"
L["attslot.muzzle.default"] = "Standard Muzzle"
L["attslot.barrel.default"] = "Standard Barrel"
L["attslot.choke.default"] = "Standard Choke"
L["attslot.grip.default"] = "Standard Grip"
L["attslot.stock.default"] = "Standard Stock"
L["attslot.stock.none"] = "No Stock"
L["attslot.fcg.default"] = "Standard FCG"

-- Trivia
L["trivia.class"] = "Class"
L["trivia.year"] = "Year"
L["trivia.mechanism"] = "Mechanism"
L["trivia.calibre"] = "Calibre"
L["trivia.ammo"] = "Ammo Type"
L["trivia.country"] = "Country"
L["trivia.manufacturer"] = "Manufacturer"
L["trivia.clipsize"] = "Magazine Capacity"
L["trivia.precision"] = "Precision"
L["trivia.noise"] = "Noise"
L["trivia.recoil"] = "Vertical Recoil"
L["trivia.penetration"] = "Penetration"
L["trivia.firerate"] = "Fire Rate"
L["trivia.firerate_burst"] = "Burst Fire Rate"
L["trivia.fusetime"] = "Fuse Time"

-- Class
L["class.pistol"] = "Pistol"
L["class.revolver"] = "Revolver"
L["class.machinepistol"] = "Machine Pistol"
L["class.smg"] = "Submachine Gun"
L["class.pdw"] = "Personal Defense Weapon"
L["class.shotgun"] = "Shotgun"
L["class.assaultcarbine"] = "Assault Carbine"
L["class.carbine"] = "Carbine"
L["class.assaultrifle"] = "Assault Rifle"
L["class.rifle"] = "Rifle"
L["class.battlerifle"] = "Battle Rifle"
L["class.dmr"] = "DMR"
L["class.sniperrifle"] = "Sniper Rifle"
L["class.antimaterielrifle"] = "Antimateriel Rifle"
L["class.rocketlauncher"] = "Rocket Launcher"
L["class.grenade"] = "Hand Grenade"
L["class.melee"] = "Melee Weapon"

-- UI
L["ui.savepreset"] = "Save Preset"
L["ui.loadpreset"] = "Load Preset"
L["ui.stats"] = "Stats"
L["ui.trivia"] = "Trivia"
L["ui.tttequip"] = "Equipment"
L["ui.tttchat"] = "Quickchat"
L["ui.position"] = "POSITION"
L["ui.positives"] = "POSITIVES:"
L["ui.negatives"] = "NEGATIVES:"
L["ui.information"] = "INFORMATION:"

-- Stats
L["stat.stat"] = "Stat" -- Used on first line of stat page
L["stat.original"] = "Original"
L["stat.current"] = "Current"
L["stat.damage"] = "Close Range Damage"
L["stat.damage.tooltip"] = "How much damage this weapon does at point blank."
L["stat.damagemin"] = "Long Range Damage"
L["stat.damagemin.tooltip"] = "How much damage this weapon does beyond its range."
L["stat.range"] = "Range"
L["stat.range.tooltip"] = "The distance between which close range damage turns to long range damage, in meters."
L["stat.firerate"] = "Fire Rate"
L["stat.firerate.tooltip"] = "The rate at which this weapon cycles at, in rounds per minute."
L["stat.firerate.manual"] = "MANUAL" -- Shown instead of RPM when it is a manual weapon
L["stat.capacity"] = "Capacity"
L["stat.capacity.tooltip"] = "How many rounds this weapon can hold."
L["stat.precision"] = "Precision"
L["stat.precision.tooltip"] = "How precise the weapon is when still and aimed, in minutes of arc."
L["stat.hipdisp"] = "Hip Dispersion"
L["stat.hipdisp.tooltip"] = "How much imprecision is added when the weapon is hipfired."
L["stat.movedisp"] = "Moving Accuracy"
L["stat.movedisp.tooltip"] = "How much imprecision is added when the weapon is used while moving."
L["stat.recoil"] = "Recoil"
L["stat.recoil.tooltip"] = "The amount of kick produced each shot."
L["stat.recoilside"] = "Side Recoil"
L["stat.recoilside.tooltip"] = "The amount of horizontal kick produced each shot."
L["stat.sighttime"] = "Handling Time"
L["stat.sighttime.tooltip"] = "How long does it take to transition from or to sprinting and sights with this weapon."
L["stat.speedmult"] = "Move Speed"
L["stat.speedmult.tooltip"] = "The speed at which you move with the gun, in percentage of original speed."
L["stat.sightspeed"] = "Speed while Sighted"
L["stat.sightspeed.tooltip"] = "The additional slowdown applied when you are moving with sights down."
L["stat.meleedamage"] = "Bash Damage"
L["stat.meleedamage.tooltip"] = "How much damage the melee bash causes."
L["stat.meleetime"] = "Bash Time"
L["stat.meleetime.tooltip"] = "The time it takes to do a melee bash."
L["stat.shootvol"] = "Firing Volume"
L["stat.shootvol.tooltip"] = "How loud the weapon is, in decibels. Louder weapons can be heard from further away."
L["stat.barrellen"] = "Weapon length"
L["stat.barrellen.tooltip"] = "The length of the weapon, in Hammer units / inches. Long barrels will be blocked by walls more easily."
L["stat.pen"] = "Penetration"
L["stat.pen.tooltip"] = "How much material this weapon can penetrate."

-- Autostats
L["autostat.bipodrecoil"] = "Recoil in bipod"
L["autostat.bipoddisp"] = "Dispersion in bipod"
L["autostat.damage"] = "Close range damage"
L["autostat.damagemin"] = "Long range damage"
L["autostat.damageboth"] = "Damage" -- When damage and damagemin are the same value
L["autostat.range"] = "Range"
L["autostat.penetration"] = "Penetration"
L["autostat.muzzlevel"] = "Muzzle velocity"
L["autostat.meleetime"] = "Melee attack time"
L["autostat.meleedamage"] = "Melee damage"
L["autostat.meleerange"] = "Melee range"
L["autostat.recoil"] = "Recoil"
L["autostat.recoilside"] = "Horizontal recoil"
L["autostat.firerate"] = "Fire rate"
L["autostat.precision"] = "Imprecision"
L["autostat.hipdisp"] = "Spread in hipfire"
L["autostat.sightdisp"] = "Spread while sighted"
L["autostat.movedisp"] = "Spread while moving"
L["autostat.jumpdisp"] = "Spread while in midair"
L["autostat.barrellength"] = "Weapon length"
L["autostat.shootvol"] = "Weapon volume"
L["autostat.speedmult"] = "Movement speed"
L["autostat.sightspeed"] = "Speed while sighted"
L["autostat.shootspeed"] = "Speed while shooting"
L["autostat.reloadtime"] = "Reload time"
L["autostat.drawtime"] = "Draw time"
L["autostat.sighttime"] = "Handling"
L["autostat.cycletime"] = "Cycle time"
L["autostat.magextender"] = "Extended magazine size"
L["autostat.magreducer"] = "Reduced magazine size"
L["autostat.bipod"] = "Can use Bipod"
L["autostat.holosight"] = "Precision sight picture"
L["autostat.zoom"] = "Increased zoom"
L["autostat.glint"] = "Visible scope glint"
L["autostat.thermal"] = "Thermal vision"
L["autostat.silencer"] = "Suppresses firing sound"
L["autostat.norandspr"] = "No random spread"
L["autostat.sway"] = "Aim sway"
L["autostat.heatcap"] = "Heat capacity"
L["autostat.heatfix"] = "Overheat fix time"
L["autostat.heatdelay"] = "Heat recovery delay"
L["autostat.heatdrain"] = "Heat recovery rate"

-- TTT
L["ttt.roundinfo"] = "ArcCW Configuration"
L["ttt.roundinfo.replace"] = "Auto-replace TTT weapons"
L["ttt.roundinfo.cmode"] = "Customize Mode:"
L["ttt.roundinfo.cmode0"] = "No Restrictions"
L["ttt.roundinfo.cmode1"] = "Restricted"
L["ttt.roundinfo.cmode2"] = "Pre-game only"
L["ttt.roundinfo.cmode3"] = "T/D only"

L["ttt.roundinfo.attmode"] = "Attachment Mode:"
L["ttt.roundinfo.free"] = "Free"
L["ttt.roundinfo.locking"] = "Locking"
L["ttt.roundinfo.inv"] = "Inventory"
L["ttt.roundinfo.persist"] = "Persistent"
L["ttt.roundinfo.drop"] = "Drop on death"
L["ttt.roundinfo.inv"] = "Inventory"
L["ttt.roundinfo.pickx"] = "Pick"

L["ttt.roundinfo.bmode"] = "Attachment Info on Body:"
L["ttt.roundinfo.bmode0"] = "Unavailable"
L["ttt.roundinfo.bmode1"] = "Detectives Only"
L["ttt.roundinfo.bmode2"] = "Available"

L["ttt.roundinfo.amode"] = "Ammo Explosion:"
L["ttt.roundinfo.amode-1"] = "Disabled"
L["ttt.roundinfo.amode0"] = "Simple"
L["ttt.roundinfo.amode1"] = "Frag"
L["ttt.roundinfo.amode2"] = "Full"
L["ttt.roundinfo.achain"] = "Chain explosions"

L["ttt.bodyatt.found"] = "You think the murder weapon"
L["ttt.bodyatt.founddet"] = "With your detective skills, you deduce the murder weapon"
L["ttt.bodyatt.att1"] = " had {att} installed."
L["ttt.bodyatt.att2"] = " had {att1} and {att2} installed."
L["ttt.bodyatt.att3"] = " had these attachments: "

L["ttt.attachments"] = " Attachment(s): " -- Used in TTT2 TargetID
L["ttt.ammo"] = "Ammo: " -- Used in TTT2 TargetID

-- Shit that used to be in CS+ why
L["info.togglesight"] = "Double press +USE to toggle sights"
L["info.toggleubgl"] = "Double press +ZOOM to toggle underbarrel" -- deprecated
L["pro.ubgl"] = "Selectable underbarrel launcher" -- deprecaated
L["pro.ubsg"] = "Selectable underbarrel shotgun" -- deprecaated
L["con.obstruction"] = "May obstruct sights"
L["autostat.underwater"] = "Shoot underwater"
L["autostat.sprintshoot"] = "Shoot while sprinting"
L["con.beam"] = "Visible laser beam"
L["con.light"] = "Visible flashlight beam"
L["con.noscope"] = "No point of aim"
L["pro.invistracers"] = "Invisible tracers"

-- Incompatibility Menu
L["incompatible.title"] = "ArcCW: INCOMPATIBLE ADDONS"
L["incompatible.line1"] = "You have some addons that are known to not work with ArcCW."
L["incompatible.line2"] = "Disable them or expect broken behavior!"
L["incompatible.confirm"] = "Acknowledge"
L["incompatible.wait"] = "Wait {time}s"
L["incompatible.never"] = "Never warn me again"
L["incompatible.never.hover"] = "Are you absolutely sure you understand the consequences?"
L["incompatible.never.confirm"] = "You have chosen to never show incompatiblity warnings again. If you encounter errors or broken behaviour, it is your own responsibility."

-- 2020-12-11
L["hud.hp"] = "HP: " -- Used in default HUD
L["fcg.safe"] = "Safety"
L["fcg.semi"] = "Semi-auto"
L["fcg.auto"] = "Automatic"
L["fcg.burst"] = "%d-round burst"
L["fcg.ubgl"] = "UBGL"

-- 2021-01-14
L["ui.toggle"] = "TOGGLE"
L["ui.whenmode"] = "When %s"
L["ui.modex"] = "Mode %s"

-- 2021-01-25
L["attslot.magazine"] = "Magazine"

-- 2021-03-13
L["trivia.damage"] = "Damage"
L["trivia.range"] = "Range"
L["trivia.attackspersecond"] = "Attacks Per Second"
L["trivia.description"] = "Description"
L["trivia.meleedamagetype"] = "Damage Type"

-- Units
L["unit.rpm"] = "RPM"
L["unit.moa"] = "MOA"
L["unit.mm"] = "mm"
L["unit.db"] = "dB"
L["unit.bce"] = "BC"
L["unit.aps"] = "APS"

-- melee damage types
L["dmg.generic"] = "Unarmed"
L["dmg.bullet"] = "Piercing"
L["dmg.slash"] = "Slashing"
L["dmg.club"] = "Blunt"
L["dmg.shock"] = "Shock"

L["ui.presets"] = "Presets"
L["ui.customize"] = "Customize"
L["ui.inventory"] = "Inventory"

-- 2021-05-05
L["ui.gamemode_buttons"] = "Gamemode-specific commands"
L["ui.gamemode_usehint"] = "You can hold USE to access original keybinds."
L["ui.darkrpdrop"] = "Drop Weapon"
L["ui.noatts"] = "You have no attachments"
L["ui.noatts_slot"] = "You have no attachments for this slot"
L["ui.lockinv"] = "These attachments are unlocked for all weapons."
L["autostat.ammotype"] = "Converts weapon ammo type to %s"

-- 2021-05-08
L["autostat.rangemin"] = "Minimum range"

-- 2021-05-13
L["autostat.malfunctionmean"] = "Reliability"
L["ui.heat"] = "HEAT"
L["ui.jammed"] = "JAMMED"

-- 2021-05-15
L["trivia.muzzlevel"] = "Muzzle Velocity"
L["unit.mps"] = "m/s"
L["unit.lbfps"] = "lb-fps"
L["trivia.recoilside"] = "Horizontal Recoil"

--2021-05-27
L["ui.pickx"] = "Attachments: %d/%d"
L["ui.ballistics"] = "Ballistics"

L["ammo.pistol"] = "Pistol Ammo"
L["ammo.357"] = "Magnum Ammo"
L["ammo.smg1"] = "Carbine Ammo"
L["ammo.ar2"] = "Rifle Ammo"
L["ammo.buckshot"] = "Shotgun Ammo"
L["ammo.sniperpenetratedround"] = "Sniper Ammo"
L["ammo.smg1_grenade"] = "Rifle Grenades"

--2021-05-31
L["ui.nodata"] = "No Data"
L["ui.createpreset"] = "Create"
L["ui.deletepreset"] = "Delete"

--2021-06-09 nice
L["autostat.clipsize"] = "%d-round magazine capacity"

--2021-06-30
L["autostat.bipod2"] = "Allows bipod (-%d%% Dispersion, -%d%% Recoil)"
L["autostat.nobipod"] = "Disables bipod"

--2021-07-01
L["fcg.safe2"] = "Lowered"
L["fcg.dact"] = "Double-action"
L["fcg.sact"] = "Single-action"
L["fcg.bolt"] = "Bolt-action"
L["fcg.pump"] = "Pump-action"
L["fcg.lever"] = "Lever-action"
L["fcg.manual"] = "Manual-action"
L["fcg.break"] = "Break-action"
L["fcg.sngl"] = "Single"
L["fcg.both"] = "Both"

--2021-08-11
L["autostat.clipsize.mod"] = "Magazine capacity" -- used for Add_ClipSize and Mult_ClipSize

--2021-08-22
L["trivia.recoilscore"] = "Recoil Score (Lower is better)"
L["fcg.safe.abbrev"] = "SAFE"
L["fcg.semi.abbrev"] = "SEMI"
L["fcg.auto.abbrev"] = "AUTO"
L["fcg.burst.abbrev"] = "%d-BST"
L["fcg.ubgl.abbrev"] = "UBGL"
L["fcg.safe2.abbrev"] = "LOW"
L["fcg.dact.abbrev"] = "DACT"
L["fcg.sact.abbrev"] = "SACT"
L["fcg.bolt.abbrev"] = "BOLT"
L["fcg.pump.abbrev"] = "PUMP"
L["fcg.lever.abbrev"] = "LEVER"
L["fcg.manual.abbrev"] = "MANUAL"
L["fcg.break.abbrev"] = "BREAK"
L["fcg.sngl.abbrev"] = "SNGL"
L["fcg.both.abbrev"] = "BOTH"

-- 2021-10-10
STL["lowered"] = "fcg.safe2"
STL["double-action"] = "fcg.dact"
STL["single-action"] = "fcg.sact"
STL["bolt-action"] = "fcg.bolt"
STL["pump-action"] = "fcg.pump"
STL["lever-action"] = "fcg.lever"
STL["manual-action"] = "fcg.manual"
STL["break-action"] = "fcg.break"
--STL["single"] = "fcg.sngl"
--STL["both"] = "fcg.both"

-- 2021-11-27
L["ui.hitgroup"] = "Hitgroup"
L["ui.shotstokill"] = "Shots to kill"
L["ui.hitgroup.head"] = "Head"
L["ui.hitgroup.torso"] = "Torso" -- chest+stomach when they're the same
L["ui.hitgroup.chest"] = "Chest"
L["ui.hitgroup.stomach"] = "Stomach"
L["ui.hitgroup.arms"] = "Arms"
L["ui.hitgroup.legs"] = "Legs"
L["ui.nonum"] = "You need bullets to kill people, silly." -- num is 0

-- 2022-05-23
L["fcg.nade"] = "Grenade"
L["fcg.nade.abbrev"] = "NADE"

-- 2022-08-03
L["attslot.magazine"] = "Magazine"
L["attslot.magazine.default"] = "Standard Magazine"

-- 2022-08-17
L["autostat.ubgl"] = "Selectable underbarrel weapon"
L["autostat.ubgl2"] = "Press your USE key and RELOAD key together to activate underbarrel weapon"
L["autostat.ammotypeubgl"] = "Underbarrel weapon uses %s"

-- 2023-09-09
L["autostat.triggerdelay"] = "Trigger delay"


--[[]
You can translate the trivia of any arbitrary weapon or attachment by adding the phrase ["desc.class_name"]
Similarly, you can translate attachment and weapon names with ["name.class_name"]
When translating weapon names, append .true for truename, like ["name.arccw_p228.true"]
Example:
 L["desc.fcg_auto"] = "blah blah blah automatic firemode"
 L["name.fcg_auto"] = "Auto But Cooler"
You can also translate custom firemodes with "fcg.FIREMODE_NAME"
]]
--addons/arccw_base_modified/lua/arccw/client/cl_singleplayer.lua:
net.Receive("arccw_sp_anim", function(len, ply)
    local wep    = LocalPlayer():GetActiveWeapon()
    local key    = net.ReadString()
    local mul    = net.ReadFloat()
    local start  = net.ReadFloat()
    local time   = net.ReadBool()
    --local skip   = net.ReadBool() Unused
    local ignore = net.ReadBool()

    if !wep.ArcCW then return end

    wep:PlayAnimation(key, mul, false, start, time, false, ignore)
end)

net.Receive("arccw_sp_checkpoints", function(len, ply)
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep.ArcCW then return end

    wep.CheckpointAnimation = nil
end)

net.Receive("arccw_sp_lhikanim", function(len, ply)
    local wep  = LocalPlayer():GetActiveWeapon()
    local key  = net.ReadString()
    local time = net.ReadFloat() or -1

    if !wep.ArcCW then return end

    wep:DoLHIKAnimation(key, time)
end)

net.Receive("arccw_sp_health", function(len, ply)
    local ent = net.ReadEntity()

    if !IsValid(ent) then return end

    ent:SetHealth(0)
    ent.ArcCWCLHealth = 0
end)

local clr_b = Color(160, 190, 255)
local clr_r = Color(255, 190, 190)

concommand.Add("arccw_listvmanims", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    local alist = vm:GetSequenceList()

    for i = 0, #alist do
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\t", alist[i], "\n     [")
        MsgC(clr_r, "\t", vm:SequenceDuration(i), "\n")
    end
end)

concommand.Add("arccw_listvmbones", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    for i = 0, (vm:GetBoneCount() - 1) do
        print(i .. " - " .. vm:GetBoneName(i))
    end
end)

concommand.Add("arccw_listvmatts", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    local alist = vm:GetAttachments()

    for i = 1, #alist do
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\tindex : ", alist[i].id, "\n     [")
        MsgC(clr_r, "\tname: ", alist[i].name, "\n")
    end
end)

concommand.Add("arccw_listvmbgs", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    local alist = vm:GetBodyGroups()

    for i = 1, #alist do
        local alistsm = alist[i].submodels
        local active = vm:GetBodygroup(alist[i].id)
        MsgC(clr_b, alist[i].id, " --  ")
        MsgC(color_white, "\t", alist[i].name, "\n")
        if alistsm then
            for j = 0, #alistsm do
                MsgC(active == j and color_white or clr_b, "\t" .. j, " - ")
                MsgC(active == j and color_white or clr_r, alistsm[j], "\n")
            end
        end
    end
end)

local lastwpn = nil

hook.Add("Think", "ArcCW_FixDeploy", function()
    --if !game.SinglePlayer() then return end
    local wep = LocalPlayer():GetActiveWeapon()

    if wep.ArcCW and wep != lastwpn then wep:Deploy() end

    lastwpn = wep
end)
--addons/auralvsradar/lua/aura_lvs_radar/aura_lvs_radar_client.lua:
-- Begin our clientside portion (most of it) 
if (CLIENT) then
	-- More materials and apperance-related variables
	local displayMaterial = Material("sprites/holo_base.vmt")
	local displayMaterial2 = Material("sprites/lfs_fight_display_image.png")
	local oldScale = 850 / aura_lfs_fight_displaybaseHeight
	local holo_pos_start = -aura_lfs_fight_displaybaseWidth / 2
	local holo_pos_end = -aura_lfs_fight_displaybaseHeight / 2
	local direction_pos = 350 / oldScale
	local radius = .3
	local feeling_colors = 
	{
		[0] = Color(255,255,255,200),
		[1] = Color(255,0,0,200),
		[2] = Color(255,255,100,200),
		[3] = Color(150,255,255,200),
		[4] = Color(255,255,255,200),
	}

	-- I love colors!!!!
	local white_color_faded = Color(255, 255, 255, 150)
	local friendly_color = Color(0,255,255,255)
	local enemy_color = Color(255,0,0,255)
	local friendly_color_ply = Color(0,255,255,200)
	local enemy_color_ply = Color(255,0,0,200)
	aura_lvs_radar_table_color = Color( 0, 255, 0, 255 )
	local table_oscilation_time = 3
	local table_up_offset = Vector(0,0,35)
	local table_direction_angle = Angle(0,90,0)
	local table_direction_letters =
	{
		[1] = "N",
		[2] = "E",
		[3] = "S",
		[4] = "W",
	}
	local table_top_render_scale = Vector(.1,.1,.1)

	-- As the file loads or the script is edited, cleanup models for ease of edits
	Aura_Radar_CleanUpAllShipEnts()

	function Aura_LVS_Radar_Calculate_Table_Values(ent)
		ent.position_to_self = ent:GetPos() + Vector(0,0,ent:GetNWInt("SelfOffsetY",70)) + Vector( -- Find appropriate z (altitude) scaling number for any map
		(ent:GetPos().x / aura_lfs_fight_displaymult), 
		(ent:GetPos().y / aura_lfs_fight_displaymult),
		(ent:GetPos().z / aura_lfs_fight_displaymult))
	end

	function Aura_LVS_Radar_Draw_Holo_Overlay(ent)
		local table_top_pos = ent:GetPos() + table_up_offset
		local mat = Matrix()

		cam.Start3D2D(table_top_pos, table_direction_angle , .1)
			for i=1, 4 do
				cam.PushModelMatrix( mat, true )
					draw.DrawText( table_direction_letters[i], "LFSFightDisplayFont2", 0, direction_pos, color_white )
				cam.PopModelMatrix()
				mat:Rotate( table_direction_angle )
			end

        	surface.SetMaterial(displayMaterial)
            surface.DrawTexturedRect(holo_pos_start,holo_pos_end,aura_lfs_fight_displaybaseWidth ,aura_lfs_fight_displaybaseHeight)
            surface.SetMaterial(displayMaterial2)
            surface.DrawTexturedRect(holo_pos_start,holo_pos_end,aura_lfs_fight_displaybaseWidth ,aura_lfs_fight_displaybaseHeight)
            surface.SetDrawColor( 50, 50, 50, 255 )

        cam.End3D2D()

	end

	function Aura_LVS_Radar_Draw_Table_On_Self(ent)
		render.SetColorMaterial()
    	render.DrawSphere(ent.position_to_self or ent:GetPos(), radius, 25, 25, aura_lvs_radar_table_color )
	end

	function Aura_LVS_Radar_Draw_Entity_Names(table, ent, ang)
		local ship = ent.original_ent
    	cam.Start3D2D(table:GetPos() + Vector(0,0,table:GetNWInt("SelfOffsetY",99)) + Vector(
			(ship:GetPos().x / aura_lfs_fight_displaymult),
			(ship:GetPos().y / aura_lfs_fight_displaymult), 
			(ship:GetPos().z / aura_lfs_fight_displaymult)), ang , .1)
        	draw.SimpleTextOutlined(ent.aura_radar_name or "", "LFSFightDisplayFont", 0, 4, white_color_faded, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1.25, color_black)
        cam.End3D2D()
	end

	-- We want to know what name to use for the entities on our table, as well as the colors involved in them
	function Aura_LVS_Radar_Determine_Entity_Name_And_Color(sp, ent)
		local ply = LocalPlayer()
		local original_entity = sp.original_ent
		sp.aura_radar_name = ""
		if (original_entity and IsValid(original_entity)) then
			if (original_entity.LFS or original_entity.LVS) then
				if (original_entity:GetAITEAM() == ent:GetAITEAM()) then
	    			if (original_entity.GetDriver and IsValid(original_entity:GetDriver())) then
	    				sp.aura_radar_name = original_entity:GetDriver():Nick()
	    			else
	    				sp.aura_radar_name = "AI"
	    			end
		    		sp.aura_radar_color = friendly_color
		    	else
		    		if (ply.canSeeLFSNames) then
		    			sp.aura_radar_name = "Hostile"
		    		end
		    		sp.aura_radar_color = enemy_color
		    	end
		    	if (original_entity:GetAI() != nil and original_entity:GetAI() == false) then
					sp.aura_radar_name = ""
				end
		    	return
		    end
	    	if (original_entity.IsSWVehicle) then
	    		if (((original_entity.Allegiance == "Republic" or original_entity.Allegiance == "Rebels" or original_entity.Allegiance == nil) and ent:GetAITEAM() == 2) or ((original_entity.Allegiance == "CIS" or original_entity.Allegiance == "Empire") and ent:GetAITEAM() == 1) ) then
	    			if (original_entity:GetDriver() and (original_entity:GetDriver() != nil and original_entity:GetDriver():IsValid()) and original_entity:GetDriver():IsPlayer()) then
	    				original_entity.aura_radar_name = original_entity:GetDriver():Nick()
	    			else
	    				sp.aura_radar_name = "AI"
	    				if (original_entity:GetAI() != nil and original_entity:GetAI() == false) then
	    					sp.aura_radar_name = ""
	    				end
	    			end
	    			if (original_entity.pilot and original_entity.Pilot:IsPlayer()) then
	    				sp.aura_radar_name = original_entity.pilot:Nick()
	    			end
		    		sp.aura_radar_color = friendly_color
		    	else
		    		if (ply.canSeeLFSNames) then
		    			sp.aura_radar_name = "Hostile"
		    		end
		    		sp.aura_radar_color = enemy_color
		    	end
		    	return
	    	end
	    	if (original_entity:IsPlayer()) then
	    		sp.aura_radar_name = original_entity:Nick()
	    		sp.aura_radar_color = friendly_color
	    		return
	    	end
			if (original_entity:IsNPC()) then
				
				if (original_entity.PlayerFriendly == nil) then
					net.Start("Aura_LVS_Radar_Check_Friendly")
					net.WriteEntity(original_entity)
					net.SendToServer()
					net.Receive("Aura_LVS_Radar_Check_Friendly", function()
						sp.aura_radar_color = feeling_colors[net.ReadUInt(3) or 0]
					end)
				end
				local friendly = original_entity.PlayerFriendly
				if (friendly) then
					sp.aura_radar_color = friendly_color_ply
				else
					sp.aura_radar_color = enemy_color_ply
				end
				return
			end
	    end
	end

	-- Create the small holographic entity for the table
	function AuraLVSRadarCreateEntityModel(ship, table_ent)
		table_ent.aura_radar_models = table_ent.aura_radar_models or {}
		table_ent.aura_radar_loaded_entities = table_ent.aura_radar_loaded_entities or {}

		local shipProp = nil

		local model = ship:GetModel()
		if (ship:GetClass() == "aura_acclamator_spawner_ai") then
			model = "models/acclamator/syphadias/acclamator.mdl"
		end
		if (ship:GetClass() == "aura_munificent_spawner_ai") then
			model = "models/munificent/syphadias/munificent.mdl"
		end
		shipProp = ClientsideModel( "models/error.mdl", RENDERGROUP_TRANSLUCENT )
		shipProp:SetModel(model)
		shipProp.aura_radar_prop = true
		shipProp.original_ent = ship
		shipProp.table_ent = table_ent
		shipProp:Spawn()
		shipProp:SetModelScale((1 / (aura_lfs_fight_displaymapAspect - 100)) * ship:GetModelScale() * .65)
		shipProp:SetCollisionGroup(10)
		shipProp:SetLOD(8)
		shipProp:SetMaterial(table_ent:GetHologramMaterial() or "ace/sw/hologram")
		shipProp:SetRenderMode( RENDERMODE_TRANSALPHA )
		table.insert(aura_lvs_radar_entity_models, shipProp)
		table.insert(table_ent.aura_radar_models,shipProp)
		table.insert(table_ent.aura_radar_loaded_entities,ship)
		shipProp.aura_radar_color = table.Copy(color_white)
		shipProp.aura_radar_name = ""
	end

	function AuraLVSRadarUpdateEntityModel(shipProp, table_ent)
		local ship = shipProp.original_ent
    	local ang = ship:GetAngles()
		local placeVec = (table_ent:GetPos() + Vector(0,0,table_ent:GetNWInt("SelfOffsetY",99)) + Vector(
		(ship:GetPos().x / aura_lfs_fight_displaymult),
		(ship:GetPos().y / aura_lfs_fight_displaymult), 
		(ship:GetPos().z / aura_lfs_fight_displaymult)))
		if (ship.LFS or ship.LVS) then
			shipProp.aura_radar_color.a = ((ship:GetHP() / ship:GetMaxHP() ) * 255)
		elseif (ship.IsSWVehicle) then
			shipProp.aura_radar_color.a = ((ship:GetNWInt("Health",0) / ship.StartHealth ) * 255)
		elseif (ship.lfsRepairDroid) then
			shipProp.aura_radar_color.a = ((ship:GetParent():GetHP() / ship:GetParent():GetMaxHP() ) * 255)
			shipProp:SetModelScale((1 / (aura_lfs_fight_displaymapAspect - 100)) * ship:GetModelScale() * 2)
			ang = ship:GetParent():GetAngles()
		elseif (ship:IsPlayer() or ship:IsNPC()) then
			shipProp.aura_radar_color.a = ((ship:Health() / ship:GetMaxHealth() ) * 255)
			shipProp:SetModelScale((1 / (aura_lfs_fight_displaymapAspect - 100)) * ship:GetModelScale() * 2)
			ang.z = 0
			ang.x = 0
			shipProp:SetSequence(ship:GetSequence())
		end
		shipProp:SetColor(shipProp.aura_radar_color)
		shipProp:SetPos(placeVec)
		shipProp:SetAngles(ang)
	end
end
--addons/auralvsradar/lua/aura_lvs_radar/aura_lvs_radar_hooks.lua:
if (SERVER) then
	-- Print our server config has initialized
	hook.Add("Initialize","Aura_Fight_Radar_Init_Server",function()
		timer.Simple(3, function()
			print("---------------------------------------")
			print("Aura LFS fighting display server initalized")
			print("---------------------------------------")
		end)
	end)
end

if (CLIENT) then
	local allEnts = {}
	local viewDist = 90000
	local update = 0
	local updateTime = 2
	local position_updates_per_second = 40
	local update_ship_names = CurTime() + updateTime
	local update_ships_total = CurTime() + 1/position_updates_per_second

	-- Set up some map related variables for sizing on initialization of entities
	hook.Add("InitPostEntity", "Aura_Fight_Radar_Init_Client", function()
		AuraRadarGenerateMapScalar()
			-- Create our fonts
		surface.CreateFont( "LFSFightDisplayFont", {
			    font = "roboto",
			    italic = true,
			    size = 8 * (ScrW() / 1920),
			    weight = 500 * (ScrW() / 1920),
			    antialias = true,
		} )

		surface.CreateFont( "LFSFightDisplayFont2", {
			    font = "roboto",
			    size = 50 * (ScrW() / 1920),
			    weight = 1000 * (ScrW() / 1920),
			    antialias = true,
		} )
		print("---------------------------------------")
		print("Aura LFS fighting display client initalized")
		print("---------------------------------------")
	end)

	hook.Add( "OnEntityCreated", "Aura_LVS_Radar_Entity_Create", function( ent )
		timer.Simple(.1, function()
			if (!IsValid(ent)) then return end
			if (ent:GetClass() == "aura_lfs_fight_display_panel") then
				-- Grab a list of all the table entities around the map
				ent.aura_radar_models = ent.aura_radar_models or {}
				ent.aura_radar_loaded_entities = ent.aura_radar_loaded_entities or {}
				aura_lfs_fight_display_ent_list = ents.FindByClass("aura_lfs_fight_display_panel")
				return
			end
		end)
	end)

	-- The meat of our scanning for entities to add
	-- CHANGE -- MAKE MORE EFFICIENT GOOD LORD, TOO MANY LOOPS AND CONDITIONALS
	hook.Add("Think","Aura_LVS_Radar_Update_Ship_Table", function()
		if (#aura_lfs_fight_display_ent_list == 0) then
			return
		end

		-- Update the table color to oscilate synchronously
		aura_lvs_radar_table_color.a = math.abs(math.sin(CurTime())) * 255

		-- We DO NOT want this to run every frame, so lets do that every few seconds (2 in this case)
		if (update < CurTime()) then
			local ply = LocalPlayer()

			if (!aura_lfs_fight_displaymult) then
				AuraRadarGenerateMapScalar()
			end

			local temp_remove = {}

			for k,v in ipairs(aura_lfs_fight_display_ent_list) do
				if (!IsValid(v)) then
					table.insert(temp_remove, k)
					continue
				end
				Aura_LVS_Radar_Calculate_Table_Values(v)
				if (v:GetNWBool("Powered",false) and v:GetPos():DistToSqr(ply:GetPos()) < viewDist) then
					for i=1,#v.aura_radar_models do
						sp = v.aura_radar_models[i]
						if (IsValid(sp)) then
							Aura_LVS_Radar_Determine_Entity_Name_And_Color(sp, v)
						end
					end
				else
					for i=1,#v.aura_radar_models do
						local sp = v.aura_radar_models[i]
						Aura_Radar_Remove_Model(v, sp)
					end
					v.aura_radar_loaded_entities = {}
				end
			end

			for i=1,#temp_remove do
				table.remove(aura_lfs_fight_display_ent_list,temp_remove[i])
			end

			local ents = ents.GetAll()
			for k,v in ipairs(ents) do
				if (AuraRadarShouldAddEntityToTable(v) and !table.HasValue(aura_lfs_fight_display_ship_list, v)) then
					table.insert(aura_lfs_fight_display_ship_list, v)
					continue
				end
			end


			temp_remove = {}
			for k,v in pairs(aura_lfs_fight_display_ship_list) do
				if (!IsValid(v) or !v) then
					table.insert(temp_remove, k)
					continue
				end
				for l,n in ipairs(aura_lfs_fight_display_ent_list) do
					if (!table.HasValue(n.aura_radar_loaded_entities,v)) then
						AuraLVSRadarCreateEntityModel(v,n)
					end
				end
			end

			for i=1,#temp_remove do
				table.remove(aura_lfs_fight_display_ship_list,temp_remove[i])
			end

			temp_remove = {}
			for k,v in pairs(aura_lvs_radar_entity_models) do
				if (!IsValid(v.table_ent)) then
					table.insert(temp_remove, k)
					Aura_Radar_Remove_Model(nil, v)
				end
			end

			for i=1,#temp_remove do
				table.remove(aura_lvs_radar_entity_models,temp_remove[i])
			end

			update = CurTime() + updateTime
		end
	end)

	hook.Add("PostDrawOpaqueRenderables", "Aura_LVS_Radar_Entity_Draw", function()
		-- Should try and implement a check to NOT run any rendering or even scanning of entities if the player is not close enough to the table, since this is all clientside
		if (#aura_lfs_fight_display_ent_list == 0) then
			return
		end
		local ply = LocalPlayer()
		local plyAng = ply:GetAngles()
		local ang = Angle(0, plyAng.y - 180, 0)
		ang = Angle(0, plyAng.y - 180, 0)
    	ang:RotateAroundAxis(ang:Forward(), 90)
    	ang:RotateAroundAxis(ang:Right(), -90)
    	local update_pos = false

		-- We only want to update positions so many times a second so that we can preserve performance
		if (update_ships_total < CurTime()) then
			update_pos = true
			update_ships_total = CurTime() + 1/position_updates_per_second
		end

		-- Loop through our table list
		for k,v in ipairs(aura_lfs_fight_display_ent_list) do
			if (IsValid(v)) then
				if (v:GetNWBool("Powered",false) and v:GetPos():DistToSqr(ply:GetPos()) < viewDist) then
		        	Aura_LVS_Radar_Draw_Table_On_Self(v)
		        	Aura_LVS_Radar_Draw_Holo_Overlay(v)
		        	if (update_pos) then
				        for i=1,#v.aura_radar_models do
							local sp = v.aura_radar_models[i]
							if (sp and sp.original_ent) then
								local should_draw = AuraRadarShouldDrawEntity(v, sp.original_ent)
								if (!should_draw) then
									table.RemoveByValue(v.aura_radar_loaded_entities, sp.original_ent)
									Aura_Radar_Remove_Model(v, sp)
									continue
								end
								if (should_draw) then
									AuraLVSRadarUpdateEntityModel(sp, v)
									continue
								end
							end
						end
				    end
			        if (ply.canSeeLFSNames and v.aura_radar_models) then
				        for i=1,#v.aura_radar_models do
							sp = v.aura_radar_models[i]
							if (IsValid(sp) and IsValid(sp.original_ent)) then
								Aura_LVS_Radar_Draw_Entity_Names(v, sp, ang)
							end
						end
					end
		        end
			end
		end
	end)
end
--addons/sh_lounge_chatbox/lua/chatbox_markups.lua:
/**
* Markups Permissions configuration
**/

-- Here you can decide who is allowed to use a specific markup/parser.
-- If a markup isn't in the list below, then it'll be usable by anyone.
-- The server can use any markup available.
LOUNGE_CHAT.MarkupsPermissions = {
	// Only the "respected", "admin" and "superadmin" usergroups can use flash, rainbow and glow parsers.
	["flash"] = {
		usergroups = {"respected", "admin", "superadmin"},
		-- steamids = {"STEAM_0:1:8039869", "76561197976345467"},
	},
	["rainbow"] = {
		usergroups = {"respected", "admin", "superadmin"},
		-- steamids = {"STEAM_0:1:8039869", "76561197976345467"},
	},
	["glow"] = {
		usergroups = {"respected", "admin", "superadmin"},
		-- steamids = {"STEAM_0:1:8039869", "76561197976345467"},
	},

	// Only those of "admin" and "superadmin" usergroups can send external images, avatars of other players and named URLs.
	["external image"] = {
		usergroups = {"admin", "superadmin"},
		-- steamids = {"STEAM_0:1:8039869", "76561197976345467"},
	},
	["avatar other"] = {
		usergroups = {"admin", "superadmin"},
		-- steamids = {"STEAM_0:1:8039869", "76561197976345467"},
	},
	["named url"] = {
		usergroups = {"admin", "superadmin"},
		-- steamids = {"STEAM_0:1:8039869", "76561197976345467"},
	},

	// No one except the author (it's an example) should be allowed to use line breaks.
	["line break"] = {
		usergroups = {"admin", "superadmin"},
		steamids = {"STEAM_0:1:8039869", "76561197976345467"},
	},

	// No one should be allowed to use lua buttons. It's internal.
	["lua"] = {
	},
}
--lua/autorun/bric.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Bric",		"models/player/tiki/bric.mdl" )

--lua/autorun/capybara2.lua:
player_manager.AddValidModel( "Capybara2", "models/TSBB/Animals/Capybara2.mdl")
list.Set( "PlayerOptionsModel", "Capybara2", "models/TSBB/Animals/Capybara2.mdl")

--addons/gm_express_binding/lua/gm_express_bindings/p2m/sh_init.lua:
AddCSLuaFile()

local Module = { default = true }

if SERVER then
    AddCSLuaFile( "cl_init.lua" )
    include( "sv_init.lua" )( Module )
else
    include( "cl_init.lua" )( Module )
end

function Module:IsValid()
    return prop2mesh ~= nil
end

ExpressBindings.RegisterModule( "p2m", Module )

--addons/aocrp_map/lua/autorun/gmaps.lua:

gmaps = gmaps or {}
gmaps.Config = gmaps.Config or {}

include("sh_gmaps_config.lua")
include("gmaps/sh_gmaps.lua")

if SERVER then
	AddCSLuaFile()
	AddCSLuaFile("sh_gmaps_config.lua")
	AddCSLuaFile("gmaps/sh_gmaps.lua")
	AddCSLuaFile("gmaps/cl_gmaps.lua")
	AddCSLuaFile("gmaps/cl_dmap.lua")
	AddCSLuaFile("gmaps/cl_zslider.lua")
	AddCSLuaFile("gmaps/cl_dpoiinfo.lua")
	AddCSLuaFile("gmaps/cl_dpoieditor.lua")
	AddCSLuaFile("gmaps/cl_dallpoi.lua")
	AddCSLuaFile("gmaps/cl_dgmapsicons.lua")
	AddCSLuaFile("gmaps/cl_dgmapssettings.lua")
	
	include("gmaps/sv_gmaps.lua")
else
	include("gmaps/cl_zslider.lua")
	include("gmaps/cl_dpoiinfo.lua")
	include("gmaps/cl_dpoieditor.lua")
	include("gmaps/cl_dgmapsicons.lua")
	include("gmaps/cl_dallpoi.lua")
	include("gmaps/cl_dmap.lua")
	include("gmaps/cl_dgmapssettings.lua")
	include("gmaps/cl_gmaps.lua")
end

--addons/aocrp_map/lua/sh_gmaps_config.lua:

--[[
PLEASE READ THE FOLLOWING ABOUT NAVMESHES BEFORE ASKING FOR SUPPORT.

To install, place the 'gmaps' folder in your addons folder.

In order for GMaps to use the GPS navigation feature, you'll need to create a navmesh for your map.
Run sv_cheats 1 in the console, then spawn a Navmesh Editing SWEP from the spawnmenu and right click to get started.
I strongly recommend completing this process in a singleplayer sandbox game and transferring the navmesh file to your server once you're finished.

If you're using one of the prepackaged navmeshes, please place it in GarrysModDS/garrysmod/maps/nav_mesh.nav

Here's some important tips while creating your navmesh:

	Try to do all your navmesh editing in singleplayer, especially generating a new one.
	
	Mark all roads as avoid, then create crosswalk areas using the splitting tool and unmark them.
	
	If your console says "No valid walkable seed positions.  Cannot generate Navigation Mesh." when generating a navmesh, walk to a place on the ground and run 'nav_mark_walkable' in the console, then try again.
	
	Set 'nav_split_place_on_ground 1' to create sloped nav areas.
	
	Use 'nav_begin_drag_selecting' and 'nav_end_drag_selecting' to select large groups of nav areas. Then use a one-click nav tool to take that action, such as the delete tool.
	
	Use the splice tool to easily correct misgenerated stairs. You can run 'nav_check_stairs' to update stair status without having to reload.
	
	The max navarea size is {{ user_id | 76561198006484623}} units. Make sure any nav areas you create are smaller than this.
	
	For your final save, set 'nav_quicksave 0' to make sure everything compiles correctly.
	
	For more info, see this page: https://developer.valvesoftware.com/wiki/Navigation_Meshes
	
	
"Thank you for using GMaps! Enjoy!" ~Bobblehead
]]

gmaps.Config.MaxZoom = 30000 	--distance users can zoom out.
gmaps.Config.MinZoom = 150		--Max distance users can zoom in.

gmaps.Config.POISize = 48		--Size of POI's on the map.
gmaps.Config.POIInfoWidth = 250	--Width of POI's info popups. Larger means more room for big descriptions. Height is relative to this. 
gmaps.Config.AlwaysShowLabels = false	--Whether to always show the labels for POI's in the map.

gmaps.Config.NavArrowSize = 20		--Size of 3D2D navigation arrows in the game world.
gmaps.Config.NavFlagSize = 20		--Size of 3D2D navigation goal waypoint flag in the game world.
gmaps.Config.NavGoalTolerance = 100 --How far you must be from the goal waypoint before the navigation is finished.
gmaps.Config.RoadAvoidWeight = 1.3	--How hardcore the navigation will attempt to avoid roads while walking. 0 means it will not differentiate between roads and sidewalk.
gmaps.Config.SidewalkAvoidWeight = 2 --How hardcore the navigation will attempt to stay on roads while in a vehicle. 0 means it will not differentiate between roads and sidewalk.

gmaps.Config.ChatCommand = "/gmaps"			--Chat command to open GMaps
gmaps.Config.ConsoleCommand = "gmaps_open"	--Console command to open GMaps
gmaps.Config.DefaultKey = KEY_NONE 		--Bound to M by default. Customized per-player. List is here: http://wiki.garrysmod.com/page/Enums/KEY
gmaps.Config.DefaultCorner = 1 --1 is top right, 2 is top left, 3 is bottom left, 4 is bottom right. Users can change this themselves but this is the default.

gmaps.Config.POILimitMessage = "Donate now to increase this limit!"	--Message to show players who hit their public POI limit.

gmaps.Config.UseWorkshop = true	--Whether to use the Garry's Mod workshop for downloads; false means use fastdl.

gmaps.Config.LinuxMode = true --Whether the server is on a Linux box. 

--The following is a list of limits for each usergroup. You can add your own usergroups. If you use ULX it will check inheritance.
gmaps.Config.Limits = {
	
	--How many Public POI's a user can make. Public means visible to more than just the owner. -1 means no limit. 0 means none allowed.
	PublicPOI = {
		["user"] = 3,
		["donator"] = 5,
		["admin"] = -1
	},
	
	--How fast to update the navigation path for different usergroups. 1 means 1 second of delay per update.
	--Decreasing these numbers can significantly reduce performance. Calculating and sending the route is a long process.
	NavUpdateRate = { 
		["user"] = 10,
		["donator"] = 5
	},
}
--These permissions follow the ULX inheritance chain, if ULX is installed.
gmaps.Config.Permissions = {
	MakePOI = "user",				--Who can create POI's at all.
	MakeVIPIconPOI = "donator",		--Who can use VIP icons (see below for the list.)
	
	MakeCustomIconPOI = "admin",	--Who can create a POI using a custom path for the icon.
	MakePermanentPOI = "admin",		--Who can make a permanent POI which persists across server retarts.
	
	DeletePermanentPOI = "admin",	--Who can delete permanent POI's
	DeleteOtherPOI = "admin",		--Who can delete OTHER user's POI's
	
	ViewPrivatePOI = "admin",		--Who can view otherwise private POI's in the "All POI's" menu.
	
}

--This list determines which icons are available for use for free and VIP tiers (see above for permissions).
gmaps.Config.Icons={
	Free ={	--Add files here to make them usable by any user.
		"materials/gmaps/poi/poi.png",
		"materials/gmaps/poi/poi_dollarsign.png",
		"materials/gmaps/poi/poi_home.png",
		"materials/gmaps/poi/poi_police.png",
	},
	VIP ={	--Add files here to make them usable by VIP users, as defined in the permissions list.
		"materials/gmaps/poi/poi_bandaid.png",
		"materials/gmaps/poi/poi_biohazard.png",
		"materials/gmaps/poi/poi_cards.png",
		"materials/gmaps/poi/poi_cart.png",
		"materials/gmaps/poi/poi_flag.png",
		"materials/gmaps/poi/poi_food.png",
		"materials/gmaps/poi/poi_grenade.png",
		"materials/gmaps/poi/poi_gun.png",
		"materials/gmaps/poi/poi_leaf.png",
		"materials/gmaps/poi/poi_movie.png",
		"materials/gmaps/poi/poi_nuke.png",
		"materials/gmaps/poi/poi_office.png",
		"materials/gmaps/poi/poi_skull.png",
		"materials/gmaps/poi/poi_star.png",
		"materials/gmaps/poi/poi_target.png",
		"materials/gmaps/poi/poi_warning.png",
		"materials/gmaps/poi/poi_weed.png"
	}
}

--Here you can add maps and POI's manually. This is entirely optional, as it is usually generated automatically
--However, if you have issues with the Z-Slider on the map you can manually configure it here.
gmaps.Config.Maps = {
	
	rp_downtown_v2 = {
		--These are the floor and ceiling of the map for Z-Slider purposes.
		--To find these, noclip to the highest and lowest points of your map and type 'getpos' in the console.
		--It will print some numbers. The third number is your Z position; copy it and paste it here.
		minz = -887,
		maxz = 612,
		
		--Set to false if you DON'T have a navmesh for the map. This disables navigation.
		nav = true,
		
		--Any permanent POI's created in-game are saved as data/gmaps/poi/map_name/poi-name.txt
		--This list is separate. Items from this list can not be deleted in-game by any user (regardless of permissions).
		POI = {
			-- ["Police Station"]={
				-- pos= Vector(-1436.968750,117.0,-131.968750), --use 'getpos' in console to find this position.
				-- icon= "materials/gmaps/poi/poi_police.png",
				-- desc= "The heart of the police force in the city.",
				-- color= Color(0,115,246), --red, green, blue
				-- privacy= { TEAM_COP, TEAM_CHIEF, TEAM_MAYOR } --a list of teams, or 'false' for public.
			-- },
		},
	},
	
	--Add more maps below this line:--
	
	
	
}

--This hook lets you decide whether a POI is suitable.
--It's only run on the server after receiving a POI from a player.
--Return a string and one of NOTIFY_GENERIC, NOTIFY_HINT, NOTIFY_ERROR to override default checks.
--The string is used as the message displayed to the player, and if you use NOTIFY_ERROR then it will not create the POI.
hook.Add("PlayerCanCreatePOI","GMaps_Config",function(ply,poi)

	--Example:
	if (false) then
		return "This is not suitable!", NOTIFY_ERROR 
	end
end)

--Whether to allow expletive words to be used in titles/descriptions for POI's.
gmaps.Config.AllowBadWords = true

--This list is only used if gmaps.Config.AllowBadWords is set to false. You can add or remove words below:
gmaps.Config.BannedWords = {
	"4r5e",
	"5h1t",
	"5hit",
	"a55",
	"anal",
	"anus",
	"ar5e",
	"arrse",
	"arse",
	"ass",
	"a_s_s",
	"b!tch",
	"b17ch",
	"b1tch",
	"bastard",
	"bi+ch",
	"biatch",
	"bitch",
	"butt",
	"c0ck",
	"c0cksucker",
	"cawk",
	"chink",
	"cipa",
	"cnut",
	"cock",
	"cok",
	"coon",
	"crap",
	"cum",
	"cunt",
	"d1ck",
	"damn",
	"dick",
	"dink",
	"dlck",
	"doosh",
	"douche",
	"duche",
	"dyke",
	"f u c k",
	"f u c k e r",
	"fag",
	"fcuk",
	"feck",
	"fook",
	"fuck",
	"fudge packer",
	"fudgepacker",
	"fuk",
	"fux",
	"f_u_c_k",
	"hell",
	"hoar",
	"hoer",
	"homo",
	"hore",
	"jizz",
	"kawk",
	"kock",
	"kunilingus",
	"l3i+ch",
	"l3itch",
	"lmao",
	"lmfao",
	"m0f0",
	"m0fo",
	"mo-fo",
	"mof0",
	"mofo",
	"negro",
	"n1gga",
	"n1gger",
	"nigg3r",
	"nigg4h",
	"nigga",
	"nigger",
	"phuck",
	"phuk",
	"phuq",
	"piss",
	"puss",
	"pen is",
	"penis",
	"retard",
	"sh!+",
	"sh!t",
	"sh1t",
	"shi+",
	"shit",
	"skank",
	"slut",
	"s_h_i_t",
	"tw4t",
	"twat",
	"wang",
	"whoar",
	"whore"
}

--addons/billy_gas_logging/lua/gmodadminsuite/modules/logging/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Billy's Logs",

		--####################### UI PHRASES #######################--

		no_data                     = "Aucune donnée",
		add_to_evidence_box         = "Ajouter à la boite à preuves",
		livelogs_show_logs_for      = "Afficher les Logs pour",
		background_color            = "Couleur d'Arrière Plan",
		health_abbrieviated         = "%d PV",
		livelogs                    = "Logs en Direct",
		exit_deep_storage           = "Quitter le Stockage Interne",
		log_formatting              = "Formattage des Logs",
		strings                     = "Variables",
		when                        = "Quand",
		copy_log                    = "Copier Log",
		evidence_box                = "Boite à Preuves",
		livelogs_position_x         = "Position X (pixels)",
		width                       = "Largeur",
		color                       = "Couleur",
		help                        = "Aide",
		live_log_antispam           = "< journal en direct supprimé pour antispam >",
		settings                    = "Paramètres",
		loading_ellipsis            = "Chargement...",
		livelogs_enabled            = "Activer les logs en temps réel",
		armor_abbrieviated          = "%d ARM",
		deep_storage                = "Stockage Interne",
		all_logs                    = "Tous les logs",
		logs                        = "Logs",
		padding                     = "Bordure (pixels)",
		livelogs_position_y         = "Position Y (pixels)",
		livelogs_rows_help          = "Quel est le nombre maximal de logs devant être affichés ?",
		livelogs_rows               = "Rangées (Nombre de Logs)",
		livelogs_color_help         = "Les logs doivent-ils être affichés en couleur ?",
		export_to_clipboard         = "Exporter vers le Presse-Papier",
		players                     = "Joueurs",
		script_page                 = "Page de Script",
		wiki                        = "Wiki",
		module                      = "Module",
		modules                     = "Modules",
		localization                = "Localisation",
		view_deep_storage           = "Afficher Stockage Interne",
		copied                      = "Copié !",
		operator                    = "Opérateur",
		log                         = "Log",
		reset_to_defaults           = "Réinitialiser",
		livelogs_show_logs_for_help = "Combien de secondes les logs doivent-ils être affichés ?\nMettez 0 pour toujours.",
		advanced_search             = "Recherche Avancée",
		quick_search                = "Recherche Rapide",
		quick_search_ellipsis       = "Recherche Rapide...",
		entities                    = "Entitées",
		tutorial                    = "Tutoriel",
		clear_filters               = "Nettoyer Filtre",
		no_results_found            = "Aucun résultat trouvé",
		add_player                  = "+ Ajouter Joueur",
		add_module                  = "+ Ajouter Module",
		add_entity                  = "+ Ajouter Entitée",
		add_string                  = "+ Ajouter Variable",
		modules_search_tooltip      = "Quel(s) module(s) souhaitez-vous inclure ? (laissez blanc pour aucun module)",
		players_search_tooltip      = "Quel(s) joueur(s) cherchez-vous ? (laissez blanc pour n'importe quel joueur)",
		entities_search_tooltip     = "Quelle entitée(s) cherchez-vous ? (SWEPs, SENTs, véhicule, props, classes, etc.)",
		strings_search_tooltip      = "Recherchez-vous un texte spécifique ?",
		class_name_ellipsis         = "Nom de la classe...",
		add_string_popup_title      = "Ajouter Variable",
		add_string_popup_text       = "Entrez le texte que vous essayez de trouver.",
		text_ellipsis               = "Texte...",
		click_to_focus              = "Cliquez pour obtenir le focus",
		right_click_to_focus        = "Clic droit pour obtenir le focus",
		highlight_color             = "Couleur de surlignage",
		weapon_color                = "Couleur d'Armes",
		money_color                 = "Couleur d'Argent",
		vehicle_color               = "Couleur de Véhicules",
		entity_color                = "Couleur d'Entitées",
		health_color                = "Couleur de Santé",
		armor_color                 = "Couleur d'Armure",
		usergroup_color             = "Couleur de Grade",
		unavailable_color           = "Couleur Indisponible/Inconnue",
		learn_more                  = "En savoir plus",
		player_combats              = "Combats de joueurs",
		took_damage                 = "[a pris %d dgts]",
		jump_to_pvp_event           = "Sauter à l'évènement PvP",
		remove                      = "Retirer",
		greedy                      = "Gourmande",
		greedy_tip                  = "Si votre recherche est conséquente, le système tentera de faire correspondre le plus de logs possible. Si elle n'est pas conséquente, il tentera de faire correspondre le moins de logs possible.",
		log_colouring               = "Coloration des Logs",
		done_exclamation            = "Terminé !",
		module_settings             = "Paramètres des Modules",
		storage_settings            = "Paramètres du Stockage",
		third_party_addons          = "Addons Tiers",
		pvp_settings                = "Système de Log PvP",
		live_logs_settings          = "Paramètres de Logs en Direct",
		logging_settings            = "Paramètres de Logs",
		settings                    = "Paramètres",
		enabled_modules             = "Modules Activés",
		permissions                 = "Permissions",
		gamemode_modules            = "Modules de Mode de Jeu",
		saved_exclamation           = "Sauvegardé !",
		save_settings               = "Sauvegarder Paramètres",
		weapon_class                = "Classe d'Arme",
		enter_weapon_class          = "Entrez la classe de l'arme.\nVous ne la connaissez-pas ? Ouvrez votre menu de spawn, cliquez-droit sur une arme et séléctionnez \"Copy to clipboard\"",
		save                        = "Sauvegarder",
		add_new                     = "+ Ajouter Nouveau",
		enabled                     = "Activé",
		website                     = "Site Web",
		name                        = "Nom",
		usergroups                  = "Groupes d'Utilisateurs",
		everyone                    = "Tout le Monde",
		all_modules                 = "Tout les modules",
		all_teams                   = "Toutes les équipes",
		add_usergroup               = "Ajouter Groupe d'Utilisateurs",
		cl_sv_tooltip               = [[cl réprésente le temps nécéssaire à votre ordinateur pour demander les logs, les recevoir, les lire et les afficher
		
		sv réprésente le temps nécéssaire au serveur pour récupérer les logs depuis la mémoire/la base de données, les lires et vous les envoyer

		Les serveurs utilisant MySQL auront une valeur sv supérieur en fonction de la latence entre le serveur MySQL et Garry's Mod]],
		deep_storage_help           = [[Le Stockage Interne est une fonctionnalité de bLogs qui améliore les performances en stockant les logs des sessions serveurs précédentes séparément de la session actuelle.

		Après avoir cliqué sur "Afficher Stockage Interne", vous verrez seulement les logs des sessions serveurs précédentes.
		Vous pouvez voir les logs de la session actuelle en cliquant sur le bouton ci-dessus de nouveau, ou en réouvrant le menu.

		NOTE: Les logs de dégats ne sont pas inclus dans le stockage interne et sont supprimés à chaque redémarrage du serveur pour économiser de l'espace disque]],

		class_type_other = "Autres",
		class_type_player = "Joueur",
		class_type_team = "Equipe",
		class_type_weapon = "Arme",
		class_type_vehicle = "Véhicule",
		class_type_usergroup = "Groupe d'Utilisateur",
		class_type_prop = "Prop",
		class_type_ragdoll = "Ragdoll",
		class_type_country = "Pays",
		class_type_ammo = "Munition",
		class_type_role = "Rôle",
		class_selector = "Sélecteur de classe",
		custom_class = "Classe Personnalisée",
		class_type = "Type de Classe",
		value = "Valeur",
		search = "Rechercher",
		check_all = "Tout Cocher",
		uncheck_all = "Tout Décocher",
		general = "Général",
		class_search_title = "Recherche de classe",
		class_search_text = "Entrez le nom ou une partie du nom de la classe que vous cherchez (insensibles aux majuscules/minuscules)",
		view_logs = "Voir Logs",
		open_menu = "Ouvrir Menu",
		licensed_to = "License accordée à %s",

		--####################### SETTINGS #######################--

		Player_RecordTeam = "Afficher l'équipe du joueur dans les logs",
		Player_RecordUsergroup = "Afficher le grade du joueur dans les logs",
		Player_RecordHealth = "Afficher la santé du joueur dans les logs",
		Player_RecordArmor = "Afficher l'armure du joueur dans les logs",
		Player_RecordWeapon = "Afficher l'arme du joueur dans les logs",
		Player_RecordWeapon_DoNotRecord = "Filtre d'arme du joueur",
		Player_RecordWeapon_DoNotRecord_help = "Si vous souhaitez afficher les armes des joueurs dans les logs, utilisez cette option pour filtrer les armes non-désirées (comme le physgun, toolgun, etc.)",

		OverrideMoneyFormat = "Outrepasser le formatage de l'argent par défaut",
		OverrideMoneyFormat_help = "Lorsque désactivé, le formattage de l'argent du mode de jeu sera utilisé.\nLorsque activé, vous pouvez utiliser l'option ci-dessous pour créer votre propre formattage de l'argent.",
		MoneyFormat = "Formattage de l'Argent",
		MoneyFormat_help = "Entrez la façon dont vous souhaitez que l'argent apparaisse et insérez \"%s\" (sans guillemts) à l'endroit ou vous souhaitez voir l'argent affiché.",

		MaxSessionLogs = "Logs de session max",
		MaxSessionLogs_help = "Combien de logs de la session actuelle peuvent être affichées avant de déplacer toutes les logs dans le stockage interne ? (économies de performances)\nDéfinissez sur 0 pour infini ((Déconseillée)).",

		DeepStorageTooOld = "Age max des logs du stockage interne",
		DeepStorageTooOld_help = "Combien de jours souhaitez-vous conserver les logs dans le stockage interne avant de les supprimer? (économise l'espace disque)\nDéfinissez sur 0 pour ne jamais supprimer les logs dans le stockage interne (Déconseillée).",

		LiveLogsEnabled = "Logs en Direct Activées",
		LiveLogsEnabled_help = "Les logs en direct peuvent nuire aux performances sur les gros serveurs; vous pouvez complètement désactiver cette fonctionnalité ici.",
		LiveLogsIn10Seconds = "Logs en Direct max en 10 secondes",
		LiveLogsIn10Seconds_help = "Combien de logs en direct peuvent être envoyées avant que les logs supplémentaires ne soient supprimées par l'antispam ?",
		NotifyLiveLogsAntispam = "Notifier Antispam",
		NotifyLiveLogsAntispam_help = "Les utilisateurs doivent-ils être notifiés qu'un log en direct à été supprimée par l'antispam ?",

		TimeBetweenPvPEvents = "Temps entre les évènements PvP",
		TimeBetweenPvPEvents_help = "Quant un joueur commence à se battre, il crée un \"Evènement PvP\", quand aucun combat supplémentaire n'a eu lieu dans un certain nombre de secondes, l'évènement PvP est défini comme terminé et est envoyé aux logs. Combien de secondes bLogs doit attendre avant de faire cela ?",
		NonPvPWeapons = "Filtre des Armes PvP",
		NonPvPWeapons_help = "Quelles armes ne doivent pas être considérées comme des armes PvP ?",

		server_restart_required = "NOTE: Les modification effectuées ici ne prendront effets qu'après un redémarrage du serveur.",

		gamemode_modules_tip = [[bLogs supporte un grand nombre de modes de jeu.
		Cependant, il peut arriver que bLogs ait des problèmes à détecter le mode de jeu utilisé sur votre serveur.
		Sur cet écran, vous pouvez forcer bLogs à détecter un certain mode de jeu.

		Décoché = Comportement par défaut
		Coché = Activation Forcée
		Coché avec une croix = Désactivé

		Veuillez noter que certains modes de jeu sont des dérivation du Sandbox, cela signifie qu'ils utilisent certaines fonctionnalitées du Sandbox.
		Pour les modes de jeu comme DarkRP qui dérivent du Sandbox, il est recommandé de laisser Sandbox comme mode jeu par défaut.]],

		third_party_addons_tip = [[[bLogs supporte un grand nombre d'addons tiers'.
		Cependant, il peut arriver que bLogs ait des problèmes à détecter certains addons tiers installés.
		Sur cet écran, vous pouvez forcer bLogs à détecter certains addons tiers.

		Décoché = Comportement par défaut
		Coché = Activation Forcée
		Coché avec une croix = Désactivé]],

		edit_discord_webhooks = "Modifier les Webhooks Discord",
		webhook_name = "Nom du Webhook",
		webhook_name_tip = "Entrez le nom de votre webhook.\nIl ne sagit que d'un identifiant pour le webhook, vous entrerez l'URL dans la prochaine page.",
		webhook = "Webhook",
		webhook_url = "URL Webhook",
		webhook_url_tip = "Copier l'URL webhook de votre serveur discord et collez-la ici.",
		copy_webhook = "Copier Webhook",

		can_access_module = "Peu accéder au Module",
		can_access_all_modules = "Peu accéder à tous les modules",
		all_usergroups = "Tous les Grades",
		all_jobs_in_category = "Tous les métiers dans la catégorie",
		all_teams_in_category = "Toutes les équipes dans la catégorie",
		teams = "Equipes",
		permissions_tip = "Décoché = Hérité de \"%s\"\nCoché = Autorisé à utiliser le module\nCoché avec une croix = Interdit d'utiliser le module",
		all_modules_tip = "Les permissions sont héritées de cette section sauf en cas de substitution.",

		wipes_and_resets = "Nettoyage & Réinitialisations", -- wipes as in data wipes
		disable_buttons = "Désactiver les Boutons",
		enable_buttons = "Activer les Boutons",
		wipe_deepstorage = "Nettoyer le Stockage Interne",
		wipe_session = "Nettoyer les logs de Session",
		wipe_all_logs = "Nettoyer toutes les logs",
		reset_config = "Réinitialiser configuration",

		--####################### LOG PHRASES #######################--
		Logs = {
			round_start     = "DEBUT DE MANCHE",
			round_preparing = "PREPARATION DE MANCHE",
			round_end       = "FIN DE MANCHE",

			connected                                     = "{1} se connecte",
			connected_from_country                        = "{1} se connecte depuis {2}",
			finished_connecting                           = "{1} a fini de se connecter",
			respawned                                     = "{1} réapparu",
			disconnected                                  = "{1} déconnecté ({2})",
			picked_up_weapon                              = "{1} a ramassé une arme {2}",
			picked_up_item                                = "{1} a ramassé un item {2}",
			prop_killed_self                              = "{1} s'est suicidé avec son prop {2}",
			prop_killed_other                             = "{1} a été tué par un prop posé par {2} ({3})",
			prop_killed_world                             = "{1} a été tué par un prop de map {2}",
			prop_damaged_self                             = "{1} s'est infligé {2} de dégats avec son prop {3}",
			prop_damaged_other                            = "{1} a reçu des dégats d'un prop créer par {2} pour {3} dégats ({4})",
			prop_damaged_world                            = "{1} a reçu des dégats par un prop de map {2} pour {3} dégats",
			toolgun_used_their_ent                        = "{1} a utilisé l'outils {2} sur {3}",
			toolgun_used_other_ent                        = "{1} a utilisé l'outils {2} sur {3} créer par {4}",
			toolgun_used_world_ent                        = "{1} a utilisé l'outils {2} sur {3}",
			spawned_effect                                = "{1} a fait apparaitre un effet {2}",
			spawned_npc                                   = "{1} a fait apparaitre un NPC {2}",
			spawned_prop                                  = "{1} a fait apparaitre un prop {2}",
			spawned_ragdoll                               = "{1} a fait apparaitre un ragdoll {2}",
			spawned_sent                                  = "{1} a fait apparaitre un SENT {2}",
			spawned_swep                                  = "{1} a fait apparaitre un SWEP {2}",
			spawned_vehicle                               = "{1} a fait apparaitre un véhicule {2}",

			murder_loot                                   = "{1} a ramassé du butin",

			cinema_video_queued                           = "[{1}] {2} fait la queue [{3}] \"{4}\" {5}",

			ttt_win_traitor                               = "Les Traites ont gagné !",
			ttt_win_innocent                              = "Les Innocents ont gagné !",
			ttt_win_timelimit                             = "Innocents ont gagné - Limite de temps atteinte !",
			ttt_bought                                    = "{1} a acheté {2}",
			ttt_karma                                     = "{1} a été ÉJECTÉ pour faible karma",
			ttt_foundbody                                 = "{1} a trouvé le corps de {2}",
			ttt_founddna                                  = "{1} a trouvé l'ADN de {2} sur son {3}",
			ttt_founddna_corpse                           = "{1} a trouvé l'ADN de {2} sur son cadavre",

			darkrp_agenda_updated                         = "{1} a mis à jour l'agenda {2} pour: {3}",
			darkrp_agenda_removed                         = "{1} a supprimé le {2}",
			darkrp_arrest                                 = "{1} a arrêté {2}",
			darkrp_unarrest                               = "{1} a relaché {2}",
			darkrp_batteringram_owned_success             = "{1} a enfoncé le {2} de {3}",
			darkrp_batteringram_owned_door_success        = "{1} a enfoncé la porte de {2}",
			darkrp_batteringram_success                   = "{1} a enfoncé une {2} sans propriétaire",
			darkrp_batteringram_door_success              = "{1} a enfoncé une porte sans propriétaire",
			darkrp_batteringram_owned_failed              = "{1} n'a pas réussi à enfoncer le {2} de {3}",
			darkrp_batteringram_owned_door_failed         = "{1} n'a pas réussi à enfoncer la porte de {2}",
			darkrp_batteringram_failed                    = "{1} n'a pas réussi à enfoncer la {2} sans propriétaire",
			darkrp_batteringram_door_failed               = "{1} n'a pas réussi à enfoncer une porte sans propriétaire",
			darkrp_cheque_dropped                         = "{1} a posé un chèque de {2} pour {3}",
			darkrp_cheque_picked_up                       = "{1} a empoché un chèque de {2} fait par {3}",
			darkrp_cheque_tore_up                         = "{1} a dériché un chèque de {2} destiné à {3}",
			darkrp_demoted                                = "{1} a rétrogradé {2} pour {3}",
			darkrp_demoted_afk                            = "{1} a été rétrogradé pour avoir été AFK",
			darkrp_door_sold                              = "{1} a vendu une porte",
			darkrp_door_bought                            = "{1} a acheté une porte",
			darkrp_money_dropped                          = "{1} a posé {2}",
			darkrp_money_picked_up                        = "{1} a ramassé {2}",
			darkrp_money_picked_up_owned                  = "{1} a ramassé {2} posé par {3}",
			darkrp_job_changed                            = "{1} a changé de {2} pour {3}",
			darkrp_law_added                              = "{1} a ajouté la loi: {2}",
			darkrp_law_removed                            = "{1} a supprimé la loi: {2}",
			darkrp_purchase                               = "{1} a acheté {2} pour {3}",
			darkrp_purchase_ammo                          = "{1} a acheté {2} munitionjs pour {3}",
			darkrp_purchase_shipment                      = "{1} a acheté une caisse de x{2} {3} pour {4}",
			darkrp_purchase_food                          = "{1} a acheté {2} pour {3}",
			darkrp_weapons_checked                        = "{1} a vérifié l'arme de {2}",
			darkrp_weapons_confiscated                    = "{1} a confisqué les armes de {2}",
			darkrp_weapons_returned                       = "{1} a rendu les armes confisquées de {2}",
			darkrp_filed_warant                           = "{1} a déposé un mandat sur {2} pour: {3}",
			darkrp_warrant_cancelled                      = "{1} a annulé un mandat sur {2}",
			darkrp_set_wanted                             = "{1} recherche {2} pour {3}",
			darkrp_cancelled_wanted                       = "{1} a annulé l'avis de recherche de {2}",
			darkrp_starved                                = "{1} est mort affamé",
			darkrp_pocket_added                           = "{1} a mit {2} dans son sac",
			darkrp_pocket_dropped                         = "{1} a posé {2} depuis son sac",
			darkrp_rpname_change                          = "{1} a changé de nom rp de {2} pour {3}",
			darkrp_started_lockpick_owned_entity          = "{1} a commencé à crocheter {2} possédé par {3}",
			darkrp_started_lockpick_unowned_entity        = "{1} a commencé à crocheter une {2} sans propriétaire",
			darkrp_started_lockpick_owned_door            = "{1} a commencé à crocheter une porte appartenant à {2}",
			darkrp_started_lockpick_unowned_door          = "{1} a commencé à crocheter une porte sans propriétaire",
			darkrp_started_lockpick_own_entity            = "{1} a commencé à crocheter son {2}",
			darkrp_started_lockpick_own_door              = "{1} a commencé à crocheter l'une de ses portes",
			darkrp_successfully_lockpicked_owned_entity   = "{1} a crocheté {2} possédé par {3}",
			darkrp_successfully_lockpicked_unowned_entity = "{1} a crocheté une {2} sans propriétaire",
			darkrp_successfully_lockpicked_owned_door     = "{1} a crocheté une porte appartenant à {2}",
			darkrp_successfully_lockpicked_unowned_door   = "{1} a crocheté une porte sans propriétaire",
			darkrp_successfully_lockpicked_own_entity     = "{1} a crocheté sa {2}",
			darkrp_successfully_lockpicked_own_door       = "{1} a crocheté l'une de ses portes",
			darkrp_failed_lockpick_owned_entity           = "{1} n'a pas réussi à crocheter une {2} possédé par {3}",
			darkrp_failed_lockpick_unowned_entity         = "{1} n'a pas réussi à crocheter une {2} sans propriétaire",
			darkrp_failed_lockpick_owned_door             = "{1} n'a pas réussi à crocheter une porte possédé par {2}",
			darkrp_failed_lockpick_unowned_door           = "{1} n'a pas réussi à crocheter une porte sans propriétaire",
			darkrp_failed_lockpick_own_entity             = "{1} n'a pas réussi à crocheter sa {2}",
			darkrp_failed_lockpick_own_door               = "{1} n'a pas réussi à crocheter l'une de ses portes",
			darkrp_changed_job                            = "{1} a changé de métier de {2} pour {3}",
			darkrp_added_law                              = "{1} a ajouté la loi: {2}",
			darkrp_removed_law                            = "{1} a supprimé la loi: {2}",
			darkrp_hit_accepted                           = "{1} a accepté un contrat sur {2} donné par {3}",
			darkrp_hit_completed                          = "{1} a completé un contrat sur {2} ayant été donné par {3}",
			darkrp_hit_failed                             = "{1} a échoué sur un contrat contre {2} parce que {3}",
			darkrp_hit_requested                          = "{1} a donné un contrat sur {2} pendant {3} pour {4}",
			darkrp_sold_door                              = "{1} a vendu une porte",
			darkrp_bought_door                            = "{1} a acheté une porte",
			darkrp_dropped_money                          = "{1} a posé {2}",
			darkrp_picked_up_money                        = "{1} a ramassé {2}",
			darkrp_picked_up_money_dropped_by             = "{1} a ramssé {2} ayant été posé(e) par {3}",
			darkrp_afk_demoted                            = "{1} a été rétrogradé pour avoir été AFK",

			pvp_instigator_killed_noweapon                = "{1} {2} a fini un combat et à TUÉ {3} {4} après {5}", -- after X seconds/minutes/hours
			pvp_instigator_killed_weapon                  = "{1} {2} a fini un combat en utilisant {3} et à TUÉ {4} {5} après {6}",
			pvp_instigator_killed_weapons                 = "{1} {2} a fini un combat en utilisant plusieurs armes et à TUÉ {3} {4} après {5}",
			pvp_victim_killed_noweapon                    = "{1} {2} a fini un combat et à ÉTÉ TUÉ PAR {3} {4} après {5}",
			pvp_victim_killed_weapon                      = "{1} {2} a fini un combat en utilisant {3} et A ÉTÉ TUÉ PAR {4} {5} après {6}",
			pvp_victim_killed_weapons                     = "{1} {2} a fini un combat en utilisant plusieurs armes et A ÉTÉ TUÉ PAR {3} {4} après {5}",
			pvp_combat_noweapon                           = "{1} {2} finished combat with {3} {4} après {5}",
			pvp_combat_weapon                             = "{1} {2} a fini un combat en utilisant {3} avec {4} {5} après {6}",
			pvp_combat_weapons                            = "{1} {2} a fini un combat en utilisant plusieurs armes avec {3} {4} après {5}",
			pvp_log_noweapon                              = "{1} a touché {2} infligeant {3} dégats",
			pvp_log_weapon                                = "{1} a touché {2} infligeant {3} dégats avec un(e) {4}",
			pvp_killed                                    = "{1} a tué {2}",
			pvp_vehicle_owned_killed                      = "{1} a été touché et tué par un(e) {2} sans conducteur et appartenant à {3}",
			pvp_vehicle_owned_damaged                     = "{1} a été touché, recevant {2} dégats par {3} sans conducteur, et appartenant à {4}",
			pvp_vehicle_killed                            = "{1} a été touché et tué par un(e) {2} sans conducteur et sans propriétaire",
			pvp_vehicle_damaged                           = "{1} a été touché, recevant {2} dégats par {3} sans conducteur et sans propriétaire",
			pvp_killed_self                               = "{1} s'est suicidé",
			pvp_damaged_self                              = "{1} s'est infligé {2} dégats",

			changed_team                                  = "{1} a changé d'équipe de {2} pour {3}",
			command_used                                  = "{1}: {2}",
			warned_reason                                 = "{1} a été averti par {2} pour {3}",
			warned_noreason                               = "{1} a été averti par {2}",
			warned_kicked                                 = "{1} a été ÉJECTÉ pour avoir dépassé le seuil maximal d'avertissements",
			warned_banned                                 = "{1} a été BANNI pour avoir dépassé le seuil maximal d'avertissements",
			handcuffed                                    = "{1} a menotté {2}",
			handcuffs_broken_by                           = "{1} a libéré {2} de ses menottes",
			handcuffs_broken                              = "{1} s'est libéré de ses menottes",
			npc_health_bought                             = "{1} a acheté de la santé à un PNJ pour {2}",
			npc_armor_bought                              = "{1} a acheté de l'armure à un PNJ pour {2}",
			pac_outfit                                    = "{1} a changé pour une tenue PAC {2}",
			party_chat                                    = "{1} ({2}): {3}",
			party_created                                 = "{1} a créer une partie {2}",
			party_join                                    = "{1} a rejoint une partie {2}",
			party_join_request                            = "{1} a demandé à rejoindre une partie {2}",
			party_invite                                  = "{1} a invité {2} sur la partie {3}",
			party_leave                                   = "{1} a quitté la partie {2}",
			party_kick                                    = "{1} a ejecté {2} de la partie {3}",
			party_disbanded                               = "{1} a supprimé la partie {2}",
			party_abandoned                               = "{1} a quitté le serveur et a abandonné sa partie {2}",
			spraymesh                                     = "{1} a utilisé son spray {2}",
			starwarsvehicle_damage_owned_weapon           = "{1} a infligé des dégats sur Star Wars vehicle {2} possédé par {3} pour {4} dégats avec {5}",
			starwarsvehicle_damage_owned                  = "{1} a infligé des dégats sur Star Wars vehicle {2} possédé par {3} pour {4} dégats",
			starwarsvehicle_damage_weapon                 = "{1} a infligé des dégats sur Star Wars vehicle {2} pour {3} dégats avec {4}",
			starwarsvehicle_damage                        = "{1} a infligé des dégats sur Star Wars vehicle {2} pour {3} dégats",
			wac_damage_owned_weapon                       = "{1} a infligé des dégats sur WAC aircraft {2} possédé par {3} pour {4} dégats avec {5}",
			wac_damage_owned                              = "{1} a infligé des dégats sur WAC aircraft {2} possédé par {3} pour {4} dégats",
			wac_damage_weapon                             = "{1} a infligé des dégats sur WAC aircraft {2} pour {3} dégats avec {4}",
			wac_damage                                    = "{1} a infligé des dégats sur WAC aircraft {2} pour {3} dégats",
			wyozi_cinema_queued                           = "{1} a demandé la vidéo {2} ➞ {3} au cinéma {4}",
			wyozi_dj_queued                               = "{1} a ajouté en file d'attente {2} ➞ {3} sur le canal {4}",
			wyozi_dj_channel_rename                       = "{1} a renommé le canal en {2}",
		}

} end }
--addons/billy_gas/lua/gmodadminsuite/modules/playerdatabase/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Player Database",

		right_click_to_focus    = "Right click to focus",
		steamid                 = "SteamID",
		name                    = "Name",
		usergroup               = "Usergroup",
		ip_address              = "IP Address",
		last_seen               = "Last Seen",
		copy_steamid            = "Copy SteamID",
		copy_steamid64          = "Copy SteamID64",
		copy_usergroup          = "Copy Usergroup",
		copy_ip_address         = "Copy IP Address",
		copy_name               = "Copy Name",
		copy_steam_profile_link = "Copy Steam Profile Link",
		search                  = "Search",
		country                 = "Country",
		copy_country            = "Copy Country",
		search_usergroup        = "Search Usergroup",
		search_ip_address       = "Search IP Address",
		search_country          = "Search Country",
		search_name             = "Search Name",
		none                    = "< none >",
		cancel                  = "Cancel",
		steamid                 = "SteamID",

} end }
--addons/billy_gas/lua/gmodadminsuite/sh_registry_tbl.lua:
-- Optimization library
-- Helps with optimizing pairs() into ipairs() for some stuff
-- Basically just a table that makes sure there are no duplicates

AddCSLuaFile()

local setmetatable = setmetatable
local rawget = rawget
local rawset = rawset
local isnumber = isnumber

local function __index_func(self, i)
	if (isnumber(i)) then
		return rawget(self, "seq")[i]
	else
		return rawget(self, "kv")[i]
	end
end

local function __call_func(self, i, method)
	local kv = rawget(self, "kv")

	if (method == nil and kv[i] ~= nil) then -- remove

		local seq = rawget(self, "seq")
		local seq_i = rawget(self, "seq_i")
		local seq_r = rawget(self, "seq_r")
		
		kv[i] = nil
		seq[seq_r[i]] = nil
		for shift=seq_r[i]+1,seq_i do
			if (seq[shift] ~= nil) then
				seq_r[seq[shift]] = shift - 1
			end
			seq[shift-1] = seq[shift]
		end
		
		seq_r[i] = nil

		rawset(self, "seq_i", seq_i - 1)

	elseif (method ~= nil) then -- add

		if (kv[i] ~= nil) then
			self(i, nil)
		end

		local seq = rawget(self, "seq")
		local seq_i = rawget(self, "seq_i")
		local seq_r = rawget(self, "seq_r")

		kv[i] = method
		seq[seq_i] = i
		seq_r[i] = seq_i

		rawset(self, "seq_i", seq_i + 1)

	end
end

local function ipairs_func(self)
	return ipairs(rawget(self, "seq"))
end

local function pairs_func(self)
	return pairs(rawget(self, "kv"))
end

local function ipairs_pop_func(self)
	local n, prev_n
	return function()
		n = self:len()
		if (n > 0) then
			assert(prev_n == nil or n < prev_n, "ipairs_pop requires element to always be popped")
			prev_n = n
			return n, rawget(self, "seq")[n]
		end
	end
end

local ipairs_poppy_func
do
	local active_ipairs_pop
	local function pop_func()
		active_ipairs_pop(rawget(active_ipairs_pop, "seq")[rawget(active_ipairs_pop, "poppy_i")], nil)
	end
	ipairs_poppy_func = function(self)
		self(NULL, nil)
		active_ipairs_pop = self
		rawset(self, "poppy_i", self:len() + 1)
		return function()
			rawset(self, "poppy_i", rawget(self, "poppy_i") - 1)
			if (rawget(self, "poppy_i") > 0) then
				return rawget(self, "poppy_i"), rawget(self, "seq")[rawget(self, "poppy_i")], pop_func
			end
		end
	end
end

local function len_func(self)
	self(NULL, nil)
	return rawget(self, "seq_i") - 1
end

local function sequential_func(self)
	self(NULL, nil)
	return rawget(self, "seq")
end

local function dictionary_func(self)
	self(NULL, nil)
	return rawget(self, "kv")
end

function GAS:Registry()
	local Registry = {
		seq = {},
		seq_i = 1,
		seq_r = {},
		kv = {},
		ipairs = ipairs_func,
		ipairs_pop = ipairs_pop_func,
		ipairs_poppy = ipairs_poppy_func,
		pairs = pairs_func,
		len = len_func,
		sequential = sequential_func,
		dictionary = dictionary_func
	}

	setmetatable(Registry, {
		__index = __index_func,
		__call = __call_func
	})
	
	return Registry
end
--addons/weapon_jedi/lua/lscs/init.lua:

if CLIENT then
	LSCS.KeyToForce = LSCS.KeyToForce or {}

	function LSCS:RefreshKeys() -- we don't know how many forcepowers we gonna expect, so a lookup table might be a good idea.
		table.Empty( LSCS.KeyToForce )
		for name, entry in pairs( LSCS.Force ) do
			local ID = entry.cmd:GetInt()

			if not LSCS.KeyToForce[ ID ] then
				LSCS.KeyToForce[ ID ] = {}
			end

			table.insert( LSCS.KeyToForce[ ID ], name ) -- it must be done like this so we can bind multiple forcepowers to the same key
		end
	end
else
	AddCSLuaFile("includes/circles/circles.lua")
end

function LSCS:RegisterDeflectableTracer( tracername )
	if not table.HasValue( LSCS.BulletTracerDeflectable, tracername ) then
		table.insert( LSCS.BulletTracerDeflectable, tracername )
	end
end

LSCS:RegisterDeflectableTracer( "laser_*" ) -- this should pretty much include all laser types, but you can add your own
LSCS:RegisterDeflectableTracer( "ar2tracer_custom" )

function LSCS:AngleBetweenVectors( Vec1, Vec2 )
	local clampDot = math.Clamp( Vec1:Dot( Vec2 ) ,-1,1) -- this clamp took me 1 whole day to figure out in 2014... If the dotproduct of both vectors that are supposedly 1 unit long goes above 1 this can be NAN and cause instant ctd when applied as force...
	local rads = math.acos( clampDot ) -- rad is for nerds

	return math.deg( rads ) -- degrees is what normal humans use
end

function LSCS:SetHilt( ply, hilt_right, hilt_left )
	if hilt_right == "" or not LSCS:GetHilt( hilt_right ) then
		ply.m_lscs_hilt_right = nil
	else
		ply.m_lscs_hilt_right = hilt_right
	end

	if hilt_left == ""  or not LSCS:GetHilt( hilt_left ) then
		ply.m_lscs_hilt_left = nil
	else
		ply.m_lscs_hilt_left = hilt_left
	end
end

function LSCS:SetBlade( ply, blade_right, blade_left )
	if blade_right == "" or not LSCS:GetBlade( blade_right ) then
		ply.m_lscs_blade_right = nil
	else
		ply.m_lscs_blade_right = blade_right
	end

	if blade_left == ""  or not LSCS:GetBlade( blade_left ) then
		ply.m_lscs_blade_left = nil
	else
		ply.m_lscs_blade_left = blade_left
	end
end

function LSCS:GetHilt( name )
	return LSCS.Hilt[ name ]
end

function LSCS:GetBlade( name )
	return LSCS.Blade[ name ]
end

function LSCS:GetStance( name )
	return LSCS.Stance[ name ]
end

function LSCS:GetForce( name )
	return LSCS.Force[ name ]
end

function LSCS:ClassToItem( class )
	if not isstring( class ) then return end

	local words = string.Explode( "_", class )
	local type = words[ 2 ]
	local id = words[ 3 ]

	if type == "saberhilt" then
		return LSCS.Hilt[ id ]
	end
	if type == "crystal" then
		return LSCS.Blade[ id ]
	end
	if type == "stance" then
		return LSCS.Stance[ id ]
	end
	if type == "force" then
		return LSCS.Force[ id ]
	end

	return false
end

function LSCS:RegisterForce( data )
	if not data.id then return end

	local id = string.lower( data.id )
	local class = "item_force_"..id
	local fallback = function( ply ) end

	LSCS.Force[ id ] = {
		id = id,
		name = data.PrintName,
		description = data.Description,
		author = data.Author,
		type = "force",
		Type = "Force",
		class = class,
		Equip = (data.Equip or fallback),
		UnEquip = (data.UnEquip or fallback),
		StartUse = (data.StartUse or fallback),
		StopUse = (data.StopUse or fallback),
	}

	if data.OnClk then
		hook.Add( "LSCS:PlayerForcePowerThink", id, data.OnClk )
	end

	if CLIENT then
		LSCS.Force[ id ].cmd = CreateClientConVar( "lscs_key_force_"..id, KEY_NONE, true, true )
		LSCS:RefreshKeys()
	end

	local ENT = {}

	ENT.Base = "lscs_force_base"

	ENT.PrintName = data.PrintName
	ENT.Author = data.Author
	ENT.Category = "[LSCS] - Force"

	ENT.Spawnable       = data.Spawnable ~= false
	ENT.AdminSpawnable  = false

	scripted_ents.Register( ENT, class )
end

function LSCS:RegisterHilt( data )
	if not data.id or not data.mdl or not data.info then return end

	local id = string.lower( data.id )
	local class = "item_saberhilt_"..id

	LSCS.Hilt[ id ] = {
		id = id,
		name = data.PrintName,
		type = "hilt",
		Type = "Hilt",
		class = class,
		mdl = data.mdl,
		info = data.info,
	}

	local ENT = {}

	ENT.Base = "lscs_hilt_base"

	ENT.PrintName = data.PrintName
	ENT.Author = data.Author
	ENT.Category = "[LSCS] - Hilts"

	ENT.Spawnable = data.Spawnable ~= false
	ENT.AdminSpawnable = false

	ENT.MDL = data.mdl

	scripted_ents.Register( ENT, class )
end

function LSCS:RegisterBlade( data )
	if not data.id then return end

	local id = string.lower( data.id )
	local class = "item_crystal_"..id

	LSCS.Blade[ id ] = {
		id = id,
		name = data.PrintName,
		type = "crystal",
		Type = "Crystal",
		class = class,
		color_blur = data.color_blur or Color(0,65,255),
		color_core = data.color_core or color_white,
		length = data.length or 45,
		width = data.width or 0.9,
		widthWiggle = data.widthWiggle or 0.6,
		mdl = data.mdl,
		mdl_poseparameter = data.mdl_poseparameter,
		material_core_tip = data.material_core_tip or Material( "lscs/effects/lightsaber_tip" ),
		material_core = data.material_core or Material( "lscs/effects/lightsaber_core" ),
		material_glow = data.material_glow or Material( "lscs/effects/lightsaber_glow" ),
		material_trail = data.material_trail or Material( "lscs/effects/lightsaber_trail" ),
		dynamic_light = (data.dynamic_light == true),
		no_trail = (data.no_trail == true),
		sounds = {
			Attack = (data.sounds.Attack or "saber_hup"),
			Attack1 = (data.sounds.Attack1 or "saber_spin1"),
			Attack2 = (data.sounds.Attack2 or "saber_spin2"),
			Attack3 = (data.sounds.Attack3 or "saber_spin3"),
			Activate = (data.sounds.Activate or "saber_turnon"),
			Disable = (data.sounds.Disable or "saber_turnoff"),
			Idle =  (data.sounds.Idle or "saber/saberhum4.wav"),
		}
	}

	local ENT = {}

	ENT.Base = "lscs_crystal_base"

	ENT.PrintName = data.PrintName
	ENT.Author = data.Author
	ENT.Category = "[LSCS] - Crystals"

	ENT.Spawnable       = data.Spawnable ~= false
	ENT.AdminSpawnable  = false

	ENT.ID = id

	scripted_ents.Register( ENT, class )
end

local function FileIsEmpty( filename )
	if file.Size( filename, "LUA" ) <= 1 then -- this is suspicous
		local data = file.Read( filename, "LUA" )

		if data and string.len( data ) <= 1 then -- confirm its empty
			print("[LSCS] - refusing to load '"..filename.."'! File is Empty!" )

			return true
		end
	end

	return false
end

LSCS.Timeout = LSCS.Timeout or 0

LSCS.Reload = function()
	local Time = CurTime()
	if LSCS.Timeout > Time then 
		print("[LSCS] - refusing refresh ["..Time.."]")
		return
	else
		print("[LSCS] - initialized ["..Time.."]")
	end
	LSCS.Timeout = CurTime() + 1

	for _, filename in pairs( file.Find("lscs/autorun/*.lua", "LUA") ) do
		if string.StartWith( filename, "sv_") then -- sv_ prefix only load serverside
			if SERVER then
				include("lscs/autorun/"..filename)
			end

			continue
		end

		if string.StartWith( filename, "cl_") then -- cl_ prefix only load clientside
			if SERVER then
				AddCSLuaFile("lscs/autorun/"..filename)
			else
				include("lscs/autorun/"..filename)
			end

			continue
		end

		-- everything else is shared
		if SERVER then
			AddCSLuaFile("lscs/autorun/"..filename)
		end
		include("lscs/autorun/"..filename)
	end

	-- combo files
	COMBO = {} -- yeah this can cause conflicts if someone happens to have a global table with the same name somewhere in his gamemode. 
	for _, filename in pairs( file.Find("lscs/combos/*.lua", "LUA") ) do
		if FileIsEmpty( "lscs/combos/"..filename ) then continue end -- sometimes i feel like people just want to troll me. Maximum incompetence honestly.

		if SERVER then
			AddCSLuaFile("lscs/combos/"..filename)
		end

		table.Empty( COMBO )

		include("lscs/combos/"..filename)

		local id = string.lower( COMBO.id )
		local class = "item_stance_"..id

		LSCS.Stance[ id ] = {
			id = id,
			name = COMBO.PrintName,
			description = COMBO.Description,
			author = COMBO.Author,
			type = "stance",
			Type = "Stance",
			class = class,
			HoldType = COMBO.HoldType,
			DeflectBullets = COMBO.DeflectBullets,
			AutoBlock = COMBO.AutoBlock,
			Attacks = table.Copy( COMBO.Attacks ),
			LeftSaberActive = (COMBO.LeftSaberActive == true),
			MaxBlockPoints = COMBO.MaxBlockPoints,
			BPDrainPerHit = COMBO.BPDrainPerHit,
			DamageMul = (COMBO.DamageMultiplier or 1),
			BlockDistanceNormal = COMBO.BlockDistanceNormal,
			BlockDistancePerfect = COMBO.BlockDistancePerfect,
            BlockAnims = COMBO.BlockAnims
		}

		local ENT = {}

		ENT.Base = "lscs_stance_base"

		ENT.PrintName = COMBO.PrintName
		ENT.Author = COMBO.Author
		ENT.Category = "[LSCS] - Stances"

		ENT.Spawnable       = COMBO.Spawnable ~= false
		ENT.AdminSpawnable  = false

		scripted_ents.Register( ENT, class )

		table.Empty( COMBO )
	end

	-- content, such as hilts, blades, force powers
	for _, filename in pairs( file.Find("lscs/content/*.lua", "LUA") ) do
		if FileIsEmpty( "lscs/content/"..filename ) then continue end -- sometimes i feel like people just want to troll me. Maximum incompetence honestly.

		if SERVER then
			AddCSLuaFile("lscs/content/"..filename)
		end
		include("lscs/content/"..filename)
	end
end

LSCS:Reload()

-- TODO: allow this to be changed in combo file
LSCS.ComboInterupt = {
	["____"] = "b_block_forward_riposte",
	["-45-"] = "b_block_forward_riposte",
	["+45+"] = "b_block_forward_riposte",
	["__S_"] = "b_block_forward_riposte",
	["_A__"] = "b_block_left_riposte",
	["___D"] = "b_block_right_riposte",
	["W__D"] = "b_right_riposte",
	["WA__"] = "b_block_forward_riposte",
	["__SD"] = "b_right_riposte",
	["_AS_"] = "b_block_left_riposte",
	["W___"] = "b_forward_riposte",
}

LSCS.ComboInfo = {
	["____"] = {
		name = "Base Attack",
		order = 1,
		description = "[Mouse 1]",
	},
	["W___"] = {
		name = "Forward Attack",
		order = 2,
		description = "[W]+[Mouse 1]+([Shift] to prioritize)",
	},
	["__S_"] = {
		name = "Reverse Attack",
		order = 3,
		description = "[S]+[Mouse 1]",
	},
	["_A__"] = {
		name = "Left Attack",
		order = 4,
		description = "[A]+[Mouse 1]",
	},
	["___D"] = {
		name = "Right Attack",
		order = 5,
		description = "[D]+[Mouse 1]",
	},
	["W__D"] = {
		name = "Front-Right Attack",
		order = 6,
		description = "[W]+[D]+[Mouse 1]",
	},
	["WA__"] = {
		name = "Front-Left Attack",
		order = 7,
		description = "[W]+[A]+[Mouse 1]",
	},
	["__SD"] = {
		name = "Back-Right Attack",
		order = 8,
		description = "[S]+[D]+[Mouse 1]",
	},
	["_AS_"] = {
		name = "Back-Left Attack",
		order = 9,
		description = "[A]+[S]+[Mouse 1]",
	},
	["W_S_"] = {
		name = "Special Attack",
		order = 10,
		description = "[W]+[S]+[Mouse 1]",
	},
	["-45-"] = {
		name = "Up Attack",
		order = 11,
		description = "while looking UP\nPress [Mouse 1] or [W]+[Mouse 1]",
	},
	["+45+"] = {
		name = "Down Attack",
		order = 12,
		description = "while looking DOWN\nPress [Mouse 1] or [W]+[Mouse 1]",
	},
	["FRONT_DASH"] = {
		name = "Dash Forward",
		order = 13,
		description = "HOLD [SPACE]+[W] then\nPress [Mouse 1] while still in air",
	},
	["BACKFLIP"] = {
		name = "Backflip",
		order = 14,
		description = "HOLD [SPACE]+[S] then\nPress [Mouse 1] while still in air",
	},
	["SLAM"] = {
		name = "Slam",
		order = 15,
		description = "Perform a [Backflip] then\nHOLD [Mouse 1] while still in air",
	},
	["ROLL_RIGHT"] = {
		name = "Dodge Right",
		order = 16,
		description = "HOLD [SPACE]+[D] then\nPress [Mouse 1] while still in air",
	},
	["ROLL_LEFT"] = {
		name = "Dodge Left",
		order = 17,
		description = "HOLD [SPACE]+[A] then\nPress [Mouse 1] while still in air",
	},
}
--addons/weapon_jedi/lua/lscs/autorun/cl_lscs_thirdperson.lua:

-- local function Validate( ply )
-- 	if not ply:Alive() or ply:GetViewEntity() ~= ply then return false end -- when a player uses the camera tool for example

-- 	local weapon = ply:GetActiveWeapon()

-- 	if not IsValid( weapon ) or not weapon.LSCS then return false end -- not holding our lightsaber

-- 	if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return false end -- use vehicle view in vehicles

-- 	return true
-- end

-- this is the main camera. If all goes to plan this should do the job
-- hook.Add( "CalcView", "!!!!!!!!!!!!simple_glowstickthirdperson",  function( ply, pos, angles, fov )
-- 	if not Validate( ply ) then return end

-- 	local view = {}
-- 	view.origin = ply:lscsGetViewOrigin()
-- 	view.angles = ply:EyeAngles()
-- 	view.fov = fov
-- 	view.drawviewer = true

-- 	ply._lscsCalcViewTime = CurTime() + 0.1

-- 	return view
-- end )

-- -- this is used for when the CalcView hook somehow doesn't get called but the SWEP:CalcView function is. If the hook fails this will probably fail aswell tho
-- hook.Add( "ShouldDrawLocalPlayer", "!!!!!!!!!!!!simple_glowstickthirdperson",  function( ply )
-- 	if (ply._lscsCalcViewTime or 0) < CurTime() then return end

-- 	if not Validate( ply ) then return end

-- 	return true
-- end )

--addons/lvs_base/lua/lvs_framework/autorun/lvs_hookers.lua:

hook.Add( "InitPostEntity", "!!!lvsBullshitFixer", function()
	timer.Simple(1, function()
		LVS.MapDoneLoading = true
	end)

	if SERVER then return end

	-- this needs to be here to make sure all sents are registered
	for _, vehicletype in ipairs( LVS:GetVehicleTypes() ) do
		CreateClientConVar( "lvs_mouseaim_type_"..vehicletype, 0, true, false)
	end
end )

local function SetDistance( vehicle, ply )
	local iWheel = ply:GetCurrentCommand():GetMouseWheel()

	if iWheel == 0 or not vehicle.SetCameraDistance then return end

	local newdist = math.Clamp( vehicle:GetCameraDistance() - iWheel * 0.03 * ( 1.1 + vehicle:GetCameraDistance() ), -1, 10 )

	vehicle:SetCameraDistance( newdist )
end

local function SetHeight( vehicle, ply )
	local iWheel = ply:GetCurrentCommand():GetMouseWheel()

	if iWheel == 0 or not vehicle.SetCameraHeight then return end

	local newdist = math.Clamp( vehicle:GetCameraHeight() - iWheel * 0.03 * ( 1.1 + vehicle:GetCameraHeight() ), -1, 10 )

	vehicle:SetCameraHeight( newdist )
end

hook.Add( "VehicleMove", "!!!!lvs_vehiclemove", function( ply, vehicle, mv )
	if not ply.lvsGetVehicle then return end

	local veh = ply:lvsGetVehicle()

	if not IsValid( veh ) then return end

	if SERVER and ply:lvsKeyDown( "VIEWDIST" ) then
		if ply:lvsKeyDown( "VIEWHEIGHT" ) then
			SetHeight( vehicle, ply )
		else
			SetDistance( vehicle, ply )
		end
	end

	if CLIENT and not IsFirstTimePredicted() then return end
	
	local KeyThirdPerson = ply:lvsKeyDown("THIRDPERSON")

	if ply._lvsOldThirdPerson ~= KeyThirdPerson then
		ply._lvsOldThirdPerson = KeyThirdPerson

		if KeyThirdPerson and vehicle.SetThirdPersonMode then
			vehicle:SetThirdPersonMode( not vehicle:GetThirdPersonMode() )
		end
	end

	return true
end )

hook.Add("CalcMainActivity", "!!!lvs_playeranimations", function(ply)
	if not ply.lvsGetVehicle then return end

	local Ent = ply:lvsGetVehicle()

	if IsValid( Ent ) then
		local A,B = Ent:CalcMainActivity( ply )

		if A and B then
			return A, B
		end
	end
end)

hook.Add("UpdateAnimation", "!!!lvs_playeranimations", function( ply, velocity, maxseqgroundspeed )
	if not ply.lvsGetVehicle then return end

	local Ent = ply:lvsGetVehicle()

	if not IsValid( Ent ) then return end

	return Ent:UpdateAnimation( ply, velocity, maxseqgroundspeed )
end)

hook.Add( "StartCommand", "!!!!LVS_grab_command", function( ply, cmd )
	if not ply.lvsGetVehicle then return end

	local veh = ply:lvsGetVehicle()

	if not IsValid( veh ) then return end

	veh:StartCommand( ply, cmd )
end )

hook.Add( "CanProperty", "!!!!lvsEditPropertiesDisabler", function( ply, property, ent )
	if ent.LVS and not ply:IsAdmin() and property == "editentity" then return false end
end )

LVS.ToolsDisable = {
	["rb655_easy_animation"] = true,
	["rb655_easy_bonemerge"] = true,
	["rb655_easy_inspector"] = true,
}
hook.Add( "CanTool", "!!!!lvsCanToolDisabler", function( ply, tr, toolname, tool, button )
	if LVS.ToolsDisable[ toolname ] and IsValid( tr.Entity ) and tr.Entity.LVS then return false end
end )

if CLIENT then
	local hide = {
		["CHudHealth"] = true,
		["CHudBattery"] = true,
		["CHudAmmo"] = true,
	}
	local function HUDShouldDrawLVS( name )
		if hide[ name ] then return false end
	end

	hook.Add( "LVS.PlayerEnteredVehicle", "!!!!lvs_player_enter", function( ply, veh )
		hook.Add( "HUDShouldDraw", "!!!!lvs_hidehud", HUDShouldDrawLVS )

		if not IsValid( veh ) then return end

		local cvar = GetConVar( "lvs_mouseaim_type" )

		if not cvar or cvar:GetInt() ~= 1 or not veh.GetVehicleType then return end

		local vehicletype = veh:GetVehicleType()

		local cvar_type = GetConVar( "lvs_mouseaim_type_"..vehicletype )
		local cvar_mouseaim = GetConVar( "lvs_mouseaim" )

		if not cvar_type or not cvar_mouseaim then return end

		cvar_mouseaim:SetInt( cvar_type:GetInt() )
	end )

	hook.Add( "LVS.PlayerLeaveVehicle", "!!!!lvs_player_exit", function( ply, veh )
		hook.Remove( "HUDShouldDraw", "!!!!lvs_hidehud" )
	end )

	return
end

local DamageFix = {
	["npc_hunter"] = true,
	["npc_stalker"] = true,
	["npc_strider"] = true,
	["npc_combinegunship"] = true,
	["npc_helicopter"] = true,
}

hook.Add( "EntityTakeDamage", "!!!_lvs_fix_vehicle_explosion_damage", function( target, dmginfo )
	if not target:IsPlayer() then
		if target.LVS then
			local attacker = dmginfo:GetAttacker()

			if IsValid( attacker ) and DamageFix[ attacker:GetClass() ] then
				dmginfo:SetDamageType( DMG_AIRBOAT )
				dmginfo:SetDamageForce( dmginfo:GetDamageForce():GetNormalized() * 15000 )
			end
		end

		return
	end

	local veh = target:lvsGetVehicle()

	if not IsValid( veh ) or dmginfo:IsDamageType( DMG_DIRECT ) then return end

	if target:GetCollisionGroup() == COLLISION_GROUP_PLAYER then return end

	dmginfo:SetDamage( 0 )
end )

hook.Add( "PlayerEnteredVehicle", "!!!!lvs_player_enter", function( ply, Pod )
	local veh = ply:lvsGetVehicle()

	if IsValid( veh ) then
		net.Start( "lvs_player_enterexit" )
			net.WriteBool( true )
			net.WriteEntity( veh )
		net.Send( ply )

		ply._lvsIsInVehicle = true

		if istable( veh.PlayerBoneManipulate ) then
			local ID = Pod:lvsGetPodIndex()
			local BoneManipulate = veh.PlayerBoneManipulate[ ID ]

			if BoneManipulate then
				ply._lvsStopBoneManipOnExit = true
				ply:lvsStartBoneManip()
			end
		end
	end

	if not Pod.HidePlayer then return end

	ply:SetNoDraw( true )

	if pac then pac.TogglePartDrawing( ply, 0 ) end
end )

hook.Add( "PlayerLeaveVehicle", "!!!!lvs_player_exit", function( ply, Pod )
	if ply._lvsIsInVehicle then
		net.Start( "lvs_player_enterexit" )
			net.WriteBool( false )
			net.WriteEntity( ply:lvsGetVehicle() )
		net.Send( ply )

		ply._lvsIsInVehicle = nil

		if ply._lvsStopBoneManipOnExit then
			ply._lvsStopBoneManipOnExit = nil

			ply:lvsStopBoneManip()
		end
	end

	if not Pod.HidePlayer then return end

	ply:SetNoDraw( false )

	if pac then pac.TogglePartDrawing( ply, 1 ) end
end )

hook.Add( "PlayerDisconnected", "!!!!lvs_player_reset_bonemanip_client", function(ply)
	if not ply._lvsStopBoneManipOnExit then return end

	ply._lvsStopBoneManipOnExit = nil

	ply:lvsStopBoneManip()
end )
--addons/billy_gas/lua/autorun/openpermissions.lua:
OpenPermissions_Readying = true
OpenPermissions_Ready = nil

if (CLIENT and IsValid(OpenPermissions_Menu)) then
	OpenPermissions_Menu:Close()
end

OpenPermissions = {}
OpenPermissions.pon = include("openpermissions/thirdparty/pon.lua")

OpenPermissions.Version = "v1.0"

OpenPermissions.COLOR_WHITE      = Color(255,255,255)
OpenPermissions.COLOR_LIGHT_BLUE = Color(0,255,255)
OpenPermissions.COLOR_YELLOW     = Color(0,255,255)
OpenPermissions.COLOR_RED        = Color(255,0,0)
OpenPermissions.COLOR_GREEN      = Color(0,255,0)
OpenPermissions.COLOR_BLACK      = Color(0,0,0)
OpenPermissions.COLOR_SOFT_GREEN = Color(76,216,76)
OpenPermissions.COLOR_SOFT_RED   = Color(216,76,76)

local version_info = "Version: " .. OpenPermissions.Version
local padding = (65 - #version_info) / 2
local version_str = (" "):rep(math.ceil(padding)) .. version_info .. (" "):rep(math.floor(padding))

local github_link = "https://github.com/WilliamVenner/GLua-OpenPermissions"
local padding = (65 - #github_link) / 2
local github_str = (" "):rep(math.ceil(padding)) .. github_link .. (" "):rep(math.floor(padding))

MsgC(OpenPermissions.COLOR_YELLOW, [[

     _____             _____               _         _             
    |     |___ ___ ___|  _  |___ ___ _____|_|___ ___|_|___ ___ ___ 
    |  |  | . | -_|   |   __| -_|  _|     | |_ -|_ -| | . |   |_ -|
    |_____|  _|___|_|_|__|  |___|_| |_|_|_|_|___|___|_|___|_|_|___|
          |_|                                                      

]])
MsgC(OpenPermissions.COLOR_GREEN,  "  [=================================================================]\n")
MsgC(OpenPermissions.COLOR_YELLOW, "  [" ..                       version_str                       .. "]\n")
MsgC(OpenPermissions.COLOR_YELLOW, "  [" ..                       github_str                        .. "]\n")
MsgC(OpenPermissions.COLOR_GREEN,  "  [=================================================================]\n\n")

function OpenPermissions:Print(msg, prefix, color)
	MsgC(color or Color(0,255,255), "[OpenPermissions] " .. (prefix or "") .. " ", Color(255,255,255), msg, "\n")
end
function OpenPermissions:ChatPrint(msg, prefix, color)
	chat.AddText(color or Color(0,255,255), "[OpenPermissions] " .. (prefix or "") .. " ", Color(255,255,255), msg)
end

--## BillysErrors ##--

if (file.Exists("includes/modules/billyserrors.lua", "LUA")) then
	require("billyserrors")
end
if (SERVER and BillysErrors) then
	OpenPermissions.BillysErrors = BillysErrors:AddAddon({
		Name  = "OpenPermissions",
		Color = Color(80,0,255),
		Icon  = "icon16/group.png",
	})
end

--## Initialize configs ##--
OpenPermissions.Operators = {}

local function InstallConfigAddon()
	if (SERVER and BillysErrors) then
		OpenPermissions.BillysErrors:AddMessage("Looks like the OpenPermissions Config Addon has not been installed to your server: ", {Link = "https://gmodsto.re/openpermissions-config-addon"}, "\nYou need to install this addon in order to use & configure OpenPermissions.")
	else
		OpenPermissions:Print("Looks like the OpenPermissions Config Addon has not been installed to your server: https://gmodsto.re/openpermissions-config-addon\nYou need to install this addon in order to use & configure OpenPermissions.", "[ERROR]", OpenPermissions.COLOR_RED)
	end
end

if (not file.Exists("openpermissions_config.lua", "LUA")) then
	return InstallConfigAddon()
else
	local config_worked = include("openpermissions_config.lua")
	if (not config_worked) then
		if (SERVER and BillysErrors) then
			OpenPermissions.BillysErrors:AddMessage("Your config file appears to have an error! Please fix the errors by looking above or by resetting to the default config.")
		else
			OpenPermissions:Print("Your config file appears to have an error! Please fix the errors by looking above or by resetting to the default config.", "[ERROR]", OpenPermissions.COLOR_RED)
		end
		return
	end
end

if (not file.Exists("openpermissions_lua_functions.lua", "LUA")) then
	return InstallConfigAddon()
else
	local config_worked = include("openpermissions_lua_functions.lua")
	if (not config_worked) then
		if (SERVER and BillysErrors) then
			OpenPermissions.BillysErrors:AddMessage("Your Lua functions file appears to have an error! Please fix the errors by looking above or by resetting to the default Lua functions config.")
		else
			OpenPermissions:Print("Your Lua functions file appears to have an error! Please fix the errors by looking above or by resetting to the default Lua functions config.", "[ERROR]", OpenPermissions.COLOR_RED)
		end
		return
	else
		OpenPermissions.LuaFunctions = config_worked
	end
end

--## Languages ##--

if (CLIENT) then
	function OpenPermissions.L(phrase)
		return OpenPermissions.LANG.Phrases[phrase] or OpenPermissions.LANG_ENGLISH.Phrases[phrase] or phrase
	end
	function OpenPermissions.Lf(phrase, ...)
		return (OpenPermissions.LANG.Phrases[phrase] or OpenPermissions.LANG_ENGLISH.Phrases[phrase] or phrase):format(...)
	end

	function OpenPermissions:LoadPhrasebook()
		if (not file.Exists("openpermissions_lang.txt", "DATA")) then
			file.Write("openpermissions_lang.txt", "english")
		end
		local selected_language = file.Read("openpermissions_lang.txt", "DATA")
		if (not selected_language or not file.Find("openpermissions/lang/" .. selected_language .. ".lua", "LUA")) then selected_language = "english" end
		OpenPermissions.LANG_ENGLISH = include("openpermissions/lang/english.lua")
		if (selected_language == "english" or not file.Exists("openpermissions/lang/" .. selected_language .. ".lua", "LUA")) then
			OpenPermissions.LANG = OpenPermissions.LANG_ENGLISH or {}
		else
			OpenPermissions.LANG = include("openpermissions/lang/" .. selected_language .. ".lua") or {}
		end
	end
	OpenPermissions:LoadPhrasebook()
else
	local fs = file.Find("openpermissions/lang/*.lua", "LUA")
	for _,f in ipairs(fs) do
		AddCSLuaFile("openpermissions/lang/" .. f)
	end
end

--## Enums and Data Structures ##--

OpenPermissions.ACCESS_GROUP = {}
OpenPermissions.ACCESS_GROUP.USERGROUP = 1
OpenPermissions.ACCESS_GROUP.STEAMID = 2
OpenPermissions.ACCESS_GROUP.TEAM = 3
OpenPermissions.ACCESS_GROUP.LUA_FUNCTION = 4
OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY = 5

OpenPermissions.ACCESS_GROUP_KEY = {
	[OpenPermissions.ACCESS_GROUP.USERGROUP] = Color(216,76,76),
	[OpenPermissions.ACCESS_GROUP.STEAMID] = Color(81,174,255),
	[OpenPermissions.ACCESS_GROUP.TEAM] = Color(76,216,76),
	[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION] = Color(76,76,216),
	[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY] = Color(255,163,71),
}

OpenPermissions.CHECKBOX = {}
OpenPermissions.CHECKBOX.INHERIT = 0
OpenPermissions.CHECKBOX.TICKED = 1
OpenPermissions.CHECKBOX.CROSSED = 2

--## Add resources ##--

if (SERVER) then
	resource.AddWorkshop("1603635147")
	for _,f in ipairs((file.Find("materials/openpermissions/*.vmt", "GAME"))) do
		resource.AddFile("materials/openpermissions/" .. f)
	end
end

local function IsDarkRPCheck()
	hook.Remove(SERVER and "PlayerConnect" or "InitPostEntity", "OpenPermissions.IsDarkRP")
	OpenPermissions.IsDarkRP = DarkRP and DarkRP.getCategories and RPExtraTeams and true
end
hook.Add(SERVER and "PlayerConnect" or "InitPostEntity", "OpenPermissions.IsDarkRP", IsDarkRPCheck)

--## Initialize files ##--
include("openpermissions/sh.lua")
if (SERVER) then
	AddCSLuaFile("openpermissions/thirdparty/pon.lua")
	AddCSLuaFile("openpermissions_config.lua")
	AddCSLuaFile("openpermissions_lua_functions.lua")
	AddCSLuaFile("openpermissions/sh.lua")
	AddCSLuaFile("openpermissions/cl.lua")

	include("openpermissions/sv.lua")
else
	include("openpermissions/cl.lua")
end
--addons/billy_gas/lua/openpermissions_lua_functions.lua:
--[[

	    __                   ______                 __  _                 
	   / /   __  ______ _   / ____/_  ______  _____/ /_(_)___  ____  _____
	  / /   / / / / __ `/  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
	 / /___/ /_/ / /_/ /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  ) 
	/_____/\__,_/\__,_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/  
	                                                                      

	Welcome to the Lua functions config.
	OpenPermissions has been designed to be as customizable as possible.
	In this configuration, you can define custom Lua functions which OpenPermissions can use.

	These Lua functions can be used as Access Groups, which allow you to assign permissions to people
	who successfully pass your own custom Lua code.

]]

return {
	["example_function"] = function(ply, permission_id)
		if (ply:SteamID() == "STEAM_0:1:40314158" or ply:SteamID64() == "76561198112561190") then
			return true -- allow!
		elseif (ply:SteamID() == "STEAM_0:1:7099") then
			return false -- disallow!
		else
			return -- ignore!
		end
	end,
}

--lua/autorun/protocol_droids_by_grady.lua:
player_manager.AddValidModel( "Protocol Droid Black", 		"models/starwars/grady/protocol_droids/protocol-black.mdl" );
player_manager.AddValidHands( "Protocol Droid Black", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Black", 	"models/starwars/grady/protocol_droids/protocol-black.mdl.mdl" );

player_manager.AddValidModel( "Protocol Droid Blue", 		"models/starwars/grady/protocol_droids/protocol-blue.mdl" );
player_manager.AddValidHands( "Protocol Droid Blue", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Blue", 		"models/starwars/grady/protocol_droids/protocol-blue.mdl" );

player_manager.AddValidModel( "Protocol Droid Cyan", 		"models/starwars/grady/protocol_droids/protocol-cyan.mdl" );
player_manager.AddValidHands( "Protocol Droid Cyan", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Cyan", 		"models/starwars/grady/protocol_droids/protocol-cyan.mdl" );

player_manager.AddValidModel( "Protocol Droid Green", 		"models/starwars/grady/protocol_droids/protocol-green.mdl" );
player_manager.AddValidHands( "Protocol Droid Green", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Green", 	"models/starwars/grady/protocol_droids/protocol-green.mdl" );

player_manager.AddValidModel( "Protocol Droid Killer", 		"models/starwars/grady/protocol_droids/protocol-killer.mdl" );
player_manager.AddValidHands( "Protocol Droid Killer", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Killer", 	"models/starwars/grady/protocol_droids/protocol-killer.mdl" );

player_manager.AddValidModel( "Protocol Droid Recycling", 	"models/starwars/grady/protocol_droids/protocol-recycling.mdl" );
player_manager.AddValidHands( "Protocol Droid Recycling", 	"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Recycling",	"models/starwars/grady/protocol_droids/protocol-recycling.mdl" );

player_manager.AddValidModel( "Protocol Droid Red", 		"models/starwars/grady/protocol_droids/protocol-red.mdl" );
player_manager.AddValidHands( "Protocol Droid Red", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Red", 		"models/starwars/grady/protocol_droids/protocol-red.mdl" );

player_manager.AddValidModel( "Protocol Droid Rust", 		"models/starwars/grady/protocol_droids/protocol-rust.mdl" );
player_manager.AddValidHands( "Protocol Droid Rust", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Rust", 		"models/starwars/grady/protocol_droids/protocol-rust.mdl" );

player_manager.AddValidModel( "Protocol Droid Silver", 		"models/starwars/grady/protocol_droids/protocol-silver.mdl" );
player_manager.AddValidHands( "Protocol Droid Silver", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Silver", 	"models/starwars/grady/protocol_droids/protocol-silver.mdl" );

player_manager.AddValidModel( "Protocol Droid Stripper", 	"models/starwars/grady/protocol_droids/protocol-stripper.mdl" );
player_manager.AddValidHands( "Protocol Droid Stripper", 	"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Stripper", 	"models/starwars/grady/protocol_droids/protocol-stripper.mdl" );

player_manager.AddValidModel( "Protocol Droid White", 		"models/starwars/grady/protocol_droids/protocol-white.mdl" );
player_manager.AddValidHands( "Protocol Droid White", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid White", 	"models/starwars/grady/protocol_droids/protocol-white.mdl" );
--addons/admin_sam/lua/autorun/sam.lua:
if SAM_LOADED then return end

local version = tonumber("156") or 156

sam = {}
sam.config = {}
sam.language = {}
sam.player = {}
sam.ranks = {}
sam.permissions = {}
sam.author = "Srlion"
sam.version = version

function sam.print(...)
	MsgC(
		Color(236, 240, 241), "(",
		Color(244, 67, 54), "SAM",
		Color(236, 240, 241), ") ",
		Color(236, 240, 241), ...
	) Msg("\n")
end

local FAILED = false
do
	local types = {
		sv_ = SERVER and include or function() end,
		cl_ = SERVER and AddCSLuaFile or include,
		sh_ = function(name)
			if SERVER then
				AddCSLuaFile(name)
			end
			return include(name)
		end
	}

	sam.load_file = function(name, type)
		if FAILED then return end

		if type and not type:EndsWith("_") then
			type = type .. "_"
		end

		local func = types[type] or types[name:GetFileFromFilename():sub(1, 3)] or types["sh_"]
		if func then
			local rets = {func(name)}
			if rets[1] == false then
				FAILED = true
				sam.print("Failed to load!")
			end
			return unpack(rets)
		end
	end
end
local load_file = sam.load_file

sam.print("Loading...")

load_file("sam/libs/sh_types.lua")
load_file("sam/libs/sh_pon.lua")
load_file("sam/libs/sh_mp.lua")

do
	local IsValid = IsValid
	local OLD_Player = Player

	-- this is because sam sends players' ids to the client, so if a player disconnects while net message is being sent
	-- the client will not know the player's name
	if CLIENT then
		local players = {}

		local Name = function(s)
			return s.name
		end

		local not_valid = function() return false end

		Player = function(id)
			local ply = OLD_Player(id)

			if not IsValid(ply) then
				local name = players[id]
				if name then
					return {
						name = name,
						Name = Name,
						IsValid = not_valid
					}
				end
			end

			return ply
		end

		hook.Add("OnEntityCreated", "SAM.GetPlayerName", function(ent)
			if ent:IsPlayer() and ent:IsValid() then
				ent.sam_userid = ent:UserID() -- userid is -1 in EntityRemoved?????
			end
		end)

		hook.Add("EntityRemoved", "SAM.GetPlayerName", function(ent)
			if not ent:IsPlayer() then return end

			local id = ent.sam_userid
			if not id then return end

			players[id] = ent:Name()

			timer.Simple(60, function()
				if not IsValid(ent) then
					players[id] = nil
				end
			end)
		end)
	end

	local sfs = load_file("sam/libs/sh_sfs.lua")
	sam.sfs = sfs

	local Encoder = sfs.Encoder
	local chars = sfs.chars
	local write = Encoder.write

	local CONSOLE
	CONSOLE = sfs.add_encoder("console", function(buf, color)
		write(buf, chars[CONSOLE])
	end)

	sfs.add_decoder(CONSOLE, function(ctx)
		ctx[1] = ctx[1] + 1
		return sam.console
	end)

	sfs.set_type_function(sam.type)

	Player = OLD_Player
end

load_file("sam/libs/sh_netstream.lua")
load_file("sam/libs/sh_async_netstream.lua")
load_file("sam/libs/sh_globals.lua")
load_file("sam/libs/sql/sv_init.lua")
sam.Promise = load_file("sam/libs/sh_promises.lua")

load_file("sam/sh_colors.lua")

load_file("sam/sh_util.lua")
load_file("sam/sh_lang.lua")
load_file("sam/sv_sql.lua")
load_file("sam/sh_permissions.lua")

load_file("sam/ranks/sh_ranks.lua")
load_file("sam/ranks/sv_ranks.lua")

load_file("sam/config/sh_config.lua")
load_file("sam/config/sv_config.lua")
load_file("sam/config/cl_config.lua")

load_file("sam/player/sh_player.lua")
load_file("sam/player/sh_nw_vars.lua")
load_file("sam/player/sv_player.lua")
load_file("sam/player/cl_player.lua")
load_file("sam/player/sv_ranks.lua")
load_file("sam/player/sv_auth.lua")
load_file("sam/player/sv_bans.lua")

load_file("sam/command/sh_command.lua")
load_file("sam/command/sv_command.lua")
load_file("sam/command/cl_command.lua")

for _, f in ipairs(file.Find("sam/command/arguments/*.lua", "LUA")) do
	load_file("sam/command/arguments/" .. f, "sh")
end

load_file("sam/sh_restrictions.lua")

load_file("sam/menu/sh_init.lua")
load_file("sam/menu/cl_init.lua")

load_file("sam/sh_motd.lua")

local modules = file.Find("sam/modules/*.lua", "LUA")
for _, module in ipairs(modules) do
	load_file("sam/modules/" .. module)
end

load_file("sam/reports/cl_reports.lua")
load_file("sam/reports/sv_reports.lua")

do
	if SERVER then
		hook.Add("SAM.LoadedConfig", "SAM.AdvertsMain", function(config)
			if not config.Adverts then
				sam.config.set("Adverts", {})
			end
		end)
	end
	load_file("sam/cl_adverts.lua")
end

if not FAILED then
	sam.print("Loaded!")
end

if SERVER then
	local path = "sam/importers/"

	concommand.Add("sam_import", function(ply, _, args)
		if IsValid(ply) then return end

		local admin_mod = args[1]
		if not admin_mod then
			sam.print("You need to provide an admin mod to import!")
			return
		end

		if not file.Exists(path .. admin_mod, "LUA") then
			sam.print("There is no importer for '" .. admin_mod .. "'")
			return
		end

		CompileFile(path .. admin_mod .. "/main.lua")()
	end, nil, nil, FCVAR_PROTECTED)
end

SAM_LOADED = true

hook.Run("SAM.LOADED")
--addons/admin_sam/lua/sam/libs/sh_promises.lua:
if SAM_LOADED then return end
-- not real promises, just really simple one

local isfunction = sam and sam.isfunction or isfunction

local null = {}

local Promise = {}

local PromiseMethods = {}
local Promise_meta = {__index = PromiseMethods}

function Promise.new()
	return setmetatable({
		value = null,
		null = null
	}, Promise_meta)
end

function Promise.IsPromise(v)
	return getmetatable(v) == Promise_meta
end

function PromiseMethods:resolve(v)
	if self.value ~= null then return end
	if self.done_callback then
		self.done_callback(v)
	else
		self.value = v
		self.callback = 0
	end
end

function PromiseMethods:reject(v)
	if self.value ~= null then return end
	if self.catch_callback then
		self.catch_callback(v)
	else
		self.value = v
		self.callback = 1
	end
end

function PromiseMethods:done(func)
	if isfunction(func) then
		if self.value ~= null and self.callback == 0 then
			func(self.value)
		else
			self.done_callback = func
		end
	end
	return self
end

function PromiseMethods:catch(func)
	if isfunction(func) then
		if self.value ~= null and self.callback == 1 then
			func(self.value)
		else
			self.catch_callback = func
		end
	end
	return self
end

return Promise
--addons/admin_sam/lua/sam/command/arguments/player.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local can_target_player = function(arg, admin, target, cmd, input)
	if not IsValid(target) or not target:IsPlayer() or not target:sam_get_nwvar("is_authed") then
		if input then
			admin:sam_send_message("cant_find_target", {
				S = input
			})
		end
		return false
	end

	if not arg.allow_higher_target and not admin:CanTarget(target) then
		if cmd then
			admin:sam_send_message("cant_target_player", {
				S = target:Name()
			})
		end
		return false
	end

	if arg.cant_target_self and admin == target then
		if cmd then
			admin:sam_send_message("cant_target_self", {
				S = cmd.name
			})
		end
		return false
	end

	return true
end

local check_text_match = function(text, ply)
	if ply:Name():lower():find(text, 1, true) then return true end
	if ply:GetUserGroup():lower():find(text, 1, true) then return true end
	if team.GetName(ply:Team()):lower():find(text, 1, true) then return true end

	if not ply:IsBot() then
		return ply:SteamID():lower():find(text, 1, true) or ply:SteamID64():lower():find(text, 1, true)
	end

	return false
end

command.new_argument("player")
	:OnExecute(function(arg, input, ply, cmd, result, n)
		if input == nil and arg.optional then
			if sam.isconsole(ply) then
				ply:sam_send_message("cant_target_self", {
					S = cmd.name
				})
				return false
			end
			result[n] = {ply, admin = ply, input = input}
			return
		end

		local single_target = arg.single_target
		local targets = {admin = ply, input = input}

		if input == "*" then
			if single_target then
				ply:sam_send_message("cant_target_multi_players")
				return false
			end
			local players = player.GetAll()
			for i = 1, #players do
				local v = players[i]
				if can_target_player(arg, ply, v) then
					table.insert(targets, v)
				end
			end
		elseif input:sub(1, 1) == "#" and not single_target then
			local tmp = {}
			for _, v in ipairs(input:sub(2):Trim():Split(",")) do
				v = tonumber(v)
				if not sam.isnumber(v) then continue end
				local target = Entity(v)
				if not tmp[target] and IsValid(target) and target:IsPlayer() then
					tmp[target] = true
					if can_target_player(arg, ply, target) then
						table.insert(targets, target)
					end
				end
			end
		else
			local target
			if input == "^" then
				target = ply
			elseif input == "@" and not sam.isconsole(ply) then
				target = ply:GetEyeTrace().Entity
			elseif sam.is_steamid(input) then
				target = player.GetBySteamID(input)
			elseif sam.is_steamid64(input) then
				target = player.GetBySteamID64(input)
			elseif input:sub(1, 1) == "#" then
				local index = input:sub(2):Trim()
				index = tonumber(index)

				if not isnumber(index) then
					ply:sam_send_message("invalid_id", {
						S = input
					})
					return false
				end

				target = Entity(index)

				if not IsValid(target) or not target:IsPlayer() then
					ply:sam_send_message("player_id_not_found", {
						S = index
					})
					return false
				end
			else
				if input:sub(1, 1) == "%" and #input > 1 then
					input = input:sub(2)
				end

				target = sam.player.find_by_name(input)
				if sam.istable(target) then
					if single_target then
						ply:sam_send_message("found_multi_players", {T = target})
						return false
					else
						for k, v in ipairs(target) do
							if can_target_player(arg, ply, v) then
								table.insert(targets, v)
							end
						end
						goto _end
					end
				end
			end

			if not can_target_player(arg, ply, target, cmd, input) then
				return false
			end

			table.insert(targets, target)
		end

		::_end::

		if #targets == 0 then
			ply:sam_send_message("cant_find_target", {
				S = input
			})
			return false
		end
		result[n] = targets
	end)

	-- Do NOT ask me about this code at all please because I feel shit about it but I'm not gonna make
	-- a file specially for this one
	:Menu(function(set_result, body, buttons, argument, childs)
		if body.ply_list then
			local ply_list = body.ply_list
			ply_list.argument = argument
			ply_list.set_result = set_result
			ply_list.multi_select = argument.single_target ~= true

			if argument.single_target == true and #ply_list:GetSelected() > 1 then
				ply_list:ClearSelection()
			end

			ply_list:OnRowSelected()
			ply_list:GetParent():Show()

			return
		end

		local SUI = sam.SUI

		local SetVisible = FindMetaTable("Panel").SetVisible

		local left_body = body:Add("SAM.Panel")
		left_body:Dock(LEFT)
		left_body:DockMargin(0, 0, 5, 0)
		left_body:SetWide(0)
		left_body.no_remove = true
		left_body.no_change = "player"

		SetVisible(left_body, false)
		left_body.SetVisible = function(s, visible)
			if visible == s:IsVisible() or visible == s.visible_state then return end

			if visible then
				SetVisible(s, true)
				s:InvalidateLayout(true)
			end

			s.visible_state = visible
			s:Stop()

			s:SizeTo(visible and SUI.Scale(320) or 0, -1, 0.2, 0, 0, function()
				SetVisible(s, visible)
				s:InvalidateParent(true)
			end)
		end
		left_body:Show()

		table.insert(childs, left_body)

		local ply_list = left_body:Add("SAM.ScrollPanel")
		ply_list:Dock(FILL)
		ply_list:Background(Color(34, 34, 34), 3)
		ply_list.argument = argument
		ply_list.set_result = set_result
		ply_list.multi_select = argument.single_target ~= true
		ply_list.Paint = function(s, w, h)
			s:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("text_entry_bg"))
		end

		local lines = {}
		function ply_list:OnClickLine(line, clear)
			local multi_select = ply_list.multi_select
			if not multi_select and not clear then return end

			if multi_select and input.IsKeyDown(KEY_LCONTROL) then
				if line.Selected then
					line.Selected = false
					self.main_selected_line = nil
					self:OnRowSelected()
					return
				end
				clear = false
			end

			if multi_select and input.IsKeyDown(KEY_LSHIFT) then
				local selected = self:GetSelectedLine()
				if selected then
					self.main_selected_line = self.main_selected_line or selected

					if clear then
						self:ClearSelection()
					end

					local first = math.min(self.main_selected_line.id, line.id)
					local last = math.max(self.main_selected_line.id, line.id)

					for id = first, last do
						local line_2 = lines[id]
						local was_selected = line_2.Selected

						line_2.Selected = true

						if not was_selected then
							self:OnRowSelected(line_2.id, line_2)
						end
					end

					return
				end
			end

			if not multi_select or clear then
				self:ClearSelection()
			end

			line.Selected = true

			self.main_selected_line = line
			self:OnRowSelected(line.id, line)
		end

		function ply_list:GetSelected()
			local ret = {}
			for _, v in ipairs(lines) do
				if v.Selected then
					table.insert(ret, v)
				end
			end
			return ret
		end

		function ply_list:GetSelectedLine()
			for _, line in ipairs(lines) do
				if line.Selected then return line end
			end
		end

		function ply_list:ClearSelection()
			for _, line in ipairs(lines) do
				line.Selected = false
			end
			self:OnRowSelected()
		end

		function ply_list:OnRowSelected()
			local plys = {}
			for k, v in ipairs(ply_list:GetSelected()) do
				plys[k] = v.ply:EntIndex()
			end
			if #plys == 0 then
				self.set_result(nil)
			else
				self.set_result("#" .. table.concat(plys, ","))
			end
		end

		function ply_list:OnRowRightClick(_, line)
			local dmenu = vgui.Create("SAM.Menu")
			dmenu:SetInternal(line)

			local name = line.ply:Name()
			dmenu:AddOption("Copy Name", function()
				SetClipboardText(name)
			end)

			dmenu:AddSpacer()

			local steamid = line.ply:SteamID()
			dmenu:AddOption("Copy SteamID", function()
				SetClipboardText(steamid)
			end)

			dmenu:AddOption("Copy SteamID64", function()
				SetClipboardText(util.SteamIDTo64(steamid))
			end)

			dmenu:Open()
			dmenu:SetPos(input.GetCursorPos())
		end

		local item_click = function(s)
			ply_list:OnClickLine(s, true)
		end

		local item_rightclick = function(s)
			if not s.Selected then
				ply_list:OnClickLine(s, true)
			end
			ply_list:OnRowRightClick(s.id, s)
		end

		local item_cursor = function(s)
			if input.IsMouseDown(MOUSE_LEFT) then
				ply_list:OnClickLine(s)
			end
		end

		local added_players = {}

		local add_player = function(ply, i)
			if can_target_player(ply_list.argument, LocalPlayer(), ply) then
				local player_button = ply_list:Add("SAM.Button")
				player_button:Dock(TOP)
				player_button:DockMargin(0, 0, 0, 2)
				player_button:DockPadding(4, 4, 4, 4)
				player_button:SetContained(false)
				player_button:SetText("")
				player_button:SetZPos(i)
				player_button.DoClick = item_click
				player_button.DoRightClick = item_rightclick
				player_button.OnCursorMoved = item_cursor

				local line = player_button:Add("SAM.PlayerLine")
				line:SetMouseInputEnabled(false)
				line:SetInfo({
					steamid = ply:IsBot() and "BOT" or ply:SteamID(),
					name = ply:Name(),
					rank = ply:GetUserGroup()
				})

				player_button:InvalidateLayout(true)
				player_button:SizeToChildren(false, true)

				player_button.ply = ply
				player_button.line = line
				player_button.id = table.insert(lines, player_button)
				body.search_entry:OnValueChange()

				added_players[ply] = true
			end
		end

		ply_list:On("Think", function()
			local players = player.GetAll()
			for i = 1, #players do
				local ply = players[i]
				if not added_players[ply] then
					add_player(ply, i)
				end
			end

			local argument = ply_list.argument
			for i = 1, #lines do
				local line = lines[i]
				local ply = line.ply

				if not can_target_player(argument, LocalPlayer(), ply) then
					line:Remove()
					table.remove(lines, i)
					added_players[ply] = nil
					ply_list:OnRowSelected()
					break
				end

				line = line.line
				line:SetName(ply:Name())
				line:SetRank(ply:GetUserGroup())
			end
		end)

		local search_entry = left_body:Add("SAM.TextEntry")
		search_entry:Dock(TOP)
		search_entry:DockMargin(0, 0, 0, 5)
		search_entry:SetPlaceholder("Search... (name/steamid/rank/job)")
		search_entry:SetBackground(Color(34, 34, 34))
		search_entry:SetTall(25)
		search_entry:SetNoBar(true)

		function search_entry:OnValueChange(text)
			if text == nil then
				text = self:GetValue()
			end
			if text ~= "" then
				ply_list:ClearSelection()
			end
			text = text:lower()
			for i, line in ipairs(lines) do
				local ply = line.ply
				if IsValid(ply) then
					line:SetVisible(check_text_match(text, ply))
				end
			end
			ply_list:GetCanvas():InvalidateLayout(true)
		end

		body.ply_list = ply_list
		body.search_entry = search_entry
	end)

	:AutoComplete(function(arg, result, name)
		local ply = LocalPlayer()
		for k, v in ipairs(player.GetAll()) do
			if can_target_player(arg, ply, v) and v:Name():lower():find(name, 1, true) then
				table.insert(result, "%" .. v:Name())
			end
		end
	end)
:End()

--addons/admin_sam/lua/sam/command/arguments/text.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("text")
	:OnExecute(function(argument, input, ply, _, result, i)
		if sam.isstring(input) then
			input = input:sub(1, 255)
		end

		local invalid = false
		if input == nil then
			if not argument.optional then
				invalid = true
			end
		elseif argument.check and not argument.check(input, ply) then
			invalid = true
		end

		if invalid then
			ply:sam_send_message("invalid", {
				S = argument.hint or "text", S_2 = input
			})
			return false
		end

		result[i] = input
	end)
	:Menu(function(set_result, body, buttons, argument)
		local text_entry = buttons:Add("SAM.TextEntry")
		text_entry:SetTall(25)

		local default = argument.default
		text_entry:SetCheck(function(text)
			local valid = true
			if text == "" then
				if default then
					text = default
				elseif not argument.optional then
					valid = false
				end
			elseif argument.check and not argument.check(text, LocalPlayer()) then
				valid = false
			end

			set_result(valid and text or nil)

			return valid
		end)

		local hint = argument.hint or "text"
		if default then
			hint = hint .. " = " .. tostring(default)
		end

		text_entry:SetPlaceholder(hint)

		return text_entry
	end)
:End()
--addons/admin_sam/lua/sam/menu/cl_init.lua:
if SAM_LOADED then return end

local vgui = vgui
local draw = draw

local sam = sam
local sui = sui
local TDLib = sui.TDLib

local config = sam.config

do
	local funcs = {
		["SAM.ComboBox"] = {
			event = "OnSelect",
			function(s, _, value)
				config.set(s.config_key, value)
			end
		},
		["SAM.TextEntry"] = {
			event = "OnEnter",
			function(s)
				local v = s:GetText()
				if s:GetNumeric() then
					v = tonumber(v)
				end
				config.set(s.config_key, v)
			end
		},
		["SAM.ToggleButton"] = {
			event = "OnChange",
			function(s, v)
				config.set(s.config_key, v)
			end
		}
	}

	sam.SUI = sam.SUI or sui.new("SAM", true, {
		SetConfig = function(s, key, default)
			s.config_key = key

			local i = config.hook({key}, function(value, old)
				local v = config.get(key, default)
				s:SetValue(v)
			end)

			local t = funcs[s:GetName()]
			s[t.event] = t[1]

			s:On("OnRemove", function()
				config.remove_hook(i)
			end)
		end
	})
end

local SUI = sam.SUI
local GetColor = SUI.GetColor

sam.menu = {}

local tabs = {}
function sam.menu.add_tab(icon, func, check, pos)
	local tab = {
		icon = icon,
		func = func,
		check = check,
		pos = pos
	}
	for k, v in ipairs(tabs) do
		if v.icon == icon then
			tabs[k] = tab
			return
		end
	end
	table.insert(tabs, tab)
end

function sam.menu.remove_tab(name)
	for k, v in ipairs(tabs) do
		if v.name == name then
			table.remove(tabs, k)
			break
		end
	end
end

SAM_TAB_TITLE_FONT = SUI.CreateFont("TabTitle", "Roboto Bold", 22)
SAM_TAB_DESC_FONT = SUI.CreateFont("TabDesc", "Roboto Medium", 15)

local MENU_LOADING = SUI.CreateFont("MenuLoading", "Roboto", 30)

SUI.AddToTheme("Dark", {
	frame = "#181818",

	scroll_panel = "#181818",

	menu_tabs_title = "#ffffff",

	--=--
	player_list_titles = "#f2f1ef",

	player_list_names = "#eeeeee",
	player_list_names_2 = "#ff6347",
	player_list_data = "#e8e8e8",

	player_list_rank = "#41b9ff",
	player_list_console = "#00c853",
	player_list_rank_text = "#2c3e50",

	player_list_steamid = "#a4a4a4",
	--=--

	--=--
	actions_button = Color(0, 0, 0, 0),
	actions_button_hover = Color(200, 200, 200, 60),

	actions_button_icon = "#aaaaaa",
	actions_button_icon_hover = "#ffffff",
	--=--

	--=--
	page_switch_bg = "#222222",
	--=--
})

SUI.SetTheme("Dark")

function SUI.panels.Frame:Paint(w, h)
	if GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	draw.RoundedBox(8, 0, 0, w, h, GetColor("frame"))
end

function SUI.panels.Frame:HeaderPaint(w, h)
	draw.RoundedBoxEx(8, 0, 0, w, h, GetColor("header"), true, true, false, false)
	draw.RoundedBox(0, 0, h - 1, w, 1, GetColor("line"))
end

do
	function sam.menu.add_loading_panel(parent)
		local is_loading = false

		local loading_panel = parent:Add("Panel")
		loading_panel:SetVisible(false)
		loading_panel:SetZPos(999999)
		loading_panel:SetMouseInputEnabled(false)

		function loading_panel:Paint(w, h)
			draw.RoundedBox(3, 0, 0, w, h, Color(50, 50, 50, 200))
			draw.SimpleText(string.rep(".", (CurTime() * 3) % 3), MENU_LOADING, w/2, h/2, Color(200, 200, 200, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		parent:SUI_TDLib()
		parent:On("PerformLayout", function(s, w, h)
			loading_panel:SetSize(w, h)
		end)

		local first = true
		local toggle_loading = function(bool)
			if not IsValid(loading_panel) then return end

			is_loading = bool or not is_loading
			if is_loading and not first then
				loading_panel:SetVisible(is_loading and true or false)
				loading_panel:SetMouseInputEnabled(is_loading)
			else
				timer.Simple(0.2, function()
					if not IsValid(loading_panel) then return end
					loading_panel:SetVisible(is_loading and true or false)
					loading_panel:SetMouseInputEnabled(is_loading)
				end)
			end

			first = false
		end

		return toggle_loading, function()
			return is_loading
		end
	end
end

local sam_menu
function sam.menu.open_menu()
	if IsValid(sam_menu) then
		return sam_menu:IsVisible() and sam_menu:Hide() or sam_menu:Show()
		-- sam_menu:Remove()
	end

	sam_menu = vgui.Create("SAM.Frame")
	sam_menu:Center()
	sam_menu:MakePopup()
	sam_menu:SetTitle("SAM")

	sam_menu:AddAnimations(800, 600)

	sam_menu.close.DoClick = function()
		sam_menu:Hide()
	end

	local sheet = sam_menu:Add("SAM.ColumnSheet")
	sheet:Dock(FILL)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)
	sheet.Paint = nil

	local tab_scroller = sheet.tab_scroller
	tab_scroller:DockMargin(0, 1, 0, 1)

	function tab_scroller:Paint(w, h)
		draw.RoundedBoxEx(8, 0, 0, w, h, GetColor("column_sheet_bar"), false, false, true, false)
	end

	local sheets = {}
	for _, v in SortedPairsByMemberValue(tabs, "pos") do
		sheets[v.icon] = sheet:AddSheet(v.icon, v.func)
	end

	tab_scroller = tab_scroller:GetCanvas()
	sam_menu:On("Think", function()
		for _, v in ipairs(tabs) do
			local tab = sheets[v.icon]
			if v.check and not v.check() then
				if tab:IsVisible() then
					tab:SetVisible(false)
					if sheet:GetActiveTab() == tab then
						sheet:SetActiveTab(sheet.tabs[1])
					end
					tab_scroller:InvalidateLayout()
				end
			elseif not tab:IsVisible() then
				tab:SetVisible(true)
				tab_scroller:InvalidateLayout()
			end
		end
	end)
end

function sam.menu.get()
	return sam_menu
end

hook.Add("GUIMouseReleased", "SAM.CloseMenu", function(mouse_code)
	local panel = vgui.GetHoveredPanel()
	if mouse_code == MOUSE_LEFT and panel == vgui.GetWorldPanel() and IsValid(sam_menu) and sam_menu:HasHierarchicalFocus() then
		sam_menu:Hide()
	end
end)

for _, f in ipairs(file.Find("sam/menu/tabs/*.lua", "LUA")) do
	sam.load_file("sam/menu/tabs/" .. f, "sh")
end
--addons/admin_sam_sui/lua/sui/vgui/sui_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_bValue", "Value", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMin", "Min", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMax", "Max", FORCE_NUMBER)
AccessorFunc(Panel, "m_bDecimals", "Decimals", FORCE_NUMBER)


AccessorFunc(Panel, "m_fSlideX", "SlideX")
AccessorFunc(Panel, "m_fSlideY", "SlideY")

AccessorFunc(Panel, "m_iLockX", "LockX")
AccessorFunc(Panel, "m_iLockY", "LockY")

AccessorFunc(Panel, "Dragging", "Dragging")

function Panel:Init()
	self:ScaleInit()

	self:SetSlideX(0.5)
	self:SetSlideY(0.5)

	self:SetMouseInputEnabled(true)
	self:SetMin(0)
	self:SetMax(10)
	self:SetValue(1)
	self:SetDecimals(1)

	self:SetSize(100, 12)

	self.rounded_box = {}

	self.Knob = vgui.Create("DButton", self)
	self.Knob:SetText("")
	self.Knob:SetSize(15, 15)
	self.Knob:NoClipping(true)
	self.Knob.Paint = self.KnobPaint
	self.Knob.OnCursorMoved = function(panel, x, y)
		x, y = panel:LocalToScreen(x, y)
		x, y = self:ScreenToLocal(x, y)
		self:OnCursorMoved(x, y)
	end
	self.Knob.circle = {}

	self:SetLockY(0.5)
end

function Panel:IsEditing()
	return self.Dragging or self.Knob.Depressed
end

function Panel:SetEnabled(b)
	self.Knob:SetEnabled(b)
	FindMetaTable("Panel").SetEnabled(self, b) -- There has to be a better way!
end

function Panel:OnCursorMoved(x, y)
	if (not self.Dragging and not self.Knob.Depressed) then return end

	local w, h = self:GetSize()
	local iw, ih = self.Knob:GetSize()

	w = w - iw
	h = h - ih

	x = x - iw * 0.5
	y = y - ih * 0.5

	x = math.Clamp(x, 0, w) / w
	y = math.Clamp(y, 0, h) / h

	if self.m_iLockX then x = self.m_iLockX end
	if self.m_iLockY then y = self.m_iLockY end

	x, y = self:TranslateValues(x, y)

	self:SetSlideX(x)
	self:SetSlideY(y)

	self:InvalidateLayout()
end

function Panel:OnMousePressed(mcode)
	if not self:IsEnabled() then return true end

	-- When starting dragging with not pressing on the knob.
	self.Knob.Hovered = true

	self:SetDragging(true)
	self:MouseCapture(true)

	local x, y = self:CursorPos()
	self:OnCursorMoved(x, y)
end

function Panel:OnMouseReleased(mcode)
	-- This is a hack. Panel.Hovered is not updated when dragging a panel (Source's dragging, not Lua Drag'n'drop)
	self.Knob.Hovered = vgui.GetHoveredPanel() == self.Knob

	self:SetDragging(false)
	self:MouseCapture(false)
end

function Panel:SetMinMax(min, max)
	self:SetMin(min)
	self:SetMax(max)
end

function Panel:TranslateValues(x, y)
	self:SetValue(self:GetMin() + (x * self:GetRange()))
	return self:GetFraction(), y
end

function Panel:GetFraction()
	return (self:GetValue() - self:GetMin()) / self:GetRange()
end

function Panel:SetValue(val)
	val = math.Clamp(val, self:GetMin(), self:GetMax())
	val = math.Round(val, self:GetDecimals())

	self.m_bValue = val
	self:SetSlideX((val - self:GetMin()) / self:GetRange())

	self:OnValueChanged(val)
end

function Panel:OnValueChanged(val)
end

function Panel:GetRange()
	return self:GetMax() - self:GetMin()
end

function Panel:Paint(w, h)
	local _h = SUI.Scale(2)
	TDLib.RoundedBox(self.rounded_box, 3, 0, h / 2 - _h / 2, w, _h, SUI.GetColor("slider_track"))
end

function Panel:KnobPaint(w, h)
	if self.Depressed then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_pressed"))
	elseif self.Hovered then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_hover"))
	end

	TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 2, SUI.GetColor("slider_knob"))
end

function Panel:PerformLayout(w, h)
	local knob_size = SUI.Scale(12)
	self.Knob:SetSize(knob_size, knob_size)

	w = w - knob_size
	h = h - knob_size
	self.Knob:SetPos((self.m_fSlideX or 0) * w, (self.m_fSlideY or 0) * h)
end

function Panel:SetSlideX(i)
	self.m_fSlideX = i
	self:InvalidateLayout()
end

function Panel:SetSlideY(i)
	self.m_fSlideY = i
	self:InvalidateLayout()
end

function Panel:GetDragging()
	return self.Dragging or self.Knob.Depressed
end

sui.register("Slider", Panel, "Panel")

--addons/admin_sam/lua/sam/menu/tabs/bans.lua:
if SAM_LOADED then return end

local sam = sam
local SQL = sam.SQL
local SUI = sam.SUI
local netstream = sam.netstream

sam.permissions.add("manage_bans", nil, "superadmin")

local get_pages_count = function(bans_count)
	bans_count = bans_count / 35
	local i2 = math.floor(bans_count)
	return bans_count ~= i2 and i2 + 1 or bans_count
end

if SERVER then
	local check = function(ply)
		return ply:HasPermission("manage_bans") and ply:sam_check_cooldown("MenuManageBans", 0.1)
	end

	local limit = 35

	local get_page_count = function(res, callback, page, order_by, keyword)
		local current_time = os.time()
		local query = [[
			SELECT
				COUNT(`steamid`) AS `count`
			FROM
				`sam_bans`
			WHERE
				(`unban_date` >= %d OR `unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		SQL.Query(query, callback, true, {res, page, order_by, keyword, current_time})
	end

	local resolve_promise = function(data, arguments)
		local res = arguments[1]
		arguments[1] = data
		res(arguments)
	end

	local get_bans = function(count_data, arguments)
		local res, page, order_by, keyword, current_time = unpack(arguments)
		local count = count_data.count

		local current_page
		if page < 1 then
			page, current_page = 1, 1
		end

		local pages_count = get_pages_count(count)
		if page > pages_count then
			page, current_page = pages_count, pages_count
		end

		local query = [[
			SELECT
				`sam_bans`.*,
				IFNULL(`p1`.`name`, '') AS `name`,
				IFNULL(`p2`.`name`, '') AS `admin_name`
			FROM
				`sam_bans`
			LEFT OUTER JOIN
				`sam_players` AS `p1`
			ON
				`sam_bans`.`steamid` = `p1`.`steamid`
			LEFT OUTER JOIN
				`sam_players` AS `p2`
			ON
				`sam_bans`.`admin` = `p2`.`steamid`
			WHERE
				(`sam_bans`.`unban_date` >= %d OR `sam_bans`.`unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `sam_bans`.`steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		local offset = math.abs(limit * (page - 1))
		query = query .. ([[
			ORDER BY
				`sam_bans`.`id` %s
			LIMIT
				%d OFFSET %d]]):format(order_by, limit, offset)

		SQL.Query(query, resolve_promise, nil, {res, count, current_page})
	end

	netstream.async.Hook("SAM.GetBans", function(res, ply, page, order_by, keyword)
		if not isnumber(page) then return end
		if order_by ~= "ASC" and order_by ~= "DESC" then return end
		if keyword ~= nil and not sam.isstring(keyword) then return end

		get_page_count(res, get_bans, page, order_by, keyword)
	end, check)

	return
end

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)
local LINE_FONT = SUI.CreateFont("Line", "Roboto", 16)
local NEXT_FONT = SUI.CreateFont("NextButton", "Roboto", 18)

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/ban-user.png", function(column_sheet)
	local refresh, pages
	local current_page, current_order, keyword = nil, "DESC", nil

	local bans_body = column_sheet:Add("Panel")
	bans_body:Dock(FILL)
	bans_body:DockMargin(0, 1, 0, 0)
	bans_body:DockPadding(10, 10, 10, 10)

	local toggle_loading, is_loading = sam.menu.add_loading_panel(bans_body)

	local title = bans_body:Add("SAM.Label")
	title:Dock(TOP)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Bans")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = bans_body:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(0, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText("60 total bans")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SetPos(10, SUI.Scale(40))
	total:SizeToContents()

	do
		local container = bans_body:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(0, 6, 10, 0)
		container:SetTall(30)

		local sort_order = container:Add("SAM.ComboBox")
		sort_order:Dock(RIGHT)
		sort_order:SetWide(96)
		sort_order:SetValue("Desc")
		sort_order:AddChoice("Desc")
		sort_order:AddChoice("Asc")

		function sort_order:OnSelect(_, value)
			value = value:upper()
			if current_order ~= value then
				current_order = value
				refresh()
			end
		end

		local search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)

		function search_entry:OnEnter()
			local value = self:GetValue()
			if keyword ~= value then
				keyword = value ~= "" and value or nil
				refresh()
			end
		end
	end

	Line(bans_body, nil, -5, 15, -5, 0)

	do
		local columns = bans_body:Add("Panel")
		columns:Dock(TOP)
		columns:DockMargin(0, 10, 0, 0)

		local info = columns:Add("SAM.Label")
		info:Dock(LEFT)
		info:DockMargin(4, 0, 0, 0)
		info:SetFont(COLUMN_FONT)
		info:SetText("Player")
		info:SetTextColor(GetColor("player_list_titles"))
		info:SetWide(SUI.Scale(280) + SUI.Scale(34))
		info:SizeToContentsY(3)

		local time_left = columns:Add("SAM.Label")
		time_left:Dock(LEFT)
		time_left:DockMargin(-4, 0, 0, 0)
		time_left:SetFont(COLUMN_FONT)
		time_left:SetText("Time Left")
		time_left:SetTextColor(GetColor("player_list_titles"))
		time_left:SetWide(SUI.Scale(180))
		time_left:SizeToContentsY(3)

		local reason = columns:Add("SAM.Label")
		reason:Dock(LEFT)
		reason:DockMargin(-4, 0, 0, 0)
		reason:SetFont(COLUMN_FONT)
		reason:SetText("Reason")
		reason:SetTextColor(GetColor("player_list_titles"))
		reason:SetWide(SUI.Scale(280))
		reason:SizeToContentsY(3)

		columns:SizeToChildren(false, true)
	end

	local body = bans_body:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(0, 10, 0, 0)
	body:SetVBarPadding(6)

	local set_data = function(data)
		body:GetCanvas():Clear()
		body.VBar.Scroll = 0

		local bans, bans_count, current_page_2 = unpack(data)
		total:SetText(bans_count .. " total bans")

		pages = get_pages_count(bans_count)
		current_page.i = pages == 0 and 0 or current_page_2 or current_page.i
		current_page:SetText(current_page.i .. "/" .. pages)

		body:Line()

		for k, v in ipairs(bans) do
			local line = body:Add("SAM.PlayerLine")
			line:DockMargin(0, 0, 0, 10)

			local name = v.name ~= "" and v.name or nil
			local admin_name = v.admin_name ~= "" and v.admin_name or nil
			line:SetInfo({
				steamid = v.steamid,
				name = name,
				rank = admin_name or (v.admin == "Console" and "Console"),
				rank_bg = not admin_name and GetColor("player_list_console")
			})

			local unban_date = tonumber(v.unban_date)
			local time_left = line:Add("SAM.Label")
			time_left:Dock(LEFT)
			time_left:DockMargin(-3, 0, 0, 0)
			time_left:SetFont(LINE_FONT)
			time_left:SetText(unban_date == 0 and "Never" or sam.reverse_parse_length((unban_date - os.time()) / 60))
			time_left:SetTextColor(GetColor("player_list_data"))
			time_left:SetContentAlignment(4)
			time_left:SetWide(SUI.Scale(180))

			local reason = line:Add("SAM.Label")
			reason:Dock(LEFT)
			reason:DockMargin(4, 0, 0, 0)
			reason:SetFont(LINE_FONT)
			reason:SetText(v.reason)
			reason:SetTextColor(GetColor("player_list_data"))
			reason:SetContentAlignment(4)
			reason:SetWrap(true)
			reason:SetWide(SUI.Scale(200))

			local old_tall = line.size
			function reason:PerformLayout()
				local _, h = self:GetTextSize()
				if old_tall < h then
					line:SetTall(h)
				end
			end

			local but = line:Actions()
			but:On("DoClick", function()
				local dmenu = vgui.Create("SAM.Menu")
				dmenu:SetInternal(but)
				if name then
					dmenu:AddOption("Copy Name", function()
						SetClipboardText(name)
					end)
				end
				dmenu:AddOption("Copy SteamID", function()
					SetClipboardText(v.steamid)
				end)
				dmenu:AddOption("Copy Reason", function()
					SetClipboardText(v.reason)
				end)
				dmenu:AddOption("Copy Time Left", function()
					SetClipboardText(time_left:GetText())
				end)

				if v.admin ~= "Console" then
					dmenu:AddSpacer()

					if admin_name then
						dmenu:AddOption("Copy Admin Name", function()
							SetClipboardText(admin_name)
						end)
					end

					dmenu:AddOption("Copy Admin SteamID", function()
						SetClipboardText(v.admin)
					end)
				end

				if LocalPlayer():HasPermission("unban") then
					dmenu:AddSpacer()
					dmenu:AddOption("Unban", function()
						local user = name and ("%s (%s)"):format(name, v.steamid) or v.steamid
						local querybox = vgui.Create("SAM.QueryBox")
						querybox:SetWide(350)
						querybox:SetTitle(user)

						local check = querybox:Add("SAM.Label")
						check:SetText(sui.wrap_text("Are you sure that you want to unban\n" .. user, LINE_FONT, SUI.Scale(350)))
						check:SetFont(LINE_FONT)
						check:SizeToContents()

						querybox:Done()
						querybox.save:SetEnabled(true)
						querybox.save:SetText("UNBAN")

						querybox.save:SetContained(false)
						querybox.save:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))

						querybox.cancel:SetContained(true)
						querybox.cancel:SetColors()

						querybox:SetCallback(function()
							RunConsoleCommand("sam", "unban", v.steamid)
						end)
					end)
				end
				dmenu:Open()
			end)

			body:Line()
		end

		body:InvalidateLayout(true)
		body:GetCanvas():InvalidateLayout(true)
	end

	refresh = function()
		if not is_loading() and LocalPlayer():HasPermission("manage_bans") then
			local refresh_query = netstream.async.Start("SAM.GetBans", toggle_loading, current_page.i, current_order, keyword)
			refresh_query:done(set_data)
		end
	end

	local bottom_panel = bans_body:Add("SAM.Panel")
	bottom_panel:Dock(BOTTOM)
	bottom_panel:DockMargin(0, 6, 0, 0)
	bottom_panel:SetTall(30)
	bottom_panel:Background(GetColor("page_switch_bg"))

	local previous_page = bottom_panel:Add("SAM.Button")
	previous_page:Dock(LEFT)
	previous_page:SetWide(30)
	previous_page:SetText("<")
	previous_page:SetFont(NEXT_FONT)

	previous_page:On("DoClick", function()
		if current_page.i <= 1 then return end

		current_page.i = current_page.i - 1
		refresh()
	end)

	current_page = bottom_panel:Add("SAM.Label")
	current_page:Dock(FILL)
	current_page:SetContentAlignment(5)
	current_page:SetFont(SAM_TAB_DESC_FONT)
	current_page:SetText("loading...")
	current_page.i = 1

	local next_page = bottom_panel:Add("SAM.Button")
	next_page:Dock(RIGHT)
	next_page:SetWide(30)
	next_page:SetText(">")
	next_page:SetFont(NEXT_FONT)

	next_page:On("DoClick", function()
		if current_page.i == pages then return end

		current_page.i = current_page.i + 1
		refresh()
	end)

	function bottom_panel:Think()
		next_page:SetEnabled(current_page.i ~= pages)
		previous_page:SetEnabled(current_page.i > 1)
	end

	for k, v in ipairs({"SAM.BannedPlayer", "SAM.BannedSteamID", "SAM.EditedBan", "SAM.UnbannedSteamID"}) do
		hook.Add(v, "SAM.MenuBans", function()
			if IsValid(body) then
				refresh()
			end
		end)
	end

	refresh()

	return bans_body
end, function()
	return LocalPlayer():HasPermission("manage_bans")
end, 4)
--addons/admin_sam/lua/sam/menu/tabs/commands.lua:
if SAM_LOADED then return end
if SERVER then return end

local sam = sam
local SUI = sam.SUI
local type = sam.type

local Line = sui.TDLib.LibClasses.Line

local COMMAND_HELP = SUI.CreateFont("CommandHelp", "Roboto", 14)
local COMMAND_RUN = SUI.CreateFont("CommandRun", "Roboto Medium", 14)

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/command_window.png", function(column_sheet)
	local tab_body = column_sheet:Add("Panel")
	tab_body:Dock(FILL)
	tab_body:DockMargin(0, 1, 0, 0)

	do
		local title = tab_body:Add("SAM.Label")
		title:Dock(TOP)
		title:DockMargin(10, 10, 0, 0)
		title:SetFont(SAM_TAB_TITLE_FONT)
		title:SetText("Commands")
		title:SetTextColor(SUI.GetColor("menu_tabs_title"))
		title:SizeToContents()
	end

	local body = tab_body:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(10, 5, 10, 10)

	Line(body)

	local left_body = body:Add("SAM.Panel")
	left_body:Dock(LEFT)
	left_body:SetWide(148)

	local search_entry = left_body:Add("SAM.TextEntry")
	search_entry:Dock(TOP)
	search_entry:SetNoBar(true)
	search_entry:SetPlaceholder("Search...")
	search_entry:SetRadius(4)
	search_entry:SetTall(27)

	local category_list = left_body:Add("SAM.CollapseCategory")
	category_list:Dock(FILL)
	category_list:DockMargin(0, SUI.Scale(10), 0, 0)

	local canvas = category_list:GetCanvas()

	local commands_refresh = function()
		if not IsValid(category_list) then return end

		canvas:Clear()
		table.Empty(category_list.items)
		table.Empty(category_list.categories)

		for k, v in ipairs(sam.command.get_commands()) do
			if (v.permission and not LocalPlayer():HasPermission(v.permission)) or v.menu_hide then
				continue
			end

			local item = category_list:add_item(v.name, v.category)
			item:InvalidateParent(true)
			item.help = v.help
			item.command = v

			item.names = {v.name:lower()}
			for _, aliase in ipairs(v.aliases) do
				table.insert(item.names, aliase:lower())
			end
		end
	end
	commands_refresh()

	do
		local hooks = {
			"SAM.CommandAdded", "SAM.CommandModified", "SAM.CommandRemoved",
			"SAM.RemovedPermission",
			{"SAM.ChangedPlayerRank", func = function(ply, rank, old_rank)
				if rank == old_rank then return end
				if ply == LocalPlayer() then
					commands_refresh()
				end
			end},
			{
				"SAM.RankPermissionGiven", "SAM.RankPermissionTaken", "SAM.ChangedInheritRank",
				func = function(rank)
					if rank == LocalPlayer():GetUserGroup() then
						commands_refresh()
					end
				end
			},
			{
				"SAM.AddedPermission", "SAM.PermissionModified",
				func = function(_, _, rank)
					if rank == LocalPlayer():GetUserGroup() then
						commands_refresh()
					end
				end
			}
		}
		for _, v in ipairs(hooks) do
			if type(v) == "table" then
				for _, v2 in ipairs(v) do
					hook.Add(v2, "SAM.Menu.RefreshCommands", v.func)
				end
			else
				hook.Add(v, "SAM.Menu.RefreshCommands", commands_refresh)
			end
		end
	end

	function search_entry:OnValueChange(text)
		category_list:Search(text:lower())
	end

	do
		local line = Line(body, LEFT)
		line:DockMargin(10, 0, 10, 0)
		line:SetWide(1)
	end

	local buttons = body:Add("SAM.ScrollPanel")
	buttons:Dock(FILL)

	local childs = {}
	local pos = 0
	buttons:GetCanvas():On("OnChildAdded", function(s, child)
		child:Dock(TOP)
		child:DockMargin(0, 0, 0, 5)
		child:SetAlpha(0)
		child:SetVisible(false)
		table.insert(childs, child)

		pos = pos + 1
		child:SetZPos(pos)
	end)

	local run_command = buttons:Add("SAM.Button")
	run_command:Dock(TOP)
	run_command:SetTall(25)
	run_command:SetFont(COMMAND_RUN)
	run_command:SetZPos(100)
	run_command:SetEnabled(false)

	run_command:On("DoClick", function(self)
		LocalPlayer():ConCommand("sam\"" .. self:GetText() .. "\"\"" .. table.concat(self.input_arguments, "\"\"") .. "\"")
	end)

	local help = buttons:Add("SAM.Label")
	help:Dock(TOP)
	help:SetFont(COMMAND_HELP)
	help:SetZPos(101)
	help:SetWrap(true)
	help:SetAutoStretchVertical(true)

	sam.menu.get():On("OnKeyCodePressed", function(s, key_code)
		if key_code == KEY_ENTER and IsValid(run_command) and run_command:IsEnabled() and run_command:IsMouseInputEnabled() and tab_body:IsVisible() then
			run_command:DoClick()
		end
	end)

	function category_list:item_selected(item)
		local arguments = sam.command.get_arguments()
		local command = item.command
		local command_arguments = command.args
		local input_arguments = {}

		for i = #childs, 3, -1 do
			local v = childs[i]
			if not v.no_change or not command:HasArg(v.no_change) then
				if v.no_remove ~= true then
					v:Remove()
				else
					v:Hide()
				end
			end
		end

		local NIL = {}
		for _, v in ipairs(command_arguments) do
			local func = arguments[v.name]["menu"]
			if not func then continue end

			local i = table.insert(input_arguments, NIL)
			local p = func(function(allow)
				if not IsValid(run_command) then return end
				input_arguments[i] = allow == nil and NIL or allow
				for i_2 = 1, #input_arguments do
					if input_arguments[i_2] == NIL then
						run_command:SetEnabled(false)
						return
					end
				end
				run_command:SetEnabled(true)
			end, body, buttons, v, childs)
			if p then
				p:AnimatedSetVisible(true)
			end
		end

		if #command_arguments == 0 then
			run_command:SetEnabled(true)
		end

		run_command:SetText(command.name)
		run_command:AnimatedSetVisible(true)
		run_command.input_arguments = input_arguments

		if command.help then
			help:SetText(command.help)
			help:AnimatedSetVisible(true)
			help:SizeToContents()
		else
			help:AnimatedSetVisible(false)
		end

		buttons:InvalidateLayout(true)
	end

	return tab_body
end, nil, 1)

--addons/admin_sam/lua/sam/modules/ttt.lua:
if SAM_LOADED then return end

local run = function(fn)
	if not GAMEMODE then
		timer.Simple(0, fn)
	else
		fn()
	end
end

run(function()
	if engine.ActiveGamemode() ~= "terrortown" then return end

	local sam, command, language = sam, sam.command, sam.language

	command.set_category("TTT")

	command.new("setslays")
		:SetPermission("setslays", "admin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", optional = true, min = 1, default = 1, round = true})

		:Help("setslays_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:sam_set_pdata("slays_amount", amount)

			sam.player.send_message(nil, "setslays", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	command.new("removeslays")
		:SetPermission("removeslays", "admin")

		:AddArg("player", {single_target = true})

		:Help("removeslays_help")

		:OnExecute(function(ply, targets, amount)
			local target = targets[1]
			target:sam_set_pdata("slays_amount", nil)
			target:SetForceSpec(false)

			sam.player.send_message(nil, "removeslays", {
				A = ply, T = targets
			})
		end)
	:End()

	OldBeginRound = OldBeginRound or BeginRound
	function BeginRound(...)
		local players = player.GetAll()
		for i = 1, #players do
			local ply = players[i]

			local slays = ply:sam_get_pdata("slays_amount")
			if not slays then continue end

			if not ply:IsSpec() then
				ply:Kill()
			end

			GAMEMODE:PlayerSpawnAsSpectator(ply)

			ply:SetTeam(TEAM_SPEC)
			ply:SetForceSpec(true)
			ply:Spawn()

			ply:SetRagdollSpec(false) -- dying will enable this, we don't want it here

			slays = slays - 1

			if slays == 0 then
				timer.Simple(0, function()
					ply:SetForceSpec(false)
				end)
				ply:sam_set_pdata("slays_amount", nil)
			else
				ply:sam_set_pdata("slays_amount", slays)
			end

			sam.player.send_message(nil, "setslays_slayed", {
				T = {ply}, V = slays
			})
		end

		return OldBeginRound(...)
	end
end)
--addons/joes_stuff/lua/shieldsystem/cl_renderswrpshield.lua:
local shieldmat = Material( "effects/shieldgen/joeisgay" )
local col1 = Color(50,50,255,255)

hook.Add( "PostDrawTranslucentRenderables", "SWRPShield:DrawLasers", function( bDepth, bSkybox )
    if bSkybox then return end
    for ent,_ in pairs(SWRPShield.ents) do
        if not IsValid(ent) then continue end
        if ent:GetSequence() != 3 then continue end
        local bone = ent:LookupBone( "gen" )
        if not bone or bone == -1 then return end
        local StartPos = ent:GetBonePosition(bone)
        if not StartPos then return end
        render.SetMaterial( shieldmat )
        render.DrawBeam( StartPos, StartPos + Vector(0,0,ent.laserlength) , 3 + math.Rand(0,2), 1, 0, col1 )
        render.DrawBeam( StartPos, StartPos + Vector(0,0,ent.laserlength) , 1 + math.Rand(0.5,1), 1, 0, color_white )
    end
end )
--addons/aocrp_pixelui/lua/pixelui/drawing/cl_text.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local ceil = math.ceil
local setFont = PIXEL.SetFont
local getTextSize = PIXEL.GetTextSize
local setTextPos = surface.SetTextPos
local setTextColor = surface.SetTextColor
local drawText = surface.DrawText

function PIXEL.DrawSimpleText(text, font, x, y, col, xAlign, yAlign)
    setFont(font)
    local w, h = getTextSize(text)

    if xAlign == 1 then
        x = x - w / 2
    elseif xAlign == 2 then
        x = x - w
    end

    if yAlign == 1 then
        y = y - h / 2
    elseif yAlign == 4 then
        y = y - h
    end

    setTextPos(ceil(x), ceil(y))
    setTextColor(col.r, col.g, col.b, col.a)
    drawText(text)

    return w, h
end

local drawSimpleText = PIXEL.DrawSimpleText
local gmatch = string.gmatch
local find = string.find
local max = math.max
local select = select

function PIXEL.DrawText(text, font, x, y, col, xAlign, yAlign)
    local curX = x
    local curY = y

    setFont(font)
    local lineHeight = select(2, getTextSize("\n"))
    local tabWidth = 50

    for str in gmatch(text, "[^\n]*") do
        if #str > 0 then
            if find(str, "\t") then
                for tabs, str2 in gmatch(str, "(\t*)([^\t]*)") do
                    curX = ceil((curX + tabWidth * max(#tabs - 1, 0 )) / tabWidth) * tabWidth

                    if #str2 > 0 then
                        drawSimpleText(str2, font, curX, curY, col, xAlign)
                        curX = curX + getTextSize(str2)
                    end
                end
            else
                drawSimpleText(str, font, curX, curY, col, xAlign)
            end
        else
            curX = x
            curY = curY + lineHeight / 2
        end
    end
end

function PIXEL.DrawShadowText(text, font, x, y, col, xAlign, yAlign, depth, shadow)
    shadow = shadow or 50

    for i = 1, depth do
        drawSimpleText(text, font, x + i, y + i, Color(0, 0, 0, i * shadow), xAlign, yAlign)
    end

    drawSimpleText(text, font, x, y, col, xAlign, yAlign)
end

local drawShadowText = PIXEL.DrawShadowText

function PIXEL.DrawDualText(title, subtitle, x, y, h)
    x = x or 0
    y = y or 0

    setFont(title[2])
    local tH = select(2, getTextSize(title[1]))

    setFont(subtitle[2])
    local sH = select(2, getTextSize(subtitle[1]))

    drawShadowText(title[1], title[2], x, y - sH / 2, title[3], title[4], 1, title[5], title[6])
    drawShadowText(subtitle[1], subtitle[2], x, y + tH / 2, subtitle[3], subtitle[4], 1, subtitle[5], subtitle[6])
end

local textWrapCache = {}

local function charWrap(text, remainingWidth, maxWidth)
    local totalWidth = 0

    text = text:gsub(".", function(char)
        totalWidth = totalWidth + getTextSize(char)

        if totalWidth >= remainingWidth then
            totalWidth = getTextSize(char)
            remainingWidth = maxWidth
            return "\n" .. char
        end

        return char
    end)

    return text, totalWidth
end

local subString = string.sub

function PIXEL.WrapText(text, width, font) --Edit of https://github.com/FPtje/DarkRP/blob/master/gamemode/modules/base/cl_util.lua#L21
    local chachedName = text .. width .. font
    if textWrapCache[chachedName] then return textWrapCache[chachedName] end

    setFont(font)
    local textWidth = getTextSize(text)

    if textWidth <= width then
        textWrapCache[chachedName] = text
        return text
    end

    local totalWidth = 0
    local spaceWidth = getTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
        local char = subString(word, 1, 1)
        if char == "\n" or char == "\t" then
            totalWidth = 0
        end

        local wordlen = getTextSize(word)
        totalWidth = totalWidth + wordlen

        if wordlen >= width then
            local splitWord, splitPoint = charWrap(word, width - (totalWidth - wordlen), width)
            totalWidth = splitPoint
            return splitWord
        elseif totalWidth < width then
            return word
        end

        if char == ' ' then
            totalWidth = wordlen - spaceWidth
            return '\n' .. subString(word, 2)
        end

        totalWidth = wordlen
        return '\n' .. word
    end)

    textWrapCache[chachedName] = text
    return text
end

local left = string.Left

local ellipsesTextCache = {}

function PIXEL.EllipsesText(text, width, font)
    local chachedName = text .. width .. font
    if ellipsesTextCache[chachedName] then return ellipsesTextCache[chachedName] end

    setFont(font)
    local textWidth = getTextSize(text)

    if textWidth <= width then
        ellipsesTextCache[chachedName] = text
        return text
    end

    local infiniteLoopPrevention = 0 --Just in case we really fuck up

    repeat
        text = left(text, #text - 1)
        textWidth = getTextSize(text .. "...")

        infiniteLoopPrevention = infiniteLoopPrevention + 1
    until textWidth <= width or infiniteLoopPrevention > 10000

    text = text .. "..."

    ellipsesTextCache[chachedName] = text
    return text
end
--addons/aocrp_pixelui/lua/pixelui/elements/cl_validated_text_entry.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

function PANEL:Init()
    self.TextEntry = vgui.Create("PIXEL.TextEntry", self)
    self.Message = vgui.Create("PIXEL.Label", self)
    self.Message:SetText("")

    self.TextEntry.OnChange = function(s)
        local text = s:GetValue()
        if text == "" then
            self.Message:SetText("")
            s.OverrideCol = nil
            return
        end

        local valid, message = self:IsTextValid(text)

        self:OnValidate(valid, message)

        if valid then
            self.Message:SetText(message or "")
            self.Message:SetTextColor(PIXEL.Colors.Positive)

            s.OverrideCol = PIXEL.Colors.Positive
        else
            self.Message:SetText(message or "")
            self.Message:SetTextColor(PIXEL.Colors.Negative)

            s.OverrideCol = PIXEL.Colors.Negative
        end
    end
end

function PANEL:IsTextValid(text)
    if text == "test" then
        return true
    end

    return false, "This is invalid text lol"
end

function PANEL:OnValidate(valid, message) end

function PANEL:PerformLayout(w, h)
    self.TextEntry:SetTall(PIXEL.Scale(34))
    self.TextEntry:Dock(TOP)

    self.Message:Dock(TOP)
    self.Message:DockMargin(PIXEL.Scale(4), PIXEL.Scale(5), 0, 0)

    self:SizeToChildren(false, true)
end

function PANEL:SetValue(text) self.TextEntry:SetValue(text) end
function PANEL:GetValue() return self.TextEntry:GetValue() end

function PANEL:SetPlaceholderText(text) self.TextEntry:SetPlaceholderText(text) end
function PANEL:GetPlaceholderText() return self.TextEntry:GetPlaceholderText() end

vgui.Register("PIXEL.ValidatedTextEntry", PANEL, "Panel")
--addons/sit_everywhere/lua/sitanywhere/helpers.lua:
SitAnywhere = SitAnywhere or {}
SitAnywhere.NET = {
	["SitWantedAng"] = 0,
	["SitRequestExit"] = 1,
}

SitAnywhere.ClassBlacklist = {
	["gmod_wire_keyboard"] = true,
	["prop_combine_ball"] = true
}

SitAnywhere.DoNotParent = {
	["yava_chunk"] = true
}
SitAnywhere.ModelBlacklist = {
}

local EMETA = FindMetaTable"Entity"

function SitAnywhere.GetAreaProfile(pos, resolution, simple)
	local filter = player.GetAll()
	local dists = {}
	local distsang = {}
	local ang_smallest_hori = nil
	local smallest_hori = 90000
	local angPerIt = (360 / resolution)
	for I = 0, 360, angPerIt do
		local rad = math.rad(I)
		local dir = Vector(math.cos(rad), math.sin(rad), 0)
		local trace = util.QuickTrace(pos + dir * 20 + Vector(0,0,5), Vector(0,0,-15000), filter)
		trace.HorizontalTrace = util.QuickTrace(pos + Vector(0,0,5), dir * 1000, filter)
		trace.Distance  =  trace.StartPos:Distance(trace.HitPos)
		trace.Distance2 = trace.HorizontalTrace.StartPos:Distance(trace.HorizontalTrace.HitPos)
		trace.ang = I

		if (not trace.Hit or trace.Distance > 14) and (not trace.HorizontalTrace.Hit or trace.Distance2 > 20) then
			if simple then return true end
			table.insert(dists, trace)
		end
		if trace.Distance2 < smallest_hori and (not trace.HorizontalTrace.Hit or trace.Distance2 > 3) then
			smallest_hori = trace.Distance2
			ang_smallest_hori = I
		end
		distsang[I] = trace
	end

	if simple then return false end
	return dists, distsang, ang_smallest_hori, smallest_hori
end

function SitAnywhere.CheckValidAngForSit(pos, surfaceAng, ang)
	local rad = math.rad(ang)
	local dir = Vector(math.cos(rad), math.sin(rad), 0)
	local trace2 = util.TraceLine({
		start = pos - dir * (20 - .5) + surfaceAng:Forward() * 5,
		endpos = pos - dir * (20 - .5) + surfaceAng:Forward() * -160,
		filter = player.GetAll()
	})

	local hor_trace = util.TraceLine({
		start = pos + Vector(0, 0, 5),
		endpos = pos + Vector(0, 0, 5) - dir * 1600,
		filter = player.GetAll()
	})

	return hor_trace.StartPos:Distance(hor_trace.HitPos) > 20 and trace2.StartPos:Distance(trace2.HitPos) > 14
end


local SitOnEntsMode = CreateConVar("sitting_ent_mode","3", {FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_REPLICATED}, "0 = No entities\n1 = World entities only\n2 = Self-Owned, World, Unowned\n3 = Any Entity", 0, 3)
--[[
	0 - Can't sit on any ents
	1 - Can't sit on any player ents
	2 - Can only sit on your own ents
	3 - Any
]]

local blacklist = SitAnywhere.ClassBlacklist
local model_blacklist = SitAnywhere.ModelBlacklist
function SitAnywhere.ValidSitTrace(ply, EyeTrace)
	if not EyeTrace.Hit then return false end
	if EyeTrace.HitPos:Distance(EyeTrace.StartPos) > 100 then return false end
	local t = hook.Run("CheckValidSit", ply, EyeTrace)

	if t == false or t == true then
		return t
	end

	if not EyeTrace.HitWorld and SitOnEntsMode:GetInt() == 0 then return false end
	if not EyeTrace.HitWorld and blacklist[string.lower(EyeTrace.Entity:GetClass())] then return false end
	if not EyeTrace.HitWorld and EyeTrace.Entity:GetModel() and model_blacklist[string.lower(EyeTrace.Entity:GetModel())] then return false end


	if EMETA.CPPIGetOwner and SitOnEntsMode:GetInt() >= 1 then
		if SitOnEntsMode:GetInt() == 1 then
			if not EyeTrace.HitWorld then
				local owner = EyeTrace.Entity:CPPIGetOwner()
				if type(owner) == "Player" and owner ~= nil and owner:IsValid() and owner:IsPlayer() then
					return false
				end
			end
		elseif SitOnEntsMode:GetInt() == 2 then
			if not EyeTrace.HitWorld then
				local owner = EyeTrace.Entity:CPPIGetOwner()
				if type(owner) == "Player" and owner ~= nil and owner:IsValid() and owner:IsPlayer() and owner ~= ply then
					return false
				end
			end
		end
	end
	return true
end

local seatClass = "prop_vehicle_prisoner_pod"
local PMETA = FindMetaTable"Player"
function PMETA:GetSitters()
	local seats, holders = {}, {}

	local function processSeat(seat, depth)
		depth = (depth or 0) + 1
		if IsValid(seat:GetDriver()) and seat:GetDriver() ~= self then
			table.insert(seats, seat)
		end
		for _, v in pairs(seat:GetChildren()) do
			if IsValid(v) and v:GetClass() == seatClass and IsValid(v:GetDriver()) and #v:GetChildren() > 0 and depth <= 128 then
				processSeat(v, depth)
			end
		end
	end

	local plyVehicle = self:GetVehicle()
	if IsValid(plyVehicle) and plyVehicle:GetClass() == seatClass then
		processSeat(plyVehicle)
	end

	for _, v in pairs(self:GetChildren()) do
		if IsValid(v) and v:GetClass() == seatClass then
			processSeat(v)
		end
	end

	for _, v in pairs(ents.FindByClass("sit_holder")) do
		if v.GetTargetPlayer and v:GetTargetPlayer() == self then
			table.insert(holders, v)
			if v.GetSeat and IsValid(v:GetSeat()) then
				processSeat(v:GetSeat())
			end
		end
	end
	return seats, holders
end

function PMETA:IsPlayerSittingOn(ply)
	local seats = ply:GetSitters()
	for _,v in pairs(seats) do
		if IsValid(v:GetDriver()) and v:GetDriver() == self then return true end
	end
	return false
end

function PMETA:GetSitting()
	if not IsValid(self:GetVehicle()) then return false end
	local veh = self:GetVehicle()
	if veh:GetNWBool("playerdynseat", false) then
		local parent = veh:GetParent()
		if IsValid(parent) and parent:GetClass() == "sit_holder" then
			return veh, parent
		else
			return veh
		end
	end
	return false
end

function PMETA:ExitSit()
	if CLIENT then
		if self ~= LocalPlayer() then return end
		net.Start("SitAnywhere")
			net.WriteInt(SitAnywhere.NET.SitRequestExit, 4)
		net.SendToServer()
	else
		local seat, holder = self:GetSitting()
		SafeRemoveEntity(seat)
		SafeRemoveEntity(holder)

		if SitAnywhere.GroundSit and self:GetNWBool("SitGroundSitting", false) then
			self:SetNWBool("SitGroundSitting", false)
		end
	end
end

function EMETA:IsSitAnywhereSeat()
	if self:GetClass() ~= "prop_vehicle_prisoner_pod" then return false end
	if SERVER and self.playerdynseat then return true end
	return self:GetNWBool("playerdynseat", false)
end
--lua/autorun/swjs_csf.lua:
player_manager.AddValidModel( "Corusant Security Force Lead",						"models/nada/CSF_Leader.mdl" ) 
list.Set( "PlayerOptionsModel",  "Corusant Security Force Lead",						"models/nada/CSF_Leader.mdl" )
player_manager.AddValidHands( "Corusant Security Force Lead", "models/nada/hands/CSF_arms.mdl", 0, "00000000" )

player_manager.AddValidModel( "Corusant Security Force",						"models/nada/CSF.mdl" ) 
list.Set( "PlayerOptionsModel",  "Corusant Security Force",						"models/nada/CSF.mdl" )
player_manager.AddValidHands( "Corusant Security Force", "models/nada/hands/CSF_arms.mdl", 0, "00000000" )

player_manager.AddValidModel( "Corusant Security Variant",						"models/nada/CSF_Variant.mdl" ) 
list.Set( "PlayerOptionsModel",  "Corusant Security Variant",						"models/nada/CSF_Variant.mdl" )
player_manager.AddValidHands( "Corusant Security Variant", "models/nada/hands/CSF_arms.mdl", 0, "00000000" )
--addons/vyhub-gmod/lua/vyhub/shared/sh_lang.lua:
local f = string.format
local json = VyHub.Lib.json

VyHub.Lang = VyHub.Lang or {}
VyHub.lang = VyHub.lang or nil

if SERVER then
    util.AddNetworkString("vyhub_lang")

    VyHub.Lang.compressed = VyHub.Lang.compressed or nil 

    function VyHub.Lang:load()
        local f_en = file.Open("vyhub/lang/en.json", "r", "LUA")

        if f_en == nil then
            VyHub:msg("Missing language file en.json!!! PLEASE MAKE SURE TO DOWNLOAD VYHUB-GMOD ON THE GITHUB RELESES PAGE! https://github.com/matbyte-com/vyhub-gmod/releases", "error")
            return
        end

        local en = json.decode(f_en:Read())
        f_en:Close()

        if not istable(en) then
            VyHub:msg("Could not load language file en.json!", "error")
            return
        end

        VyHub.lang = en

        VyHub:msg("Loaded language en.")

        if VyHub.Config.lang != 'en' then
            local f_custom = file.Open(f("vyhub/lang/%s.json", VyHub.Config.lang), "r", "LUA")

            if f_custom != nil then 
                local custom = json.decode(f_custom:Read())
                f_custom:Close()

                if istable(custom) then
                    table.Merge(VyHub.lang, custom)
                    VyHub:msg(f("Loaded language %s.", VyHub.Config.lang))
                else
                    VyHub:msg(f("Could not load language file %s.json!", VyHub.Config.lang), "warning")
                end
            else
                VyHub:msg(f("Missing language file %s.json.", VyHub.Config.lang), "warning")
            end
        end     
        
        VyHub.Lang.compressed = util.Compress(json.encode(VyHub.lang))
    end

    if VyHub.lang == nil then
        VyHub.Lang:load()
    end

    net.Receive("vyhub_lang", function(_, ply)
        if not IsValid(ply) then return end
        if not VyHub.Lang.compressed then return end

        local len = #VyHub.Lang.compressed

        net.Start("vyhub_lang")
            net.WriteUInt(len, 16)
            net.WriteData(VyHub.Lang.compressed, len)
        net.Send(ply)
    end)
end

if CLIENT then
    function VyHub.Lang:load()
        net.Start("vyhub_lang")
        net.SendToServer()
    end

    net.Receive("vyhub_lang", function()
        timer.Remove("vyhub_lang_load")

        local len = net.ReadUInt(16)
        local lang_compr = net.ReadData(len)

        VyHub.lang = json.decode(util.Decompress(lang_compr))

        VyHub:msg("Loaded language.")
        
        hook.Run("vyhub_lang_loaded")
    end)

    hook.Add("Initialize", "vyhub_lang_Initialize", function ()
        VyHub.Lang:load()

        timer.Create("vyhub_lang_load", 5, 5, function ()
            if VyHub.lang == nil then
                VyHub.Lang:load()
            else
                timer.Remove("vyhub_lang_load")
            end
        end)
    end)
end

--lua/autorun/wiltos_animbase_loader.lua:

--[[-------------------------------------------------------------------
	Animation Base:
		Create your own animations, mount animations from other games, and more!
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--


if SERVER then
	AddCSLuaFile( "wos/anim_extension/loader/loader.lua" )
end

include( "wos/anim_extension/loader/loader.lua" )
--lua/wos/anim_extension/extensions/wos_customtaunt.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Custom Taunt" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Custom Taunt\n" )
--lua/wos/anim_extension/holdtypes/g_combo3.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo3"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo3" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo3" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/languages/ru.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

// Translated by KIRILLBREST123 :)

local ru = {
	
	-- Stats
	lag = "ЛАГ",
	collisions = "СТОЛКНОВЕНИЯ",
	props = "ПРОПЫ",
	propsFrozen = "ЗАМОРОЖЕННЫЕ ПР.",
	npcs = "НПС",
	vehicles = "ТРАНСПОРТ",
	players = "ИГРОКИ",
	uptime = "СЕРВЕР ЗАПУЩЕН",
	entities = "ЭНТИТИ",
	spawned = "СОЗДАННО",
	fps = "FPS",
	tickrate = "ТИКРЕЙТ",
	runAntiLagMeasures = "ЗАПУСТИТЬ АНТИ-ЛАГОВЫЕ МЕРЫ",
	
	-- Users
	search = "Поиск",
	constraints = "СОЕДИНЕНИЯ",
	showEntities = "Показать Энтити",
	hideEntities = "Спрятать Энтити",
	resetMap = "Очистить",
	freezeEntities = "Заморозить Энтити",
	removeEntities = "Удалить Энтити",
	
	-- Global
	noCollideEntities = "Отключить Столкновения у Энтити",
	
	-- Lag
	heavyLag = "Обнаружены сильные лаги!",
	lagIsStuck = "Внимание: продолжительные лаги",
	crashPrevented = "Предотвращён краш сервера!",
	cleaningMap = "+ Очистка карты...",
	removingEnts = "+ Удаление %s энтити",
	revertChanges = "+ Удаление %s энтити созданные в последние %s минут",
	freezeingEnts = "+ Заморозка %s энтити",
	noCollidingEnts = "+ Выключение столкновения у %s энтити",
	offenderWarning = "У %s есть подозрительное количество энтити (%s) создающее лаги!",
	freezingAllEntities = "Замрозозка все энтити (%s)",
	
	-- Dupes
	dupesNotEnabled = "Дупликаты не включены на этом сервере!",
	advDupesNotEnabled = "Дюпы из Advanced Duplicator не включены на этом сервере!",
	dupeExceedsSize = "Размер этого дюпа превышает максимально допустимый! (размер:%s, максимальный:%s)",
	dupeInformation = "%s заспавнил дюп содержащий %s энтити и %s соединений",
	
	-- Notifications
	triggeredAntiLagMeasures = "срабатывают меры против лагов!",
	ranAntilagMeasures = "запущены меры против лагов!",
	hasNoEntities = "не имеет энтити!",
	youRemovedFrom = "Вы удалили %s энтити у %s!",
	removedYourObjects = "удалены ваши созданные объекты!",
	youFrozeFrom = "Вы заморозили %s энтити у %s!",
	frozeYourObjects = "заморожены ваши созданные объекты!",
	enabledSpawnAbility = "включил вашу способность создание объектов!",
	disabledSpawnAbility = "выключил вашу способность создания объектов!",
	youEnabledSpawnAbility = "Вы включили у %s способность создания объектов!",
	youDisabledSpawnAbility = "Вы выключили у %s способность создания объектов!",
	
	resetTheMap = "очистил карту!",
	noEntNameFound = "%s не найден!",
	noEntitiesFound = "Не найдено никаких энтити!",
	noUnfrozenEntsFound = "Не найдено не замороженных энтити!",
	noUnCollidedEntsFound = "Не найдено энтити с столкновениями!",
	freezeAllEnts = "%s заморозил объекты у %s! (%s)",
	noCollideAllEnts = "%s выключил столкновения объектов у %s! (%s)",
	removedAllEntName = "%s удалил объекты у %s! (%s)",
	entitiesLowCase = "энтити",
	
	-- Console Log
	removedEntitiesFrom = "%s удалил %s энтити у %s!",
	frozeEntitiesFrom = "%s заморозил %s энтити у %s!",
	enabledSpawningCapabilities = "%s включил способность создания у %s!",
	disabledSpawningCapabilities = "%s выключил способность создания у %s!",
	removingHighCollision = "Удаление сильных столкновения %s (%s) у %s!",
	
}

return ru
--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_debug.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local debugMat = Material("editor/wireframe")
local enableDebug = false

local function IsValidEnt(ent)
	return IsValid(ent) and !ent:IsWorld() and ent:z_anticrashHasCreator() and !ent.__markedForDelete
end

local function DebugDraw()

	if !enableDebug then return end

	local entTbl = ents.GetAll()
	local offsetVector = SH_ANTICRASH.VARS.NEIGHBOUROFFSETVECTOR
	
	cam.Start3D()
		
		for i=1, #entTbl do
			
			local ent = entTbl[i]
			
			if !IsValidEnt(ent) then
				continue
			end
			
			local neighbours = SH_ANTICRASH.GetNeighboringEnts(ent)
			local validNeightbours = {}
			for ii=1, #neighbours do
			
				local ent2 = neighbours[ii]
				
				if !IsValidEnt(ent2) or ent == ent2 then
					continue
				end
				
				table.insert(validNeightbours, ent2) 
			
			end
			
			local hasNeighbours = #validNeightbours > 0
			local debugCol = hasNeighbours and SH_ANTICRASH.VARS.COLOR.RED or color_white
		
			render.SetMaterial(debugMat)
			
			-- Search box
			render.DrawBox(ent:GetPos(), ent:GetAngles(), ent:OBBMins()-offsetVector, ent:OBBMaxs()+offsetVector, debugCol)
			
			-- Find in box lines
			local worldMins = LocalToWorld(ent:OBBMins()-offsetVector, Angle(0,0,0), ent:GetPos(), ent:GetAngles())
			local worldMaxs = LocalToWorld(ent:OBBMaxs()+offsetVector, Angle(0,0,0), ent:GetPos(), ent:GetAngles())
			
			render.DrawLine(worldMins, worldMaxs, SH_ANTICRASH.VARS.COLOR.BLUE)
			
			-- World pos
			render.DrawLine(ent:GetPos()-Vector(0,3,0), ent:GetPos()+Vector(0,3,0), SH_ANTICRASH.VARS.COLOR.GREEN)
			render.DrawLine(ent:GetPos()-Vector(0,0,3), ent:GetPos()+Vector(0,0,3), SH_ANTICRASH.VARS.COLOR.GREEN)
		
		end
			
	cam.End3D()

end
hook.Add("HUDPaint","cl_anticrash_DebugDraw",DebugDraw)
--addons/tools_advdupe/lua/advdupe2/sh_codec.lua:
--[[
	Title: Adv. Dupe 2 Codec

	Desc: Dupe encoder/decoder.

	Author: emspike

	Version: 2.0
]]

local REVISION = 5
AdvDupe2.CodecRevision = REVISION
AdvDupe2.MaxDupeSize = 32e6 -- 32 MB

include( "sh_codec_legacy.lua" )
AddCSLuaFile( "sh_codec_legacy.lua" )

local pairs = pairs
local type = type
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat
local compress = util.Compress
local decompress = util.Decompress

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local function makeInfo(tbl)
	local info = ""
	for k, v in pairs(tbl) do
		info = concat{info,k,"\1",v,"\1"}
	end
	return info.."\2"
end

local AD2FF = "AD2F%s\n%s\n%s"

local tables, buff

local function noserializer() end

local enc = {}
for i = 1, 255 do enc[i] = noserializer end

local function isArray(tbl)
	local ret = true
	local m = 0

	for k, v in pairs(tbl) do
		m = m + 1
		if k ~= m or enc[TypeID(v)] == noserializer then
			ret = false
			break
		end
	end

	return ret
end

local function write(obj)
	enc[TypeID(obj)](obj)
end

local len, tables, tablesLookup

enc[TYPE_TABLE] = function(obj) --table
	if not tablesLookup[obj] then
		tables = tables + 1
		tablesLookup[obj] = tables
	else
		buff:WriteByte(247)
		buff:WriteShort(tablesLookup[obj])
		return
	end

	if isArray(obj) then
		buff:WriteByte(254)
		for i, v in pairs(obj) do
			write(v)
		end
	else
		buff:WriteByte(255)
		for k, v in pairs(obj) do
			if(enc[TypeID(k)] ~= noserializer and enc[TypeID(v)] ~= noserializer) then
				write(k)
				write(v)
			end
		end
	end
	buff:WriteByte(246)
end

enc[TYPE_BOOL] = function(obj) --boolean
	buff:WriteByte(obj and 253 or 252)
end

enc[TYPE_NUMBER] = function(obj) --number
	buff:WriteByte(251)
	buff:WriteDouble(obj)
end

enc[TYPE_VECTOR] = function(obj) --vector
	buff:WriteByte(250)
	buff:WriteDouble(obj.x)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.z)
end

enc[TYPE_ANGLE] = function(obj) --angle
	buff:WriteByte(249)
	buff:WriteDouble(obj.p)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.r)
end

enc[TYPE_STRING] = function(obj) --string
	len = #obj
	if len < 246 then
		buff:WriteByte(len)
		buff:Write(obj)
	else
		buff:WriteByte(248)
		buff:WriteULong(len)
		buff:Write(obj)
	end
end

local function error_nodeserializer()
	buff:Seek(buff:Tell()-1)
	error(format("Couldn't find deserializer for type {typeid:%d}!", buff:ReadByte()))
end

local reference = 0
local read4, read5

do --Version 4
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		if tt == 0 then
			return nil
		end
		return dec[tt]()
	end
	read4 = read

	dec[255] = function() --table
		local t = {}
		local k
		reference = reference + 1
		local ref = reference
		repeat
			k = read()
			if k ~= nil then
				t[k] = read()
			end
		until (k == nil)
		tables[ref] = t
		return t
	end

	dec[254] = function() --array
		local t = {}
		local k = 0
		local v
		reference = reference + 1
		local ref = reference
		repeat
			k = k + 1
			v = read()
			if(v ~= nil) then
				t[k] = v
			end

		until (v == nil)
		tables[ref] = t
		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() --null-terminated string
		local start = buff:Tell()
		local slen = 0

		while buff:ReadByte() ~= 0 do
			slen = slen + 1
		end

		buff:Seek(start)

		local retv = buff:Read(slen)
		if(not retv) then retv="" end
		buff:ReadByte()

		return retv
	end
	dec[247] = function() --table reference
		reference = reference + 1
		return tables[buff:ReadShort()]
	end

	for i = 1, 246 do dec[i] = function() return buff:Read(i) end end
end

do --Version 5
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		return dec[tt]()
	end
	read5 = read

	dec[255] = function() --table
		local t = {}
		reference = reference + 1
		tables[reference] = t

		for k in read do
			t[k] = read()
		end

		return t
	end

	dec[254] = function() --array
		local t = {}
		reference = reference + 1
		tables[reference] = t

		local k = 1
		for v in read do
			t[k] = v
			k = k + 1
		end

		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() -- Length>246 string
		local slen = buff:ReadULong()
		local retv = buff:Read(slen)
		if(not retv) then retv = "" end
		return retv
	end
	dec[247] = function() --table reference
		return tables[buff:ReadShort()]
	end
	dec[246] = function() --nil
		return
	end

	for i = 1, 245 do dec[i] = function() return buff:Read(i) end end

	dec[0] = function() return "" end
end

local function serialize(tbl)
	tables = 0
	tablesLookup = {}

	buff = file.Open("ad2temp.txt", "wb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	write(tbl)
	buff:Close()

	buff = file.Open("ad2temp.txt","rb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local ret = buff:Read(buff:Size())
	buff:Close()
	return ret
end


local function deserialize(str, read)

	if(str == nil) then
		error("File could not be decompressed!")
		return {}
	end

	tables = {}
	reference = 0
	buff = file.Open("ad2temp.txt","wb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	buff:Write(str)
	buff:Flush()
	buff:Close()

	buff = file.Open("ad2temp.txt","rb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local success, tbl = pcall(read)
	buff:Close()

	if success then
		return tbl
	else
		error(tbl)
	end
end

--[[
	Name:	Encode
	Desc:	Generates the string for a dupe file with the given data.
	Params:	<table> dupe, <table> info, <function> callback, <...> args
	Return:	runs callback(<string> encoded_dupe, <...> args)
]]
function AdvDupe2.Encode(dupe, info, callback, ...)
	local encodedTable = compress(serialize(dupe))
	info.check = "\r\n\t\n"
	info.size = #encodedTable

	callback(AD2FF:format(char(REVISION), makeInfo(info), encodedTable),...)
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("Attempt to read AD2 file with malformed info block!")
	end
	local info = {}
	local ss = str:sub(1, last - 1)
	for k, v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end

	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("Detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)!")
		elseif info.check ~= nil then
			error("Detected AD2 file corrupted by newline replacements (copy/pasting the data in various editors can cause this!)")
		else
			error("Attempt to read AD2 file with malformed info block!")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[1] = AdvDupe2.LegacyDecoders[1]
versions[2] = AdvDupe2.LegacyDecoders[2]

versions[3] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	return versions[4](encodedDupe)
end

versions[4] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read4), info
end

versions[5] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read5), info
end

function AdvDupe2.CheckValidDupe(dupe, info)
	if not dupe.HeadEnt then return false, "Missing HeadEnt table" end
	if not dupe.Entities then return false, "Missing Entities table" end
	if not dupe.Constraints then return false, "Missing Constraints table" end
	if not dupe.HeadEnt.Z then return false, "Missing HeadEnt.Z" end
	if not dupe.HeadEnt.Pos then return false, "Missing HeadEnt.Pos" end
	if not dupe.HeadEnt.Index then return false, "Missing HeadEnt.Index" end
	if not dupe.Entities[dupe.HeadEnt.Index] then return false, "Missing HeadEnt index ["..dupe.HeadEnt.Index.."] from Entities table" end
	for key, data in pairs(dupe.Entities) do
		if not data.PhysicsObjects then return false, "Missing PhysicsObject table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if not data.PhysicsObjects[0] then return false, "Missing PhysicsObject[0] table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if info.ad1 then -- Advanced Duplicator 1
			if not data.PhysicsObjects[0].LocalPos then return false, "Missing PhysicsObject[0].LocalPos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].LocalAngle then return false, "Missing PhysicsObject[0].LocalAngle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		else -- Advanced Duplicator 2
			if not data.PhysicsObjects[0].Pos then return false, "Missing PhysicsObject[0].Pos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].Angle then return false, "Missing PhysicsObject[0].Angle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		end
	end
	return true, dupe
end

--[[
	Name:	Decode
	Desc:	Generates the table for a dupe from the given string. Inverse of Encode
	Params:	<string> encodedDupe, <function> callback, <...> args
	Return:	runs callback(<boolean> success, <table/string> tbl, <table> info)
]]
function AdvDupe2.Decode(encodedDupe)

	local sig, rev = encodedDupe:match("^(....)(.)")

	if not rev then
		return false, "Malformed dupe (wtf <5 chars long)!"
	end

	rev = rev:byte()

	if sig ~= "AD2F" then
		if sig == "[Inf" then --legacy support, ENGAGE (AD1 dupe detected)
			local success, tbl, info, moreinfo = pcall(AdvDupe2.LegacyDecoders[0], encodedDupe)

			if success then
				info.ad1 = true
				info.size = #encodedDupe
				info.revision = 0

				local index = tonumber(moreinfo.Head) or (istable(tbl.Entities) and next(tbl.Entities))
				if not index then return false, "Missing head index" end
				local pos
				if isstring(moreinfo.StartPos) then
					local spx,spy,spz = moreinfo.StartPos:match("^(.-),(.-),(.+)$")
					pos = Vector(tonumber(spx) or 0, tonumber(spy) or 0, tonumber(spz) or 0)
				else
					pos = Vector()
				end
				local z
				if isstring(moreinfo.HoldPos) then
					z = (tonumber(moreinfo.HoldPos:match("^.-,.-,(.+)$")) or 0)*-1
				else
					z = 0
				end
				tbl.HeadEnt = {
					Index = index,
					Pos = pos,
					Z = z
				}
			else
				ErrorNoHalt(tbl)
			end

			if success then
				success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
			end

			return success, tbl, info, moreinfo
		else
			return false, "Unknown duplication format!"
		end
	elseif rev > REVISION then
		return false, format("Newer codec needed. (have rev %u, need rev %u) Update Advdupe2.",REVISION,rev)
	elseif rev < 1 then
		return false, format("Attempt to use an invalid format revision (rev %d)!", rev)
	else
		local success, tbl, info = pcall(versions[rev], encodedDupe)

		if success then
			success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
		end
		if success then
			info.revision = rev
		end

		return success, tbl, info
	end
end

if CLIENT then

	concommand.Add("advdupe2_to_json", function(_,_,arg)
		if not arg[1] then print("Need AdvDupe2 file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".json"

		writeFileName = AdvDupe2.SanitizeFilename(writeFileName)

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()
		local ok, tbl = AdvDupe2.Decode(readData)
		local writeFile = file.Open(writeFileName, "wb", "DATA")
		if not writeFile then print("File could not be written! ("..writeFileName..")") return end
		writeFile:Write(util.TableToJSON(tbl))
		writeFile:Close()
		print("File written! ("..writeFileName..")")
	end)

	concommand.Add("advdupe2_from_json", function(_,_,arg)
		if not arg[1] then print("Need json file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".txt"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()

		AdvDupe2.Encode(util.JSONToTable(readData), {}, function(data)
			local writeFile = file.Open(writeFileName, "wb", "DATA")
			if not writeFile then print("File could not be written! ("..writeFileName..")") return end
			writeFile:Write(data)
			writeFile:Close()
			print("File written! ("..writeFileName..")")
		end)
	end)

end



--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_var_mount.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--
























































































































































wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Vars = wOS.PES.Vars || {}
wOS.PES.Vars.Data = wOS.PES.Vars.Data || {}


function wOS.PES.Vars:Autoloader()
    for _,source in pairs( file.Find( "wos/pes/vars/*", "LUA"), true ) do

        local lua = "wos/pes/vars/" .. source
        if SERVER then AddCSLuaFile(lua) end
		local varData = include(lua)

        if !varData then
            print("ERROR: " .. source .. " this variable is invalid")
            continue
        end

        varData.ToolTips = varData.ToolTips or {}
        local default_hint = {
            key = "gui/r.png",
            text = "Return to the Node Layout Menu",
        }
        table.insert( varData.ToolTips, 1, default_hint )

        self.Data[varData.Name] = varData
    end
end

function wOS.PES.Vars:GetAll()
    return wOS.PES.Vars.Data
end

function wOS.PES.Vars:Get(name)
    if not name then return end
    return self.Data[name]
end

wOS.PES.Vars:Autoloader()
--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_sfs_extern.lua:
if wOS and wOS.SFS_EXTERN then return end

-- SFS (Srlion's Fast Serializer)
-- we try to avoid NYI operations in luajit as much as possible
-- unforunately, we can't avoid all of them in luajit 2.0.5 - pairs & table.concat
-- https://github.com/tarantool/tarantool/wiki/LuaJIT-Not-Yet-Implemented
-- we don't use string concating because it's also NYI in luajit 2.0.5
-- we never error so we don't get blacklisted by the jit compiler
-- errors return strings instead of throwing errors

-- this is intentionally made for net messages, so you don't have to use pcall to check if there are any errors
-- you should use this without using util.Compress, as this just adds one byte to each value, you will probably end up with a larger string if you compress it

-- this idea is from messagepack which is really smart
-- small numbers (0 ~ 127) and (-32 ~ -1) are encoded as a single byte
-- tables and arrays are encoded with a prefix byte, which is the number of elements in the table or array, but it can be one byte if it's less than 16
-- strings are encoded with a prefix byte, which is the length of the string, but it can be one byte if it's less than 32

local math = math
local HUGE = math.huge
local floor = math.floor
local internal_type = type
local IsColor = IsColor
local type = function(v)
    if IsColor(v) then
        return "Color"
    end
    return internal_type(v)
end

-- string.char is not jit compiled in luajit 2.0.5
local chars = {}; do
    for i = 0, 255 do
        chars[i] = string.char(i)
    end
end

local MAX_NUMBER = 1.7976931348623e+308
local MIN_NUMBER = -MAX_NUMBER

---
local POSITIVE_INT = 0x00
local POSITIVE_INT_END = 0x7f

local TABLE_FIXED = 0x80
local TABLE_FIXED_END = 0x8f

local ARRAY_FIXED = 0x90
local ARRAY_FIXED_END = 0x9f

local STR_FIXED = 0xa0
local STR_FIXED_END = 0xbf

local NIL = 0xc0
local FALSE = 0xc1
local TRUE = 0xc2

local UINT_8 = 0xc3
local UINT_16 = 0xc4
local UINT_32 = 0xc5
local UINT_52 = 0xc6

local NINT_8 = 0xc7
local NINT_16 = 0xc8
local NINT_32 = 0xc9
local NINT_52 = 0xca

local DOUBLE = 0xcb

local STR_8 = 0xcc
local STR_16 = 0xcd
local STR_32 = 0xce

local ARRAY_8 = 0xcf
local ARRAY_16 = 0xd0
local ARRAY_32 = 0xd1

local TABLE_8 = 0xd2
local TABLE_16 = 0xd3
local TABLE_32 = 0xd4

local VECTOR = 0xd5
local ANGLE = 0xd6

local ENTITY = 0xd7
local PLAYER = 0xd8

local COLOR = 0xd9

-- this was added in version 2.0.0
-- it's used for arrays that start at 0, I'm not sure if lua 5.1 has same behavior as luajit 2.0.5
-- but luajit 2.0.5 supports starting arrays at 0 index, so checking if table is an array or not gets messed up and output is wrong
-- so if you supply local t = {[0] = 0, 1, 2, 3} and do next(t, #t) it will return (nil, nil) instead of (0, 0)
local ARRAY_ZERO_BASED_INDEX = 0xda

local FREE_FOR_CUSTOM = 0xdb
local FREE_FOR_CUSTOM_END = 0xdf

local NEGATIVE_INT = 0xe0
local NEGATIVE_INT_END = 0xff
---

local encoders = {}
local Encoder = {
    encoders = encoders
}
do
    local pairs = pairs
    local next = next
    local ceil = math.ceil
    local log = math.log
    local concat = table.concat
    local write, write_unsigned, write_double

    -- garry's mod related
    local Vector_Unpack, Angle_Unpack
    local Entity_EntIndex, Player_UserID
    if FindMetaTable then
        Vector_Unpack = FindMetaTable("Vector").Unpack
        Angle_Unpack = FindMetaTable("Angle").Unpack

        Entity_EntIndex = FindMetaTable("Entity").EntIndex
        Player_UserID = FindMetaTable("Player").UserID
    end
    --

    local get_encoder = function(buf, t)
        local encoder = encoders[type(t)]
        if encoder == nil then
            write(buf, "Unsupported type: ")
            write(buf, type(t))
            return nil
        end
        return encoder
    end

    local buffer = {
        [0] = 0 -- buffer length
    }

    -- this function is obviously not jit compiled in luajit 2.0.5 but internal functions are
    function Encoder.encode(val, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        local encoder = get_encoder(buffer, val)
        if encoder == nil then
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        if encoder(buffer, val, arg) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function Encoder.encode_array(arr, len, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        if encoders.array(buffer, arr, len) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function write(buf, chr)
        local buf_len = buf[0] + 1
        buf[0] = buf_len
        buf[buf_len] = chr
    end
    Encoder.write = write

    encoders["nil"] = function(buf)
        write(buf, chars[NIL])
    end

    function encoders.boolean(buf, bool)
        if bool == true then
            write(buf, chars[TRUE])
        else
            write(buf, chars[FALSE])
        end
    end

    function encoders.array(buf, arr, len, start_index)
        start_index = (start_index == nil or start_index ~= 0 and start_index ~= 1) and 1 or start_index

        if len < 0 then
            write(buf, "Array size cannot be negative: ")
            write(buf, len)
            return true
        elseif len > 0xFFFFFFFF then
            write(buf, "Array size too large to encode: ")
            write(buf, len)
            return true
        end

        if len <= 0xF then
            write(buf, chars[ARRAY_FIXED + len])
        else
            write_unsigned(buf, ARRAY_8, len)
        end

        if start_index == 0 then
            write(buf, chars[ARRAY_ZERO_BASED_INDEX])
        end

        for idx = start_index, len do
            local val = arr[idx]
            local encoder = get_encoder(buf, val)
            if encoder == nil then return true end
            encoder(buf, val)
        end
    end

    -- we can't check if a table is an array or not because lua tables are not arrays, they are tables
    -- use Encoder.encode_array if you want to encode an array
    function encoders.table(buf, tbl)
        -- check if it's an array, it's not accurate for arrays with holes but better than nothing
        do
            -- this is the fastest possible way, a lot better than cbor's/messagepack's/pon's way of checking if it's an array
            local tbl_len = #tbl
            if tbl_len > 0 and next(tbl, tbl_len) == nil then
                if tbl[0] ~= nil then
                    return encoders.array(buf, tbl, tbl_len, 0)
                else
                    return encoders.array(buf, tbl, tbl_len)
                end
            end
        end

        local buf_len = buf[0]
        local table_start = buf_len -- we store the start of the table so when we write the table size, we can change the current buffer index to the start of the table
        -- we have no way to get the table size without iterating through it, so we just add 5 empty strings to the buffer as a placeholder
        -- we add 5 empty strings because we don't know if table size is going to be a fixed number, uint8, uint16 or uint32
        -- uint32 takes 5 bytes, so we add 5 empty strings
        do
            for idx = 1, 5 do
                buf[buf_len + idx] = ""
            end
            buf_len = buf_len + 5
            buf[0] = buf_len
        end

        local table_count = 0
        for key, val in pairs(tbl) do
            table_count = table_count + 1

            local encoder_key = get_encoder(buf, key)
            if encoder_key == nil then return true end
            encoder_key(buf, key)

            local encoder_val = get_encoder(buf, val)
            if encoder_val == nil then return true end
            encoder_val(buf, val)
        end

        local table_end = buf[0] -- we store the end of the table because we need to change current buffer index to the start of the table to write the table size
        buf[0] = table_start -- change current buffer index to the start of the table

        -- write the table size
        if table_count <= 0xF then
            write(buf, chars[TABLE_FIXED + table_count])
        else
            if table_count > 0xFFFFFFFF then
                write(buf, "Table size too large to encode: ")
                write(buf, table_count)
                return true
            end
            write_unsigned(buf, TABLE_8, table_count)
        end

        buf[0] = table_end -- change current buffer index back to the end of the table
    end

    function encoders.string(buf, str)
        local str_len = #str
        if str_len > 0xFFFFFFFF then
            write(buf, "String too large to encode: ")
            write(buf, str_len)
            return true
        end

        if str_len <= 0x1F then
            write(buf, chars[STR_FIXED + str_len])
        else
            write_unsigned(buf, STR_8, str_len)
        end
        write(buf, str)
    end

    function encoders.number(buf, num)
        if (num > MAX_NUMBER and num ~= HUGE) or (num < MIN_NUMBER and num ~= -HUGE) then
            write(buf, "Number too large to encode: ")
            write(buf, num)
            return true
        end

        if num % 1 ~= 0 or num > 0xFFFFFFFFFFFFF or num < -0xFFFFFFFFFFFFF then -- DOUBLE
            write_double(buf, DOUBLE, num)
            return
        end

        if num < 0 then
            num = -num
            if num <= 0x1F then
                write(buf, chars[NEGATIVE_INT + num])
            else
                write_unsigned(buf, NINT_8, num)
            end
        else
            if num <= 0x7F then
                write(buf, chars[POSITIVE_INT + num])
            else
                write_unsigned(buf, UINT_8, num)
            end
        end
    end

    function encoders.Vector(buf, vec)
        write(buf, chars[VECTOR])
        local x, y, z = Vector_Unpack(vec)
        encoders.number(buf, x)
        encoders.number(buf, y)
        encoders.number(buf, z)
    end

    function encoders.Angle(buf, ang)
        write(buf, chars[ANGLE])
        local p, y, r = Angle_Unpack(ang)
        encoders.number(buf, p)
        encoders.number(buf, y)
        encoders.number(buf, r)
    end

    function encoders.Entity(buf, ent)
        write(buf, chars[ENTITY])
        encoders.number(buf, Entity_EntIndex(ent))
    end

    function encoders.Player(buf, ply)
        write(buf, chars[PLAYER])
        encoders.number(buf, Player_UserID(ply))
    end

    function encoders.Color(buf, col)
        write(buf, chars[COLOR])
        encoders.number(buf, col.r)
        encoders.number(buf, col.g)
        encoders.number(buf, col.b)
        encoders.number(buf, col.a)
    end

    function write_unsigned(buf, tag, num)
        if num <= 0xFF then -- uint8
            write(buf, chars[tag + 0x00])
            write(buf, chars[num])
        elseif num <= 0xFFFF then -- uint16
            write(buf, chars[tag + 0x01])
            write(buf, chars[floor(num / 256)])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFF then -- uint32
            write(buf, chars[tag + 0x02])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFFFFFFF then -- uint52
            write(buf, chars[tag + 0x3])
            write(buf, chars[num % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x100000000) % 256])
            write(buf, chars[floor(num / 0x10000000000) % 256])
            write(buf, chars[floor(num / 0x1000000000000) % 256])
        end
    end
    Encoder.write_unsigned = write_unsigned

    -- i can't remember where i got this from, but it's not mine (i swear i always credit people)
    local log2 = log(2)
    function write_double(buf, tag, value)
        local abs_value = value < 0 and -value or value
        --IEEE double-precision floating point number
        --Specification: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
        --Separate out the sign, exponent and fraction
        local sign = value < 0 and 1 or 0
        local exponent = ceil(log(abs_value) / log2) - 1
        local fraction = abs_value / (2 ^ exponent) - 1
        --Make sure the exponent stays in range - allowed values are -1023 through 1024
        if exponent < -1023 then
            --We allow this case for subnormal numbers and just clamp the exponent and re-calculate the fraction
            --without the offset of 1
            exponent = -1023
            fraction = abs_value / (2 ^ exponent)
        elseif abs_value ~= HUGE and exponent > 1024 then
            write(buf, "Exponent out of range: ")
            write(buf, value)
            return true
        end

        --Handle special cases
        if value == 0 then
            --Zero
            exponent = -1023
            fraction = 0
        elseif abs_value == HUGE then
            --Infinity
            exponent = 1024
            fraction = 0
        elseif value ~= value then
            --NaN
            exponent = 1024
            fraction = 1
        end

        local exp_out = exponent + 1023
        local fraction_out = fraction * 0x10000000000000

        write(buf, chars[tag])
        write(buf, chars[128 * sign + floor(exp_out / 16)])
        write(buf, chars[(exp_out % 16) * 16 + floor(fraction_out / 0x1000000000000)])
        write(buf, chars[floor(fraction_out / 0x10000000000) % 256])
        write(buf, chars[floor(fraction_out / 0x100000000) % 256])
        write(buf, chars[floor(fraction_out / 0x1000000) % 256])
        write(buf, chars[floor(fraction_out / 0x10000) % 256])
        write(buf, chars[floor(fraction_out / 0x100) % 256])
        write(buf, chars[floor(fraction_out % 256)])
    end
    Encoder.write_double = write_double
end

local decoders = {}
local Decoder = {
    decoders = decoders
}
do
    local sub = string.sub

    local read_type, read_byte, read_word, read_dword
    local decode_array, decode_table, decode_string, decode_double

    -- garry's mod related
    local Vector, Angle, Entity, Player, Color = Vector, Angle, Entity, Player, Color
    --

    local str_byte = string.byte
    local byte = function(ctx, size)
        local index = ctx[1]
        if index + size - 1 > ctx[3] then -- buffer length
            return nil, "Attemped to read beyond buffer size"
        elseif index + size - 1 > ctx[4] then -- max size
            return nil, "Max decode size exceeded"
        end
        ctx[1] = index + size
        return str_byte(ctx[2], index, index + size - 1)
    end
    Decoder.byte = byte

    local get_decoder = function(ctx)
        local t = read_type(ctx)
        local decoder = decoders[t]
        if decoder == nil then
            return nil, "Unsupported type: ", t
        end
        return decoder
    end
    Decoder.get_decoder = get_decoder

    local context = {
        1,  -- index
        "", -- buffer
        0,  -- buffer length
        HUGE, -- max size for decode, useful when decoding from user input that was sent over netmessages
    }

    local decode = function()
        if context[3] < 1 then -- this will make string.byte fail
            return nil, "Buffer is empty"
        end

        local err, err_2
        local decoder
        local val

        decoder, err, err_2 = get_decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        val, err, err_2 = decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        return val
    end

    function Decoder.decode(str)
        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = HUGE

        return decode()
    end

    function Decoder.decode_with_max_size(str, max_size)
        if type(max_size) ~= "number" then
            return nil, "max_size is not a number", max_size
        end

        if max_size < 0 then
            return nil, "max_size can either be a positive number or math.huge for unlimited", max_size
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = max_size

        return decode()
    end

    decoders[NIL] = function(ctx)
        ctx[1] = ctx[1] + 1
        return nil
    end

    decoders[FALSE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return false
    end

    decoders[TRUE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return true
    end

    --
    decoders[ARRAY_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - ARRAY_FIXED
        return decode_array(ctx, len)
    end

    for i = ARRAY_FIXED + 1, ARRAY_FIXED_END do
        decoders[i] = decoders[ARRAY_FIXED]
    end
    --

    decoders[ARRAY_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if len == nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    --
    decoders[TABLE_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - TABLE_FIXED
        return decode_table(ctx, len)
    end

    for i = TABLE_FIXED + 1, TABLE_FIXED_END do
        decoders[i] = decoders[TABLE_FIXED]
    end
    --

    decoders[TABLE_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    --
    decoders[STR_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        local len = bty - STR_FIXED
        return decode_string(ctx, len)
    end

    for i = STR_FIXED + 1, STR_FIXED_END do
        decoders[i] = decoders[STR_FIXED]
    end
    --

    decoders[STR_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    --
    decoders[POSITIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return bty - POSITIVE_INT
    end

    for i = POSITIVE_INT + 1, POSITIVE_INT_END do
        decoders[i] = decoders[POSITIVE_INT]
    end
    --

    decoders[UINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u8, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return u8
    end

    decoders[UINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return u16
    end

    decoders[UINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return u32
    end

    decoders[UINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000)
    end

    --
    decoders[NEGATIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        return NEGATIVE_INT - bty
    end

    for i = NEGATIVE_INT + 1, NEGATIVE_INT_END do
        decoders[i] = decoders[NEGATIVE_INT]
    end
    --

    decoders[NINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n8, err = read_byte(ctx)
        if n8 == nil then
            return nil, err
        end
        return -n8
    end

    decoders[NINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n16
    end

    decoders[NINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n32
    end

    decoders[NINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return -(b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000))
    end

    decoders[DOUBLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return decode_double(ctx)
    end

    decoders[VECTOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local x, y, z

        -- x
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        x, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- z
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        z, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Vector(x, y, z)
    end

    decoders[ANGLE] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local p, y, r

        -- p
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        p, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Angle(p, y, r)
    end

    decoders[ENTITY] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local ent_index

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        ent_index, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Entity(ent_index)
    end

    decoders[PLAYER] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local user_id

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        user_id, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Player(user_id)
    end

    decoders[COLOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local r, g, b, a

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- g
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        g, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- b
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        b, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- a
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        a, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Color(r, g, b, a)
    end

    function decode_array(ctx, len)
        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local arr = {nil, nil, nil, nil, nil, nil, nil, nil}

        local start_index = 1
        if read_type(ctx) == ARRAY_ZERO_BASED_INDEX then
            ctx[1] = ctx[1] + 1
            start_index = 0
        end

        for idx = start_index, len do
            local err, err_2
            local decoder
            local val

            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end

            arr[idx] = val
        end

        return arr
    end
    Decoder.decode_array = decode_array

    function decode_table(ctx, len)
        local err, err_2
        local decoder
        local key, val

        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local tbl = {nil, nil, nil, nil, nil, nil, nil, nil}
        for _ = 1, len do
            -- key
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            key, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            -- val
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            tbl[key] = val
        end

        return tbl
    end
    Decoder.decode_table = decode_table

    function decode_string(ctx, len)
        local index = ctx[1]
        if index + len - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + len - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + len

        return sub(ctx[2], index, index + len - 1)
    end
    Decoder.decode_string = decode_string

    function decode_double(ctx)
        local b1, b2, b3, b4, b5, b6, b7, b8 = byte(ctx, 8)
        if b1 == nil then
            return nil, b2
        end

        --Separate out the values
        local sign = b1 >= 128 and 1 or 0
        local exponent = (b1 % 128) * 16 + floor(b2 / 16)
        local fraction = (b2 % 16) * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8
        --Handle special cases
        if exponent == 2047 then
            --Infinities
            if fraction == 0 then return ((sign == 0 and 1) or -1) * HUGE end
            --NaN
            if fraction == 0xfffffffffffff then return 0 / 0 end
        end

        --Combine the values and return the result
        if exponent == 0 then
            --Handle subnormal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * (fraction / 0x10000000000000)
        else
            --Handle normal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * ((fraction / 0x10000000000000) + 1)
        end
    end
    Decoder.decode_double = decode_double

    function read_type(ctx)
        local typ = str_byte(ctx[2], ctx[1])
        return typ
    end
    Decoder.read_type = read_type

    function read_byte(ctx)
        local bty, err = byte(ctx, 1)
        if bty == nil then
            return nil, err
        end
        return bty
    end
    Decoder.read_byte = read_byte

    function read_word(ctx)
        local b1, b2 = byte(ctx, 2)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x100 + b2
    end
    Decoder.read_word = read_word

    function read_dword(ctx)
        local b1, b2, b3, b4 = byte(ctx, 4)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x1000000 + b2 * 0x10000 + b3 * 0x100 + b4
    end
    Decoder.read_dword = read_dword
end

wOS.SFS_EXTERN = {
    Encoder = Encoder, -- to allow usage of internal functions
    Decoder = Decoder, -- to allow usage of internal functions

    encode = Encoder.encode,
    encode_with_buffer = Encoder.encode_with_buffer,
    encode_array = Encoder.encode_array,

    decode = Decoder.decode,
    decode_with_max_size = Decoder.decode_with_max_size,

    set_type_function = function(t_fn) -- this is for me as I have custom type function in sam/scb to allow type function to get jit compiled :c
        type = t_fn
    end,

    add_encoder = function(typ, encoder)
        encoders[typ] = encoder
        if FREE_FOR_CUSTOM == FREE_FOR_CUSTOM_END then
            return nil, "No more free slots for custom encoders"
        end
        FREE_FOR_CUSTOM = FREE_FOR_CUSTOM + 1
        return FREE_FOR_CUSTOM - 1
    end,

    add_decoder = function(typ, decoder)
        decoders[typ] = decoder
    end,

    chars = chars,
    VERSION = "2.0.1"
}

function wOS.SFS_EXTERN:Compress( data_table )
    if not data_table then return nil, "NO DATA PRESENT" end
    local encoded, err = self.encode( data_table )
    if err then return encoded, err end
    return util.Compress( encoded )
end

function wOS.SFS_EXTERN:RawCompress( data_table )
    if not data_table then return nil, "NO DATA PRESENT" end
    local encoded, err = self.encode( data_table )
    if err then return encoded, err end
    return encoded
end

function wOS.SFS_EXTERN:Decompress( data )
    if not data then return nil, "NO DATA PRESENT" end
    local decomp = util.Decompress( data )
    return self.decode( decomp )
end

function wOS.SFS_EXTERN:RawDecompress( data )
    if not data then return nil, "NO DATA PRESENT" end
    return self.decode( data )
end
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_tool/cl_wos_simulation_tool.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local SWEP = {}

SWEP.ToolNameHeight = 0
SWEP.InfoBoxHeight = 0
SWEP.WepSelectIcon = surface.GetTextureID( "vgui/gmod_tool" )
SWEP.Gradient = surface.GetTextureID( "gui/gradient" )
SWEP.InfoIcon = surface.GetTextureID( "gui/info" )

SWEP.PrintName = "Combat Simulation Tool"
SWEP.Slot = 5
SWEP.SlotPos = 6
SWEP.HoldType = "pistol"
--SWEP.Author	        = "Jan (wiltOS)"

SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel	= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.Category = "[wOS] Passive Event"
SWEP.UseHands = true

SWEP.Primary = {}
SWEP.Primary.Swap           = Sound( "weapons/clipempty_rifle.wav" )
SWEP.Primary.Sound			= Sound( "NPC_CombineCamera.Click" )
SWEP.Primary.Delete1		= Sound( "Weapon_StunStick.Melee_Hit" )
SWEP.Primary.Delete			= Sound( "Weapon_StunStick.Melee_HitWorld" )

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.Secondary = {}
SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

-- TODO: Add "Modify Border Points"

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "ToolMode" )
	self:NetworkVar( "Int", 1, "ToolStep" )

	self:NetworkVar( "Entity", 0, "SelectedSimulator")
end

function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
end

function SWEP:PrimaryAttack()
    if not IsFirstTimePredicted() then return end

	local mode = self:GetToolMode()
	local step = self:GetToolStep()
	local trace = self:GetOwner():GetEyeTrace()

	if mode == WOS_CSS.MODE.INITIAL then
		local ent = trace.Entity
		if !IsValid(ent) then return end
		if ent:GetClass() == "prop_physics" then
			self:CreateSimulator(ent)
		end
	elseif mode == WOS_CSS.MODE.AREASELECT then
		local ent = trace.Entity

		if step == WOS_CSS.AREASELECT.BORDER then
			if IsValid(ent) and ent:GetClass() == "wos_simulation_system" then
				return
			end
			self:SelectBorderPoint(trace)
		elseif step == WOS_CSS.AREASELECT.HEIGHT then
			if IsValid(ent) and ent:GetClass() == "wos_simulation_system" then
				-- TODO: Validation
				self:FinishAreaSelectMode()
				return
			end
			self:SelectHeightPoint(trace)
		end
	elseif mode == WOS_CSS.MODE.POINTSELECT then
		self:DoVarPrimary()
	end
end

function SWEP:SecondaryAttack()
    if not IsFirstTimePredicted() then return end

	local mode = self:GetToolMode()
	local step = self:GetToolStep()
	
	if mode == WOS_CSS.MODE.AREASELECT then
		if step != WOS_CSS.AREASELECT.BORDER then return end
		self:RemoveBorderPoint()
	elseif mode == WOS_CSS.MODE.POINTSELECT then
		self:DoVarSecondary()
	end

end

function SWEP:Reload()
    if not IsFirstTimePredicted() then return end

	timer.Create("wOS.CombatSim.ReloadTime", 1, 1, function()
		self.LastReloadPressed = false
	end)

	if self.LastReloadPressed then return end
	self.LastReloadPressed = true

	local mode = self:GetToolMode()
	local step = self:GetToolStep()

	if mode == WOS_CSS.MODE.POINTSELECT then
		wOS.CombatSim:OpenSimulationCreator(simulator)
		return
	elseif mode == WOS_CSS.MODE.SIMSELECTED then
        wOS.CombatSim:OpenSimulationCreator(simulator)
	end

end

function SWEP:Think()
end

function SWEP:Deploy()
    local cur_pan = wOS.PES:GetActiveMenu()
    if !IsValid(cur_pan) then return end
    if !cur_pan.menu then return end
    if not cur_pan.menu.CreationType then return end 
    if cur_pan.menu.CreationType == WOS_PES.CREATOR.SIMULATION then return end
    cur_pan:Remove()
end

function SWEP:Holster()
	return true
end

function SWEP:CreateSimulator(ent)
	self.SelectedBorderPoints = {}
	self.SelectedHeight = 0
end

function SWEP:SelectBorderPoint(trace)
	table.insert(self.SelectedBorderPoints, trace.HitPos)
end

function SWEP:RemoveBorderPoint()
	self.SelectedBorderPoints[#self.SelectedBorderPoints] = nil
end

function SWEP:SelectHeightPoint(trace)
	local firstPoint = self.SelectedBorderPoints[1]
	
	if isvector(firstPoint) then
		self.SelectedHeight = trace.HitPos.z - firstPoint.z
	end
end

function SWEP:FinishAreaSelectMode()
	wOS.CombatSim:OpenSimulatorNameMenu(self.SelectedBorderPoints, self.SelectedHeight)
end

function SWEP:DoVarPrimary(trace)
	local simulator = self:GetSelectedSimulator()
	if simulator == self then return end
	if not IsValid(simulator) then return end
	if simulator:GetClass() != "wos_simulation_system" then return end
  
	local wtbl = weapons.Get( "wos_pes_tool" )
	if not wtbl then return end

	local hookname = "wOS.CombatSim.EnforceVarPrimaryPlacement." .. self:EntIndex()
	hook.Add( "wOS.CombatSim.CanPlaceEntity", hookname, function( wep, ply, pos ) 
		if wep != self then return end
		if ply != LocalPlayer() then return end
		local inside = simulator:CheckInBorders(pos + Vector(0, 0, 1)) -- Offset because the floor isn't 100% inside.
		if inside then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		notification.AddLegacy( "[wOS-PES] You can't operate vars outside the simulation area.", NOTIFY_ERROR, 3 )
		return false
	end )

	local success = wtbl.PrimaryAttack( self )
	hook.Remove( "wOS.CombatSim.CanPlaceEntity", hookname )
end

function SWEP:DoVarSecondary()
	local simulator = self:GetSelectedSimulator()
	if simulator == self then return end
	if not IsValid(simulator) then return end
	if simulator:GetClass() != "wos_simulation_system" then return end
  
	local wtbl = weapons.Get( "wos_pes_tool" )
	if not wtbl then return end

	local hookname = "wOS.CombatSim.EnforceVarSecondaryPlacement." .. self:EntIndex()
	hook.Add( "wOS.CombatSim.CanPlaceEntity", hookname, function( wep, ply, pos ) 
		if wep != self then return end
		if ply != LocalPlayer() then return end
		local inside = simulator:CheckInBorders(pos + Vector(0, 0, 1)) -- Offset because the floor isn't 100% inside.
		if inside then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		notification.AddLegacy( "[wOS-PES] You can't operate vars outside the simulation area.", NOTIFY_ERROR, 3 )
		return false
	end )

	local success = wtbl.SecondaryAttack( self )
	hook.Remove( "wOS.CombatSim.CanPlaceEntity", hookname )
end

local w,h = ScrW(), ScrH()
function SWEP:DrawHUD()
	local mode = self:GetToolMode()
	local step = self:GetToolStep()
	
	if mode != WOS_CSS.MODE.POINTSELECT then
		draw.SimpleText("Simulation System Tool", "wOS.CombatSim.MainFont", w * 0.02, h * 0.02, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		draw.SimpleText("Create new or configure existing Combat Simulators.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	end

	if mode == WOS_CSS.MODE.INITIAL then
		draw.SimpleText("Simulator Selection / Creation", "wOS.CombatSim.LeaderFont", w * 0.02, h * 0.09, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

		draw.SimpleText("Create a new simulator by left-clicking a prop.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		draw.SimpleText("Select an existing simulator by left-clicking its console.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.15, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	elseif mode == WOS_CSS.MODE.AREASELECT then
		draw.SimpleText("Simulator Area Creation", "wOS.CombatSim.LeaderFont", w * 0.02, h * 0.09, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

		if step == WOS_CSS.AREASELECT.BORDER then
			draw.SimpleText("Left-click to add a border point to the simulator area.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("Right-click to remove the last border point from the simulator area.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.14, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("Left-click the simulator console to confirm border.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.16, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		elseif step == WOS_CSS.AREASELECT.HEIGHT then
			draw.SimpleText("Left-click to set the border height of the simulator area.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("Left-click the simulator console to confirm height.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.15, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
		
		draw.SimpleText("Press R to abort creation.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.18, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	elseif mode == WOS_CSS.MODE.SIMSELECTED then
		draw.SimpleText("Simulator | Challenges Creation/Editing", "wOS.CombatSim.LeaderFont", w * 0.02, h * 0.09, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	elseif mode == WOS_CSS.MODE.POINTSELECT then
		local wtbl = weapons.Get( "wos_pes_tool" )
		if not wtbl then return end
		local success = wtbl.DrawHUD( self )
		self.RenderScreen = wtbl.RenderScreen
	end
end

weapons.Register(SWEP, "wos_simulation_tool")
--addons/billy_gas/lua/vgui/bvgui/colormixer.lua:
local matGradient = Material( "vgui/gradient-u" )
local matGrid = Material( "gui/alpha_grid.png", "nocull" )

local PANEL = {}

function PANEL:Init()
	self.ColorMixer = vgui.Create("DColorMixer", self)
	self.ColorMixer:SetPalette(false)

	self.ColorMixer.HSV.Knob.Paint = nil 
	self.ColorMixer.HSV.PaintOver = function(s,w,h)
		self.GottenRGB = s:GetRGB()
		self.ColorContrast = bVGUI.TextColorContrast(self.GottenRGB)

		local x,y = s.Knob:GetPos()
		local ww,hh = s.Knob:GetSize()
		surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
		surface.DrawOutlinedRect(0,0,w,h)
		draw.NoTexture()

		surface.DrawPoly({
			{x=x,y=y},
			{x=x+ww,y=y},
			{x=x+math.ceil(ww/2),y=y+math.ceil(hh/2)},
		})
		surface.DrawRect(x,y-hh,ww,hh)

		surface.SetDrawColor(self.ColorContrast)
		surface.DrawRect(x+2,y-hh+2,ww-4,hh-4)

		surface.SetDrawColor(self.GottenRGB)
		surface.DrawRect(x+3,y-hh+3,ww-6,hh-6)
	end

	self.ColorMixer.colPrev = self.ColorMixer.WangsPanel:Add( "DPanel" )
	self.ColorMixer.colPrev:SetTall( 20 )
	self.ColorMixer.colPrev:Dock( TOP )
	self.ColorMixer.colPrev:DockMargin( 0, 4, 0, 0 )
	self.ColorMixer.colPrev.Paint = function(s,w,h)
		if !self.GottenRGB then return end
		
		surface.SetDrawColor(self.GottenRGB)
		surface.DrawRect(0,0,w,h)
		surface.SetDrawColor(self.ColorContrast)
		surface.DrawOutlinedRect(0,0,w,h)
	end

	function self.ColorMixer.Alpha:Paint(w, h)
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(matGrid)
		local size = 128
	
		for i = 0, math.ceil(h / size) do
			surface.DrawTexturedRect(w / 2 - size / 2, i * size, size, size)
		end
	
		surface.SetDrawColor(self.m_BarColor)
		surface.SetMaterial(matGradient)

		surface.DrawTexturedRect(0, 0, w, h)
		surface.DrawTexturedRect(0, 0, w, h)

		surface.SetDrawColor(0, 0, 0, 250)
		self:DrawOutlinedRect()
		surface.DrawRect(2, (1 - self.m_Value) * h - 3, w - 4, 6)

		surface.SetDrawColor(255, 255, 255, 250)
		surface.DrawRect(4, (1 - self.m_Value) * h - 1, w - 8, 2)
	end
	
	function self.ColorMixer.RGB:Paint(w, h)
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(self.Material)

		surface.DrawTexturedRect(0, 0, w, h)
		
		surface.SetDrawColor(0, 0, 0, 250)
		self:DrawOutlinedRect()
		surface.DrawRect(2, self.LastY - 3, w - 4, 6)
		
		surface.SetDrawColor(255, 255, 255, 250)
		surface.DrawRect(4, self.LastY - 1, w - 8, 2)
	end
end

function PANEL:SetColor(col)
	self.ColorMixer:SetColor(col)
end
function PANEL:GetColor()
	return self.ColorMixer:GetColor()
end

function PANEL:SetLabel(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContentsX()
	self.Label:SetTall(21)
end

function PANEL:PerformLayout()
	self.ColorMixer:AlignBottom(0)
	if (IsValid(self.Label)) then
		self.ColorMixer:SetSize(self:GetTall() * 1.6, self:GetTall() - self.Label:GetTall())
	else
		self.ColorMixer:SetSize(self:GetTall() * 1.6, self:GetTall())
	end
end

derma.DefineControl("bVGUI.ColorMixer", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/bvgui/form.lua:
local PANEL = {}

function PANEL:Init()
	self:SetColumns(bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK, bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN, bVGUI.COLUMN_LAYOUT_COLUMN_GROW)
end

function PANEL:SetTextSize(textsize)
	self.TextSize = textsize
end

function PANEL:CreateLabel(text, icon)
	if (ispanel(text)) then return text end
	local icon_container
	if (icon) then
		icon_container = vgui.Create("bVGUI.BlankPanel", self)
		icon_container:SetTall(16)
		icon_container.icon = vgui.Create("DImage", icon_container)
		icon_container.icon:SetSize(16,16)
		icon_container.icon:SetImage(icon)
	end

	local label
	if (icon) then
		label = vgui.Create("DLabel", icon_container)
	else
		label = vgui.Create("DLabel", self)
	end
	label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", self.TextSize or 16))
	label:SetTextColor(bVGUI.COLOR_WHITE)
	label:SetText(text)
	label:SizeToContents()
	label:SetContentAlignment(7)
	label:SetWrap(true)
	label:SetAutoStretchVertical(true)
	if (icon) then
		function label:PerformLayout()
			icon_container:SetSize(16 + 5 + self:GetWide(), self:GetTall())
			self:AlignLeft(16 + 5)
		end
		return icon_container
	else
		return label
	end
end

function PANEL:AddSpacing(h)
	local pnl1 = vgui.Create("bVGUI.BlankPanel", self)
	pnl1:SetSize(0,h)
	local pnl2 = vgui.Create("bVGUI.BlankPanel", self)
	pnl2:SetSize(0,h)
	local pnl3 = vgui.Create("bVGUI.BlankPanel", self)
	pnl3:SetSize(0,h)
	self:AddRow(pnl1,pnl2,pnl3)
end

function PANEL:AddButton(text, btncolor, help, func)
	local btn = vgui.Create("bVGUI.Button", self)
	btn:SetColor(btncolor)
	btn:SetText(text)
	btn:SetTall(25)
	if (func) then
		function btn:DoClick()
			func()
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, btn, l2)

	return l1, btn, l2
end

function PANEL:AddSwitch(text, state, help, func)
	local switch = vgui.Create("bVGUI.Switch", self)
	switch:SetChecked(state)
	switch:SetText("")
	if (func) then
		function switch:OnChange()
			func(switch:GetChecked())
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, switch, l2)

	return l1, switch, l2
end

function PANEL:AddCheckbox(text, state, help, func)
	local switch = vgui.Create("bVGUI.Checkbox_Crossable", self)
	switch:SetChecked(state)
	switch:SetText("")
	if (func) then
		function switch:OnChange()
			func(switch:GetChecked())
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, switch, l2)

	return l1, switch, l2
end

function PANEL:AddComboBox(text, selected, help, func, icon)
	local combobox = vgui.Create("bVGUI.ComboBox", self)
	if (selected) then combobox:SetValue(selected) end
	if (func) then
		function combobox:OnSelect(index, value, data)
			func(index, value, data)
		end
	end

	local l1 = self:CreateLabel(text, icon)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, combobox, l2)

	return l1, combobox, l2
end

function PANEL:AddTextEntry(text, value, help, func, validation, placeholder, icon)
	local textentry = vgui.Create("bVGUI.TextEntry", self)
	textentry:SetValue(value)
	if (placeholder) then
		textentry:SetPlaceholderText(placeholder)
	end
	local prev_val = value
	function textentry:OnValueChange(val)
		if (validation == nil or validation(val) == true) then
			prev_val = val
			if (func) then func(val) end
		else
			self:SetValue(prev_val)
			self:SetText(prev_val)
			GAS:PlaySound("error")
		end
	end

	local l1 = self:CreateLabel(text, icon)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, textentry, l2)

	return l1, textentry, l2
end

function PANEL:AddLongTextEntry(...)
	local l1, textentry, l2 = self:AddTextEntry(...)

	textentry:SetMultiline(true)
	textentry:SetContentAlignment(7)
	textentry:SetTall(75)

	return l1, textentry, l2
end

function PANEL:AddNumberEntry(text, value, help, func, allow_negative)
	local textentry = vgui.Create("bVGUI.TextEntry", self)
	textentry:SetNumeric(true)
	textentry:SetValue(value)
	local prev_val = value
	function textentry:OnValueChange(val)
		if (not tonumber(self:GetValue()) or (allow_negative ~= true and tonumber(self:GetValue()) < 0)) then
			self:SetValue(prev_val)
			self:SetText(prev_val)
			GAS:PlaySound("error")
		else
			prev_val = self:GetValue()
			if (func) then func(tonumber(val)) end
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, textentry, l2)

	return l1, textentry, l2
end

function PANEL:AddColorMixer(text, value, help, func, alpha)
	local colormixer = vgui.Create("DColorMixer", self)
	colormixer:SetAlphaBar(alpha == true)
	colormixer:SetPalette(false)
	colormixer:SetTall(120)
	if (value) then
		colormixer:SetColor(value)
	end
	if (func) then
		function colormixer:ValueChanged(col)
			func(col)
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, colormixer, l2)

	return l1, colormixer, l2
end

derma.DefineControl("bVGUI.Form", nil, PANEL, "bVGUI.ColumnLayout")
--gamemodes/starwarsrp/gamemode/modules/terminals/sh_terminals.lua:
--test
--gamemodes/starwarsrp/gamemode/modules/player/sh_money.lua:
AOCRP.Player = AOCRP.Player or {}
local meta = FindMetaTable("Player")


function meta:canAfford(amount)
    local money = self:getMoney()
    if money >= amount then
        return true
    else 
        return false
    end
end

function meta:getMoney()
    return self:GetAOCMoney()
end


--gamemodes/starwarsrp/gamemode/modules/gui/cl_playersettings.lua:
AOCRP.PlayerSettings = AOCRP.PlayerSettings or {}



function AOCRP.PlayerSettings:OpenMenu()
    if ValidPanel(self.FRAME) then self.FRAME:Remove() end

    self.FRAME = AOCDerma:DefaultFrame()
    self.FRAME:SetSize(AOCW(600), AOCH(1000))
    self.FRAME:Center()
    self.FRAME:SetNewTitle("AOC:RP Einstellungen")
    self.FRAME:SetSizable(false)
    self.FRAME:SetDraggable(false)

    local ScrollPanel = AOCDerma:ScrollBar(self.FRAME) 
    ScrollPanel:Dock( FILL )

    for k, v in SortedPairs(AOCRP.Config.PlayerSettings) do
        local btn = AOCDerma:Button(ScrollPanel, v.name, function() 
            
            if ValidPanel(self.FRAME) then self.FRAME:Remove() end

            if v.cmd then 
                LocalPlayer():ConCommand(v.cmd) 
            end 

            if v.func then 
                v.func() 
            end
        
        
        end, "b")
        btn:Dock(TOP)
        btn:DockMargin(0,0,0,AOCH(5))
    end
end



--gamemodes/starwarsrp/gamemode/modules/comlink/sh_comlink.lua:
AOCRP.Comlink = AOCRP.Comlink or {}
local meta = FindMetaTable("Player")


function AOCRP.Comlink:GetAllPlayersHearingChannel(chan)
    local plys = {}
    for k, v in pairs(player.GetHumans()) do
        if v:WouldHearChannel(chan) then
            table.insert(plys, v)
        end
    end
    return plys
end

function meta:WouldHearChannel(chan)
    if AOCRP.Comlink:ChannelCanHear(self, chan) then
        if !self:ComlinkIsChannelMuted(chan) then
            return true
        end
    end
    return false
end


function meta:IsComlinkChannelMuted(chan)
    if !self.AOCRP_Comlink_Muted then
        return false
    end
    return table.HasValue(self.AOCRP_Comlink_Muted,chan)
end



function meta:ComlinkSetInactive()
    if SERVER then
        self:SetNetVar("AOCRP_Comlink_Active", "")
    else
        net.Start("AOCRP.Comlink.ComlinkSetInactive")
        net.SendToServer()    
    end
end

local function FToVar(f)
    if f == "f1" then
        return AOCRP_Comlink_F1
    end
    if f == "f2" then
        return AOCRP_Comlink_F2
    end
    if f == "f3" then
        return AOCRP_Comlink_F3
    end    
end
function meta:ComlinkSetQuickBind(f)

    

    local chan = FToVar(f)

    if chan == "" then self:ComlinkSetInactive() return end 

    if chan == self:ComlinkGetActiveChannel() then
        surface.PlaySound(AOCRP.Config.ComlinkSound)
        self:ComlinkSetInactive()    
        return 
    end

    surface.PlaySound(AOCRP.Config.ComlinkSound)
    self:ComlinkSetActiveChannel(chan)
end

function meta:ComlinkSetActiveChannel(chanID)
    
    if !chanID then return end
    if !AOCRP.Comlink.Channels[chanID] then print("[AOCRP] ".. self:Nick().. " versuchte Channel "..chanID.." zu schalten, dieser existiert aber nicht.") return end 
    if !AOCRP.Comlink:ChannelCanSpeak(self, chanID) then print("[AOCRP] ".. self:Nick().. " versuchte Channel "..chanID.." zu schalten, das darf er aber nicht.") return end  
 
    if SERVER then
        self:SetNetVar("AOCRP_Comlink_Active", chanID)
    else
        net.Start("AOCRP.Comlink.SetActiveChannel")
        net.WriteString(chanID)
        net.SendToServer()    
    end
end

function meta:ComlinkGetActiveChannel()
    return self:GetNetVar("AOCRP_Comlink_Active", "")
end

if CLIENT then
    
    function meta:ComlinkMuteChannel(chan)
        net.Start("AOCRP.Comlink.MuteChannel")
        net.WriteString(chan)
        net.SendToServer()
    end
end

-- SetActiveChannel
if SERVER then
    util.AddNetworkString("AOCRP.Comlink.SetActiveChannel")
        util.AddNetworkString("AOCRP.Comlink.ComlinkSetInactive")
         util.AddNetworkString("AOCRP.Comlink.MuteChannel")
     util.AddNetworkString("AOCRP.Comlink.MuteData")
    
    net.Receive( "AOCRP.Comlink.MuteChannel", function( len, ply )
        local chan = tonumber(net.ReadString())

        AOCRP.Comlink.Mute(ply, chan)
        AOCRP.Comlink.SendMuteData(ply)
    end)

    function AOCRP.Comlink.Mute(ply, chan)
        --if !ply.AOCRP_Comlink_Muted then ply.AOCRP_Comlink_Muted = {} end
        if ply:IsComlinkChannelMuted(chan) then
            table.RemoveByValue(ply.AOCRP_Comlink_Muted, chan)
        else 
            table.insert(ply.AOCRP_Comlink_Muted, chan)
        end     
    end

    function AOCRP.Comlink.SendMuteData(ply)

        net.Start("AOCRP.Comlink.MuteData")
        net.WriteTable(ply.AOCRP_Comlink_Muted)
        net.Send(ply)
    end

    function AOCRP.Comlink.DoSpawnThings(ply, muteChannels)
        ply:SetNetVar("AOCRP_Comlink_Active", "")

        if !ply.AOCRP_Comlink_Muted then ply.AOCRP_Comlink_Muted = {} end
        
        if muteChannels then
            for k, v in pairs(AOCRP.Comlink.Channels) do
                if v.defMute then
                    if !table.HasValue(ply.AOCRP_Comlink_Muted, k) then
                        table.insert(ply.AOCRP_Comlink_Muted, k)
                    end
                end
            end
            AOCRP.Comlink.SendMuteData(ply)
        end
    end



    function meta:ComlinkIsChannelMuted(chan)
        return table.HasValue(self.AOCRP_Comlink_Muted, chan)
    end
    

    function meta:ComlinkDeactivated()
        return false
    end

end

if CLIENT then
    net.Receive( "AOCRP.Comlink.MuteData", function( len, ply )
        local muteData = net.ReadTable()

        LocalPlayer().AOCRP_Comlink_Muted = muteData
    end)
end 

if SERVER then
    net.Receive( "AOCRP.Comlink.SetActiveChannel", function( len, ply )
        local chanID = tonumber(net.ReadString())
        if ( IsValid( ply ) and ply:IsPlayer() ) then
            if !AOCRP.Comlink.Channels[chanID] then print("[AOCRP] ".. ply:Nick().. " versuchte Channel "..chanID.." zu schalten, dieser Existiert aber nicht.") return end 
            if !AOCRP.Comlink:ChannelCanSpeak(ply, chanID) then print("[AOCRP] ".. ply:Nick().. " versuchte Channel "..chanID.." zu schalten, das darf er aber nicht.") return end  
            
            ply:SetNetVar("AOCRP_Comlink_Active", chanID)
        end
    end )


    net.Receive( "AOCRP.Comlink.ComlinkSetInactive", function( len, ply )
        ply:SetNetVar("AOCRP_Comlink_Active", "")
    end )
end

--gamemodes/starwarsrp/gamemode/modules/char/sh_char.lua:
AOCRP.CharSys = AOCRP.CharSys or {}

local meta = FindMetaTable("Player")


local function insert_dash(str)
  -- Extract the first two digits and the rest of the string
  local first_two = string.sub(str, 1, 2)
  local rest = string.sub(str, 3)

  -- Insert the dash between the first two digits and the rest of the string
  return first_two .. "-" .. rest
end

function AOCRP.CharSys:IDToDashID(id)
    return insert_dash(id)
end

function meta:AOCName()

  local class = player_manager.GetPlayerClass( self )
  if class == "player_aocrp" then
    if self:GetCloneID() != 0 then
        if self:GetHideCloneID() then
            return self:GetCloneName()
        else
            local fancyID = insert_dash(self:GetCloneID())
            return fancyID.." "..self:GetCloneName()
        end

    end
  end

  return self:SteamID64()

end



function AOCRP.CharSys:IsCorrectID(id)
  id = tonumber(id)

  if id then
    if id > 111111 && id < 999999 then
        return true
    end
  end
  return false
end

function AOCRP.CharSys:IdToPlayer(id)
  for k, v in pairs(player.GetHumans()) do
    if tonumber(v:GetCloneID()) == tonumber(id) then
         return v
    end 
 end
 return nil 
end


function meta:IsInChar()
  return self:GetCloneID() != 0
end

function meta:GetName()
  return self:AOCName()
end

function meta:Name()
  return self:AOCName()
end

function meta:Nick()
  return self:AOCName()
end



function AOCRP.CharSys:AllowedCharSlots(ply)
    if ply:GetAOCVIP() then
        return 5
    end

    if AOCRP.Config.CharSlots[ply:GetUserGroup()] then
        return AOCRP.Config.CharSlots[ply:GetUserGroup()] 
    end

    return 1
end
--gamemodes/starwarsrp/gamemode/modules/abilitys/cl_ability.lua:
--
AOCRP.Ability = AOCRP.Ability or {}


function AOCRP.Ability:LoadAbilitys()
    AOCRP.API:Request("getabilitybychar", function(data) 
        AOCRP_ABILITYS = {}
		if (type(data) == "table" and #data > 0) then
            for k, v in pairs(data) do
                AOCRP_ABILITYS[v.ability] = v
            end

            local temp = table.Copy(AOCRP_ABILITYS)

            for l, p in pairs(AOCRP.Ability.Items) do
                if p.requires != nil then
                    if !AOCRP_ABILITYS[p.requires] then continue end
            
                    if AOCRP_ABILITYS[l] then
                        print("Removeing " .. p.requires .. " because we own ".. p.name)
                        temp[p.requires] = nil
                    end
                end
            end

            AOCRP_ABILITYS = table.Copy(temp)



            
            AOCRP.QIM.BTNS["ability"] = {}

            for k, v in SortedPairs(AOCRP.Ability.Items) do
                AOCRP.QIM.BTNS["ability"][#AOCRP.QIM.BTNS["ability"]+1] = { 
                    title = v.name,
                    runFunc = function()         
                        net.Start("AOCRP.Ability.Select")
                        net.WriteString(k)
                        net.SendToServer()
                    end,
                    limitFunc = function() 
                        if AOCRP_ABILITYS then
                                
                            if AOCRP_ABILITYS[k] then
                                return true
                            end
                        end
                        return false
                    end,
                }
            end

        end;
    end, {cloneid=LocalPlayer():GetCloneID()})
end

net.Receive( "AOCRP.Ability.LoadData", function( len, ply )
    AOCRP.Ability:LoadAbilitys()
end )



--addons/wos-passiveevent-ageo/lua/wos/pes/vars/angle.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Angle"
VAR.UseTool = true
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Save your current aiming angles", key = "gui/lmb.png", },
}

VAR.IsValid = function(varTable, value)
    if not isangle(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel.Value = value

    function panel:Paint(ww, hh)
        if isangle(self.Value) then
            draw.SimpleText("Angle set at: " .. tostring(self.Value), nil, ww * 0.5, hh * 0.5, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw.SimpleText("Angle needs to be set!", nil, ww * 0.5, hh * 0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    return panel
end

VAR.GetValue = function(panel)
    return panel.Value
end

VAR.PrimaryAttack = function(wep, ply, panel)
    panel.Value = ply:EyeAngles()
end

VAR.OnStart = function(node, value, var)
    if !isangle(value) then

        local vec = Angle(value)
        if vec then
            node:SetVar(var.Name, vec)
        end
    end
end

VAR.Draw3D = function(wep, ply, element)
    local ang = element.Value
    if not isangle(vec) then return end

    local pos = EyePos()
    render.DrawLine(pos, pos + ang:Forward() * 30 , Color(255, 255, 255), false)
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/color.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Color"
VAR.IsValid = function(varTable, value)
    if not IsColor(value) and not istable( value ) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local colorMixer = vgui.Create("DColorMixer")

    if not IsColor( value ) and istable( value ) then
        value = Color( value.r or value.x, value.g or value.y, value.b or value.z, value.a or 255 )
    end

    if IsColor(value) then
        colorMixer:SetColor(value)
    else
        colorMixer:SetColor(varTable.Default)
    end

    return colorMixer
end

VAR.GetValue = function(colorMixer)
    return colorMixer:GetColor()
end


return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/vector.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Vector"
VAR.DirtyValidate = true
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Save the position you are AIMING AT", key = "gui/lmb.png", },
    { text = "Save your current EYE position", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Save your current STANDING position", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
}

VAR.IsValid = function(varTable, value)
    if not isvector(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel.Value = value

    function panel:Paint(ww, hh)
        if isvector(self.Value) then
            draw.SimpleText("Vector set at: " .. tostring(self.Value), nil, ww * 0.5, hh * 0.5, Color(125, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw.SimpleText("Vector needs to be set!", nil, ww * 0.5, hh * 0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    return panel
end

VAR.GetValue = function(panel)
    return panel.Value
end

VAR.PrimaryAttack = function(wep, ply, panel)
    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end
    panel.Value = pos
end

VAR.OnStart = function(node, value, var)
    if !isvector(value) then

        local vec = Vector(value)
        if vec then
            node:SetVar(var.Name, vec)
        end
    end
end

VAR.Draw3D = function(wep, ply, element)
    local vec = element.Value
    if not isvector(vec) then return end

    local top = Vector(vec.x, vec.y, vec.z + 200)
    render.DrawLine(vec, top, Color(255, 255, 255), false)
end


return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_settings.lua:
// Might want to spilt files up

wOS.PES.Settings = wOS.PES.Settings or {}

wOS.PES.Settings.List = wOS.PES.Settings.List or {}

function wOS.PES.Settings.GetList()
	return wOS.PES.Settings.List
end

function wOS.PES.Settings.Register(tbl)
	wOS.PES.Settings.List[tbl.Name] = tbl
end

wOS.PES.Settings.Register({
	Name = "Random Events Run",
	Description = "",
	Type = "Boolean",
	Default = true,
})

wOS.PES.Settings.Values = wOS.PES.Settings.Values  or {}


function wOS.PES.Settings.Get(varName, fallback)
	if wOS.PES.Settings.Values[varName] != nil then
		return wOS.PES.Settings.Values[varName]
	elseif wOS.PES.Settings.List[varName] then
		return wOS.PES.Settings.List[varName].Default
	end

	return fallback
end


if SERVER then

	hook.Call( "wOS.PES.PostLoaded", "Settings.Sync", function()
		// For the players that missed the auth request

		if file.Exists("wos/pes/settings.json") then
			local json = file.Read("wos/pes/settings.json")

			local tbl = util.JSONToTable(json)
			if tbl then
				wOS.PES.Settings.Values = tbl
			end
		end
		local func = hook.GetTable()["PlayerAuthed"]["wOS.PES.Settings.Sync"]
		for index, ply in ipairs(player.GetAll()) do
			func(ply)
		end
	end )

	util.AddNetworkString("wOS.PES.Sync.Setting")
	util.AddNetworkString("wOS.PES.Sync.Settings")

	function wOS.PES.Settings.Set(varName, value, ply)
		wOS.PES.Settings.Values[varName] = value

		net.Start("wOS.PES.Sync.Setting")
			net.WriteString(varName)
			net.WriteType(value)
		net.Broadcast()

		//hook.Call("wOS.PES.SettingSet" .. varName, nil, varName, value, ply)
		
		timer.Create("wOS.PES.Settings.Save", 0, 1,  function()
			local json = util.TableToJSON(wOS.PES.Settings.Values)
			file.Write("wos/pes/settings.json", json)
		end)
	end

	hook.Add("PlayerAuthed", "wOS.PES.Settings.Sync", function(ply)
		timer.Simple(5, function()
			net.Start("wOS.PES.Sync.Settings")
				local count = table.Count(wOS.PES.Settings.Values)

				net.WriteUInt(count, 8)

				local keyTbl = table.GetKeys(wOS.PES.Settings.Values)
				for x = 1, count do
					net.WriteString(keyTbl[x])
					net.WriteType(wOS.PES.Settings.Values[ keyTbl[x] ])
				end
			net.Send(ply)
		end)
	end)
else
	net.Receive("wOS.PES.Sync.Settings", function()
		local count = net.ReadUInt(8)

		local settings = {}
		for x = 1, count do
			settings[net.ReadString()] = net.ReadType()
		end
	end)

	net.Receive("wOS.PES.Sync.Setting", function()
		wOS.PES.Settings.Values[net.ReadString()] = net.ReadType()
	end)
end

function wOS.PES:SelectableMaps()
	return wOS.PES.Modules:Get("map").Maps
end

function wOS.PES:SelectableNextBots()
    local npcs = {}

    for k, v in pairs(AOCRPNextbots.Config.Tool) do
        table.insert(npcs, v.name)
    end

    return npcs
end

function wOS.PES:SpawnableWeapons()
	// Default the HL2 weapons
	local dummy_tbl = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["weapon_crowbar"] = true,
		["weapon_pistol"] = true,
		["weapon_357"] = true,
		["weapon_smg1"] = true,
		["weapon_ar2"] = true,
		["weapon_shotgun"] = true,
		["weapon_crossbow"] = true,
		["weapon_frag"] = true,
		["weapon_rpg"] = true,
		["weapon_bugbait"] = true,
	}
	// Get only real, spawnable weapons
	for _, weapon in pairs(weapons.GetList()) do
		if !weapon.Spawnable then continue end
		dummy_tbl[ weapon.ClassName ] = true
	end

	// Relooping ensures it's in alphabetical order
	local tbl = {}
	for weapon, _ in SortedPairs( dummy_tbl ) do
		table.insert( tbl, weapon )
	end

	return tbl
end
--addons/wos-passiveevent-ageo/lua/wos/css/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}
wOS.CombatSim.GameTypes = wOS.CombatSim.GameTypes or {}

local w,h = ScrW(), ScrH()

surface.CreateFont( "wOS.CombatSim.MainFont", {
	font = "Bebas Neue",
	extended = false,
	size = 40*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.MainFontB", {
	font = "Bebas Neue",
	extended = false,
	size = 44*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.LeaderFont", {
	font = "Bebas Neue",
	extended = false,
	size = 36*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.MediumFont", {
	font = "Bebas Neue",
	extended = false,
	size = 32*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.SmallFont", {
	font = "Bebas Neue",
	extended = false,
	size = 30*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.DescFont", {
	font = "Bebas Neue",
	extended = false,
	size = 24*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )


local blur = Material("pp/blurscreen")

local function DrawBlur(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, w, h)
	end
end

local createChallengeIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )
local joinGameIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )

function wOS.CombatSim:AddExitButton(backFunction)
	if not self.SimulatorMenu then return end
	
	local exitbutt = vgui.Create( "DButton", self.SimulatorMenu )
	exitbutt:SetSize( self.SimulatorMenu.SizeT.h * 0.08, h * 0.03 )
	exitbutt:SetPos(  self.SimulatorMenu.SizeT.w * 0.92, h * 0.0125 )
	exitbutt:SetText( "" )
	exitbutt.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText("X", "wOS.CombatSim.MainFont", ww*0.5, hh*0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText("X", "wOS.CombatSim.MainFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end
	exitbutt.DoClick = function( pan )
		if self.SimulatorMenu.Clicked then return end

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
		
		net.Start("wOS.CombatSim.ResetTool")
		net.SendToServer()
	end
	
	if isfunction(backFunction) then
		local backButton = vgui.Create( "DButton", self.SimulatorMenu )
		backButton:SetSize( self.SimulatorMenu.SizeT.h * 0.08, h * 0.03 )
		backButton:SetPos(  self.SimulatorMenu.SizeT.w * 0.025 + w * 0.0125, h * 0.0125 )
		backButton:SetText( "" )
		backButton.Paint = function( pan, ww, hh )
			if pan:IsHovered() then
				draw.SimpleText("<", "wOS.CombatSim.MainFontB", ww*0.5, hh*0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			else
				draw.SimpleText("<", "wOS.CombatSim.MainFontB", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end
		backButton.DoClick = function( pan )
			if isfunction(backFunction) then
				backFunction()
			end
		end
	end
end

function wOS.CombatSim:OpenMenu(simulator)
	if IsValid(self.SimulatorMenu) then
		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
		return
	end

	self.SelectedSimulator = simulator
	
	gui.EnableScreenClicker( true )
	
	self.SimulatorMenu = vgui.Create( "DFrame" )
	self.SimulatorMenu:SetSize( 0, 0 )
	self.SimulatorMenu:SetTitle( "" )
	self.SimulatorMenu:SetDraggable( false )
	self.SimulatorMenu:ShowCloseButton( false )
	self.SimulatorMenu:Center()
	self.SimulatorMenu.SizeT = { w = w*0.66, h = h*0.33 }
	self.SimulatorMenu.LastSize = { w = w*0.66, h = 0 }
	self.SimulatorMenu.Title = ""
	self.SimulatorMenu.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.FrameColor )
		surface.DrawPoly( background )
		DrawBlur( pan, 2 )
		
		draw.SimpleText( pan.Title, "wOS.CombatSim.MainFont", ww/2, h*0.04, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		surface.SetDrawColor( color_white )
		surface.DrawLine( ww*0.05, h*0.045, ww*0.95, h*0.045 )
	end
	self.SimulatorMenu.Think = function( pan )
		pan.LastSize.h = ( pan.LastSize.h == pan.SizeT.h and pan.LastSize.h ) or Lerp( FrameTime()*16, pan.LastSize.h, pan.SizeT.h )
		pan.LastSize.w = ( pan.LastSize.w == pan.SizeT.w and pan.LastSize.w ) or Lerp( FrameTime()*16, pan.LastSize.w, pan.SizeT.w )
		pan:SetSize( pan.LastSize.w, pan.LastSize.h )
		pan:Center()
	end
	self.SimulatorMenu.Clear = function( pan )
		local children = pan:GetChildren()
		for i=5, #children do
			children[i]:Remove()
		end
	end
	self.SimulatorMenu.ToggleClose = function( pan )
		pan:Clear()
		pan:SetKeyboardInputEnabled(false)
		pan:SetMouseInputEnabled(false)

		self.SimulatorMenu = nil

		gui.EnableScreenClicker( false )

		pan.SizeT.h = 8
		timer.Simple( 0.15, function()
			if not IsValid( pan ) then return end

			pan.SizeT.w = 0
			timer.Simple(0.15, function()
				if not IsValid( pan ) then return end
				pan:Remove()
			end)
		end )

		timer.Remove("WOS.CSS.LobbyTimer")
	end

	self.SimulatorMenu:MakePopup()
	
	self:AddExitButton()
end

function wOS.CombatSim:OpenSimulatorMenu(simulator, challenges)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.66, h = h*0.88 }
	self.SimulatorMenu.Title = "SIMULATOR: " .. simulator:GetSimulatorName()
	self.SimulatorMenu:Clear()
	timer.Simple(0, function() self:AddExitButton() end)
	
	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	self.InnerFrameCurrent = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	self.InnerFrameCurrent.XScroll = false
	self.InnerFrameCurrent:SetSize( rw*0.48, rh*0.9 )
	self.InnerFrameCurrent:SetPos( rw*0.01, rh*0.075 )
	self.InnerFrameCurrent:SetPanelSize(rw * 0.46, rh * 0.06)
	self.InnerFrameCurrent:SetPanelSpacing(rw * 0.01)
	self.InnerFrameCurrent.ChallengeName = ""
	self.InnerFrameCurrent.GameType = ""
	self.InnerFrameCurrent.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}

		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
		
		draw.SimpleText("Aktuell: " .. pan.ChallengeName, "wOS.CombatSim.LeaderFont", ww*0.5, hh*0.01, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(pan.GameType, "wOS.CombatSim.LeaderFont", ww*0.5, hh*0.05, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
	
	self.InnerframeQueue = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	self.InnerframeQueue.XScroll = false
	self.InnerframeQueue:SetSize( rw*0.48, rh*0.8 )
	self.InnerframeQueue:SetPos( rw*0.51, rh*0.135 )
	self.InnerframeQueue:SetPanelSize(rw * 0.46, rh * 0.06)
	self.InnerframeQueue:SetPanelSpacing(rw * 0.01)
	self.InnerframeQueue.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
		
		draw.SimpleText("Warteschlange", "wOS.CombatSim.LeaderFont", ww*0.5, hh*0.01, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end

	self.CreatePartyButton = vgui.Create("DButton", self.SimulatorMenu)
	self.CreatePartyButton:SetSize( rw*0.15, rh*0.05 )
	self.CreatePartyButton:SetPos( rw*0.8, rh*0.065 )
	self.CreatePartyButton:SetFont( "wOS.CombatSim.MediumFont" )
	self.CreatePartyButton:SetText( "Erstellen" )

	self.CreatePartyButton.DoClick = function(pan)
		local challengeName = self.ChallengeSelector:GetValue()
		if isstring(challengeName) and challengeName ~= "" then
			if challengeName == "Simulationswahl" then
				surface.PlaySound( "buttons/lightswitch2.wav" )
                AOCRP.HUD:Notification(LocalPlayer(), {text="Du musst zuerst eine Simulation auswählen!", barcolor=Color(255,0,0)}) 
				return
			end

			net.Start("wOS.CombatSim.QueueParty")
				net.WriteEntity(simulator)
				net.WriteString(challengeName)
				net.WriteBool((self.OpenSelector:GetValue() or "") == "Offen")
			net.SendToServer()

			self.SimulatorMenu.Clicked = true
			self.SimulatorMenu:ToggleClose()
		end
	end

	self.LeaveQueueButton = vgui.Create("DButton", self.SimulatorMenu)
	self.LeaveQueueButton:SetSize( rw*0.15, rh*0.05 )
	self.LeaveQueueButton:SetPos( rw*0.55, rh*0.065 )
	self.LeaveQueueButton:SetFont( "wOS.CombatSim.LeaderFont" )
	self.LeaveQueueButton:SetText( "Leave Party" )
	self.LeaveQueueButton:SetVisible(false)
	self.LeaveQueueButton.DoClick = function(pan)
		if pan.PartyLeader then
			net.Start("wOS.CombatSim.DequeueParty")
				net.WriteEntity(simulator)
				net.WriteInt(pan.PartyId, 32)
			net.SendToServer()
		else
			net.Start("wOS.CombatSim.LeaveParty")
				net.WriteEntity(simulator)
				net.WriteInt(pan.PartyId, 32)
			net.SendToServer()
		end

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
	end
	
	self.StartGameButton = vgui.Create("DButton", self.SimulatorMenu)
	self.StartGameButton:SetSize( rw*0.15, rh*0.05 )
	self.StartGameButton:SetPos( rw*0.8, rh*0.065 )
	self.StartGameButton:SetFont( "wOS.CombatSim.LeaderFont" )
	self.StartGameButton:SetText( "Starten" )
	self.StartGameButton:SetVisible(false)
	self.StartGameButton.DoClick = function(pan)
		net.Start("wOS.CombatSim.StartGame")
			net.WriteEntity(simulator)
		net.SendToServer()

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
	end

	self.OpenSelector = vgui.Create("DComboBox", self.SimulatorMenu)
	self.OpenSelector:SetSize( rw*0.1, rh*0.05 )
	self.OpenSelector:SetPos( rw*0.7, rh*0.065 )
	self.OpenSelector:SetFont( "wOS.CombatSim.SmallFont" )
	self.OpenSelector:SetValue( "Offen" )
	self.OpenSelector:AddChoice("Offen")
	self.OpenSelector:AddChoice("Einladung")

	self.ChallengeSelector = vgui.Create("DComboBox", self.SimulatorMenu)
	self.ChallengeSelector:SetSize( rw*0.15, rh*0.05 )
	self.ChallengeSelector:SetPos( rw*0.55, rh*0.065 )
	self.ChallengeSelector:SetFont( "wOS.CombatSim.SmallFont" )
	self.ChallengeSelector:SetValue( "Simulationswahl" )

	self.RefreshButton = vgui.Create("DButton", self.SimulatorMenu)
	self.RefreshButton:SetSize( rw*0.15, rh*0.03 )
	self.RefreshButton:SetPos( rw*0.675, rh*0.95 ) -- TODO
	self.RefreshButton:SetFont( "wOS.CombatSim.MediumFont" )
	self.RefreshButton:SetText( "Refreshen" )
	self.RefreshButton.DoClick = function(pan)
		net.Start("wOS.CombatSim.GetGameInfo")
			net.WriteEntity(simulator)
		net.SendToServer()
	end

	for name, _ in pairs(challenges) do
		self.ChallengeSelector:AddChoice(name)
	end

	net.Start("wOS.CombatSim.GetGameInfo")
		net.WriteEntity(simulator)
	net.SendToServer()

	timer.Create("WOS.CSS.LobbyTimer", 10, 0,function()
		net.Start("wOS.CombatSim.GetGameInfo")
			net.WriteEntity(simulator)
		net.SendToServer()
	end)
end

function wOS.CombatSim:UpdateSimulatorMenuQueue(simulator, partyQueue)
	if not self.SimulatorMenu then
		-- TODO: Stop Auto Updating
		return
	end

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	self.InnerframeQueue:Clear()

	for partyId, partyData in pairs(partyQueue) do
		if table.HasValue(partyData.Players, LocalPlayer():SteamID64()) then
			if partyId == 1 and partyData.CreatorSteamId64 == LocalPlayer():SteamID64() then
				self.StartGameButton:SetVisible(true)
				self.LeaveQueueButton.PartyLeader = true
				self.LeaveQueueButton:SetText("Beenden")
				
				self.OpenSelector:SetText(partyData.Open and "Offen" or "Einladung")
				self.OpenSelector.OnSelect = function(pan, i, text, data)
					net.Start("wOS.CombatSim.ChangePartyOpen")
						net.WriteEntity(simulator)
						net.WriteInt(partyId, 32)
						net.WriteBool(text == "Open")
					net.SendToServer()
					
					self.SimulatorMenu.Clicked = true
					self.SimulatorMenu:ToggleClose()
				end
			else
				self.OpenSelector:SetVisible(false)
			end

			self.CreatePartyButton:SetVisible(false)
			self.ChallengeSelector:SetVisible(false)

			self.LeaveQueueButton:SetVisible(true)
			self.LeaveQueueButton.PartyId = partyId
		end
		
		local ply = player.GetBySteamID64(partyData.CreatorSteamId64)
		if IsValid(ply) then
			local plyPanel = self.InnerframeQueue:CreatePanel("DPanel")
			plyPanel.Paint = function( pan, ww, hh )
				local background = {
					{ x = 0           , y = hh*0.05 },
					{ x = 0  + hh*0.05, y = 0       },
					{ x = ww - hh*0.05, y = 0       },
					{ x = ww          , y = hh*0.05 },
					{ x = ww          , y = hh*0.95 },
					{ x = ww - hh*0.05, y = hh      },
					{ x = 0  + hh*0.05, y = hh      },
					{ x = 0           , y = hh*0.95 },		
				}
				draw.NoTexture()
				surface.SetDrawColor( wOS.CombatSim.FrameColor )
				surface.DrawPoly( background )		
				DrawBlur( pan, 1 )

				draw.SimpleText("Erstellt von: " .. ply:GetName(), "wOS.CombatSim.MediumFont", rw*0.01, rh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

				draw.SimpleText("Teilnehmer: " .. #partyData.Players, "wOS.CombatSim.SmallFont", rw*0.01, rh*0.035, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
				draw.SimpleText("Simulation: " .. partyData.QueuedChallenge, "wOS.CombatSim.SmallFont", rw*0.45, rh*0.035, white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)

				if pan:IsHovered() then
					cam.Start2D()
						local x = gui.MouseX()
						local y = gui.MouseY()

						local n = #partyData.Players
						draw.RoundedBox(0, x, y, rw * 0.25, rh * 0.025 * n, Color(255, 255, 255))

						for i, plySteamId64 in pairs(partyData.Players) do
							local partyPly = player.GetBySteamID64(plySteamId64)
							if IsValid(partyPly) then
								draw.SimpleText(partyPly:GetName(), "wOS.CombatSim.SmallFont", x, y + rh * 0.025 * (i-1), Color(0, 0, 0), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
							end

						end
					cam.End2D()
				end
			end

			if partyData.CreatorSteamId64 == LocalPlayer():SteamID64() then
				local inviteButton = vgui.Create("DButton", plyPanel)
				inviteButton:SetPos(rw*0.35, rh*0.01)
                inviteButton:SetSize(rw*0.1, rh*0.03)
				inviteButton:SetFont( "wOS.CombatSim.SmallFont" )
				inviteButton:SetText( "Einladen" )
				inviteButton.DoClick = function(pan) 
					self:OpenSimulatorInviteMenu(simulator, partyId, partyData)
				end
			else
				if partyData.Open or table.HasValue(partyData.InvitedPlayers, LocalPlayer():SteamID64()) then
					if not table.HasValue(partyData.Players, LocalPlayer():SteamID64()) then 
						local joinButton = vgui.Create("DButton", plyPanel)
						joinButton:SetPos(rw*0.4, rh*0.01)
						joinButton:SetFont( "wOS.CombatSim.SmallFont" )
						joinButton:SetText( "Join" )
						joinButton.DoClick = function(pan) 
							net.Start("wOS.CombatSim.JoinParty")
								net.WriteEntity(simulator)
								net.WriteInt(partyId, 32)
							net.SendToServer()
							
							self.SimulatorMenu.Clicked = true
							self.SimulatorMenu:ToggleClose()
						end	
					end
				end
			end
		end
	end
end

function wOS.CombatSim:OpenSimulatorInviteMenu(simulator, partyId, partyData)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.33, h = h*0.66 }
	self.SimulatorMenu.Title = "Zur Simulation einladen"
	self.SimulatorMenu:Clear()
	timer.Simple(0, function() self:AddExitButton() end)
	
	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.05)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end
	
	for _, ply in pairs(player.GetHumans()) do
		if ply:SteamID64() == partyData.CreatorSteamId64 then continue end

		local isInvited = table.HasValue(partyData.InvitedPlayers, ply:SteamID64())

		local plyPanel = innerframe:CreatePanel("DPanel")
		plyPanel.Paint = function( pan, ww, hh )
			local background = {
				{ x = 0           , y = hh*0.05 },
				{ x = 0  + hh*0.05, y = 0       },
				{ x = ww - hh*0.05, y = 0       },
				{ x = ww          , y = hh*0.05 },
				{ x = ww          , y = hh*0.95 },
				{ x = ww - hh*0.05, y = hh      },
				{ x = 0  + hh*0.05, y = hh      },
				{ x = 0           , y = hh*0.95 },		
			}
			draw.NoTexture()
			surface.SetDrawColor( wOS.CombatSim.FrameColor )
			surface.DrawPoly( background )		
			DrawBlur( pan, 1 )

			draw.SimpleText(ply:GetName(), "wOS.CombatSim.MediumFont", rw*0.01, hh * 0.5, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		local selector = vgui.Create("DCheckBox", plyPanel)
		selector:SetSize(rh * 0.04, rh * 0.04)
		selector:SetPos(rw * 0.8, rh*0.0075)
		selector:SetValue(isInvited)
		selector.OnChange = function(pan, val)
			if val then
				table.insert(partyData.InvitedPlayers, ply:SteamID64())
			else
				table.RemoveByValue(partyData.InvitedPlayers, ply:SteamID64())
			end
		end
	end

	self.SetInviteButton = vgui.Create("DButton", self.SimulatorMenu)
	self.SetInviteButton:SetSize( rw*0.5, rh*0.05 )
	self.SetInviteButton:SetPos( rw*0.25, rh*0.925 )
	self.SetInviteButton:SetFont( "wOS.CombatSim.LeaderFont" )
	self.SetInviteButton:SetText( "Einladungen setzen" )
	self.SetInviteButton.DoClick = function(pan)

		net.Start("wOS.CombatSim.SetPartyInvites")
			net.WriteEntity(simulator)
			net.WriteInt(partyId, 32)
			net.WriteTable(partyData.InvitedPlayers)
		net.SendToServer()

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
	end
end

function wOS.CombatSim:UpdateSimulatorMenuGameInfo(simulator, gameInfo)
	if not self.SimulatorMenu then
		-- TODO: Stop Auto Updating
		return
	end

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	self.InnerFrameCurrent.ChallengeName = gameInfo.ChallengeName
	self.InnerFrameCurrent.GameType = gameInfo.GameType

	self.InnerFrameCurrent:Clear()

	for _, plyName in pairs(gameInfo.PlayerNames) do
		local plyPanel = self.InnerFrameCurrent:CreatePanel("DPanel")
		plyPanel.Paint = function( pan, ww, hh )
			local background = {
				{ x = 0           , y = hh*0.05 },
				{ x = 0  + hh*0.05, y = 0       },
				{ x = ww - hh*0.05, y = 0       },
				{ x = ww          , y = hh*0.05 },
				{ x = ww          , y = hh*0.95 },
				{ x = ww - hh*0.05, y = hh      },
				{ x = 0  + hh*0.05, y = hh      },
				{ x = 0           , y = hh*0.95 },		
			}
			draw.NoTexture()
			surface.SetDrawColor( wOS.CombatSim.FrameColor )
			surface.DrawPoly( background )
			DrawBlur( pan, 1 )

			draw.SimpleText(plyName, "wOS.CombatSim.MediumFont", rw*0.01, hh*0.5, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
	end
end

hook.Add("HUDPaint", "wOS.CombatSim.HUDPaint", function()
	local ply = LocalPlayer()

	-- if !ply:Alive() then
	-- 	local respawnTime = ply:GetNW2Float("wOS.CombatSim.RespawnTime", 0)
	-- 	if respawnTime == 0 then return end
	-- 	local diff = math.max(math.floor(respawnTime - CurTime()), 0)
	-- 	draw.SimpleText(diff .. "s until you can respawn!", "wOS.CombatSim.LeaderFont", ScrW() * 0.5, ScrH() * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	-- 	return
	-- end

    if !ply:Alive() then return end

	local simulator = ply:GetNW2Entity("wOS.CombatSim.Entity")
	if !IsValid(simulator) then return end

	local endTime = simulator:GetEndTime()
	if endTime <= CurTime() then return end

	local diff = math.max(math.floor(endTime - CurTime()), 0)
	draw.SimpleText(diff .. "s bis zum Ende der Simulation!", "wOS.CombatSim.LeaderFont", ScrW() * 0.5, ScrH() * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

end)
--addons/wos-passiveevent-ageo/lua/wos/css/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}

//PES STUFF

net.Receive("wOS.CSS.OpenToolMenu", function()
	local simulator = net.ReadEntity()
	if not IsValid( simulator ) then return end
	wOS.CombatSim:OpenToolMenu(simulator)
end)


net.Receive( "wOS.CSS.CreateNewSimulation", function( len, ply )
	local simulator = net.ReadEntity()
	if not IsValid( simulator ) then return end
	wOS.CombatSim:OpenSimulationCreator(simulator)
end )

net.Receive( "wOS.CSS.GetEditableChallenges", function(len, ply)
	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) or wep:GetClass() != "wos_simulation_tool" then return end
	
	local sim = wep:GetSelectedSimulator()
	if not IsValid( sim ) or sim == wep then return end

	local challenges = net.ReadTable()

	wOS.CombatSim:OpenToolPreChallengeMenu( challenges )
end )

//CSS ORIGINAL STUFF


















net.Receive("wOS.CombatSim.GetChallenges", function()
	local ply = LocalPlayer()

	local simulator = net.ReadEntity()

	if IsValid(simulator) and simulator:GetClass() == "wos_simulation_system" then
		wOS.CombatSim:OpenToolMenu(simulator)
	end
end)

net.Receive("wOS.CombatSim.OpenChallenges", function()
	local ply = LocalPlayer()

	local simulator = net.ReadEntity()
	if IsValid(simulator) and simulator:GetClass() == "wos_simulation_system" then
		local challenges = net.ReadTable()

		wOS.CombatSim:OpenSimulatorMenu(simulator, challenges)
	end
end)

net.Receive("wOS.CombatSim.UpdateWallCollisions", function()
	local wall = net.ReadEntity()
	if not IsValid( wall ) then return end
	local vertices = net.ReadTable()

	if IsValid(wall) and isfunction(wall.ApplyCustomCollisions) then
		wall:ApplyCustomCollisions(vertices)
	end
end)

net.Receive("wOS.CombatSim.GetGameInfo", function()
	local simulator = net.ReadEntity()
	if IsValid(simulator) and simulator:GetClass() == "wos_simulation_system" then
		local gameInfo = net.ReadTable()
		local partyQueue = net.ReadTable()

		wOS.CombatSim:UpdateSimulatorMenuGameInfo(simulator, gameInfo)
		wOS.CombatSim:UpdateSimulatorMenuQueue(simulator, partyQueue)
	end
end)
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_system/cl_wos_simulation_system.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local ENT = {}

ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Spawnable = false

-- Sets up the NetworkVars for the entity.
function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Activated" )

	self:NetworkVar( "Int", 0, "Score" )
	self:NetworkVar( "Int", 1, "StartTime" )
	self:NetworkVar( "Int", 2, "EndTime" )
	self:NetworkVar( "Int", 3, "BorderPointCount" )
	self:NetworkVar( "Int", 4, "BorderHeight" )
    
	self:NetworkVar( "String", 0, "SimulatorName" )

	self:NetworkVar( "Float", 0, "BorderUpdate" )
	
end

function ENT:PrepareCheckBorderValues()
	self.PreparedBorderValues = {}
	
	local borderPointCount = self:GetBorderPointCount()

	for i=1, borderPointCount do
		local preparedValue = {
			v = self:GetNW2Vector("BorderPoint" .. i)
		}

		self.PreparedBorderValues[i] = preparedValue
	end

	local j = borderPointCount

	for i=1, borderPointCount do
		local borderI = self.PreparedBorderValues[i].v
		local borderJ = self.PreparedBorderValues[j].v

		if borderJ.y == borderI.y then
			self.PreparedBorderValues[i].c = borderI.x
			self.PreparedBorderValues[i].m = 0
		else
			self.PreparedBorderValues[i].c = borderI.x - (borderI.y * borderJ.x) / (borderJ.y - borderI.y) + (borderI.y * borderI.x) / (borderJ.y - borderI.y)
			self.PreparedBorderValues[i].m = (borderJ.x - borderI.x) / (borderJ.y - borderI.y);
		end

		j = i
	end
end

-- Check if the Vector is inside the 2D border of the sim area.
--
-- @param Vector vec
-- @return Bool inBorders
function ENT:CheckInBorders2D(vec)
	local borderPointCount = self:GetBorderPointCount()

	if not self.PreparedBorderValues or #self.PreparedBorderValues ~= borderPointCount then 
		self:PrepareCheckBorderValues()
	end
	
	local j = borderPointCount
	local inBorders = false

	for i=1, borderPointCount do
		local borderI = self.PreparedBorderValues[i].v
		local borderJ = self.PreparedBorderValues[j].v

		if ((borderI.y<vec.y && borderJ.y>=vec.y || borderJ.y<vec.y && borderI.y>=vec.y)) then
			if (vec.y * self.PreparedBorderValues[i].m + self.PreparedBorderValues[i].c < vec.x) then
				inBorders = not inBorders
			end
	  	end

		j = i
	end

	return inBorders
end

-- Check if the given vector is inside the border of the sim area.
--
-- @param Vector vec
-- @return Bool inBorders
function ENT:CheckInBorders(vec)
	local firstPoint = self:GetNW2Vector("BorderPoint1")

	local heightt = self:GetBorderHeight()
	local below = vec.z - 50 < firstPoint.z + heightt
	local above = vec.z + 50 > firstPoint.z

	if heightt < 0 then
		below = vec.z - 50 < firstPoint.z 
		above = vec.z + 50 > firstPoint.z + heightt
	end

	if below && above then
		if self:CheckInBorders2D(vec) then
			return true
		end
	end

	return false
end

-- Returns the time left until the game ends.
--
-- @return Number timeLeft
function ENT:GetTimeLeft()
	return math.Round(CurTime() - self:GetStartTime(), 0)
end

-- Clientside Initialize
function ENT:Initialize()
	self.Positions = {}
	self.BorderUpdate = 0
end

-- Clientside Think
function ENT:Think()
	if self.BorderUpdate != self:GetBorderUpdate() and self:GetBorderUpdate() < CurTime() then
		self.BorderUpdate = self:GetBorderUpdate()
		self.PreparedBorderValues = nil
	end
end

-- Clientside OnRemove
function ENT:OnRemove()
end

---- Main Draw function.
--function ENT:Draw()
--	self:DrawModel()
--end

scripted_ents.Register(ENT, "wos_simulation_system")
--addons/weapons_other/lua/weapons/alydus_fusioncutter.lua:
--[[ 
	© Alydus.net
	Do not reupload lua to workshop without permission of the author

	Star Wars Fusion Cutter Repairer
	
	Alydus: (officialalydus@gmail.com | STEAM_0:1:57622640)
--]]

AddCSLuaFile()

if CLIENT then
	SWEP.PrintName = "F-187 Fusion Cutter"
	SWEP.Slot = 1
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false

	surface.CreateFont("Orbitron40", {font = "Orbitron Regular", size = 40})
end

SWEP.Author = "Alydus"
SWEP.Instructions = "A repairing utility weapon."
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.WorldModel = ""
SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.Category = "Alydus's Weapons"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Delay = 0.5

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 0.5

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/weapons/w_grenade.mdl"
SWEP.ShowViewModel = false
SWEP.DrawViewModel = false
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Pin"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01"] = { scale = Vector(1, 1, 1), pos = Vector(0, -1.297, 0), angle = Angle(0, 0, 0) }
}

SWEP.IronSightsPos = Vector(-13.04, 0, 1.24)
SWEP.IronSightsAng = Vector(0, 0, 0)

SWEP.VElements = {
	["fusioncutter"] = { type = "Model", model = "models/cosmo/starwarscutter.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(-0.519, 0.518, 1.557), angle = Angle(162.468, -180, 24.545), size = Vector(0.82, 0.82, 0.82), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["lighteffect"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Grenade_body", rel = "fusioncutter", pos = Vector(9.869, -0.519, 16.104), size = { x = 10, y = 10 }, color = Color(255, 0, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["lighteffect+"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Grenade_body", rel = "fusioncutter", pos = Vector(-1.558, -0.119, 9.67), size = { x = 1.599, y = 1.599 }, color = Color(255, 0, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}

SWEP.WElements = {
	["fusioncutter"] = { type = "Model", model = "models/cosmo/starwarscutter.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.596, 4.675, 3.635), angle = Angle(-8.183, -17.532, -146.105), size = Vector(0.885, 0.885, 0.885), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["lighteffect"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(16.104, -1.558, -12.988), size = { x = 10, y = 10 }, color = Color(255, 0, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}

if SERVER then
	-- hook.Add("PlayerSwitchWeapon", "Alydus_PlayerSwitchWeapon_FusionCutterInit", function(ply, oldWep, newWep)
	-- 	if IsValid(ply) and IsValid(oldWep) and IsValid(newWep) then
	-- 		if newWep:GetClass() == "alydus_fusioncutter" then
	-- 			ply:EmitSound("HL1/fvox/blip.wav")
	-- 		elseif ply:HasWeapon("alydus_fusioncutter") and IsValid(oldWep) and oldWep:GetClass() == "alydus_fusioncutter" then
	-- 			ply:EmitSound("HL1/fvox/hiss.wav")
	-- 		end
	-- 	end
	-- end)

	repairDatabase = {}
	repairDatabase["func_door"] = function(fusionCutter, ent, trace)
		if GetConVar("sv_starwarsfusioncutter_enable_door_unlocking"):GetInt() == 0 then
			return false
		end

		ent:Fire("Unlock", 1, 0)
		ent:Fire("Open", 1, 0)

		ParticleEffect("electrical_arc_01_system", ent:GetPos(), Angle(0, 0, 0))
	end
	repairDatabase["func_door_rotating"] = function(fusionCutter, ent, trace)
		repairDatabase["func_door"](fusionCutter, ent, trace)
	end
	repairDatabase["prop_door"] = function(fusionCutter, ent, trace)
		repairDatabase["func_door"](fusionCutter, ent, trace)
	end
	repairDatabase["prop_door_rotating"] = function(fusionCutter, ent, trace)
		repairDatabase["func_door"](fusionCutter, ent, trace)
	end
	repairDatabase["alydus_destructiblefortification"] = function(fusionCutter, ent, trace)
		if alydusDestructibleFortificationExtension and GetConVar("alydus_defaultfortificationhealth") then
			local defaultHealth = GetConVar("alydus_defaultfortificationhealth"):GetInt()
			local hp = ent:GetFortificationHealth()

			if hp == false then
				return false
			end

			if hp <= defaultHealth - 50 then
				hp = hp + 50
			else
				hp = defaultHealth
			end

			if hp != ent:GetFortificationHealth() then
				ent:SetFortificationHealth(hp)
				return true
			else
				return false
			end
		end
	end

	repairDatabase["droneRefuel"] = function(fusionCutter, ent, trace)
		if ent:IsDroneDestroyed() then
			return false
		else
			if math.Round(ent:GetFuel()) < ent.MaxFuel then
				ent:SetFuel(ent:GetFuel() + 10)
				return true
			else
				return false
			end
		end
	end
	repairDatabase["starwarsVehicleRepair"] = function(fusionCutter, ent, trace)
		local hp = ent:GetNWInt("Health", 0)

		if hp <= ent.StartHealth - 50 then
			hp = hp + 50
		else
			hp = ent.StartHealth
		end

		if hp != ent:GetNWInt("Health", 0) then
			ent:SetNWInt("Health", hp)
			return true
		else
			return false
		end
	end
	repairDatabase["lfsVehicleRepair"] = function(fusionCutter, ent, trace)
		local hp = ent:GetHP()

		if hp <= ent.MaxHealth - 50 then
			hp = hp + 50
		else
			hp = ent.MaxHealth
		end

		if hp != ent:GetHP() then
			ent:SetHP(hp)
			return true
		else
			return false
		end
	end
	repairDatabase["lvsVehicleRepair"] = function(fusionCutter, ent, trace)
		local hp = ent:GetHP()

		if hp <= ent.MaxHealth - 50 then
			hp = hp + 50
		else
			hp = ent.MaxHealth
		end

		if hp != ent:GetHP() then
			ent:SetHP(hp)
			return true
		else
			return false
		end
	end
	repairDatabase["simfphysVehicleRepair"] = function(fusionCutter, ent, trace)
		local hp = ent:GetCurHealth()

		if hp <= ent:GetMaxHealth() - 100 then
			hp = hp + 100
		else
			hp = ent:GetMaxHealth()
		end

		if hp != ent:GetCurHealth() then
			ent:SetOnFire(false)
			ent:SetOnSmoke(false)

			if hp == ent:GetMaxHealth() then
				net.Start("simfphys_lightsfixall")
					net.WriteEntity(ent)
				net.Broadcast()

				if istable(ent.Wheels) then
					for i = 1, table.Count( ent.Wheels ) do
						local Wheel = ent.Wheels[ i ]
						if IsValid(Wheel) then
							Wheel:SetDamaged( false )
						end
					end
				end
			end

			ent:SetCurHealth(hp)
			return true
		else
			return false
		end
	end
	repairDatabase["scarsVehicleRepair"] = function(fusionCutter, ent, trace)
		if ent:IsDamaged() then
			ent.DoRepair = true
			ent:EmitSound("carStools/tune.wav", 100, math.random(80, 150))
			return true
		end
		
		return false
	end

	function exceptionContinue(ent)
		if ent.IS_DRR then
			return "droneRefuel"
		elseif ent.IsSWVehicle then
			return "starwarsVehicleRepair"
		elseif ent.LFS then
			return "lfsVehicleRepair"
		elseif ent.LVS then
			return "lvsVehicleRepair"
		elseif string.find(ent:GetClass(), "sent_sakarias_car") or string.find(ent:GetClass(), "sent_sakarias_carwheel") or string.find(ent:GetClass(), "sent_sakarias_carwheel_punked") then
			return "scarsVehicleRepair"
		elseif simfphys and simfphys.IsCar and simfphys.IsCar(ent) then
			return "simfphysVehicleRepair"
		end
		return false
	end
end

function SWEP:ShouldDrawViewModel()
	if CLIENT then
		return true
	end
end

function SWEP:PostDrawViewModel(vm, wep, ply)
	if CLIENT then
		local ply = self:GetOwner()
		local fade = math.abs(math.sin(CurTime() * 1.15))
		local bone = "ValveBiped.Grenade_body"

		if IsValid(vm) and IsValid(ply) and ply:HasWeapon(self:GetClass()) and vm:LookupBone(bone) then
			local atch = vm:GetBoneMatrix(vm:LookupBone(bone))
			local pos, ang = vm:GetBonePosition(vm:LookupBone(bone)), vm:GetBoneMatrix(vm:LookupBone(bone)):GetAngles()
			ang:RotateAroundAxis(ang:Right(), 90)

			cam.Start3D2D(pos - ang:Right() * 6 - ang:Forward() * 6.5 + ang:Right() * 5.65, Angle(0, ply:EyeAngles().y, ang.z) + Angle(180, 90, 160), 0.01)
				draw.SimpleText("F-187 Fusion Cutter", "Orbitron40", -300, -180, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				draw.SimpleText("LMB: Attempt Repair", "Orbitron40", -300, -140, Color(200, 200, 200, 255 * fade), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			cam.End3D2D()

			--render.DrawLine(pos + ang:Up() * -5, ply:GetEyeTrace().HitPos)
		end
	end
end

function SWEP:PrimaryAttack()
	if SERVER then
		local ply = self:GetOwner()
		local plyEyeTrace = ply:GetEyeTrace()
		local vm = ply:GetViewModel()
		local bone = "ValveBiped.Grenade_body"

		if IsValid(ply) and IsValid(plyEyeTrace.Entity) then
			if repairDatabase[plyEyeTrace.Entity:GetClass()] or exceptionContinue(plyEyeTrace.Entity) != false then
				if ply:GetPos():Distance(plyEyeTrace.Entity:GetPos()) > 300 then
					ply:EmitSound("items/medshotno1.wav")
				else
					local success = false
					if exceptionContinue(plyEyeTrace.Entity) == false then
						success = repairDatabase[plyEyeTrace.Entity:GetClass()](self, plyEyeTrace.Entity, plyEyeTrace)
					else
						success = repairDatabase[exceptionContinue(plyEyeTrace.Entity)](self, plyEyeTrace.Entity, plyEyeTrace)
					end

					if success == true then
						local effectdata = EffectData()
						effectdata:SetOrigin(plyEyeTrace.HitPos)
						effectdata:SetMagnitude(3)
						effectdata:SetScale(5)
						effectdata:SetRadius(2)
						util.Effect("cball_explode", effectdata, true, true)

						sound.Play("HL1/ambience/port_suckin1.wav", plyEyeTrace.HitPos, 75, 100, 1)

						if IsValid(vm) and vm:LookupBone(bone) then
							local atch = vm:GetBoneMatrix(vm:LookupBone(bone))
							local pos, ang = vm:GetBonePosition(vm:LookupBone(bone)), vm:GetBoneMatrix(vm:LookupBone(bone)):GetAngles()

							local effectData = EffectData()
							effectData:SetOrigin(pos)
							util.Effect("MuzzleFlash", effectData, true, true)

							local effectData = EffectData()
							effectData:SetOrigin(pos)
							effectData:SetNormal(pos:GetNormalized())
							effectData:SetMagnitude(1)
							effectData:SetScale(1)
							effectData:SetRadius(2)
							util.Effect("Sparks", effectData)
						end
					else
						ply:EmitSound("items/medshotno1.wav")
					end
				end
			else
				ply:EmitSound("items/medshotno1.wav")
			end

			self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		end
	end

	return false
end

function SWEP:SecondaryAttack()
	return false
end

function SWEP:Initialize()
	self:SetHoldType("slam")
	if CLIENT then
		self.VElements = table.FullCopy(self.VElements)
		self.WElements = table.FullCopy(self.WElements)
		self.ViewModelBoneMods = table.FullCopy(self.ViewModelBoneMods)

		self:CreateModels(self.VElements)
		self:CreateModels(self.WElements)
		
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					vm:SetColor(Color(255,255,255,1))
					vm:SetMaterial("Debug/hsv")
				end
			end
		end
	end
end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				local fade = math.abs(math.sin(CurTime() * 1.15))
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				if name != "lighteffect+" then
					render.DrawSprite(drawpos, v.size.x, v.size.y, Color(192, 57, 43, 255 * fade))
				else
					render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				end
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end
	 
	function SWEP:ResetBonePositions(vm)
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
	end

	function table.FullCopy( tab )
		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
	end
end
--lua/weapons/antlion_mace/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Antlion mace"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ant"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, Special +jump"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bomb", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bomb", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 23.377), angle = Angle(0, 90, 0), size = Vector(0.2, 0.2, 0.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bomb", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -33.896, 8), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bomb", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 23.377), angle = Angle(0, 90, 0), size = Vector(0.2, 0.2, 0.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}




SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 40
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Glass"
SWEP.Primary.Range       = 12

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0
SWEP.SetJumpPower=205

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
self.Owner:SetJumpPower(self.SetJumpPower)
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetJumpPower(self.SetJumpPower+20)
		self.SetJumpPower=self.SetJumpPower +25
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--gamemodes/starwarsrp/entities/weapons/aocrp_datapad.lua:
AddCSLuaFile()
if SERVER then
util.AddNetworkString( "COMMANDPAD_EntityInteractionOpen" )
end
if CLIENT then
    SWEP.PrintName = "Datapad"
    SWEP.Slot = 5
    SWEP.SlotPos = 0
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

SWEP.Author = ""
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = ""

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "AOCRP - Tools"
SWEP.Sound = "doors/door_latch3.wav"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/v_slam.mdl"
SWEP.WorldModel = "models/hunter/plates/plate.mdl"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Bip01_L_Hand"] = { scale = Vector(0.647, 0.647, 0.647), pos = Vector(-30, 0, 0), angle = Angle(0, 0, 0) },
	["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Bip01_L_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(-30, 0, 0), angle = Angle(0, 27.777, 180) }
}


SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)

SWEP.VElements = {
	["datapad"] = { type = "Model", model = "models/mig/datapad.mdl", bone = "Bip01_R_Finger0", rel = "", pos = Vector(5.714, -6.753, 0.518), angle = Angle(66.623, -64.287, 180), size = Vector(0.885, 0.885, 0.885), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["datapad"] = { type = "Model", model = "models/mig/datapad.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.635, 7.791, 0.518), angle = Angle(-29.222, -171.818, 162.468), size = Vector(0.82, 0.82, 0.82), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


function SWEP:PrimaryAttack()
	if !IsFirstTimePredicted() then return end


	if CLIENT then
		local traceent = self.Owner:GetEyeTrace().Entity	

		AOCRP.Datapad:DataPadFrame(traceent)
	end


	--self.Owner:ConCommand("commandpad")
end

function SWEP:SecondaryAttack()
	if !IsFirstTimePredicted() then return end
--[[ 	if SERVER then
		local traceent = self.Owner:GetEyeTrace().Entity
		if traceent:IsWorld() then return end
		net.Start("COMMANDPAD_EntityInteractionOpen")
		net.WriteEntity(traceent)
		net.Send(self.Owner)
		--net.Start("")
	end ]]
end

function SWEP:Reload()
   -- nix
end


--[[ 	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378 ]]
       
       
function SWEP:Initialize()
    self:SetHoldType("slam")
	// other initialize code goes here

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

--addons/arccw_weapons/lua/weapons/aocrp_dc15a_heavy.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Heavy DC-15a"
SWEP.Trivia_Class = "Heavy-Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a_hvy.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000400000001"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc15a.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-13, 6, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.NoHideLeftHandInCustomization = true

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.8,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 1.1,
    [HITGROUP_RIGHTARM] = 1.1,
}

SWEP.Damage = 30
SWEP.RangeMin = 530
SWEP.DamageMin = 15
SWEP.Range = 1200
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 413
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50
SWEP.Recoil = 0.23
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.11
SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 1
    },
    {
        Mode = 0
    },
}
SWEP.AccuracyMOA = 0.59
SWEP.HipDispersion = 447
SWEP.MoveDispersion = 54

-- Speed Mult
SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootSound = "armas/disparos/dc15le.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.987, -9.924, 0.939),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Iron Sights", 
        Slot = "optic",
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(-0.5,-1.7,11.5),
            vang = Angle(90,0,-40),
            wpos = Vector(6, 0.4, -4.8),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Bone = "dc-15a",
        Slot = {"dc15a_magazine_75"},
        Offset = {
            vpos = Vector(-1.7, -0.6, 2.5),
            vang = Angle(0, 0, 0),
        },
    },         
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = {"aocrp_ammo"},
    },
    {
        PrintName = "Grenade Launcher",
        DefaultAttName = "None",
        Slot = {"rep_ubgl"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.675),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.7),
            vang = Angle(90, 0, 0),
        },
    },      
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 31.2),
            vang = Angle(90, 0, 0),
        },
    },  
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.83, 10.273),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}

-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_dc15s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15s"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Damage = 20
SWEP.RangeMin = 500
SWEP.DamageMin = 10
SWEP.Range = 1344
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 375

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 1
    },
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "weapons/bf3/dc15a.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = true
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "armasclasicas/wpn_cis_medequip.wav",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },   
    {
        PrintName = "Werfeinrichtung",
        DefaultAttName = "None",
        Slot = "aocrp_ubgl",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1, 1.663),
            vang = Angle(90, 0, -90),
        },          
    },
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 0, 5.100),
        vmax = Vector(-0.2, 0, 9),
        },          
    },
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15",
        Slot = "stock",
        Offset = {
            vpos = Vector(0, 0.5, -9.1),
            vang = Angle(0, 0, -90),
        },
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 20
SWEP.DamageMin = 10
SWEP.RangeMin = 500
SWEP.Range = 1344
SWEP.Delay = 60 / 375
SWEP.Primary.ClipSize = 50
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_dc15sarc.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15SC"
SWEP.Category = 'REP'
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Damage = 32
SWEP.RangeMin = 500
SWEP.DamageMin = 10
SWEP.Range = 1344
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.24
SWEP.RecoilRise = 0.23
SWEP.Delay = 60 / 400

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "westar/blasters_f-11aba_heavycannon_laser_close_var_01.mp3"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "armasclasicas/wpn_cis_medequip.wav",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 0, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },   
    {
        PrintName = "Werfeinrichtung",
        DefaultAttName = "None",
        Slot = "aocrp_ubgl",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1, 1.663),
            vang = Angle(90, 0, -90),
        },          
    },
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 0, 5.100),
        vmax = Vector(-0.2, 0, 9),
        },          
    },
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15",
        Slot = "stock",
        Offset = {
            vpos = Vector(0, 0.5, -9.1),
            vang = Angle(0, 0, -90),
        },
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}
--addons/arccw_weapons/lua/weapons/aocrp_dc15x_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "REP"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-15x"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-15A Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dc15x.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc15x_v2.mdl"
SWEP.ViewModelFOV = 50
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -4),
    ang = Angle(165, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc15x.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 200
SWEP.RangeMin = 600
SWEP.DamageMin = 100
SWEP.Range = 1600
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 0
SWEP.BipodRecoil = 0.1

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 1.78
SWEP.RecoilSide = 0.36
SWEP.RecoilRise = 0.76

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.47
SWEP.HipDispersion = 2000
SWEP.MoveDispersion = 1000

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 67
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "shared/snipers/Shared_Corebass_Close_Sniper_VAR_03 0 4 0.ogg"
SWEP.ShootSound = "dc15x/SW02_Weapons_Blaster_DLT19X_Laser_Close_VAR_01 3 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.74, -12, 1.45),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 40,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -5, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"dc15x", ""}

-- SWEP.AttachmentElements = {
--     ["dc15x"] = {
--         VMMaterial = "asdzxc.vmt",
--     }
-- }

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    [2] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.0, -0.9, 6),
            vang = Angle(90, 0, -90),
            wpos = Vector(13.066, 1, -7.3),
            wang = Angle(-16, 0, 180)
        },
    },
    [3] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.0, 2.4, 15.2),
            vang = Angle(90, 0, -90),
            wang = Angle(165, 180, 0),
            wpos = Vector(22.5, 1, -6.2),
        },
    },          
    [4] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 0.8, 31),
            vang = Angle(90, 0, -0),
            wpos = Vector(38, 1.8, -12),
            wang = Angle(-15, 0, -90)
        },
    },
    [5] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 0.9, 36.7),
            vang = Angle (90, 0, -90),
            wpos = Vector(44.6, 1, -13.8),
            wang = Angle (-15, 0, 0)
        },
    }, 
    [6] = {
        PrintName = "Charm",
        DefaultAttName = "No Attachment",
        Slot = {"charm"},
        Bone = "sights",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(.8, 1, 8),
            vang = Angle(90, 0, -90),
            wpos = Vector(),
            wang = Angle()
        },
    },       
    [7] = {
        PrintName = "Killcounter",
        DefaultAttName = "No Attachment",
        Slot = {"killcounter"},
        Bone = "sights",
        Offset = {
            vpos = Vector(.8, 1, 8),
            vang = Angle(90, 0, -90),
            wpos = Vector(),
            wang = Angle()
        },
    }, 
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}
--gamemodes/starwarsrp/entities/weapons/aocrp_medicscanner.lua:
--[[--------------------------------------------
            DO NOT EDIT BELOW THIS LINE
--------------------------------------------]]
--
if (SERVER) then
    AddCSLuaFile()
end

-- Swep info
SWEP.PrintName = "Phasenscanner"
SWEP.Author = ""
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = ""
-- Spawnable
SWEP.AdminSpawnable = true
SWEP.Spawnable = true
-- Model
SWEP.ViewModel = Model("models/epsilon/cwa_furniture/wield/eps_wield_medicalscanner.mdl")
SWEP.WorldModel = Model("models/epsilon/cwa_furniture/wield/eps_wield_medicalscanner.mdl")
SWEP.UseHands = true

-- Client info
if (CLIENT) then
    SWEP.Category				= "AOCRP - Eingestellte Waffen"
    SWEP.Slot = 4
    SWEP.SlotPos = 2
    SWEP.ViewModelFOV = 69
    SWEP.DrawCrosshair = true
    SWEP.DrawAmmo = true
end

-- Primary attack info
SWEP.Primary.Ammo = "None"
SWEP.Primary.ClipSize = AOCRP.Config.DefaultMedicSupply
SWEP.Primary.DefaultClip = AOCRP.Config.DefaultMedicSupply
SWEP.Primary.Delay = 2
SWEP.Primary.Automatic = false
-- Secondary attack info
SWEP.Secondary.Ammo = "None"
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.ClipSize = -1


function SWEP:GetFiremodeName()
    return "Sanitätsmaterial"
end

function SWEP:PrimaryAttack()
    if !IsFirstTimePredicted() then return end 
    if CLIENT then return end 

    self:SetNextPrimaryFire(CurTime() + 2)

    if self:Clip1() <= 0 then 
        self:GetOwner():EmitSound("misc/sw01_characters_gunfoley_draw_blaster_var19.mp3")
        return 
    end  

    local eyeTrace = self:GetOwner():GetEyeTrace() 

    if eyeTrace.HitPos:DistToSqr(self:GetOwner():GetPos()) > 8000 then return end 
    if !IsValid(eyeTrace.Entity) then return end

    local ent = eyeTrace.Entity
    if IsValid(ent.BodyOf) then 

        if self:Clip1() < 200 then 
            self:GetOwner():EmitSound("misc/sw01_characters_gunfoley_draw_blaster_var19.mp3")
            return 
        end  

        AOCRP.Medic:DoRevive(ent.BodyOf,self:GetOwner())
        self:TakePrimaryAmmo(200)
    end

    if ent:IsPlayer() then



        local healAmount = 25
        local maxHealth = ent:GetMaxHealth()
        local currentHealth = ent:Health()

        if currentHealth >= maxHealth then 
            
            ent:EmitSound("everfall/equipment/squad_shield/start_stop/gadgets_burstshield_stop_var_02_05.mp3")
            return 
        
        end
        
        local newHealth = math.min(currentHealth + healAmount, maxHealth) -- Calculate new health without exceeding max health
        local healthToHeal = newHealth - currentHealth -- Calculate the actual amount being healed
    
        if self:Clip1() < healthToHeal then 
            self:GetOwner():EmitSound("misc/sw01_characters_gunfoley_draw_blaster_var19.mp3")
            return 
        end  


        ent:SetHealth(newHealth) -- Set the player's health to the new calculated value

        self:GetOwner():addMoney(1, "Behandlung")
        self:TakePrimaryAmmo(healthToHeal)

        ent:EmitSound("everfall/equipment/combat_heal/combatheal_var_0".. math.random(8) .. ".mp3")
    end
end


function SWEP:SecondaryAttack()
    if !IsFirstTimePredicted() then return end 
    if CLIENT then return end 

    local eyeTrace = self:GetOwner():GetEyeTrace() 

    if eyeTrace.HitPos:DistToSqr(self:GetOwner():GetPos()) > 8000 then return end 
    if !IsValid(eyeTrace.Entity) then return end

    local target = nil
    if IsValid(eyeTrace.Entity.BodyOf) then
        target = eyeTrace.Entity.BodyOf
    end

    if eyeTrace.Entity:IsPlayer() then
        target = eyeTrace.Entity
    end

    if !IsValid(target) then return end 

    net.Start("AOCRP.Medic.StartMedicChat")
    net.WriteEntity(self:GetOwner())
    net.Send(target)

    net.Start("AOCRP.Medic.StartMedicChat")
    net.WriteEntity(target)
    net.Send(self:GetOwner())
end 

-- Weapon 
function SWEP:Initialize()
    self.lastPrimaryFire = CurTime()
end

function SWEP:Deploy()
    self:SetHoldType("slam")

    return true
end

if CLIENT then
    local WorldModel = ClientsideModel(SWEP.WorldModel)

    -- Settings...
    WorldModel:SetNoDraw(true)

    function SWEP:DrawWorldModel()
        local _Owner = self:GetOwner()

        if (IsValid(_Owner)) then
            -- Specify a good position
            local offsetVec = Vector(-15, -6, -12)
            local offsetAng = Angle(0, 0, 180)
            
            local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
            if !boneid then return end

            local matrix = _Owner:GetBoneMatrix(boneid)
            if !matrix then return end

            local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

            WorldModel:SetPos(newPos)
            WorldModel:SetAngles(newAng)

            WorldModel:SetupBones()
        else
            WorldModel:SetPos(self:GetPos())
            WorldModel:SetAngles(self:GetAngles())
        end

        WorldModel:DrawModel()
    end
end
--addons/arccw_weapons/lua/weapons/aocrp_shock_grenade.lua:
SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "REP" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Droidenkracher"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Standard Shock ordnance with a timed fuse and a small-medium blast radius."

SWEP.Slot = 4

SWEP.CamAttachment = 3

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.nade",
    },
}

SWEP.IconOverride = "materials/entities/stun_grenade_meeks.png"

SWEP.FuseTime = 1

SWEP.Primary.Ammo = "grenade"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1300
SWEP.MuzzleVelocityAlt = 1300
SWEP.ShootEntity = "arccw_thr_ion"

SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.DefaultElements = {"shock_grenade"}

SWEP.AttachmentElements = {
    ["shock_grenade"] = {
        VMElements = {
            {
                Model = "models/arccw/shock_grenade.mdl",
                Bone = "def_c_base",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(-.5, -0.1, -.1),
                    ang = Angle(-35, -190, 90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/shock_grenade.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

WMOverride = "models/arccw/shock_grenade.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },

sound.Add({
    name =          "ArcCW_ThermalDet.holster1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var21.mp3"
    }),

sound.Add({
    name =          "ArcCW_ThermalDet.armthrow",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/shock/SW02_Weapons_Grenades_Shock_Beep_01.wav"
    }),

sound.Add({
    name =          "ArcCW_ThermalDet.deploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/gunfoley_blaster_sheathe_var_03.mp3"
    }),
       
sound.Add({
    name =          "ArcCW_ThermalDet.firstdeploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var19.mp3"
    }),
        
sound.Add({
    name =          "ArcCW_primer.button",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/buttonpress.mp3"
    }),

sound.Add({
    name =          "ArcCW_Underhand.explosion2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/underhand.mp3"
    }),
}
--addons/arccw_weapons/lua/weapons/aocrp_valken42.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = "Kraken/Masita/Meeks"
SWEP.PrintName = "Valken 42"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "Sonderanfertigung für die dumme Engineering Company"
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/valken38.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.ViewModel = "models/servius/weapons/viewmodels/c_valken38x.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_valken38x.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false

-- Damage & Tracer
SWEP.Damage = 26
SWEP.RangeMin = 700
SWEP.DamageMin = 14
SWEP.Range = 1500
SWEP.Penetration = 1.2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 80
SWEP.Recoil = 0.27
SWEP.RecoilSide = 0.18
SWEP.RecoilRise = 0.2
SWEP.Delay = 60 / 550
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}


SWEP.AccuracyMOA = 0.25
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 60
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/valken.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.99, -4.258, 1.029),
    Ang = Vector(0, 0.127, 2.813),
     Magnification = 1,
     SwitchToSound = "armasclasicas/wpn_cis_lgequip.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.ActivePos = Vector(3, 6, 0)
SWEP.ActiveAng = Angle(0, 0, 0)
SWEP.SprintPos = Vector(7, -0, 0)
SWEP.SprintAng = Angle(10, 40, 0)
SWEP.CustomizePos = Vector(10, -5, 3.8)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

--[[ -- Attachments 
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        WMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(20, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        },
    },
} ]]

SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0.18, -6.25, 1.273),
            vang = Angle(0, -90, 0),
            wpos = Vector(6, 1.5, -5),
            wang = Angle(-10, 2, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Laser/Flashlight", 
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0.972, 7.546, 0.651),
            vang = Angle(0, -90, 90),
            wpos = Vector(14, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
    },
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0, 1.628, 0),
            vang = Angle(0, -90, 0),
            wpos = Vector(9, .5, 2),
            wang = Angle(0, 0, 180)    
        },
        SlideAmount = {
        vmin = Vector(-0.2, 2, 0),
        vmax = Vector(-0.2, 7, 0),
        wmin = Vector(9, 0.8, -4), 
        wmax = Vector(9, 0.8, -4)
        },                  
    },     
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0.6, -7.752, 0.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(6, 1.8, -4.5),
            wang = Angle(0, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
--[[     ["fire"] = {
        Source = "Shoot"
    }, ]]
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "draw/sw01_characters_gunfoley_draw_blaster_var14.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "valken38_r1", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "valken38_r1",
    channel =       CHAN_ITEM,
    volume =        1.1,
    sound =             "armas/misc/standard_reload.ogg"
    }),
}

-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 26
SWEP.DamageMin = 14
SWEP.RangeMin = 100
SWEP.Range = 500
SWEP.Delay = 60 / 525
SWEP.Primary.ClipSize = 80
SWEP.Category = 'REP'
--addons/arccw_base_modified/lua/weapons/arccw_base/cl_customize2.lua:
local translate = ArcCW.GetTranslation
local try_translate = ArcCW.TryTranslation
local defaultatticon = Material("arccw/hud/atts/default.png", "mips smooth")
local blockedatticon = Material("arccw/hud/atts/blocked.png", "mips smooth")

local bullseye = Material("arccw/hud/bullseye.png", "mips smooth")
local mat_hit = Material("arccw/hud/hit.png", "mips smooth")
local mat_hit_dot = Material("arccw/hud/hit_dot.png", "mips smooth")

local pickx_empty = Material("arccw/hud/pickx_empty.png", "mips smooth")
local pickx_full = Material("arccw/hud/pickx_filled.png", "mips smooth")

local bird = Material("arccw/hud/arccw_bird.png", "mips smooth")

local iconlock = Material("arccw/hud/locked_32.png", "mips smooth")
local iconunlock = Material("arccw/hud/unlocked_32.png", "mips smooth")

local col_fg = Color(255, 255, 255, 255)
local col_fg_tr = Color(255, 255, 255, 100)
local col_shadow = Color(0, 0, 0, 255)
local col_button = Color(0, 0, 0, 175)
local col_button_hv = Color(75, 75, 75, 175)
local col_mayomustard = Color(255, 255, 127)
local mayoicons = false

local col_block = Color(50, 0, 0, 175)
local col_block_txt = Color(175, 10, 10, 255)

local col_bad = Color(255, 50, 50, 255)
local col_good = Color(100, 255, 100, 255)
local col_info = Color(150, 150, 255, 255)

local col_unowned = col_block
local col_unowned_txt = col_block_txt

local ss, rss, thicc

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

local function LerpColor(d, col1, col2)
    local r = Lerp(d, col1.r, col2.r)
    local g = Lerp(d, col1.g, col2.g)
    local b = Lerp(d, col1.b, col2.b)
    local a = Lerp(d, col1.a, col2.a)
    return Color(r, g, b, a)
end

local function DrawTextRot(span, txt, x, y, tx, ty, maxw, only)
    local tw, th = surface.GetTextSize(txt)

    span.TextRot = span.TextRot or {}

    if tw > maxw then
        local realx, realy = span:LocalToScreen(x, y)
        render.SetScissorRect(realx, realy, realx + maxw, realy + (th * 2), true)

        span.TextRot[txt] = span.TextRot[txt] or 0

        if !only then
            span.StartTextRot = span.StartTextRot or CurTime()
            span.TextRotState = span.TextRotState or 0 -- 0: start, 1: moving, 2: end
            if span.TextRotState == 0 then
                span.TextRot[txt] = 0
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 1
                end
            elseif span.TextRotState == 1 then
                span.TextRot[txt] = span.TextRot[txt] + (FrameTime() * ScreenScaleMulti(16))
                if span.TextRot[txt] >= (tw - maxw) + ScreenScaleMulti(8) then
                    span.StartTextRot = CurTime()
                    span.TextRotState = 2
                end
            elseif span.TextRotState == 2 then
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 3
                    span.StartTextRot = CurTime()
                end
            elseif span.TextRotState == 3 then
                span.TextRot[txt] = span.TextRot[txt] - (FrameTime() * ScreenScaleMulti(16))
                if span.TextRot[txt] <= 0 then
                    span.StartTextRot = CurTime()
                    span.TextRotState = 0
                end
            end
        end
        surface.SetTextPos(tx - span.TextRot[txt], ty)
        surface.DrawText(txt)
        render.SetScissorRect(0, 0, 0, 0, false)
    else
        surface.DrawText(txt)
    end
end

local function multlinetext(text, maxw, font)
    local content = {}
    local tline = ""
    local x = 0
    surface.SetFont(font)

    local newlined = string.Split(text, "\n")

    for _, line in pairs(newlined) do
        local words = string.Split(line, " ")

        for _, word in pairs(words) do
            local tx = surface.GetTextSize(word)

            if x + tx >= maxw then
                table.insert(content, tline)
                tline = ""
                x = surface.GetTextSize(word)
            end

            tline = tline .. word .. " "

            x = x + surface.GetTextSize(word .. " ")
        end

        table.insert(content, tline)
        tline = ""
        x = 0
    end

    return content
end

-- given fov and distance solve apparent size
local function solvetriangle(angle, dist)
    local a = angle / 2
    local b = dist
    return b * math.tan(a) * 2
end

local hits_1 = {}
local hits_3 = {}

local function rollhit(radius)
    local anglerand = math.Rand(0, 360)
    local dist = math.Rand(0, radius)

    local hit_x = math.sin(anglerand) * dist
    local hit_y = math.cos(anglerand) * dist

    return {x = hit_x, y = hit_y}
end

local function rollallhits(self, range_3, range_1)

    hits_1 = {}
    hits_3 = {}

    local ang = self:GetBuff("AccuracyMOA") / 60

    local radius_1 = solvetriangle(ang, range_1 * ArcCW.HUToM)
    local radius_3 = solvetriangle(ang, range_3 * ArcCW.HUToM)

    local hitcount = math.Clamp(math.max(math.Round(self:GetCapacity() / 4), math.Round(self:GetBuff("Num") * 2)), 10, 20)

    for i = 1, hitcount do
        table.insert(hits_1, rollhit(radius_1))
    end

    for i = 1, hitcount do
        table.insert(hits_3, rollhit(radius_3))
    end
end

local function RangeText(range)
    local metres = tostring(math.Round(range)) .. "m"
    local hu = tostring(math.Round(range / ArcCW.HUToM / 100) * 100) .. "HU"

    return metres, hu
end

local shot_limit = 12
local max_shots = 8

local function shotstokill(mult, dmgmin, dmgmax, mran, sran)

    -- for i, return range where i * damage == 100
    -- return -1 if can't kill with i shots, math.huge if can kill at any range
    local result = {}

    for i = 1, shot_limit do
        local req_damage = math.ceil(100 / mult / i) -- target damage to kill in i shots
        if req_damage > dmgmin and req_damage > dmgmax then
            -- cannot reach target damage ever
            result[i] = -1
        elseif req_damage <= dmgmin and req_damage <= dmgmax then
            -- will always exceed target damage
            result[i] = math.huge
        elseif dmgmin < dmgmax then
            -- damage decays over range
            local frac = 1 - math.Clamp((req_damage - dmgmin) / (dmgmax - dmgmin), 0, 1)
            result[i] = mran + frac * (sran - mran)
        else
            -- damage increases over range
            local frac = math.Clamp((req_damage - dmgmax) / (dmgmin - dmgmax), 0, 1)
            result[i] = mran + frac * (sran - mran)
        end
    end
    return result
end

local function linepaintfunc(self2, w, h)
    surface.SetDrawColor(Color(self2.Color.r, self2.Color.g, self2.Color.b, self2.Color.a * ArcCW.Inv_Fade))
    surface.SetMaterial(pickx_full)

    local imsize = h * 0.45

    surface.DrawTexturedRect((h - imsize) / 2, ((h - imsize) / 2) + (ss * 2), imsize, imsize)

    local tp = h + (ss * 2)

    surface.SetFont("ArcCWC2_10_Glow")
    surface.SetTextColor(col_shadow)
    surface.SetTextPos(tp, 0)
    DrawTextRot(self2, self2.Text, tp, 0, tp, 0, self2:GetWide() - tp)

    surface.SetFont("ArcCWC2_10")
    surface.SetTextColor(Color(self2.Color.r, self2.Color.g, self2.Color.b, self2.Color.a * ArcCW.Inv_Fade))
    surface.SetTextPos(tp, 0)
    DrawTextRot(self2, self2.Text, tp, 0, tp, 0, self2:GetWide() - tp, true)
end

local function headpaintfunc(self2, w, h)
    local tp = 0

    surface.SetFont("ArcCWC2_8_Glow")
    surface.SetTextColor(col_shadow)
    surface.SetTextPos(tp, 0)
    DrawTextRot(self2, self2.Text, tp, 0, tp, 0, self2:GetWide() - tp)

    surface.SetFont("ArcCWC2_8")
    surface.SetTextColor(Color(self2.Color.r, self2.Color.g, self2.Color.b, self2.Color.a * ArcCW.Inv_Fade))
    surface.SetTextPos(tp, 0)
    DrawTextRot(self2, self2.Text, tp, 0, tp, 0, self2:GetWide() - tp, true)
end

function SWEP:ShowInventoryButton()
    if ArcCW.ConVars["attinv_free"]:GetBool() then return false end
    --if ArcCW.ConVars["attinv_lockmode"]:GetBool() then return false end
    if !ArcCW.ConVars["enable_dropping"]:GetBool() then return false end

    return true
end

function SWEP:GetSlotInstalled(i)
    local slot = self.Attachments[i]
    local installed = slot.Installed

    if !installed then
        for _, slot2 in pairs(slot.MergeSlots or {}) do
            if !isnumber(slot2) then continue end
            if self.Attachments[slot2] and self.Attachments[slot2].Installed then
                installed = self.Attachments[slot2].Installed
                break
            elseif !self.Attachments[slot2] then
                print("ERROR! No attachment " .. tostring(slot2))
            end
        end
    end

    return installed
end

-- 1: Customize
-- 2: Presets
-- 3: Inventory
ArcCW.Inv_SelectedMenu = 1

-- Selected inventory slot
SWEP.Inv_SelectedSlot = 0

SWEP.Inv_Scroll = {}

-- 1: Stats
-- 2: Trivia
-- 3: Ballistics
ArcCW.Inv_SelectedInfo = 1

ArcCW.Inv_Fade = 0.01

ArcCW.Inv_ShownAtt = nil
ArcCW.Inv_Hidden = false

function SWEP:CreateCustomize2HUD()
    local cvar_reloadincust = ArcCW.ConVars["reloadincust"]
    local cvar_cust_sounds = ArcCW.ConVars["cust_sounds"]
    local cvar_darkunowned = ArcCW.ConVars["attinv_darkunowned"]
    local cvar_lockmode = ArcCW.ConVars["attinv_lockmode"]
    local cvar_truenames = ArcCW.ConVars["truenames"]

    if cvar_darkunowned:GetBool() then
        col_unowned = Color(0, 0, 0, 150)
        col_unowned_txt = Color(150, 150, 150, 255)
    else
        col_unowned = col_block
        col_unowned_txt = col_block_txt
    end

    ArcCW.Inv_ShownAtt = nil

    local scrw, scrh = ScrW(), ScrH()
    if vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        -- Other resolutions seem to cause stretching issues
        scrw = 1366
        scrh = 768
    end

    ArcCW.InvHUD = vgui.Create("DFrame")

    local scrwmult = ArcCW.ConVars["hud_deadzone_x"]:GetFloat() * scrw
    local scrhmult = ArcCW.ConVars["hud_deadzone_y"]:GetFloat() * scrh

    ss = ArcCW.AugmentedScreenScale(1)
    rss = ss -- REAL SCREEN SCALE
    thicc = math.ceil(ss * 2)

    scrw, scrh = scrw - scrwmult, scrh - scrhmult

    local bar1_w = scrw / 4
    local bar2_w = scrw / 5
    local bar3_w = scrw / 2
    local airgap_x = ss * 24
    local airgap_y = ss * 24
    local smallgap = ss * 4

    local top_zone = ss * 24
    local bottom_zone = ss * 40

    local cornerrad = ss * 4

    local bigbuttonheight = ss * 36
    local smallbuttonheight = rss * 16

    local function PaintScrollBar(panel, w, h)
        local s = ss * 2
        draw.RoundedBox(ss * 1, (w - s) / 2, 0, s, h, col_fg)
    end

    local function clearrightpanel()
        if ArcCW.Inv_SelectedInfo == 1 then
            ArcCW.InvHUD_FormWeaponStats()
        elseif ArcCW.Inv_SelectedInfo == 2  then
            ArcCW.InvHUD_FormWeaponTrivia()
        elseif ArcCW.Inv_SelectedInfo == 3 then
            ArcCW.InvHUD_FormWeaponBallistics()
        end
    end

    ArcCW.Inv_Fade = 0.01

    ArcCW.InvHUD:SetPos(0, 0)
    ArcCW.InvHUD:SetSize(scrw, scrh)
    ArcCW.InvHUD:Center()
    ArcCW.InvHUD:SetDraggable(false)
    ArcCW.InvHUD:SetText("")
    ArcCW.InvHUD:SetTitle("")
    ArcCW.InvHUD:ShowCloseButton(false)
    ArcCW.InvHUD.Paint = function(self2)
        if !IsValid(self) then
            gui.EnableScreenClicker(false)
            ArcCW.InvHUD:Remove()
            return
        end

        if self:GetReloading() and !cvar_reloadincust:GetBool() then
            ArcCW.InvHUD:Remove()
            return
        end

        local st = 1 / 5
        if self:GetState() == ArcCW.STATE_CUSTOMIZE and !ArcCW.Inv_Hidden then
            ArcCW.Inv_Fade = math.Approach(ArcCW.Inv_Fade, 1, FrameTime() * 1 / st)
            --print("nooo")
        else
            ArcCW.Inv_Fade = math.Approach(ArcCW.Inv_Fade, 0, FrameTime() * 1 / st)
            --if (!game.SinglePlayer() and IsFirstTimePredicted() or true) and (self:GetState() != ArcCW.STATE_CUSTOMIZE or !ArcCW.Inv_Hidden) and ArcCW.Inv_Fade == 0 then ArcCW.InvHUD:Remove() end
            --print(CurTime())
                -- This'll completely screw up on multiplayer games and sometimes even singleplayer
        end
        col_fg = Color(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 255))
        col_mayomustard = Color(255, 255, 127, Lerp(ArcCW.Inv_Fade, 0, 255))
        col_fg_tr = Color(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 125))
        col_shadow = Color(0, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 255))
        col_button = Color(0, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 175))

        col_block = Color(50, 0, 0, 175 * ArcCW.Inv_Fade)
        col_block_txt = Color(175, 10, 10, Lerp(ArcCW.Inv_Fade, 0, 255))

        if cvar_darkunowned:GetBool() then
            col_unowned = Color(0, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 150))
            col_unowned_txt = Color(150, 150, 150, Lerp(ArcCW.Inv_Fade, 0, 255))
        else
            col_unowned = col_block
            col_unowned_txt = col_block_txt
        end

        --col_bad = Color(255, 50, 50, 255 * ArcCW.Inv_Fade)
        --col_good = Color(100, 255, 100, 255 * ArcCW.Inv_Fade)
        --col_info = Color(75, 75, 255, 255 * ArcCW.Inv_Fade)
    end
    ArcCW.InvHUD.ActiveWeapon = self
    ArcCW.InvHUD.OnRemove = function()
        local close = false
        if self:IsValid() and self:GetState() == ArcCW.STATE_CUSTOMIZE then
            close = true
        end

        if LocalPlayer():GetActiveWeapon() != ArcCW.InvHUD.ActiveWeapon then
            close = true
        end

        if close then
            net.Start("arccw_togglecustomize")
            net.WriteBool(false)
            net.SendToServer()

            if IsValid(self) and self.ToggleCustomizeHUD then
                self:ToggleCustomizeHUD(false)
            end
        end

        --print("INVHUD REMOVED", CurTime())
        ArcCW.Inv_Fade = 0.01
        gui.EnableScreenClicker(false)
    end

    if ArcCW.ConVars["attinv_onlyinspect"]:GetBool() then
        return
    end

    local menu1_w = bar1_w - airgap_x
    local menu1_h = scrh - (2 * airgap_y) - bottom_zone - top_zone + smallgap

    local closebutton = vgui.Create("DButton", ArcCW.InvHUD)
    closebutton:SetText("")
    closebutton:SetPos(scrw - smallbuttonheight - airgap_x, smallgap)
    closebutton:SetSize(rss * 24, bigbuttonheight)
    closebutton.Paint = function(self2, w, h)
        local col = col_fg

        if self2:IsHovered() then
            col = col_shadow
        end
        --draw.RoundedBox(ss * 1, 0, 0, w, h, Color(127, 127, 127, 127))
            -- Comment me! But it'll show when the HUD is alive.

        surface.SetTextColor(col_shadow)
        surface.SetTextPos(ss * 8, 0)
        surface.SetFont("ArcCWC2_24_Glow")
        surface.DrawText("x")

        surface.SetTextColor(col)
        surface.SetTextPos(ss * 8, 0)
        surface.SetFont("ArcCWC2_24")
        surface.DrawText("x")
    end
    closebutton.DoClick = function(self2, clr, btn)
        net.Start("arccw_togglecustomize")
        net.WriteBool(false)
        net.SendToServer()

        if IsValid(self) and self.ToggleCustomizeHUD then
            self:ToggleCustomizeHUD(false)
        end
    end
    closebutton.DoRightClick = function(self2, clr, btn)
        ArcCW.InvHUD:Remove()
    end

    local hidebutton = vgui.Create("DButton", ArcCW.InvHUD)
    hidebutton:SetText("")
    hidebutton:SetPos(scrw - smallbuttonheight * 2 - airgap_x, smallgap)
    hidebutton:SetSize(smallbuttonheight, bigbuttonheight)
    hidebutton.Paint = function(self2, w, h)
        local col = col_fg

        if self2:IsHovered() then
            col = Color(col_shadow.r, col_shadow.g, col_shadow.b, col_shadow.a * ArcCW.Inv_Fade)
        end
        --draw.RoundedBox(ss * 1, 0, 0, w, h, Color(127, 127, 127, 127))
            -- Comment me! But it'll show when the HUD is alive.

        surface.SetTextColor(col_shadow)
        surface.SetTextPos(ss * 8, ss * -4)
        surface.SetFont("ArcCWC2_24_Glow")
        surface.DrawText("_")

        surface.SetTextColor(col)
        surface.SetTextPos(ss * 8, ss * -4)
        surface.SetFont("ArcCWC2_24")
        surface.DrawText("_")
    end
    hidebutton.DoClick = function(self2, clr, btn)
        if IsValid(self) and self.ToggleCustomizeHUD then
            ArcCW.Inv_Hidden = !ArcCW.Inv_Hidden
            gui.EnableScreenClicker(false)
        end
    end

    -- Menu for attachment slots/presets
    ArcCW.InvHUD_Menu1 = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    ArcCW.InvHUD_Menu1:SetPos(airgap_x, airgap_y + top_zone + smallgap)
    ArcCW.InvHUD_Menu1:SetSize(menu1_w, menu1_h)

    local scroll_1 = ArcCW.InvHUD_Menu1:GetVBar()
    scroll_1.Paint = function() end

    scroll_1.btnUp.Paint = function(span, w, h)
    end
    scroll_1.btnDown.Paint = function(span, w, h)
    end
    scroll_1.btnGrip.Paint = PaintScrollBar

    local topframe = vgui.Create("DPanel", ArcCW.InvHUD)
    topframe:SetSize(menu1_w, ss * 16)
    topframe:SetPos(airgap_x, airgap_y + ss * 8)
    topframe.Paint = function() end

    local customizebutton = vgui.Create("DButton", topframe)
    customizebutton:SetSize(ss * 90, ss * 16)
    customizebutton:SetPos(0, 0)
    customizebutton:SetText("")
    customizebutton.Text = translate("ui.customize")
    customizebutton.Val = 1
    customizebutton.DoClick = function(self2, clr, btn)
        ArcCW.Inv_SelectedMenu = 1
        ArcCW.InvHUD_FormAttachments()

        surface.PlaySound("weapons/arccw/hover.wav")
    end
    customizebutton.Paint = function(self2, w, h)
        local col = col_button
        local col2 = col_fg

        if self2:IsHovered() or (ArcCW.Inv_SelectedMenu == self2.Val) then
            col = col_fg_tr
            col2 = col_shadow
        end

        draw.RoundedBox(cornerrad, 0, 0, w, h, col)

        surface.SetFont("ArcCWC2_8")
        local tw, th = surface.GetTextSize(self2.Text)

        surface.SetFont("ArcCWC2_8_Glow")
        surface.SetTextColor(col_shadow)
        surface.SetTextPos((w - tw) / 2, (h - th) / 2)
        surface.DrawText(self2.Text)

        surface.SetFont("ArcCWC2_8")
        surface.SetTextColor(col2)
        surface.SetTextPos((w - tw) / 2, (h - th) / 2)
        surface.DrawText(self2.Text)
    end

    local presetsbutton = vgui.Create("DButton", topframe)
    presetsbutton:SetSize(ss * 80, ss * 16)
    presetsbutton:SetPos(ss * 94, 0)
    presetsbutton:SetText("")
    presetsbutton.Text = translate("ui.presets")
    presetsbutton.Val = 2
    presetsbutton.DoClick = function(self2, clr, btn)
        ArcCW.Inv_SelectedMenu = 2
        ArcCW.InvHUD_FormPresets()

        surface.PlaySound("weapons/arccw/hover.wav")
    end
    presetsbutton.Paint = customizebutton.Paint

    if self:ShowInventoryButton() then
        customizebutton:SetSize(ss * 60, ss * 16)
        presetsbutton:SetSize(ss * 55, ss * 16)
        presetsbutton:SetPos(ss * 65, 0)

        local inventorybutton = vgui.Create("DButton", topframe)
        inventorybutton:SetSize(ss * 50, ss * 16)
        inventorybutton:SetPos(ss * 125, 0)
        inventorybutton:SetText("")
        inventorybutton.Text = translate("ui.inventory")
        inventorybutton.Val = 3
        inventorybutton.DoClick = function(self2, clr, btn)
            ArcCW.Inv_SelectedMenu = 3
            ArcCW.InvHUD_FormInventory()

            surface.PlaySound("weapons/arccw/hover.wav")
        end
        inventorybutton.Paint = customizebutton.Paint
    end

    local menu2_x, menu2_y = ArcCW.InvHUD_Menu1:GetPos()
    menu2_x = menu2_x + ArcCW.InvHUD_Menu1:GetWide() + smallgap
    local menu2_w = bar2_w
    local menu2_h = scrh - top_zone - airgap_y - airgap_y - (ss * 16)

    -- Menu for attachments
    ArcCW.InvHUD_Menu2 = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    ArcCW.InvHUD_Menu2:SetPos(menu2_x, menu2_y)
    ArcCW.InvHUD_Menu2:SetSize(menu2_w, menu2_h)

    -- ArcCW.InvHUD_Menu2.Paint = function(self2, w, h)
    --     draw.RoundedBox(2, 0, 0, w, h, col_fg)
    -- end

    local scroll_2 = ArcCW.InvHUD_Menu2:GetVBar()
    scroll_2.AlreadySet = false
    scroll_2.Paint = function(self2, w, h)
        if !self2.AlreadySet then
            self2:SetScroll(self.Inv_Scroll[self.Inv_SelectedSlot or 0] or 0)
            self2.AlreadySet = true
        end

        local scroll = self2:GetScroll()

        self.Inv_Scroll[self.Inv_SelectedSlot or 0] = scroll
    end

    scroll_2.btnUp.Paint = function(span, w, h)
    end
    scroll_2.btnDown.Paint = function(span, w, h)
    end
    scroll_2.btnGrip.Paint = PaintScrollBar

    function ArcCW.InvHUD_FormInventory()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu1:Clear()
        ArcCW.InvHUD_Menu2:Clear()
        self.Inv_SelectedSlot = nil
        clearrightpanel()

        local attinv = LocalPlayer().ArcCW_AttInv or {}

        local atts = table.GetKeys(attinv)

        table.sort(atts)

        local str = nil
        if #atts == 0 then
            str = translate("ui.noatts")
        elseif cvar_lockmode:GetBool() then
            str = translate("ui.lockinv")
        end

        if str then
            local msg = vgui.Create("DPanel", ArcCW.InvHUD_Menu1)
            msg:SetText("")
            msg:SetSize(menu2_w - (2 * ss), rss * 12)
            msg:Dock(TOP)
            msg.Paint = function(self2, w, h)
                local old = DisableClipping(true)
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_12_Glow")
                surface.DrawText(str)
                --DrawTextRot(self2, str, ss * 4, 0, ss * 4, ss * 2, w - (ss * 4))

                surface.SetTextColor(col_fg)
                surface.SetTextPos(ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_12")
                surface.DrawText(str)
                --DrawTextRot(self2, str, ss * 4, 0, ss * 4, ss * 2, w - (ss * 4))
                DisableClipping(old)
            end
        end

        for i, k in ipairs(atts) do
            if (ArcCW:PlayerGetAtts(self:GetOwner(), k) or 0) <= 0 then continue end
            local atttbl = ArcCW.AttachmentTable[k or ""]

            if atttbl.Free then continue end

            local button = vgui.Create("DButton", ArcCW.InvHUD_Menu1)
            button.att = k
            button:SetText("")
            button:SetSize(menu2_w - (2 * ss), smallbuttonheight)
            button:DockMargin(0, smallgap, 0, 0)
            button:Dock(TOP)
            button.DoClick = function(self2, clr, btn)
                if cvar_lockmode:GetBool() then return end

                surface.PlaySound("weapons/arccw/uninstall.wav")

                net.Start("arccw_asktodrop")
                    net.WriteUInt(ArcCW.AttachmentTable[self2.att].ID, 24)
                net.SendToServer()

                ArcCW:PlayerTakeAtt(self:GetOwner(), self2.att)
                if (self:GetOwner().ArcCW_AttInv[self2.att] or 0) == 0 then
                    self2:Remove()
                end
                clearrightpanel()
            end
            button.DoRightClick = function(self2, clr, btn)
                ArcCW.InvHUD_FormAttachmentStats(self2.att, self2.attslot)
            end
            button.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                --[[]
                if self2:IsHovered() then
                    ArcCW.InvHUD_FormAttachmentStats(self2.att, self2.attslot)
                end
                ]]

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local icon_h = h
                local buffer = 0

                if !cvar_lockmode:GetBool() then
                    local amt = ArcCW:PlayerGetAtts(self:GetOwner(), self2.att) or 0
                    amt = math.min(amt, 99)
                    local amttxt = tostring(amt)
                    surface.SetFont("ArcCWC2_8")
                    local amt_w = surface.GetTextSize(amttxt)

                    -- surface.SetTextColor(col_shadow)
                    -- surface.SetFont("ArcCWC2_8_Glow")
                    -- surface.SetTextPos(w - amt_w - (ss * 1), h - (rss * 8) - (ss * 1))
                    -- surface.DrawText(amttxt)

                    surface.SetTextColor(col2)
                    surface.SetFont("ArcCWC2_8")
                    surface.SetTextPos(w - amt_w - (ss * 4), h - (rss * 8) - (ss * 1))
                    surface.DrawText(amttxt)

                    buffer = amt_w + (ss * 6)
                end

                local txt = translate("name." .. self2.att .. ".short") or atttbl.AbbrevName
                if !txt then
                    txt = translate("name." .. self2.att) or atttbl.PrintName
                end

                surface.SetTextColor(atttbl.Ignore and col_mayomustard or col2)
                surface.SetTextPos(icon_h + ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_12")

                DrawTextRot(self2, txt, icon_h + (ss * 4), 0, icon_h + ss * 4, ss * 2, w - icon_h - (ss * 4) - buffer)

                local icon = atttbl.Icon
                if !icon or icon:IsError() then icon = bird end

                surface.SetDrawColor(atttbl.Ignore and mayoicons and col_mayomustard or col2)
                surface.SetMaterial(icon)
                surface.DrawTexturedRect(ss * 2, 0, icon_h, icon_h)
            end
        end
    end

    function ArcCW.InvHUD_FormPresets()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu1:Clear()
        ArcCW.InvHUD_Menu2:Clear()
        self.Inv_SelectedSlot = nil
        self.Preset_DeleteMode = false
        clearrightpanel()

        local framer = vgui.Create("DPanel", ArcCW.InvHUD_Menu1)
        framer:SetSize(menu1_w, smallbuttonheight * 1.2)
        framer:DockMargin(0, 0, 0, smallgap)
        framer:Dock(TOP)
        framer.Paint = function() end

        local button = vgui.Create("DButton", framer)
        button:SetText("")
        button:Dock(LEFT)
        button:SetWide(menu1_w * 0.5)
        button:DockMargin(0, 0, smallgap, 0)
        button.DoClick = function(self2, clr, btn)
            self:CreatePresetSave()
            surface.PlaySound("weapons/arccw/open.wav")
        end
        button.Paint = function(self2, w, h)
            local col = col_button
            local col2 = col_fg

            if self2:IsHovered() then
                col = col_fg_tr
                col2 = col_shadow
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            local preset_txt = translate("ui.createpreset") --"Create New Preset"

            surface.SetFont("ArcCWC2_14")
            surface.SetTextPos(ss * 4, ss * 0)
            surface.SetTextColor(col2)
            DrawTextRot(self2, preset_txt, 0, 0, ss * 4, ss * 0, w - ss * 4)
        end

        local remov = vgui.Create("DButton", framer)
        remov:SetText("")
        remov:Dock(FILL)
        remov.DoClick = function(self2, clr, btn)
            self.Preset_DeleteMode = !self.Preset_DeleteMode
            surface.PlaySound(self.Preset_DeleteMode and "weapons/arccw/open.wav" or "weapons/arccw/close.wav")
        end
        remov.Paint = function(self2, w, h)
            local col = col_button
            local col2 = col_fg

            if self.Preset_DeleteMode then
                if self2:IsHovered() then
                    col = Color(200, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 125))
                    col2 = col_shadow
                else
                    col = Color(100, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 175))
                end
            elseif self2:IsHovered() then
                col = col_fg_tr
                col2 = col_shadow
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            local preset_txt = translate("ui.deletepreset")

            surface.SetFont("ArcCWC2_14")
            surface.SetTextPos(ss * 4, ss * 0)
            surface.SetTextColor(col2)
            DrawTextRot(self2, preset_txt, 0, 0, ss * 4, ss * 0, w - ss * 4)
        end

        local presetpanel = vgui.Create("DScrollPanel", ArcCW.InvHUD_Menu1)
        presetpanel:SetSize(menu1_w, menu1_h - smallbuttonheight * 1.2 - smallgap)
        presetpanel:SetPos(0, smallbuttonheight * 1.2 + smallgap)

        local scroll_preset = presetpanel:GetVBar()
        scroll_preset.Paint = function() end
        scroll_preset.btnUp.Paint = function(span, w, h)
        end
        scroll_preset.btnDown.Paint = function(span, w, h)
        end
        scroll_preset.btnGrip.Paint = PaintScrollBar

        local preset = {}

        preset = self:GetPresets()

        for i, k in pairs(preset) do
            if string.StripExtension(k) == "autosave" then continue end
            local load_btn = vgui.Create("DButton", presetpanel)
            load_btn:SetText("")
            load_btn.PresetName = string.StripExtension(k)
            load_btn.PresetFile = k
            load_btn:SetSize(menu1_w, smallbuttonheight)
            load_btn:DockMargin(0, smallgap, 0, 0)
            load_btn:Dock(TOP)
            load_btn.DoClick = function(self2, clr, btn)
                if !self.Preset_DeleteMode then
                    self.LastPresetName = self2.PresetName
                    self:LoadPreset(self2.PresetName)
                else
                    file.Delete(ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. self2.PresetFile)
                    self2:Remove()
                    surface.PlaySound("weapons/arccw/uninstall.wav")
                end
            end
            --[[]
            load_btn.DoRightClick = function(self2)
                local filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. self2.PresetName .. ".txt"
                file.Delete(filename)
                self2:Remove()
            end
            ]]
            load_btn.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self.Preset_DeleteMode then
                    if self2:IsHovered() then
                        col = Color(200, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 125))
                        col2 = col_shadow
                    --else
                    --    col = Color(100, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 175))
                    end
                elseif self2:IsHovered() then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local preset_txt = self2.PresetName:upper()

                surface.SetFont("ArcCWC2_14")
                surface.SetTextPos(ss * 4, ss * 0)
                surface.SetTextColor(col2)
                DrawTextRot(self2, preset_txt, 0, 0, ss * 4, ss * 0, w - ss * 4)
            end
        end
    end

    function ArcCW.InvHUD_FormAttachmentSelect()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu2:Clear()

        local slot = self.Attachments[self.Inv_SelectedSlot or 0]

        if !slot then return end

        local atts = {}
        local slots = {self.Inv_SelectedSlot}
        local attCheck = {}

        table.Add(slots, slot.MergeSlots or {})

        for _, y in pairs(slots) do
            for _, bruh in pairs(ArcCW:GetAttsForSlot((self.Attachments[y] or {}).Slot, self)) do
                if attCheck[bruh] then continue end
                table.insert(atts, {
                    att = bruh,
                    slot = y
                })
                attCheck[bruh] = true
            end
        end

        atts[0] = {
            att = "",
            slot = self.Inv_SelectedSlot
        }

        table.sort(atts, function(a, b)
            a = a.att or ""
            b = b.att or ""
            local atttbl_a = ArcCW.AttachmentTable[a]
            local atttbl_b = ArcCW.AttachmentTable[b]

            local order_a = 0
            local order_b = 0

            order_a = atttbl_a.SortOrder or order_a
            order_b = atttbl_b.SortOrder or order_b

            if order_a == order_b then
                return (translate("name." .. a) or atttbl_a.PrintName or "") > (translate("name." .. b) or atttbl_b.PrintName or "")
            end

            return order_a > order_b
        end)

        local has = false
        for _, att in pairs(atts) do
            if !att then continue end
            if !istable(att) then continue end

            local show, _, _ = self:ValidateAttachment(att.att, nil, att.slot)
            -- if !ArcCW.AttachmentTable[att] then continue end

            if !show then continue end
            has = (att.att != "")

            local button = vgui.Create("DButton", ArcCW.InvHUD_Menu2)
            button.att = att.att
            button.attslot = att.slot
            button:SetText("")
            button:SetSize(menu2_w - (2 * ss), smallbuttonheight)
            button:DockMargin(0, smallgap, 0, 0)
            button:Dock(TOP)
            button.DoClick = function(self2, clr, btn)
                -- self.Inv_SelectedSlot = self2.attindex
                -- ArcCW.InvHUD_FormAttachmentSelect()
                -- self:DetachAllMergeSlots(self2.attslot, true)
                --if ArcCW.ConVars["enable_customization"]:GetInt() < 0 then return end
                if ArcCW:PlayerCanAttach(LocalPlayer(), self, self2.att, self2.attslot, false) then
                    if self2.att == "" then
                        self2:DoRightClick()
                    elseif self:Attach(self2.attslot, self2.att) then
                        ArcCW.Inv_ShownAtt = nil -- Force a regen on the panel so we can see toggle/slider options
                        ArcCW.InvHUD_FormAttachmentStats(self2.att, self2.attslot, true)
                    elseif self:CountAttachments() >= self:GetPickX() then
                        ArcCW.Inv_LastPickXBlock = CurTime()
                    end
                else
                    if CLIENT then surface.PlaySound("items/medshotno1.wav") end
                end
            end
            button.DoRightClick = function(self2)
                if ArcCW:PlayerCanAttach(LocalPlayer(), self, self2.att, self2.attslot, true) then
                    self:DetachAllMergeSlots(self2.attslot)
                    ArcCW.InvHUD_FormAttachmentSelect()
                else
                    if CLIENT then surface.PlaySound("items/medshotno1.wav") end
                end
            end
            button.Paint = function(self2, w, h)
                if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
                local col = col_button
                local col2 = col_fg

                local atttbl = ArcCW.AttachmentTable[self2.att or ""] or {}

                local _, _, blocked, showqty = self:ValidateAttachment(att.att, nil, att.slot)

                if blocked and atttbl.HideIfBlocked then self2:Remove() return end

                local installed = self:GetSlotInstalled(self2.attslot)

                if self2:IsHovered() or self2.att == installed or (self2.att == "" and !installed) then
                    col = col_fg_tr
                    col2 = col_shadow

                --     self2:SetSize(menu2_w - (2 * ss), smallbuttonheight * 2)
                -- else
                --     self2:SetSize(menu2_w - (2 * ss), smallbuttonheight)
                end

                if self2:IsHovered() then
                    ArcCW.InvHUD_FormAttachmentStats(self2.att, self2.attslot, installed == self2.att)
                end

                local owned = ArcCW:PlayerGetAtts(self:GetOwner(), att.att) > 0

                if blocked then
                    col = col_block
                    col2 = col_block_txt
                elseif !owned and installed != self2.att then
                    col = col_unowned
                    col2 = col_unowned_txt
                end

                if !owned and installed != self2.att then
                    showqty = false
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local icon_h = h

                if !self2.att or self2.att == "" then
                    local attslot = self.Attachments[self2.attslot]
                    local att_txt = self:GetBuff_Hook("Hook_GetDefaultAttName", self2.attslot, true) or attslot.DefaultAttName
                    att_txt = att_txt and try_translate(att_txt) or translate("attslot.noatt")
                    atttbl = {
                        PrintName = att_txt,
                        Icon = self:GetBuff_Hook("Hook_GetDefaultAttIcon", self2.attslot, true) or attslot.DefaultAttIcon or defaultatticon
                    }
                end

                local buffer = 0

                if showqty then
                    local amt = ArcCW:PlayerGetAtts(self:GetOwner(), self2.att) or 0

                    amt = math.min(amt, 99)

                    local amttxt = tostring(amt)

                    surface.SetFont("ArcCWC2_8")
                    local amt_w = surface.GetTextSize(amttxt)

                    -- surface.SetTextColor(col_shadow)
                    -- surface.SetFont("ArcCWC2_8_Glow")
                    -- surface.SetTextPos(w - amt_w - (ss * 1), h - (rss * 8) - (ss * 1))
                    -- surface.DrawText(amttxt)

                    surface.SetTextColor(col2)
                    surface.SetFont("ArcCWC2_8")
                    surface.SetTextPos(w - amt_w - (ss * 4), h - (rss * 8) - (ss * 1))
                    surface.DrawText(amttxt)

                    buffer = amt_w + (ss * 6)
                end

                local txt = translate("name." .. self2.att .. ".short") or atttbl.AbbrevName
                if !txt then
                    txt = translate("name." .. self2.att) or atttbl.PrintName
                end

                surface.SetTextColor(atttbl.Ignore and col_mayomustard or col2)
                surface.SetTextPos(icon_h + ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_12")

                DrawTextRot(self2, txt, icon_h + (ss * 4), 0, icon_h + ss * 4, ss * 2, w - icon_h - (ss * 4) - buffer)

                local icon = atttbl.Icon
                if !icon or icon:IsError() then icon = bird end

                surface.SetDrawColor(atttbl.Ignore and mayoicons and col_mayomustard or col2)
                surface.SetMaterial(icon)
                surface.DrawTexturedRect(ss * 2, 0, icon_h, icon_h)
            end
        end

        if table.Count(atts) > 1 and !has then
            local msg = vgui.Create("DPanel", ArcCW.InvHUD_Menu2)
            msg:SetText("")
            msg:SetSize(menu2_w - (2 * ss), smallbuttonheight)
            msg:Dock(TOP)
            msg.Paint = function(self2, w, h)
                local txt = translate("ui.noatts_slot")

                surface.SetTextColor(col_shadow)
                surface.SetTextPos(ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_10_Glow")
                DrawTextRot(self2, txt, ss * 4, 0, ss * 4, ss * 2, w - (ss * 4))

                surface.SetTextColor(col_fg)
                surface.SetTextPos(ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_10")
                DrawTextRot(self2, txt, ss * 4, 0, ss * 4, ss * 2, w - (ss * 4))
            end
        end
    end

    -- add attachments

    function ArcCW.InvHUD_FormAttachments()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu1:Clear()
        for i, slot in pairs(self.Attachments) do
            if !istable(slot) then continue end
            if !slot.PrintName then continue end
            if i == "BaseClass" then continue end
            if slot.Hidden or slot.Blacklisted then continue end
            if slot.Integral then continue end

            local button = vgui.Create("DButton", ArcCW.InvHUD_Menu1)
            button.attindex = i
            button:SetText("")
            button:SetSize(menu1_w, bigbuttonheight)
            button:DockMargin(0, 0, 0, smallgap)
            button:Dock(TOP)
            button.DoClick = function(self2, clr, btn)
                if self.Inv_SelectedSlot == self2.attindex then
                    self.Inv_SelectedSlot = nil
                    ArcCW.InvHUD_Menu2:Clear()
                    clearrightpanel()
                    if cvar_cust_sounds:GetBool() then surface.PlaySound("weapons/arccw/close.wav") end
                else
                    local aslot = self.Attachments[i]

                    if self:CheckFlags(aslot.ExcludeFlags, aslot.RequireFlags) then
                        self.Inv_SelectedSlot = self2.attindex
                        ArcCW.InvHUD_FormAttachmentSelect()
                        ArcCW.InvHUD_FormAttachmentStats(self2.attindex, self2.attindex, true)
                        if cvar_cust_sounds:GetBool() then surface.PlaySound("weapons/arccw/open.wav") end
                    end
                end
            end
            button.DoRightClick = function(self2)
                if ArcCW:PlayerCanAttach(LocalPlayer(), self, nil, self2.attindex, true) then
                    self:DetachAllMergeSlots(self2.attindex)
                    ArcCW.InvHUD_FormAttachmentSelect()
                else
                    if CLIENT then surface.PlaySound("items/medshotno1.wav") end
                end
            end
            button.Paint = function(self2, w, h)
                if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() or self.Inv_SelectedSlot == self2.attindex then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                local aslot = self.Attachments[i]

                if !self:CheckFlags(aslot.ExcludeFlags, aslot.RequireFlags) then
                    col = col_block
                    col2 = col_block_txt
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local installed = self:GetSlotInstalled(i)

                local att_icon = self:GetBuff_Hook("Hook_GetDefaultAttIcon", i, true) or slot.DefaultAttIcon or defaultatticon
                local att_txt = self:GetBuff_Hook("Hook_GetDefaultAttName", i, true) or slot.DefaultAttName
                att_txt = att_txt and try_translate(att_txt) or translate("attslot.noatt")
                local atttbl = ArcCW.AttachmentTable[installed or ""]

                if atttbl then
                    att_txt = translate("name." .. installed .. ".short") or atttbl.AbbrevName
                    if !att_txt then
                        att_txt = translate("name." .. installed) or atttbl.PrintName
                    end
                    att_icon = atttbl and atttbl.Icon
                    if !att_icon or att_icon:IsError() then att_icon = bird end
                end

                local slot_txt = try_translate(slot.PrintName)

                surface.SetDrawColor((atttbl and atttbl.Ignore and mayoicons and col_mayomustard) or col2)
                local icon_h = h
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - icon_h - ss * 2, 0, icon_h, icon_h)

                surface.SetTextColor((atttbl and atttbl.Ignore and col_mayomustard) or col2)
                surface.SetFont("ArcCWC2_10")
                surface.SetTextPos(ss * 6, ss * 4)
                DrawTextRot(self2, slot_txt, 0, 0, ss * 6, ss * 4, w - icon_h - ss * 4)
                -- surface.DrawText(slot.PrintName)

                surface.SetFont("ArcCWC2_14")
                surface.SetTextPos(ss * 6, ss * 14)
                DrawTextRot(self2, att_txt, 0, 0, ss * 6, ss * 14, w - icon_h - ss * 4)
            end
        end

        local pickxpanel = vgui.Create("DPanel", ArcCW.InvHUD)
        pickxpanel:SetSize(menu1_w - ArcCW.InvHUD_Menu1:GetVBar():GetWide(), bottom_zone - smallgap * 4)
        pickxpanel:SetPos(airgap_x, scrh - bottom_zone - smallgap * 4)
        pickxpanel.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
            local pickx_amount = self:GetPickX()
            local pickedatts = self:CountAttachments()

            local col_fg_pick = col_fg
            local d = 0.5
            local diff = CurTime() - (ArcCW.Inv_LastPickXBlock or 0 + d)
            if diff > 0 then
                col_fg_pick = Color(255, 255 * diff / d, 255 * diff / d, 255*ArcCW.Inv_Fade)
            end

            if pickx_amount == 0 then return end
            if pickx_amount > 8 then
                surface.SetFont("ArcCWC2_16")
                local txt = string.format(translate("ui.pickx"), pickedatts, pickx_amount)
                local s = surface.GetTextSize(txt)
                surface.SetTextColor(col_fg_pick)
                surface.SetTextPos(w / 2 - s / 2, ss * 4)
                surface.DrawText(txt)
                return
            end

            local x = 0
            local y = ss * 4

            local s = ss * 20

            x = (w - (s * pickx_amount)) / 2

            local icons = {}
            for k, v in pairs(self.Attachments) do
                if v.Installed and !v.FreeSlot and !ArcCW.AttachmentTable[v.Installed].IgnorePickX then
                    local icon = (ArcCW.AttachmentTable[v.Installed] or {}).Icon or defaultatticon
                    if !icon or icon:IsError() then icon = bird end
                    table.insert(icons, icon)
                end
            end

            for i = 1, pickx_amount do
                surface.SetDrawColor(col_fg_pick)
                if i > pickedatts then
                    surface.SetMaterial(pickx_empty)
                else
                    surface.SetMaterial(pickx_full)
                end
                surface.DrawTexturedRect(x, y, s, s)
                if i <= pickedatts and icons[i] then
                    surface.SetDrawColor(col_shadow)
                    surface.SetMaterial(icons[i])
                    surface.DrawTexturedRect(x + ss * 3, y + ss * 3, ss * 14, ss * 14)
                end

                x = x + s
            end
        end
    end

    local menu3_h = scrh - airgap_y - bottom_zone
    local menu3_w = bar3_w

    -- weapon details
    ArcCW.InvHUD_Menu3 = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    ArcCW.InvHUD_Menu3:SetPos(scrw - menu3_w, airgap_y + smallgap)
    ArcCW.InvHUD_Menu3:SetSize(menu3_w, menu3_h)

    function ArcCW.InvHUD_FormAttachmentStats(att, slot, equipped)
        if ArcCW.Inv_ShownAtt == att then
            return
        end
        if isnumber(att) then
            local installed = self:GetSlotInstalled(att)

            att = installed
        end
        if !att then
            clearrightpanel()
            return
        end
        local atttbl = ArcCW.AttachmentTable[att]

        if !atttbl then return end

        ArcCW.InvHUD_Menu3:Clear()

        ArcCW.Inv_ShownAtt = att

        local s = ss * 250

        local bgim = vgui.Create("DLabel", ArcCW.InvHUD_Menu3)
        bgim:SetText("")
        bgim:SetPos(menu3_w - s - (ss * 25), 0)
        bgim:SetSize(s, s)
        bgim.Paint = function(self2, w, h)
            local icon = atttbl.Icon
            if !icon or icon:IsError() then icon = bird end

            surface.SetDrawColor(255, 255, 255, 25 * ArcCW.Inv_Fade)
            surface.SetMaterial(icon)
            surface.DrawTexturedRect(0, 0, w, h)
        end

        local attname_panel = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        attname_panel:SetSize(menu3_w, rss * 24)
        attname_panel:SetPos(0, rss * 16)
        attname_panel.Paint = function(self2, w, h)
            local name = translate("name." .. atttbl.ShortName) or atttbl.PrintName

            surface.SetFont("ArcCWC2_24")
            local tw = surface.GetTextSize(name)

            surface.SetTextColor(col_shadow)
            surface.SetFont("ArcCWC2_24_Glow")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_24")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x, true)
        end

        local scroll = vgui.Create("DScrollPanel", ArcCW.InvHUD_Menu3)
        --scroll:SetSize(menu3_w - airgap_x, ss * 128)
        --scroll:SetPos(0, rss * 32 + ss * 16)

        local scroll_bar = scroll:GetVBar()
        scroll_bar.Paint = function() end

        scroll_bar.btnUp.Paint = function(span, w, h)
        end
        scroll_bar.btnDown.Paint = function(span, w, h)
        end
        scroll_bar.btnGrip.Paint = PaintScrollBar

        local bottombuffer = 0

        local m_w = menu3_w * 0.75
        local leftbuffer = 0

        if equipped and self.Attachments[slot].SlideAmount and !atttbl.MountPositionOverride then
            local slider = vgui.Create("DButton", ArcCW.InvHUD_Menu3)

            slider:SetSize(m_w * 2 / 3, rss * 10)
            slider:SetPos(0, rss * 16 + rss * 24 + ss * 128 - (rss * 10))
            slider:SetText("")
            slider.Dragging = false
            slider.NextDrag = 0
            slider.OnRemove = function(self2)
                self:SendDetail_SlidePos(slot)
                self:SavePreset("autosave")
            end
            slider.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() or self2.Dragging then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local linebuffer = ss * 8
                local line_w = w - (linebuffer * 2)

                if self2.Dragging or (self2:IsHovered() and input.IsMouseDown(MOUSE_LEFT)) then
                    local x, _ = self2:LocalCursorPos()

                    local mouse_line_x = x - linebuffer

                    local delta = mouse_line_x / line_w

                    delta = math.Clamp(delta, 0, 1)

                    if self.Attachments[slot].SlidePos != delta and self2.NextDrag <= CurTime() then
                        -- local amt = math.abs(self.Attachments[slot].SlidePos - delta)
                        EmitSound("weapons/arccw/dragatt.wav", EyePos(), -2, CHAN_ITEM, 1,75, 0, math.Clamp(90+(delta * 20), 90, 110))
                        self2.NextDrag = CurTime() + 0.05
                    end

                    self.Attachments[slot].SlidePos = delta

                    self2.Dragging = true

                    if !input.IsMouseDown(MOUSE_LEFT) then
                        self2.Dragging = false

                        self:SetupActiveSights()
                        self:SendDetail_SlidePos(slot)
                        self:SavePreset("autosave")
                    end
                end

                local slide = (self.Attachments[slot] or {}).SlidePos or 0.5

                surface.SetDrawColor(col2)
                surface.DrawLine(linebuffer, h / 2, w - linebuffer, h / 2)

                local rect_x = slide * line_w + linebuffer
                local rect_w = ss * 6
                surface.DrawRect(rect_x - (rect_w / 2), (h - rect_w) / 2, rect_w, rect_w)
            end

            leftbuffer = m_w * 2 / 3
            bottombuffer = bottombuffer + rss * 10
        end

        if equipped and atttbl.ToggleStats then
            local toggle = vgui.Create("DButton", ArcCW.InvHUD_Menu3)

            toggle:SetSize(m_w * 1 / 3 - rss * 2, rss * 10)
            toggle:SetPos(leftbuffer + (ss * 4), rss * 16 + rss * 24 + ss * 128 - (rss * 10))
            toggle:SetText("")
            toggle.OnMousePressed = function(self2, kc)
                if kc == MOUSE_LEFT then
                    self:ToggleSlot(slot)
                elseif kc == MOUSE_RIGHT then
                    self:ToggleSlot(slot, nil, nil, true)
                end
            end
            toggle.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() or ArcCW.Inv_SelectedInfo == self2.Val then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local txt = (translate("ui.toggle"))
                local catttbl = ArcCW.AttachmentTable[att]
                if catttbl and catttbl.ToggleStats[self.Attachments[slot].ToggleNum]
                        and catttbl.ToggleStats[self.Attachments[slot].ToggleNum].PrintName then
                    txt = try_translate(catttbl.ToggleStats[self.Attachments[slot].ToggleNum].PrintName)
                end

                surface.SetFont("ArcCWC2_8")
                local tw, th = surface.GetTextSize(txt)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col2)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)
            end

            local togglelock = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
            togglelock:SetSize(rss * 10, rss * 10)
            togglelock:SetPos(leftbuffer + (ss * 4) + m_w * 1 / 3, rss * 16 + rss * 24 + ss * 128 - (rss * 10))
            togglelock:SetText("")
            togglelock.OnMousePressed = function(self2, kc)
                self.Attachments[slot].ToggleLock = !self.Attachments[slot].ToggleLock
                if self.Attachments[slot].ToggleLock then
                    self:EmitSound("weapons/arccw/dragatt.wav", 0, 150)
                else
                    self:EmitSound("weapons/arccw/dragatt.wav", 0, 80)
                end
            end
            togglelock.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() or ArcCW.Inv_SelectedInfo == self2.Val then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)
                surface.SetDrawColor(col2.r, col2.g, col2.b)
                surface.SetMaterial(self.Attachments[slot].ToggleLock and iconlock or iconunlock)
                surface.DrawTexturedRect(4, 4, w - 8, h - 8)
            end

            bottombuffer = bottombuffer + rss * 10
        end

        scroll:SetPos(0, rss * 32 + ss * 16 + bottombuffer)
        scroll:SetSize(menu3_w - airgap_x, ss * 128 - bottombuffer)

        local multiline = {}
        local desc = translate("desc." .. atttbl.ShortName) or translate(atttbl.Description) or atttbl.Description

        multiline = multlinetext(desc, scroll:GetWide() - (ss * 2), "ArcCW_10")

        local desc_title = vgui.Create("DPanel", scroll)
        desc_title:SetSize(scroll:GetWide(), rss * 8)
        desc_title:SetPos(0, 0)
        desc_title.Paint = function(self2, w, h)
            surface.SetFont("ArcCWC2_8")
            local txt = translate("trivia.description")
            local tw_1 = surface.GetTextSize(txt)

            surface.SetFont("ArcCWC2_8_Glow")
            surface.SetTextColor(col_shadow)
            surface.SetTextPos(w - tw_1, 0)
            surface.DrawText(txt)

            surface.SetFont("ArcCWC2_8")
            surface.SetTextColor(col_fg)
            surface.SetTextPos(w - tw_1, 0)
            surface.DrawText(txt)
        end

        for i, text in pairs(multiline) do
            local desc_line = vgui.Create("DPanel", scroll)
            desc_line:SetSize(scroll:GetWide(), rss * 10)
            desc_line:SetPos(0, (rss * 10 * i) - (rss * 2))
            desc_line.Paint = function(self2, w, h)
                surface.SetFont("ArcCWC2_10")
                local tw = surface.GetTextSize(text)

                surface.SetFont("ArcCWC2_10_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw, 0)
                surface.DrawText(text)

                surface.SetFont("ArcCWC2_10")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw, 0)
                surface.DrawText(text)
            end
        end

        local scroll_pros = vgui.Create("DScrollPanel", ArcCW.InvHUD_Menu3)
        scroll_pros:SetSize(menu3_w, ss * 172)
        scroll_pros:SetPos(0, menu3_h - (ss * 172))
        scroll_pros.Paint = function() end

        local scroll_bar_pros = scroll_pros:GetVBar()
        scroll_bar_pros.Paint = function() end

        scroll_bar_pros.btnUp.Paint = function(span, w, h)
        end
        scroll_bar_pros.btnDown.Paint = function(span, w, h)
        end
        scroll_bar_pros.btnGrip.Paint = PaintScrollBar

        -- Don't have stats disappear due to toggle state
        local pros, cons, infos = ArcCW:GetProsCons(self, atttbl) -- self.Attachments[slot].ToggleNum

        pros = pros or {}
        cons = cons or {}
        infos = infos or {}

        local p_w = menu3_w / 2

        local pan_pros = vgui.Create("DPanel", scroll_pros)
        pan_pros:SetPos(0, 0)
        pan_pros.Paint = function() end

        local pan_cons = vgui.Create("DPanel", scroll_pros)
        pan_cons:SetPos(#pros > 0 and (menu3_w * 1 / 2) or 0, 0)
        pan_cons.Paint = function() end

        local pan_infos

        if #infos > 0 then
            pan_infos = vgui.Create("DPanel", scroll_pros)
            pan_infos:SetWide(menu3_w)
            pan_infos.Paint = function() end
        end
        p_w = (pan_pros and pan_cons) and (menu3_w / 2) or p_w

        if #pros > 0 then
            local pan_head = vgui.Create("DPanel", pan_pros)
            pan_head:SetTall(rss * 8)
            pan_head:Dock(TOP)
            pan_head.Paint = headpaintfunc
            pan_head.Text = translate("ui.positives")
            pan_head.Color = col_good
        end

        if #cons > 0 then
            local pan_head = vgui.Create("DPanel", pan_cons)
            pan_head:SetTall(rss * 8)
            pan_head:Dock(TOP)
            pan_head.Paint = headpaintfunc
            pan_head.Text = translate("ui.negatives")
            pan_head.Color = col_bad
        end

        for i, line in pairs(pros) do
            if !line or line == "" then continue end
            local pan_line = vgui.Create("DPanel", pan_pros)
            pan_line:SetSize(p_w, rss * 10)
            pan_line:SetPos(0, rss * 10 * i)
            pan_line.Paint = linepaintfunc
            pan_line.Text = line
            pan_line.Color = col_good
        end

        pan_pros:SizeToChildren(true, true)

        for i, line in pairs(cons) do
            if !line or line == "" then continue end
            local pan_line = vgui.Create("DPanel", pan_cons)
            pan_line:SetSize(p_w, rss * 10)
            pan_line:SetPos(0, rss * 10 * i)
            pan_line.Paint = linepaintfunc
            pan_line.Text = line
            pan_line.Color = col_bad
        end

        pan_cons:SizeToChildren(true, true)

        if #infos > 0 then
            local pan_head = vgui.Create("DPanel", pan_infos)
            pan_head:SetTall(rss * 8)
            pan_head:Dock(TOP)
            pan_head.Paint = headpaintfunc
            pan_head.Text = translate("ui.information")
            pan_head.Color = col_info

            for i, line in pairs(infos) do
                if !line or line == "" then continue end
                local pan_line = vgui.Create("DPanel", pan_infos)
                pan_line:SetSize(menu3_w, rss * 10)
                pan_line:SetPos(0, rss * 10 * i)
                pan_line.Paint = linepaintfunc
                pan_line.Text = line
                pan_line.Color = col_info
            end

            -- We can't do this on initialize because SizeToChildren isn't called yet
            local h = math.max(pan_pros and pan_pros:GetTall() or 0, pan_cons and pan_cons:GetTall() or 0)
            h = (h > 0) and (h + rss * 10) or 0 -- if only info, don't add padding
            pan_infos:SetPos(0, h)
            pan_infos:SizeToChildren(true, true)
        end
    end

    function ArcCW.InvHUD_FormStatsTriviaBar()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        local statsbutton = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        statsbutton:SetSize(ss * 48, ss * 16)
        statsbutton:SetPos(menu3_w - (ss * 48 * 2) - airgap_x - (ss * 4), rss * 48 + ss * 12)
        statsbutton:SetText("")
        statsbutton.Text = translate("ui.stats")
        statsbutton.Val = 1
        statsbutton.DoClick = function(self2, clr, btn)
            ArcCW.InvHUD_FormWeaponStats()
            ArcCW.Inv_SelectedInfo = 1
        end
        statsbutton.Paint = function(self2, w, h)
            local col = col_button
            local col2 = col_fg

            if self2:IsHovered() or ArcCW.Inv_SelectedInfo == self2.Val then
                col = col_fg_tr
                col2 = col_shadow
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            surface.SetFont("ArcCWC2_8")
            local tw, th = surface.GetTextSize(self2.Text)

            surface.SetFont("ArcCWC2_8_Glow")
            surface.SetTextColor(col_shadow)
            surface.SetTextPos((w - tw) / 2, (h - th) / 2)
            surface.DrawText(self2.Text)

            surface.SetFont("ArcCWC2_8")
            surface.SetTextColor(col2)
            surface.SetTextPos((w - tw) / 2, (h - th) / 2)
            surface.DrawText(self2.Text)
        end

        local triviabutton = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        triviabutton:SetSize(ss * 48, ss * 16)
        triviabutton:SetPos(menu3_w - ss * 48 - airgap_x, rss * 48 + ss * 12)
        triviabutton:SetText("")
        triviabutton.Text = translate("ui.trivia")
        triviabutton.Val = 2
        triviabutton.DoClick = function(self2, clr, btn)
            ArcCW.InvHUD_FormWeaponTrivia()
            ArcCW.Inv_SelectedInfo = 2
        end
        triviabutton.Paint = statsbutton.Paint

        local ballisticsbutton = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        ballisticsbutton:SetSize(ss * 48, ss * 16)
        ballisticsbutton:SetPos(menu3_w - (ss * 48 * 3) - airgap_x - (ss * 4 * 2), rss * 48 + ss * 12)
        ballisticsbutton:SetText("")
        ballisticsbutton.Text = translate("ui.ballistics")
        ballisticsbutton.Val = 3
        ballisticsbutton.DoClick = function(self2, clr, btn)
            ArcCW.InvHUD_FormWeaponBallistics()
            ArcCW.Inv_SelectedInfo = 3
        end
        ballisticsbutton.Paint = statsbutton.Paint
    end

    function ArcCW.InvHUD_FormWeaponName()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_FormStatsTriviaBar()
        local weapon_title = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        weapon_title:SetSize(menu3_w, rss * 32)
        weapon_title:SetPos(0, 0)
        weapon_title.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
            local name = translate("name." .. self:GetClass() .. (cvar_truenames:GetBool() and ".true" or "")) or translate(self.PrintName) or self.PrintName

            surface.SetFont("ArcCWC2_32")
            local tw = surface.GetTextSize(name)

            surface.SetTextColor(col_shadow)
            surface.SetFont("ArcCWC2_32_Glow")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_32")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x, true)
        end

        local weapon_cat = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        weapon_cat:SetSize(menu3_w, rss * 16)
        weapon_cat:SetPos(0, rss * 32)
        weapon_cat.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
            local class = try_translate(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class) or "missing"
            local cal = try_translate(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre)
            local name = class

            if !self.PrimaryMelee and !self.Throwing and cal then
                name = name .. ", " .. cal
            end

            surface.SetFont("ArcCWC2_16")
            local tw = surface.GetTextSize(name)

            surface.SetTextColor(col_shadow)
            surface.SetFont("ArcCWC2_16_Glow")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_16")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x, true)
        end
    end

    function ArcCW.InvHUD_FormWeaponTrivia()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu3:Clear()
        ArcCW.InvHUD_FormWeaponName()

        local scroll = vgui.Create("DScrollPanel", ArcCW.InvHUD_Menu3)
        scroll:SetSize(menu3_w - airgap_x, ss * 110)
        scroll:SetPos(0, rss * 48 + ss * 32)

        local scroll_bar = scroll:GetVBar()
        scroll_bar.Paint = function() end

        scroll_bar.btnUp.Paint = function(span, w, h)
        end
        scroll_bar.btnDown.Paint = function(span, w, h)
        end
        scroll_bar.btnGrip.Paint = PaintScrollBar

        local multiline = {}
        local desc = translate(self:GetBuff_Override("Override_Trivia_Desc")) or translate("desc." .. self:GetClass()) or self.Trivia_Desc

        multiline = multlinetext(desc, scroll:GetWide() - (ss * 2), "ArcCW_10")

        local desc_title = vgui.Create("DPanel", scroll)
        desc_title:SetSize(scroll:GetWide(), rss * 8)
        desc_title:Dock(TOP)
        desc_title.Paint = function(self2, w, h)
            surface.SetFont("ArcCWC2_8")
            local txt = translate("trivia.description")
            local tw_1 = surface.GetTextSize(txt)

            surface.SetFont("ArcCWC2_8_Glow")
            surface.SetTextColor(col_shadow)
            surface.SetTextPos(w - tw_1, 0)
            surface.DrawText(txt)

            surface.SetFont("ArcCWC2_8")
            surface.SetTextColor(col_fg)
            surface.SetTextPos(w - tw_1, 0)
            surface.DrawText(txt)
        end

        for i, text in pairs(multiline) do
            local desc_line = vgui.Create("DPanel", scroll)
            desc_line:SetSize(scroll:GetWide(), rss * 10)
            desc_line:Dock(TOP)
            desc_line.Paint = function(self2, w, h)
                surface.SetFont("ArcCWC2_10")
                local tw = surface.GetTextSize(text)

                surface.SetFont("ArcCWC2_10_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw, 0)
                surface.DrawText(text)

                surface.SetFont("ArcCWC2_10")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw, 0)
                surface.DrawText(text)
            end
        end

        local info = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        info:SetSize(menu3_w - airgap_x, menu3_h - ss * 110 - rss * 48 - ss * 32)
        info:SetPos(0, rss * 48 + ss * 32 + ss * 110)
        info.Paint = function(self2, w, h)
            local infos = self.Infos_Trivia or {}

            local year = try_translate(self:GetBuff_Override("Override_Trivia_Year") or self.Trivia_Year)

            if year then
                if isnumber(year) and year < 0 then
                    table.insert(infos, {
                        title = translate("trivia.year"),
                        value = tostring(-year),
                        unit = translate("unit.bce"),
                    })
                else
                    table.insert(infos, {
                        title = translate("trivia.year"),
                        value = tostring(year),
                    })
                end
            end

            local mech = try_translate(self:GetBuff_Override("Override_Trivia_Mechanism") or self.Trivia_Mechanism)

            if mech then
                table.insert(infos, {
                    title = translate("trivia.mechanism"),
                    value = translate(mech) or mech,
                })
            end

            local country = try_translate(self:GetBuff_Override("Override_Trivia_Country") or self.Trivia_Country)

            if country then
                table.insert(infos, {
                    title = translate("trivia.country"),
                    value = translate(country) or country,
                })
            end

            local manufacturer = try_translate(self:GetBuff_Override("Override_Trivia_Manufacturer") or self.Trivia_Manufacturer)

            if manufacturer then
                table.insert(infos, {
                    title = translate("trivia.manufacturer"),
                    value = translate(manufacturer) or manufacturer,
                })
            end

            local calibre = try_translate(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre)

            if calibre then
                table.insert(infos, {
                    title = translate("trivia.calibre"),
                    value = translate(calibre) or calibre,
                })
            end

            for i, triv in pairs(infos) do
                triv.unit = triv.unit or ""
                local i_2 = i - 1
                surface.SetFont("ArcCWC2_8")
                local tw_1 = surface.GetTextSize(triv.title)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)

                surface.SetFont("ArcCWC2_8")
                local tw_2 = surface.GetTextSize(triv.unit)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 12))
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 12))
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_16")
                local tw_3 = surface.GetTextSize(tostring(triv.value))

                surface.SetFont("ArcCWC2_16_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_2 - tw_3, (i_2 * (rss * 24)) + (rss * 6))
                -- surface.DrawText(triv.value)
                DrawTextRot(self2, triv.value, 0, i_2 * (rss * 24), math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6), w)

                -- (span, txt, x, y, tx, ty, maxw, only)

                surface.SetFont("ArcCWC2_16")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_2 - tw_3, (i_2 * (rss * 24)) + (rss * 6))
                -- surface.DrawText(triv.value)
                DrawTextRot(self2, triv.value, 0, i_2 * (rss * 24), math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6), w, true)
            end
        end
    end

    function ArcCW.InvHUD_FormWeaponStats()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu3:Clear()
        ArcCW.InvHUD_FormWeaponName()

        self.Infos_Stats = nil
        self.Infos_Breakpoints = nil
        local stats_breakpoint = false

        local info = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        info:SetSize(menu3_w - airgap_x, menu3_h - ss * 110 - rss * 48 - ss * 32)
        info:SetPos(0, rss * 48 + ss * 32 + ss * 110)
        info.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
            --local infos = self.Infos_Stats or {}

            if !self.Infos_Stats then

                self.Infos_Stats = {}

                -- rpm
                local rpm = math.Round(60 / self:GetFiringDelay())

                if self:GetIsManualAction() then

                    local fireanim = self:GetBuff_Hook("Hook_SelectFireAnimation") or self:SelectAnimation("fire")
                    local firedelay = self.Animations[fireanim].MinProgress or 0
                    rpm = math.Round(60 / ((firedelay + self:GetAnimKeyTime("cycle", true)) * self:GetBuff_Mult("Mult_CycleTime")))

                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.firerate"),
                        value = "~" .. tostring(rpm),
                        unit = translate("unit.rpm"),
                    })
                elseif !self.PrimaryBash and !self.Throwing then
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.firerate"),
                        value = tostring(rpm),
                        unit = translate("unit.rpm"),
                    })
                    local mode = self:GetCurrentFiremode()
                    if mode.Mode < 0 then
                        table.insert(self.Infos_Stats, {
                            title = translate("trivia.firerate_burst"),
                            value = tostring( math.Round( 60 / (self:GetFiringDelay() + ((mode.PostBurstDelay or 0) / -mode.Mode)) ) ),
                            unit = translate("unit.rpm"),
                        })
                    end
                end

                -- precision
                local precision = math.Round(self:GetBuff("AccuracyMOA"), 1)

                if !self.PrimaryBash and !self.Throwing then
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.precision"),
                        value = precision,
                        unit = translate("unit.moa"),
                    })
                end

                -- ammo type
                local ammo = string.lower(self:GetBuff_Override("Override_Ammo", self.Primary.Ammo))
                if (ammo or "") != "" and ammo != "none" then
                    local ammotype = ArcCW.TranslateAmmo(ammo) --language.GetPhrase(self.Primary.Ammo .. "_ammo")
                    if ammotype then
                        table.insert(self.Infos_Stats, {
                            title = translate("trivia.ammo"),
                            value = ammotype,
                            --unit = " (" .. ammo .. ")",
                        })
                    end
                end

                -- penetration
                local shootent = self:GetBuff("ShootEntity", true)

                if !self.PrimaryBash and !shootent then
                    local pen = math.Round( self:GetBuff("Penetration") )
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.penetration"),
                        value = pen,
                        unit = translate("unit.mm"),
                    })
                end

                -- noise
                local noise = self:GetBuff("ShootVol")

                if !self.PrimaryBash and !self.Throwing then
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.noise"),
                        value = math.Round(noise),
                        unit = translate("unit.db"),
                    })
                end

                if self.Throwing then
                    local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime
                    if ft and ft > 0 then
                        table.insert(self.Infos_Stats, {
                            title = translate("trivia.fusetime"),
                            value = tostring(math.Round(ft, 1)),
                            unit = "s"
                        })
                    end
                end

                if self.PrimaryBash then
                    local meleedelay = self.MeleeTime * self:GetBuff_Mult("Mult_MeleeTime")
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.attackspersecond"),
                        value = tostring(math.Round(1 / meleedelay, 1)),
                        unit = translate("unit.aps")
                    })

                    local meleerange = self:GetBuff("MeleeRange")
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.range"),
                        value = tostring(math.Round(meleerange * ArcCW.HUToM)),
                        unit = "m"
                    })

                    local dmg = self.MeleeDamage * self:GetBuff_Mult("Mult_MeleeDamage")
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.damage"),
                        value = dmg,
                    })

                    local dmgtype = self:GetBuff_Override("Override_MeleeDamageType") or self.MeleeDamageType

                    if ArcCW.MeleeDamageTypes[dmgtype or ""] then
                        table.insert(self.Infos_Stats, {
                            title = translate("trivia.meleedamagetype"),
                            value = translate(ArcCW.MeleeDamageTypes[dmgtype]),
                        })
                    end
                end

            end

            for i, triv in pairs(self.Infos_Stats) do
                triv.unit = triv.unit or ""
                local i_2 = i - 1
                surface.SetFont("ArcCWC2_8")
                local tw_1 = surface.GetTextSize(triv.title)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)


                surface.SetFont("ArcCWC2_16")
                local tw_3a = select(2, surface.GetTextSize(tostring(triv.value)))

                surface.SetFont("ArcCWC2_8")
                local tw_2 = surface.GetTextSize(triv.unit)
                local tw_2a = select(2, surface.GetTextSize(triv.unit))

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 4.4) + tw_2a)
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 4.4) + tw_2a)
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_16")
                local tw_3 = surface.GetTextSize(tostring(triv.value))

                surface.SetFont("ArcCWC2_16_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6))
                surface.DrawText(triv.value)

                surface.SetFont("ArcCWC2_16")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6))
                surface.DrawText(triv.value)
            end
        end

        local stk_min, stk_max, stk_count = 1, shot_limit, shot_limit
        local stk_num = self:GetBuff("Num")
        local dmgt = tostring("DMG")

        local rangegraph = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        rangegraph:SetSize(ss * 200, ss * 110)
        rangegraph:SetPos(menu3_w - ss * 200 - airgap_x, rss * 48 + ss * 32)
        rangegraph:SetText("")
        rangegraph.DoClick = function(self2)
            stats_breakpoint = !stats_breakpoint
        end
        rangegraph.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end

            local col = col_button
            if self2:IsHovered() then
                col = col_button_hv
            end
            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            if self.PrimaryBash or
                self.ShootEntity or
                self:GetBuff_Override("Override_ShootEntity") or
                self.NoRangeGraph
            then

                local txt = translate("ui.nodata")

                surface.SetTextColor(col_fg)
                surface.SetFont("ArcCWC2_24")
                local tw, th = surface.GetTextSize(txt)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)

                return
            elseif self:GetBuff("Num") <= 0 then

                local txt = translate("ui.nonum")

                surface.SetTextColor(col_fg)
                surface.SetFont("ArcCWC2_12")
                local tw, th = surface.GetTextSize(txt)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)

                return
            end

            local dmgmax = self:GetDamage(0)
            local dmgmin = self:GetDamage(math.huge)

            local mran, sran = self:GetMinMaxRange()

            if stats_breakpoint then

                if !self.Infos_Breakpoints then
                    self.Infos_Breakpoints = {}

                    local our = self:GetBuff_Override("Override_BodyDamageMults", self.BodyDamageMults)
                    local gam = ArcCW.LimbCompensation[engine.ActiveGamemode()] or ArcCW.LimbCompensation[1]
                    if our and ArcCW.ConVars["bodydamagemult_cancel"]:GetBool() then
                        gam = {}
                    elseif !our then
                        our = {}
                    end

                    -- Head
                    table.insert(self.Infos_Breakpoints, {"ui.hitgroup.head", shotstokill((our[HITGROUP_HEAD] or 1) / (gam[HITGROUP_HEAD] or 1), dmgmin, dmgmax, mran, sran)})

                    -- Torso
                    -- separates into Chest and Stomach if they have different values
                    local m_chest = (our[HITGROUP_CHEST] or 1) / (gam[HITGROUP_CHEST] or 1)
                    local m_stomach = (our[HITGROUP_STOMACH] or 1) / (gam[HITGROUP_STOMACH] or 1)
                    if m_chest == m_stomach then
                        table.insert(self.Infos_Breakpoints, {"ui.hitgroup.torso", shotstokill(m_chest, dmgmin, dmgmax, mran, sran)})
                    else
                        table.insert(self.Infos_Breakpoints, {"ui.hitgroup.chest", shotstokill(m_chest, dmgmin, dmgmax, mran, sran)})
                        table.insert(self.Infos_Breakpoints, {"ui.hitgroup.stomach", shotstokill(m_stomach, dmgmin, dmgmax, mran, sran)})
                    end

                    -- Arms and Legs
                    -- if two limbs have different multipliers (why???), use the smaller one
                    local m_arms = math.min((our[HITGROUP_LEFTARM] or 1) / (gam[HITGROUP_LEFTARM] or 1), (our[HITGROUP_RIGHTARM] or 1) / (gam[HITGROUP_RIGHTARM] or 1))
                    table.insert(self.Infos_Breakpoints, {"ui.hitgroup.arms", shotstokill(m_arms, dmgmin, dmgmax, mran, sran)})
                    local m_legs = math.min((our[HITGROUP_LEFTLEG] or 1) / (gam[HITGROUP_LEFTLEG] or 1), (our[HITGROUP_RIGHTLEG] or 1) / (gam[HITGROUP_RIGHTLEG] or 1))
                    table.insert(self.Infos_Breakpoints, {"ui.hitgroup.legs", shotstokill(m_legs, dmgmin, dmgmax, mran, sran)})

                    stk_num = self:GetBuff("Num")
                    local max = max_shots * (stk_num > 1 and 0.5 or 1)

                    -- Trim table values that are all -1 or math.huge on either end
                    stk_min, stk_max = 1, 1 + max_shots
                    local stk_min_n, stk_min_y = true, true
                    for i = 1, shot_limit do
                        if stk_min_y or stk_min_n then
                            stk_min = i
                        else
                            break
                        end
                        for j = 1, #self.Infos_Breakpoints do
                            if stk_min_n and self.Infos_Breakpoints[j][2][i] != -1 then
                                stk_min_n = false
                            elseif stk_min_y and self.Infos_Breakpoints[j][2][i] != math.huge then
                                stk_min_y = false
                            end
                            if !stk_min_y and !stk_min_n then
                                stk_min = math.Clamp(shot_limit, 1, math.max(1, i - 1))
                                break
                            end
                        end
                    end

                    local stk_max_n, stk_max_y = true, true
                    for i = shot_limit, 1, -1 do
                        if stk_max_y or stk_max_n then
                            stk_max = i
                        else
                            break
                        end
                        for j = 1, #self.Infos_Breakpoints do
                            if stk_max_n and self.Infos_Breakpoints[j][2][i] != -1 then
                                stk_max_n = false
                            elseif stk_max_y and self.Infos_Breakpoints[j][2][i] != math.huge then
                                stk_max_y = false
                            end
                            if !stk_max_y and !stk_max_n then
                                stk_max = math.Clamp(i + 1, 1, shot_limit)
                                break
                            end
                        end
                    end

                    stk_count = stk_max - stk_min + 1
                    if stk_count > max then
                        stk_max = stk_min + max - 1
                        stk_count = max
                    end


                    if GetConVar("developer"):GetInt() > 0 then
                        print(dmgmax .. "-" .. dmgmin .. "DMG; range " .. mran .. "/" .. sran)
                        print("table range: " .. stk_min .. " - " .. stk_max .. " (" .. stk_count .. ")")
                        PrintTable(self.Infos_Breakpoints)
                    end
                end

                local header_w = ss * 48
                local column_w = (w - header_w) / stk_count
                local header_h = ss * 16
                local column_h = (h - header_h) / #self.Infos_Breakpoints

                -- header texts
                surface.SetTextColor(col_fg)
                surface.SetFont("ArcCWC2_8")

                local hg_t = translate("ui.hitgroup")
                local _, hg_h = surface.GetTextSize(hg_t)
                surface.SetTextPos(ss, header_h - (thicc / 2) - hg_h)
                surface.DrawText(hg_t)

                local stk_t = translate("ui.shotstokill")
                local stk_w, _ = surface.GetTextSize(stk_t)
                surface.SetTextPos(header_w - (thicc / 2) - stk_w, 0)
                surface.DrawText(stk_t)

                -- vertical dividers
                local cnt_t = stk_num > 1 and ("×" .. stk_num) or ""
                surface.SetFont("ArcCWC2_8")
                local cnt_w, cnt_h = surface.GetTextSize(cnt_t)

                surface.SetDrawColor(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 255))
                for i = 1, stk_count do
                    surface.DrawLine(header_w + i * column_w, 0, header_w + i * column_w, header_h)
                    surface.SetFont("ArcCWC2_16")
                    local num_t = tostring(i + stk_min - 1)
                    local num_w, num_h = surface.GetTextSize(num_t)
                    surface.SetTextPos(header_w + (i - 0.5) * column_w - num_w / 2 - cnt_w / 2, header_h / 2 - num_h / 2)
                    surface.DrawText(num_t)

                    if stk_num > 1 then
                        surface.SetFont("ArcCWC2_8")
                        surface.SetTextPos(header_w + (i - 0.5) * column_w + num_w / 2 - cnt_w / 2, header_h / 2 - num_h / 2 + cnt_h / 2)
                        surface.DrawText(cnt_t)
                    end
                end

                -- table info
                surface.SetFont("ArcCWC2_8")
                for i, tbl in ipairs(self.Infos_Breakpoints) do
                    local row_t = translate(tbl[1])
                    local row_w, row_h = surface.GetTextSize(row_t)
                    surface.SetTextPos(header_w / 2 - row_w / 2, header_h + column_h * (i - 0.5) - row_h / 2)
                    surface.DrawText(row_t)

                    for j = 1, stk_count do
                        local val = tbl[2][j + stk_min - 1]
                        local mat, siz
                        if val == -1 then
                            --ran_t = "⨯"
                            siz = ss * 8
                            mat = mat_hit
                            surface.SetDrawColor(col_bad.r, col_bad.g, col_bad.b, Lerp(ArcCW.Inv_Fade, 0, 255))
                        elseif val == math.huge then
                            --ran_t = "⚫"
                            siz = ss * 16
                            mat = mat_hit_dot
                            surface.SetDrawColor(col_good.r, col_good.g, col_good.b, Lerp(ArcCW.Inv_Fade, 0, 255))
                        else
                            local ran_t = math.floor(val) .. "m"
                            local ran_w, ran_h = surface.GetTextSize(ran_t)
                            surface.SetTextPos(header_w + (j - 0.5) * column_w - ran_w / 2, header_h + column_h * (i - 0.5) - ran_h / 2)
                            surface.DrawText(ran_t)
                        end

                        if mat then
                            surface.SetMaterial(mat)
                            surface.DrawTexturedRect(header_w + (j - 0.5) * column_w - siz / 2, header_h + column_h * (i - 0.5) - siz / 2, siz, siz)
                        end
                    end
                end


                for i = 1, thicc do
                    local meth = ((thicc - i) / thicc)
                    surface.SetDrawColor(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 127 * meth))

                    local of
                    if i == 1 then
                        surface.SetDrawColor(col_fg)
                        of = 0
                    elseif (i % 2 == 0) then
                        -- even
                        of = -1 * i / 2
                    else
                        -- odd
                        of = 1 * i / 2
                    end

                    -- first vertical
                    surface.DrawLine(header_w + of, 0, header_w + of, h)

                    -- first horizontal
                    surface.DrawLine(0, header_h + of, w, header_h + of)

                    -- diagonal header
                    --surface.DrawLine(0, of, header_w, header_h + of)

                    -- horizontal dividers
                    for j = 1, #self.Infos_Breakpoints - 1 do
                        surface.DrawLine(0, header_h + column_h * j + of, w, header_h + column_h * j + of)
                    end
                end

                return
            end

            local scale = math.ceil((math.max(dmgmax, dmgmin) + 10) / 25) * 25
            local hscale = math.ceil(math.max(mran, sran) / 150) * 150

            scale = math.max(scale, 75)
            hscale = math.max(hscale, 150)

            local wmin = mran / hscale * w
            local wmax = math.min(sran / hscale * w, w - ss * 32)
            if sran == hscale then wmax = w end

            -- segment 1: minimum range
            local x_1 = 0
            local y_1 = h - (dmgmax / scale * h)
            y_1 = math.Clamp(y_1, ss * 16, h - (ss * 16))
            -- segment 2: slope
            local x_2 = 0
            local y_2 = y_1
            -- segment 3: maximum range
            local x_3 = wmax
            local y_3 = h - (dmgmin / scale * h)
            y_3 = math.Clamp(y_3, ss * 16, h - (ss * 16))

            local x_4 = w
            local y_4 = y_3

            if sran == mran then
                x_2 = w / 2
                x_3 = w / 2
            elseif mran > 0 then
                x_2 = wmin -- w * 1 / 3
            end

            local col_vline = LerpColor(0.5, col_fg, Color(0, 0, 0, 0))

            surface.SetDrawColor(col_vline)

            -- line for min range
            if dmgmax != dmgmin and mran > 0 then
                surface.DrawLine(x_2, 0, x_2, h)
            end

            -- line for max range
            if dmgmax != dmgmin then
                surface.DrawLine(x_3, 0, x_3, h)
            end

            -- damage number text
            for i = 1, thicc do
                local meth = ((thicc - i) / thicc)
                surface.SetDrawColor(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 127 * meth))

                local of
                if i == 1 then
                    surface.SetDrawColor(col_fg)
                    of = 0
                elseif (i % 2 == 0) then
                    -- even
                    of = -1 * i / 2
                else
                    -- odd
                    of = 1 * i / 2
                end

                if mran > 0 then
                    -- draw seg 1
                    surface.DrawLine(x_1, y_1 + of, x_2, y_2 + of)
                end
                -- draw seg 2
                surface.DrawLine(x_2, y_2 + of, x_3, y_3 + of)
                -- drag seg 3
                surface.DrawLine(x_3, y_3 + of, x_4, y_4 + of)
            end

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")

            local drawndmg = false
            if dmgmax != dmgmin then

                if mran == 0 or wmin > ss * 24 then
                    local m_1, hu_1 = RangeText(0)

                    surface.SetTextPos(ss * 2, h - rss * 16)
                    surface.DrawText(m_1)
                    surface.SetTextPos(ss * 2, h - rss * 10)
                    surface.DrawText(hu_1)
                end

                if sran != hscale and w - wmax > ss * 40 then
                    local m_1x, hu_1x = RangeText(hscale)
                    local w_m, _ = surface.GetTextSize(m_1x)
                    local w_hu, _ = surface.GetTextSize(hu_1x)

                    surface.SetTextPos(w - w_m - ss * 2, h - rss * 16)
                    surface.DrawText(m_1x)
                    surface.SetTextPos(w - w_hu - ss * 2, h - rss * 10)
                    surface.DrawText(hu_1x)
                end

                if mran > 0 then
                    -- min damage
                    local dmg = tostring(math.Round(dmgmax))
                    local tw = surface.GetTextSize(dmg)
                    if wmin < tw then
                        surface.SetTextPos(x_2 + ss * 1, ss * 1)
                    else
                        surface.SetTextPos(x_2 - (tw / 2), ss * 1)
                    end
                    surface.DrawText(dmg)

                    local m_2, hu_2 = RangeText(mran)

                    surface.SetTextPos(x_2, h - rss * 16)
                    surface.DrawText(m_2)
                    surface.SetTextPos(x_2, h - rss * 10)
                    surface.DrawText(hu_2)

                    local twt = surface.GetTextSize(dmgt)

                    if wmin < tw then
                        surface.SetTextPos(x_2 + ss * 1, ss * 8)
                    else
                        surface.SetTextPos(x_2 - (twt / 2), ss * 8)
                    end
                    surface.DrawText(dmgt)

                    drawndmg = true
                end

                if sran == hscale then
                    -- draw max damage at edge
                    local dmg = tostring(math.Round(dmgmin))
                    local tw = surface.GetTextSize(dmg)
                    surface.SetTextPos(w - ss * 2 - tw, ss * 1)
                    surface.DrawText(dmg)

                    local m_3, hu_3 = RangeText(sran)
                    local w_m, _ = surface.GetTextSize(m_3)
                    local w_hu, _ = surface.GetTextSize(hu_3)

                    surface.SetTextPos(w - ss * 2 - w_m, h - rss * 16)
                    surface.DrawText(m_3)
                    surface.SetTextPos(w - ss * 2 - w_hu, h - rss * 10)
                    surface.DrawText(hu_3)

                    local twt = surface.GetTextSize(dmgt)
                    surface.SetTextPos(w - ss * 2 - twt, ss * 8)
                    surface.DrawText(dmgt)

                elseif sran != mran then
                    -- draw max damage centered
                    local dmg = tostring(math.Round(dmgmin))
                    local tw = surface.GetTextSize(dmg)
                    surface.SetTextPos(x_3 - (tw / 2), ss * 1)
                    surface.DrawText(dmg)

                    local m_3, hu_3 = RangeText(sran)

                    surface.SetTextPos(x_3, h - rss * 16)
                    surface.DrawText(m_3)
                    surface.SetTextPos(x_3, h - rss * 10)
                    surface.DrawText(hu_3)

                    local twt = surface.GetTextSize(dmgt)
                    surface.SetTextPos(x_3 - (twt / 2), ss * 8)
                    surface.DrawText(dmgt)
                end


                if sran != mran and self2:IsHovered() then
                    local mouse_x, _ = self2:ScreenToLocal(input.GetCursorPos())
                    local mouse_frac = math.Clamp((mouse_x - x_2) / (x_3 - x_2), 0, 1)

                    if mouse_frac > 0 and mouse_frac < 1 then
                        local mouse_range = mran + mouse_frac * (sran - mran)
                        local mouse_dmg = math.Round(self:GetDamage(mouse_range))
                        local y_slope = Lerp(mouse_frac, y_2, y_3)

                        surface.SetDrawColor(col_vline)
                        surface.DrawLine(mouse_x, 0, mouse_x, h)

                        local mouse_text1 = tostring(mouse_dmg)
                        local mouse_text_w, _ = surface.GetTextSize(mouse_text1)
                        local nudge = -mouse_text_w * 0.5
                        local side_margin = ss * 12
                        local a = 255
                        if mouse_x - x_2 <= side_margin then
                            local f = (1 - (mouse_x - x_2) / side_margin)
                            a = Lerp(f, 255, 0)
                        elseif x_3 - mouse_x <= side_margin then
                            local f = (1 - (x_3 - mouse_x) / side_margin)
                            a = Lerp(f, 255, 25)
                        end
                        surface.SetTextColor(255, 255, 255, a)
                        surface.SetTextPos(mouse_x + nudge, y_slope - ss * 12)
                        surface.DrawText(mouse_text1)

                        local m_mouse, hu_mouse = RangeText(mouse_range)
                        local w_m, _ = surface.GetTextSize(m_mouse)
                        local w_hu, _ = surface.GetTextSize(hu_mouse)
                        surface.SetTextPos(mouse_x - w_m * 0.5, y_slope + rss * 5)
                        surface.DrawText(m_mouse)
                        surface.SetTextPos(mouse_x - w_hu * 0.5, y_slope + rss * 11)
                        surface.DrawText(hu_mouse)

                    end
                end
            end

            if !drawndmg then
                surface.SetTextColor(col_fg)

                local dmg = tostring(math.Round(dmgmax))
                surface.SetTextPos(ss * 2, ss * 1)
                surface.DrawText(dmg)

                surface.SetTextPos(ss * 2, ss * 8)
                surface.DrawText(dmgt)

            end
        end
    end

    function ArcCW.InvHUD_FormWeaponBallistics()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu3:Clear()
        ArcCW.InvHUD_FormWeaponName()

        self.Infos_Ballistics = nil

        local info = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        info:SetSize(menu3_w - airgap_x, menu3_h - (ss * 110) - (ss * 70) - rss * 48 - ss * 32)
        info:SetPos(0, rss * 48 + ss * 32 + (ss * 110) + (ss * 70))
        info.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end

            if !self.Infos_Ballistics then

                self.Infos_Ballistics = {}

                table.insert(self.Infos_Ballistics, {
                    title = translate("trivia.muzzlevel"),
                    value = math.Round(self:GetMuzzleVelocity() * ArcCW.HUToM),
                    unit = translate("unit.mps"),
                })

                table.insert(self.Infos_Ballistics, {
                    title = translate("trivia.recoil"),
                    value = math.Round(self.Recoil * ArcCW.RecoilUnit * self:GetBuff_Mult("Mult_Recoil"), 1),
                    unit = translate("unit.lbfps"),
                })

                table.insert(self.Infos_Ballistics, {
                    title = translate("trivia.recoilside"),
                    value = math.Round(self.RecoilSide * ArcCW.RecoilUnit * self:GetBuff_Mult("Mult_RecoilSide"), 1),
                    unit = translate("unit.lbfps"),
                })

                -- arccw_approved_recoil_score
                local aars = 0
                local disclaimers = ""

                aars = aars + (self.Recoil + self:GetBuff_Add("Add_Recoil")) * self:GetBuff_Mult("Mult_Recoil")
                aars = aars + (self.RecoilSide + self:GetBuff_Add("Add_RecoilSide")) * self:GetBuff_Mult("Mult_RecoilSide") * 0.5

                local arpm = (60 / self:GetFiringDelay())

                if self:GetIsManualAction() then
                    local fireanim = self:GetBuff_Hook("Hook_SelectFireAnimation") or self:SelectAnimation("fire")
                    local firedelay = self.Animations[fireanim].MinProgress or 0

                    arpm = math.Round(60 / ((firedelay + self:GetAnimKeyTime("cycle", true)) * self:GetBuff_Mult("Mult_CycleTime")))
                elseif self:GetCurrentFiremode().Mode == 1 then
                    arpm = math.min(400, 60 / self:GetFiringDelay())
                end
                aars = aars * arpm

                --[[
                if self:GetCurrentFiremode().Mode == 1 or self:GetIsManualAction() then
                    disclaimers = disclaimers .. " " .. arpm .. translate("unit.rpm")
                end
                ]]

                table.insert(self.Infos_Ballistics, {
                    title = translate("trivia.recoilscore"),
                    value = math.Round(aars),
                    unit = " points" .. disclaimers,
                })

            end

            for i, triv in pairs(self.Infos_Ballistics) do
                triv.unit = triv.unit or ""
                local i_2 = i - 1
                surface.SetFont("ArcCWC2_8")
                local tw_1 = surface.GetTextSize(triv.title)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)


                surface.SetFont("ArcCWC2_16")
                local tw_3a = select(2, surface.GetTextSize(tostring(triv.value)))

                surface.SetFont("ArcCWC2_8")
                local tw_2 = surface.GetTextSize(triv.unit)
                local tw_2a = select(2, surface.GetTextSize(triv.unit))

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 4.4) + tw_2a)
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 4.4) + tw_2a)
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_16")
                local tw_3 = surface.GetTextSize(tostring(triv.value))

                surface.SetFont("ArcCWC2_16_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6))
                surface.DrawText(triv.value)

                surface.SetFont("ArcCWC2_16")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6))
                surface.DrawText(triv.value)
            end
        end

        local range_3 = math.max(math.Round(self:GetBuff("Range") / 25) * 25, 50) --self.Range * self:GetBuff_Mult("Mult_Range")
        local range_1 = math.max(math.Round(range_3 / 3 / 25) * 25, 15) --(self.RangeMin or 0) * self:GetBuff_Mult("Mult_RangeMin")

        if range_1 == 0 then
            range_1 = range_3 * 0.5
        end

        rollallhits(self, range_3, range_1)

        local ballisticchart = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        ballisticchart:SetSize(ss * 200, ss * 110)
        ballisticchart:SetPos(menu3_w - ss * 200 - airgap_x, rss * 48 + ss * 32)
        ballisticchart:SetText("")
        ballisticchart.DoClick = function(self2)
            rollallhits(self, range_3, range_1)
        end
        ballisticchart.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end

            local col = col_button
            if self2:IsHovered() then
                col = col_button_hv
            end

            if self.PrimaryBash then
                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local txt = translate("ui.nodata")

                surface.SetTextColor(col_fg)
                surface.SetFont("ArcCWC2_24")
                local tw, th = surface.GetTextSize(txt)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)
                return
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            local s = w / 2
            local s2 = ss * 10

            local range_1_txt = tostring(range_1) .. "m / " .. tostring(math.Round(range_1 / ArcCW.HUToM / 100) * 100) .. "HU"
            local range_3_txt = tostring(range_3) .. "m / " .. tostring(math.Round(range_3 / ArcCW.HUToM / 100) * 100) .. "HU"

            local col_bullseye = Color(200, 200, 200, Lerp(ArcCW.Inv_Fade, 0, 100))

            surface.SetMaterial(bullseye)
            surface.SetDrawColor(col_bullseye)
            surface.DrawTexturedRect(0, 0, s, s)

            local r_1_x, r_1_y = self2:LocalToScreen(0, 0)

            render.SetScissorRect(r_1_x, r_1_y, r_1_x + s, r_1_y + s, true)

            for _, hit in ipairs(hits_1) do
                if self:GetBuff("Num") > 1 then
                    surface.SetMaterial(mat_hit_dot)
                else
                    surface.SetMaterial(mat_hit)
                end
                surface.SetDrawColor(col_fg)
                surface.DrawTexturedRect((s / 2) + (hit.x * s) - (s2 / 2), (s / 2) + (hit.y * s) - (s2 / 2), s2, s2)
            end

            render.SetScissorRect(r_1_x, r_1_y, r_1_x + s, r_1_y + s, false)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_12")
            local range_1_txtw = surface.GetTextSize(range_1_txt)
            surface.SetTextPos((s - range_1_txtw) / 2, h - (ss * 12) - (ss * 1))
            surface.DrawText(range_1_txt)

            surface.SetMaterial(bullseye)
            surface.SetDrawColor(col_bullseye)
            surface.DrawTexturedRect(s, 0, s, s)

            render.SetScissorRect(r_1_x + s, r_1_y, r_1_x + (s * 2), r_1_y + s, true)

            for _, hit in ipairs(hits_3) do
                if self:GetBuff("Num") > 1 then
                    surface.SetMaterial(mat_hit_dot)
                else
                    surface.SetMaterial(mat_hit)
                end
                surface.SetDrawColor(col_fg)
                surface.DrawTexturedRect(s + (s / 2) + (hit.x * s) - (s2 / 2), (s / 2) + (hit.y * s) - (s2 / 2), s2, s2)
            end

            render.SetScissorRect(r_1_x, r_1_y, r_1_x + s, r_1_y + s, false)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_12")
            local range_3_txtw = surface.GetTextSize(range_3_txt)
            surface.SetTextPos(s + (s - range_3_txtw) / 2, h - (ss * 12) - (ss * 1))
            surface.DrawText(range_3_txt)
        end

        local penchart = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        penchart:SetSize(ss * 200, ss * 60)
        penchart:SetPos(menu3_w - ss * 200 - airgap_x, rss * 48 + ss * 32 + (ss * 115))
        penchart:SetText("")
        penchart.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end

            local col = col_button

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            local pen = self:GetBuff("Penetration")

            local pm_wood = ArcCW.PenTable[MAT_WOOD]
            local pm_metal = ArcCW.PenTable[MAT_METAL]
            local pm_concrete = ArcCW.PenTable[MAT_CONCRETE]

            local line_s = ss * 1
            local line_h = h - (rss * 8 * 2) - (ss * 2)

            -- wood

            local pen_wood = math.Round(pen / pm_wood, 1)
            local wood_txt = "WOOD"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local wood_txtw = surface.GetTextSize(wood_txt)
            surface.SetTextPos((w * 1 / 6) - (wood_txtw / 2), h - (rss * 8))
            surface.DrawText(wood_txt)

            local wood_txt2 = tostring(pen_wood) .. "HU"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local wood_txt2w = surface.GetTextSize(wood_txt)
            surface.SetTextPos((w * 1 / 6) - (wood_txt2w / 2), h - (rss * 8 * 2))
            surface.DrawText(wood_txt2)

            local wood_width = (math.ceil(pen_wood / 5) * 5)
            wood_width = math.max(wood_width, 5)
            wood_width = math.min(wood_width, 20)

            local wood_s = wood_width * ss

            surface.SetDrawColor(col_fg_tr)
            surface.DrawRect((w * 1 / 6) - (wood_s / 2), ss * 4, wood_s, line_h / 2 - (line_s / 2) - (ss * 4))
            surface.DrawRect((w * 1 / 6) - (wood_s / 2), line_h / 2 + (line_s / 2), wood_s, line_h / 2 - (line_s / 2))
            -- bullet
            surface.DrawRect((w * 1 / 6) - (wood_s / 2) - (w / 6), line_h / 2 - (line_s / 2), w / 6, line_s)

            if pen_wood > wood_width then
                -- penetrated
                surface.DrawRect((w * 1 / 6) + (wood_s / 2), line_h / 2 - (line_s / 2), ss * 4, line_s)
            else
                -- did not penetrate
                local pen_percent = (pen_wood / wood_width)
                surface.DrawRect((w * 1 / 6) - (wood_s / 2) + math.ceil(wood_s * pen_percent), line_h / 2 - (line_s / 2) - 1, wood_s - math.ceil(wood_s * pen_percent), line_s + 1)
            end

            -- metal

            local pen_metal = math.Round(pen / pm_metal, 1)
            local metal_txt = "METAL"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local metal_txtw = surface.GetTextSize(metal_txt)
            surface.SetTextPos((w * 3 / 6) - (metal_txtw / 2), h - (rss * 8))
            surface.DrawText(metal_txt)

            local metal_txt2 = tostring(pen_metal) .. "HU"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local metal_txt2w = surface.GetTextSize(metal_txt)
            surface.SetTextPos((w * 3 / 6) - (metal_txt2w / 2), h - (rss * 8 * 2))
            surface.DrawText(metal_txt2)

            local metal_width = (math.ceil(pen_metal / 5) * 5)
            metal_width = math.max(metal_width, 5)
            metal_width = math.min(metal_width, 20)

            local metal_s = metal_width * ss

            surface.SetDrawColor(col_fg_tr)
            surface.DrawRect((w * 3 / 6) - (metal_s / 2), ss * 4, metal_s, line_h / 2 - (line_s / 2) - (ss * 4))
            surface.DrawRect((w * 3 / 6) - (metal_s / 2), line_h / 2 + (line_s / 2), metal_s, line_h / 2 - (line_s / 2))
            -- bullet
            surface.DrawRect((w * 3 / 6) - (metal_s / 2) - (w / 6), line_h / 2 - (line_s / 2), w / 6, line_s)

            if pen_metal > metal_width then
                -- penetrated
                surface.DrawRect((w * 3 / 6) + (metal_s / 2), line_h / 2 - (line_s / 2), ss * 4, line_s)
            else
                -- did not penetrate
                local pen_percent = (pen_metal / metal_width)
                surface.DrawRect((w * 3 / 6) - (metal_s / 2) + math.ceil(metal_s * pen_percent), line_h / 2 - (line_s / 2) - 1, metal_s - math.ceil(metal_s * pen_percent), line_s + 1)
            end

            -- concrete

            local pen_concrete = math.Round(pen / pm_concrete, 1)
            local concrete_txt = "CONCRETE"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local concrete_txtw = surface.GetTextSize(concrete_txt)
            surface.SetTextPos((w * 5 / 6) - (concrete_txtw / 2), h - (rss * 8))
            surface.DrawText(concrete_txt)

            local concrete_txt2 = tostring(pen_concrete) .. "HU"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local concrete_txt2w = surface.GetTextSize(concrete_txt)
            surface.SetTextPos((w * 5 / 6) - (concrete_txt2w / 2), h - (rss * 8 * 2))
            surface.DrawText(concrete_txt2)

            local concrete_width = (math.ceil(pen_concrete / 5) * 5)
            concrete_width = math.max(concrete_width, 5)
            concrete_width = math.min(concrete_width, 20)

            local concrete_s = concrete_width * ss

            surface.SetDrawColor(col_fg_tr)
            surface.DrawRect((w * 5 / 6) - (concrete_s / 2), ss * 4, concrete_s, line_h / 2 - (line_s / 2) - (ss * 4))
            surface.DrawRect((w * 5 / 6) - (concrete_s / 2), line_h / 2 + (line_s / 2), concrete_s, line_h / 2 - (line_s / 2))
            -- bullet
            surface.DrawRect((w * 5 / 6) - (concrete_s / 2) - (w / 6), line_h / 2 - (line_s / 2), w / 6, line_s)

            if pen_concrete > concrete_width then
                -- penetrated
                surface.DrawRect((w * 5 / 6) + (concrete_s / 2), line_h / 2 - (line_s / 2), ss * 4, line_s)
            else
                -- did not penetrate
                local pen_percent = (pen_concrete / concrete_width)
                surface.DrawRect((w * 5 / 6) - (concrete_s / 2) + math.ceil(concrete_s * pen_percent), line_h / 2 - (line_s / 2) - 1, concrete_s - math.ceil(concrete_s * pen_percent), line_s + 1)
            end
        end
    end

    function ArcCW.InvHUD_FormGamemodeFunctions()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        if !ArcCW.ConVars["attinv_gamemodebuttons"]:GetBool() then return end

        local shoulddrawtitle = false
        local function paint_gmbutton(self2, w, h)
            local col = col_button
            local col2 = col_fg

            if self2:IsHovered() then
                col = col_fg_tr
                col2 = col_shadow
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            surface.SetFont("ArcCWC2_14")
            local tw, th = surface.GetTextSize(self2.Text)

            surface.SetFont("ArcCWC2_14_Glow")
            surface.SetTextColor(col_shadow)
            surface.SetTextPos((w - tw) / 2, (h - th) / 2)
            surface.DrawText(self2.Text)

            surface.SetFont("ArcCWC2_14")
            surface.SetTextColor(col2)
            surface.SetTextPos((w - tw) / 2, (h - th) / 2)
            surface.DrawText(self2.Text)
        end

        if engine.ActiveGamemode() == "terrortown" then
            shoulddrawtitle = true
            local shop = vgui.Create("DButton", ArcCW.InvHUD)
            shop:SetSize(ss * 64, ss * 24)
            shop:SetPos(ScrW() * 0.5 - ss * (64 + 4), ScrH() - ss * (24 + 10))
            shop:SetText("")
            shop.Text = translate("ui.tttequip")
            shop.DoClick = function(self2, clr, btn)
                RunConsoleCommand("ttt_cl_traitorpopup")
            end
            shop.Paint = paint_gmbutton

            local quickchat = vgui.Create("DButton", ArcCW.InvHUD)
            quickchat:SetSize(ss * 64, ss * 24)
            quickchat:SetPos(ScrW() * 0.5 + ss * 4, ScrH() - ss * (24 + 10))
            quickchat:SetText("")
            quickchat.Text = translate("ui.tttchat")
            quickchat.DoClick = function(self2, clr, btn)
                if RADIO then RADIO:ShowRadioCommands(!RADIO.Show) end
            end
            quickchat.Paint = paint_gmbutton
        elseif engine.ActiveGamemode() == "darkrp" or DarkRP then
            -- Check for the global table, as DarkRP has many derivatives
            shoulddrawtitle = true
            local drop = vgui.Create("DButton", ArcCW.InvHUD)
            drop:SetSize(ss * 96, ss * 24)
            drop:SetPos(ScrW() * 0.5 - ss * 48, ScrH() - ss * (24 + 10))
            drop:SetText("")
            drop.Text = translate("ui.darkrpdrop")
            drop.DoClick = function(self2, clr, btn)
                LocalPlayer():ConCommand("say /drop")
            end
            drop.Paint = paint_gmbutton
        end

        if shoulddrawtitle then
            local text = vgui.Create("DPanel", ArcCW.InvHUD)
            text:SetSize(ss * 256, ss * 12)
            text:SetPos(ScrW() * 0.5 - ss * 128, ScrH() - ss * (24 + 12 + 12))
            text.Paint = function(self2, w, h)
                local col2 = col_fg
                local str = translate("ui.gamemode_buttons")
                surface.SetFont("ArcCWC2_12")
                local tw, th = surface.GetTextSize(str)

                surface.SetFont("ArcCWC2_12_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(str)

                surface.SetFont("ArcCWC2_12")
                surface.SetTextColor(col2)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(str)
            end

            local text2 = vgui.Create("DPanel", ArcCW.InvHUD)
            text2:SetSize(ss * 256, ss * 8)
            text2:SetPos(ScrW() * 0.5 - ss * 128, ScrH() - ss * 9)
            text2.Paint = function(self2, w, h)
                local col2 = col_fg
                local str = translate("ui.gamemode_usehint")
                surface.SetFont("ArcCWC2_8")
                local tw, th = surface.GetTextSize(str)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(str)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col2)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(str)
            end
        end
    end

    clearrightpanel()

    ArcCW.Inv_SelectedMenu = ArcCW.Inv_SelectedMenu or 1

    if ArcCW.Inv_SelectedMenu == 1 then
        ArcCW.InvHUD_FormAttachments()
        if self.Inv_SelectedSlot then
            ArcCW.InvHUD_FormAttachmentSelect()
        end
    elseif ArcCW.Inv_SelectedMenu == 2 then
        ArcCW.InvHUD_FormPresets()
    elseif ArcCW.Inv_SelectedMenu == 3 then
        ArcCW.InvHUD_FormInventory()
    end

    ArcCW.InvHUD_FormGamemodeFunctions()

end

--addons/arccw_base_modified/lua/weapons/arccw_base/sh_customize.lua:
local translate = ArcCW.GetTranslation

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

local temp = 0
local SolidBlack = Color(temp, temp, temp)
-- don't fucking mess with the shadow, makes the menu hurt your goddamn eyes

local function DrawTextRot(span, txt, x, y, tx, ty, maxw, only)
    local tw, th = surface.GetTextSize(txt)

    if tw > maxw then
        local realx, realy = span:LocalToScreen(x, y)
        render.SetScissorRect(realx, realy, realx + maxw, realy + (th * 2), true)

        if !only then
            span.TextRot = span.TextRot or 0
            span.StartTextRot = span.StartTextRot or CurTime()
            span.TextRotState = span.TextRotState or 0 -- 0: start, 1: moving, 2: end
            if span.TextRotState == 0 then
                span.TextRot = 0
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 1
                end
            elseif span.TextRotState == 1 then
                span.TextRot = span.TextRot + (FrameTime() * ScreenScaleMulti(16))
                if span.TextRot >= (tw - maxw) + ScreenScaleMulti(8) then
                    span.StartTextRot = CurTime()
                    span.TextRotState = 2
                end
            elseif span.TextRotState == 2 then
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 0
                    span.StartTextRot = CurTime()
                end
            end
        end
        surface.SetTextPos(tx - span.TextRot, ty)
        surface.DrawText(txt)
        render.SetScissorRect(0, 0, 0, 0, false)
    else
        surface.DrawText(txt)
    end
end


function SWEP:ToggleCustomizeHUD(ic)
    if ic and self:GetState() == ArcCW.STATE_SPRINT then return end
    if self:GetReloading() then ic = false end
    if self:GetState() == ArcCW.STATE_DISABLE then return end

    local noinspect = (CLIENT and ArcCW.ConVars["noinspect"]:GetBool()) or (SERVER and self:GetOwner():GetInfoNum("arccw_noinspect", 0) > 0)

    if ic then
        if (self:GetNextPrimaryFire() + 0.1) >= CurTime() then return end

        self:SetState(ArcCW.STATE_CUSTOMIZE)
        self:ExitSights()
        self:SetShouldHoldType()
        self:ExitBipod()
        if !noinspect then
            self:PlayAnimation(self:SelectAnimation("enter_inspect"), nil, true, nil, nil, true, false)
        end

        if CLIENT then
            self:OpenCustomizeHUD()
        end
    else
        self:SetState(ArcCW.STATE_IDLE)
        self.Sighted = false
        self.Sprinted = false
        self:SetShouldHoldType()

        if !noinspect then
            self:PlayAnimation(self:SelectAnimation("exit_inspect"), nil, true, nil, nil, true, false)
        end

        if CLIENT then
            self:CloseCustomizeHUD()
            self:SendAllDetails()
        end
    end
end

if CLIENT then

local function multlinetext(text, maxw, font)
    local content = {}
    local tline = ""
    local x = 0
    surface.SetFont(font)

    local newlined = string.Split(text, "\n")

    for _, line in pairs(newlined) do
        local words = string.Split(line, " ")

        for _, word in pairs(words) do
            local tx = surface.GetTextSize(word)

            if x + tx >= maxw then
                table.insert(content, tline)
                tline = ""
                x = surface.GetTextSize(word)
            end

            tline = tline .. word .. " "

            x = x + surface.GetTextSize(word .. " ")
        end

        table.insert(content, tline)
        tline = ""
        x = 0
    end

    -- local space_len = surface.GetTextSize(" ")

    -- for _, word in pairs(string.Split(text, " ")) do
    --     if word == "\n" then
    --         table.insert(content, line)
    --         line = ""
    --         x = 0
    --     else
    --         x = x + surface.GetTextSize(word)

    --         if x >= limitx then
    --             table.insert(content, line)
    --             line = ""
    --             x = 0
    --             x = x + surface.GetTextSize(word)
    --         end

    --         line = line .. word .. " "

    --         x = x + space_len

    --         -- print(word .. " at " .. tostring(x))
    --     end
    -- end

    -- table.insert(content, line)

    return content
end

-- Same snippet of code in Paint() moved to its own function so the button won't be added if it's not valid to begin with
function SWEP:ValidateAttachment(attname, attslot, i)
    if !self:IsValid() or !self.Attachments then return false end
    local atttbl = ArcCW.AttachmentTable[attname]
    if !atttbl then return true, nil, nil, nil end

    attslot = attslot or self.Attachments[i]

    local show = true
    local showqty = true
    local installed = false
    local blocked = !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags)
    local owned = self:PlayerOwnsAtt(attname)

    if !ArcCW:SlotAcceptsAtt(attslot.Slot or "", self, attname) then
        blocked = true
    end

    if !atttbl or atttbl.Free then
        showqty = false
    end

    if ArcCW.ConVars["attinv_free"]:GetBool() then
        showqty = false
    end

    -- if !owned then
    --     showqty = false
    -- end

    if ArcCW.ConVars["attinv_lockmode"]:GetBool() then
        showqty = false
    end

    -- orighas checks if the original slot accepts this attachment.
    -- If the original slot is ok but the mergeslot that has the same attachment is not, we're still okay
    local orighas = ArcCW:SlotAcceptsAtt(self.Attachments[i], self, attname) and self:CheckFlags(self.Attachments[i].ExcludeFlags, self.Attachments[i].RequireFlags)

    if attslot.Installed == attname then
        installed = true
    end

    if attname == "" and !attslot.Installed then
        installed = true

        for _, slot in pairs(attslot.MergeSlots or {}) do
            if self.Attachments[slot].Installed then
                installed = false
                break
            end
        end
    end

    for _, slot in pairs(attslot.MergeSlots or {}) do
        if !slot then continue end
        if !self.Attachments[slot] then continue end
        if !blocked and ArcCW:SlotAcceptsAtt(self.Attachments[slot], self, attname) and
                !self:CheckFlags(self.Attachments[slot].ExcludeFlags, self.Attachments[slot].RequireFlags) and
                !orighas then
            blocked = true
            if self.Attachments[slot].HideIfBlocked then
                show = false
            end
            break
        end
        if self.Attachments[slot].Installed == attname then
            installed = true
            break
        end
    end

    if blocked and atttbl and atttbl.HideIfBlocked then
        show = false
    end

    if !owned and atttbl and atttbl.HideIfUnavailable then
        show = false
    end

    if !owned and ArcCW.ConVars["attinv_hideunowned"]:GetBool() then
        show = false
    end

    return show, installed, blocked, showqty
end

function SWEP:OpenCustomizeHUD()
    if self:GetPriorityAnim() then return end
    if IsValid(ArcCW.InvHUD) then
        ArcCW.InvHUD:Show()
        -- ArcCW.InvHUD:RequestFocus()
    else
        --if GetConVar("arccw_dev_cust2beta"):GetBool() then self:CreateCustomize2HUD() else self:CreateCustomizeHUD() end
        self:CreateCustomize2HUD()
        gui.SetMousePos(ScrW() / 2, ScrH() / 2)
    end

    ArcCW.Inv_Hidden = false
    gui.EnableScreenClicker(true)

    if ArcCW.ConVars["cust_sounds"]:GetBool() then surface.PlaySound("weapons/arccw/extra.wav") end

end

function SWEP:CloseCustomizeHUD( hide )
    if IsValid(ArcCW.InvHUD) then
        --if !GetConVar("arccw_dev_cust2beta"):GetBool() then
        if false then
            ArcCW.InvHUD:Hide()
            ArcCW.InvHUD:Clear()
            if vrmod and vrmod.MenuExists( "ArcCW_Customize" ) then
                vrmod.MenuClose( "ArcCW_Customize" )
            end
            if !hide then
                ArcCW.InvHUD:Remove()
            end
        else
            -- The new hud fades out instead of commiting sudoku, only do this if we're debugging
            if ArcCW.ConVars["dev_removeonclose"]:GetBool() then
                ArcCW.InvHUD:Remove()
            end
        end

        if !hide then
            gui.EnableScreenClicker(false)
        end
        ArcCW.Inv_Hidden = false

        if ArcCW.ConVars["cust_sounds"]:GetBool() then surface.PlaySound("weapons/arccw/extra2.wav") end
    end
end

local defaultatticon = Material("arccw/hud/atts/default.png", "smooth mips")
local blockedatticon = Material("arccw/hud/atts/blocked.png", "smooth mips")
local activeslot = nil
local bird = Material("arccw/hud/arccw_bird.png", "mips smooth")

SWEP.InAttMenu = false

function SWEP:CreateCustomizeHUD()
    local barsize = ScreenScaleMulti(160)
    local airgap = ScreenScaleMulti(16)
    local smallgap = ScreenScaleMulti(2)
    local linesize = ScreenScaleMulti(1)
    local buttonsize = ScreenScaleMulti(32)
    local fg_col = Color(255, 255, 255, 255)
    local bg_col = Color(0, 0, 0, 150)

    if !self:IsValid() then return end

    self.InAttMenu = false
    activeslot = nil

    local scrw, scrh = ScrW(), ScrH()
    if vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        -- Other resolutions seem to cause stretching issues
        scrw = 1366
        scrh = 768
    end

    ArcCW.InvHUD = vgui.Create("DFrame")

            local scrwmult = ArcCW.ConVars["hud_deadzone_x"]:GetFloat() * ScrW()
            local scrhmult = ArcCW.ConVars["hud_deadzone_y"]:GetFloat() * ScrH()

    scrw, scrh = scrw - scrwmult, scrh - scrhmult

    ArcCW.InvHUD:SetPos(0, 0)
    ArcCW.InvHUD:SetSize(scrw, scrh)
    ArcCW.InvHUD:Center()
    ArcCW.InvHUD:SetText("")
    ArcCW.InvHUD:SetTitle("")
    ArcCW.InvHUD.Paint = function(span)
        if !IsValid(self) then
            gui.EnableScreenClicker(false)
            span:Remove()
        end

        if --[[self:GetState() != ArcCW.STATE_CUSTOMIZE or]] self:GetReloading() then
            span:Remove()
        end
    end
    ArcCW.InvHUD.ActiveWeapon = self
    ArcCW.InvHUD.OnRemove = function()
        local close = false
        if self:IsValid() and self:GetState() == ArcCW.STATE_CUSTOMIZE then
            close = true
        end

        if LocalPlayer():GetActiveWeapon() != ArcCW.InvHUD.ActiveWeapon then
            close = true
        end

        if close then
            net.Start("arccw_togglecustomize")
            net.WriteBool(false)
            net.SendToServer()

            if IsValid(self) and self.ToggleCustomizeHUD then
                self:ToggleCustomizeHUD(false)
            end
        end

        gui.EnableScreenClicker(false)
    end

    if ArcCW.ConVars["attinv_onlyinspect"]:GetBool() then
        return
    end

    local loadpresets = vgui.Create("DButton", ArcCW.InvHUD)
    loadpresets:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    loadpresets:SetText("")
    loadpresets:SetPos(scrw - barsize - airgap, airgap)

    loadpresets.OnMousePressed = function(spaa, kc)
        self:CreatePresetMenu()
    end

    loadpresets.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (translate("ui.loadpreset"))

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local savepresets = vgui.Create("DButton", ArcCW.InvHUD)
    savepresets:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    savepresets:SetText("")
    savepresets:SetPos(scrw - (barsize / 2) + ScreenScaleMulti(1) - airgap, airgap)

    savepresets.OnMousePressed = function(spaa, kc)
        self:CreatePresetSave()
    end

    savepresets.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (translate("ui.savepreset"))

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local attcatsy = scrh - ScreenScaleMulti(64) - airgap

    local attcats = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    attcats:SetText("")
    attcats:SetSize(barsize, attcatsy)
    attcats:SetPos(airgap, airgap)
    attcats.Paint = function(span, w, h)
        -- surface.SetDrawColor(bg_col)
        -- surface.DrawRect(0, 0, w, h)
    end

    local triviabox = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    triviabox:SetText("")
    triviabox:SetSize(barsize, scrh - ScreenScaleMulti(64) - (3 * airgap))
    triviabox:SetPos(scrw - barsize - airgap, 2 * airgap)
    triviabox.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local sbar = attcats:GetVBar()
    sbar.Paint = function() end

    sbar.btnUp.Paint = function(span, w, h)
    end

    sbar.btnDown.Paint = function(span, w, h)
    end

    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local wpninfo = attcats:Add("DLabel")
    wpninfo:SetSize(barsize, buttonsize)
    wpninfo:SetText("")
    wpninfo:Dock( TOP )
    wpninfo:DockMargin( 0, 0, 0, smallgap )

    wpninfo.Paint = function(span, w, h)
        if !IsValid(self) then return end
        local Bfg_col = fg_col
        local Bbg_col = bg_col

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)
        surface.DrawRect(0, 0, w, h / 2)

        surface.SetDrawColor(Bfg_col)
        surface.DrawRect(0, (h - linesize) / 2, w, linesize)

        surface.SetTextColor(SolidBlack)
        surface.SetTextPos(smallgap, 0)
        surface.SetFont("ArcCW_12_Glow")
        surface.DrawText(translate("name." .. self:GetClass() .. (ArcCW.ConVars["truenames"]:GetBool() and ".true" or "")) or self.PrintName)

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, 0)
        surface.SetFont("ArcCW_12")
        surface.DrawText(translate("name." .. self:GetClass() .. (ArcCW.ConVars["truenames"]:GetBool() and ".true" or "")) or self.PrintName)

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap * 2, (h - linesize) / 2 + smallgap)
        surface.SetFont("ArcCW_12")

        local pick = self:GetPickX()

        if pick <= 0 then
            surface.DrawText(ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class))
        else
            local txt = self:CountAttachments() .. "/" .. pick .. " Attachments"

            surface.DrawText(txt)
        end
    end

    local statbox = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    statbox:SetText("")
    statbox:SetSize(barsize, scrh - ScreenScaleMulti(64) - (3 * airgap))
    statbox:SetPos(scrw - barsize - airgap, 2 * airgap)
    statbox.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)
    end
    statbox:Hide()
    local regenStatList -- early definition so category unequiping can update

    local sbar3 = statbox:GetVBar()
    sbar3.Paint = function() end

    sbar3.btnUp.Paint = function(span, w, h)
    end

    sbar3.btnDown.Paint = function(span, w, h)
    end

    sbar3.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local attmenuh = scrh - (2 * airgap)

    local attmenu = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    attmenu:SetText("")
    attmenu:SetSize(barsize + ScreenScaleMulti(12), attmenuh)
    attmenu:SetPos(airgap + barsize + smallgap, airgap)
    attmenu.Paint = function(span, w, h)
        -- surface.SetDrawColor(bg_col)
        -- surface.DrawRect(0, 0, w, h)
    end
    attmenu:Hide()

    local sbar4 = attmenu:GetVBar()
    sbar4.Paint = function() end

    sbar4.btnUp.Paint = function(span, w, h)
    end

    sbar4.btnDown.Paint = function(span, w, h)
    end

    sbar4.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local attslidebox = vgui.Create("DPanel", ArcCW.InvHUD)
    attslidebox:SetSize(barsize, ScreenScaleMulti(20))
    attslidebox:SetPos(scrw - barsize - airgap, scrh - ScreenScaleMulti(64) - (1 * airgap))
    attslidebox.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)

        surface.SetTextColor(fg_col)
        surface.SetFont("ArcCW_6")
        surface.SetTextPos(smallgap, smallgap)
        surface.DrawText(translate("ui.position"))
    end

    local attslider = vgui.Create("DSlider", attslidebox)
    attslider:SetPos(ScreenScaleMulti(4), ScreenScaleMulti(12))
    attslider:SetSize(barsize - ScreenScaleMulti(4 * 2), ScreenScaleMulti(4))

    attslider.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, h / 2, w, ScreenScaleMulti(1))
    end

    local lastslidepos = 0
    local lastsoundtime = 0

    attslider.Knob.Paint = function(span, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end

        if span:IsHovered() or attslider:GetDragging() then
            surface.SetDrawColor(fg_col)
            surface.DrawRect((w - ScreenScaleMulti(2)) / 2, 0, ScreenScaleMulti(2), h)
        else
            surface.SetDrawColor(fg_col)
            surface.DrawRect((w - ScreenScaleMulti(1)) / 2, 0, ScreenScaleMulti(1), h)
        end

        if attslider:GetDragging() and activeslot then
            local delta = attslider:GetSlideX()
            if lastslidepos != delta and lastsoundtime <= CurTime() then

                EmitSound("weapons/arccw/dragatt.wav", EyePos(), -2, CHAN_ITEM, 1,75, 0, math.Clamp(delta * 200, 90, 110))

                lastsoundtime = CurTime() + 0.05
            end

            self.Attachments[activeslot].SlidePos = delta
            lastslidepos = delta
        end

        attslider:SetSlideX((self.Attachments[activeslot] or {}).SlidePos or 0.5)
    end

    local og_attsliderknobmr = attslider.Knob.OnMouseReleased

    attslider.Knob.OnMouseReleased = function(span, kc)
        og_attsliderknobmr(span, kc)
        self:SendDetail_SlidePos(activeslot)
        self:SavePreset("autosave")
    end

    attslidebox:Hide()

    local atttogglebtn = vgui.Create("DButton", ArcCW.InvHUD)
    atttogglebtn:SetSize(barsize * 0.25, ScreenScaleMulti(15))
    atttogglebtn:SetPos(scrw - barsize - airgap + barsize * 0.75, scrh - ScreenScaleMulti(64) - (1 * airgap))
    atttogglebtn:SetText("")
    atttogglebtn.OnMousePressed = function(spaa, kc)
        if !self.Attachments[activeslot] then return end
        local catttbl = ArcCW.AttachmentTable[self.Attachments[activeslot].Installed]
        if !catttbl or !catttbl.ToggleStats then return end

        self:ToggleSlot(activeslot)
        --[[]
        self.Attachments[activeslot].ToggleNum = (self.Attachments[activeslot].ToggleNum or 1) + 1
        if self.Attachments[activeslot].ToggleNum > #catttbl.ToggleStats then
            self.Attachments[activeslot].ToggleNum = 1
        end
        self:SendDetail_ToggleNum(activeslot)
        self:AdjustAtts()
        if self:GetHasFlashlights() then
            self:CreateFlashlightsVM()
        end

        EmitSound("weapons/arccw/firemode.wav", EyePos(), -2, CHAN_ITEM, 1,75, 0, 100)
        ]]
    end
    atttogglebtn.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (translate("ui.toggle"))
        local catttbl = activeslot and ArcCW.AttachmentTable[self.Attachments[activeslot].Installed]
        if catttbl and catttbl.ToggleStats[self.Attachments[activeslot].ToggleNum]
                and catttbl.ToggleStats[self.Attachments[activeslot].ToggleNum].PrintName then
            txt = ArcCW.TryTranslation(catttbl.ToggleStats[self.Attachments[activeslot].ToggleNum].PrintName)
        end

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    atttogglebtn:Hide()

    local atttrivia = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    atttrivia:SetSize(barsize, scrh - ScreenScaleMulti(116))
    atttrivia:SetPos(scrw - barsize - airgap, 2 * airgap)
    atttrivia.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)
    end
    atttrivia:Hide()

    local sbar5 = atttrivia:GetVBar()
    sbar5.Paint = function() end

    sbar5.btnUp.Paint = function(span, w, h)
    end

    sbar5.btnDown.Paint = function(span, w, h)
    end

    sbar5.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local last_atttrivia = nil

    local function atttrivia_do(att, slot)

        if !att then
            last_atttrivia = att
            atttrivia:Hide()
            atttrivia:Clear()
            return
        end

        if att == "" then
            last_atttrivia = att
            atttrivia:Hide()
            atttrivia:Clear()
            return
        end

        if att == last_atttrivia then
            last_atttrivia = att
            return
        end

        atttrivia:Clear()

        last_atttrivia = att

        local atttbl = ArcCW.AttachmentTable[att]

        atttrivia:Show()

        -- att name

        local triv_attname = vgui.Create("DLabel", atttrivia)
            triv_attname:SetSize(barsize, ScreenScaleMulti(16))
            triv_attname:Dock(TOP)
            triv_attname:DockMargin( 0, 0, 0, 0 )
            triv_attname:SetText("")
            triv_attname.Paint = function(span, w, h)
                local txt = multlinetext(translate("name." .. att) or atttbl.PrintName, w, "ArcCW_16")

                c = 0

                for _, i in pairs(txt) do
                    surface.SetFont("ArcCW_16")
                    local tw = surface.GetTextSize(i)

                    surface.SetFont("ArcCW_16_Glow")
                    surface.SetTextPos((smallgap + (w - tw)) / 2, c)
                    surface.SetTextColor(SolidBlack)
                    surface.DrawText(i)

                    surface.SetFont("ArcCW_16")
                    surface.SetTextPos((smallgap + (w - tw)) / 2, c)
                    surface.SetTextColor(fg_col)
                    surface.DrawText(i)

                    c = c + ScreenScaleMulti(16)
                end

                span:SetSize(barsize, c)
            end

        -- att pic

        local triv_pic = vgui.Create("DLabel", atttrivia)
            triv_pic:SetSize(barsize, barsize / 2)
            triv_pic:Dock(TOP)
            triv_pic:DockMargin( 0, 0, 0, smallgap )
            triv_pic:SetText("")
            triv_pic.Paint = function(span, w, h)
                local img = atttbl.Icon or defaultatticon
                if !img or img:IsError() then img = bird end

                surface.SetDrawColor(fg_col)
                surface.SetMaterial(img)
                surface.DrawTexturedRect(h / 2, 0, h, h)
            end

        -- att desc

        desctext = multlinetext(translate("desc." .. att) or atttbl.Description, barsize - smallgap * 2, "ArcCW_8")

        local triv_desc = vgui.Create("DLabel", atttrivia)
        triv_desc:SetSize(barsize, ScreenScaleMulti(8) * (table.Count(desctext) + 1))
        triv_desc:SetText("")
        triv_desc:DockMargin( 0, 0, 0, smallgap )
        triv_desc:Dock(TOP)
        triv_desc.Paint = function(span, w, h)
            local y = ScreenScaleMulti(8)
            for i, line in pairs(desctext) do
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap * 2, y)
                surface.SetTextColor(fg_col)
                surface.DrawText(line)
                y = y + ScreenScaleMulti(8)
            end
        end

        local neutrals = atttbl.Desc_Neutrals or {}

        local pros, cons = ArcCW:GetProsCons(self, atttbl, self.Attachments[slot].ToggleNum)

        if (pros and #pros or 0) > 0 then

            local triv_pros = vgui.Create("DLabel", atttrivia)
            triv_pros:SetSize(barsize, ScreenScaleMulti(10))
            triv_pros:SetText("")
            triv_pros:Dock(TOP)
            triv_pros.Paint = function(span, w, h)
                surface.SetDrawColor(Color(0, 50, 0, 100))
                surface.DrawRect(0, 0, w, h)

                surface.SetTextColor(Color(125, 200, 125))
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.DrawText(translate("ui.positives"))
            end

            for _, i in pairs(pros) do
                local triv_pro = vgui.Create("DLabel", atttrivia)
                triv_pro:SetSize(barsize, ScreenScaleMulti(10))
                triv_pro:SetText("")
                triv_pro:Dock(TOP)
                triv_pro.Paint = function(span, w, h)

                    surface.SetTextColor(Color(150, 225, 150))
                    surface.SetFont("ArcCW_8")
                    surface.SetTextPos(smallgap, 0)
                    surface.DrawText(i)
                end
            end
        end

        if (cons and #cons or 0) > 0 then
            local triv_cons = vgui.Create("DLabel", atttrivia)
            triv_cons:SetSize(barsize, ScreenScaleMulti(10))
            triv_cons:SetText("")
            triv_cons:Dock(TOP)
            triv_cons.Paint = function(span, w, h)
                surface.SetDrawColor(Color(50, 0, 0, 100))
                surface.DrawRect(0, 0, w, h)

                surface.SetTextColor(Color(200, 125, 125))
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.DrawText(translate("ui.negatives"))
            end

            for _, i in pairs(cons) do
                local triv_con = vgui.Create("DLabel", atttrivia)
                triv_con:SetSize(barsize, ScreenScaleMulti(10))
                triv_con:SetText("")
                triv_con:Dock(TOP)
                triv_con.Paint = function(span, w, h)

                    surface.SetTextColor(Color(225, 150, 150))
                    surface.SetFont("ArcCW_8")
                    surface.SetTextPos(smallgap, 0)
                    surface.DrawText(i)
                end
            end
        end

        if #neutrals > 0 then

            local triv_neutrals = vgui.Create("DLabel", atttrivia)
            triv_neutrals:SetSize(barsize, ScreenScaleMulti(10))
            triv_neutrals:SetText("")
            triv_neutrals:Dock(TOP)
            triv_neutrals.Paint = function(span, w, h)
                surface.SetDrawColor(Color(0, 0, 50, 100))
                surface.DrawRect(0, 0, w, h)

                surface.SetTextColor(Color(125, 125, 200))
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.DrawText(translate("ui.information"))
            end

            for _, i in pairs(neutrals) do
                local triv_neutral = vgui.Create("DLabel", atttrivia)
                triv_neutral:SetSize(barsize, ScreenScaleMulti(10))
                triv_neutral:SetText("")
                triv_neutral:Dock(TOP)
                triv_neutral.Paint = function(span, w, h)

                    surface.SetTextColor(Color(150, 150, 225))
                    surface.SetFont("ArcCW_8")
                    surface.SetTextPos(smallgap, 0)
                    surface.DrawText(ArcCW.TryTranslation(i))
                end
            end
        end
    end

    ArcCW.InvHUD.OnMousePressed = function(span, kc)
        if (kc == MOUSE_LEFT or kc == MOUSE_RIGHT) and
                !triviabox:IsVisible() and !statbox:IsVisible() then
            activeslot = nil
            triviabox:Show()
            statbox:Hide()
            attmenu:Hide()
            self.InAttMenu = false
            atttrivia:Hide()
            attslidebox:Hide()
            atttogglebtn:Hide()
            if ArcCW.ConVars["cust_sounds"]:GetBool() then surface.PlaySound("weapons/arccw/close.wav") end
        end
    end

    for i, k in pairs(self.Attachments) do
        if !k.PrintName then continue end
        if i == "BaseClass" then continue end
        if k.Hidden or k.Blacklisted then continue end
        if k.Integral then continue end

        local attcatb = attcats:Add("DButton")
        if ArcCW.ConVars["hud_embracetradition"]:GetBool() then
            attcatb:SetSize(barsize, buttonsize )
        else
            attcatb:SetSize(barsize, buttonsize / 2)
        end
        attcatb:SetText("")
        attcatb:Dock( TOP )
        attcatb:DockMargin( 0, 0, 0, smallgap )

        attcatb.AttIndex = i
        attcatb.AttSlot = k

        local function attcatb_regen(span)
            local catt = self.Attachments[span.AttIndex].Installed
            local catttbl
            if catt then
                catttbl = ArcCW.AttachmentTable[catt]
            end

            if self.Attachments[span.AttIndex].Installed and self.Attachments[span.AttIndex].SlideAmount and !catttbl.MountPositionOverride then
                attslidebox:Show()
            else
                attslidebox:Hide()
            end

            if self.Attachments[span.AttIndex].Installed and catttbl and catttbl.ToggleStats then
                if attslidebox:IsVisible() then
                    atttogglebtn:SetPos(scrw - barsize - airgap + barsize * 0.75, scrh - ScreenScaleMulti(40) - (1 * airgap))
                else
                    atttogglebtn:SetPos(scrw - barsize - airgap + barsize * 0.75, scrh - ScreenScaleMulti(64) - (1 * airgap))
                end
                atttogglebtn:Show()
            else
                atttogglebtn:Hide()
            end

            attmenu:Clear()

            local atts = {}
            local slots = {i}
            local attCheck = {}

            table.Add(slots, k.MergeSlots or {})

            for _, y in pairs(slots) do
                for _, bruh in pairs(ArcCW:GetAttsForSlot((self.Attachments[y] or {}).Slot, self)) do
                    if attCheck[bruh] then continue end
                    table.insert(atts, {
                        att = bruh,
                        slot = y
                    })
                    attCheck[bruh] = true
                end
            end

            atts[0] = ""

            table.sort(atts, function(a, b)
                a = a.att or ""
                b = b.att or ""
                local atttbl_a = ArcCW.AttachmentTable[a]
                local atttbl_b = ArcCW.AttachmentTable[b]

                local order_a = 0
                local order_b = 0

                order_a = atttbl_a.SortOrder or order_a
                order_b = atttbl_b.SortOrder or order_b

                if order_a == order_b then
                    return (translate("name." .. a) or atttbl_a.PrintName or "") > (translate("name." .. b) or atttbl_b.PrintName or "")
                end

                return order_a > order_b
            end)

            local ca = 0

            for _, att in pairs(atts) do
                local aslot = att
                if istable(att) then
                    aslot = aslot.slot
                    att = att.att
                end
                local owned = self:PlayerOwnsAtt(att)

                if !owned and ArcCW.ConVars["attinv_hideunowned"]:GetBool() then continue end

                local valid, installed, blocked, showqty = self:ValidateAttachment(att, k, i)

                if !valid then continue end

                local attbtn = attmenu:Add("DButton")
                attbtn:SetSize(barsize + ScreenScaleMulti(12), ScreenScaleMulti(14))
                attbtn:SetText("")
                attbtn:Dock( TOP )
                attbtn:DockMargin( 0, 0, 0, smallgap )

                ca = ca + 1

                attbtn.AttName = att

                attbtn.OnMousePressed = function(spaa, kc2)

                    owned = self:PlayerOwnsAtt(spaa.AttName)
                    local installed = false
                    local orighas = ArcCW:SlotAcceptsAtt(self.Attachments[i], self, spaa.AttName) and self:CheckFlags(self.Attachments[i].ExcludeFlags, self.Attachments[i].RequireFlags)

                    local atttbl = ArcCW.AttachmentTable[spaa.AttName]
                    if atttbl then
                        if !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags) then return end
                        for _, slot in pairs(k.MergeSlots or {}) do
                            if self.Attachments[slot].Installed then
                                installed = true
                            end

                            if slot and self.Attachments[slot] and
                                    ArcCW:SlotAcceptsAtt(self.Attachments[slot], self, spaa.AttName) and
                                    !self:CheckFlags(self.Attachments[slot].ExcludeFlags, self.Attachments[slot].RequireFlags) and
                                    !orighas then
                                return
                            end
                        end
                    end

                    if kc2 == MOUSE_LEFT and owned then

                        if spaa.AttName == "" then
                            self:DetachAllMergeSlots(span.AttIndex)
                        else
                            self:DetachAllMergeSlots(span.AttIndex, true)
                            self:Attach(aslot, spaa.AttName)
                        end
                    elseif kc2 == MOUSE_RIGHT and spaa.AttName != "" then
                        if span.AttSlot.Installed == spaa.AttName then
                            -- Unequip
                            self:DetachAllMergeSlots(span.AttIndex)
                        elseif installed then
                            self:DetachAllMergeSlots(span.AttIndex)
                        elseif owned then
                            -- Drop attachment
                            if ArcCW.ConVars["attinv_free"]:GetBool() then return end
                            if ArcCW.ConVars["attinv_lockmode"]:GetBool() then return end
                            if ArcCW.ConVars["enable_customization"]:GetInt() < 0 then return end
                            if !ArcCW.ConVars["enable_dropping"]:GetBool() then return end

                            net.Start("arccw_asktodrop")
                                net.WriteUInt(ArcCW.AttachmentTable[spaa.AttName].ID, 24)
                            net.SendToServer()

                            ArcCW:PlayerTakeAtt(self:GetOwner(), spaa.AttName)
                        end
                    end

                    attcatb_regen(span)
                end

                attbtn.Paint = function(spaa, w, h)
                    if !self:IsValid() then return end
                    if !self.Attachments then return end
                    local Bfg_col = Color(255, 255, 255, 255)
                    local Bbg_col = Color(0, 0, 0, 100)
                    local atttbl = ArcCW.AttachmentTable[spaa.AttName]
                    local qty = ArcCW:PlayerGetAtts(self:GetOwner(), spaa.AttName)

                    valid, installed, blocked, showqty = self:ValidateAttachment(att, k, i)
                    if !valid then
                        attbtn:Remove()
                        return
                    end

                    owned = self:PlayerOwnsAtt(spaa.AttName)

                    if !atttbl and ArcCW.AttachmentTable[k.EmptyFallback] then
                        atttbl = ArcCW.AttachmentTable[k.EmptyFallback]
                    elseif !atttbl then
                        atttbl = {
                            PrintName = k.DefaultAttName and ArcCW.TryTranslation(k.DefaultAttName) or translate("attslot.noatt"),
                            Icon = k.DefaultAttIcon or defaultatticon,
                            Free = true
                        }
                    end

                    if spaa:IsHovered() or installed then
                        Bbg_col = Color(255, 255, 255, 100)
                        Bfg_col = Color(0, 0, 0, 255)
                    end

                    if spaa:IsHovered() and installed then
                        Bbg_col = Color(255, 255, 255, 200)
                        Bfg_col = Color(0, 0, 0, 255)
                    end

                    if spaa:IsHovered() then
                        atttrivia_do(spaa.AttName, i)
                    end

                    if !owned and ArcCW.ConVars["attinv_darkunowned"]:GetBool() then
                        if spaa:IsHovered() then
                            Bbg_col = Color(50, 50, 50, 150)
                            Bfg_col = Color(150, 150, 150, 255)
                        else
                            Bbg_col = Color(20, 20, 20, 150)
                            Bfg_col = Color(150, 150, 150, 255)
                        end
                    elseif !owned or blocked then
                        if spaa:IsHovered() then
                            Bbg_col = Color(125, 25, 25, 150)
                            Bfg_col = Color(150, 50, 50, 255)
                        else
                            Bbg_col = Color(75, 0, 0, 150)
                            Bfg_col = Color(150, 50, 50, 255)
                        end
                    end

                    local max = atttbl.Max

                    if max then
                        local amt = 0

                        for i2, k2 in pairs(self.Attachments) do
                            if k2.Installed == spaa.AttName then
                                amt = amt + 1
                            end
                        end

                        if amt >= max and self.Attachments[i].Installed != spaa.AttName then
                            if spaa:IsHovered() then
                                Bbg_col = Color(125, 25, 25, 150)
                                Bfg_col = Color(150, 50, 50, 255)
                            else
                                Bbg_col = Color(75, 0, 0, 150)
                                Bfg_col = Color(150, 50, 50, 255)
                            end
                        end
                    end

                    surface.SetDrawColor(Bbg_col)
                    surface.DrawRect(0, 0, w, h)
                    surface.DrawRect(0, 0, h * 1.5, h)

                    surface.SetDrawColor(Bfg_col)
                    surface.DrawRect((h * 1.5) - (linesize / 2), 0, linesize, h)

                    local txt = translate("name." .. spaa.AttName) or atttbl.PrintName or "???"

                    if showqty then
                        txt = txt .. " (" .. tostring(qty) .. ")"
                    end

                    surface.SetTextColor(Bfg_col)
                    surface.SetTextPos((h * 1.5) + smallgap, ScreenScaleMulti(1))
                    surface.SetFont("ArcCW_12")

                    DrawTextRot(spaa, txt, h * 1.5, 0, (h * 1.5) + smallgap, ScreenScaleMulti(1), w - (h * 1.5))

                    -- surface.DrawText(txt)

                    local icon = k.DefaultAttIcon or defaultatticon
                    if atttbl then
                        icon = atttbl.Icon
                    end
                    if (!icon or icon:IsError()) then icon = bird end

                    surface.SetDrawColor(Bfg_col)
                    surface.SetMaterial(icon)
                    surface.DrawTexturedRect(h / 4, 0, h, h)

                    if blocked then
                        surface.SetDrawColor(color_white)
                        surface.SetMaterial(blockedatticon)
                        surface.DrawTexturedRect(h / 4 - h * 0.1, - h * 0.1, h * 1.2, h * 1.2)
                    end
                end
            end

            local specsize = ca * (ScreenScaleMulti(14) + smallgap)

            attmenu:SetSize(barsize + ScreenScaleMulti(12), math.min(specsize, attmenuh))
        end

        attcatb.OnMousePressed = function(span, kc)
            if !self:CheckFlags(span.AttSlot.ExcludeFlags, span.AttSlot.RequireFlags) then
                return
            end

            if kc == MOUSE_LEFT then
                if activeslot == span.AttIndex then
                    activeslot = nil
                    triviabox:Show()
                    statbox:Hide()
                    attmenu:Hide()
                    self.InAttMenu = false
                    atttrivia:Hide()
                    attslidebox:Hide()
                    atttogglebtn:Hide()
                    surface.PlaySound("weapons/arccw/close.wav")
                else
                    activeslot = span.AttIndex
                    triviabox:Hide()
                    statbox:Hide()
                    attmenu:Show()
                    attslider:SetSlideX(self.Attachments[span.AttIndex].SlidePos)
                    lastslidepos = self.Attachments[span.AttIndex].SlidePos
                    self.InAttMenu = true
                    surface.PlaySound("weapons/arccw/open.wav")

                    span.TextRot = 0
                    span.StartTextRot = CurTime()
                    span.TextRotState = 0

                    if self.Attachments[span.AttIndex].Installed then
                        atttrivia_do(self.Attachments[span.AttIndex].Installed, span.AttIndex)
                    end

                    attcatb_regen(span)
                end
            elseif kc == MOUSE_RIGHT then
                self:DetachAllMergeSlots(span.AttIndex)
                attcatb_regen(span)
                if statbox:IsVisible() then
                    regenStatList()
                end
            end
        end

        attcatb.Paint = function(span, w, h)

            -- Might error when player dies
            if !self or !self.Attachments then return end

            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if span:IsHovered() or activeslot == span.AttIndex then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            if span:IsHovered() and activeslot == span.AttIndex then
                Bbg_col = Color(255, 255, 255, 200)
                Bfg_col = Color(0, 0, 0, 255)
            end

            if self.CheckFlags and !self:CheckFlags(span.AttSlot.ExcludeFlags, span.AttSlot.RequireFlags) then
                Bbg_col = Color(75, 0, 0, 150)
                Bfg_col = Color(150, 50, 50, 255)
            end

            local txt =  ArcCW.TryTranslation(k.PrintName)

            local att_txt = k.DefaultAttName and ArcCW.TryTranslation(k.DefaultAttName) or translate("attslot.noatt")
            local att_icon = k.DefaultAttIcon or defaultatticon

            local installed = k.Installed

            if !installed then
                (k.MergeSlots or {})["BaseClass"] = nil
                for _, slot in pairs(k.MergeSlots or {}) do
                    if self.Attachments[slot] and self.Attachments[slot].Installed then
                        installed = self.Attachments[slot].Installed
                        break
                    elseif !self.Attachments[slot] then
                        print("ERROR! No attachment " .. tostring(slot))
                    end
                end
            end

            if installed then
                local atttbl = ArcCW.AttachmentTable[installed]

                if atttbl.Health then
                    local perc = (self:GetAttachmentHP(i) / self:GetAttachmentMaxHP(i)) * 100
                    perc = math.Round(perc)
                    txt = txt .. " (" .. tostring(perc) .. "%)"
                end
                if !ArcCW.ConVars["hud_embracetradition"]:GetBool() then
                    att_txt = translate("name." .. installed) or atttbl.PrintName

                    if atttbl.Icon then
                        att_icon = atttbl.Icon
                        if (!att_icon or att_icon:IsError()) then att_icon = bird end
                    end
                end
            end

            if ArcCW.ConVars["hud_embracetradition"]:GetBool() then
                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(0, 0, w, h / 2)
                surface.DrawRect(w - (1.5 * h), h / 2, 1.5 * h, h / 2)

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(0, 0, w, h / 2)
                surface.DrawRect(w - (1.5 * h), h / 2, 1.5 * h, h / 2)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(0, (h - linesize) / 2, w - (1.5 * h), linesize)

                surface.SetTextColor(SolidBlack)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12_Glow")
                surface.DrawText(txt)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12")
                surface.DrawText(txt)

                if installed then
                    local atttbl = ArcCW.AttachmentTable[installed]

                    att_txt = translate("name." .. installed) or atttbl.PrintName

                    if atttbl.Icon then
                        att_icon = atttbl.Icon
                        if (!att_icon or att_icon:IsError()) then att_icon = bird end
                    end
                end

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap * 2, (h - linesize) / 2 + smallgap)
                surface.SetFont("ArcCW_12")
                DrawTextRot(span, att_txt, 0, h / 2, smallgap * 2, (h - linesize) / 2 + smallgap, w - 1.5 * h)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(w - (1.5 * h), 0, linesize, h)

                surface.SetDrawColor(Bfg_col)
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - (1.25 * h), 0, h, h)
            ----------------------------------------------------------------------
            elseif activeslot == span.AttIndex then
                span:SetSize(barsize, buttonsize)

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(0, 0, w, h / 2)
                surface.DrawRect(w - (1.5 * h), h / 2, 1.5 * h, h / 2)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(0, (h - linesize) / 2, w - (1.5 * h), linesize)

                surface.SetTextColor(SolidBlack)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12_Glow")
                surface.DrawText(txt)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12")
                surface.DrawText(txt)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap * 2, (h - linesize) / 2 + smallgap)
                surface.SetFont("ArcCW_12")

                DrawTextRot(span, att_txt, 0, h / 2, smallgap * 2, (h - linesize) / 2 + smallgap, w - 1.5 * h)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(w - (1.5 * h), 0, linesize, h)

                surface.SetDrawColor(Bfg_col)
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - (1.25 * h), 0, h, h)
            else
                if installed then
                    local atttbl = ArcCW.AttachmentTable[installed]
                    txt = att_txt

                    if atttbl.Health then
                        local perc = (self:GetAttachmentHP(i) / self:GetAttachmentMaxHP(i)) * 100
                        perc = math.Round(perc)
                        txt = txt .. " (" .. tostring(perc) .. "%)"
                    end
                end

                span:SetSize(barsize, buttonsize / 2)

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(w - (1.5 * h), 0, 1.5 * h, h)

                surface.SetTextColor(SolidBlack)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12_Glow")
                -- surface.DrawText(txt)
                DrawTextRot(span, txt, 0, 0, smallgap, 0, w - 1.5 * h)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12")
                DrawTextRot(span, txt, 0, 0, smallgap, 0, w - 1.5 * h, true)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(w - (1.5 * h), 0, linesize, h)

                surface.SetDrawColor(Bfg_col)
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - (1.25 * h), 0, h, h)
            end
        end
    end

    local sbar2 = triviabox:GetVBar()
    sbar2.Paint = function() end

    sbar2.btnUp.Paint = function(span, w, h)
    end

    sbar2.btnDown.Paint = function(span, w, h)
    end

    sbar2.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local triv_wpnnamelabel = vgui.Create("DLabel", triviabox)
    triv_wpnnamelabel:SetSize(barsize, buttonsize)
    triv_wpnnamelabel:Dock(TOP)
    triv_wpnnamelabel:DockMargin( 0, 0, 0, smallgap )
    triv_wpnnamelabel:SetText("")
    triv_wpnnamelabel.Paint = function(span, w, h)
        if !IsValid(self) then return end
        local txt = translate("name." .. self:GetClass()) or self.PrintName

        surface.SetFont("ArcCW_20")
        local tw, th = surface.GetTextSize(txt)

        surface.SetFont("ArcCW_20_Glow")
        surface.SetTextPos((w - tw) / 2, th / 2)
        surface.SetTextColor(SolidBlack)
        surface.DrawText(txt)

        surface.SetFont("ArcCW_20")
        surface.SetTextPos((w - tw) / 2, th / 2)
        surface.SetTextColor(fg_col)
        surface.DrawText(txt)
    end

    local year = self:GetBuff_Override("Override_Trivia_Year") or self.Trivia_Year

    if isnumber(year) and year < 0 then
        year = tostring(math.abs(year)) .. "BC"
    end

    year = tostring(year)

    local trivia = {
        function() return translate("trivia.class") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class) or "Unknown" end,
        function() return translate("trivia.year") .. ": " .. year or "Unknown" end,
        function() return translate("trivia.mechanism") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Mechanism") or self.Trivia_Mechanism or "Unknown") end,
        function() return translate("trivia.calibre") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre or "Unknown") end,
        function() return translate("trivia.ammo") .. ": " .. language.GetPhrase(self.Primary.Ammo or self.PrintName) end,
        function() return translate("trivia.country") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Country") or self.Trivia_Country or "Unknown") end,
        function() return translate("trivia.manufacturer") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Manufacturer") or self.Trivia_Manufacturer or "Unknown") end,
        function() return translate("trivia.clipsize") .. ": " .. self:GetCapacity() end,
        function() return translate("trivia.precision") .. ": " .. self:GetBuff("AccuracyMOA") .. " MOA" end,
        function() return translate("trivia.noise") .. ": " .. (self:GetBuff("ShootVol")) .. "dB" end,
        function() return translate("trivia.recoil") .. ": " .. math.Truncate(self.Recoil * 41.4 * self:GetBuff_Mult("Mult_Recoil"), 1) .. " lb-fps" end,
        function() return translate("trivia.penetration") .. ": " .. math.Round(self:GetBuff("Penetration"), 1) .. "mm" end,
    }

    if !self.ManualAction and !self:GetBuff_Override("Override_ManualAction") then
        table.insert(trivia, function()
            local rpm = math.Round(60 / self:GetFiringDelay())
            return translate("trivia.firerate") .. ": " .. rpm .. "RPM"
        end)
    end

    if !(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class) then
        trivia[1] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Year") or self.Trivia_Year) then
        trivia[2] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Mechanism") or self.Trivia_Mechanism) then
        trivia[3] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre) then
        trivia[4] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Country") or self.Trivia_Country) then
        trivia[6] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Manufacturer") or self.Trivia_Manufacturer) then
        trivia[7] = nil
    end

    if self.PrimaryBash then
        trivia[4] = nil
        trivia[5] = nil
        trivia[8] = nil
        trivia[9] = nil
        trivia[10] = nil
        trivia[11] = nil
        trivia[12] = nil
        trivia[13] = nil
    end

    if self.Throwing then
        trivia[4] = nil
        trivia[8] = nil
        trivia[9] = nil
        trivia[10] = nil
        trivia[11] = nil
        trivia[12] = nil
        trivia[13] = nil
    end

    local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime

    if ft then
        table.insert(trivia, function() return translate("trivia.fusetime") .. ": " .. tostring(ft) end)
    end

    for _, i in pairs(trivia) do
        if !i then continue end
        local triv_misc = vgui.Create("DLabel", triviabox)
        triv_misc:SetSize(barsize, ScreenScaleMulti(8))
        triv_misc:Dock(TOP)
        triv_misc:SetText("")
        triv_misc:DockMargin( 0, 0, 0, 0 )
        triv_misc.Paint = function(span, w, h)
            if !IsValid(self) then return end
            local txt = i()

            surface.SetFont("ArcCW_8")
            surface.SetTextPos(smallgap, 0)
            surface.SetTextColor(fg_col)
            surface.DrawText(txt)
        end
    end

    -- multlinetext(text, maxw, font)

    local adesctext = multlinetext(ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Desc")) or translate("desc." .. self:GetClass()) or self.Trivia_Desc, barsize - smallgap, "ArcCW_8")

    table.insert(adesctext, "")

    local triv_desc = vgui.Create("DLabel", triviabox)
    triv_desc:SetSize(barsize, ScreenScaleMulti(8) * (table.Count(adesctext) + 1))
    triv_desc:SetText("")
    triv_desc:Dock(TOP)
    triv_desc.Paint = function(span, w, h)
        local y = ScreenScaleMulti(8)
        for _, line in pairs(adesctext) do
            surface.SetFont("ArcCW_8")
            surface.SetTextPos(smallgap, y)
            surface.SetTextColor(fg_col)
            surface.DrawText(line)
            y = y + ScreenScaleMulti(8)
        end
    end

    if !self.ShootEntity and !self.PrimaryBash and !self.Throwing and !self.NoRangeGraph then
        local rangegraph = vgui.Create("DLabel", triviabox)
        rangegraph:SetSize(barsize, ScreenScaleMulti(64))
        rangegraph:SetText("")
        rangegraph:Dock(TOP)
        rangegraph.Paint = function(span, w, h)
            if !IsValid(self) then return end
            local sidegap = 0
            local gx, gy = 0, smallgap
            local gw, gh = w - (2 * sidegap), h - smallgap - ScreenScaleMulti(6)

            local dmgmax = math.Round(self:GetDamage(0))
            local dmgmin = math.Round(self:GetDamage(math.huge))

            local grsh = math.max(dmgmax, dmgmin)

            grsh = math.ceil((grsh / 12) + 1) * 12

            local mingr = self.RangeMin * self:GetBuff_Mult("Mult_Range") * self:GetBuff_Mult("Mult_RangeMin")
            local maxgr = self.Range * self:GetBuff_Mult("Mult_Range")

            if dmgmax < dmgmin then
                maxgr = (self.Range / self:GetBuff_Mult("Mult_Range"))
            end

            maxgr = math.Round(maxgr)

            local grsw = math.ceil((maxgr / 12) + 1) * 12

            local convw = gw / grsw
            local convh = gh / grsh

            local starty = gh - (dmgmax * convh)
            local endy = gh - (dmgmin * convh)
            local startx = mingr * convw
            local endx = maxgr * convw

            surface.SetDrawColor(bg_col)
            surface.DrawRect(gx, gy, gw, gh)

            surface.SetDrawColor(fg_col)

            -- start
            surface.DrawLine(0, gy + starty, gx + startx, gy + starty)
            -- before mid
            surface.DrawLine(gx + startx, gy + starty, gx + endx, gy + endy)
            if mingr != 0 then
                surface.DrawLine(gx + startx, gy+ScreenScaleMulti(2) + starty, gx + startx, gy-ScreenScaleMulti(2) + starty)
            end
            -- long and into the void
            surface.DrawLine(gx + endx, gy + endy, gx + gw, gy + endy)
            surface.DrawLine(gx + endx, gy+ScreenScaleMulti(2) + endy, gx + endx, gy-ScreenScaleMulti(2) + endy)

            -- start dmg
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            surface.SetTextPos(0, gy + starty - ScreenScaleMulti(7) - 1)
            surface.DrawText(tostring(dmgmax) .. "DMG")

            -- end dmg
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")

            local dtw = surface.GetTextSize(tostring(dmgmin) .. "DMG")
            surface.SetTextPos(gx + gw - dtw, gy + endy - ScreenScaleMulti(7) - 1)
            surface.DrawText(tostring(dmgmin) .. "DMG")

            -- start range
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            surface.SetTextPos(sidegap, smallgap + gh)
            surface.DrawText("0m")

            -- before mid range
            if mingr != 0 then
                surface.SetTextColor(fg_col)
                surface.SetFont("ArcCW_6")
                local btw = surface.GetTextSize(tostring(mingr) .. "m")
                surface.SetTextPos(gx + startx - (btw / 2), smallgap + gh)
                surface.DrawText(tostring(mingr) .. "m")
            end

            -- mid range
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            local mtw = surface.GetTextSize(tostring(maxgr) .. "m")
            surface.SetTextPos(gx + endx - (mtw / 2), smallgap + gh)
            surface.DrawText(tostring(maxgr) .. "m")

            -- end range
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            local rtw = surface.GetTextSize(tostring(grsw) .. "m")
            surface.SetTextPos(w - sidegap - rtw, smallgap + gh)
            surface.DrawText(tostring(grsw) .. "m")

            local mousex, mousey = span:CursorPos()

            if mousex > gx and mousex < (gx + gw) and
                    (mousey > gy and mousey < (gy + gh)) then
                local mouser = (mousex - gx) / convw

                local shy
                local shdmg

                if mouser < mingr then
                    shy = starty
                    shdmg = dmgmax
                elseif mouser < maxgr then
                    local delta = mouser / maxgr
                    shy = Lerp(delta, starty, endy)
                    shdmg = Lerp(delta, dmgmax, dmgmin)
                else
                    shy = endy
                    shdmg = dmgmin
                end

                surface.SetDrawColor(Color(fg_col.r, fg_col.g, fg_col.b, 150))
                surface.DrawLine(gx, gy + shy, gw, gy + shy)
                surface.DrawLine(mousex, gy, mousex, gh + gy)

                shy = shy + ScreenScaleMulti(4)

                mouser = math.Round(mouser)
                shdmg = math.Round(shdmg)

                local alignleft = true

                surface.SetFont("ArcCW_6")
                local twmr = surface.GetTextSize(tostring(mouser) .. "m")
                local twmb = surface.GetTextSize(tostring(shdmg) .. "DMG")

                if mousex < math.max(twmr, twmb) + ScreenScaleMulti(2) then
                    alignleft = false
                end

                surface.SetTextColor(fg_col)
                surface.SetFont("ArcCW_6")
                if alignleft then
                    surface.SetTextPos(mousex - ScreenScaleMulti(2) - twmr, shy)
                else
                    surface.SetTextPos(mousex + ScreenScaleMulti(2), shy)
                end
                surface.DrawText(tostring(mouser) .. "m")

                surface.SetTextColor(fg_col)
                surface.SetFont("ArcCW_6")
                if alignleft then
                    surface.SetTextPos(mousex - ScreenScaleMulti(2) - twmb, ScreenScaleMulti(2) + gy)
                else
                    surface.SetTextPos(mousex + ScreenScaleMulti(2), ScreenScaleMulti(2) + gy)
                end
                surface.DrawText(tostring(shdmg) .. "DMG")
            end
        end
    end

    local function defaultStatFunc(name, unit, round)
        local orig = self[name]
        if ArcCW.ConVar_BuffMults["Mult_" .. name] then
            orig = orig * GetConVar(ArcCW.ConVar_BuffMults["Mult_" .. name]):GetFloat()
        end
        return math.Round((unit == "%" and 100 or unit == "ms" and 1000 or 1) * orig, round) .. (unit or ""),
               math.Round((unit == "%" and 100 or unit == "ms" and 1000 or 1) * self[name] * self:GetBuff_Mult("Mult_" .. name), round) .. (unit or "")
    end

    local function defaultBetterFunc(name, inverse)
        local mult = self:GetBuff_Mult("Mult_" .. name)
        if ArcCW.ConVar_BuffMults[name] then
            mult = mult / GetConVar(ArcCW.ConVar_BuffMults[name]):GetFloat()
        end
        if inverse then mult = 1 / mult end
        if mult > 1 then return true
        elseif mult < 1 then return false
        else return nil end
    end

    local statList
    regenStatList = function()
        statList = {
            {translate("stat.stat"), "",
                function() return translate("stat.original"), translate("stat.current") end,
                function() return nil end,
            },
            {translate("stat.damage"), translate("stat.damage.tooltip"),
                function()
                    local curNum = self:GetBuff("Num")
                    local orig = math.Round(self.Damage * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (self.Num != 1 and ("×" .. self.Num) or "")
                    local cur = math.Round(self:GetDamage(0) / curNum * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (curNum != 1 and ("×" .. curNum) or "")
                    return orig, cur
                end,
                function()
                    local orig = self.Damage * self.Num * ArcCW.ConVars["mult_damage"]:GetFloat()
                    local cur = self:GetDamage(0)
                    if orig == cur then return nil else return cur > orig end
                end,
            },
            {translate("stat.damagemin"), translate("stat.damagemin.tooltip"),
                function()
                    local curNum = self:GetBuff("Num")
                    local orig = math.Round(self.DamageMin * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (self.Num != 1 and ("×" .. self.Num) or "")
                    local cur = math.Round(self:GetDamage(self.Range) / curNum * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (curNum != 1 and ("×" .. curNum) or "")
                    return orig, cur
                end,
                function()
                    local orig = self.DamageMin * self.Num * ArcCW.ConVars["mult_damage"]:GetFloat()
                    local maxgr = (self:GetBuff("Range"))
                    if math.Round(self:GetDamage(self.Range)) < math.Round(self:GetDamage(0)) then
                        maxgr = (self.Range / self:GetBuff_Mult("Mult_Range"))
                    end
                    local cur = self:GetDamage(maxgr)
                    if orig == cur then return nil else return cur > orig end
                end,
            },
            {translate("stat.range"), translate("stat.range.tooltip"),
                function() return defaultStatFunc("Range", "m") end,
                function() return defaultBetterFunc("Range") end,
            },
            {translate("stat.firerate"), translate("stat.firerate.tooltip"),
                function()

                local orig = math.Round(60 / self.Delay) .. "RPM"
                local cur = math.Round(60 / self:GetFiringDelay()) .. "RPM"

                if self.ManualAction then
                    orig = translate("stat.firerate.manual")
                end
                if self:GetBuff_Override("Override_ManualAction") or self.ManualAction then
                    cur = translate("stat.firerate.manual")
                end

                return orig, cur
                end,
                function()
                    if !self:GetBuff_Override("Override_ManualAction") and !self.ManualAction then
                        return defaultBetterFunc("RPM")
                    end
                    -- Funky calculations for when some manual gun goes automatic
                    if !self.ManualAction and self:GetBuff_Override("Override_ManualAction") == true then
                        return false
                    elseif self.ManualAction and self:GetBuff_Override("Override_ManualAction") == false then
                        return true
                    end
                    return nil
                end,
            },
            {translate("stat.capacity"), translate("stat.capacity.tooltip"),
                function()
                    local m = self.RegularClipSize
                    local m2 = self.Primary.ClipSize
                    local cs = self.ChamberSize
                    local cs2 = self:GetChamberSize()
                    return m .. (cs > 0 and " +" .. cs or ""), m2 .. (cs2 > 0 and " +" .. cs2 or "")
                end,
                function()
                    local m = self.RegularClipSize
                    local m2 = self.Primary.ClipSize
                    local cs = self.ChamberSize
                    local cs2 = self:GetChamberSize()
                    if m + cs == m2 + cs2 then return nil end
                    return m + cs < m2 + cs2
                end,
            },
            {translate("stat.precision"), translate("stat.precision.tooltip"),
                function() return defaultStatFunc("AccuracyMOA", " MOA", 3) end,
                function() return defaultBetterFunc("AccuracyMOA", true) end,
            },
            {translate("stat.hipdisp"), translate("stat.hipdisp.tooltip"),
                function() return defaultStatFunc("HipDispersion", " MOA") end,
                function() return defaultBetterFunc("HipDispersion", true) end,
            },
            {translate("stat.movedisp"), translate("stat.movedisp.tooltip"),
                function() return defaultStatFunc("MoveDispersion", " MOA") end,
                function() return defaultBetterFunc("MoveDispersion", true) end,
            },
            {translate("stat.recoil"), translate("stat.recoil.tooltip"),
                function() return defaultStatFunc("Recoil", nil, 2) end,
                function() return defaultBetterFunc("Recoil", true) end,
            },
            {translate("stat.recoilside"), translate("stat.recoilside.tooltip"),
                function() return defaultStatFunc("RecoilSide", nil, 2) end,
                function() return defaultBetterFunc("RecoilSide", true) end,
            },
            {translate("stat.sighttime"), translate("stat.sighttime.tooltip"),
                function() return defaultStatFunc("SightTime", "ms") end,
                function() return defaultBetterFunc("SightTime", true) end,
            },
            {translate("stat.speedmult"), translate("stat.speedmult.tooltip"),
                function()
                    return math.Round(self.SpeedMult * 100) .. "%", math.Round(math.Clamp(self:GetBuff("SpeedMult") * self:GetBuff_Mult("Mult_MoveSpeed"), 0, 1) * 100) .. "%"
                end,
                function()
                    local mult = self:GetBuff_Mult("Mult_SpeedMult") * self:GetBuff_Mult("Mult_MoveSpeed")
                    if mult == 1 then return nil
                    elseif mult > 1 then return true
                    else return false end
                end,
            },
            {translate("stat.sightspeed"), translate("stat.sightspeed.tooltip"),
                function()
                    return math.Round(self.SightedSpeedMult * 100) .. "%", math.Round(math.Clamp(self:GetBuff("SightedSpeedMult") * self:GetBuff_Mult("Mult_SightedMoveSpeed"), 0, 1) * 100) .. "%"
                end,
                function()
                    local mult = self:GetBuff_Mult("Mult_SightedSpeedMult") * self:GetBuff_Mult("Mult_SightedMoveSpeed")
                    if mult == 1 then return nil
                    elseif mult > 1 then return true
                    else return false end
                end,
            },
            {translate("stat.meleedamage"), translate("stat.meleedamage.tooltip"),
                function() return defaultStatFunc("MeleeDamage") end,
                function() return defaultBetterFunc("MeleeDamage") end,
            },
            {translate("stat.meleetime"), translate("stat.meleetime.tooltip"),
                function() return defaultStatFunc("MeleeTime", "ms", 2) end,
                function() return defaultBetterFunc("MeleeTime", true) end,
            },
            {translate("stat.shootvol"), translate("stat.shootvol.tooltip"),
                function() return defaultStatFunc("ShootVol","dB") end,
                function() return defaultBetterFunc("ShootVol", true) end,
            },
            {translate("stat.barrellen"), translate("stat.barrellen.tooltip"),
                function()
                    local orig = self.BarrelLength
                    local cur = orig + self:GetBuff_Add("Add_BarrelLength")
                    return orig .. "in", cur .. "in"
                end,
                function()
                    local add = self:GetBuff_Add("Add_BarrelLength")
                    if add == 0 then return nil else return add < 0 end
                end,
            },
            {translate("stat.pen"), translate("stat.pen.tooltip"),
                function() return defaultStatFunc("Penetration","mm") end,
                function() return defaultBetterFunc("Penetration") end,
            },
        }

        statbox:Clear()

        for _, i in pairs(statList) do
            if !i then continue end
            local stat_panel = vgui.Create("DPanel", statbox)
            stat_panel:SetSize(barsize, ScreenScaleMulti(10))
            stat_panel:Dock(TOP)
            stat_panel:SetText("")
            stat_panel:DockMargin( 0, ScreenScaleMulti(1), 0, ScreenScaleMulti(1) )
            stat_panel.Paint = function(spaa, w, h)
                local Bbg_col = Color(0, 0, 0, 50)

                if spaa:IsHovered() then
                    Bbg_col = Color(100, 100, 100, 50)
                end

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
            end

            local stat_title = vgui.Create("DLabel", stat_panel)
            stat_title:SetSize(barsize * 0.5, ScreenScaleMulti(10))
            stat_title:SetText("")
            stat_title:Dock(LEFT)
            stat_title.Paint = function(span, w, h)
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.SetTextColor(fg_col)
                surface.DrawText(i[1])
            end

            local origStat, curStat = i[3]()
            local better = i[4]()
            local stat_orig = vgui.Create("DLabel", stat_panel)
            stat_orig:SetSize(barsize * 0.25, ScreenScaleMulti(10))
            stat_orig:SetText("")
            stat_orig:Dock(LEFT)
            stat_orig.Paint = function(span, w, h)
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.SetTextColor(fg_col)
                surface.DrawText(origStat)
            end
            local stat_cur = vgui.Create("DLabel", stat_panel)
            stat_cur:SetSize(barsize * 0.25, ScreenScaleMulti(10))
            stat_cur:SetText("")
            stat_cur:Dock(LEFT)
            stat_cur.Paint = function(span, w, h)
                local color = better == true and Color(150, 255, 150) or better == false and Color(255, 150, 150) or fg_col

                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.SetTextColor(color)
                surface.DrawText(curStat)
            end
        end
    end

    if !self.Throwing and !self.PrimaryBash and !self.ShootEntity then
        local togglestat = vgui.Create("DButton", ArcCW.InvHUD)
        togglestat:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
        togglestat:SetText("")
        togglestat:SetPos(scrw - barsize - airgap - ScreenScaleMulti(1) - (barsize / 2), airgap)

        togglestat.OnMousePressed = function(spaa, kc)
            if statbox:IsVisible() then
                statbox:Hide()
                triviabox:Show()
            else
                regenStatList()
                statbox:Show()
                triviabox:Hide()
                attmenu:Hide()
                self.InAttMenu = false
                atttrivia:Hide()
                attslidebox:Hide()
                atttogglebtn:Hide()
            end
        end

        togglestat.Paint = function(spaa, w, h)
            if !self:IsValid() then return end
            if !self.Attachments then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local txt = translate(statbox:IsVisible() and "ui.trivia" or "ui.stats")

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(smallgap, ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)
        end
    end

    if engine.ActiveGamemode() == "terrortown" then
        local gap = airgap

        if GetRoundState() == ROUND_ACTIVE and (LocalPlayer():GetTraitor() or LocalPlayer():GetDetective() or (TTT2 and LocalPlayer().IsShopper and LocalPlayer():IsShopper())) then
            local buymenu = vgui.Create("DButton", ArcCW.InvHUD)
            buymenu:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
            buymenu:SetText("")
            buymenu:SetPos(scrw - barsize - airgap - ScreenScaleMulti(1) - (barsize / 2), airgap + gap)
            gap = gap + airgap

            buymenu.OnMousePressed = function(spaa, kc)
                RunConsoleCommand("ttt_cl_traitorpopup")
            end

            buymenu.Paint = function(spaa, w, h)
                if !self:IsValid() then return end
                if !self.Attachments then return end
                local Bfg_col = Color(255, 255, 255, 255)
                local Bbg_col = Color(0, 0, 0, 100)

                if spaa:IsHovered() then
                    Bbg_col = Color(255, 255, 255, 100)
                    Bfg_col = Color(0, 0, 0, 255)
                end

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)

                local txt = translate("ui.tttequip")

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, ScreenScaleMulti(1))
                surface.SetFont("ArcCW_12")
                surface.DrawText(txt)
            end
        end

        local radiomenu = vgui.Create("DButton", ArcCW.InvHUD)
        radiomenu:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
        radiomenu:SetText("")
        radiomenu:SetPos(scrw - barsize - airgap - ScreenScaleMulti(1) - (barsize / 2), airgap + gap)

        radiomenu.OnMousePressed = function(spaa, kc)
            RADIO:ShowRadioCommands(!RADIO.Show)
        end

        radiomenu.Paint = function(spaa, w, h)
            if !self:IsValid() then return end
            if !self.Attachments then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local txt = translate("ui.tttchat")

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(smallgap, ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)
        end
    end

    if CLIENT and vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        local w, h = ArcCW.InvHUD:GetSize()
        local ang = Angle(0,g_VR.tracking.hmd.ang.yaw-90,45)
        local pos = g_VR.tracking.hmd.pos + Vector(0,0,-20) + Angle(0,g_VR.tracking.hmd.ang.yaw,0):Forward() * 30 + ang:Forward() * w * -0.02 + ang:Right() * h * -0.02
        pos, ang = WorldToLocal(pos, ang, g_VR.origin, g_VR.originAngle)
        vrmod.MenuCreate( "ArcCW_Customize", w, h, ArcCW.InvHUD, 4,
                pos, ang, 0.04, true, function()
            self:CloseCustomizeHUD()
        end)
    end

end

end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_model.lua:
function SWEP:KillModels()
    self:KillModel(self.WM)
    self.WM = nil
    self:KillModel(self.VM)
    self.VM = nil
end

function SWEP:AddElement(elementname, wm)
    local e = self.AttachmentElements[elementname]

    if !e then return end
    if !wm and self:GetOwner():IsNPC() then return end

    if !self:CheckFlags(e.ExcludeFlags, e.RequireFlags) then return end

    if ArcCW.ConVars["truenames"]:GetBool() and e.TrueNameChange then
        self.PrintName = e.TrueNameChange
    elseif ArcCW.ConVars["truenames"]:GetBool() and e.NameChange then
        self.PrintName = e.NameChange
    end

    if !ArcCW.ConVars["truenames"]:GetBool() and e.NameChange then
        self.PrintName = e.NameChange
    elseif !ArcCW.ConVars["truenames"]:GetBool() and e.TrueNameChange then
        self.PrintName = e.TrueNameChange
    end

    if e.AddPrefix then
        self.PrintName = e.AddPrefix .. self.PrintName
    end

    if e.AddSuffix then
        self.PrintName = self.PrintName .. e.AddSuffix
    end

    local og_weapon = weapons.GetStored(self:GetClass())

    local og_vm = og_weapon.ViewModel
    local og_wm = og_weapon.WorldModel

    self.ViewModel = og_vm
    self.WorldModel = og_wm

    local parent = self
    local elements = self.WM

    if !wm then
        parent = self:GetOwner():GetViewModel()
        elements = self.VM
    end

    local eles = e.VMElements

    if wm then
        eles = e.WMElements

        if self.MirrorVMWM then
            self.WorldModel = e.VMOverride or self.WorldModel
            self:SetSkin(e.VMSkin or self.DefaultSkin)
            eles = e.VMElements
        else
            self.WorldModel = e.WMOverride or self.WorldModel
            self:SetSkin(e.WMSkin or self.DefaultWMSkin)
        end
    else
        self.ViewModel = e.VMOverride or self.ViewModel
        self:GetOwner():GetViewModel():SetSkin(e.VMSkin or self.DefaultSkin)
    end

    if SERVER then return end

    for _, i in pairs(eles or {}) do
        local model = ClientsideModel(i.Model)

        if !model or !IsValid(model) or !IsValid(self) then continue end

        if i.BoneMerge then
            model:SetParent(parent)
            model:AddEffects(EF_BONEMERGE)
        else
            model:SetParent(self)
        end

        local element = {}

        local scale = Matrix()
        scale:Scale(i.Scale or Vector(1, 1, 1))

        model:SetNoDraw(ArcCW.NoDraw)
        model:DrawShadow(false)
        model.Weapon = self
        model:SetSkin(i.ModelSkin or 0)
        --model:SetBodyGroups(i.ModelBodygroups or "")
        ArcCW.SetBodyGroups(model, i.ModelBodygroups or "")
        model:EnableMatrix("RenderMultiply", scale)
        model:SetupBones()
        element.Model = model
        element.DrawFunc = i.DrawFunc
        element.WM = wm or false
        element.Bone = i.Bone
        element.NoDraw = i.NoDraw or false
        element.BoneMerge = i.BoneMerge or false
        element.Bodygroups = i.ModelBodygroups
        element.DrawFunc = i.DrawFunc
        element.OffsetAng = Angle()
        element.OffsetAng:Set(i.Offset.ang or Angle(0, 0, 0))
        element.OffsetPos = Vector()
        element.OffsetPos:Set(i.Offset.pos or Vector(), 0, 0)
        element.IsMuzzleDevice = i.IsMuzzleDevice

        if self.MirrorVMWM then
            element.WMBone = i.Bone
        else
            element.WMBone = i.WMBone
        end

        table.insert(elements, element)
    end

end

local function ScaleModel(model, vscale)
    if !model then return end
    local scale = Matrix()
    scale:Scale(vscale)
    model:EnableMatrix("RenderMultiply", scale)
end

function SWEP:SetupModel(wm)
    local elements = {}

    if !wm and !self:GetOwner():IsPlayer() then return end
    local owner = self:GetOwner()

    local og = weapons.Get(self:GetClass())

    self.PrintName = self.OldPrintName or og.PrintName
    local prefix, suffix = "", ""

    self:GetActiveElements(true)

    if !wm then
        local vm = owner:GetViewModel()

        vm.RenderOverride = function(v)
            if !self or !self.ArcCW then v.RenderOverride = nil return end
            local wep = LocalPlayer():GetActiveWeapon()
            if wep and !wep.ArcCW then v.RenderOverride = nil return end
            self:RefreshBGs()

            for i, k in pairs(self:GetBuff_Override("Override_CaseBGs", self.CaseBGs) or {}) do
                if !isnumber(i) then continue end
                local bone = vm:LookupBone(k)

                if !bone then continue end

                if self:GetVisualClip() >= i then
                    vm:SetBodygroup(k.ind, k.bg)
                else
                    vm:SetBodygroup(k.ind, 0)
                end
            end

            for i, k in pairs(self:GetBuff_Override("Override_BulletBGs", self.BulletBGs) or {}) do
                if !isnumber(i) then continue end
                local bone = vm:LookupBone(k)

                if !bone then continue end

                if self:GetVisualBullets() >= i then
                    vm:SetBodygroup(k.ind, k.bg)
                else
                    vm:SetBodygroup(k.ind, 0)
                end
            end

            for i, k in pairs(self:GetBuff_Override("Override_StripperClipBGs", self.StripperClipBGs) or {}) do
                if !isnumber(i) then continue end
                local bone = vm:LookupBone(k)

                if !bone then continue end

                if self:GetVisualLoadAmount() >= i then
                    vm:SetBodygroup(k.ind, k.bg)
                else
                    vm:SetBodygroup(k.ind, 0)
                end
            end

            if !self.HideViewmodel then
                ArcCW.VM_OverDraw = true
                v:DrawModel()
                ArcCW.VM_OverDraw = false
            end
        end
    end

    if CLIENT then

    if wm then
        self:KillModel(self.WM)
        self.WM = elements
    else
        self:KillModel(self.VM)
        self.VM = elements

        if !IsValid(owner) or owner:IsNPC() then
            return
        end

        if !IsValid(owner:GetViewModel()) then
            self:SetTimer(0.5, function()
                self:SetupModel(wm)
            end)
            return
        end

        owner:GetViewModel():SetupBones()
    end

    render.OverrideDepthEnable( true, true )

    end

    local vscale = Vector(1, 1, 1)

    -- if !wm and CLIENT then
    --     local sm = self.ViewModel

    --     local model = ClientsideModel(sm)

    --     if !model then return end
    --     if !IsValid(model) then return end

    --     model:SetNoDraw(ArcCW.NoDraw)
    --     model:DrawShadow(true)
    --     model:SetPredictable(false)
    --     model.Weapon = self
    --     model:SetSkin(self.DefaultVMSkin or 0)
    --     model:SetBodyGroups(self.DefaultVMBodygroups or "")
    --     model:SetupBones()
    --     local element = {}
    --     element.Model = model

    --     model:SetParent(self:GetOwner():GetViewModel())
    --     model:AddEffects(EF_BONEMERGE)
    --     element.BoneMerge = true
    --     element.IsBaseVM = true

    --     self.VMModel = model

    --     table.insert(elements, element)
    -- end

    if wm and CLIENT then
        local sm = self.WorldModel
        if self.MirrorVMWM then
            sm = self.MirrorWorldModel or self.ViewModel
        end
        local vs = (self.WorldModelOffset or {}).scale or 1
        vscale = Vector(vs, vs, vs)
        local model = ClientsideModel(sm)

        if !model then return end
        if !IsValid(model) then return end

        model:SetNoDraw(ArcCW.NoDraw)
        model:DrawShadow(false)
        model:SetPredictable(false)
        model.Weapon = self
        model:SetSkin(self.DefaultWMSkin or 0)
        --model:SetBodyGroups(self.DefaultWMBodygroups or "")
        ArcCW.SetBodyGroups(model, self.DefaultWMBodygroups or "")
        ScaleModel(model, vscale)
        model:SetupBones()
        local element = {}
        element.Model = model
        element.WM = true
        element.IsBaseWM = true
        element.WMBone = "ValveBiped.Bip01_R_Hand"

        if self.WorldModelOffset then
            if !IsValid(owner) then
                element.OffsetAng = Angle(0, 0, 0)
                element.OffsetPos = Vector(0, 0, 0)
            else
                element.OffsetAng = self.WorldModelOffset.ang or Angle(0, 0, 0)
                element.OffsetPos = self.WorldModelOffset.pos or Vector(0, 0, 0)
                element.WMBone = self.WorldModelOffset.bone or element.WMBone
            end
            element.BoneMerge = false
        else
            model:SetParent(owner or self)
            model:AddEffects(EF_BONEMERGE)
            element.BoneMerge = true
            element.OffsetAng = Angle(0, 0, 0)
        end

        self.WMModel = model

        table.insert(elements, element)
    end

    for _, k in pairs(self:GetActiveElements()) do
        self:AddElement(k, wm)
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local atttbl = ArcCW.AttachmentTable[k.Installed]

        local slots = atttbl.Slot

        if isstring(slots) then
            slots = {slots}
        end

        for _, ele in pairs(slots) do
            self:AddElement(ele, wm)
        end

        if atttbl.AddPrefix then
            -- self.PrintName = atttbl.AddPrefix .. self.PrintName
            prefix = atttbl.AddPrefix .. prefix
        end

        if atttbl.AddSuffix then
            -- self.PrintName = self.PrintName .. atttbl.AddSuffix
            suffix = suffix .. atttbl.AddSuffix
        end

        if CLIENT and !ArcCW.ConVars["att_showothers"]:GetBool() and LocalPlayer() != owner then
            continue
        end

        if SERVER then continue end

        if wm and k.NoWM then continue end
        if !wm and k.NoVM then continue end

        if !atttbl.Model then continue end
        if atttbl.HideModel then continue end

        if !k.Offset and !atttbl.BoneMerge then continue end

        local model = ClientsideModel(atttbl.Model)

        if !model or !IsValid(model) then continue end

        if atttbl.BoneMerge then
            local parent = owner:GetViewModel()

            if wm then
                parent = owner
            end

            model:SetParent(parent)
            model:AddEffects(EF_BONEMERGE)
        else
            model:SetParent(self)
        end

        local repbone = nil
        local repang = nil

        for _, e in pairs(self:GetActiveElements()) do
            local ele = self.AttachmentElements[e]

            if !ele then continue end

            if ((ele.AttPosMods or {})[i] or {}).bone then
                repbone = ele.AttPosMods[i].bone
            end

            if wm then
                if ((ele.AttPosMods or {})[i] or {}).wang then
                    repang = ele.AttPosMods[i].wang
                end
            else
                if ((ele.AttPosMods or {})[i] or {}).vang then
                    repang = ele.AttPosMods[i].vang
                end
            end
        end

        local element = {}

        local scale

        if wm then
            scale = (k.WMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1)
        else
            scale = (k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1)
        end

        scale = scale * vscale

        model:SetNoDraw(ArcCW.NoDraw)
        model:DrawShadow(false)
        model:SetPredictable(false)
        model.Weapon = self
        model:SetSkin(self:GetBuff_Stat("ModelSkin", i) or 0)
        model:SetBodyGroups(self:GetBuff_Stat("ModelBodygroups", i) or "")
        model:SetupBones()
        ScaleModel(model, scale)
        element.Model = model
        element.DrawFunc = atttbl.DrawFunc
        element.WM = wm or false
        element.Bone = repbone or k.Bone
        element.NoDraw = atttbl.NoDraw or false
        element.BoneMerge = k.BoneMerge or false
        element.Bodygroups = self:GetBuff_Stat("ModelBodygroups", i)
        element.DrawFunc = atttbl.DrawFunc
        element.Slot = i
        element.ModelOffset = self:GetBuff_Stat("ModelOffset", i) or Vector(0, 0, 0)

        if wm then
            element.OffsetAng = Angle()
            element.OffsetAng:Set(repang or k.Offset.wang or Angle(0, 0, 0))
            element.OffsetAng = element.OffsetAng + (atttbl.OffsetAng or Angle(0, 0, 0))
            k.WElement = element

            if self.MirrorVMWM then
                element.WMBone = repbone or k.Bone
                element.OffsetAng = Angle()
                element.OffsetAng:Set(repang or k.Offset.vang or Angle(0, 0, 0))
                element.OffsetAng = element.OffsetAng + (atttbl.OffsetAng or Angle(0, 0, 0))
            else
                element.WMBone = k.WMBone or "ValveBiped.Bip01_R_Hand"
            end
        else
            element.OffsetAng = Angle()
            element.OffsetAng:Set(repang or k.Offset.vang or Angle(0, 0, 0))
            element.OffsetAng = element.OffsetAng + (atttbl.OffsetAng or Angle(0, 0, 0))
            k.VMOffsetAng = element.OffsetAng
            k.VElement = element
        end

        table.insert(elements, element)

        if atttbl.Charm and atttbl.CharmModel then
            local charmmodel = ClientsideModel(atttbl.CharmModel)

            local charmscale = vscale

            if wm then
                if self.MirrorVMWM then
                    charmscale = charmscale * ((k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                else
                    charmscale = charmscale * ((k.WMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                end
            else
                charmscale = charmscale * ((k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
            end

            charmscale = charmscale * (atttbl.CharmScale or Vector(1, 1, 1))

            if IsValid(charmmodel) then
                charmmodel:SetNoDraw(ArcCW.NoDraw)
                charmmodel:DrawShadow(false)
                charmmodel:SetupBones()
                ScaleModel(charmmodel, charmscale)
                charmmodel:SetSkin(atttbl.CharmSkin or 0)
                charmmodel:SetBodyGroups(atttbl.CharmBodygroups or "")

                local charmelement = {}
                charmelement.Model = charmmodel
                charmelement.CharmOffset = atttbl.CharmOffset or Vector(0, 0, 0)
                charmelement.CharmAngle = atttbl.CharmAngle or Angle(0, 0, 0)
                charmelement.CharmAtt = atttbl.CharmAtt or "charm"
                charmelement.CharmParent = element
                charmelement.SubModel = true

                if wm then
                    if self.MirrorVMWM then
                        charmelement.CharmScale = ((k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                    else
                        charmelement.CharmScale = ((k.WMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                    end
                else
                    charmelement.CharmScale = ((k.VMScale or Vector(1, 1, 1)) * (atttbl.ModelScale or 1))
                end

                table.insert(elements, charmelement)
            end
        end

        if atttbl.IsMuzzleDevice or atttbl.UBGL then
            local hspmodel = ClientsideModel(atttbl.Model)

            if k.BoneMerge then
                local parent = owner:GetViewModel()

                if wm then
                    parent = owner
                end

                hspmodel:SetParent(parent)
                hspmodel:AddEffects(EF_BONEMERGE)
            else
                hspmodel:SetParent(self)
            end

            local hspelement = {}
            hspmodel:SetNoDraw(true)
            hspmodel:DrawShadow(false)
            hspmodel:SetPredictable(false)
            hspmodel.Weapon = self

            hspelement.Model = hspmodel
            ScaleModel(charmmodel, scale)

            hspelement.WM = wm or false
            hspelement.Bone = repbone or k.Bone
            hspelement.NoDraw = true
            hspelement.BoneMerge = k.BoneMerge or false
            hspelement.Slot = i
            hspelement.WMBone = k.WMBone

            hspelement.OffsetAng = element.OffsetAng

            if atttbl.IsMuzzleDevice then
                hspelement.IsMuzzleDevice = true
            end

            if wm then
                k.WMuzzleDeviceElement = hspelement

                if self.MirrorVMWM then
                    hspelement.WMBone = k.Bone
                end
            else
                k.VMuzzleDeviceElement = hspelement
            end

            table.insert(elements, hspelement)
        else
            k.VMuzzleDeviceElement = nil
            k.WMuzzleDeviceElement = nil
        end

        if atttbl.HolosightPiece then
            local hspmodel = ClientsideModel(atttbl.HolosightPiece)

            if k.BoneMerge then
                local parent = owner:GetViewModel()

                if wm then
                    parent = owner
                end

                hspmodel:SetParent(parent)
                hspmodel:AddEffects(EF_BONEMERGE)
            else
                hspmodel:SetParent(self)
            end

            local hspelement = {}
            hspmodel:SetNoDraw(true)
            hspmodel:DrawShadow(false)
            hspmodel:SetPredictable(false)
            ScaleModel(hspmodel, scale)
            hspmodel.Weapon = self

            hspelement.Model = hspmodel

            hspelement.WM = wm or false
            hspelement.Bone = repbone or k.Bone
            hspelement.NoDraw = atttbl.NoDraw or false
            hspelement.BoneMerge = k.BoneMerge or false
            hspelement.Slot = i
            hspelement.WMBone = k.WMBone

            hspelement.ModelOffset = atttbl.HolosightModelOffset or atttbl.ModelOffset
            hspelement.OffsetAng = element.OffsetAng

            if !wm then
                k.HSPElement = hspelement
            else
                if self.MirrorVMWM then
                    hspelement.WMBone = k.Bone
                end
            end

            table.insert(elements, hspelement)
        else
            k.HSPElement = nil
        end

        -- These shouldn't be created in WM.
        -- These shouldn't be created in WM.
        -- BUT THEY ARE!!
        if atttbl.LHIK_GunDriver or atttbl.LHIK_CamDriver then
            local godmodel = ClientsideModel(atttbl.Model)

            local godelement = {}
            godmodel:SetNoDraw(true)
            godmodel:DrawShadow(false)
            godmodel:SetPredictable(false)
            godmodel.Weapon = self

            godelement.Model = godmodel

            godelement.WM = wm or false
            godelement.NoDraw = true
            godelement.BoneMerge = false
            godelement.Slot = i
            if !wm then
                -- godmodel:SetNoDraw(false)
                k.GodDriver = godelement
            end
            table.insert(elements, godelement)
        end

        if atttbl.LHIK_GunDriver then
            local reflectmodel = ClientsideModel(self.ViewModel)

            local reflectelement = {}
            reflectmodel:SetNoDraw(true)
            reflectmodel:DrawShadow(false)
            reflectmodel:SetPredictable(false)
            reflectmodel.Weapon = self

            reflectelement.Model = reflectmodel

            reflectelement.WM = wm or false
            reflectelement.NoDraw = true
            reflectelement.Slot = i
            if !wm then
                -- reflectmodel:SetNoDraw(false)
                k.ReflectDriver = reflectelement
            end
            table.insert(elements, reflectelement)
        end
    end

    if CLIENT then

    if !wm and self.HolosightPiece then
        local hspmodel = ClientsideModel(self.HolosightPiece)

        hspmodel:SetParent(parent)
        hspmodel:AddEffects(EF_BONEMERGE)

        local hspelement = {}
        hspmodel:SetNoDraw(true)
        hspmodel:DrawShadow(false)
        hspmodel:SetPredictable(false)
        hspmodel.Weapon = self

        hspelement.Model = hspmodel

        hspelement.WM = wm or false
        hspelement.BoneMerge = true
        hspelement.NoDraw = false

        if !wm then
            self.HSPElement = hspelement
        end

        table.insert(elements, hspelement)
    end

    local eid = self:EntIndex()

    for i, k in pairs(elements) do
        local piletab = {
            Model = k.Model,
            Weapon = self
        }

        table.insert(ArcCW.CSModelPile, piletab)
    end

    if !ArcCW.CSModels[eid] then
        ArcCW.CSModels[eid] = {
            Weapon = self
        }
    end

    if wm then
        self.WM = elements
        self:KillModel(ArcCW.CSModels[eid].WModels)
        ArcCW.CSModels[eid].WModels = elements
    else
        self.VM = elements
        self:KillModel(ArcCW.CSModels[eid].VModels)
        ArcCW.CSModels[eid].VModels = elements
    end

    render.OverrideDepthEnable( false, true )

    if !wm then
    --     self:CreateFlashlightsWM()
    -- else
        self:CreateFlashlightsVM()
    end

    end

    self.PrintName = prefix .. (self:GetBuff_Hook("Hook_NameChange", self.PrintName) or self.PrintName) .. suffix
    self.Trivia_Class = self:GetBuff_Hook("Hook_ClassChange", self.Trivia_Class) or self.Trivia_Class
    self.Trivia_Desc = self:GetBuff_Hook("Hook_DescChange", self.Trivia_Desc) or self.Trivia_Desc

    self:SetupActiveSights()

    self:RefreshBGs()
end

function SWEP:KillModel(models)
    if !models then return end
    if table.IsEmpty(models) then return end

    for _, i in pairs(models) do
        if !isentity(i.Model) then continue end
        SafeRemoveEntity(i.Model)
    end
end

function SWEP:DrawCustomModel(wm, origin, angle)
    if ArcCW.VM_OverDraw then return end
    local owner = self:GetOwner()
    local disttoeye = self:GetPos():DistToSqr(EyePos())
    local visibility = math.pow(ArcCW.ConVars["visibility"]:GetInt(), 2)
    local always = false
    if ArcCW.ConVars["visibility"]:GetInt() < 0 or self:GetOwner() == LocalPlayer() then
        always = true
    end
    local models = self.VM
    local vm

    if origin and !angle then
        angle = Angle()
    end
    local custompos = origin and angle
    if custompos then
        wm = true --VM drawing borked
    end

    -- self:KillModel(self.VM)
    -- self:KillModel(self.WM)
    -- self.VM = nil
    -- self.WM = nil

    local vscale = 1

    if wm then
        if !always and disttoeye >= visibility * 2 then return end

        if !self.WM then
            self:SetupModel(wm)
        end

        models = self.WM

        vm = owner

        if self.MirrorVMWM or !IsValid(owner) then
            vm = self.WMModel or self
        end

        if self.WorldModelOffset then
            vscale = self.WorldModelOffset.scale or 1
        end

        if !vm or !IsValid(vm) then return end
    else
        if !self.VM then
            self:SetupModel(wm)
        end

        vm = owner:GetViewModel()

        if !vm or !IsValid(vm) then return end

        models = self.VM

        -- if self.HSPElement then
        --     self.HSPElement.Model:DrawModel()
        -- end
    end

    for i, k in pairs(models) do
        if !IsValid(k.Model) then
            self:SetupModel(wm)
            return
        end

        -- local asight = self:GetActiveSights()

        -- if asight then
        --     local activeslot = asight.Slot
        --     if k.Slot == activeslot and ArcCW.Overdraw then
        --         continue
        --     end
        -- end

        if k.IsBaseVM and !custompos then
            k.Model:SetParent(owner:GetViewModel())
            vm = self
            selfmode = true
            basewm = true
        elseif k.IsBaseWM then
            if IsValid(owner) and !custompos then
                local wmo = self.WorldModelOffset
                if !wmo then
                    wmo = {pos = Vector(0, 0, 0), ang = Angle(0, 0, 0)}
                end
                k.Model:SetParent(owner)
                vm = owner
                k.OffsetAng = wmo.ang
                k.OffsetPos = wmo.pos
            else
                k.Model:SetParent(self)
                vm = self
                selfmode = true
                basewm = true
                k.OffsetAng = Angle(0, 0, 0)
                k.OffsetPos = Vector(0, 0, 0)
            end
        elseif wm and self:ShouldCheapWorldModel() then
            continue
        else
            if wm and self.MirrorVMWM then
                vm = self.WMModel or self
                -- vm = self
            end

            if wm and !always and disttoeye >= visibility then
                continue
            end
        end

        if k.BoneMerge and !k.NoDraw then
            k.Model:DrawModel()
            continue
        end

        local bonename = k.Bone

        if wm then
            bonename = k.WMBone or "ValveBiped.Bip01_R_Hand"
        end

        local bpos, bang
        local offset = k.OffsetPos

        if k.IsBaseWM and !IsValid(self:GetOwner()) then
            bpos = self:GetPos()
            bang = self:GetAngles()
        elseif bonename then
            local boneindex = vm:LookupBone(bonename)

            if !boneindex then continue end

            if wm then
                bpos, bang = vm:GetBonePosition(boneindex)
            else
                local bonemat = vm:GetBoneMatrix(boneindex)

                if bonemat then
                    bpos = bonemat:GetTranslation()
                    bang = bonemat:GetAngles()
                end
            end

            if custompos and (!self.MirrorVMWM or (self.MirrorVMWM and k.Model:GetModel() == self.ViewModel) ) then
                bpos = origin
                bang = angle
            end

            if k.Slot then

                local attslot = self.Attachments[k.Slot]

                local delta = attslot.SlidePos or 0.5

                local vmelemod = nil
                local wmelemod = nil
                local slidemod = nil

                for _, e in pairs(self:GetActiveElements(true)) do
                    local ele = self.AttachmentElements[e]

                    if !ele then continue end

                    if ((ele.AttPosMods or {})[k.Slot] or {}).vpos then
                        vmelemod = ele.AttPosMods[k.Slot].vpos
                        if self.MirrorVMWM then
                            wmelemod = ele.AttPosMods[k.Slot].vpos
                        end
                    end

                    if !self.MirrorVMWM then
                        if ((ele.AttPosMods or {})[k.Slot] or {}).wpos then
                            wmelemod = ele.AttPosMods[k.Slot].wpos
                        end
                    end

                    if ((ele.AttPosMods or {})[k.Slot] or {}).slide then
                        slidemod = ele.AttPosMods[k.Slot].slide
                    end

                    -- Why the fuck is it called 'slide'. Call it fucking SlideAmount like it is
                    -- in the fucking attachment slot you fucking cockfuck shitdick
                    if ((ele.AttPosMods or {})[k.Slot] or {}).SlideAmount then
                        slidemod = ele.AttPosMods[k.Slot].SlideAmount
                    end
                end

                if wm and !self.MirrorVMWM then
                    offset = wmelemod or (attslot.Offset or {}).wpos or Vector(0, 0, 0)

                    if attslot.SlideAmount then
                        offset = LerpVector(delta, (slidemod or attslot.SlideAmount).wmin or Vector(0, 0, 0), (slidemod or attslot.SlideAmount).wmax or Vector(0, 0, 0))
                    end
                else
                    offset = vmelemod or (attslot.Offset or {}).vpos or Vector(0, 0, 0)

                    if attslot.SlideAmount then
                        offset = LerpVector(delta, (slidemod or attslot.SlideAmount).vmin or Vector(0, 0, 0), (slidemod or attslot.SlideAmount).vmax or Vector(0, 0, 0))
                    end

                    attslot.VMOffsetPos = offset
                end

            end

        end

        local apos, aang

        if k.CharmParent and IsValid(k.CharmParent.Model) then
            local cm = k.CharmParent.Model
            local boneindex = cm:LookupAttachment(k.CharmAtt)
            local angpos = cm:GetAttachment(boneindex)
            if angpos then
                apos, aang = angpos.Pos, angpos.Ang

                local pos = k.CharmOffset
                local ang = k.CharmAngle
                local scale = k.CharmScale or Vector(1, 1, 1)

                apos = apos + aang:Forward() * pos.x * scale.x
                apos = apos + aang:Right() * pos.y * scale.y
                apos = apos + aang:Up() * pos.z * scale.z

                aang:RotateAroundAxis(aang:Right(), ang.p)
                aang:RotateAroundAxis(aang:Up(), ang.y)
                aang:RotateAroundAxis(aang:Forward(), ang.r)
            end
        elseif bang and bpos then

            local pos = offset or Vector(0, 0, 0)
            local ang = k.OffsetAng or Angle(0, 0, 0)

            pos = pos * vscale

            local moffset = (k.ModelOffset or Vector(0, 0, 0))

            apos = bpos + bang:Forward() * pos.x
            apos = apos + bang:Right() * pos.y
            apos = apos + bang:Up() * pos.z

            aang = Angle()
            aang:Set(bang)

            aang:RotateAroundAxis(aang:Right(), ang.p)
            aang:RotateAroundAxis(aang:Up(), ang.y)
            aang:RotateAroundAxis(aang:Forward(), ang.r)

            apos = apos + aang:Forward() * moffset.x
            apos = apos + aang:Right() * moffset.y
            apos = apos + aang:Up() * moffset.z
        else
            continue
        end

        if !apos or !aang then return end

        k.Model:SetPos(apos)
        k.Model:SetAngles(aang)
        k.Model:SetRenderOrigin(apos)
        k.Model:SetRenderAngles(aang)

        if k.Bodygroups then
            k.Model:SetBodyGroups(k.Bodygroups)
        end

        if k.DrawFunc then
            k.DrawFunc(self, k, wm)
        end

        if !k.NoDraw then
            k.Model:DrawModel()
        end

        -- FIXME: activeslot is nil?
        if i != activeslot and ArcCW.Overdraw then
            k.Model:SetBodygroup(1, 0)
        end
    end

    if wm then
        self:DrawFlashlightsWM()
        -- self:KillFlashlightsVM()
    else
        self:DrawFlashlightsVM()
    end

    -- self:RefreshBGs()
end

SWEP.ReferencePosCache = {}

function SWEP:GetFromReference(boneid)
    if !boneid then boneid = 1 end
    if self.ReferencePosCache[boneid] then
        return self.ReferencePosCache[boneid].Pos, self.ReferencePosCache[boneid].Ang
    end

    SafeRemoveEntity(ArcCW.ReferenceModel)

    if !self.ViewModel then
        -- uh oh panic
        local og = weapons.Get(self:GetClass())
        self.ViewModel = og.ViewModel
    end

    ArcCW.ReferenceModel = ClientsideModel(self.ViewModel)

    local pos = self:GetOwner():EyePos()
    local ang = self:GetOwner():EyeAngles()

    local seq = "idle"
    seq = self:GetBuff_Override("Override_AutosolveSourceSeq") or self.AutosolveSourceSeq or seq
    ArcCW.ReferenceModel:ResetSequence(seq)

    ArcCW.ReferenceModel:SetPos(pos)
    ArcCW.ReferenceModel:SetAngles(ang)
    ArcCW.ReferenceModel:SetNoDraw(true)
    ArcCW.ReferenceModel:SetupBones()

    local ma = ArcCW.ReferenceModel:GetBoneMatrix(boneid)
    local bpos, bang = ma:GetTranslation(), ma:GetAngles()

    bpos, bang = WorldToLocal(pos, ang, bpos, bang)

    self.ReferencePosCache[boneid] = {Pos = bpos, Ang = bang}

    return bpos, bang
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_reload.lua:


function SWEP:GetReloadTime()
    -- Only works with classic mag-fed weapons.
    local mult = self:GetBuff_Mult("Mult_ReloadTime")
    local anim = self:SelectReloadAnimation()

    if !self.Animations[anim] then return false end

    local full = self:GetAnimKeyTime(anim) * mult
    local magin = self:GetAnimKeyTime(anim, true) * mult

    return { full, magin }
end

function SWEP:SetClipInfo(load)
    load = self:GetBuff_Hook("Hook_SetClipInfo", load) or load
    self.LastLoadClip1 = load - self:Clip1()
    self.LastClip1 = load
end

function SWEP:Reload()
    if IsValid(self:GetHolster_Entity()) then return end
    if self:GetHolster_Time() > 0 then return end

    if self:GetOwner():IsNPC() then
        return
    end

    if self:GetState() == ArcCW.STATE_CUSTOMIZE then
        return
    end

    -- Switch to UBGL
    if self:GetBuff_Override("UBGL") and self:GetOwner():KeyDown(IN_USE) then
        if self:GetInUBGL() then
            --net.Start("arccw_ubgl")
            --net.WriteBool(false)
            --net.SendToServer()

            self:DeselectUBGL()
        else
            --net.Start("arccw_ubgl")
            --net.WriteBool(true)
            --net.SendToServer()

            self:SelectUBGL()
        end

        return
    end

    if self:GetInUBGL() then
        if self:GetNextSecondaryFire() > CurTime() then return end
            self:ReloadUBGL()
        return
    end

    if self:GetNextPrimaryFire() >= CurTime() then return end
    -- if !game.SinglePlayer() and !IsFirstTimePredicted() then return end


    if self.Throwing then return end
    if self.PrimaryBash then return end

    -- with the lite 3D HUD, you may want to check your ammo without reloading
    local Lite3DHUD = self:GetOwner():GetInfo("arccw_hud_3dfun") == "1"
    if self:GetOwner():KeyDown(IN_WALK) and Lite3DHUD then
        return
    end

    if self:GetMalfunctionJam() then
        local r = self:MalfunctionClear()
        if r then return end
    end

    if !self:GetMalfunctionJam() and self:Ammo1() <= 0 and !self:HasInfiniteAmmo() then return end

    if self:HasBottomlessClip() then return end

    if self:GetBuff_Hook("Hook_PreReload") then return end

    -- if we must dump our clip when reloading, our reserve ammo should be more than our clip
    local dumpclip = self:GetBuff_Hook("Hook_ReloadDumpClip")
    if dumpclip and !self:HasInfiniteAmmo() and self:Clip1() >= self:Ammo1() then
        return
    end

    self.LastClip1 = self:Clip1()

    local reserve = self:Ammo1()

    reserve = reserve + self:Clip1()
    if self:HasInfiniteAmmo() then reserve = self:GetCapacity() + self:Clip1() end

    local clip = self:GetCapacity()

    local chamber = math.Clamp(self:Clip1(), 0, self:GetChamberSize())
    if self:GetNeedCycle() then chamber = 0 end

    local load = math.Clamp(clip + chamber, 0, reserve)

    if !self:GetMalfunctionJam() and load <= self:Clip1() then return end

    self:SetBurstCount(0)

    local shouldshotgunreload = self:GetBuff_Override("Override_ShotgunReload")
    local shouldhybridreload = self:GetBuff_Override("Override_HybridReload")

    if shouldshotgunreload == nil then shouldshotgunreload = self.ShotgunReload end
    if shouldhybridreload == nil then shouldhybridreload = self.HybridReload end

    if shouldhybridreload then
        shouldshotgunreload = self:Clip1() != 0
    end

    if shouldshotgunreload and self:GetShotgunReloading() > 0 then return end

    local mult = self:GetBuff_Mult("Mult_ReloadTime")

    if shouldshotgunreload then
        local anim = "sgreload_start"
        local insertcount = 0

        local empty = self:Clip1() == 0 --or self:GetNeedCycle()

        if self.Animations.sgreload_start_empty and empty then
            anim = "sgreload_start_empty"
            empty = false
            if (self.Animations.sgreload_start_empty or {}).ForceEmpty == true then
                empty = true
            end

            insertcount = (self.Animations.sgreload_start_empty or {}).RestoreAmmo or 1
        else
            insertcount = (self.Animations.sgreload_start or {}).RestoreAmmo or 0
        end

        anim = self:GetBuff_Hook("Hook_SelectReloadAnimation", anim) or anim

        local time = self:GetAnimKeyTime(anim)
        local time2 = self:GetAnimKeyTime(anim, true)

        if time2 >= time then
            time2 = 0
        end

        if insertcount > 0 then
            self:SetMagUpCount(insertcount)
            self:SetMagUpIn(CurTime() + time2 * mult)
        end
        self:PlayAnimation(anim, mult, true, 0, true, nil, true)

        self:SetReloading(CurTime() + time * mult)

        self:SetShotgunReloading(empty and 4 or 2)
    else
        local anim = self:SelectReloadAnimation()

        if !self.Animations[anim] then print("Invalid animation \"" .. anim .. "\"") return end

        self:PlayAnimation(anim, mult, true, 0, false, nil, true)

        local reloadtime = self:GetAnimKeyTime(anim, true) * mult
        local reloadtime2 = self:GetAnimKeyTime(anim, false) * mult

        self:SetNextPrimaryFire(CurTime() + reloadtime2)
        self:SetReloading(CurTime() + reloadtime2)

        self:SetMagUpCount(0)
        self:SetMagUpIn(CurTime() + reloadtime)
    end

    self:SetClipInfo(load)
    if game.SinglePlayer() then
        self:CallOnClient("SetClipInfo", tostring(load))
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl.DamageOnReload then
            self:DamageAttachment(i, atttbl.DamageOnReload)
        end
    end

    if !self.ReloadInSights then
        self:ExitSights()
        self.Sighted = false
    end

    self:GetBuff_Hook("Hook_PostReload")
end

function SWEP:ReloadTimed()
    -- yeah my function names are COOL and QUIRKY and you can't say a DAMN thing about it.
    self:RestoreAmmo(self:GetMagUpCount() != 0 and self:GetMagUpCount())
    self:SetMagUpCount(0)
    self:SetLastLoad(self:Clip1())
    self:SetNthReload(self:GetNthReload() + 1)
end

function SWEP:Unload()
    if !self:GetOwner():IsPlayer() then return end
    if SERVER and self:Clip1() != ArcCW.BottomlessMagicNumber then
        self:GetOwner():GiveAmmo(self:Clip1(), self.Primary.Ammo or "", true)
    end
    self:SetClip1(0)
end

function SWEP:HasBottomlessClip()
    if ArcCW.ConVars["mult_bottomlessclip"]:GetBool() then return true end
    if self.BottomlessClip or self:GetBuff_Override("Override_BottomlessClip") then return true end
    return false
end

function SWEP:HasInfiniteAmmo()
    if ArcCW.ConVars["mult_infiniteammo"]:GetBool() then return true end
    if self:GetBuff_Override("Override_InfiniteAmmo", self.InfiniteAmmo) then return true end
    return false
end

function SWEP:RestoreAmmo(count)
    if self:GetOwner():IsNPC() then return end

    local chamber = math.Clamp(self:Clip1(), 0, self:GetChamberSize())
    if self:GetNeedCycle() then chamber = 0 end

    local clip = self:GetCapacity()

    count = count or (clip + chamber)

    local reserve = (self:HasInfiniteAmmo() and math.huge or self:Ammo1())

    local dumpclip = self:GetBuff_Hook("Hook_ReloadDumpClip")
    if !dumpclip then
        reserve = reserve + self:Clip1()
    end

    local load = math.Clamp(self:Clip1() + count, 0, reserve)
    load = math.Clamp(load, 0, clip + chamber)
    reserve = reserve - load

    if !self:HasInfiniteAmmo() then
        self:GetOwner():SetAmmo(reserve, self.Primary.Ammo, true)
    end
    self:SetClip1(load)
end

-- local lastframeclip1 = 0

SWEP.LastClipOutTime = 0

function SWEP:GetVisualBullets()
    local h = self:GetBuff_Hook("Hook_GetVisualBullets")
    if h then return h end

    local _clip = self:Clip1()
    local _ammo = self:Ammo1()

    if self:HasInfiniteAmmo() then
        _ammo = math.huge
    end
    if self:HasBottomlessClip() then
        _clip = _ammo
    end

    if self.LastClipOutTime > CurTime() then
        return self.LastClip1_B or _clip
    else
        self.LastClip1_B = _clip

        if self:GetReloading() and !(self.ShotgunReload or (self.HybridReload and _clip == 0)) then
            return math.Clamp(_clip + _ammo, 0, self:GetCapacity() + self:GetChamberSize())
        else
            return _clip
        end
    end
end

function SWEP:GetVisualClip()
    -- local reserve = self:Ammo1()
    -- local chamber = math.Clamp(self:Clip1(), 0, self:GetChamberSize())
    -- local abouttoload = math.Clamp(self:GetCapacity() + chamber, 0, reserve + self:Clip1())

    -- local h = self:GetBuff_Hook("Hook_GetVisualClip")

    -- if h then return h end
    -- if self.LastClipOutTime > CurTime() then
    --     return self.LastClip1 or self:Clip1()
    -- else
    --     if !self.RevolverReload then
    --         self.LastClip1 = self:Clip1()
    --     else
    --         if self:Clip1() > lastframeclip1 then
    --             self.LastClip1 = self:Clip1()
    --         end

    --         lastframeclip1 = self:Clip1()
    --     end

    --     if self:GetReloading() and !(self.ShotgunReload or (self.HybridReload and self:Clip1() == 0)) then
    --         return abouttoload
    --     else
    --         return self.LastClip1 or self:Clip1()
    --     end
    -- end

    local reserve = self:Ammo1()
    if self:HasInfiniteAmmo() then
        reserve = math.huge
    end
    local chamber = math.Clamp(self:Clip1(), 0, self:GetChamberSize())
    local abouttoload = math.Clamp(self:GetCapacity() + chamber, 0, reserve + self:Clip1())

    local h = self:GetBuff_Hook("Hook_GetVisualClip")

    if h then return h end

    if self.LastClipOutTime > CurTime() then
        return self:GetLastLoad() or self:Clip1()
    end

    if self.RevolverReload then
        if self:GetReloading() and !(self.ShotgunReload or (self.HybridReload and self:Clip1() == 0)) then
            return abouttoload
        else
            return self:GetLastLoad() or self:Clip1()
        end
    else
        return self:Clip1()
    end
end

function SWEP:GetVisualLoadAmount()
    return self.LastLoadClip1 or self:Clip1()
end

function SWEP:SelectReloadAnimation()
    local ret

    if self.Animations.reload_empty and self:Clip1() == 0 then
        ret = "reload_empty"
    else
        ret = "reload"
    end

    ret = self:GetBuff_Hook("Hook_SelectReloadAnimation", ret) or ret

    return ret
end

function SWEP:ReloadInsert(empty)
    local total = self:GetCapacity()

    -- if !game.SinglePlayer() and !IsFirstTimePredicted() then return end

    if !empty and !self:GetNeedCycle() then
        total = total + (self:GetBuff("ChamberLoadNonEmpty", true) or self:GetChamberSize())
    else
        total = total + (self:GetBuff("ChamberLoadEmpty", true) or 0)
    end

    local mult = self:GetBuff_Mult("Mult_ReloadTime")

    if self:Clip1() >= total or (self:Ammo1() == 0 and !self:HasInfiniteAmmo()) or ((self:GetShotgunReloading() == 3 or self:GetShotgunReloading() == 5) and self:Clip1() > 0) then
        local ret = "sgreload_finish"

        if empty then
            if self.Animations.sgreload_finish_empty then
                ret = "sgreload_finish_empty"
            end
            if self:GetNeedCycle() then
                self:SetNeedCycle(false)
            end
        end

        ret = self:GetBuff_Hook("Hook_SelectReloadAnimation", ret) or ret

        self:PlayAnimation(ret, mult, true, 0, true, nil, true)
        self:SetReloading(CurTime() + (self:GetAnimKeyTime(ret, true) * mult))

        self:SetTimer(self:GetAnimKeyTime(ret, true) * mult,
        function()
            self:SetNthReload(self:GetNthReload() + 1)
            if self:GetOwner():KeyDown(IN_ATTACK2) then
                self:EnterSights()
            end
        end)

        self:SetShotgunReloading(0)
    else
        local insertcount = self:GetBuff_Override("Override_InsertAmount") or 1
        local insertanim = "sgreload_insert"

        local ret = self:GetBuff_Hook("Hook_SelectInsertAnimation", {count = insertcount, anim = insertanim, empty = empty})

        if ret then
            insertcount = ret.count
            insertanim = ret.anim
        end

        local load = self:GetCapacity() + math.min(self:Clip1(), self:GetChamberSize())
        if load - self:Clip1() > self:Ammo1() then load = self:Clip1() + self:Ammo1() end
        self:SetClipInfo(load)
        if game.SinglePlayer() then
            self:CallOnClient("SetClipInfo", tostring(load))
        end

        local time = self:GetAnimKeyTime(insertanim, false)
        local time2 = self:GetAnimKeyTime(insertanim, true)

        if time2 >= time then
            time2 = 0
        end

        self:SetMagUpCount(insertcount)
        self:SetMagUpIn(CurTime() + time2 * mult)

        self:SetReloading(CurTime() + time * mult)

        self:PlayAnimation(insertanim, mult, true, 0, true, nil, true)
        self:SetShotgunReloading(empty and 4 or 2)
    end
end

function SWEP:GetCapacity()
    local clip = self.RegularClipSize or self.Primary.ClipSize

    if !self.RegularClipSize then
        self.RegularClipSize = self.Primary.ClipSize
    end

    local level = 1

    if self:GetBuff_Override("MagExtender") then
        level = level + 1
    end

    if self:GetBuff_Override("MagReducer") then
        level = level - 1
    end

    if level == 0 then
        clip = self.ReducedClipSize
    elseif level == 2 then
        clip = self.ExtendedClipSize
    end

    clip = self:GetBuff("ClipSize", true, clip) or clip

    local ret = self:GetBuff_Hook("Hook_GetCapacity", clip)

    clip = ret or clip

    clip = math.Clamp(math.Round(clip), 0, math.huge)

    self.Primary.ClipSize = clip

    return clip
end

function SWEP:GetChamberSize()
    return self:GetBuff("ChamberSize") --(self:GetBuff_Override("Override_ChamberSize") or self.ChamberSize) + self:GetBuff_Add("Add_ChamberSize")
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_timers.lua:
local tbl     = table
local tbl_ins = tbl.insert

local tick = 0

function SWEP:InitTimers()
    self.ActiveTimers = {} -- { { time, id, func } }
end

function SWEP:SetTimer(time, callback, id)
    if !IsFirstTimePredicted() then return end

    tbl_ins(self.ActiveTimers, { time + CurTime(), id or "", callback })
end

function SWEP:TimerExists(id)
    for _, v in pairs(self.ActiveTimers) do
        if v[2] == id then return true end
    end

    return false
end

function SWEP:KillTimer(id)
    local keeptimers = {}

    for _, v in pairs(self.ActiveTimers) do
        if v[2] != id then tbl_ins(keeptimers, v) end
    end

    self.ActiveTimers = keeptimers
end

function SWEP:KillTimers()
    self.ActiveTimers = {}
end

function SWEP:ProcessTimers()
    local keeptimers, UCT = {}, CurTime()

    if CLIENT and UCT == tick then return end

    if !self.ActiveTimers then self:InitTimers() end

    for _, v in pairs(self.ActiveTimers) do
        if v[1] <= UCT then v[3]() end
    end

    for _, v in pairs(self.ActiveTimers) do
        if v[1] > UCT then tbl_ins(keeptimers, v) end
    end

    self.ActiveTimers = keeptimers
end

local function DoShell(wep, data)
    if !(IsValid(wep) and IsValid(wep:GetOwner())) then return end

    local att = data.att or wep:GetBuff_Override("Override_CaseEffectAttachment") or wep.CaseEffectAttachment or 2

    if !att then return end

    local getatt = wep:GetAttachment(att)

    if !getatt then return end

    local pos, ang = getatt.Pos, getatt.Ang

    local ed = EffectData()
    ed:SetOrigin(pos)
    ed:SetAngles(ang)
    ed:SetAttachment(att)
    ed:SetScale(1)
    ed:SetEntity(wep)
    ed:SetNormal(ang:Forward())
    ed:SetMagnitude(data.mag or 100)

    util.Effect(data.e, ed)
end

function SWEP:PlaySoundTable(soundtable, mult, start, key)
    --if CLIENT and game.SinglePlayer() then return end

    local owner = self:GetOwner()

    start = start or 0
    mult  = 1 / (mult or 1)

    for _, v in pairs(soundtable) do
        if table.IsEmpty(v) then continue end

        local ttime
        if v.t then
            ttime = (v.t * mult) - start
        else
            continue
        end
        if ttime < 0 then continue end
        if !(IsValid(self) and IsValid(owner)) then continue end

        local jhon = CurTime() + ttime

        --[[if game.SinglePlayer() then
            if SERVER then
                net.Start("arccw_networksound")
                v.ntttime = ttime
                net.WriteTable(v)
                net.WriteEntity(self)
                net.Send(owner)
            end
        end]]

        -- i may go fucking insane
        if !self.EventTable[1] then self.EventTable[1] = {} end

        for i, de in ipairs(self.EventTable) do
            if de[jhon] then
                if !self.EventTable[i + 1] then
                    --[[print(CurTime(), "Occupier at " .. i .. ", creating " .. i+1)]]
                    self.EventTable[i + 1] = {}
                    continue
                end
            else
                self.EventTable[i][jhon] = table.Copy(v)
                self.EventTable[i][jhon].StartTime = CurTime()
                self.EventTable[i][jhon].AnimKey = key
                -- print(CurTime(), "Clean at " .. i)
            end
        end
    end
end

function SWEP:PlayEvent(v)
    if !v or !istable(v) then error("no event to play") end
    v = self:GetBuff_Hook("Hook_PrePlayEvent", v) or v
    if v.e and IsFirstTimePredicted() then
        DoShell(self, v)
    end

    if v.s then
        if v.s_km then
            self:StopSound(v.s)
        end
        self:MyEmitSound(v.s, v.l, v.p, v.v, v.c or CHAN_AUTO)
    end

    if v.bg then
        self:SetBodygroupTr(v.ind or 0, v.bg)
    end

    if v.pp then
        local vm = self:GetOwner():GetViewModel()

        vm:SetPoseParameter(pp, ppv)
    end

    v = self:GetBuff_Hook("Hook_PostPlayEvent", v) or v
end


if CLIENT then
    net.Receive("arccw_networksound", function(len)
        local v = net.ReadTable()
        local wep = net.ReadEntity()

        wep.EventTable[CurTime() + v.ntttime] = v
    end)
end
--addons/arccw_base_modified/lua/weapons/arccw_base_melee/shared.lua:
SWEP.Base = "arccw_base"

SWEP.Primary.Ammo = "" -- Prevent base "pistol" ammo type from showing up on the HUD of melee weapons

SWEP.MeleeDamage = 25
SWEP.MeleeDamageBackstab = nil -- If not exists, use multiplier on standard damage
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.Melee2 = false
SWEP.Melee2Damage = 25
SWEP.Melee2DamageBackstab = nil -- If not exists, use multiplier on standard damage
SWEP.Melee2Range = 16
SWEP.Melee2Time = 0.5
SWEP.Melee2Gesture = nil
SWEP.Melee2AttackTime = 0.2

SWEP.Backstab = false
SWEP.BackstabMultiplier = 2

SWEP.NotForNPCs = true

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "MELEE"
    },
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "melee"

SWEP.Primary.ClipSize = -1

SWEP.Animations = {
    -- ["draw"] = {
    --     Source = "draw",
    --     Time = 0.5,
    -- },
    -- ["ready"] = {
    --     Source = "draw",
    --     Time = 0.5,
    -- },
    -- ["bash"] = {
    --     Source = {"stab", "midslash1", "midslash2", "stab_miss"},
    --     Time = 0.5,
    -- },
    -- ["bash_backstab"] = {
    --     Source = {"stab_backstab"},
    --     Time = 0.5,
    -- },
}

SWEP.IronSightStruct = false

SWEP.BashPreparePos = Vector(0, 0, 0)
SWEP.BashPrepareAng = Angle(0, 0, 0)

SWEP.BashPos = Vector(0, 0, 0)
SWEP.BashAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0, -1, 0)
SWEP.HolsterAng = Angle(-10, 0, 0)

SWEP.ShootWhileSprint = true

SWEP.SpeedMult = 1

SWEP.Secondary.Automatic = true


--addons/arccw_base_modified/lua/weapons/arccw_base_nade/shared.lua:
SWEP.Base = "arccw_base"

SWEP.Throwing = true
SWEP.Singleton = false -- for grenades, means that weapons ARE ammo; hold one, use one.

SWEP.NotForNPCs = true

SWEP.Delay = 1
SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "NADE"
    },
}

SWEP.MuzzleVelocity = 1000
SWEP.MuzzleVelocityAlt = nil -- Throwing with alt-fire will use this velocity if exists

SWEP.PullPinTime = 0.25
SWEP.FuseTime = 3.5

SWEP.WindupTime = 0.5 -- Time to reach max velocity (does not apply for altfire)
SWEP.WindupMinimum = 0.25 -- Velocity fraction if released without windup

SWEP.ShootEntityDelay = 0.25 -- Delay between Throw() call and projectile existing

SWEP.ThrowInertia = nil -- override default throw intertia settings

SWEP.CookPrimFire = true
SWEP.CookAltFire = true

SWEP.ChamberSize = 0

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "slam"
SWEP.HoldtypeSights = "grenade"
SWEP.HoldtypeCustomize = "slam"

SWEP.Primary.ClipSize = 1
SWEP.Primary.Ammo = "grenade"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE
SWEP.AnimShootAlt = ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM

-- By default, grenades with no ammo will be stripped. Set true to prevent
SWEP.KeepIfEmpty = false

SWEP.Animations = {
    -- ["draw"] = {
    --     Source = "draw",
    --     Time = 0.5,
    -- },
    -- ["ready"] = {
    --     Source = "draw",
    --     Time = 0.5,
    -- },
    -- ["pre_throw"] = {
    --     Source = "pullpin",
    --     Time = 0.5,
    -- },
    -- ["throw"] = {
    --     Source = "throw",
    --     Time = 0.5
    -- }
}

SWEP.BashPreparePos = Vector(2.187, -7.117, -1)
SWEP.BashPrepareAng = Angle(5, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.HolsterPos = Vector(0.532, -1, 0)
SWEP.HolsterAng = Angle(-10, 0, 0)

SWEP.IronSightStruct = false

SWEP.MeleeSwingSound = "weapons/arccw/m249/m249_draw.wav"
SWEP.MeleeHitSound = "weapons/arccw/knife/knife_hitwall1.wav"
SWEP.MeleeHitNPCSound = "physics/body/body_medium_break2.wav"

SWEP.ShootWhileSprint = true

SWEP.SpeedMult = 1

SWEP.Secondary.Automatic = true

function SWEP:SecondaryAttack()
    self:PrimaryAttack()
end

function SWEP:OnRemove()
    if engine.ActiveGamemode() != "terrortown" then return end
    if CLIENT and IsValid(self:GetOwner()) and self:GetOwner() == LocalPlayer() and self:GetOwner():Alive() then
        RunConsoleCommand("use", "weapon_ttt_unarmed")
    end
end
--addons/arccw_weapons/lua/weapons/arccw_blaster_dc15s.lua:
AddCSLuaFile()
SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "DC-15s"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "High tech verstile modular blaster base, suited for allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"

SWEP.ViewModel = "models/arccw/ser/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/arccw/ser/starwars/w_dc15s.mdl"
SWEP.IconOverride = "materials/entities/tfa_dc15s_serv.png"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 27
SWEP.DamageMin = 14 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 100 -- how far bullets will retain their maximum damage for
SWEP.Range = 300 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3 -- color for phys tracer.

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "tfa_tracer_blue" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(0, 47, 255)
SWEP.HullSize = 2 -- HullSize used by FireBullets

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 20 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.15
SWEP.RecoilRise = 0.53
SWEP.VisualRecoilMult = 2
SWEP.RecoilPunch = 1.4
SWEP.RecoilPunchBackMax = 0.9

SWEP.RecoilDirection = Angle(1.1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 330 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 65 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 130 -- dispersion that remains even in sights
SWEP.JumpDispersion = 200 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "w/dc15s/blasters_dc15_laser_close_var_02.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 102, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-2.8, -0, 2.3),
    Ang = Angle(0, 0, 1),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0
-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.SprintPos = Vector(6, -4, 0)
SWEP.SprintAng = Angle(-16.524, 60, -11.046)

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(10.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = true

SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    ["nil"] = {
        VMElements = {
            {
                Model = "models/arccw/props/e11r_scope/e11r_scope.mdl",
                Bone = "weapon",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0.05, -2.85, 0.8),
                    ang = Angle(-0.3, 0, -90)
                }
            }
        },
        WMElements = { -- Purely handles muzzle effect on the world model
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(20, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}


SWEP.Attachments = {
	[1] = {
		PrintName = "Optic", -- print name
		DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
		Slot = "optic",
        DefaultEles = {"ironsight"},
		Bone = "DC15", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(0.02, -1.5, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.5, -5),
            wang = Angle(-10, 2, 180)
        },
        NoWM = false
	},
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(.9, -0.5, 6),
            vang = Angle(90, 0, -0),
            wpos = Vector(14, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
        NoWM = false
    },
    [3] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.9, 0, -3.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.8, -4.5),
            wang = Angle(0, 0, 180)
        },
    },
    [4] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        Bone = "DC15", -- relevant bone any attachments wwill be mostly referring to /
        Offset = {
            vpos = Vector(-0, 0.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, 2),
            wang = Angle(0, 0, 180)            
        },
        SlideAmount = {
        vmin = Vector(-0, 0.2, 2),
        vmax = Vector(-0, 0.2, 6),
        wmin = Vector(14, 1, -4.5), 
        wmax = Vector(14, 1, -4.5) -- how far this attachment can slide in both directions.
        },          -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = {"ammo", "sw_ammo"},
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"dc15a_magazine_75"},
        Bone = "Magazine", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(2, 0.7, -1.6),
            vang = Angle(180, 0, 0),
            wpos = Vector(9.5, 1.5, -3.8),
            wang = Angle(80, 90, 0) 
        },
    },
    [8] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -0.5, 11.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 1, -6.5),
            wang = Angle(-12, 0.5, 180) 
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sights"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["enter_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["exit_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },  
	["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {
				s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_03.mp3", -- sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 0.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
			{
				s = "w/dc15s/overheat_reset_var_02.mp3", -- "everfall/weapons/miscellaneous/charge/blasters_deathray_charge_start_var_04.mp3"sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 1.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
		}
    },
	["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
	["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_bowcaster.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[R] Bowcaster"
SWEP.Trivia_Class = "Laser Crossbow"
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "Forged Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_bowcaster.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 35
SWEP.RangeMin = 150
SWEP.DamageMin = 15
SWEP.Range = 800
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_green"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },          
}

SWEP.AccuracyMOA = 0.52 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50
SWEP.SightsDispersion = 0

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/bowcaster.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(0, 255, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-3.2, -3, 1.2),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, -4, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(1, -2, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"bowcaster"}

SWEP.AttachmentElements = {
    ["bowcaster"] = {
        VMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/bowcaster.mdl", -- using the model-edit i made in like 2 mins lol
                Bone = "v_dlt19_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0.4, 3, -6.8),
                    ang = Angle(0,-90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/bowcaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(600, 2.5, 500),
                    ang = Angle(-15, 0, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}
WMOverride = "models/arccw/hauptmann/star wars/weapons/bowcaster.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.01, -0.2, -4.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(360, 0, -600),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.1, 3.28, 7),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 3.0, 8),
            vmax = Vector(-0, 3.0, 8),
            wmin = Vector(1500, 0, -580), 
            wmax = Vector(1500, 0, -580)  -- how far this attachment can slide in both directions.
        },
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 3.5, 10),
            vang = Angle(90, 0, -90),
            wpos = Vector(1750, 0, -600),
            wang = Angle(-15, 0, -180)
        },
    },     
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.5, 3, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(900, 70, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_cj9.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[R] CJ-9"
SWEP.Trivia_Class = "Galactic Electrified Bo-Rifle"
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "Forged Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_cj9.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 20
SWEP.RangeMin = 135
SWEP.DamageMin = 15
SWEP.Range = 450
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(255,0,0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/cj9.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(255, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-3, -4, 0.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -1, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"cj9"}

SWEP.AttachmentElements = {
    ["cj9"] = {
        VMElements = {
            {
                Model = "models/arccw/rising/w_bo.mdl", -- using the model-edit i made in like 2 mins lol
                Bone = "v_dlt19_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0.84, 6, 01.75),
                    ang = Angle(0, 2, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/rising/w_bo.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(800, 2.5, -300),
                    ang = Angle(-15, -90, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}
WMOverride = "models/arccw/rising/w_bo.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.25, -1, 6.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(1400, -45, -800),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.1, 3.28, 2),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
        vmin = Vector(0, 3, -1),
        vmax = Vector(0, 3, 4),
        wmin = Vector(1200, -30, -320), 
        wmax = Vector(1200, -30, -320) -- how far this attachment can slide in both directions.
        },        
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.5, 2.5, 12),
            vang = Angle(90, 0, -45),
            wpos = Vector(2000, 50, -700),
            wang = Angle(-15, 0, -90)
        },
    },     
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.3, 2.05, 12),
            vang = Angle(90, 0, -90),
        },
    },             
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 1.5, 0),
            vang = Angle(90, 0, -70),
            wpos = Vector(900, 70, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dc15x_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-15x"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-15A Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dc15x.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc15x_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -4),
    ang = Angle(165, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc15x.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 45
SWEP.RangeMin = 190
SWEP.DamageMin = 27
SWEP.Range = 550
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 9

SWEP.Recoil = 1
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.34

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "shared/snipers/Shared_Corebass_Close_Sniper_VAR_03 0 4 0.ogg"
SWEP.ShootSound = "dc15x/SW02_Weapons_Blaster_DLT19X_Laser_Close_VAR_01 3 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.74, -12, 1.45),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -5, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"dc15x", ""}

-- SWEP.AttachmentElements = {
--     ["dc15x"] = {
--         VMMaterial = "asdzxc.vmt",
--     }
-- }

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.03, -0.87, 8.0),
            vang = Angle(90, 0, -90),
            wpos = Vector(17, 1, -8.5),
            wang = Angle(-16, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.0, 2.4, 15.2),
            vang = Angle(90, 0, -90),
            wang = Angle(165, 180, 0),
            wpos = Vector(22.5, 1, -6.2),
        },
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 0.8, 31),
            vang = Angle(90, 0, -0),
            wpos = Vector(38, 1.8, -12),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 1.5, 29),
            vang = Angle(90, 0, -90),
            wpos = Vector(3650, 0, -1210),
            wang = Angle(-15, 0, -90)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
            wpos = Vector(440, 10, -260),
            wang = Angle(-15, 90, -90)
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.65, .8, 10),
            vang = Angle(90, 0, -90),
            wpos = Vector(13, 1.8, -5.5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    [9] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1, 7),
            vang = Angle(90, 0, -90),
            wpos = Vector(675, 90, -400),
            wang = Angle(-15 , 0, 180)
        },
    },   
    [10] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [11] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}
--addons/arccw_weapons/lua/weapons/arccw_dual_dc17.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual DC-17 (V1 - WIP)"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact DC15S Blaster Carbine, preffered for CQB enviroments and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_dc17.png"

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true
SWEP.Damage = 30
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 330
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"


SWEP.MuzzleFlashColor = Color(0, 0, 255, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dc17", "dc17+"}

SWEP.AttachmentElements = {
    ["dc17"] = {
        VMElements = {
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3, 2, -0.7),
                    ang = Angle(-0, -2, 90)
                }
            }
        },
    },
    ["dc17+"] = {
         VMElements = {
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-3.5, -2.2, 1.2),
                    ang = Angle(-180, -2, -90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-8, -4, 2),
            vang = Angle(170, 0, 0),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [3] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [4] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}   


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dual_e5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual E-5"
SWEP.Trivia_Class = "CIS Dual Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact Dual E-5 Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_e5.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 150
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 380
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5.wav"

SWEP.MuzzleFlashColor = Color(255, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)


SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"e5", "e5+"}

SWEP.AttachmentElements = {
    ["e5"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(4, -1.5, -1),
                    ang = Angle(-4, -2, 90)
                }
            }
        },
    },
    ["e5+"] = {
         VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-4, 1.5, 1),
                    ang = Angle(-4, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(40.5, 10, 20.75),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-40, 230, -25),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-12, -4, 2.5),
            vang = Angle(170, 0, 0),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}


-- AOCRP WAFFENSTATS arccw_dual_e5 - 02.06.2024
SWEP.Damage = 25
SWEP.DamageMin = 15
SWEP.RangeMin = 150
SWEP.Range = 350
SWEP.Delay = 60 / 380
SWEP.Primary.ClipSize = 40
SWEP.Category = 'KUS'
--addons/arccw_weapons/lua/weapons/arccw_e5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "E-5"
SWEP.Trivia_Class = "CIS Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact CIS E-5 Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_e11.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_e5.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 41
SWEP.RangeMin = 150
SWEP.DamageMin = 24
SWEP.Range = 400
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 270
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.44 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(255, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-2.87, -8, .7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 65,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.9, -4, .5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)

SWEP.DefaultElements = {"e5", "muzzle"}

SWEP.AttachmentElements = {
    ["e5"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "v_e11_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-0.95, 0.899, -3.5),
                    ang = Angle(0, -90, 0)
                }
            }
        }
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "e11_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 4, 11),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(450, 60, 200),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2000, 0, -900),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.24, -1.5, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 55, -740),
            wang = Angle(-15, 0, 180)
        },
    },    
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 10),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 2.5, 10),
            vmax = Vector(-0, 2.5, 12),
            wmin = Vector(1000, 60, -450), 
            wmax = Vector(1000, 60, -450) -- how far this attachment can slide in both directions.
            },
    },
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1.5, 11),
            vang = Angle(90, 0, 0),
            wpos = Vector(1200, 130, -750),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.1, 0.6, 17),
            vang = Angle(90, 0, -90),
            wpos = Vector(1640, 60, -860),
            wang = Angle(-15, 0, -90)
        },
    },
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 2.1, -0.5),
            vang = Angle(0, 0, 0),
        },
    },        
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.9, 1, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 220, -500),
            wang = Angle(-10 , 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.2,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15s.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}


-- AOCRP WAFFENSTATS arccw_e5 - 02.06.2024
SWEP.Damage = 20
SWEP.DamageMin = 10
SWEP.RangeMin = 500
SWEP.Range = 1344
SWEP.Delay = 60 / 375
SWEP.Primary.ClipSize = 50
SWEP.Category = 'KUS'
--addons/arccw_weapons/lua/weapons/arccw_ll30.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "LL-30"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_ll30.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 100
SWEP.DamageMin = 14
SWEP.Range = 320
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 145
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/ll30.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.66, -8, 2.4),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"ll30"}

SWEP.AttachmentElements = {
    ["ll30"] = {
        VMElements = {
            {
                Model = "models/arccw/weapons/ll30.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.05, 1.05, 1.05),
                Offset = {
                    pos = Vector(-0.25, 0.5, -2.1),
                    ang = Angle(0, 180, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/weapons/ll30.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 20, 0.3),
                    ang = Angle(-15, -90, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/weapons/ll30.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.3, -2.2, 2.4),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 20, -50),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.3, -13, 1),
            vang = Angle(0, 90, 0),
            wpos = Vector(130, 20, -56),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        WMScale = Vector(10, 10, 10),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.25, 0.4, 18),
            vang = Angle(90, 0, -90),
            wpos = Vector(213, 20, -87),
            wang = Angle(-15, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, 0.4, 4),
            vang = Angle(90, 0, -90),
            wpos = Vector(60, 22, -50),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_sops_deadmansrevenge.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "'Dead Man's Revenge'"
SWEP.Trivia_Class = "Blaster Lever-Action Rifle"
SWEP.Trivia_Desc = "Galactic Lever-Action rifle. Unkown origin. 'Long, short, they all end the same way.'"
SWEP.IconOverride = "entities/sopsmisc/lever1.png"

SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_dead_mans_revenge.mdl"
SWEP.WorldModel = "models/tor/weapons/w_quadblaster.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.WorldModelOffset = {
    pos = Vector(-12, 6, -5),
    ang = Angle(-10, 0, 180)
}

-- Special properties
SWEP.ShotgunReload = true
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 2

-- Damage & Entity Options
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 39
SWEP.DamageMin = 26
SWEP.RangeMin = 190
SWEP.Range = 450
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false

SWEP.MuzzleVelocity = 800

SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 125, 255)
SWEP.TracerWidth = 10
SWEP.PhysTracerProfile = "apex_bullet_energy"
SWEP.Tracer = "arccw_apex_tracer_energy_sniper"
SWEP.HullSize = 0.5
SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 14
SWEP.AmmoPerShot = 1

SWEP.Recoil = 1.23
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.76
SWEP.RecoilPunch = 1.28

SWEP.Delay = 60 / 102
SWEP.Num = 1 
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150

SWEP.Primary.Ammo = "ar2" 
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/rifles/deadmansfire1.wav"
SWEP.ShootSound = "sops-v2/weapons/rifles/deadmansfire3.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.MuzzleEffectAttachment = 1 
SWEP.CaseEffectAttachment = 2
SWEP.ProceduralViewBobAttachment = 1
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-5.237, -10.469, 0),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, -5, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {       
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },         
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle_retracted",
    },
	["fire"] = {
        Source = "shoot",
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "shootiron",
        ShellEjectAt = 0,
    },
    ["sgreload_start"] = {
        Source = "start reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "sops-v2/weapons/rifles/deadmansreloadstart.wav", t = 0.1},
                    },
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0,
    },
    ["sgreload_insert"] = {
        Source = "insert",
        RestoreAmmo = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "sops-v2/weapons/rifles/deadmansreloadinsert.wav", t = 3/30},
                    },
        TPAnimStartTime = 0.3,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["sgreload_finish"] = {
        Source = "finish reload",
        SoundTable = {
                        {s = "sops-v2/weapons/rifles/deadmansreloadend.wav", t = 0.01},
                    },
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.4,
    },  
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/weapons/rifles/deadmansdraw.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/weapons/rifles/deadmansdraw.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_dg29.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = "Kraken"
SWEP.PrintName = "[P] DG-29"
SWEP.Trivia_Class = "Blaster Revolver"
SWEP.Trivia_Desc = "The DG-29 blaster pistol was a stylish and reliable heavy blaster pistol that was manufactured by Antrech Arms, a subsidiary of BlasTech Industries. It was vaunted for its reliability and ease of maintenance, and heavily resembled a slugthrower revolver."
SWEP.Trivia_Manufacturer = "Antrech Arms"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/sopsmisc/dg29.png"

-- Viewmodel & Entity Properties
SWEP.HideViewmodel = false
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/blasterpistol_template.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 40
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 35
SWEP.RangeMin = 125
SWEP.DamageMin = 15
SWEP.Range = 300
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_purple"
SWEP.TracerCol = Color(171, 0, 250)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 14

SWEP.Recoil = 1.50
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 100

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/dg29.wav"
SWEP.ShootSound = "sops-v2/weapons/dg29.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_purple"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(171, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-5, -10, 0.2),
    Ang = Angle(0, 0, 2.5),
     Magnification = 1.3,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(-4, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/dg29.mdl",
                Bone = "DC-15SA",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-2.6, 3.1, -2),
                    ang = Angle(0, 0, -90)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC-15SA",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 5, 12),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/dg29.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(80, -10, 10),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(150, 10, -50),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/dg29.mdl"

SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.05, -3.4, -2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(55, 21.5, -64),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(0.05, -0.5, 3.8),
            vang = Angle(90, 0, -90),
            wpos = Vector(130, 21.5, -48),
            wang = Angle(-15, 0, 180)
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.05, -1.65, 5.9),
            vang = Angle(90, 0, -90),
            wpos = Vector(163, 21.5, -72),
            wang = Angle(-15, 0, 180)

        },
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(0.2, -0.5, -4),
            vang = Angle(90, 0, -90),
            wpos = Vector(52, 23.5, -25),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.5, -1.5, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(120, 28, -60),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false
    },
    ["fire"] = {
        Source = {"Fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 105 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_dlt34.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = "Kraken"
SWEP.PrintName = "[MG] DLT-34"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The DLT-34 heavy blaster rifle was a model of heavy blaster rifle manufactured by BlasTech Industries. They were used by regular stormtroopers and Heavy Weapons Stormtroopers of the Galactic Empire, but they also saw use by other parties, including the Alliance to Restore the Republic and certain bounty hunters."
SWEP.IconOverride = "entities/sopsmisc/dlt34.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_dlt34.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_dlt34.mdl"
SWEP.ViewModelFOV = 60
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-7, 6, -8),
    ang = Angle(0, 5, 180)
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 25
SWEP.RangeMin = 150
SWEP.DamageMin = 10
SWEP.Range = 600
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 250

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 520

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 400
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 125
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/dlt34.wav"
SWEP.ShootSound = "sops-v2/weapons/dlt34.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)


-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.744, -10, 2.42),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "crossbow"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 1)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -7)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -5)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(0, 0, 0)
SWEP.HolsterAng = Vector(0, 0, 0)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "None", 
        Slot = "optic", 
        Bone = "dlt34",
        VMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(-0.1, -2.3, 6.3),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, -0.050),
    },   
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0, -0.9, 31.4),
            vang = Angle(90, 0, -90),
        },
    },   
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.7, -0.8, 24),
            vang = Angle(90, 0, 0),
        },
    },        
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.8, -1, 13),
            vang = Angle(90, 0, -90),
        },
    },       
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.9, -1, 10.9),
            vang = Angle(90, 0, -90),
        },
    },        
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "shoot",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 115 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_iondisruptor.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "T-7 Ion Disruptor"
SWEP.Trivia_Class = "Ion Disruptor"
SWEP.Trivia_Desc = "The T-7 ion disruptor rifle was a model of high-powered disruptor rifle designed to disable starships and take out multiple enemies at one time. The rifles would also have destructive effects when used on organic lifeforms. The rifles were responsible for the near-extinction of the Lasat species, and their destructive powers led the Imperial Senate to ban their use within the Galactic Empire. The rebel crew of the Ghost later stole a shipment of T-7 ion disruptors and destroyed them before they could fall into the hands of the Empire."
SWEP.IconOverride = "entities/sopsmisc/iondisruptor.png"

-- Viewmodel & Entity Properties
SWEP.HideViewmodel = false
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.ShootEntity = "emp_throwed"
SWEP.MuzzleVelocity = 3400

SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 2.5
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = true -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 1.7
SWEP.HeatFix = true -- when the "fix" animation is played, all heat is restored.

SWEP.ChamberSize = 0 
SWEP.Primary.ClipSize = 6
SWEP.ExtendedClipSize = 8
SWEP.ReducedClipSize = 2

SWEP.Recoil = 1.87
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 102

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 200

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "RPG_Round"
SWEP.MagID = "rpg7"

SWEP.ShootVol = 50
SWEP.ShootPitch = 60
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/disruptor/disruptor_fire.mp3"
SWEP.ShootSound = "sops-v2/weapons/disruptor/disruptor_fire.mp3"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 208)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -5, 0.5),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/ion_disruptor.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "0000000",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0.1, 2, -9),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 35, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/ion_disruptor.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                ModelBodygroups = "0000000",
                Offset = {
                    pos = Vector(140, 10, 40),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(430, 15, -150),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/ion_disruptor.mdl"

SWEP.Attachments = {     
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.8, -0.5, 2.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(80, 18, -75),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(1.1, 18, 0.6),
            vang = Angle(0, -90, 90),
            wpos = Vector(220, 23, -89),
            wang = Angle(-15, 0, -90)
        },
    },  
    {
        PrintName = "Rocket", 
        DefaultAttName = "None",
        Slot = {"ammo_rocket"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "None"
    },         
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(1.7, -2, 2.05),
            vang = Angle(0, -90, 0),
            wpos = Vector(65, 28, -68),
            wang = Angle(-15, 0, 180)
        },
    },    
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_md12x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "MD-12x"
SWEP.Trivia_Class = "Blaster-Experimental Shotgun"
SWEP.Trivia_Desc = "The MD-12x heavy shotgun, also known as MD-12 shotgun, was a heavy blaster shotgun wielded by the Clone Trooper 'Hunter' of the Grand Army of the Galactic Republic during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/sopsmisc/md12.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.UseHands = true
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.3,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 24 * 8
SWEP.RangeMin = 101
SWEP.DamageMin = 12 * 8
SWEP.Range = 202
SWEP.Penetration = 12
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 14

SWEP.Recoil = 0.76
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.56
SWEP.Delay = 60 / 201

SWEP.Num = 8
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 20
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 70
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/md12x.wav"
SWEP.ShootSound = "sops-v2/weapons/md12x.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.5, -5, 0),
    Ang = Angle(1, -0.9, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 4, -2)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/md12.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(-0.5, -4.5, -1),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-4, 26, -8),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/md12.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.9, 0.9, 0.9),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(50, 10, -30),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(240, 15, -100),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/md12.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.15, 0, 2.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(86, 14, -80),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(1.2, 9, 1),
            vang = Angle(0, -90, 90),
            wpos = Vector(190, 28, -90),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.15, 7, -4.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(180, 14, -29),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(18, 18, 18),
        VMScale = Vector(2, 2, 2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 15, 0.9),
            vang = Angle(0, -90, 0),
            wpos = Vector(274, 14, -112),
            wang = Angle(-15, 0, 180)
        },     
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(1.5, -2, 0.3),
            vang = Angle(0, -90, 0),
            wpos = Vector(72, 31, -50),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.5, -8, 0.3),
            vang = Angle(0, -90, 0),
            wpos = Vector(10, 32, -35),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_thelastword.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "'The Last Word'"
SWEP.Trivia_Class = "Blaster Revolver"
SWEP.Trivia_Desc = "Yours, until the last flame dies and all words have been spoken."
SWEP.IconOverride = "entities/sopsmisc/thelastword.png"

SWEP.HideViewmodel = false
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_the_last_word.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.WorldModelOffset = {
    pos = Vector(-19, 6, -5),
    ang = Angle(-10, 0, 180)
}

-- Damage & Entity options
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}


SWEP.Damage = 43
SWEP.RangeMin = 143
SWEP.DamageMin = 24
SWEP.Range = 298
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800

SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 125, 255)
SWEP.TracerWidth = 10
SWEP.PhysTracerProfile = "apex_bullet_energy"
SWEP.Tracer = "arccw_apex_tracer_energy_sniper"
SWEP.HullSize = 0.5
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8
SWEP.AmmoPerShot = 1

SWEP.Recoil = 1.63
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.62

SWEP.Delay = 60 / 170
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = 2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.MuzzleEffectAttachment = 1 
SWEP.ProceduralViewBobAttachment = 1
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ammo & Stuff
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 150
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/revolvers.wav"
SWEP.ShootSound = "sops-v2/weapons/revolvers.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.IronSightStruct = {
    Pos = Vector(-5.373, -11.532, 1.552),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 60,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "revolver"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_REVOLVER

SWEP.ActivePos = Vector(-1, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },      
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot"},
        Time = 0.9,
    },
    ["fire_iron"] = {
        ShellEjectAt = 0,
        Source = {"shoot"}
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_REVOLVER,
        SoundTable = {
            {s = "sops-v2/weapons/revolver_reload.wav", t = 0.1 / 30},
        },
    },
}
--addons/weapon_jedi/lua/weapons/arcknife_lscs.lua:
-- this script will add a pre-assembled lightsaber to your q-menu

AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category = "[LSCS]"
SWEP.PrintName = "ARC Knife"
SWEP.Author = "Rino Lauchi <3"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = false
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("arcknife")
		self:SetBladeR("arcsabermodel")
		self:SetStance("default")
	end
end
--lua/weapons/blood_sword/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Blood sword"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Blood"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +vampirism"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++++"] = { type = "Model", model = "models/gibs/hgibs_spine.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-2, 0, 4.9), angle = Angle(0, -90, 90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 16), angle = Angle(-90, 90, 0), size = Vector(0.5, 0.009, 0.1), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/gibs/hgibs_spine.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(2, 0, 4.9), angle = Angle(0, 90, 90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 27), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 3.7), color = Color(160, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/gibs/agibs.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 90, 0), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/gibs/agibs.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 90, 0), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/gibs/hgibs_spine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(2, 0, 4.9), angle = Angle(0, 90, 90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/gibs/hgibs_spine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-2, 0, 4.9), angle = Angle(0, -90, 90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 16), angle = Angle(-90, 90, 0), size = Vector(0.5, 0.009, 0.1), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 27), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 3.7), color = Color(160, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 45
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.5
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Blood"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 75
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.9
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Blood"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		self.Owner:SetHealth(math.Clamp(self.Owner:Health()+3,0,100))
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		self.Owner:SetHealth(math.Clamp(self.Owner:Health()+3,0,100))
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/gm_climbswep/lua/weapons/climb_swep2/cl_init.lua:
include("shared.lua")

CreateClientConVar("climbswep2_showhud", 1, true, false)
SWEP.PrintName       = "Climb SWEP 2"
SWEP.Slot             = 0
SWEP.SlotPos         = 4
SWEP.DrawAmmo         = false
SWEP.DrawCrosshair     = false

local flags = {FCVAR_REPLICATED, FCVAR_ARCHIVE};
CreateConVar("climbswep2_necksnaps", "0", flags);
CreateConVar("climbswep2_wallrun_minheight", "250", flags);
CreateConVar("climbswep2_roll_allweps", "0", flags);
CreateConVar("climbswep2_slide_allweps", "0", flags);
CreateConVar("climbswep2_maxjumps", "3", flags);
--addons/lvs_base/gamemodes/sandbox/entities/weapons/gmod_tool/stools/lvsaienabler.lua:

TOOL.Category		= "LVS"
TOOL.Name			= "#AI Enabler"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "team" ] = "-1"

if CLIENT then
	language.Add( "tool.lvsaienabler.name", "AI Enabler" )
	language.Add( "tool.lvsaienabler.desc", "A tool used to enable/disable AI on LVS-Vehicles" )
	language.Add( "tool.lvsaienabler.0", "Left click on a LVS-Vehicle to enable AI, Right click to disable." )
	language.Add( "tool.lvsaienabler.1", "Left click on a LVS-Vehicle to enable AI, Right click to disable." )
end

function TOOL:LeftClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if isfunction( ent.SetAI ) then
		ent:SetAI( true )
	end

	if SERVER then
		local Team = self:GetClientNumber( "team" )

		if Team ~= -1 then
			ent:SetAITEAM( math.Clamp( Team, 0, 3 ) )
		end
	end

	return true
end

function TOOL:RightClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if isfunction( ent.SetAI ) then
		ent:SetAI( false )
	end

	return true
end

function TOOL:Reload( trace )
	return false
end

function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl( "Header", { Text = "#tool.lvsaienabler.name", Description	= "#tool.lvsaienabler.desc" }  )

	CPanel:AddControl( "Slider", { Label = "TeamOverride", Type = "Int", Min = -1, Max = 3, Command = "lvsaienabler_team" } )
end

--addons/tools/lua/weapons/gmod_tool/stools/prop_healthifier.lua:
-- Made for Excalibur Networks by Keegan
TOOL.Category = "Construction"
TOOL.Name = "Prop Healthifier"
TOOL.ClientConVar["health"] = "100"
TOOL.ClientConVar["shields_enabled"] = "0"
TOOL.ClientConVar["shields"] = "100"
TOOL.ClientConVar["explosion_amount"] = "1"
TOOL.ClientConVar["explosion_type"] = "lvs_explosion"
TOOL.ClientConVar["explosion_final"] = "0"
TOOL.ClientConVar["explosion_final_type"] = "h_blu82"
TOOL.ClientConVar["explosion_final_sound"] = "gbombs_5/explosions/daisy/daisy_explo.wav"
TOOL.ClientConVar["regen_enabled"] = "0"
TOOL.ClientConVar["regen_delay"] = "60"
TOOL.ClientConVar["regen_percent"] = "0.1"

TOOL.Information = {
	{
		name = "info",
		stage = 1
	},
	{
		name = "left"
	},
	{
		name = "right"
	}
}

if (CLIENT) then
	language.Add("tool.prop_healthifier.name", "Prop Healthifier")
	language.Add("tool.prop_healthifier.desc", "Convert a prop into an entity with health and shields")
	language.Add("tool.prop_healthifier.left", "Healthify Prop")
	language.Add("tool.prop_healthifier.right", "De-Healthify Prop")
end

function TOOL:TransferEnt(player, old_ent, desired_class)
	local new_ent = ents.Create(desired_class)
	new_ent:SetPos(old_ent:GetPos())
	new_ent:SetAngles(old_ent:GetAngles())
	new_ent:SetModel(old_ent:GetModel())
	new_ent:SetMaterial(old_ent:GetMaterial())

	if CPPI then
		new_ent:CPPISetOwner(player)
	end

	old_ent:Remove()
	return new_ent
end

function TOOL:LeftClick(trace)
	if not (trace.Entity:GetClass() == "prop_physics") then return false end
	if (CLIENT) then return true end

	local PROP_HEALTH = tonumber(self:GetClientInfo("health"))
	local PROP_SHIELDS = tonumber(self:GetClientInfo("shields"))
	local PROP_EXPLOSION_AMOUNT = tonumber(self:GetClientInfo("explosion_amount"))
	local PROP_EXPLOSION_TYPE = tostring(self:GetClientInfo("explosion_type"))
	local PROP_EXPLOSION_FINAL = tobool(self:GetClientInfo("explosion_final"))
	local PROP_EXPLOSION_FINAL_TYPE = tostring(self:GetClientInfo("explosion_final_type"))
	local PROP_EXPLOSION_FINAL_SOUND = tostring(self:GetClientInfo("explosion_final_sound"))
	local PROP_REGEN_ENABLED = tobool(self:GetClientInfo("regen_enabled"))
	local PROP_REGEN_DELAY = tonumber(self:GetClientInfo("regen_delay"))
	local PROP_REGEN_PERCENT = tonumber(self:GetClientInfo("regen_percent"))

	local ent = self:TransferEnt(self:GetOwner(), trace.Entity, "healthified_prop")
	ent:SetHealth(PROP_HEALTH)
	ent:SetMaxHealth(PROP_HEALTH)
	ent:SetShields(PROP_SHIELDS)
	ent:SetMaxShields(PROP_SHIELDS)
	ent.ExplosionAmount = PROP_EXPLOSION_AMOUNT
	ent.ExplosionType = PROP_EXPLOSION_TYPE
	ent.ExplosionFinal = PROP_EXPLOSION_FINAL
	ent.ExplosionFinalType = PROP_EXPLOSION_FINAL_TYPE
	ent.ExplosionFinalSound = PROP_EXPLOSION_FINAL_SOUND
	ent.RegenEnabled = PROP_REGEN_ENABLED
	ent.RegenDelay = PROP_REGEN_DELAY
	ent.RegenPercent = PROP_REGEN_PERCENT
	ent:Spawn()

	if (not ent:IsValid()) then return true end
	
	local phys = ent:GetPhysicsObject()
	if phys:IsValid() then
		phys:EnableMotion(false)
	end

	undo.Create("Healthified Prop")
	undo.AddEntity(ent)
	undo.SetPlayer(self:GetOwner())
	undo.Finish()
	self:GetOwner():AddCleanup("sents", ent)

	return true
end

function TOOL:RightClick(trace)
	if not (trace.Entity:GetClass() == "healthified_prop") then return false end
	if (CLIENT) then return true end

	local prop = self:TransferEnt(self:GetOwner(), trace.Entity, "prop_physics")
	prop:Spawn()

	if (not prop:IsValid()) then return true end
	
	local phys = prop:GetPhysicsObject()
	if phys:IsValid() then
		phys:EnableMotion(false)
	end

	undo.Create("Prop")
	undo.AddEntity(prop)
	undo.SetPlayer(self:GetOwner())
	undo.Finish()
	self:GetOwner():AddCleanup("props", ent)
	
	return true
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
	-- START PRESET DROPDOWN --
	local Preset = vgui.Create("ControlPresets")
	Preset:SetPreset("prop_healthifier")
	Preset:AddOption("Default", ConVarsDefault)

	for _, v in pairs(table.GetKeys(ConVarsDefault)) do
		Preset:AddConVar(v)
	end

	CPanel:AddPanel(Preset)
	-- END PRESET DROPDOWN --
	CPanel:NumSlider("Health", "prop_healthifier_health", 1, 10000, 0)
	CPanel:NumSlider("Shields", "prop_healthifier_shields", 0, 10000, 0)
	CPanel:CheckBox("Shield Regen Enabled?", "prop_healthifier_regen_enabled")
	CPanel:NumSlider("Shield Regen Delay", "prop_healthifier_regen_delay", 1, 1000, 0)
	CPanel:NumSlider("Shield Regen Percent", "prop_healthifier_regen_percent", 0.01, 1, 2)
	CPanel:NumSlider("Number of Explosions", "prop_healthifier_explosion_amount", 0, 10, 0)

	local SmallExplosionBox, SmallExplosionBoxLabel = CPanel:ComboBox("Regular Explosion Type: ", "prop_healthifier_explosion_type")
	SmallExplosionBoxLabel:SizeToContents()
	local explosionTypes = {
		["Small"] = "lvs_explosion_small",
		["Bomb"] = "lvs_explosion_bomb",
		["No Debris"] = "lvs_explosion_nodebris",
		["Normal"] = "lvs_explosion",
	}
	for k, v in pairs(explosionTypes) do
		SmallExplosionBox:AddChoice(k, v)
	end

--[[ 	CPanel:CheckBox("Big Final Explosion", "prop_healthifier_explosion_final")
	local BigExplosionBox, BigExplosionBoxLabel = CPanel:ComboBox("Final Explosion Type: ", "prop_healthifier_explosion_final_type")
	BigExplosionBoxLabel:SizeToContents()
	local bigExplosionTypes = {
		["BLU-82"] = {"h_blu82", "gbombs_5/explosions/daisy/daisy_explo.wav"},
		["Combine Bomb"] = {"combine_explo", "gbombs_5/explosions/special/blackhole_effect.mp3"},
		["500lb"] = {"h_500lb", "gbombs_5/explosions/medium_bomb/explosion_medium.mp3"},
		["Fuel Bomb"] = {"h_fab", "gbombs_5/explosions/heavy_bomb/ex2.mp3"},
		["JDAM"] = {"h_shockwave", "gbombs_5/explosions/heavy_bomb/explosion_big_6.mp3"},
	}
	for k, v in pairs(bigExplosionTypes) do 
		BigExplosionBox:AddChoice(k, v)
	end
	function BigExplosionBox:OnSelect(index, text, data)
		RunConsoleCommand("prop_healthifier_explosion_final_type", data[1])
		RunConsoleCommand("prop_healthifier_explosion_final_sound", data[2])
	end ]]
end

--addons/tools/lua/includes/modules/af_derma_extension.lua:
-- DermaMenu hook extension by Zaurzo
-- idk why i had to do this just to add one derma button

-- I put this file in includes/modules so you can only require it once so the 'DMenu:Open()' detour doesn't stack
-- If you want to use this hook, make sure this file is in includes/modules, and put this somewhere in your code:
--
-- if CLIENT then
--     require('af_derma_extension') 
-- end

-- ^^^ thank you Zaurzo, this is a dream

local type = type
local debug_getupvalue = debug.getupvalue

timer.Simple(0, function()
    local DMenu = vgui.GetControlTable('DMenu')
    local Open = DMenu.Open

    function DMenu:Open(...)
        Open(self, ...)

        local options, contentIcon = self:GetChildren()[1]

        if IsValid(options) then
            options = options:GetChildren()

            if options then
                for k, option in ipairs(options) do
                    local func = option.DoClick
        
                    if func then
                        for i = 1, 10 do
                            local k, v = debug_getupvalue(func, i)
                            if not k then break end
        
                            if type(v) == 'Panel' and IsValid(v) then
                                local name = v:GetName()

                                if name == 'ContentIcon' or name == 'SpawnIcon' then
                                    contentIcon = v
                                    break
                                end
                            end
                        end
        
                        if contentIcon then
                            hook.Run('AF.ContentIconMenuExtraOpened', contentIcon, self)
                            break
                        end
                    end
                end
            end
        end
    end
end)
--lua/weapons/gold_knucle/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "Gold, because you can afford it!"
SWEP.Instructions = "Kick their ass!"

SWEP.ShowWorldModel = false
SWEP.PrintName = "Golden knuckle"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 60
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "knife"

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 41
SWEP.Primary.DelayMiss = 0.7
SWEP.Primary.DelayHit = 0.9
SWEP.Primary.Force = 3000

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}


SWEP.VElements = {
	["part1"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0.05, 0.2, 1.5), angle = Angle(180, 90, -90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 1.299, 3), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.2, 2), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} },
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2, -0.301), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.599, 0.899), angle = Angle(0, 180, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} }
}




SWEP.WElements = {
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, 0), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, -1.5), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 1.2), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} },
	["part1"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 0), angle = Angle(0, 0, 90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, -2.3), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "models/screenspace", skin = 0, bodygroup = {} }
}



function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "Weapon_HL_Crowbar.Miss" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 64
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 0
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "Flesh.ImpactHard" )
else
self.Owner:EmitSound( "Weapon_HL_Crowbar.Hit" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end






/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--addons/weapons_other/lua/weapons/jet_mk6.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Jetpack Unbegrenzt"
SWEP.Category	= "Star Wars Jetpacks"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Fuel" )
	if ( SERVER ) then
		self:SetFuel(100)
	end
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end



function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if IsValid(ex) then
		ex:Remove()
		ply:SetNWEntity('Jetted',NULL)
		ply.LastJetExecuted = CurTime()
	else
		if !ply:IsOnGround() then return end
		--if (ply.LastJetExecuted or 0)+20 >= CurTime() then return end
		local jp = ents.Create('mk6')
		jp:SetSlotName('mk6')
		jp:Spawn()
		jp:Attach(ply)
		ply.Jetted = jp
		ply:SetNWEntity('Jetted',jp)
	end
	ply:EmitSound('buttons/button14.wav')
end

local skinint = 1

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if !IsValid(ex) then return end
	skinint = (skinint + 1)%3
	ex:SetSkin(skinint)
	ply:EmitSound('')
end

function SWEP:Deploy()
	return true
end

function SWEP:Equip()

end

function SWEP:ShouldDropOnDie() return false end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--addons/arccw_weapons/lua/weapons/masita_dc15s_grenadier.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Grenadier DC-15s"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s_grenadier.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.6,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 198
SWEP.DamageMin = 21
SWEP.Range = 399
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 255

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Grenade Launcher",
        DefaultAttName = "None",
        Slot = "rep_ubgl",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1, 1.663),
            vang = Angle(90, 0, -90),
        },          
    },
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15",
        Slot = "stock",
        Offset = {
            vpos = Vector(0, 0.5, -9.1),
            vang = Angle(0, 0, -90),
        },
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}
--addons/arccw_weapons/lua/weapons/masita_dc15s_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Stun DC-15s"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s_stun.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.6,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 198
SWEP.DamageMin = 21
SWEP.Range = 399
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 255

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 0, 5.100),
        vmax = Vector(-0.2, 0, 9),
        },          
    },
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15",
        Slot = "stock",
        Offset = {
            vpos = Vector(0, 0.5, -9.1),
            vang = Angle(0, 0, -90),
        },
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo", "sw_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}
--addons/arccw_weapons/lua/weapons/masita_dc17s_red.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17s [Red]"
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17s hand blaster, also known as DC-17s blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers. This one version is a powerful one."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17s_red.png"

-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapon/ven/ggn/dc17s_single.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.DefaultSkin = 0

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.AutoReload = true
SWEP.Damage = 32
SWEP.RangeMin = 133
SWEP.DamageMin = 16
SWEP.Range = 550
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20
SWEP.Recoil = 0.5
SWEP.RecoilPunch = 0.3
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17
SWEP.Delay = 60 / 337
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },    
}
SWEP.AccuracyMOA = 0.57
SWEP.HipDispersion = 576
SWEP.MoveDispersion = 53

-- Sounds & Muzzleflash
SWEP.ShootSound = "armas/disparos/dc17s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"
SWEP.NoFlash = nil 

SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)


-- Ironsight & Holdtype
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.IronSightStruct = {
    Pos = Vector(-3.947, 1.389, 0.526),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 60,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)


-- Attachments
SWEP.DefaultElements = {"dc17s"}
SWEP.AttachmentElements = {
    ["dc17s"] = { 
        WMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelSkin = 0,
                Offset = {
                    pos = Vector(450, 50, -100),
                    ang = Angle(0, -10, -180),
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(1900, 200, -200),
                    ang = Angle(0, -10, 180)
                },
                IsMuzzleDevice = true
            }, 
        },
    },
}
WMOverride = "models/weapon/ven/ggn/dc17s_single_world.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight", -- name of the attachment
        DefaultAttName = "Standard", -- default name (like: 'default', 'none', 'standard')
        Slot = "optic", -- slots, you can add attachments per slot using this: Slot = {"optic", "optics", "etc"},
        Bone = "DC17S_Root",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(0.001, -1.9, -2.32),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 100, -475),
            wang = Angle(0, -10, 180)
        },
    },
    {
        PrintName = "Laser/Flashlight", 
        DefaultAttName = "None",
        Slot = {"tac_pistol", "tactical"},
        Bone = "DC17S_Root",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(-0.101, 0.557, 7.738),
            vang = Angle(90, 0, -90),
            wpos = Vector(1450, 265, -175),
            wang = Angle(0, -10, 180)
        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk", 
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "DC17S_Root",
        Offset = {
            vpos = Vector(0.768, -0.238, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(750, 225, -350),
            wang = Angle(0, -10, 180)
        },
    },          
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["sprint"] = {
        Source = "base_sprint_loop"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "armas/misc/dc17s_draw.wav",
                p = 100,
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armas/misc/dc17s_holster.wav",
                p = 100, 
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL, 
        SoundTable = {
            {s = "dc17s_1", t = 1 / 30},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL, 
        SoundTable = {
            {s = "dc17s_2", t = 4 / 30},
        },
    },


sound.Add({
    name =          "dc17s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
sound.Add({
    name =          "dc17s_2",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armas/misc/dc17s_empty.wav"
    }),
}


--addons/arccw_weapons/lua/weapons/masita_westarm5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita/Meeks"
SWEP.PrintName = "Westar M-5"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "The WESTAR-M5 blaster rifle was a blaster rifle used during the Clone Wars by the Grand Army of the Republic. They were mainly used by the Alpha-class Advanced Recon Commandos during the later years of the conflict."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/westarm5.png"

SWEP.ViewModel = "models/ser/starwars/c_westarm5.mdl"
SWEP.WorldModel = "models/ser/starwars/w_westarm5.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 1
SWEP.DefaultWMSkin = 1

SWEP.NoHideLeftHandInCustomization = false

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1.3,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 36
SWEP.DamageMin = 22 -- damage done at maximum range
SWEP.RangeMin = 170 -- how far bullets will retain their maximum damage for
SWEP.Range = 290 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false

SWEP.MuzzleVelocity = 472

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3
SWEP.TracerNum = 1 
SWEP.TracerFinalMag = 0 
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 47, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 50 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0
SWEP.MaxRecoilBlowback = 1
SWEP.VisualRecoilMult = 1

SWEP.RecoilDirection = Angle(0.2, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 527 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 447 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 60 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 157 -- dispersion that remains even in sights
SWEP.JumpDispersion = 220 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dlt20.wav"
SWEP.ShootSound = "everfall/weapons/dlt-20a/blasters_dlt20a_laser_close_var_01.mp3"
SWEP.ShootSoundSilenced = "everfall/weapons/deadeye/blasters_deadeye_laser_close_var_01.mp3"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil

SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.MuzzleEffectAttachment = 1 
SWEP.ProceduralViewBobAttachment = 1
SWEP.MuzzleFlashColor = Color(0, 102, 255)

SWEP.SpeedMult = 0.87
SWEP.SightedSpeedMult = 0.77
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -0, 2.1),
    Ang = Angle(0, 0, 0),
    Midpoint = {
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1.2,
    SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
    SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0


SWEP.Malfunction = false
SWEP.MalfunctionJam = true 
SWEP.MalfunctionTakeRound = true 
SWEP.MalfunctionWait = 0.5 
SWEP.MalfunctionMean = nil 
SWEP.MalfunctionVariance = 0.25
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 27
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2
SWEP.SprintPos = Vector(.5, -6, -12)
SWEP.SprintAng = Angle(40, 0, 0)
SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)
SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)
SWEP.ActivePos = Vector(0, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)
SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.CustomizePos = Vector(6.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)
SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        WMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(15, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, 
    },
}

SWEP.Attachments = {
	{
		PrintName = "Sight",
		DefaultAttName = "Standard",
		Slot = "optic",
		Bone = "weapon",
		Offset = {
            vpos = Vector(0.02, -2.4, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1, -7),
            wang = Angle(-10, 2, 180)
        },
	},
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(0.8, -0.8, 4),
            vang = Angle(90, 0, -0),
            wpos = Vector(7, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
    },
    {
        PrintName = "Charms", 
        DefaultAttName = "None",
        Slot = {"charm"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(1, -1, -3.2),
            vang = Angle(90, 0, -90),
            wpos = Vector(1.2, 2.2, -4.5),
            wang = Angle(0, 0, 180)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "No Attachment", 
        Slot = "foregrip",
        Bone = "weapon",
        Offset = {
            vpos = Vector(0, 2.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, -1.5),
            wang = Angle(0, 0, 180)            
        },
        NoWM = true,
        NoVM = true,    
    },
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk", 
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(0, -0.9, 8.1),
            vang = Angle(90, 0, 0),
            wpos = Vector(16, .5, -7.2),
            wang = Angle(-10, 0, -90)
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "fire",
    },
	["idle_sights"] = {
        Source = "idle",
        Mult = 10000,
    },
	["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {s = "armas/misc/westar_reload.mp3", t = 0.1 }
        },
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "everfall/weapons/handling/023d-00000d8c.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/star_wars_mortar/lua/weapons/mortar_constructor/shared.lua:
AddCSLuaFile()

SWEP.PrintName = "Mortar"
SWEP.Base = "weapon_base"

SWEP.Author = "DolUnity"
SWEP.Purpose = "Place a Mortar"
SWEP.Instructions = "Place the mortar with attack \nPick it up with duck and use"
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Spawnable = true
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true
SWEP.DrawAmmo = false

SWEP.Slot = 4

SWEP.Primary.ClipSize = 0
SWEP.Primary.DefaultClipSize = 0

SWEP.Secondary.ClipSize = 0
SWEP.Secondary.DefaultClipSize = 0

if (CLIENT) then
    SWEP.PreviewModel = ClientsideModel("models/dolunity/starwars/mortar.mdl")
    SWEP.PreviewModel:SetNoDraw(true)
    SWEP.PreviewModel:SetMaterial("models/wireframe")
end

function SWEP:PrimaryAttack()
    if (SERVER) then
        local ply = self.Owner
        if (ply:Alive() and IsValid(ply:GetActiveWeapon()) and (ply:GetActiveWeapon():GetClass() or ""):StartWith("mortar_constructor")) then
            local trace = ply:GetEyeTrace()
            local hitAngle = trace.HitNormal:Angle()

            local ent = ents.Create("mortar")
            ent:SetPos(trace.HitPos)
            ent:SetAngles(Angle(0,0,0))

            ent:SetLocalAngles(ent:WorldToLocalAngles(hitAngle) + Angle(90,0,0))

            ent:Spawn()
            if (ent:GetLocalAngles().x > 45 or ent:GetLocalAngles().z > 45) then
                ent:Remove()
            else
                ply:StripWeapon(self:GetClass())
            end
            self:OnSpawn(ent)
        end
    end
end

function SWEP:OnSpawn(ent)
end

function SWEP:SecondaryAttack() end

function SWEP:ShouldDrawViewModel()
    return false
end

function SWEP:DrawWorldModel()
end

hook.Add("PostDrawOpaqueRenderables", "DrawMortarPreview", function ()
    local ply = LocalPlayer()
    if (ply:Alive()
            and IsValid(ply:GetActiveWeapon())
            and (ply:GetActiveWeapon():GetClass() or ""):StartWith("mortar_constructor")
            and not ply:InVehicle()) then
        local weapon = ply:GetActiveWeapon()
        local trace = LocalPlayer():GetEyeTrace()
        weapon.PreviewModel:SetPos(trace.HitPos)
        weapon.PreviewModel:SetAngles(Angle(0,0,0))

        local hitAngle = trace.HitNormal:Angle()
        weapon.PreviewModel:SetLocalAngles(weapon.PreviewModel:WorldToLocalAngles(hitAngle) + Angle(90,0,0))

        if (weapon.PreviewModel:GetLocalAngles().x > 45 or weapon.PreviewModel:GetLocalAngles().z > 45) then
            weapon.Placeable = false
            render.SetColorModulation(255/255,0,0)
        else
            weapon.Placeable = true
            render.SetColorModulation(0,180/255,25/255)
        end
        weapon.PreviewModel:DrawModel()
        render.SetColorModulation(0,0,0)
    end
end)
--addons/weapon_jedi/lua/weapons/weapon_lightsaber_ventress.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Asajj Ventress"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
        self:SetHiltL("ventress")
		self:SetHiltR("ventress")
		self:SetBladeL("red")
        self:SetBladeR("red")

        self:SetStance("jarkai")
	end
end

if CLIENT then return end 

function SWEP:ForcePowersGive(ply)
	ply:lscsWipeInventory()

	ply:lscsAddInventory("item_force_leap", true)
    ply:lscsAddInventory("item_force_push", true)
	ply:lscsAddInventory("item_force_pull", true)
	ply:lscsAddInventory("item_force_choke", true)
    ply:lscsAddInventory("item_force_sprint", true)
    ply:lscsAddInventory("item_force_breach", true)
    ply:lscsAddInventory("item_force_mindtrick", true)
    ply:lscsAddInventory("item_force_unarm", true)
    ply:lscsAddInventory("item_force_whirlwind", true)
end

function SWEP:Deploy() 
	BaseClass.Deploy(self)
	if not IsValid(self:GetOwner()) then return end

    self:GetOwner():lscsWipeInventory()

	self:ForcePowersGive(self:GetOwner())
end
--addons/aoc_nextbots/lua/weapons/weapon_npc_e5s.lua:
AddCSLuaFile()

SWEP.Base   = "weapon_summes_npcbase"

SWEP.PrintName = "NPC: E5s"
SWEP.Spawnable = false
SWEP.Author = "Summe"

SWEP.WorldModel = "models/arccw/kuro/sw_battlefront/weapons/e5s_c_blaster.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 1
SWEP.Damage = 80
SWEP.Tracer = "effect_npc_laser_red"
SWEP.ImpactEffect = "rw_sw_impact_red"
SWEP.Sound = "everfall/weapons/blasters/e-5/e5.wav"
SWEP.ClipSize = 3
SWEP.Spread = 0


--addons/weapons_other/lua/weapons/wookie_swep.lua:
AddCSLuaFile()

SWEP.PrintName			= "Wookie SWEP"
SWEP.Author				= "Rino" 
SWEP.Instructions		= [[
R - Gebrüll
LMB - Attacke mit Gebrüll
RMB - Festhalten mit Gebrüll
	]]
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Category	= "AOCRP - Soundsweps"

SWEP.AnimPrefix = "rpg"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo		= "none"
SWEP.Primary.Distance		= 100
SWEP.Primary.Delay			= 1
SWEP.Primary.Damage			= 40

SWEP.stunTime = 2.5;
 
SWEP.HoldType			= "idle"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"
SWEP.Secondary.Delay	= 2

SWEP.Weight			= 5
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.Slot			= 1
SWEP.SlotPos			= 1
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModel			= "models/weapons/c_medkit.mdl"
SWEP.WorldModel	= ""



local Stunsound = "weapons/wookie_swep/gt3.mp3"
local Attackensound = "weapons/wookie_swep/gt1.mp3"
local Gebrüllsound = "weapons/wookie_swep/gt2.mp3"

function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()
	local tr = self.Owner:GetEyeTrace().Entity
		if not tr:IsValid() then return end
		if tr:GetPos():Distance( self.Owner:GetPos() ) > self.Primary.Distance then return end
		--if not tr:IsPlayer() then return end
			if SERVER then
				net.Start("massifstun") net.WriteEntity(self.Owner) net.Broadcast();
				self.Owner:EmitSound( Attackensound )
				tr:TakeDamage( self.Primary.Damage, self.Owner, self)
			end
			self:EmitSound( Attackensound )
			self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
end


function SWEP:Reload()
	self:EmitSound( Gebrüllsound )
	self:SetNextSecondaryFire( CurTime() + 3)
end

function SWEP:SecondaryAttack()
	self:EmitSound( Stunsound )
	self:SetNextSecondaryFire( CurTime() + 2 )
 	if CLIENT then return end;
 	net.Start("massifstun") net.WriteEntity(self.Owner) net.Broadcast();
	local tr = self.Owner:GetEyeTrace()
	if !tr.Entity then return false end
	if tr.Entity:IsPlayer() then
		if tr.Entity:GetPos():Distance(self.Owner:GetPos()) < 300 then 
			if !tr.Entity:IsValid() then return false end
			tr.Entity:TakeDamage( 0, self.Owner, self)
			self:FreezeEnemy(tr.Entity)
		end
	end
end



function SWEP:FreezeEnemy(ply)
	if ply:IsPlayer() then
		ply:Freeze(true)
		timer.Create('unfreezemeswepmassif'..tostring(ply:EntIndex()),self.stunTime,1,function()
			if IsValid(ply) then ply:Freeze(false) end
		end)
	end
end



if SERVER then
	util.AddNetworkString("massifstun");
end

net.Receive('massifstun',function()
	local ply = net.ReadEntity();
	if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end;
	ply:AnimRestartGesture( GESTURE_SLOT_GRENADE,ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND, true );
end)

function SWEP:PreDrawViewModel( vm, pl, wep )
	return true
end
--gamemodes/starwarsrp/entities/entities/aoc_ammobox.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Munitionskiste"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/reizer_props/srsp/sci_fi/crate_01/crate_01.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


            local phys = self:GetPhysicsObject()
        if (phys:IsValid()) then
            phys:Wake()
        end
    end
    
    function ENT:Use( activator, caller )
        wep = activator:GetActiveWeapon()
        if wep then
            activator:GiveAmmo(9999, wep:GetPrimaryAmmoType())
            activator:GiveAmmo(9999, wep:GetSecondaryAmmoType())
        end
    end


end


--gamemodes/starwarsrp/entities/entities/aoc_unitmarker.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Spawn (Einheit)"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP - Spawns"
ENT.Spawnable       = true
ENT.Editable = true

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/hunter/plates/plate1x1.mdl" )
        self:DrawShadow( false )
        self:SetColor(Color(0,255,0))
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end


function ENT:SetupDataTables()


    
    local editTbl = {}

    if AOCRP.Units then
        for k, v in pairs(AOCRP.Units) do
            editTbl[v.name] = v.unitid
        end
    end
	self:NetworkVar( "Int", 0, "Einheit", { KeyName = "einheit",	Edit = { type = "Combo", order = 1, text = "", values=editTbl} } ) 

	if SERVER then
		self:SetEinheit(1)
	end
end


if CLIENT then

    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 
        end
    end

end
--addons/arccw_base_modified/lua/entities/arccw_ammo_buckshot.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Shotgun Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/shotgun_ammo.mdl"

ENT.AmmoType = "buckshot"
ENT.AmmoCount = 20
if engine.ActiveGamemode() == "terrortown" then
    ENT.AmmoCount = 12
end

ENT.DetonationDamage = 80
ENT.DetonationRadius = 128
ENT.DetonationSound = "weapons/shotgun/shotgun_fire6.wav"
--addons/arccw_weapons/lua/entities/arccw_rocket_follow/shared.lua:
ENT.Type 				= "anim"
ENT.Base 				= "lvs_missile"
ENT.PrintName 			= "RPG-7 HEAT Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable 			= false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0

if SERVER then
    function ENT:Initialize()
        local pb_vert = 1
        local pb_hor = 1
        self:SetModel(self.Model)
        self:PhysicsInitBox(Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor))

        self.motorsound = CreateSound( self, "weapons/rpg/rocket1.wav")
        self.motorsound:Play()
    end

    function ENT:OnRemove()
        self.motorsound:Stop()
    end

    function ENT:Detonate()
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
    
        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
            self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
        else
            util.Effect( "Explosion", effectdata)
            self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
        end
    
        local attacker = self
    
        if self.Owner:IsValid() then
            attacker = self.Owner
        end
    
        util.BlastDamage(self, attacker, self:GetPos(), 100, 7000)
        util.BlastDamage(self, attacker, self:GetPos(), 300, 200)
    
        self:FireBullets({
            Attacker = attacker,
            Damage = 0,
            Tracer = 0,
            Distance = 20000,
            Dir = self:GetVelocity(),
            Src = self:GetPos(),
            Callback = function(att, tr, dmg)
                util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
            end
        })
    
        SafeRemoveEntityDelayed(self, FrameTime())
    end
end

if CLIENT then
    function ENT:Think()
        if self.Ticks % 5 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
end

function ENT:Draw()
    cam.Start3D()
        render.SetMaterial(Material("effects/blueflare1"))
        render.DrawSprite(self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 225, 175))
    cam.End3D()
end
--addons/arccw_base_modified/lua/entities/arccw_smoke/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Smoke Cloud"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

local smokeimages = {"particle/smokesprites_0002", "particle/smokesprites_0003", "particle/smokesprites_0004", "particle/smokesprites_0005", "particle/smokesprites_0006", "particle/smokesprites_0007", "particle/smokesprites_0008", "particle/smokesprites_0009", "particle/smokesprites_0010", "particle/smokesprites_0011", "particle/smokesprites_0012", "particle/smokesprites_0013", "particle/smokesprites_0014", "particle/smokesprites_0015", "particle/smokesprites_0016"}

local function GetSmokeImage()
    return smokeimages[math.random(#smokeimages)]
end

ENT.Particles = nil
ENT.SmokeRadius = 256
ENT.SmokeColor = Color(150, 150, 150)
ENT.BillowTime = 1
ENT.Life = 15

ENT.ArcCWSmoke = true

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/weapons/w_eq_smokegrenade_thrown.mdl" )
        self:SetMoveType( MOVETYPE_NONE )
        self:SetSolid( SOLID_NONE )
        self:DrawShadow( false )
    else
        local emitter = ParticleEmitter(self:GetPos())

        self.Particles = {}

        local amt = 20

        for i = 1, amt do
            local smoke = emitter:Add(GetSmokeImage(), self:GetPos())
            smoke:SetVelocity( VectorRand() * 8 + (Angle(0, i * (360 / amt), 0):Forward() * 400) )
            smoke:SetStartAlpha( 0 )
            smoke:SetEndAlpha( 255 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( self.SmokeRadius )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( self.SmokeColor.r, self.SmokeColor.g, self.SmokeColor.b )
            smoke:SetAirResistance( 75 )
            smoke:SetPos( self:GetPos() )
            smoke:SetCollide( true )
            smoke:SetBounce( 0.2 )
            smoke:SetLighting( false )
            smoke:SetNextThink( CurTime() + FrameTime() )
            smoke.bt = CurTime() + self.BillowTime
            smoke.dt = CurTime() + self.BillowTime + self.Life
            smoke.ft = CurTime() + self.BillowTime + self.Life + math.Rand(2.5, 5)
            smoke:SetDieTime(smoke.ft)
            smoke.life = self.Life
            smoke.billowed = false
            smoke.radius = self.SmokeRadius
            smoke:SetThinkFunction( function(pa)
                if !pa then return end

                local prog = 1
                local alph = 0

                if pa.ft < CurTime() then
                    return
                elseif pa.dt < CurTime() then
                    local d = (CurTime() - pa.dt) / (pa.ft - pa.dt)

                    alph = 1 - d
                elseif pa.bt < CurTime() then
                    alph = 1
                else
                    local d = math.Clamp(pa:GetLifeTime() / (pa.bt - CurTime()), 0, 1)

                    prog = (-d ^ 2) + (2 * d)

                    alph = d
                end

                pa:SetEndSize( pa.radius * prog )
                pa:SetStartSize( pa.radius * prog )

                pa:SetStartAlpha(255 * alph)
                pa:SetEndAlpha(255 * alph)

                pa:SetNextThink( CurTime() + FrameTime() )
            end )

            table.insert(self.Particles, smoke)
        end

        emitter:Finish()
    end

    self.dt = CurTime() + self.Life + self.BillowTime
end

function ENT:Think()

    if SERVER then
        local targets = ents.FindInSphere(self:GetPos(), 256)
        for _, k in pairs(targets) do
            if k:IsNPC() then
                k:SetSchedule(SCHED_STANDOFF)
            end
        end
    end

    if self.dt < CurTime() then
        if SERVER then
            SafeRemoveEntity(self)
        end
    end
end

function ENT:Draw()
    return false
end
--lua/entities/arccw_uc_40mm_smoke.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_40mm_he"
ENT.PrintName = "40mm Smoke Grenade"

ENT.GrenadeDamage = 50
ENT.GrenadeRadius = 150
ENT.ExplosionEffect = false
ENT.Scorch = false

function ENT:DoDetonation()

    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())

    if self:WaterLevel() >= 1 then
        util.Effect("WaterSurfaceExplosion", effectdata)
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        effectdata:SetMagnitude(4)
        effectdata:SetScale(1)
        effectdata:SetRadius(4)
        effectdata:SetNormal(self:GetVelocity():GetNormalized())
        util.Effect("Sparks", effectdata)
        self:EmitSound("physics/metal/metal_box_break1.wav", 100, 200, 0.5)
    end

    -- TODO: these sounds need to be replaced (dependency)!
    self:EmitSound("weapons/arccw/smokegrenade/smoke_emit.wav", 90, 100, 1, CHAN_AUTO)

    local cloud = ents.Create( "arccw_smoke" )

    if !IsValid(cloud) then return end

    cloud:SetPos(self:GetPos())
    cloud:Spawn()

end
--addons/weapons_other/lua/entities/boots_base.lua:
AddCSLuaFile()

--[[
	An entity base that allows you to create entity that can be equipped by the player as if they were weapons or powerups, but that can still
	function when not picked up by a player

	For instance you could make a jetpack that flies off when the equipping player dies, or you can make a controllable plane but still allow
	full movement on the player

	This file is licensed under the MIT license, so go nuts.
]]

DEFINE_BASECLASS( "base_entity" )

ENT.UseNWVars = false

ENT.Spawnable = false
ENT.IsPredictedEnt = true
ENT.AttachesToPlayer = true	--whether this entity attaches to the player or not, when true this removes physics and draws the entity on the player

ENT.SaveButtonToCvar = false

if SERVER then
	ENT.DropOnDeath = false
	ENT.ShowPickupNotice = true	--plays the pickup sound and shows the pickup message on the hud
	ENT.DontTransmitToOthers = false --when true, don't transmit to anyone except the owner, this MIGHT conflict with addons that make use of SetPreventTransmit, so mind that!
	ENT.ShouldLagCompensate = true 	--automatically enables/disables lag compensation when physics are created and destroyed, might be annoying for some so disable this if you want
else
	ENT.RenderGroup = RENDERGROUP_OPAQUE
end

ENT.Editable = false

ENT.KeyAllowedKeyboard = 2 ^ 0
ENT.KeyAllowedMouse = 2 ^ 1
ENT.KeyAllowedJoystick = 2 ^ 2

ENT.KeyAllowedAll = bit.bor( ENT.KeyAllowedKeyboard , ENT.KeyAllowedMouse , ENT.KeyAllowedJoystick )

ENT.KeyAllowedFlags = ENT.KeyAllowedAll	--bitflag of the key types you want to use

ENT.HookAlways = 1 --hooks in here always run
ENT.HookEquipped = 2 --hooks in here are only added when the entity is equipped by user, and removed when unequipped
ENT.HookEquippedPrediction = 3 --like above, but on the client, only for the LocalPlayer() equipping this
ENT.HookCallback = 4 --these are callbacks handled with AddCallback, unfortunately we have no way to fully handle these

--example attachment info table, only used if AttachesToPlayer is true
--[[
ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( -90 , -5.6 , 0 ),
	OffsetAng = Angle( 180 , 90 , -90 ),
}
]]

--[[
	This is a wrapper for NetworkVars/DTVars (same thing) so we can handle their slots properly for child classes instead
	of having to modify them manually everytime something changes in order

	This could be switched to NWVars2 (vinh vars) but then I would have to hack in support for right-click editing, since that's
	based on NetworkVars and some other getters
]]
function ENT:DefineNWVar( dttype , dtname , editable , beautifulname , minval , maxval , customelement , filt )

	if not self.DefinedDTVars[dttype] then
		Error( "Wrong NWVar type " .. ( dttype or "nil" ) )
		return
	end

	local index = -1

	--only do this check for limited dtvars, once we switch to NWVars in :NetworkVar this check will go away
	if not self.UseNWVars then
		local maxindex = self.DefinedDTVars[dttype].Max

		for i = 0 , maxindex - 1 do
			--we either didn't find anything in this slot or we found the requested one again
			--in which case just override it again, someone might want to inherit and add an edit table or something
			if not self.DefinedDTVars[dttype][i] or self.DefinedDTVars[dttype][i] == dtname then
				index = i
				break
			end
		end

		if index == -1 then
			Error( "Not enough slots on "..dttype .. ",	could not add ".. dtname )
			return
		end
	else
		index = dtname:lower()
	end

	self.DefinedDTVars[dttype][index] = dtname

	local edit = nil

	--this used to check if we could actually add the edit table, so we default it to nil to override it again
	--in case of a child class

	if editable then
		edit = {
			KeyName = dtname:lower(),
			Edit = {
				title = beautifulname or dtname,	--doesn't it do this internally already?
				min = minval,
				max = maxval,
				type = customelement or self.DefinedDTVars[dttype].EditableElement,
			}
		}
	end

	self:NetworkVar( dttype , index , dtname , edit )
end

function ENT:SetupDataTables()

	--if the user is in the branch that has the NWVars change then automatically switch to this
	if self.CallNetworkProxies then
		self.UseNWVars = true
	end

	--eventually I'll create more editable elements based on garry's system

	self.DefinedDTVars = {
		Entity = {
			Max = GMOD_MAXDTVARS,
		},
		Float = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Float",
		},
		Int = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Int",
		},
		Bool = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Boolean",
		},
		Vector = {
			Max = GMOD_MAXDTVARS,
		},
		Angle = {
			Max = GMOD_MAXDTVARS,
		},
		String = {
			Max = 4,
			EditableElement = "Generic",
		},
	}

	self:DefineNWVar( "Entity" , "ControllingPlayer" )
	self:DefineNWVar( "Bool" , "BeingHeld" )
	self:DefineNWVar( "String" , "SlotName" )
	self:DefineNWVar( "Float" , "NextFire" ) --similar to primaryattack on a weapon

	--only allow the user to modify the button if the coder wants this entity to have an usable key

	self:DefineNWVar( "Int" , "Key" , true , "Button" , BUTTON_CODE_NONE + 1 , BUTTON_CODE_LAST , "EditKey" )
	self:DefineNWVar( "Bool" , "KeyPressed" )
end

function ENT:Initialize()

	self.HandledHooks = {
		[self.HookAlways] = {},
		[self.HookEquipped] = {},
		[self.HookEquippedPrediction] = {},
		[self.HookCallback] = {}
	}

	self.HookConditions = {
		[self.HookAlways] = function( ent )
			return true
		end,
		[self.HookEquipped] = function( ent )
			return ent:IsCarried()
		end,
		[self.HookEquippedPrediction] = function( ent )
			if SERVER then
				return ent:IsCarried() --self.HookConditions[self.HookEquipped]( self )
			else
				return ent:IsCarriedByLocalPlayer()
			end
		end,
		[self.HookCallback] = function( self )
			return nil --nil means don't handle me
		end,
	}

	--predicted hooks hooking with hookers and futurama memes
	self:InstallHook( "StartCommand" , self.HandlePredictedStartCommand , self.HookEquippedPrediction )
	self:InstallHook( "SetupMove" , self.HandlePredictedSetupMove , self.HookEquippedPrediction )
	self:InstallHook( "Move" , self.HandlePredictedMove , self.HookEquippedPrediction )
	self:InstallHook( "PlayerTick" , self.HandlePredictedThink , self.HookEquippedPrediction )
	self:InstallHook( "FinishMove" , self.HandlePredictedFinishMove , self.HookEquippedPrediction )
	self:InstallHook( "OnPlayerHitGround" , self.HandlePredictedHitGround , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonDown" , self.HandlePlayerButtonDown , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonUp" , self.HandlePlayerButtonUp , self.HookEquippedPrediction )


	self:InstallHook( "CalcMainActivity" , self.HandleCalcMainActivity , self.HookEquipped )
	self:InstallHook( "UpdateAnimation" , self.HandleUpdateAnimation , self.HookEquipped )
	self:InstallHook( "DoAnimationEvent" , self.HandleAnimationEvent , self.HookEquipped )


	if SERVER then
		self:InstallHook( "SetupPlayerVisibility" , self.HandleEntityVisibility , self.HookAlways )
		self:InstallHook( "EntityRemoved" , self.OnControllerRemoved , self.HookAlways )
		self:InstallHook( "PostPlayerDeath" , self.OnControllerDeath , self.HookAlways )	--using PostPlayerDeath as it's called on all kind of player deaths, even :KillSilent()
		self:InstallHook( "CanEditVariable" , self.HandleCanEditVariable , self.HookAlways )

		--just in case it has been spawned manually and the coder forgot
		if self:GetSlotName() == "" then
			ErrorNoHalt( self:GetClass() .. " was spawned without a slotname!!!!. Defaulting to classname\n" )
			self:SetSlotName( self:GetClass() )
		end

		self:SetUseType( SIMPLE_USE )
		self:SetKey( BUTTON_CODE_NONE )
	else
		self:InstallHook( "PreDrawEffects" , self.DrawFirstPersonInternal , self.HookEquipped )
		self:InstallHook( "PostDrawViewModel" , self.DrawViewModelInternal , self.HookEquipped )
		self:InstallHook( "PostPlayerDraw" , self.DrawOnPlayer , self.HookEquipped )

		self:InstallHook( "NotifyShouldTransmit" , self.HandleFullPacketUpdate , self.HookAlways )

		language.Add( self:GetClass() , self.PrintName )
		language.Add( "dropped_"..self:GetClass() , "Dropped "..self.PrintName )
	end
end

--This is needed mostly for clientside hooks, since IsValid might return false when we're out of PVS with some bad lag
--and when hook.Call tries to call on an invalid entity it removes the hook, so we need to reinstall them when that happens and the entity gets back in the PVS
--prediction and other shit like drawing on a player might fuck up since the hooks got removed
--Now this also works for adding a callback

function ENT:InstallHook( hookname , handler , hooktype )

	if self.HandledHooks[hooktype] == nil then
		hooktype = self.HookAlways
	end

	self.HandledHooks[hooktype][hookname] = handler

	if hooktype == self.HookCallback then
		self:AddCallback( hookname , handler )
	end

end

function ENT:HandleHooks( cleanup )

	--this is direct access to the hook table, but it's not slow at all
	--or at least, it shouldn't be as long as you don't have any ulib shit or some other hook overrides
	local hooktable = hook.GetTable()



	for hookindex , handledshooktab in pairs( self.HandledHooks ) do
		local condition = self.HookConditions[hookindex]( self )

		if condition ~= nil then
			for i , v in pairs( handledshooktab ) do
				if condition and not cleanup then
					if not hooktable[i] or not hooktable[i][self] then
						hook.Add( i , self , v )
					end
				else
					if hooktable[i] and hooktable[i][self] then
						hook.Remove( i , self )
					end
				end
			end
		end
	end

end

function ENT:Think()

	self:HandleHooks()

	if SERVER then

		--check if this guy is still my parent and owner, maybe something is forcibly unparenting us from him, if so, drop
		if self.AttachesToPlayer and self:IsCarried() then
			if not self:IsAttached() then
				self:Remove( true )
			end
		end

		--we have to network this ourselves since it's based on the physics object ( which is mainly serverside )
		--the reason I'm networking this is that due to the gravity gun enabling prediction, it would screw with the manual
		--predictable logic of this entity, so when we try to activate prediction, we check if we're being carried by the gravity gun
		--to prevent disabling it

		--NOTE: this is not as expensive as it looks, it just checks for the FVPHYSICS_PLAYER_HELD flag on our physobj
		self:SetBeingHeld( self:IsPlayerHolding() )
	else
		--calling this in a non-predicted hook is perfectly fine, since we need the entity to enable prediction on its own
		--even when controlling players change

		--Ideally this would be handled on the callback of SetControllingPlayer clientside, but we don't have that yet
		self:HandlePrediction()
		self:HandleButtonBind()
		self:HandleContextMenuButton()
		self:InternalHandleLoopingSounds()
	end

	--set our think rate to be in line with the server tickrate
	--this may also affect animations clientside if they're ran in this hook, considering that also happens in normal source
	--I'd say that's an accurate replication of the issue

	--default behaviour for scripted entities is to think every 200 milliseconds
	--I suppose this should be configurable by child entities

	self:NextThink( CurTime() + engine.TickInterval() )
	return true
end

if SERVER then

	--for map inputs mostly, but other addons may also be using these inputs trough ent:Input or ent:Fire
	--more inputs might come in the future
	--of course child entities are free to call the baseclass function after their own to chain stuff

	function ENT:AcceptInput( inputName, activator, called, data )

		if inputName == "Drop" then
			self:Drop( true )
			return true
		end

		if inputName == "SetSlotName" then
			if self:IsCarried() or not data or #data <= 1 or data == self:GetSlotName() then
				return false
			end

			self:SetSlotName( data )
			return true
		end

	end

	--although we should probably do validity checks on them first, but considering this would *probably* be called from maps it should be ok
	--copied from env_skypaint, allows to have the DT vars set as if they were key values

	function ENT:KeyValue( key, value )

		if self:SetNetworkKeyValue( key, value ) then
			return
		end

	end

	function ENT:ChangeSlot( newslotname )
		local oldslotname = self:GetSlotName()

		if newslotname == oldslotname then
			return false
		end

		local ply = self:GetControllingPlayer()

		--if we have a controlling player and he has an entity in the new slot, abort
		if IsValid( ply ) and IsValid( self.GetOnPlayer( ply , newslotname ) ) then
			--this slot is already occupied!!!
			return false
		end

		if IsValid( ply ) then
			self.SetOnPlayer( ply , oldslotname , NULL )
			self.SetOnPlayer( ply , newslotname , self )
		end

		self:SetSlotName( newslotname )

		return true
	end

	--useful for swapping out two slots at the same time and knowing the other entity,
	--usually in an inventory system
	function ENT:SwapSlotWith( predent )
		local ply = self:GetControllingPlayer()

		if not self:IsCarriedBy( ply ) or not IsValid( predent ) or not predent.IsPredictedEnt
		or not predent:IsCarriedBy( ply ) then
			return false
		end

		local myslot = self:GetSlotName()
		local otherslot = predent:GetSlotName()

		self.SetOnPlayer( ply , otherslot , self )
		self.SetOnPlayer( ply , myslot , predent )

		self:SetSlotName( otherslot )
		predent:SetSlotName( myslot )

		return true
	end

	--override this if you want your equip logic to be different
	function ENT:Use( activator, caller, useType, value )
		if not self:Attach( activator ) then
			self:EmitPESound( "HL2Player.UseDeny" , 150 , nil , 1 , nil , nil , activator )
		end
	end

	function ENT:InitPhysics()
		--don't actually initialize the physics if we're getting removed anyway
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end


		if self.ShouldLagCompensate then
			self:SetLagCompensated( true )
		end

		self:DoInitPhysics()
		self:OnInitPhysics( self:GetPhysicsObject() )
	end

	function ENT:DoInitPhysics()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:RemovePhysics()

		if self.AttachesToPlayer and self.ShouldLagCompensate then
			self:SetLagCompensated( false )	--entities that are attached to players will be moved back when the player is, so don't make them lag compensate on their own
		end

		self:OnRemovePhysics( self:GetPhysicsObject() )
		self:DoRemovePhysics()
	end

	function ENT:DoRemovePhysics()
		self:PhysicsDestroy()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:OnAttach( ply , forced )
		--override me
	end

	function ENT:CanAttach( ply )
		--override me
	end

	function ENT:OnDrop( ply , forced )
		--override me
	end

	function ENT:CanDrop( ply )
		--override me
	end

	--these two are not necessarely duplicates of the functions above because we may want to modify the mass
	--as soon as the physobj gets created, and that also happens in initialize

	function ENT:OnInitPhysics( physobj )
		--override me
	end

	function ENT:OnRemovePhysics( physobj )
		--override me
	end

	--being attached forcibly is usually something that happens when you want to spawn the player with this item, and you
	--don't want gamemode logic to interfere with it
	function ENT:Attach( activator , forced )

		--we were forced to attach to this player, so drop first to clear out some values
		if forced then
			self:Remove( forced )
		end

		if not IsValid( activator ) or not activator:IsPlayer() then
			return false
		end

		--we're carried in general OR that guy's using that slot already
		if self:IsCarried() or IsValid( self.GetOnPlayer( activator , self:GetSlotName() ) ) then
			return false
		end

		--we can allow the coder or gamemode to only stop the pickup if it's not forced
		if not forced then
			--simulate ourselves being a normal item pickup
			--the reason we're asking this first, is that first we want to make sure the gamemode is OK with us being able to pickup this entity
			local canattach = hook.Run( "PlayerCanPickupItem" , activator , self )

			--THEN we ask the coder if he really wants us to pickup his entity, in case it's out of "ammo", or some other restrictions
			local mycanattach = self:CanAttach( activator )
			if mycanattach == false then
				canattach = mycanattach
			end

			if canattach == false then
				return canattach
			end
		end

		if self.AttachesToPlayer then
			self:RemovePhysics()
			self:SetParent( activator )
			self:SetOwner( activator )
			self:SetTransmitWithParent( true )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck of the transmission, so UpdateTransmitState() is called right away
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( true )
			end
			]]

			self:SetNoDraw( true )
			self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		self:SendItemMessage( activator , false )

		self.SetOnPlayer( activator , self:GetSlotName() , self )
		self:SetControllingPlayer( activator )

		--if the player has a customized key for this entity, use that instead
		--we do this here so that OnAttach can make use of it

		--this also allows us to prevent the key from another user to be written clientside and override ours
		if self.SaveButtonToCvar then
			local plykey = self:GetControllingPlayerConVarKey()

			if self:IsKeyAllowed( plykey ) and plykey ~= self:GetKey() then
				self:SetKey( plykey )
			end
		end

		--THIS IS VERY SUBJECTIVE
		self:SetKeyPressed( false ) --only reset the button press state when equipped

		self:OnAttach( activator , forced )
		return true
	end

	function ENT:Drop( forced )

		--we can allow the coder to only stop the drop if it's not forced
		if not forced then
			local candrop = self:CanDrop( self:GetControllingPlayer() )

			if candrop == false then
				return candrop
			end
		end

		if self.AttachesToPlayer then
			self:SetParent( NULL )
			self:SetOwner( NULL )
			self:InitPhysics()
			self:SetTransmitWithParent( false )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck during a drop
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( false )
			end
			]]

			self:SetNoDraw( false )
			self:RemoveEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		if not forced and self:IsCarried() then
			self:SendItemMessage( self:GetControllingPlayer() , true )
		end

		--only call OnDrop if we had a player controlling us, don't do it if we were just sweeping up some unclean values
		if self:IsCarried() then
			self:OnDrop( self:GetControllingPlayer() , forced )
			self.SetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() , NULL )
		end

		self:SetControllingPlayer( NULL )
		return true
	end

	function ENT:SendItemMessage( activator , dropped )
		if dropped == nil then
			dropped = false
		end
		--GetShouldPlayPickupSound is actually a Lua table value that is then checked in c++, so it starts out as nil, wow garry
		if self.ShowPickupNotice and ( self:GetShouldPlayPickupSound() == nil or self:GetShouldPlayPickupSound() ) then

			if not dropped then
				self:EmitSound( "HL2Player.PickupWeapon" )
			else
				self:EmitSound( "Weapon_Crowbar.Single" )
			end

			if not activator:IsPlayer() or not activator:IsBot() then
				net.Start( "pe_pickup" )
					net.WriteString( self:GetClass() )
					net.WriteBit( dropped )
				net.Send( activator )
			end
		end
	end

	--we want to get properly dropped when the player entity gets removed ( aka after a disconnect )
	--why not use the disconnect hook? no.

	function ENT:OnControllerRemoved( ent )
		if self:IsCarriedBy( ent ) then
			self:Remove( true )
		end
	end

	function ENT:OnControllerDeath( ply )
		if self.DropOnDeath and self:IsCarriedBy( ply ) then
			self:Remove( true )
		end
	end

	--we're redoing this even though it's hooked up in sandbox because someone might want to use this in another gamemode ( such as ttt or whatever )
	function ENT:HandleCanEditVariable( ent , ply , key , val , editor )
		if ent == self then
			local allow = self:CanPlayerEditVariable( ply , key , val , editor )

			if key == "Key" then
				local btn = tonumber( val )
				if btn and not self:IsKeyAllowed( btn ) then
					allow = false
				end
			end

			--call the editkey hook only if the other one didn't say anything in the matter for this
			if key == "Key" and allow == nil then
				allow = self:CanEditKey( ply , val , editor )
			end

			--we'll only override all the hooks if the answer is yes or no, nil keeps the default behaviour
			if allow ~= nil then
				return allow
			end
		end
	end

	--our key can only be modified by the carrying player or by anyone if it's not carried at all
	function ENT:CanEditKey( ply , val , editor )
		--you could override me if you want to, you could leave your friends behind
		return self:IsCarriedBy( ply ) or not self:IsCarried()
	end

	function ENT:CanPlayerEditVariable( ply , key , val , editor )
		--override me
	end

	--we add this entity's position to the visibility position, but only if it doesn't attach to the player
	function ENT:HandleEntityVisibility( ply , viewent )
		if self:IsCarriedBy( ply ) and not self.AttachesToPlayer and self ~= viewent then --viewents already add themselves to the pvs
			AddOriginToPVS( self:GetPos() )
		end

		--HOW CONVENIENT!!! this hook is called before the client computes what he can see
		--so we can simply use this before this entity gets recomputed for transmission

		--TODO: This will be removed and the ENT:UpdateTransmitState() below will be enabled once Willox is done with TRANSMIT_OWNERONLY
		if self.DontTransmitToOthers and not game.SinglePlayer() then

			local shouldpreventtransmit = false

			if self:IsCarried() then
				shouldpreventtransmit = not self:IsCarriedBy( ply , true )
			end

			self:SetPreventTransmit( ply , shouldpreventtransmit )
		end
	end

	--[[
	function ENT:UpdateTransmitState()


		if self.DontTransmitToOthers and self:IsCarried() then
			return TRANSMIT_OWNERONLY
		end


		--don't return anything, default behaviour
	end
	]]

else

	function ENT:GetConVar()

		--the slotname changed, so we forget this cvar to let another one with the same slot use it
		--and we let the code below create/get one with our slotname
		if self.ConfigurableConVar and self.ConfigurableConVar:GetName() ~= self:GetConVarName() then
			self.ConfigurableConVar = nil
		end

		if not self.ConfigurableConVar then
			--internally this returns the original convar if it was already created, so it's not that big of a deal, this could be done in a better way however
			self.ConfigurableConVar = CreateConVar( self:GetConVarName() , self:GetKey() , FCVAR_ARCHIVE + FCVAR_USERINFO , "Configures the key for "..self:GetSlotName().. " , created by "..self:GetClass() )
		end

		return self.ConfigurableConVar
	end

	function ENT:InternalHandleLoopingSounds( calledinprediction )
		--the calledinprediction variable makes it so HandleLoopingSounds is called from ENT:Think instead
		--and yes, this will never be set at all during singleplayer because there's no prediction

		--if this is set then there's no need to call iscarried checks below, we're always called when that happens
		if calledinprediction and not IsFirstTimePredicted() then
			return
		end

		if game.SinglePlayer() or not self:IsCarried() or not self:IsCarriedByLocalPlayer() or ( self:IsCarriedByLocalPlayer() and calledinprediction ) then
			self:HandleLoopingSounds()
		end
	end

	function ENT:HandleLoopingSounds()
		--override me
	end

	function ENT:IsCarriedByLocalPlayer( checkspectator )
		return self:IsCarriedBy( LocalPlayer() , checkspectator )
	end

	function ENT:ShouldDrawLocalPlayer( checkspectator )
		if checkspectator then
			if LocalPlayer():GetObserverMode() == OBS_MODE_IN_EYE and IsValid( LocalPlayer():GetObserverTarget() ) then
				if LocalPlayer():GetObserverTarget():IsPlayer() then
					return LocalPlayer():GetObserverTarget():ShouldDrawLocalPlayer() --assuming this even works, otherwise just return false
				end
				return false
			end
		end
		return LocalPlayer():ShouldDrawLocalPlayer()
	end

	--immediately make this entity predicted again, if it's equipped by this localplayer
	function ENT:HandleFullPacketUpdate( ent , shouldtransmit )
		if ent == self and shouldtransmit then
			self:HandlePrediction()
		end
	end

	function ENT:HandlePrediction()

		local carried = self:IsCarriedByLocalPlayer()

		--either the gravity gun or some other stuff is carrying me, don't do anything on prediction
		--because they might enable it to carry us around smoothly
		--also don't enable prediction in singleplayer

		if self:GetBeingHeld() or game.SinglePlayer() then
			return
		end

		if self:GetPredictable() ~= carried then
			self:SetPredictable( carried )
		end
	end

	function ENT:HandleButtonBind()
		--did not disable the function call from Think as someone might want to override this

		if self.SaveButtonToCvar then
			--this is a one way server to client saving, the reason I do this is because the user should usually change the value from
			--client to server with the edit system, it still goes to the server, but not to the cvar first, so we save it from the client to the cvar

			--basically we just use the cvar as a way to save the button, but it does come at the cost of not being able to update the cvar and have it update on the
			--entity, this will probably change in the future
			local mykey = self:GetKey()

			--can't use GetControllingPlayerConVarKey as I also need to SetInt on it
			local cv = self:GetConVar()

			if cv then
				if ( mykey ~= cv:GetInt() and self:IsKeyAllowed( mykey ) ) --[[or not self:IsKeyAllowed( cv:GetInt() )]] then
					cv:SetInt( mykey )
				end
			end
		end
	end



	function ENT:CreateContextMenuButton( iconlayout )
		local button = iconlayout:Add( "DPredEnt" )
		button:SetSize( 80 , 80 )
		button:SetClassName( self.PrintName , self:GetSlotName() )
		button:SetMaterial( self.Folder .. ".png" )
		button:SetPredEnt( self )
		--SetClassName
	end

	function ENT:GetContextMenuButton( iconlayout )
		local contextbutton = nil

		for i = 0 , iconlayout:ChildCount() do

			local child = iconlayout:GetChild( i )

			if IsValid( child ) and child:GetName() == "DPredEnt" and child:GetSpawnName() == self:GetSlotName() and child:GetPredEnt() == self then
				contextbutton = child
				break
			end

		end

		return contextbutton
	end

	--forcefully removes it in case it fucks up
	function ENT:RemoveContextMenuButton( iconlayout , buttonpanel )
		if IsValid( buttonpanel ) then
			buttonpanel:Remove()
		end
	end

	function ENT:GetContextMenuLayout()
		if not IsValid( g_ContextMenu ) then
			return
		end

		local iconlayout = nil

		for i = 0 , g_ContextMenu:ChildCount() do

			local child = g_ContextMenu:GetChild( i )

			if IsValid( child ) and child:GetName() == "DIconLayout" then
				iconlayout = child
				break
			end

		end

		return iconlayout
	end

	function ENT:HandleContextMenuButton( docleanup )

		local iconlayout = self:GetContextMenuLayout()

		if not IsValid( iconlayout ) then
			return
		end

		local buttonpanel = self:GetContextMenuButton( iconlayout )

		if IsValid( buttonpanel ) and ( not self:IsCarriedByLocalPlayer() or docleanup )then
			self:RemoveContextMenuButton( iconlayout , buttonpanel )
			iconlayout:InvalidateLayout()
		end

		if not IsValid( buttonpanel ) and self:IsCarriedByLocalPlayer() then
			self:CreateContextMenuButton( iconlayout )
			iconlayout:InvalidateLayout()
		end

	end



	function ENT:DrawFirstPersonInternal()
		if self.AttachesToPlayer and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
			local fov = nil	--TODO: allow changing the FOV
			cam.Start3D( nil , nil , fov , nil , nil , nil , nil , 1 , -1 )	--znear is 1 and zfar is -1
				render.DepthRange( 0 , 0.1 )	--same depth hack valve uses in source!
					self:DrawFirstPerson( self:GetControllingPlayer() )
				render.DepthRange( 0 , 1 )		--they don't even set these back to the original values
			cam.End3D()
		end
	end

	--viewmodels don't draw without an associated weapon ( this is due to garryness, they always do in source )
	function ENT:DrawViewModelInternal( vm , ply , wpn )
		if self.AttachesToPlayer and self:IsCarriedBy( ply , true ) then
			self:DrawOnViewModel( ply , vm , ply:GetHands() ) --this will stay here
		end
	end

	function ENT:DrawFirstPerson( ply )
		--override me
	end

	--mainly used to draw stuff like shields, gloves or whatever on the viewmodel hands

	function ENT:DrawOnViewModel( ply , vm , hands )
		--override me
	end

	--the flags aren't passed yet, maybe in a future update

	function ENT:DrawOnPlayer( ply , flags )
		self:DrawModel( flags )

	end

	function ENT:Draw( flags )
		local pos , ang = self:GetCustomParentOrigin()
		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )
	end

end

--these are here to "unify" our two calls to SetNWEntity and GetNWEntity
--these might be called from pe_drop and some other stuff, so we can't rely on the entity itself being present, as lame as that is
--the alternative would be to have these as global, which would be lamer
function ENT.SetOnPlayer( ply , slot , ent )
	ply:SetNW2Entity( slot , ent )
end

function ENT.GetOnPlayer( ply , slot )
	return ply:GetNW2Entity( slot )
end

function ENT:IsAttached()
	local ply = self:GetControllingPlayer()
	return self:GetOwner() == ply and self:GetParent() == ply
end

--LOOK I DON'T CARE, this check is lame as shit but I can't be arsed to add duplicated code
function ENT:IsCarried()
	return self:IsCarriedBy( self:GetControllingPlayer() )
end

function ENT:IsCarriedBy( ply , checkspectator )

	if checkspectator and ply:GetObserverMode() ~= OBS_MODE_NONE then
		return self:IsCarriedBy( ply:GetObserverTarget() )
	end

	return IsValid( ply ) and ply == self:GetControllingPlayer() and self.GetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() ) == self
end

function ENT:IsKeyDown()
	return self:GetKeyPressed()
end

--these functions should totally not be tied to this SENT, but I don't want to go out of my way to add them to an util file
function ENT:IsValidButton( btn )
	return btn > BUTTON_CODE_NONE and btn < BUTTON_CODE_COUNT
end

function ENT:IsKeyboardButton( btn )
	return btn > KEY_FIRST and btn < KEY_COUNT
end

function ENT:IsMouseButton( btn )
	return btn >= MOUSE_FIRST and btn < MOUSE_LAST
end

function ENT:IsJoystickButton( btn )
	return btn >= JOYSTICK_FIRST and btn < JOYSTICK_LAST
end

function ENT:IsKeyAllowed( btn )
	if bit.band( self.KeyAllowedFlags , self.KeyAllowedKeyboard ) == 0 and self:IsKeyboardButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedMouse ) == 0 and self:IsMouseButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedJoystick ) == 0 and self:IsJoystickButton( btn ) then
		return false
	end

	return self:IsValidButton( btn )
end

function ENT:GetConVarName()
	return "prdent_key_"..self:GetSlotName()
end

function ENT:GetControllingPlayerConVarKey()
	local defaultkey = BUTTON_CODE_NONE

	if self:IsCarried() then
		if SERVER then
			return self:GetControllingPlayer():GetInfoNum( self:GetConVarName() , defaultkey )
		else
			--the clientside implementation of GetInfoNum makes a GetConVar lookup everytime, so use the cached one instead
			local cv = self:GetConVar()

			if cv then
				return cv:GetInt()
			end
		end
	end

	return defaultkey
end

function ENT:HandleCalcMainActivity( ply , velocity )
	if self:IsCarriedBy( ply ) then
		local calcideal , calcseqovr = self:HandleMainActivityOverride( ply , velocity )
		if calcideal and calcseqovr then
			return calcideal , calcseqovr
		end
	end
end

function ENT:HandleUpdateAnimation( ply, velocity, maxseqgroundspeed )
	if self:IsCarriedBy( ply ) then
		if self:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed ) then
			return true
		end
	end
end

function ENT:HandleAnimationEvent( ply, event, data )
	if self:IsCarriedBy( ply ) then
		if self:HandleAnimationEventOverride( ply , event , data ) then
			return ACT_INVALID
		end
	end
end

function ENT:HandleMainActivityOverride( ply , velocity )
	--override me
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	--override me
end

function ENT:HandleAnimationEventOverride( ply , event , data )
	--override me
end

function ENT:HandlePredictedStartCommand( ply , cmd )
	if self:IsCarriedBy( ply ) then
		self:PredictedStartCommand( ply , cmd )
	end
end

function ENT:HandlePlayerButtonDown( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , true )
	end
end

function ENT:HandlePlayerButtonUp( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , false )
	end
end

function ENT:HandlePlayerButtonInternal( ply , btn , pressed )
	local mykey = self:GetKey()
	if self:IsKeyAllowed( mykey ) and btn == mykey then
		self:SetKeyPressed( pressed )
	end

	self:PredictedPlayerButtonPress( ply , btn , pressed )
end

function ENT:HandlePredictedSetupMove( ply , mv , cmd )
	if self:IsCarriedBy( ply ) then
		if self:PredictedSetupMove( ply , mv , cmd ) then
			return true
		end
	end
end

function ENT:HandlePredictedMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedThink( ply , mv )
	if self:IsCarriedBy( ply ) then
		if CLIENT then
			self:InternalHandleLoopingSounds( true )
		end
		self:PredictedThink( ply , mv )
	end
end

function ENT:HandlePredictedFinishMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedFinishMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedHitGround( ply , inwater , onfloater , speed )
	if self:IsCarriedBy( ply ) then
		if self:PredictedHitGround( ply , inwater , onfloater , speed ) then
			return true
		end
	end
end

function ENT:PredictedStartCommand( ply , cmd )
	--override me
end

function ENT:PredictedPlayerButtonPress( ply , btn , pressed )
	--override me
end

function ENT:PredictedSetupMove( ply , mv , cmd )
	--override me
end

function ENT:PredictedMove( ply , mv )
	--override me
end

function ENT:PredictedThink( ply , mv )
	--override me
end

function ENT:PredictedFinishMove( ply , mv )
	--override me
end

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )
	--override me
end

--Allows for predicted movement simulation on non player entities, without disrupting the player movement itself
--FinishMove should be the best place for this, since even in case of fuckups, the rest of the movement should be fine

--[[
	function ENT:PredictedFinishMove( ply , mv )

		local sv = self:BackupMoveData( mv )

		--set the data you want on the movedata, such as the entity origin, speed, angles and stuff

		--run the entity traces

		--set the final position of the entity here with the same way garry does ( see drive.End or whatever it's called )

		--restore the movedata on the player as if nothing happened

		self:RestoreMoveData( mv , sv )


	end
]]


local movedatameta = FindMetaTable( "CMoveData" )

local emptyvalues = {
	[TYPE_VECTOR] = vector_origin * 1,
	[TYPE_ANGLE] = angle_zero * 1,
	[TYPE_NUMBER] = 0,
	[TYPE_ENTITY] = NULL,
}

local methods = {}

--cache the methods we can actually use
for i , v in pairs( movedatameta ) do
	--see if this function has a pattern like "Get*" or whatever
	--then strip out "Get" and add it here
	local functionname = i
	if functionname:find( "^Get" ) then
		local functionnamestripped = functionname:gsub( "^Get" , "" )

		local setter = movedatameta["Set"..functionnamestripped]

		if setter then
			--add the stripped method to the table to reuse later
			methods[#methods + 1] = functionnamestripped
		end
	end
end

function ENT:BackupMoveData( mv )

	if not mv or not movedatameta then
		return
	end

	local sv = {}
	--save the movedata by name on the table, then go trough the metatable to get the setters and set values to empty ones

	for i , v in pairs( methods ) do
		--see if this function has a pattern like "Get*" or whatever
		--then strip out "Get" and add it here

		--we could've cached the functions as well, but just in case someone wants us to use the modified ones
		local getter = movedata["Get"..v]
		local setter = movedata["Set"..v]

		local backupvalue = getter( mv )

		sv[v] = backupvalue

		if emptyvalues[TypeID( backupvalue )] ~= nil then
			setter( mv , emptyvalues[TypeID( backupvalue )] )
		end
	end

	return sv
end

function ENT:RestoreMoveData( mv , sv )
	if not mv or not sv or not movedatameta then
		return
	end

	--restore the values from the table, prevents duplicated code by using the setters from the metatable directly
	for i , v in pairs( sv ) do
		local setter = movedatameta["Set"..i]
		if setter then
			setter( mv , v )
		end
	end
end

--attaches the entity to the player depending on the attachmentinfo table
--you can override this safely as long as you keep the part with ply:SetupBones()
--although you generally should just use the attachment info table instead

function ENT:GetCustomParentOrigin()

	if not self.AttachmentInfo then
		return
	end

	local ply = self:GetControllingPlayer()

	--duplicated check, but people might call this manually in the entity draw hook, so gotta do this
	if not self:IsCarriedBy( ply ) then
		return
	end

	--I put this here because since the entity moves to the player bone matrix, it'll only be updated on the client
	--when the player is actally drawn, or his bones are setup again ( which happens before a draw anyway )
	--this also fixes sounds on the client playing at the last location the LocalPlayer() was drawn

	if CLIENT and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
		ply:SetupBones()
	end

	local boneid = ply:LookupBone( self.AttachmentInfo.BoneName )

	if not boneid then
		return
	end

	local matrix = ply:GetBoneMatrix( boneid )

	if not matrix then
		return
	end

	return LocalToWorld( self.AttachmentInfo.OffsetVec , self.AttachmentInfo.OffsetAng , matrix:GetTranslation() , matrix:GetAngles() )
end

--if we're attached to a player, use custom origin from the function above
--this is called shared, yes it's more expensive than source's normal parenting but it's worth it

function ENT:CalcAbsolutePosition( pos , ang )
	if self.AttachesToPlayer and self:IsCarried() then
		return self:GetCustomParentOrigin()
	end
end

function ENT:EmitPESound( soundname , level , pitch , volume , chan , predicted , activator , worldpos )

	--must've been called manually by some ent:Fire or ent:Input functions
	if IsValid( activator ) and not activator:IsPlayer() then
		activator = NULL
	end

	if not level then
		level = 75
	end

	if not pitch then
		pitch = 100
	end

	if not volume then
		volume = 1
	end

	if not chan then
		chan = CHAN_AUTO
	end

	if game.SinglePlayer() then
		predicted = false
	end

	if not worldpos then
		worldpos = vector_origin
	end

	if SERVER then

		local plys = RecipientFilter()

		if IsValid( activator ) and not predicted and not activator:IsBot() then
			plys:AddPlayer( activator )
		else

			plys:AddPVS( self:GetPos() )

			if predicted and IsValid( self:GetControllingPlayer() ) then
				plys:RemovePlayer( self:GetControllingPlayer() )
			end

		end

		if plys:GetCount() == 0 then
			return
		end

		net.Start( "pe_playsound" )
			net.WriteEntity( self )
			net.WriteString( soundname )
			net.WriteFloat( level )
			net.WriteFloat( pitch )
			net.WriteFloat( volume )
			net.WriteUInt( chan , 8 )
			net.WriteVector( worldpos )
		net.Send( plys )

	else
		if ( predicted and IsFirstTimePredicted() ) or not predicted then
			if worldpos and worldpos ~= vector_origin then
				sound.Play( soundname, worldpos, level, pitch , volume )
			else
				self:EmitSound( soundname , level , pitch , volume , chan )
			end
		end
	end
end

function ENT:OnRemove()
	--if we're being forcibly removed, make sure we're also dropped properly, in case the entity needs to do
	--some stuff on the player before it expires
	if SERVER and self:IsCarried() then
		self:Remove( true )
	end

	if CLIENT then
		self:HandleContextMenuButton( true )
	end

	self:HandleHooks( true ) --remove the hooks immediately instead of relying on garry's "remove if called again"


end

--stuff that should be in an autorun file but that I can't be arsed to split up to

if SERVER then

	util.AddNetworkString( "pe_pickup" )
	util.AddNetworkString( "pe_playsound" )

	--save the function before ENT gets removed during registration
	local GetPredictedEntityOnPlayer = ENT.GetOnPlayer

	concommand.Add( "pe_drop" , function( ply , cmd , args , fullstr )

		if not IsValid( ply ) then
			return
		end

		local nwslot = args[1]

		if not nwslot then
			return
		end

		local slotent = GetPredictedEntityOnPlayer( ply , nwslot )--ply:GetNWEntity( nwslot )

		--user tried to drop an invalid or an entity which is not a predicted entity, or doesn't have a slot assigned

		if not IsValid( slotent ) or not slotent.IsPredictedEnt or slotent:GetSlotName() == "" then
			return
		end

		slotent:Remove( false )

	end)

else

	--tells the hud to show the player the entity pickup
	language.Add( "invalid_entity" , "Invalid Entity" )
	language.Add( "dropped_invalid_entity" , "Dropped Invalid Entity" )

	net.Receive( "pe_pickup" , function( len )
		local str = net.ReadString() or "invalid_entity"
		local dropped = tobool( net.ReadBit() )

		if dropped then
			str = "dropped_" .. str
		end

		gamemode.Call( "HUDItemPickedUp" , str )
	end)

	net.Receive( "pe_playsound" , function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.EmitPESound then
			return
		end

		local soundname = net.ReadString() --yes I know that I can do util.addnetworkstring to cache it but I cba

		local level = net.ReadFloat()
		local pitch = net.ReadFloat()
		local volume = net.ReadFloat()
		local chan = net.ReadUInt( 8 )
		local pos = net.ReadVector()

		ent:EmitPESound( soundname , level , pitch , volume , chan , false , NULL , pos )
	end)

	--[[
		A DProperty that allows the user to set a preferred key using the same DBinder used in sandbox's tools
	]]

	local DBinderProperty = {}

	function DBinderProperty:Init()
	end

	function DBinderProperty:Setup( vars )

		self:Clear()

		local ctrl = self:Add( "DBinder" )
		ctrl:Dock( FILL )

		self.IsEditing = function( self )
			return ctrl.Trapping
		end

		self.SetValue = function ( self , val )
			ctrl:SetSelected( tonumber( val ) )	--use this instead of setValue to possibly avoid feedback loops
		end

		--DBinder doesn't have an onchange callback, so we must do this little hack to add it
		--[[
		ctrl.SetValue = function( ctrl , val )
			ctrl:SetSelected( val )
			self:ValueChanged( val )
		end
		]]

		ctrl.OnChange = function( ctrl , val )
			self:ValueChanged( val )
		end


	end

	derma.DefineControl( "DProperty_EditKey" , "" , DBinderProperty , "DProperty_Generic" )

	local DPredEnt = {
		matOverlay_Normal = Material( "gui/ContentIcon-normal.png" ),
		matOverlay_Hovered = Material( "gui/ContentIcon-hovered.png" )
	}

	AccessorFunc( DPredEnt, "m_MaxBorder", "MaxBorder" )
	AccessorFunc( DPredEnt, "m_MaterialName", "MaterialName" )
	AccessorFunc( DPredEnt, "m_PredEnt", "PredEnt" )
	AccessorFunc( DPredEnt, "m_Border", "Border" )
	AccessorFunc( DPredEnt, "m_Color", "Color" )
	AccessorFunc( DPredEnt, "m_Type", "ContentType" )
	AccessorFunc( DPredEnt, "m_SpawnName", "SpawnName" )
	AccessorFunc( DPredEnt, "m_NPCWeapon", "NPCWeapon" )
	AccessorFunc( DPredEnt, "m_Image", "Image" )
	AccessorFunc( DPredEnt, "m_Label", "Label" )

	function DPredEnt:Init()

		local w , h = 128, 128
		self:SetSize( w , h )

		self:SetPaintBackground( false )

		self:SetText( "" )
		self:SetDoubleClickingEnabled( false )

		self:SetImage( self:Add( "DImage" ) )
		self:GetImage():SetVisible( false )

		self:SetLabel( self:Add( "DLabel" ) )
		self:GetLabel():Dock( BOTTOM )

		self:GetLabel():SetContentAlignment( 5 )

		self:GetLabel():SetTextColor( Color( 255, 255, 255, 255 ) )
		self:GetLabel():SetExpensiveShadow( 1, Color( 0, 0, 0, 200 ) )

		self:SetBorder( 0 )



	end



	function DPredEnt:PerformLayout( w , h )
		self:SetMaxBorder( w / 16 )
		self:GetImage():SetPos( w / 32 , w / 32 )
		self:GetImage():SetSize( w - w / 16 , h - w / 16 )
		self:GetLabel():SetTall( math.Round( w / 7 ) )
		self:GetLabel():DockMargin( math.Round( w / 32 ) , 0 , math.Round( w / 32 ) , math.Round( w / 21 ) )
	end


	function DPredEnt:SetClassName( name , class )

		self:SetTooltip( name )
		self:GetLabel():SetText( name )
		self:SetSpawnName( class )
	end

	function DPredEnt:SetMaterial( name )

		self:SetMaterialName( name )

		local mat = Material( name )

		-- Look for the old style material
		if not mat or mat:IsError() then

			name = name:Replace( "entities/", "VGUI/entities/" )
			name = name:Replace( ".png", "" )
			mat = Material( name )

		end

		-- Couldn't find any material.. just return
		if not mat or mat:IsError() then
			return
		end

		self:GetImage():SetMaterial( mat )

	end

	function DPredEnt:Think()
		if not IsValid( self:GetPredEnt() ) or not self:GetPredEnt().IsPredictedEnt  then
			self:Remove()
		end
	end

	function DPredEnt:DoRightClick()
		self:OpenMenu()
	end

	function DPredEnt:DoClick()
		RunConsoleCommand( "pe_drop" , self:GetSpawnName() or ""  )
	end

	function DPredEnt:OpenMenu()
		if IsValid( self:GetPredEnt() ) then
			properties.OpenEntityMenu( self:GetPredEnt() )
		end
	end

	function DPredEnt:OnDepressionChanged( b )
	end

	function DPredEnt:Paint( w, h )

		if self.Depressed and not self.Dragging then
			if self:GetBorder() ~= self:GetMaxBorder() then
				self:SetBorder( self:GetMaxBorder() )
				self:OnDepressionChanged( true )
			end
		else
			if self:GetBorder() ~= 0 then
				self:SetBorder( 0 )
				self:OnDepressionChanged( false )
			end
		end

		render.PushFilterMag( TEXFILTER.ANISOTROPIC )
		render.PushFilterMin( TEXFILTER.ANISOTROPIC )

		local bx , by , bw , bh = self:GetBorder(), self:GetBorder(), w - self:GetBorder() * 2 , h - self:GetBorder() * 2


		self:GetImage():PaintAt( bx + self:GetMaxBorder() / 2 , by + self:GetMaxBorder() / 2 , bw - self:GetMaxBorder() , bh - self:GetMaxBorder() )



		render.PopFilterMin()
		render.PopFilterMag()

		surface.SetDrawColor( 255, 255, 255, 255 )

		if not dragndrop.IsDragging() and ( self:IsHovered() or self.Depressed or self:IsChildHovered() ) then

			surface.SetMaterial( self.matOverlay_Hovered )
			self:GetLabel():Hide()

		else

			surface.SetMaterial( self.matOverlay_Normal )
			self:GetLabel():Show()

		end

		surface.DrawTexturedRect( bx , by , bw , bh )

	end

	derma.DefineControl( "DPredEnt" , "ContentIcon for Predicted entities in the context menu" , DPredEnt , "DButton" )

end

--addons/arccw_weapons/lua/entities/emp_ball/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "EMP Projectile"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/Items/combine_rifle_ammo01.mdl"
ENT.FuseTime = 5
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		-- ParticleEffectAttach( "astw2_swbf_muzzle_rep_sniper", PATTACH_POINT_FOLLOW, self, 0 )

        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_rep_emp_rocket", self:GetPos(), self:GetAngles() )
					sound.Play( "weapons/star_wars_battlefront/jd_oc/glasslcar.wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        	 -- util.BlastDamage(self, self.Owner, self:GetPos(), 65, 100)
	 local ent = self.Owner
	if !IsValid(ent) then ent = self end
	 local t = DamageInfo()
			t:SetDamage(60)
			t:SetDamageType(DMG_SHOCK)
			t:SetAttacker(ent)
			t:SetInflictor(self)
	util.BlastDamageInfo(t, self:GetPos(), 300)
	  -- local targets = ents.FindInSphere(self:GetPos(), 256)
        -- for _, k in pairs(targets) do
            -- if k:IsPlayer() or k:IsNPC() or scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" ) then
                -- local regen = FrameTime() * 900
                -- k:SetHealth( math.Clamp( k:Health() - regen, 0, k:GetMaxHealth()+k:GetMaxHealth() ) )
				-- if(SERVER) then
				-- k:Ignite( 10 )
				-- end
			-- if !k:IsPlayer() or !k:IsNPC() then
				-- end
            -- end
        -- end
        self:Remove()
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),4096,100,0.6,1024)
    end
end

function ENT:Draw()
    if CLIENT then
        -- self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(16, 32), math.random(16, 32), Color(175, 100, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            ParticleEffectAttach( "astw2_swbf_muzzle_cis_bulldog", PATTACH_POINT_FOLLOW, self, 0 )
			cam.End3D()
        end
    end
end
--addons/aoc_fire_system/lua/entities/fire_molotov_object/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Molotov Cocktail"
ENT.Author			= "Crap-Head"
--addons/tools/lua/entities/heart_turbolaser/cl_init.lua:
include("shared.lua");
util.PrecacheModel("models/heart/turbolaser_bolt.mdl");
util.PrecacheModel("models/heart/turbolaser_glow.mdl");

function ENT:Initialize()
	self.model = ClientsideModel("models/heart/turbolaser_bolt.mdl");
	self.model:SetModelScale(self:GetScale(), 0);

	self.glow = ClientsideModel("models/heart/turbolaser_glow.mdl");
	self.glow:SetModelScale(self:GetScale(), 0);
	self.glow:SetColor(Color(self:GetColR(),self:GetColG(),self:GetColB()));
end

function ENT:Draw()
end

function ENT:Think()
	if not self:IsValid() then
		self.model:Remove();
		self.glow:Remove();
	end

	self.model:SetPos(self:GetPos());
	self.model:SetAngles(self:GetAngles());

	self.glow:SetPos(self:GetPos());
	self.glow:SetAngles(self:GetAngles());
end

function ENT:OnRemove()
	self.model:Remove();
	self.glow:Remove();
end

language.Add("heart_turbolaser", "Turbolaser");
--addons/tools/lua/entities/heart_turbolaser_spawner/cl_init.lua:
include("shared.lua");

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
end

function ENT:OnRemove()
end

--lua/entities/ls_base_mine/shared.lua:
LS_MINES = LS_MINES or {}

if CLIENT then
    language.Add("ls_base_mine", "Base Mine")
end

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Base Mine"
ENT.Category = "Star Wars - Mines"
ENT.Author = "List-Scripts"
ENT.Spawnable = false
ENT.AdminOnly = false
ENT.IsMine = true

ENT.MineOwner = nil

ENT.Model = "models/props/starwars/weapons/ap_mine.mdl"
ENT.TriggerBrush = "ls_brush_sphere"
ENT.TriggerSize = 20
ENT.ExplosionRadius = 100
ENT.ExplosionDelay = 0.08
ENT.ArmTime = 0.5 -- time it takes to arm the mine
ENT.ArmSound = "items/nvg_on.wav"
ENT.SelfArm = true -- if should arm itself after being spawned
ENT.ExplodeOnLeave = false -- if true, mine will explode when the victim leaves the trigger area
ENT.TriggerSound = "buttons/button14.wav"
ENT.HP = 100
ENT.Damage = 500

-- which entity classes can trigger the mine
ENT.TriggerFilter = {
    ["player"] = true,
}

function ENT:SetupDataTables()
    self:NetworkVar("Int", "TriggerSize")
    self:NetworkVar("Int", "ExplosionRadius")
    self:NetworkVar("Bool", "Triggered")
    self:NetworkVar("Bool", "Armed")

    if SERVER then
        self:SetTriggerSize(self.TriggerSize)
        self:SetExplosionRadius(self.ExplosionRadius)
        self:SetTriggered(false)
        self:SetArmed(false)
    end
end
--addons/lvs_addons/lua/entities/lunasflightschool_niksacokica_tx-427_imperial/cl_init.lua:
include("shared.lua")
include( "sh_turret.lua" )
include( "cl_prediction.lua" )

function ENT:OnSpawn()
	local mins, maxs = self:GetRenderBounds()
	self:SetRenderBounds( mins, maxs, Vector( 80, 0, 0 ) )
end

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(11,0,46) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,-40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:DamageFX()
end


function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() then
		if not pod:GetThirdPersonMode() then
			return pos + self:GetForward() * 100 - self:GetUp() * 20, angles + Angle(5,0,0), fov
		else
			return pos, angles, fov
		end
	end
	local GunnerPod = self:GetGunnerSeat()
	if pod == GunnerPod and pod:GetThirdPersonMode() then
		return GunnerPod:LocalToWorld( Vector(0,0,30) ), angles + Angle(5,0,0), fov
	end

	local CoSeatPod = self:GetCoSeat()
	if pod == CoSeatPod then
		if pod:GetThirdPersonMode() then
			return CoSeatPod:LocalToWorld( Vector(0,0,100) ), angles + Angle(5,0,0), fov
		else
			return pos, angles, fov
		end
	end

	local originPos = pos
	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = originPos + ( angles:Forward() * -radius ) + angles:Up() * (40 + radius * pod:GetCameraHeight())
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = originPos,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	originPos = tr.HitPos
	if tr.Hit and  not tr.StartSolid then
		originPos = originPos + tr.HitNormal * WallOffset
	end

	return originPos, angles, fov
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

--addons/lvs_base/lua/entities/lvs_armor_bounce.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "88mm Round"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Items"

ENT.Spawnable		= false
ENT.AdminOnly		= false

ENT.LifeTime = 10

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/misc/88mm_projectile.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS)

		self.DieTime = CurTime() + self.LifeTime

		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
	end

	function ENT:Think()
		if self.MarkForRemove then self:Remove() return false end

		self:NextThink( CurTime() + 0.1 )

		if (self.DieTime or 0) > CurTime() then return true end

		self:Remove()

		return false
	end

	
	function ENT:PhysicsCollide( data, physobj )
		self.MarkForRemove = true

		local effectdata = EffectData()
		effectdata:SetOrigin( data.HitPos )
		effectdata:SetNormal( -data.HitNormal )
		effectdata:SetMagnitude( 0.5 )
		util.Effect( "lvs_bullet_impact", effectdata )
	end

	return
end

ENT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function ENT:Initialize()
	self.DieTime = CurTime() + self.LifeTime

	self.emitter = ParticleEmitter( self:GetPos(), false )
end

function ENT:Smoke()
	local T = CurTime()

	if (self.DieTime or 0) < T then return end

	if not IsValid( self.emitter ) then return end

	if (self.NextFX or 0) < T then
		self.NextFX = T + 0.02

		local Timed = 1 - (self.DieTime - T) / self.LifeTime
		local Scale = math.max(math.min(2 - Timed * 2,1),0)

		local Pos = self:GetPos() 

		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], Pos )

		local VecCol = (render.GetLightColor( Pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255

		if particle then
			particle:SetVelocity( VectorRand() * 10 )
			particle:SetDieTime( math.Rand(0.5,1) )
			particle:SetAirResistance( 100 ) 
			particle:SetStartAlpha( 100 * Scale )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( 20 )
			particle:SetRollDelta( 1 )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector( 0, 0, 200 ) )
			particle:SetCollide( false )
		end
	end
end

function ENT:Think()
	self:Smoke()
end

function ENT:OnRemove()
	if not self.emitter then return end

	self.emitter:Finish()
end

function ENT:Draw()
	self:DrawModel()
end

--addons/lvs_base/lua/entities/lvs_base/cl_trailsystem.lua:

ENT.TrailMaterial = Material( "trails/smoke" )
ENT.TrailRed = 255
ENT.TrailGreen = 255
ENT.TrailBlue = 255
ENT.TrailAlpha = 100

function ENT:OnTrail( active, id )
end

function ENT:HandleTrail()
	if not self.RegisteredTrailPositions then return end

	local FT = RealFrameTime()

	local pos = self:GetPos()
	local vel = self:GetVelocity()
	local vel_length = vel:Length()

	for id, data in pairs( self.RegisteredTrailPositions ) do
		local cur_pos = self:LocalToWorld( data.pos )
		local cur_vel = (cur_pos - data.oldpos) / FT

		local cur_velL = math.abs( self:WorldToLocal( pos + cur_vel ).z )

		if cur_velL > data.activation_speed and vel_length > data.min_flight_speed then
			if not data.id then
				data.id = self:StartTrail( data.pos, data.startsize, data.endsize, data.lifetime )
				self:OnTrail( true, data.id )
			end
		else
			if data.id then
				self:OnTrail( false, data.id )
				self:FinishTrail( data.id )
				data.id = nil
			end
		end

		data.oldpos = cur_pos
	end
end

function ENT:RegisterTrail( Pos, StartSize, EndSize, LifeTime, min_flight_speed, activation_speed )
	if not istable( self.RegisteredTrailPositions ) then
		self.RegisteredTrailPositions = {}
	end

	local data = {
		pos = Pos,
		oldpos = self:LocalToWorld( Pos ),
		startsize = StartSize,
		endsize = EndSize,
		lifetime = LifeTime,
		min_flight_speed = min_flight_speed,
		activation_speed = activation_speed,
	}

	table.insert( self.RegisteredTrailPositions, data )
end

function ENT:StartTrail( Pos, StartSize, EndSize, LifeTime )
	if not LVS.ShowTraileffects then return end

	if not istable( self.TrailActive ) then
		self.TrailActive = {}
	end

	local ID = 1
	for _,_ in ipairs( self.TrailActive ) do
		ID = ID + 1
	end

	self.TrailActive[ ID ] = {
		lifetime = LifeTime,
		start_size = StartSize,
		end_size = EndSize,
		pos = Pos,
		active = true,
		positions = {},
	}

	return ID
end

function ENT:FinishTrail( ID )
	self.TrailActive[ ID ].active = false
end

function ENT:DrawTrail()
	local EntTable = self:GetTable()

	if not EntTable.TrailActive then return end

	local Time = CurTime()

	EntTable._NextTrail = EntTable._NextTrail or 0

	local Set = EntTable._NextTrail < Time

	render.SetMaterial( EntTable.TrailMaterial )

	for ID, data in pairs( EntTable.TrailActive ) do

		for pos_id, pos_data in pairs( data.positions ) do
			if Time - pos_data.time > data.lifetime then
				data.positions[ pos_id ] = nil
			end
		end

		if Set then
			if data.active then
				local cur_pos = {
					time = Time,
					pos = self:LocalToWorld( data.pos ),
				}

				table.insert( data.positions, cur_pos )
				table.sort( data.positions, function( a, b ) return a.time > b.time end )
			end
		end

		local num = #data.positions

		if num == 0 then 
			if not data.active then
				EntTable.TrailActive[ ID ] = nil
			end

			continue
		end

		render.StartBeam( num )

		for _, pos_data in ipairs( data.positions ) do
			local Scale = (pos_data.time + data.lifetime - Time) / data.lifetime
			local InvScale = 1 - Scale

			render.AddBeam( pos_data.pos, data.start_size * Scale + data.end_size * InvScale, pos_data.time * 50, Color( EntTable.TrailRed, EntTable.TrailGreen, EntTable.TrailBlue, EntTable.TrailAlpha * Scale ^ 2 ) )
		end

		render.EndBeam()
	end

	if Set then
		EntTable._NextTrail = Time + 0.025
	end
end

--addons/lvs_addons/lua/entities/lvs_base_turret/cl_camera.lua:

ENT._lvsSmoothFreeLook = 0

function ENT:CalcViewDirectInput( ply, pos, angles, fov, pod )
	local ViewPosL = pod:WorldToLocal( pos )

	local view = {}
	view.fov = fov
	view.drawviewer = true
	view.angles = self:GetAngles()

	local FreeLook = ply:lvsKeyDown( "FREELOOK" )
	local Zoom = ply:lvsKeyDown( "ZOOM" )

	if not pod:GetThirdPersonMode() then

		if FreeLook then
			view.angles = pod:LocalToWorldAngles( ply:EyeAngles() )
		end

		local velL = self:WorldToLocal( self:GetPos() + self:GetVelocity() )

		local Dividor = math.abs( velL.x )
		local SideForce = math.Clamp( velL.y / Dividor, -1, 1)
		local UpForce = math.Clamp( velL.z / Dividor, -1, 1)

		local ViewPunch = Vector(0,math.Clamp(SideForce * 10,-1,1),math.Clamp(UpForce * 10,-1,1))
		if Zoom then
			ViewPunch = Vector(0,0,0)
		end

		pod._lerpPosOffset = pod._lerpPosOffset and pod._lerpPosOffset + (ViewPunch - pod._lerpPosOffset) * RealFrameTime() * 5 or Vector(0,0,0)
		pod._lerpPos = pos

		view.origin = pos + pod:GetForward() *  -pod._lerpPosOffset.y * 0.5 + pod:GetUp() *  pod._lerpPosOffset.z * 0.5
		view.angles.p = view.angles.p - pod._lerpPosOffset.z * 0.1
		view.angles.y = view.angles.y + pod._lerpPosOffset.y * 0.1
		view.drawviewer = false

		return view
	end

	pod._lerpPos = pod._lerpPos or self:GetPos()

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	if FreeLook then
		local velL = self:WorldToLocal( self:GetPos() + self:GetVelocity() )

		local SideForce = math.Clamp(velL.y / 10,-250,250)
		local UpForce = math.Clamp(velL.z / 10,-250,250)

		pod._lerpPosL = pod._lerpPosL and (pod._lerpPosL + (Vector(radius, SideForce,150 + radius * 0.1 + UpForce) - pod._lerpPosL) * RealFrameTime() * 12) or Vector(0,0,0)
		pod._lerpPos = self:LocalToWorld( pod._lerpPosL )

		view.origin = pod._lerpPos
		view.angles = self:LocalToWorldAngles( Angle(0,180,0) )
	else
		local TargetPos = self:LocalToWorld( Vector(500,0,150 + radius * 0.1) )

		local Sub = TargetPos - pod._lerpPos
		local Dir = Sub:GetNormalized()
		local Dist = Sub:Length()

		local DesiredPos = TargetPos - self:GetForward() * (300 + radius) - Dir * 100

		pod._lerpPos = pod._lerpPos + (DesiredPos - pod._lerpPos) * RealFrameTime() * (Zoom and 30 or 12)
		pod._lerpPosL = self:WorldToLocal( pod._lerpPos )

		local vel = self:GetVelocity()

		view.origin = pod._lerpPos
		view.angles = self:GetAngles()
	end

	view.origin = view.origin + ViewPosL

	return view
end

function ENT:CalcViewMouseAim( ply, pos, angles, fov, pod )
	local cvarFocus = math.Clamp( LVS.cvarCamFocus:GetFloat() , -1, 1 )

	self._lvsSmoothFreeLook = self._lvsSmoothFreeLook + ((ply:lvsKeyDown( "FREELOOK" ) and 0 or 1) - self._lvsSmoothFreeLook) * RealFrameTime() * 10

	local view = {}
	view.origin = pos
	view.fov = fov
	view.drawviewer = true
	view.angles = (self:GetForward() * (1 + cvarFocus) * self._lvsSmoothFreeLook * 0.8 + ply:EyeAngles():Forward() * math.max(1 - cvarFocus, 1 - self._lvsSmoothFreeLook)):Angle()

	if cvarFocus >= 1 then
		view.angles = LerpAngle( self._lvsSmoothFreeLook, ply:EyeAngles(), self:GetAngles() )
	else
		view.angles.r = 0
	end

	if not pod:GetThirdPersonMode() then

		view.drawviewer = false

		return view
	end

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin - view.angles:Forward() * radius  + view.angles:Up() * radius * 0.2
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	if ply:lvsMouseAim() then
		return self:CalcViewMouseAim( ply, pos, angles, fov, pod )
	else
		return self:CalcViewDirectInput( ply, pos, angles, fov, pod )
	end
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:LVSCalcView( ply, original_pos, original_angles, original_fov, pod )
	local pos, angles, fov = self:CalcViewOverride( ply, original_pos, original_angles, original_fov, pod )

	if self:GetDriverSeat() == pod then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else
		return self:CalcViewPassenger( ply, pos, angles, fov, pod )
	end
end
--addons/lvs_addons/lua/entities/lvs_base_turret/sh_camera_eyetrace.lua:

function ENT:GetEyeTrace( trace_forward )
	local startpos = self:LocalToWorld( self:OBBCenter() )

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( pod:OBBCenter() )
	end

	local AimVector = trace_forward and self:GetForward() or self:GetAimVector()

	local data = {
		start = startpos,
		endpos = (startpos + AimVector * 50000),
		filter = self:GetCrosshairFilterEnts(),
	}

	local trace = util.TraceLine( data )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if not IsValid( Driver ) then return self:GetForward() end

	if not Driver:lvsMouseAim() then
		if Driver:lvsKeyDown( "FREELOOK" ) then
			local pod = self:GetDriverSeat()

			if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

			if pod:GetThirdPersonMode() then
				return -self:GetForward()
			else
				return Driver:GetAimVector()
			end
		else
			return self:GetForward()
		end
	end

	if SERVER then
		local pod = self:GetDriverSeat()

		if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

		return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
	else
		return Driver:EyeAngles():Forward()
	end
end

--addons/lvs_addons/lua/entities/lvs_fakehover_barc_medic/cl_init.lua:
include("shared.lua")


function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-30,0,43) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-50,65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-85,-65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:BTLProjector()
	self:DamageFX()
end

function ENT:BTLProjector()
	local Fire = self:GetBTLFire()

	if Fire == self.OldFireBTL then return end

	self.OldFireBTL = Fire
	
	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_left_projector", effectdata )
	end
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 40 - self:GetUp() * 20, angles, fov
	end

	local GunnerPod = self:GetGunnerSeat()

	if pod == GunnerPod and pod:GetThirdPersonMode() then
		return GunnerPod:LocalToWorld( Vector(0,0,60) ), angles + Angle(6,0,0), fov
	end

	return pos, angles, fov
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDraw()
	self:DrawDriverBTL()

	return true
end

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()
	if self:GetBodygroup( 2 ) ~= 1 then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( true ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 60 )
		self.projector = thelamp
	end

	local Start1 = self:LocalToWorld( Vector(64,6,10.5) )
	local Start2 = self:LocalToWorld( Vector(64,-6,10.5) )

	local Dir1 = self:LocalToWorldAngles( Angle(0,5,0) ):Forward()
	local Dir2 = self:LocalToWorldAngles( Angle(0,-5,0) ):Forward()

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( Start1, 32, 32, Color( 100, 100, 100, 255) )
	render.DrawSprite( Start2, 32, 32, Color( 100, 100, 100, 255) )

	render.SetMaterial( self.LightMaterial )
	render.DrawBeam( Start1,  Start1 + Dir1 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 
	render.DrawBeam( Start2,  Start2 + Dir2 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 

	if IsValid( self.projector ) then
		self.projector:SetPos( self:LocalToWorld( Vector(60,0,10.5) ) )
		self.projector:SetAngles( self:LocalToWorldAngles( Angle(15,0,0) ) )
		self.projector:Update()
	end

	return false
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

function ENT:DrawDriverBTL()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end

	if self:GetBodygroup(1) == 2 then
		ply:SetSequence( "sit_rollercoaster" )
		ply:SetRenderAngles( self:GetAngles() )
		ply:DrawModel()

		return
	end

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	local LAng = self:WorldToLocalAngles( Ang )
	LAng.p = 0
	LAng.r = 0

	ply:SetSequence( "sit_rollercoaster" )
	ply:SetRenderAngles( self:LocalToWorldAngles( LAng ) )
	ply:DrawModel()
end

--lua/entities/lvs_fall_missel_base.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Missile"
ENT.Author = "Luna"
ENT.Information = "LVS Missile"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_explosion_small"

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Entity", 0, "NWTarget" )
end

if SERVER then
	util.AddNetworkString( "lvs_missile_hud" )

	function ENT:FindTarget( pos, forward, cone_ang, cone_len )
		local targets = {
			[1] = player.GetAll(),
			[2] = LVS:GetVehicles(),
			[3] = LVS:GetNPCs(),
		}

		local Attacker = self:GetAttacker()
		local Parent = self:GetParent()
		local Owner = self:GetOwner()
		local Target = NULL
		local DistToTarget = 0

		for _, tbl in ipairs( targets ) do
			for _, ent in pairs( tbl ) do
				if not IsValid( ent ) or ent == Parent or ent == Owner or Target == ent or Attacker == ent then continue end

				local pos_ent = ent:GetPos()
				local dir = (pos_ent - pos):GetNormalized()
				local ang = math.deg( math.acos( math.Clamp( forward:Dot( dir ) ,-1,1) ) )

				if ang > cone_ang then continue end

				local dist, _, _ = util.DistanceToLine( pos, pos + forward * cone_len, pos_ent )

				if not IsValid( Target ) then
					Target = ent
					DistToTarget = dist

					continue
				end

				if dist < DistToTarget then
					Target = ent
					DistToTarget = dist
				end
			end
		end

		self:SetTarget( Target )

		local ply = self:GetAttacker()

		if not IsValid( ply ) or not ply:IsPlayer() then return end

		net.Start( "lvs_missile_hud", true )
			net.WriteEntity( self )
		net.Send( ply )
	end

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:SetTarget( ent ) self:SetNWTarget( ent ) end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetSpeed( num ) self._speed = num end
	function ENT:SetTurnSpeed( num ) self._turnspeed = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent ) self._attacker = ent end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 100) end
	function ENT:GetRadius() return (self._radius or 250) end
	function ENT:GetSpeed() return (self._speed or 4000) end
	function ENT:GetTurnSpeed() return (self._turnspeed or 1) * 100 end
	function ENT:GetThrust() return (self._thrust or 500) end
	function ENT:GetTarget()
		if IsValid( self:GetNWTarget() ) then
			local Pos = self:GetPos()
			local tPos = self:GetTargetPos()

			local Sub = tPos - Pos
			local Len = Sub:Length()
			local Dir = Sub:GetNormalized()
			local Forward = self:GetForward()

			local AngToTarget = math.deg( math.acos( math.Clamp( Forward:Dot( Dir ) ,-1,1) ) )

			local LooseAng = math.min( Len / 100, 90 )

			if AngToTarget > LooseAng then
				self:SetNWTarget( NULL )
			end
		end

		return self:GetNWTarget()
	end
	function ENT:GetTargetPos()
		local Target = self:GetNWTarget()

		if not IsValid( Target ) then return Vector(0,0,0) end

		if isfunction( Target.GetShield ) then
			if Target:GetShield() > 0 then
				return Target:LocalToWorld( VectorRand() * math.random( -1000, 1000 ) )
			end
		end

		if isfunction( Target.GetMissileOffset ) then
			return Target:LocalToWorld( Target:GetMissileOffset() )
		end

		return Target:GetPos()
	end

	function ENT:SpawnFunction( ply, tr, ClassName )

		local ent = ents.Create( ClassName )
		ent:SetPos( ply:GetShootPos() )
		ent:SetAngles( ply:EyeAngles() )
		ent:Spawn()
		ent:Activate()
		ent:SetAttacker( ply )
		ent:Enable()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/weapons/w_missile_launch.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		self:PhysWake()

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 100 ) 
		pObj:EnableGravity( true ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( true )
		pObj:SetVelocity(self:GetForward() * 3000) -- This can replaces PhysicsSimulate to make the projectiles drop

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	-- Not needed, cause I just need Velocity
/*
	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local Thrust = self:GetThrust()
		local Speed = self:GetSpeed()
		local Pos = self:GetPos()
		local velL = self:WorldToLocal( Pos + self:GetVelocity() )

		local ForceLinear = (Vector( Speed * Thrust,0,0) - velL) * deltatime
		
		local Target = self:GetTarget()

		if not IsValid( Target ) then
			return (-phys:GetAngleVelocity()/10 * deltatime), ForceLinear, SIM_LOCAL_ACCELERATION
		end
		

		local AngForce = -self:WorldToLocalAngles( (self:GetTargetPos() - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * self:GetTurnSpeed() - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_LOCAL_ACCELERATION
	end
*/
	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T + 1 )

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate()
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		if IsValid( target ) and not target:IsNPC() then
			Pos = target:GetPos() -- place explosion inside the hit targets location so they receive full damage. This fixes all the garbage code the LFS' missile required in order to deliver its damage
		end

		local attacker = self:GetAttacker()

		util.BlastDamage( self, IsValid( attacker ) and attacker or game.GetWorld(), Pos, self:GetRadius(), self:GetDamage() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end
else
	function ENT:Initialize()	
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		self.IsEnabled = true

		self.snd = CreateSound(self, "weapons/rpg/rocket1.wav")
		self.snd:SetSoundLevel( 80 )
		self.snd:Play()

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( self )
		util.Effect( "lvs_missiletrail", effectdata )
	end

	function ENT:CalcDoppler()
		local Ent = LocalPlayer()

		local ViewEnt = Ent:GetViewEntity()

		if Ent:lvsGetVehicle() == self then
			if ViewEnt == Ent then
				Ent = self
			else
				Ent = ViewEnt
			end
		else
			Ent = ViewEnt
		end

		local sVel = self:GetVelocity()
		local oVel = Ent:GetVelocity()

		local SubVel = oVel - sVel
		local SubPos = self:GetPos() - Ent:GetPos()

		local DirPos = SubPos:GetNormalized()
		local DirVel = SubVel:GetNormalized()

		local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

		return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
	end

	function ENT:Draw()
		if not self:GetActive() then return end

		self:DrawModel()
	end

	function ENT:Think()
		if self.snd then
			self.snd:ChangePitch( 100 * self:CalcDoppler() )
		end

		if self.IsEnabled then return end

		if self:GetActive() then
			self:Enable()
		end
	end

	function ENT:SoundStop()
		if self.snd then
			self.snd:Stop()
		end
	end

	function ENT:OnRemove()
		self:SoundStop()
	end

	local function DrawDiamond( X, Y, radius, angoffset )
		angoffset = angoffset or 0

		local segmentdist = 90
		local radius2 = radius + 1

		for ang = 0, 360, segmentdist do
			local a = ang + angoffset
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius, Y - math.sin( math.rad( a ) ) * radius, X + math.cos( math.rad( a + segmentdist ) ) * radius, Y - math.sin( math.rad( a + segmentdist ) ) * radius )
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius2, Y - math.sin( math.rad( a ) ) * radius2, X + math.cos( math.rad( a + segmentdist ) ) * radius2, Y - math.sin( math.rad( a + segmentdist ) ) * radius2 )
		end
	end

	local color_red = Color(255,0,0,255)
	local HudTargets = {}
	hook.Add( "HUDPaint", "!!!!lvs_missile_hud", function()
		local T = CurTime()

		local Index = 0

		surface.SetDrawColor( 255, 0, 0, 255 )

		for ID, _ in pairs( HudTargets ) do
			local Missile = Entity( ID )

			if not IsValid( Missile ) then
				HudTargets[ ID ] = nil

				continue
			end

			local Target = Missile:GetNWTarget()

			if not IsValid( Target ) then
				HudTargets[ ID ] = nil

				continue
			end

			local MissilePos = Missile:GetPos():ToScreen()
			local TargetPos = Target:LocalToWorld( Target:OBBCenter() ):ToScreen()

			Index =  Index + 1

			if not TargetPos.visible then continue end

			DrawDiamond( TargetPos.x, TargetPos.y, 40, ID * 1337 - T * 100 )

			if isfunction( Target.GetShield ) and Target:GetShield() > 0 then
				draw.DrawText("WEAK LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			else
				draw.DrawText(" FULL LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			end

			if not MissilePos.visible then continue end

			DrawDiamond( MissilePos.x, MissilePos.y, 16, ID * 1337 - T * 100 )
			draw.DrawText( Index, "LVS_FONT", MissilePos.x + 10, MissilePos.y + 10, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		
			surface.DrawLine( MissilePos.x, MissilePos.y, TargetPos.x, TargetPos.y )
		end
	end )

	net.Receive( "lvs_missile_hud", function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) then return end

		HudTargets[ ent:EntIndex() ] = true
	end )
end
--addons/lvs_base/lua/entities/lvs_missile.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Missile"
ENT.Author = "Luna"
ENT.Information = "LVS Missile"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_explosion_small"

ENT.lvsProjectile = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Entity", 0, "NWTarget" )
end

if SERVER then
	util.AddNetworkString( "lvs_missile_hud" )

	function ENT:GetAvailableTargets()
		local targets = {
			[1] = player.GetAll(),
			[2] = LVS:GetVehicles(),
			[3] = LVS:GetNPCs(),
		}

		return targets
	end

	function ENT:FindTarget( pos, forward, cone_ang, cone_len )
		local targets = self:GetAvailableTargets()

		local Attacker = self:GetAttacker()
		local Parent = self:GetParent()
		local Owner = self:GetOwner()
		local Target = NULL
		local DistToTarget = 0

		for _, tbl in ipairs( targets ) do
			for _, ent in pairs( tbl ) do
				if not IsValid( ent ) or ent == Parent or ent == Owner or Target == ent or Attacker == ent then continue end

				local pos_ent = ent:GetPos()
				local dir = (pos_ent - pos):GetNormalized()
				local ang = math.deg( math.acos( math.Clamp( forward:Dot( dir ) ,-1,1) ) )

				if ang > cone_ang then continue end

				local dist, _, _ = util.DistanceToLine( pos, pos + forward * cone_len, pos_ent )

				if not IsValid( Target ) then
					Target = ent
					DistToTarget = dist

					continue
				end

				if dist < DistToTarget then
					Target = ent
					DistToTarget = dist
				end
			end
		end

		self:SetTarget( Target )

		local ply = self:GetAttacker()

		if not IsValid( ply ) or not ply:IsPlayer() then return end

		net.Start( "lvs_missile_hud", true )
			net.WriteEntity( self )
		net.Send( ply )
	end

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:SetTarget( ent ) self:SetNWTarget( ent ) end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetForce( num ) self._force = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetSpeed( num ) self._speed = num end
	function ENT:SetTurnSpeed( num ) self._turnspeed = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent ) self._attacker = ent end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 100) end
	function ENT:GetForce() return (self._force or 4000) end
	function ENT:GetRadius() return (self._radius or 250) end
	function ENT:GetSpeed() return (self._speed or 4000) end
	function ENT:GetTurnSpeed() return (self._turnspeed or 1) * 100 end
	function ENT:GetThrust() return (self._thrust or 500) end
	function ENT:GetTarget()
		if IsValid( self:GetNWTarget() ) then
			local Pos = self:GetPos()
			local tPos = self:GetTargetPos()

			local Sub = tPos - Pos
			local Len = Sub:Length()
			local Dir = Sub:GetNormalized()
			local Forward = self:GetForward()

			local AngToTarget = math.deg( math.acos( math.Clamp( Forward:Dot( Dir ) ,-1,1) ) )

			local LooseAng = math.min( Len / 100, 90 )

			if AngToTarget > LooseAng then
				self:SetNWTarget( NULL )
			end
		end

		return self:GetNWTarget()
	end
	function ENT:GetTargetPos()
		local Target = self:GetNWTarget()

		if not IsValid( Target ) then return Vector(0,0,0) end

		if isfunction( Target.GetMissileOffset ) then
			return Target:LocalToWorld( Target:GetMissileOffset() )
		end

		return Target:GetPos()
	end

	function ENT:SpawnFunction( ply, tr, ClassName )

		local ent = ents.Create( ClassName )
		ent:SetPos( ply:GetShootPos() )
		ent:SetAngles( ply:EyeAngles() )
		ent:Spawn()
		ent:Activate()
		ent:SetAttacker( ply )
		ent:Enable()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/weapons/w_missile_launch.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		self:PhysWake()

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 1 ) 
		pObj:EnableGravity( false ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local Thrust = self:GetThrust()
		local Speed = self:GetSpeed()
		local Pos = self:GetPos()
		local velL = self:WorldToLocal( Pos + self:GetVelocity() )

		local ForceLinear = (Vector( Speed * Thrust,0,0) - velL) * deltatime

		local Target = self:GetTarget()

		if not IsValid( Target ) then
			return (-phys:GetAngleVelocity() * 250 * deltatime), ForceLinear, SIM_LOCAL_ACCELERATION
		end

		local AngForce = -self:WorldToLocalAngles( (self:GetTargetPos() - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * self:GetTurnSpeed() - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_LOCAL_ACCELERATION
	end

	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T + 1 )

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
		[COLLISION_GROUP_INTERACTIVE_DEBRIS] = true,
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		if entity.lvsProjectile then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		local attacker = self:GetAttacker()

		LVS:BlastDamage( Pos, self:GetForward(), IsValid( attacker ) and attacker or game.GetWorld(), self, self:GetDamage(), DMG_BLAST, self:GetRadius(), self:GetForce() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end
else
	function ENT:Initialize()	
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		self.IsEnabled = true

		self.snd = CreateSound(self, "weapons/rpg/rocket1.wav")
		self.snd:SetSoundLevel( 80 )
		self.snd:Play()

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( self )
		util.Effect( "lvs_missiletrail", effectdata )
	end

	function ENT:CalcDoppler()
		local Ent = LocalPlayer()

		local ViewEnt = Ent:GetViewEntity()

		if Ent:lvsGetVehicle() == self then
			if ViewEnt == Ent then
				Ent = self
			else
				Ent = ViewEnt
			end
		else
			Ent = ViewEnt
		end

		local sVel = self:GetVelocity()
		local oVel = Ent:GetVelocity()

		local SubVel = oVel - sVel
		local SubPos = self:GetPos() - Ent:GetPos()

		local DirPos = SubPos:GetNormalized()
		local DirVel = SubVel:GetNormalized()

		local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

		return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
	end

	function ENT:Draw()
		if not self:GetActive() then return end

		self:DrawModel()
	end

	function ENT:Think()
		if self.snd then
			self.snd:ChangePitch( 100 * self:CalcDoppler() )
		end

		if self.IsEnabled then return end

		if self:GetActive() then
			self:Enable()
		end
	end

	function ENT:SoundStop()
		if self.snd then
			self.snd:Stop()
		end
	end

	function ENT:OnRemove()
		self:SoundStop()
	end

	local function DrawDiamond( X, Y, radius, angoffset )
		angoffset = angoffset or 0

		local segmentdist = 90
		local radius2 = radius + 1

		for ang = 0, 360, segmentdist do
			local a = ang + angoffset
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius, Y - math.sin( math.rad( a ) ) * radius, X + math.cos( math.rad( a + segmentdist ) ) * radius, Y - math.sin( math.rad( a + segmentdist ) ) * radius )
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius2, Y - math.sin( math.rad( a ) ) * radius2, X + math.cos( math.rad( a + segmentdist ) ) * radius2, Y - math.sin( math.rad( a + segmentdist ) ) * radius2 )
		end
	end

	local color_red = Color(255,0,0,255)
	local HudTargets = {}
	hook.Add( "HUDPaint", "!!!!lvs_missile_hud", function()
		local T = CurTime()

		local Index = 0

		surface.SetDrawColor( 255, 0, 0, 255 )

		for ID, _ in pairs( HudTargets ) do
			local Missile = Entity( ID )

			if not IsValid( Missile ) then
				HudTargets[ ID ] = nil

				continue
			end

			local Target = Missile:GetNWTarget()

			if not IsValid( Target ) then
				HudTargets[ ID ] = nil

				continue
			end

			local MissilePos = Missile:GetPos():ToScreen()
			local TargetPos = Target:LocalToWorld( Target:OBBCenter() ):ToScreen()

			Index =  Index + 1

			if not TargetPos.visible then continue end

			DrawDiamond( TargetPos.x, TargetPos.y, 40, ID * 1337 - T * 100 )

			draw.DrawText("LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )

			if not MissilePos.visible then continue end

			DrawDiamond( MissilePos.x, MissilePos.y, 16, ID * 1337 - T * 100 )
			draw.DrawText( Index, "LVS_FONT", MissilePos.x + 10, MissilePos.y + 10, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		
			surface.DrawLine( MissilePos.x, MissilePos.y, TargetPos.x, TargetPos.y )
		end
	end )

	net.Receive( "lvs_missile_hud", function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) then return end

		HudTargets[ ent:EntIndex() ] = true
	end )
end
--addons/lvs_addons/lua/entities/lvs_protontorpedo.lua:
AddCSLuaFile()

ENT.Base = "lvs_missile"

ENT.Type            = "anim"

ENT.PrintName = "Proton Torpedo"
ENT.Author = "Luna"
ENT.Information = "geht ab wie'n zpfchen"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_proton_explosion"
ENT.GlowColor = Color( 0, 127, 255, 255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 400)
	end

	function ENT:GetRadius() 
		return (self._radius or 150)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_proton_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--addons/lvs_addons/lua/entities/lvs_repfighter_swtor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Republic Fighter"
ENT.Author = "Ophra"
ENT.Information = "Fighter of the Republic"
ENT.Category = "[LVS] - SWTOR"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_rep_fighter_nolanding.mdl"
ENT.GibModels = {
	"models/salza/arc170_gib1.mdl",
	"models/salza/arc170_gib2.mdl",
	"models/salza/arc170_gib3.mdl",
	"models/salza/arc170_gib4.mdl",
	"models/salza/arc170_gib5.mdl",
	"models/salza/arc170_gib6.mdl"
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.8
ENT.TurnRateYaw = 0.8
ENT.TurnRateRoll = 0.8

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 800
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "TailGunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(150.57,-272.18,-42.15),
		Vector(150.57,272.18,-42.15),
		
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1000
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end
 
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 30
		bullet.Damage	= 40
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("ophra/ships/weaponswitch.wav")
		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 26
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 150.57, (ent._swapMissile and 272.18 or -272.18), -42.15 ) 

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0) ) ) 
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "ophra/ships/shootsound4heavy.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )




	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 60 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-175.81,0,50.26) or Vector(-171.69,0,5.81) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 45
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("ophra/ships/randomsound1.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "ophra/ships/flysound5.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/i"
ENT.Author = "Luna"
ENT.Information = "Gunship/Troop Transport of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Gunships"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/laat.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.MaxPitch = 60

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 4000

ENT.AutomaticFrameAdvance = true

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "BTPodL" )
	self:AddDT( "Entity", "BTPodR" )

	self:AddDT( "Bool", "RearHatch" )

	self:AddDT( "Int", "DoorMode" )

	self:AddDT( "Bool", "WingTurretFire" )
	self:AddDT( "Vector", "WingTurretTarget" )

	self:AddDT( "Bool", "BTLFire" )
	self:AddDT( "Bool", "BTRFire" )

	self:AddDT( "Bool", "LightsActive" )
end

function ENT:InitWeapons()
	self:InitWeaponDriver()
	self:InitWeaponGunner()
	self:InitWeaponBTL()
	self:InitWeaponBTR()
end

sound.Add( {
	name = "LVS.LAAT.FLYBY",
	sound = {
		"lvs/vehicles/laat/flyby1.wav",
		"lvs/vehicles/laat/flyby2.wav",
		"lvs/vehicles/laat/flyby3.wav",
		"lvs/vehicles/laat/flyby4.wav",
		"lvs/vehicles/laat/flyby5.wav",
	}
} )

ENT.FlyByAdvance = 1
ENT.FlyBySound = "LVS.LAAT.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 

		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	if Pod == self:GetBTPodL() or Pod == self:GetBTPodR() then
		ply.CalcIdeal = ACT_STAND
		ply.CalcSeqOverride = ply:LookupSequence( "drive_jeep" )

		return ply.CalcIdeal, ply.CalcSeqOverride
	end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end
--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship/cl_prediction.lua:

function ENT:PredictBTL()
	local pod = self:GetBTPodL()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPosBTL()
	self:SetPoseParameterBTL( pod:lvsGetWeapon() )
end

function ENT:PredictBTR()
	local pod = self:GetBTPodR()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPosBTR()
	self:SetPoseParameterBTR( pod:lvsGetWeapon() )
end

function ENT:PredictPoseParamaters()
	self:PredictBTL()
	self:PredictBTR()

	self:InvalidateBoneCache()
end
--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship/cl_lights.lua:

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:RemoveLight()
	if IsValid( self.projector_L ) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid( self.projector_R ) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end

function ENT:PostDrawTranslucent()
	if self:GetBodygroup( 5 ) ~= 2 or not self:GetLightsActive() then 
		self:RemoveLight()

		return
	end

	if not IsValid( self.projector_L ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector_L = thelamp
	end

	if not IsValid( self.projector_R ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector_R = thelamp
	end

	if not self.SpotlightID_L then
		self.SpotlightID_L = self:LookupAttachment( "spotlight_left" )
	else
		local attachment = self:GetAttachment( self.SpotlightID_L )

		if attachment then
			local StartPos = attachment.Pos
			local Dir = attachment.Ang:Up()

			render.SetMaterial( self.GlowMaterial )
			render.DrawSprite( StartPos + Dir * 20, 400, 400, Color( 255, 255, 255, 255) )

			render.SetMaterial( self.LightMaterial )
			render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10) ) 
			
			if IsValid( self.projector_L ) then
				self.projector_L:SetPos( StartPos )
				self.projector_L:SetAngles( Dir:Angle() )
				self.projector_L:Update()
			end
		end
	end

	if not self.SpotlightID_R then
		self.SpotlightID_R = self:LookupAttachment( "spotlight_right" )
	else
		local attachment = self:GetAttachment( self.SpotlightID_R )

		if attachment then
			local StartPos = attachment.Pos
			local Dir = attachment.Ang:Up()

			render.SetMaterial( self.GlowMaterial )
			render.DrawSprite( StartPos + Dir * 20, 400, 400, Color( 255, 255, 255, 255) )

			render.SetMaterial( self.LightMaterial )
			render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10 ) ) 

			if IsValid( self.projector_R ) then
				self.projector_R:SetPos( StartPos )
				self.projector_R:SetAngles( Dir:Angle() )
				self.projector_R:Update()
			end
		end
	end
end

function ENT:AnimLights()
	if self:GetBodygroup( 5 ) ~= 2 then return end

	local TargetValue = self:HitGround() and 0 or 1
	local Rate = FrameTime() * 10

	self.smSpotLight = isnumber( self.smSpotLight ) and (self.smSpotLight + math.Clamp(TargetValue - self.smSpotLight,-Rate,Rate * 0.1)) or 0

	if not self.SpotLightID_L then
		self.SpotLightID_L = self:LookupBone( "spotlight_left" ) 
	else
		self:ManipulateBoneAngles( self.SpotLightID_L, Angle(10,-30,5) * self.smSpotLight )	
	end

	if not self.SpotLightID_R then
		self.SpotLightID_R = self:LookupBone( "spotlight_right" ) 
	else
		self:ManipulateBoneAngles( self.SpotLightID_R, Angle(-10,30,5) * self.smSpotLight )	
	end
end
--addons/laat_g/lua/entities/lvs_repulsorlift_gunship_heavy/sh_mainweapons.lua:
function ENT:InitWeaponDriver()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		if math.abs( ent.frontgunYaw ) > 100 then return end

		local ID_L = self:LookupAttachment( "muzzle_frontgun_left" )
		local ID_R = self:LookupAttachment( "muzzle_frontgun_right" )
		local Muzzle = {
			[1] = self:GetAttachment( ID_L ),
			[2] = self:GetAttachment( ID_R ),
		}

		local NewHeat = ent:GetHeat()

		for id = 1, 2 do
			if id == 1 and ent.frontgunYaw > 5 then continue end
			if id == 2 and ent.frontgunYaw < -5 then continue end

			local att = Muzzle[ id ]

			local bullet = {}
			bullet.Src 	= att.Pos
			bullet.Dir 	= att.Ang:Up()
			bullet.Spread 	= Vector( 0.015,  0.015, 0 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 40
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end

			ent:LVSFireBullet( bullet )
			ent:TakeAmmo()

			NewHeat = NewHeat + 0.075
		end

		ent:SetHeat( NewHeat )

		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("frontgun_pitch", 0 )
			ent:SetPoseParameter("frontgun_yaw", 0 )

			return
		end

		ent:SetPoseParameter("frontgun_pitch", -AimAngles.p )
		ent:SetPoseParameter("frontgun_yaw", -AimAngles.y )
	end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 20
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			if IsValid( ent._ProtonTorpedo:GetTarget() ) then
				ent:SetBodygroup( 1, 1 )
			end

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.35

		ent._swapMissile = not ent._swapMissile

		local TypeA = self:GetBodygroup( 3 ) == 0
		local Pos = Vector( (TypeA and -20 or 206.07), (ent._swapMissile and -59 or 59), 286.88 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( TypeA and "lvs_protontorpedo" or "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile
		ent._TypeA = TypeA

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		ent:SetBodygroup( 1, 0 )

		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( self._TypeA and "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3" or "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.33

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

end
--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship_space/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	self:InvalidateBoneCache()
end
--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship_space/sh_gunnerweapons.lua:

function ENT:SetNextRearGunFire( delay )
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:GetRearGunInRange( ent )
	return ent:AngleBetweenNormal( ent:GetAimVector(), -ent:GetForward() ) < 35
end

function ENT:HandleRearGun( ent, ShouldFire )
	local trace = ent:GetEyeTrace()

	local Pos, Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

	if not self:GetRearGunInRange( ent ) then 
		self:SetPoseParameter("back_turret_z", 0)
		self:SetPoseParameter("back_turret_y", 0)

		return false
	end

	self:SetPoseParameter("back_turret_z", -Ang.p )
	self:SetPoseParameter("back_turret_y", -Ang.y )

	if not ShouldFire or not self:CanFireRearGun() then self:GetRearGunInRange( ent ) return end

	local Muzzle = self:GetBonePosition(self:LookupBone("Rear_Gun_End"))
	if not Muzzle then return self:GetRearGunInRange(ent) end

	self:SetNextRearGunFire(0.3)

	local bullet = {}
	bullet.Src 	= Muzzle
	bullet.Dir 	= (trace.HitPos - Muzzle):GetNormalized()
	bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
	bullet.TracerName = "lvs_laser_green"
	bullet.Force	= 10
	bullet.HullSize 	= 25
	bullet.Damage	= 65
	bullet.Velocity = 30000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart(Vector(50,255,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
		util.Effect("lvs_laser_impact", effectdata)
	end
	ent:LVSFireBullet(bullet)

	local NewHeat = ent:GetHeat() + 0.4


	ent:SetHeat( NewHeat )
	if NewHeat >= 1 then
		ent:SetOverheated( true )
	end

	if not IsValid( self.SNDTail ) then return end

	self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
end

function ENT:InitGunnerWeapons()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	local MaxRange = 60
	local MaxTailRange = 35

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.StartAttack = function( ent )
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function( ent )
		ent.ShouldFire = false

		local base = ent:GetVehicle()

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		for _, sound in pairs( snd ) do
			if not IsValid( sound ) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		local ShouldFire = (ent.ShouldFire == true) and ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) < MaxRange

		if base:HandleRearGun( ent, ent.ShouldFire ) then
			ShouldFire = false
		end

		if base:SetWingTurretFire() ~= ShouldFire then
			base:SetWingTurretFire(ShouldFire)
		end

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		if ent._oldShouldFire ~= ShouldFire then
			ent._oldShouldFire = ShouldFire
			if ShouldFire then
				for _, sound in pairs( snd ) do
					if not IsValid( sound ) then continue end

					sound:EmitSound("laat_bf2/ballturret_fire.mp3", 110)
				end
			end
		end

		if not ShouldFire then
			for _, sound in pairs( snd ) do
				if not IsValid( sound ) then continue end
				sound:Stop()
			end

			ent:SetHeat( ent:GetHeat() - FrameTime() )

			return
		end

		if not active then
			return
		end

		local trace = ent:GetEyeTrace()
		local DesEndPos = trace.HitPos

		base:SetWingTurretTarget( DesEndPos )

		if not base:GetWingTurretFire() then return end

		local DesStartPos

		if base:WorldToLocal( DesEndPos ).z < 0 then
			DesStartPos = Vector(-172.97,334.04,93.25)
		else
			DesStartPos = Vector(-174.79,350.05,125.98)
		end

		local NewHeat = ent:GetHeat()

		for i = -1,1,2 do
			local StartPos = self:LocalToWorld( DesStartPos * Vector(1,i,1) )
			local beam = util.TraceLine( { start = StartPos, endpos = DesEndPos} )

			self:BallturretDamage( beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized() )

			if not IsValid( snd[i] ) then continue end

			if beam.Entity ~= base then
				snd[i]:Play()
				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * (250 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - clamped_angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end
--addons/lvs_addons/lua/entities/lvs_sithheavy_swtor/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-151,87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,87,-15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,-15), 0, 20, 2, 1000, 150 )
end
 
-- Engine Particles start

ENT.EngineColor = Color( 255, 0, 0)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-745.52,242.78,-29.65),
	Vector(-745.52,-242.78,-29.65),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.3)
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(100,200) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 0, 0)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end


-- Engine Particles End

function ENT:PostDraw()
	if not self:GetEngineActive() then return end
end

function ENT:OnStartBoost()
	self:EmitSound( "ophra/ships/powerstart3.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "ophra/ships/shutdown.wav", 85 )
end


--addons/lvs_addons/lua/entities/lvs_starfighter_engine.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "Float",1, "HP" )
	self:NetworkVar( "Float",2, "MaxHP" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 50, 5, Color( 0, 255, 255 ) )
	end

	function ENT:Think()
		local T = CurTime()
		local vehicle = self:GetBase()

		if not self:GetDestroyed() or not IsValid( vehicle ) or not vehicle:GetEngineActive() then self:NextThink( T + 1 ) return true end

		local PhysObj = vehicle:GetPhysicsObject()

		local Pos = self:GetPos()
		local Len = vehicle:WorldToLocal( Pos ):Length()

		PhysObj:ApplyForceOffset( -vehicle:GetVelocity() * (PhysObj:GetMass() / Len) * FrameTime() * 50, Pos )

		self:NextThink( T )

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		if self:GetDestroyed() then return end

		local Damage = dmginfo:GetDamage()

		if Damage <= 0 then return end

		local CurHealth = self:GetHP()

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:SetHP( NewHealth )

		if NewHealth <= 0 then
			self:SetDestroyed( true )
		end
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	self:DamageFX( vehicle )
end

function ENT:OnRemove()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:DamageFX( vehicle )
	local T = CurTime()
	local HP = vehicle:GetHP()
	local MaxHP = vehicle:GetMaxHP() 

	if HP <= 0 then return end

	if (self.nextDFX or 0) > T then return end

	self.nextDFX = T + 0.05

	local Destroyed = self:GetDestroyed()

	if Destroyed or HP < MaxHP * 0.5 then
		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( vehicle )
		util.Effect( "lvs_engine_blacksmoke", effectdata )
	end

	if not Destroyed then return end

	if HP < MaxHP * 0.5 then
		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetNormal( -self:GetForward() )
			effectdata:SetMagnitude( 2 )
			effectdata:SetEntity( vehicle )
		util.Effect( "lvs_exhaust_fire", effectdata )
	end
end

--addons/lvs_addons/lua/entities/lvs_starfighter_skipray/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "GAT-12h Skipray"
ENT.Author = "Nashatok"
ENT.Information = "Designed by Seinar Fleet Systems for the Galactic Empire, the design is often seen in use by militia and pirates"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/skipray/skipray1.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 1900
ENT.MaxThrust = 1900

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 750
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(115,73 * i,37) )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	--Weapon 2 - Assault Turret
	self.FirePositions = {
		Vector(68,-5,122),
		Vector(68,7,122),
	}
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 3000
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	--Weapon 3 - Proton Torpedoes
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.UseableByAI = false
	weapon.Ammo = 12
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile
		--(0,0,165)
		local Pos = Vector( 30,(ent._swapMissile and 95 or -95),70 )

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( ent:GetDriver() )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_spiral/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Cutlass-9 Patrol Fighter"
ENT.Author = "Nashatok"
ENT.Information = "Light Interceptor designed by MandalMotors, popular among pirates and militias"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/sharpspiral/rep_sharpspiral_servius.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 350
ENT.MaxShield = 100

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(110,-96,68),
		Vector(110,96,68),
	}
	
	--Weapon 1 - Rapid-fire Laser Cannons
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 2 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 30
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	--Weapon 2: Concussion Missile Launcher
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.UseableByAI = false
	weapon.Ammo = 4
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Vector(230,0,20) ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( ent:GetDriver() )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 1

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_turret_aa/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Air Turret"
ENT.Author = "Luna"
ENT.Information = "It shoots lasers into the sky and makes things go boom"
ENT.Category = "[LVS] - Turrets (Republic)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antiairturret/rep_anti-airturret.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 4800

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle1" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,60) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= -10 or AimAngles.p <= -180)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.HeatRateUp = .34
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID_1 = self:LookupAttachment( "muzzle1" )
		local ID_2 = self:LookupAttachment( "muzzle2" )
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )

		if not Muzzle1 or not Muzzle2 then return end		

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 100
		bullet.HullSize 	= 50
		bullet.Damage	= 35
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = .2
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()
		local dir = ent:GetAimVector()
		local trace = ent:GetEyeTrace()
		local base = ent:GetVehicle()

		local ID_1 = self:LookupAttachment( "muzzle1" )
		local ID_2 = self:LookupAttachment( "muzzle2" )
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )

		if not Muzzle1 or not Muzzle2 then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Up()

		ent.SwapTopBottom = not ent.SwapTopBottom

		base.SecondarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = Pos
		bullet.Dir = Dir
		bullet.Spread 	= Vector( 0.07,  0.07, 0.07 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--addons/lvs_addons/lua/entities/lvs_turret_ai_red/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--addons/lvs_addons/lua/entities/lvs_walker_atrt/shared.lua:
ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "AT-RT"
ENT.Author = "Deltaa & Deno"
ENT.Information = "The All Terrain Recon Transport (AT-RT) was a one-man bipedal walker used for reconnaissance and patrolling"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/KingPommes/starwars/atrt/main.mdl"

ENT.AITEAM = 2

ENT.MaxHealth = 4000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 73
ENT.HoverTraceLength = 400
ENT.HoverHullRadius = 5

ENT.TurretTurnRate = 100

ENT.JumpForce = 3000000
ENT.JumpDelay = 1

ENT.LAATC_PICKUPABLE = false
ENT.LAATC_DROP_IN_AIR = false
ENT.LAATC_PICKUP_POS = Vector(-260, 0, 0)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true
}

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")
	self:AddDT("Bool", "NWGround")
	self:AddDT("Bool", "Disabled")
    self:AddDT("Bool", "IsJumping")
	self:AddDT("Bool", "ProperJump")
    self:AddDT( "Int", "LastJump")

	if SERVER then
		self:NetworkVarNotify("Disabled", self.OnDisabled)
	end
end

function ENT:HitGround()
	return self:GetNWGround()
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid(Driver) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld(Vector(0, 0, 74))
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:InitWeapons()
	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.3
	weapon.Attack = function(ent)
		local veh = ent:GetVehicle()
		if not IsValid(veh) then return end

		local Attachment = self:GetAttachment(self:LookupAttachment("turret"))
		if not Attachment then return end

		local dir = ent:GetAimVector()
		if ent:AngleBetweenNormal(dir, ent:GetForward()) > 60 then return true end
		if ent:AngleBetweenNormal(dir, ent:GetUp()) > 120 then return true end

		local EyeAngle = dir:Angle()
		local forward = EyeAngle:Forward()
		local direction = forward:GetNormalized()

		local CurPos = Vector(68, 0, 69)

		local bullet = {}
		bullet.Src = veh:LocalToWorld(CurPos)
		bullet.Dir = Vector(direction.x, direction.y, direction.z)
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 50
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		self.Turret:ResetSequence(self.Turret:LookupSequence("Shoot"))
		self.Turret:SetPlaybackRate(1)
		self:EmitSound("LVS.AT-RT.Shoot")
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

sound.Add({
	name = "LVS.AT-RT.Shoot",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {160, 180},
	sound = {
		"kingpommes/starwars/atrt/shoot1.wav",
		"kingpommes/starwars/atrt/shoot2.wav"
	}
})

sound.Add( {
	name = "atrt.step1",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/step1.wav"
} )

sound.Add( {
	name = "atrt.step2",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/step2.wav"
} )
--addons/lvs_addons/lua/entities/lvs_walker_atte/cl_legs.lua:

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:DamageFX()

	local RearEnt = self:GetRearEntity()

	if not IsValid( RearEnt ) then return end

	if self:GetIsRagdoll() then 
		self:LegClearAll()
		RearEnt:LegClearAll()

		return
	end

	local Up = self:GetUp()
	local Forward = self:GetForward()
	local Vel = self:GetVelocity()
	
	local Stride = 40
	local Lift = 20
	
	local FT = math.min(FrameTime(),0.08) -- if fps lower than 12, clamp the frametime to avoid spazzing.

	local Rate = FT * 20

	if Vel:Length() < 10 then -- sync with server animation when not moving
		self.Move = self:GetMove()
	else
		self.Move = self.Move and self.Move + self:WorldToLocal( self:GetPos() + Vel ).x * FT * 1.8 or 0
	end
	
	local Cycl1 = self.Move
	local Cycl2 = self.Move + 180
	local Cycl3 = self.Move + 90
	local Cycl4 = self.Move + 270
	local Cycl5 = self.Move
	local Cycl6 = self.Move + 180
	
	local IsMoving = self:GetIsMoving()
	
	if self:GetIsCarried() then
		self.TRACEPOS1 = self:LocalToWorld( Vector(200,70,180) )
		self.TRACEPOS2 = self:LocalToWorld( Vector(200,-70,180) )
		self.TRACEPOS3 = RearEnt:LocalToWorld( Vector(-160,-70,180) )
		self.TRACEPOS4 = RearEnt:LocalToWorld( Vector(-160,70,180) )
		self.TRACEPOS5 = RearEnt:LocalToWorld( Vector(0,-140,150) )
		self.TRACEPOS6 = RearEnt:LocalToWorld( Vector(0,140,150) )
		Cycl1 = 0
		Cycl2 = 0
		Cycl3 = 0
		Cycl4 = 0
		Cycl5 = 0
		Cycl6 = 0
		IsMoving = true
	end

	local MoveRoll = math.cos( math.rad(self:GetMove()) ) * 2

	-- FRONT LEFT
	local X = 20 + math.cos( math.rad(Cycl1) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl1) ), 0) * Lift
	local STARTPOS = self:LocalToWorld( Vector(179.38,49.49,135.76) )
	self.TRACEPOS1 = self.TRACEPOS1 and self.TRACEPOS1 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS1 = self.TRACEPOS1 + (STARTPOS + Forward * X - self.TRACEPOS1) * Rate
		self.FSOG1 = false
	else
		self.FSOG1 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS1 - Up * 50, endpos = self.TRACEPOS1 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (45+Z)
	if self.FSOG1 ~= self.oldFSOG1 then
		self.oldFSOG1 = self.FSOG1
		if self.FSOG1 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4).."_light.ogg" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/hydraulic"..math.random(1,7)..".ogg" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/blu/atte_smallleg_part3.mdl", Ang = Angle(-90,-90,0), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/atte_smallleg_part2.mdl", Ang = Angle(-90,-90,0), Pos = Vector(3,4,0)},
		Foot = {MDL = "models/blu/atte_smallleg_part1.mdl", Ang = Angle(0,0,MoveRoll), Pos = Vector(0,-4,0)}
	}
	self:GetLegEnts( 1, 60, 65, self:LocalToWorldAngles( Angle(90,-10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	-- FRONT RIGHT
	local STARTPOS = self:LocalToWorld( Vector(179.38,-49.49,135.76) )
	local X = 20 + math.cos( math.rad(Cycl2) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl2) ), 0) * Lift
	self.TRACEPOS2 = self.TRACEPOS2 and self.TRACEPOS2 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS2 = self.TRACEPOS2 + (STARTPOS + Forward * X - self.TRACEPOS2) * Rate
		self.FSOG2 = false
	else
		self.FSOG2 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS2 - Up * 50, endpos = self.TRACEPOS2 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (45+Z)
	if self.FSOG2 ~= self.oldFSOG2 then
		self.oldFSOG2 = self.FSOG2
		if self.FSOG2 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4).."_light.ogg" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/hydraulic"..math.random(1,7)..".ogg" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/blu/atte_smallleg_part3.mdl", Ang = Angle(-90,90,0), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/atte_smallleg_part2.mdl", Ang = Angle(-90,90,0), Pos = Vector(-3,-4,0)},
		Foot = {MDL = "models/blu/atte_smallleg_part1.mdl", Ang = Angle(0,180,-MoveRoll), Pos = Vector(0,4,0)}
	}
	
	self:GetLegEnts( 2, 60, 65, self:LocalToWorldAngles( Angle(90,10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	local Forward = RearEnt:GetForward()
	local Up = RearEnt:GetUp()

	-- REAR RIGHT
	local STARTPOS = RearEnt:LocalToWorld( Vector(-144.56,-68.16,126.39) )
	local X = -20 + math.cos( math.rad(Cycl5) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl5) ), 0) * Lift
	self.TRACEPOS3 = self.TRACEPOS3 and self.TRACEPOS3 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS3 = self.TRACEPOS3 + (STARTPOS + Forward * X - self.TRACEPOS3) * Rate
		self.FSOG3 = false
	else
		self.FSOG3 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS3 - Up * 50, endpos = self.TRACEPOS3 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (45+Z)
	if self.FSOG3 ~= self.oldFSOG3 then
		self.oldFSOG3 = self.FSOG3
		if self.FSOG3 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4).."_light.ogg" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/hydraulic"..math.random(1,7)..".ogg" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/blu/atte_smallleg_part3.mdl", Ang = Angle(-90,-90,0), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/atte_smallleg_part2.mdl", Ang = Angle(-90,-90,0), Pos = Vector(3,4,0)},
		Foot = {MDL = "models/blu/atte_smallleg_part1.mdl", Ang = Angle(0,180,0), Pos = Vector(0,4,0)}
	}
	
	RearEnt:GetLegEnts( 3, 60, 65, RearEnt:LocalToWorldAngles( Angle(90,180,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	-- REAR LEFT
	local STARTPOS = RearEnt:LocalToWorld( Vector(-144.56,68.16,126.39) )
	local X = -20 + math.cos( math.rad(Cycl6) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl6) ), 0) * Lift
	self.TRACEPOS4 = self.TRACEPOS4 and self.TRACEPOS4 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS4 = self.TRACEPOS4 + (STARTPOS + Forward * X - self.TRACEPOS4) * Rate
		self.FSOG4 = false
	else
		self.FSOG4 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS4 - Up * 50, endpos = self.TRACEPOS4 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (45+Z)
	if self.FSOG4 ~= self.oldFSOG4 then
		self.oldFSOG4 = self.FSOG4
		if self.FSOG4 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4).."_light.ogg" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/hydraulic"..math.random(1,7)..".ogg" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/blu/atte_smallleg_part3.mdl", Ang = Angle(-90,90,0), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/atte_smallleg_part2.mdl", Ang = Angle(-90,90,0), Pos = Vector(-3,-4,0)},
		Foot = {MDL = "models/blu/atte_smallleg_part1.mdl", Ang = Angle(0,0,0), Pos = Vector(0,-4,0)}
	}
	
	RearEnt:GetLegEnts( 4, 60, 65, RearEnt:LocalToWorldAngles( Angle(90,180,0) ), STARTPOS, ENDPOS, ATTACHMENTS )


	local Right = RearEnt:GetRight()

	-- MID RIGHT
	local STARTPOS = RearEnt:LocalToWorld( Vector(-11.37,-45,139.61) )
	local X = 30 + math.cos( math.rad(Cycl3) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl3) ), 0) * Lift
	self.TRACEPOS5 = self.TRACEPOS5 and self.TRACEPOS5 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS5 = self.TRACEPOS5 + (STARTPOS + Forward * X + Right * 90 - self.TRACEPOS5) * Rate
		self.FSOG5 = false
	else
		self.FSOG5 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS5 - Up * 50, endpos = self.TRACEPOS5 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (60+Z)
	if self.FSOG5 ~= self.oldFSOG5 then
		self.oldFSOG5 = self.FSOG5
		if self.FSOG5 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4)..".ogg" ), ENDPOS, SNDLVL_100dB )
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,65) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/lift"..math.random(1,4)..".ogg" ), ENDPOS, SNDLVL_100dB )
		end
	end
	
	local ATTACHMENTS = {
		Leg2 = {MDL = "models/blu/atte_bigleg.mdl", Ang = Angle(-90,180,0), Pos = Vector(0,0,0)},
		Foot = {MDL = "models/blu/atte_bigfoot.mdl", Ang = Angle(0,180,0), Pos = Vector(-16,3,0)}
	}
	
	RearEnt:GetLegEnts( 5, 60, 94, RearEnt:LocalToWorldAngles( Angle(135,100,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	
	-- MID LEFT
	local STARTPOS = RearEnt:LocalToWorld( Vector(-11.37,45,139.61) )
	local X = 30 + math.cos( math.rad(Cycl4) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl4) ), 0) * Lift
	self.TRACEPOS6 = self.TRACEPOS6 and self.TRACEPOS6 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS6 = self.TRACEPOS6 + (STARTPOS + Forward * X - Right * 90 - self.TRACEPOS6) * Rate
		self.FSOG6 = false
	else
		self.FSOG6 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS6 - Up * 50, endpos = self.TRACEPOS6 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end } ).HitPos + Up * (60+Z)
	if self.FSOG6 ~= self.oldFSOG6 then
		self.oldFSOG6 = self.FSOG6
		if self.FSOG6 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4)..".ogg" ), ENDPOS, SNDLVL_100dB )
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,65) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/lift"..math.random(1,4)..".ogg" ), ENDPOS, SNDLVL_100dB )
		end
	end
	
	local ATTACHMENTS = {
		Leg2 = {MDL = "models/blu/atte_bigleg.mdl", Ang = Angle(-90,180,0), Pos = Vector(0,0,0)},
		Foot = {MDL = "models/blu/atte_bigfoot.mdl", Ang = Angle(0,0,0), Pos = Vector(16,-3,0)}
	}
	
	RearEnt:GetLegEnts( 6, 60, 94, RearEnt:LocalToWorldAngles( Angle(135,-100,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
end
--addons/lvs_addons/lua/entities/lvs_walker_hsd/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 100
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	end

	local view = {}
	view.origin = self:LocalToWorld( Vector(0,0,200) )
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius )
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end
--addons/weapons_other/lua/entities/mk3.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "Models/effects/vol_light001" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Rocket Boots"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0
	ENT.MinEffectsSize = 0



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_R_Thigh",
	OffsetVec = Vector( 1 , -0 , 2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

sound.Add( {
	name = "jetpack.thruster_loop",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 75,
	sound = "^thrusters/jet02.wav"
})

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/hunter/plates/plate.mdl" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( false )
		self:SetMaxFuel(100)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(3)	--drain in seconds
		self:SetFuelRecharge( 3 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 200 )
		self:SetJetpackStrafeSpeed( 200 )
		self:SetJetpackVelocity( 510 )
		self:SetJetpackStrafeVelocity( 510 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 1 , 60 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 3000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 3000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HandleLoopingSounds()

	--create the soundpatch if it doesn't exist, it might happen on the client sometimes since it's garbage collected

	if not self.JetpackSound then
		self.JetpackSound = CreateSound( self, "jetpack.thruster_loop" )
	end

	if self:GetActive() then
		local pitch = 125

		if self:GetGoneApeshit() then
			pitch = 175
		end

		self.JetpackSound:PlayEx( 0.5  , pitch )
	else
		self.JetpackSound:FadeOut( 0.1 )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--addons/star_wars_mortar/lua/entities/mortar/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"

ENT.AutomaticFrameAdvance = true
ENT.RotatingSteps = 0.25 * 100
ENT.AnglingSteps = 0.2 * 100
ENT.AnglingMax = 60
ENT.AnglingMin = 13

ENT.FireRate = 2.5
ENT.ShellChangeRate = 1
ENT.ShellClasses = {HE = "mortar_bomb_shell", SE = "mortar_smoke_shell", IN = "mortar_fire_shell"}

function ENT:Initialize()
    self:SetPredictable(true)
end

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "ShellClassId")
    self:NetworkVar("Int", 1, "NextShell")
    self:NetworkVar("Int", 2, "NextFire")
    self:NetworkVar("Entity", 3, "GunnerSeat")
end

function ENT:ChangeShell()
    if (self:GetNextShell() > CurTime()) then return end

    self:SetNextShell(CurTime() + self.ShellChangeRate)

    local id = self:GetShellClassId() + 1

    if (id > table.Count(self.ShellClasses)) then
        self:SetShellClassId(1)
    else
        self:SetShellClassId(id)
    end
end

function ENT:GetGunner()
    if (not IsValid(self:GetGunnerSeat())) then return NULL end

    return self:GetGunnerSeat():GetDriver()
end

--addons/arccw_weapons/lua/entities/plasmanade/shared.lua:
AddCSLuaFile()

ENT.Base = "base_anim"
ENT.Spawnable = false

if CLIENT then
    function ENT:Draw()
     pos = self:GetPos()
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 20, 20, Color(50, 195, 255))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 10, 10, Color(50, 195, 255))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 5, 5, Color(50, 195, 255))
    end
    function ENT:Initialize()
        pos = self:GetPos()
        self.emitter = ParticleEmitter( pos )
    end
end
function ENT:Initialize()
    self.Entity:SetNWBool("smoke", 10, true)
    if SERVER then
        self:SetModel( "models/rising/w_shock.mdl" )
        self:PhysicsInit(SOLID_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)

    local phys = self:GetPhysicsObject()
    if (IsValid(phys)) then
        phys:SetMass(1)
    end
        self:DrawShadow( true )
    end
    self.ExplodeTimer = CurTime() + 100000
    if CLIENT then
        self.emitter = ParticleEmitter( self:GetPos() , 0 )
    end
end
function ENT:PhysicsCollide( data, phys )
    if  (20 < data.Speed and 0.25 < data.DeltaTime) then
    self.ExplodeTimer = 0
    end
end
function ENT:Think()
    if SERVER and (self.ExplodeTimer and self.ExplodeTimer <= CurTime()) then
        self:Explode()
    end
    self:NextThink(CurTime())
    if CLIENT then
        local pos = self:GetPos() + self:GetForward()
        local emitter = ParticleEmitter( self:GetPos() , 0 )
        local particle = emitter:Add("particle/smokesprites_000"..math.random(1,9), pos )
        for i=1, (1) do
            if (particle) then
                particle:SetVelocity((self:GetForward() * -400)+(VectorRand()* 0) )
                particle:SetDieTime( math.Rand( 0.05, 0.15 ) )
                particle:SetStartAlpha( math.Rand( 25, 50 ) )
                particle:SetEndAlpha( 0 )
                particle:SetStartSize( math.Rand( 5, 5 ) )
                particle:SetEndSize( math.Rand( 15, 15 ) )
                particle:SetRoll( math.Rand(0, 360) )
                particle:SetRollDelta( math.Rand(-1, 1) )
                particle:SetColor(50,195,255) 
                particle:SetAirResistance( 2500 ) 
                particle:SetGravity( Vector( 0, 0, 0 ) )
            end
        end
    end
    return true
end
function ENT:Explode()
	local effectdata = EffectData()
    effectdata:SetOrigin( self:GetPos() )
    util.Effect("stw48_plasmanade_effect", effectdata)
	util.BlastDamage( self, self.Owner, self:GetPos(), 225, 110 )
	self:EmitSound("masita/explosions/ion/destruction_explosions_modular_medium_bigion_discharge_close_var_01.mp3", 500, 100)
    self:Remove()
end
--addons/weapons_other/lua/entities/recondroid/cl_init.lua:
include("shared.lua")

function ENT:Draw()

	self:DrawModel()
	
end
--addons/arccw_weapons/lua/entities/rocket_micro/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Wrist Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 5
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp02.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_reb_shotgun", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 45 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 10 )
        smoke:SetEndSize( 35 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
           ParticleEffect( "astw2_swbf_explosion_concussion_grenade", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/jd_oc/explosion_huge" .. math.random(2,3) .. ".mp3",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 324, 125)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(16, 32), math.random(16, 32), Color(255, 175, 75) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/joes_stuff/lua/entities/shield_1/cl_init.lua:
include('shared.lua')

--addons/joes_stuff/lua/entities/shield_1/shared.lua:
ENT.Type = "anim"
ENT.Base = "shield_base"
 
ENT.PrintName= "Shield Level 1"
ENT.Author= "Joe + JackJack"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Joe"
ENT.AutomaticFrameAdvance = true
ENT.shieldmodel = "models/jackjack/props/circle1.mdl"
ENT.health = 100
ENT.laserlength = 139
ENT.radius = 150
ENT.size = 1
--addons/joes_stuff/lua/entities/shield_2/shared.lua:
ENT.Type = "anim"
ENT.Base = "shield_base"
 
ENT.PrintName= "Shield Level 2"
ENT.Author= "Joe + JackJack"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Joe"
ENT.AutomaticFrameAdvance = true
ENT.shieldmodel = "models/jackjack/props/circle2.mdl"
ENT.health = 200
ENT.laserlength = 485
ENT.radius = 505
ENT.size = 1
--addons/sse_101/lua/entities/sse_trainingboard.lua:
AddCSLuaFile()


ENT.Base = "sse_base"
ENT.PrintName		= "Training Room Board"
ENT.Spawnable       = true
ENT.Editable         = true
ENT.ConfigName = "TrainingRoomBoard"
ENT.ClientInteraction = true
ENT.NoHudName = true
ENT.Category        = "SSE"
function ENT:Initialize()
    self.BaseClass.Initialize(self)
    self:SetBodygroup(1, 1)
end

function ENT:SetupDataTables()

    self:NetworkVar( "String", 0, "RoomName", { KeyName = "roomname",	Edit = { type = "Text"  } } ) 
	self:NetworkVar( "Vector",	0, "RoomColor",	{ KeyName = "roomcolor",	Edit = { type = "VectorColor",	order = 4 } } )
    self:NetworkVar( "Entity", 0, "RoomOwner" )
    self:NetworkVar( "String", 1, "SubTitle" ) 
    self:NetworkVar( "String", 2, "SubTitle2" ) 
    self:NetworkVar( "String", 3, "SubTitle3" ) 

    if SERVER then
        self:SetRoomName("New Room")
        self:SetRoomColor(Vector(0, 0, 255))
    end

end


if SERVER then
    function ENT:UpdateTransmitState()
        return TRANSMIT_ALWAYS
    end
    
    function ENT:ResetRoomLines()
        self:SetSubTitle("")
        self:SetSubTitle2("")
        self:SetSubTitle3("")
    end


    util.AddNetworkString("SSE_TrainingRoomBoard_SaveData")
    net.Receive("SSE_TrainingRoomBoard_SaveData", function(len, ply)

        if SSE:AntiSpam(ply) then return end

        local room = net.ReadEntity()
        local line1 = net.ReadString()
        local line2 = net.ReadString()
        local line3 = net.ReadString()

        if string.len(line1) > 13 then
            line1 = string.sub(line1, 1, 13)
        end
        if string.len(line2) > 23 then
            line2 = string.sub(line2, 1, 23)
        end
        if string.len(line3) > 40 then
            line3 = string.sub(line3, 1, 40)
        end
        

        if !IsValid(room) then return end
        if room:GetRoomOwner() != ply then return end
        if room:GetRoomOwner() == nil then return end
        if !room:ConfirmUse(ply) then return end

        for k, v in ipairs(ents.FindByClass("sse_trainingboard")) do
            if !IsValid(v) then continue end
            if v:GetClass() != "sse_trainingboard" then continue end
            if v:GetRoomName() != room:GetRoomName() then continue end
            if v:GetRoomOwner() != ply then continue end
            v:SetSubTitle(line1)
            v:SetSubTitle2(line2)
            v:SetSubTitle3(line3)
        end
    end)

    util.AddNetworkString("SSE_TrainingRoomBoard_GiveUp")
    net.Receive("SSE_TrainingRoomBoard_GiveUp", function(len, ply)
        local room = net.ReadEntity()

        if SSE:AntiSpam(ply) then return end
        if !IsValid(room) then return end
        if room:GetRoomOwner() != ply then return end
        if room:GetRoomOwner() == nil then return end
        if !room:ConfirmUse(ply) then return end


        for k, v in ipairs(ents.FindByClass("sse_trainingboard")) do
            if !IsValid(v) then continue end
            if v:GetClass() != "sse_trainingboard" then continue end
            if v:GetRoomName() != room:GetRoomName() then continue end
            if v:GetRoomOwner() != ply then continue end
            v:SetRoomOwner(nil)
        end
    end)
end


if CLIENT then
    function ENT:Draw()
        self:DrawModel()

        local imgui = SSE.Imgui

        if imgui.Entity3D2D(self, Vector(0, 0, 0), Angle(0, 180, 90), 0.1, 1000, 500) then

            draw.RoundedBox(0, -300, -890, 550, 735, self:ConfigValue("BackgroundColor"))
            

            draw.DrawText(self:GetRoomName(), SSE.xFont("!Agency FB@75#1000"), -25, -850, Color(209,209,209), TEXT_ALIGN_CENTER)

         

            if IsValid(self:GetRoomOwner()) then  

                draw.RoundedBox(0, -300, -760, 550, 2, Color(255,255,255,200))

                draw.DrawText(self:GetSubTitle(), SSE.xFont("!Agency FB@60#1000"), -25, -750, Color(209,209,209), TEXT_ALIGN_CENTER)
                draw.DrawText(self:GetSubTitle2(), SSE.xFont("!Agency FB@50#1000"), -25, -690, Color(209,209,209), TEXT_ALIGN_CENTER)
                draw.DrawText(self:GetSubTitle3(), SSE.xFont("!Agency FB@35#1000"), -25, -640, Color(209,209,209), TEXT_ALIGN_CENTER)

                draw.DrawText(self:ConfigValue("RoomOccupied"), SSE.xFont("!Agency FB@50#1000"), -25, -300, Color(199,0,0), TEXT_ALIGN_CENTER)  
                draw.DrawText(self:GetRoomOwner():Nick(), SSE.xFont("!Agency FB@50#1000"), -25, -250, Color(209,209,209), TEXT_ALIGN_CENTER)
            else 
                draw.DrawText(self:ConfigValue("RoomAvailable"), SSE.xFont("!Agency FB@50#1000"), -25, -600, Color(53,187,0), TEXT_ALIGN_CENTER)

                draw.DrawText(self:ConfigValue("Contact"), SSE.xFont("!Agency FB@35#1000"), -25, -550, Color(200,200,200), TEXT_ALIGN_CENTER)
            end
         

            imgui.End3D2D()
        end

    end


    function ENT:ClientUse() 

        if !IsValid(self:GetRoomOwner()) then return end
        if self:GetRoomOwner() != LocalPlayer() then return end 


        if IsValid(SSE_SIMPLE_ATC_FRAME) then SSE_SIMPLE_ATC_FRAME:Remove() end
        SSE_SIMPLE_ATC_FRAME = SSE:DefaultFrame(self:GetRoomName())
        SSE_SIMPLE_ATC_FRAME:SetSize(ScrW() * 0.3, ScrH() * 0.5)
        SSE_SIMPLE_ATC_FRAME:Center()
        SSE_SIMPLE_ATC_FRAME:MakePopup()


        -- Label for ENtry
        local label = vgui.Create("DLabel", SSE_SIMPLE_ATC_FRAME)
        label:SetText(self:ConfigValue("EditLine1"))
        label:SetFont(SSE.xFont("!Agency FB@25#1000"))
        label:Dock(TOP)
        label:DockMargin(0, 10, 0, 2)

        local entry = SSE:TextEntry(SSE_SIMPLE_ATC_FRAME,self:GetSubTitle())
        entry:Dock(TOP)
        entry:SetTall(SSEH(50))

        local label = vgui.Create("DLabel", SSE_SIMPLE_ATC_FRAME)
        label:SetText(self:ConfigValue("EditLine2"))
        label:SetFont(SSE.xFont("!Agency FB@25#1000"))
        label:Dock(TOP)
        label:DockMargin(0, 10, 0, 2)

        local entry1 = SSE:TextEntry(SSE_SIMPLE_ATC_FRAME,self:GetSubTitle2())
        entry1:Dock(TOP)
        entry1:SetTall(SSEH(50))
  
        local label = vgui.Create("DLabel", SSE_SIMPLE_ATC_FRAME)
        label:SetText(self:ConfigValue("EditLine3"))
        label:SetFont(SSE.xFont("!Agency FB@25#1000"))
        label:Dock(TOP)
        label:DockMargin(0, 10, 0, 2)

        local entry2 = SSE:TextEntry(SSE_SIMPLE_ATC_FRAME,self:GetSubTitle3())
        entry2:Dock(TOP)
        entry2:SetTall(SSEH(50))

        -- Save btn
        local button = SSE:Button(SSE_SIMPLE_ATC_FRAME, self:ConfigValue("Save"), function()
            net.Start("SSE_TrainingRoomBoard_SaveData")
                net.WriteEntity(self)
                net.WriteString(entry:GetValue())
                net.WriteString(entry1:GetValue())
                net.WriteString(entry2:GetValue())
            net.SendToServer()
            SSE_SIMPLE_ATC_FRAME:Remove()
        end, "clrtb")
        button:Dock(BOTTOM)

        -- Give Up btn
        local button = SSE:Button(SSE_SIMPLE_ATC_FRAME, self:ConfigValue("GiveUp"), function()
            net.Start("SSE_TrainingRoomBoard_GiveUp")
                net.WriteEntity(self)
            net.SendToServer() 
            SSE_SIMPLE_ATC_FRAME:Remove()
        end, "cb")
        button:Dock(BOTTOM)
        button:DockMargin(0, 10, 0, 10)
    end

end

--addons/sse_101/lua/entities/sse_unitsign.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Unit Sign"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "SSE"
ENT.Spawnable       = true
ENT.Editable       = true

function ENT:Initialize()

    self:SetModel( "models/reizer_props/alysseum_project/clones/misc_props/misc_stuff_01/misc_stuff_01.mdl" )
    self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
    self:SetSolid( SOLID_VPHYSICS )         -- Toolbox

    self:DrawShadow( false )
 
    if SERVER then 
        self:PhysicsInit( SOLID_VPHYSICS ) 


        self:SetSubMaterial(0, "vgui/null")
    end
    self:PhysWake()
end


function ENT:SetupDataTables()

    self:NetworkVar( "String", 0, "Unit", { KeyName = "Unit",	Edit = { type = "Text"  } } ) 
	self:NetworkVar( "Vector",	0, "UnitColor",	{ KeyName = "unitcolor",	Edit = { type = "VectorColor",	order = 4 } } )

    if SERVER then
        self:SetUnit("912TH")
        self:SetUnitColor(Vector(0, 0, 255))
    end

end



if CLIENT then
    
    function ENT:Draw()
        self:DrawModel()

        
        local imgui = SSE.Imgui

        if imgui.Entity3D2D(self, Vector(0, 0, 16), Angle(0, 90, 90), 0.1, 1000, 500) then

            draw.SimpleText(self:GetUnit(), SSE.xFont("!Agency FB@150#1000"), 1, 1, Color(0, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            draw.SimpleText(self:GetUnit(), SSE.xFont("!Agency FB@150#1000"), 0, 0, self:GetUnitColor():ToColor(), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            
            imgui.End3D2D()
        end
    end
end
--lua/entities/swrp_stretcher/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/arccw_weapons/lua/entities/tfa_csgo_fire_2/shared.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.AdminSpawnable = false


function ENT:Draw()
	
end

function ENT:Initialize()
	self:SetNWBool("extinguished",false)
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_incendiary.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		self:DrawShadow( false )
	end
	ParticleEffect( "molotov_explosion", self:GetPos(), self:GetAngles() )
	self:EmitSound( "TFA_CSGO_Inferno.Loop" )
end

function ENT:Think()
	if self:GetNWBool("extinguished",true) then
		ParticleEffect( "extinguish_fire", self:GetPos(), self:GetAngles() )
		self:Remove()
	end
end

function ENT:OnRemove()
	self:EmitSound( "TFA_CSGO_Inferno.FadeOut" )
    self:StopSound( "TFA_CSGO_Inferno.Loop" )
end
--addons/arccw_weapons/lua/entities/tfa_exp_rocket.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

AddCSLuaFile()

ENT.Base = "tfa_exp_base"
ENT.PrintName = "Rocket-Propelled Explosive"

-- EDITABLE PARAMETERS -- START

ENT.LaunchSound = "" -- none, replace to enable
ENT.PropelSound = Sound("Missile.Accelerate") -- looped propel sound

ENT.BaseSpeed = 500 -- base rocket speed, in units

ENT.AccelerationTime = 0.25 -- time in seconds to accelerate to max speed
ENT.MaxSpeed = 1500 -- maximum speed, works if AccelerationTime > 0

ENT.HasTrail = true -- create trail

-- EDITABLE PARAMETERS -- END

ENT.AccelProgress = 0

ENT.DefaultModel = Model("models/weapons/w_missile.mdl")
ENT.Delay = 10

DEFINE_BASECLASS(ENT.Base)

-- Creates HL2 rocket trail by default, feel free to copy and edit to your needs
function ENT:CreateRocketTrail()
	if not SERVER then return end

	local rockettrail = ents.Create("env_rockettrail")
	rockettrail:DeleteOnRemove(self)

	rockettrail:SetPos(self:GetPos())
	rockettrail:SetAngles(self:GetAngles())
	rockettrail:SetParent(self)
	rockettrail:SetMoveType(MOVETYPE_NONE)
	rockettrail:AddSolidFlags(FSOLID_NOT_SOLID)

	rockettrail:SetSaveValue("m_Opacity", 0.2)
	rockettrail:SetSaveValue("m_SpawnRate", 100)
	rockettrail:SetSaveValue("m_ParticleLifetime", 0.5)
	rockettrail:SetSaveValue("m_StartColor", Vector(0.65, 0.65, 0.65))
	rockettrail:SetSaveValue("m_EndColor", Vector(0, 0, 0))
	rockettrail:SetSaveValue("m_StartSize", 8)
	rockettrail:SetSaveValue("m_EndSize", 32)
	rockettrail:SetSaveValue("m_SpawnRadius", 4)
	rockettrail:SetSaveValue("m_MinSpeed", 2)
	rockettrail:SetSaveValue("m_MaxSpeed", 16)
	rockettrail:SetSaveValue("m_nAttachment", 0)
	rockettrail:SetSaveValue("m_flDeathTime", CurTime() + 999)

	rockettrail:Activate()
	rockettrail:Spawn()
end

function ENT:Initialize(...)
	BaseClass.Initialize(self, ...)

	self:EmitSoundNet(self.PropelSound)

	if self.LaunchSound and self.LaunchSound ~= "" then
		self:EmitSoundNet(self.LaunchSound)
	end

	self:SetFriction(0)
	self:SetLocalAngularVelocity(angle_zero)

	self:SetMoveType(bit.bor(MOVETYPE_FLYGRAVITY, MOVECOLLIDE_FLY_BOUNCE))
	self:SetLocalVelocity(self:GetForward() * self.BaseSpeed)

	if self.HasTrail then
		self:CreateRocketTrail()
	end
end

function ENT:Think(...)
	if self.AccelerationTime > 0 and self.AccelProgress < 1 then
		self.LastAccelThink = self.LastAccelThink or CurTime()
		self.AccelProgress = Lerp((CurTime() - self.LastAccelThink) / self.AccelerationTime, self.AccelProgress, 1)
	end

	self:SetLocalVelocity(self:GetForward() * Lerp(self.AccelProgress, self.BaseSpeed, self.MaxSpeed))

	return BaseClass.Think(self, ...)
end

function ENT:Explode(...)
	self:StopSound(self.PropelSound)

	return BaseClass.Explode(self, ...)
end

function ENT:Touch()
	self.killtime = -1
end

--addons/aocrp_emplacements/lua/entities/turret_bullets2/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment=self:LookupAttachment("muzzle")
	self.shootPos=self:GetDTEntity(1)
	
end
--[[
ENT.HiddenShooter=false
function ENT:Think()
	if not self.HiddenShooter and IsValid(self.shootPos) then
		self.shootPos:SetRenderMode(RENDERMODE_TRANSCOLOR)
		self.shootPos:SetColor(Color(255,255,255,1))
		self.HiddenShooter=true
	end
	
end]]

function ENT:Draw()
	
	self:DrawModel()
	
end
--addons/arccw_weapons/lua/effects/arccw_apex_muzzle_shotty/init.lua:
local ang

EFFECT.ParticleName = "tfa_apex_muzzle_shotgun"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt:IsFirstPerson() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end
    
    self.Forward = self.Forward or data:GetNormal()
    self.Angle = self.Forward:Angle()
        
    local dlight = DynamicLight(self.WeaponEnt:EntIndex())
    if (dlight) then
        dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
        dlight.r = 255
        dlight.g = 192
        dlight.b = 64
        dlight.brightness = 5
        dlight.Size = math.Rand(32, 64)
        dlight.Decay = math.Rand(32, 64) / 0.05
        dlight.DieTime = CurTime() + 0.05
    end
    
    self.Right = self.Angle:Right()
    self.vOffset = self.Position
    dir = self.Forward

    ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.WeaponEnt, self.Attachment)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/arccw_apex_tracer_chargerifle_1/init.lua:
EFFECT.TracerName = "tfa_apex_chargerifle_maxbeam"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment()
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT_FOLLOW, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(1,self.Position)
        pcf:SetControlPoint(2,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_base_modified/lua/effects/arccw_ricochet.lua:
EFFECT.StartPos = Vector(0, 0, 0)
EFFECT.EndPos = Vector(0, 0, 0)
EFFECT.StartTime = 0
EFFECT.LifeTime = 0.2
EFFECT.DieTime = 0
EFFECT.Color = Color(255, 255, 255)
-- EFFECT.Speed = 500

local head = Material("effects/whiteflare")
local tracer = Material("trails/smoke")

function EFFECT:Init(data)

    local start = data:GetStart()
    local hit = data:GetOrigin()

    -- self.LifeTime = (hit - start):Length() / self.Speed

    self.LifeTime = 0.25

    self.StartTime = UnPredictedCurTime()
    self.DieTime = UnPredictedCurTime() + self.LifeTime

    self.StartPos = start
    self.EndPos = hit
end

function EFFECT:Think()
    return self.DieTime > UnPredictedCurTime()
end

local function LerpColor(d, col1, col2)
    local r = Lerp(d, col1.r, col2.r)
    local g = Lerp(d, col1.g, col2.g)
    local b = Lerp(d, col1.b, col2.b)
    local a = Lerp(d, col1.a, col2.a)
    return Color(r, g, b, a)
end

function EFFECT:Render()
    local d = (UnPredictedCurTime() - self.StartTime) / self.LifeTime
    -- local endpos = self.StartPos + (d * (self.EndPos - self.StartPos))
    local endpos = self.EndPos
    local size = 1

    local col = LerpColor(d, self.Color, Color(0, 0, 0, 0))

    render.SetMaterial(head)
    render.DrawSprite(endpos, size, size, col)

    render.SetMaterial(tracer)
    render.DrawBeam(endpos, self.StartPos, size * 0.75, 0, 1, col)
end
--addons/arccw_weapons/lua/effects/astw2_halo3_explosion_fuelrod/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 200
            light.g = 255
            light.b = 155
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/muzzle_fuelrod", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 225, 255, 215 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	


	
		for i= 0,3 do
	  local particle = emitter:Add("effects/halo3/smoke_directional_large", self.Origin)

    particle:SetVelocity( Vector(0,math.Rand(75, 100),math.Rand(65, 125)) )
    particle:SetDieTime( math.Rand(0.5,1) )
    particle:SetStartAlpha( 155 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(25,75) )
    particle:SetEndSize( math.Rand(300,350) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 155, 255, 125 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-10,50) ) )
    particle:SetLighting( false )
    particle:SetCollide( false )
	end

    particle = emitter:Add( "effects/halo3/muzzle_plasmapistol", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(250,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 200,255,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	
    particle = emitter:Add( "effects/halo3/electric_arcs", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.3, 0.4) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(300,325) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 215,255,185 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo3_impact_plasmarifle/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 35 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(175, 175, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_reach/plasma_bolt", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 255, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
				for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/electric_arcs", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.1 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(225, 225, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 155, 155, 255, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_beamrifle/init.lua:

local Tracer = Material( "effects/halo2/plasma_contrail" )
local Tracer2  = Material( "effects/blueblacklargebeam" )
local Width = 20
local Width2 = 15

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.15
	self.LifeTime2 = 0.25
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 175, 255, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 195, 255, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_sniper/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= -256;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo3/trail_ar" );
local MaterialFront			= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 6, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_spiker/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 48;
EFFECT.Length2				= 24;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo3/trails/trail_spiker_alt" );
local MaterialMain2			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_ar_side" );
local MaterialFront			= Material( "effects/halo3/flare1" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	local startDistance2 = endDistance - self.Length2;
	
	startDistance = math.max( 0, startDistance );
	startDistance2 = math.max( 0, startDistance2 );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local startPos2 = self.StartPos + self.Normal * startDistance2;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 7, 0, 1, color_white );
	
	render.SetMaterial( MaterialMain2 );
	render.DrawBeam( startPos2, endPos, 4, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_tracer_sniper/init.lua:

local Tracer = Material( "effects/halo3/trails/trail_sniper_ce" )
local Width = 8

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 2
	self.DieTime = CurTime() + self.LifeTime

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*1/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 225, 255, 255, v * 100 ) )
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_spv3_tracer_needler/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 512;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_needler_side" );
local MaterialFront			= Material( "effects/halo_spv3/flash/smg_new" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 12, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_impact/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/swbf/sparks" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/swbf/sparks", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.5 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 25, 30 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/swbf/thicksmoke"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(2, 5));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(20, 40));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_blue_sniper/init.lua:

local Tracer = Material( "effects/swbf/blue_beam" )
local Tracer2  = Material( "effects/blueblacklargebeam" )
local Width = 15
local Width2 = 10

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.25
	self.LifeTime2 = 0.45
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 190, 200, 255, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 200, 195, 255, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_laserhit_hell/init.lua:
function EFFECT:Init( data )
	
	local vOffset = data:GetOrigin()
		self.Origin = data:GetOrigin()
	self.DirVec = data:GetNormal()
	self.Scale = data:GetScale()
		self.Magnitude = data:GetMagnitude()
	self.Emitter = ParticleEmitter( self.Origin )

	local emitter = ParticleEmitter( vOffset )

				for i=1,5 do 
			local Flash = self.Emitter:Add( "effects/ongflare", self.Origin )
			if (Flash) then
				Flash:SetVelocity( VectorRand() )
				Flash:SetAirResistance( 200 )
				Flash:SetDieTime( 0.15 )
				Flash:SetStartAlpha( 255 )
				Flash:SetEndAlpha( 0 )
				Flash:SetStartSize( 50 )
				Flash:SetEndSize( 0 )
				Flash:SetRoll( math.Rand(180,480) )
				Flash:SetRollDelta( math.Rand(-1,1) )
				Flash:SetColor(255,255,255)	
			end
		end


		for i=1,2 do 
			local particle = emitter:Add( "effects/ongflare", vOffset )

				particle:SetVelocity( 10 * data:GetNormal() )
				particle:SetAirResistance( 600 )

				particle:SetDieTime( 0.2 )

				particle:SetStartAlpha( math.Rand(0, 55) )
				particle:SetEndAlpha( 0 )

				particle:SetStartSize( 8 * i )
				particle:SetEndSize( 5 * i )

				particle:SetRoll( math.Rand(180,480) )
				particle:SetRollDelta( math.Rand(-1,1) )

				particle:SetColor(255,255,255)	
				particle:SetGravity( Vector( math.Rand(-100, 100) * self.Scale, math.Rand(-100, 100) * self.Scale, math.Rand(0, -100) ) ) 		
		end
		
	
			local particle = emitter:Add( "effects/ongflare", vOffset )

				particle:SetVelocity( 80 * data:GetNormal() + 20 * VectorRand() )
				particle:SetAirResistance( 200 )

				particle:SetDieTime( math.Rand(0.2, 0.25) )

				particle:SetStartSize( math.random(15,20) )
				particle:SetEndSize( 3 )


				particle:SetRoll( math.Rand(180,480) )
				particle:SetRollDelta( math.Rand(-1,1) )

	emitter:Finish()
	
				Sound( "weapons/laserrifle/impacts/fx_laser_impact_0"..math.random(1,4)..".wav", self.Origin,75, 100)

end

function EFFECT:Think( )

	return false
end

function EFFECT:Render()

end

--addons/arccw_weapons/lua/effects/effect_t_laser_redplasma/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 20000;
EFFECT.Length				= 500;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_red_main" );
local MaterialFront			= Material( "effects/sw_laser_red_front" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 8, 8, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 3, 3, 3, color_white );
	
end

--lua/effects/lfs_blacksmoke.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin() + VectorRand() * 50
	
	local emitter = ParticleEmitter( Pos, false )

	if emitter then
		local particle = emitter:Add( Materials[math.Round(math.Rand(1,table.Count( Materials )),0)], Pos )
		
		if particle then
			particle:SetVelocity( VectorRand() * 100 )
			particle:SetDieTime( 1.5 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 80 )
			particle:SetEndSize( math.Rand(250,300) )
			particle:SetRoll( math.Rand(-1,1) * 100 )
			particle:SetColor( 70,70,70 )
			particle:SetGravity( Vector( 0, 0, 500 ) )
			particle:SetCollide( false )
		end
		
		emitter:Finish()
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_bullet_impact_ap.lua:

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.SparkSurface = {
	["chainlink"] = true,
	["canister"] = true,
	["metal_barrel"] = true,
	["metalvehicle"] = true,
	["metal"] = true,
	["metalgrate"] = true,
	["rubbertire"] = true,
}

EFFECT.DustSurface = {
	["sand"] = true,
	["dirt"] = true,
	["grass"] = true,
	["antlionsand"] = true,
}

EFFECT.SmokeSurface = {
	["concrete"] = true,
	["tile"] = true,
	["plaster"] = true,
	["boulder"] = true,
	["plastic"] = true,
	["default"] = true,
	["glass"] = true,
	["brick"] = true,
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()

	local bullet_dir = data:GetStart()
	local dir = data:GetNormal()
	local magnitude = data:GetMagnitude()

	local ent = data:GetEntity()
	local surface = data:GetSurfaceProp()
	local surfaceName = util.GetSurfacePropName( surface )

	local emitter = ParticleEmitter( pos, false )

	local VecCol = (render.GetLightColor( pos ) * 0.8 + Vector(0.17,0.15,0.1)) * 255

	local DieTime = math.Rand(0.8,1.4)

	for i = 1, 60 * magnitude do
		local spark = emitter:Add("effects/spark", pos + dir * 8)

		if not spark then continue end

		spark:SetStartAlpha( 255 )
		spark:SetEndAlpha( 0 )
		spark:SetCollide( true )
		spark:SetBounce( math.Rand(0,1) )
		spark:SetColor( 255, 255, 255 )
		spark:SetGravity( Vector(0,0,-600) )
		spark:SetEndLength(0)

		local size = math.Rand(4, 6) * magnitude
		spark:SetEndSize( size )
		spark:SetStartSize( size )

		spark:SetStartLength( math.Rand(20,40) * magnitude )
		spark:SetDieTime( math.Rand(0.4, 1.2) )
		spark:SetVelocity( (dir * math.Rand(300, 600) + VectorRand() * 300) * magnitude )
	end

	local flash = emitter:Add( "effects/yellowflare",pos )

	if flash then
		flash:SetPos( pos + dir * 15 )
		flash:SetStartAlpha( 200 )
		flash:SetEndAlpha( 0 )
		flash:SetColor( 255,255,255 )
		flash:SetEndSize( 0 )
		flash:SetDieTime( 0.075 )
		flash:SetStartSize( 300 * magnitude ^ 2 )
	end

	if self.SparkSurface[ surfaceName ] then
		if IsValid( ent ) and ent.LVS then
			if (90 - math.deg( math.acos( math.Clamp( -dir:Dot( bullet_dir ) ,-1,1) ) )) > 10 then
				local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				util.Effect( "cball_explode", effectdata, true, true )

				local Ax = math.acos( math.Clamp( dir:Dot( bullet_dir ) ,-1,1) )
				local Fx = math.cos( Ax )

				local effectdata = EffectData()
					effectdata:SetOrigin( pos )
					effectdata:SetNormal( (bullet_dir - dir * Fx * 2):GetNormalized() * 0.75 )
				util.Effect( "manhacksparks", effectdata, true, true )

				local effectdata = EffectData()
					effectdata:SetOrigin( pos )
					effectdata:SetNormal( -bullet_dir * 0.75 )
				util.Effect( "manhacksparks", effectdata, true, true )
			end
		else
			local effectdata = EffectData()
			effectdata:SetOrigin( pos )
			util.Effect( "cball_explode", effectdata, true, true )

			local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				effectdata:SetNormal( dir )
			util.Effect( "manhacksparks", effectdata, true, true )

			local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				effectdata:SetNormal( -bullet_dir )
			util.Effect( "manhacksparks", effectdata, true, true )
		end
	end

	if self.SmokeSurface[ surfaceName ] then
		for i = 1, 24 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], pos )

			if not particle then continue end

			particle:SetStartAlpha( math.Rand(33, 66) )
			particle:SetEndAlpha( 0 )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-math.Rand(33, 66)) )
			particle:SetRollDelta( math.random(0, 0.5 * math.pi) )
			particle:SetAirResistance( 175 )

			particle:SetStartSize( 15 )
			particle:SetDieTime( math.Rand(0.5, 1) )
			particle:SetEndSize( math.Rand(45, 90) )
			particle:SetVelocity( dir * math.Rand(40, 200) + VectorRand() * 150)
		end

		for i = 1,15 do
			local particle = emitter:Add("effects/fleck_cement" .. math.random(1, 2), pos + dir * 8)

			if not particle then continue end

			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetCollide( true )
			particle:SetBounce( math.Rand(0,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity(Vector(0,0,-600))
			particle:SetRollDelta( math.random(0, 0.5*math.pi) )

			particle:SetEndSize( 2 )
			particle:SetStartSize( 2 )

			particle:SetDieTime( math.Rand(1, 2) )
			particle:SetVelocity( dir * math.Rand(40, 200) + VectorRand() * 500 )
		end
	end

	if not self.DustSurface[ surfaceName ] then return end

	for i = 1, 10 do
		for i = 1, 15 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], pos )

			if not particle then continue end

			particle:SetStartAlpha( math.Rand(40, 80) )
			particle:SetEndAlpha(0)
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-math.Rand(75, 150)) )
			particle:SetRollDelta( math.random(0, 0.5*math.pi) )
			particle:SetAirResistance( 175 )

			particle:SetStartSize( 5 )
			particle:SetDieTime( math.Rand(0.5, 1) )
			particle:SetEndSize( math.Rand(15, 30) )
			particle:SetVelocity( (dir * math.Rand(80, 400) + VectorRand() * 100) * 1.5 )
		end
    
		for n = 0,6 do
			local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ] , pos )

			if not particle then continue end

			particle:SetVelocity( (dir * 50 * i + VectorRand() * 50) )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 10 * i )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_engine_blacksmoke.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin() + VectorRand() * 25
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )
	
	if particle then
		particle:SetVelocity( VectorRand() * 100 )
		particle:SetDieTime( 2 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 60 )
		particle:SetEndSize( 200 )
		particle:SetRoll( math.Rand(-1,1) * math.pi )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( 60, 60, 60 )
		particle:SetGravity( Vector( 0, 0, 600 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_explosion_nodebris.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()

	self:Explosion( Pos, 2 )

	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		timer.Simple( delay, function()
			sound.Play( "LVS.EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.EXPLOSION", Pos )
	end

	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if not IsValid( self ) then return end

			local p = Pos + VectorRand() * 10 * i
			
			self:Explosion( p, math.Rand(0.5,0.8) )
		end)
	end
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 1000 * scale )
		particle:SetDieTime( math.Rand(0.75,1.5) * scale )
		particle:SetAirResistance( math.Rand(200,600) ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( math.Rand(60,120) * scale )
		particle:SetEndSize( math.Rand(160,280) * scale )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 40,40,40 )
		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetCollide( false )
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 1000 * scale )
		particle:SetDieTime( 0.14 )
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 * scale )
		particle:SetEndSize( math.Rand(60,120) * scale )
		particle:SetEndAlpha( 100 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 200,150,150 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_addons/lua/effects/lvs_laat_right_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "muzzle_ballturret_right" )
		
		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), Muzzle.Ang:Up() * 50000 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetBTRFire() then
		return false
	end
	
	return true
end


function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end

	local Muzzle = self.Entity:GetAttachment( self.ID )

	local Dir = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Dir * 14
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS( StartPos, EndPos )

	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )

	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )

	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()

		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )

			local vel = VectorRand()  * 100 + dir * 40

			if not particle then continue end

			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(1,30) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )

			particle:SetAirResistance( 0 )
		end
		
		emitter:Finish()
	end
end

--addons/lvs_addons/lua/effects/lvs_laser_impact.lua:
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.Col = data:GetStart() or Vector(255,100,0)

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local trace = util.TraceLine( {
		start = self.Pos - self.Dir,
		endpos = self.Pos + self.Dir,
		mask = MASK_SOLID_BRUSHONLY,
	} )

	self.Flat = trace.Hit and not trace.HitSky

	local Col = self.Col
	local Pos = self.Pos

	local emitter = ParticleEmitter( Pos, false )

	for i = 0, 10 do
		local particle = emitter:Add( "sprites/light_glow02_add", Pos )

		local vel = VectorRand() * 200 + self.Dir  * 80

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(12,24) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( Col.x,Col.y,Col.z )
		particle:SetGravity( Vector(0,0,-600) )

		particle:SetAirResistance( 0 )

		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	local S1 = 200 * Scale
	local S2 = 50 * Scale

	if self.Flat then
		cam.Start3D2D( self.Pos + self.Dir, self.Dir:Angle() + Angle(90,0,0), 1 )
			surface.SetMaterial( self.GlowMat )
			surface.SetDrawColor( self.Col.x, self.Col.y, self.Col.z, 255 )
			surface.DrawTexturedRectRotated( 0, 0, S1 , S1 , 0 )

			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.DrawTexturedRectRotated( 0, 0, S2 , S2 , 0 )
		cam.End3D2D()
	end

	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos + self.Dir, S1, S1, Color( self.Col.x, self.Col.y, self.Col.z, 255 ) )
	render.DrawSprite( self.Pos + self.Dir, S2, S2, Color( 255, 255, 255, 255) )
end

--addons/lvs_base/lua/effects/lvs_missiletrail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		if particle then
			particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
			particle:SetVelocity( -self.Entity:GetForward() * 200  )
			particle:SetAirResistance( 600 ) 
			particle:SetDieTime( math.Rand(1.5,2) )
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 20 )
			particle:SetEndSize( 60 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
			particle:SetColor(40,40,40)
			particle:SetCollide( false )
		end

		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 1 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 0.25 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 6 )
			particle:SetEndSize( 2 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity

	if not IsValid( ent ) then return end

	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )
	render.DrawSprite( pos, 100, 100, Color( 255, 200, 150, 255 ) )
end

--addons/arccw_weapons/lua/effects/stw48_plasmanade_effect.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)
	
	for i = 1, math.random(20, 50) do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1,4), self.Start)
		p:SetDieTime(math.Rand(0.1*3, 0.25*3))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(70, 190) * self.size)
		p:SetEndSize(50 * self.size)
		p:SetRoll(math.Rand(-50, 50))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * math.random(25, 75) * self.size)
		p:SetColor(0, 90, 255)
	end
	for i = 1, 40 do
		local vec = VectorRand():GetNormal()
		vec.z = 0
		local pos = (self.Start + vec * 50)
		local p = self.Emitter:Add("sprites/orangeflare1", self.Start + vec * 10)
		p:SetDieTime(math.Rand(0.9, 1.1))
		p:SetStartAlpha(255)
		p:SetEndAlpha(35)
		p:SetStartSize(18)
		p:SetEndSize(12)
		p:SetVelocity(((pos - self.Start):GetNormal() * math.random(50, 80)) + Vector(0, 0, math.random(60, 150)) * self.size)
		p:SetGravity( Vector( 0, 0, -500 ) );
		p:SetColor(0, 90, 255)
		p:SetCollide(false)
	end

	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--addons/arccw_weapons/lua/effects/swrp_muzzleflash_blue/init.lua:
local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if self.WeaponEnt.Owner:ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	dir = self.Forward

	if IsValid(LocalPlayer()) then
		AddVel = LocalPlayer():GetVelocity()
	end

	AddVel = AddVel * 0.05
	self.vOffset = self.Position
	dir = self.Forward
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(EyeAngles():Forward())
	local dotang = math.deg(math.acos(math.abs(dot)))
	local halofac = math.Clamp(1 - (dotang / 90), 0, 1)

	if CLIENT and not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = 22
		dlight.g = 55
		dlight.b = 255
		dlight.brightness = 10
		dlight.Decay = 1000
		dlight.Size = 88
		dlight.DieTime = CurTime() + 0.5
	end

	local emitter = ParticleEmitter(self.vOffset)
	local sparticle = emitter:Add("effects/muzzleflashX_nemole_w", self.vOffset)

	if (sparticle) then
		sparticle:SetVelocity(dir * 4 + 1.05 * AddVel)
		sparticle:SetLifeTime(0)
		sparticle:SetDieTime(0.08)
		sparticle:SetStartAlpha(math.Rand(255, 255))
		sparticle:SetEndAlpha(0)
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
		sparticle:SetStartSize(4 * (halofac * 0.8 + 0.2), 0, 1)
		sparticle:SetEndSize(12 * (halofac * 0.8 + 0.2), 0, 1)
		local r = math.Rand(-10, 10) * 3.14 / 180
		sparticle:SetRoll(r)
		sparticle:SetRollDelta(r / 5)
		sparticle:SetColor(200, 200, 200)
		sparticle:SetLighting(false)
		sparticle.FollowEnt = self.WeaponEnt
		sparticle.Att = self.Attachment
		TFA.Particles.RegisterParticleThink(sparticle, TFA.Particles.FollowMuzzle)
		sparticle:SetPos(vector_origin)
	end

	for i = 1, 1 do
		local particle = emitter:Add("effects/scotchmuzzleflashw", self.vOffset)

		if (particle) then
			particle:SetVelocity(dir * 4 + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(0.10)
			particle:SetStartAlpha(math.Rand(150, 185))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(1 * (halofac * 0.8 + 0.2), 0, 1)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2))
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(-40, 40)))
			particle:SetColor(2, 60, 255)
			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for i = 0, 5 do
		local particle = emitter:Add("particles/flamelet" .. math.random(1, 5), self.vOffset + (dir * 0.6 * i))

		if (particle) then
			particle:SetVelocity((dir * 19 * i) + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(0.075)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( math.max(5.4 - 0.55 * i,1) )
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(6 - 0.35 * i, 1) * 0.55)
			particle:SetEndSize(math.max(5.4 - 0.35 * i, 1) * 1.25)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(-40, 40)))
			particle:SetColor(25, 95, 200)
			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	for i = 0, 4 do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(6, 10))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 + dir * math.Rand(15, 20) + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(math.Rand(0.6, 0.7))
			particle:SetStartAlpha(math.Rand(7, 11))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7))
			particle:SetEndSize(math.Rand(12, 14))
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(10)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(50, 50, 205)
		end
	end

	local sparkcount = math.random(8, 12)

	for i = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity((VectorRand() + Vector(0, 0, 0.3)) * 60 * Vector(0.8, 0.8, 0.6) + dir * math.Rand(80, 120) + 1.15 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(math.Rand(0.25, 0.4))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(.35)
			particle:SetEndSize(1.15)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(Vector(0, 0, -50))
			particle:SetAirResistance(40)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)
			particle:SetColor(2, 95, 255)
			particle:SetVelocityScale(true)

			particle:SetThinkFunction(function(pa)
				pa.ranvel = pa.ranvel or VectorRand() * 4
				pa.ranvel.x = math.Approach(pa.ranvel.x, math.Rand(-4, 4), 0.5)
				pa.ranvel.y = math.Approach(pa.ranvel.y, math.Rand(-4, 4), 0.5)
				pa.ranvel.z = math.Approach(pa.ranvel.z, math.Rand(-4, 4), 0.5)
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * 1.5)
				pa:SetNextThink(CurTime() + 0.01)
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		for i = 0, 3 do
			local particle = emitter:Add("sprites/heatwave", self.vOffset + (dir * i))

			if (particle) then
				particle:SetVelocity((dir * 25 * i) + 1.05 * AddVel + VectorRand() * 5)
				particle:SetLifeTime(0)
				particle:SetDieTime(math.Rand(0.05, 0.15))
				particle:SetStartAlpha(math.Rand(200, 225))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(1, 2))
				particle:SetEndSize(math.Rand(1, 5))
				particle:SetRoll(math.Rand(0, 360))
				particle:SetRollDelta(math.Rand(-2, 2))
				particle:SetAirResistance(5)
				particle:SetGravity(Vector(0, 0, 40))
				particle:SetColor(5, 95, 205)
			end
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/thetalaser1/init.lua:

EFFECT.Mat = Material( "effects/blueblacklargebeam" )


function EFFECT:Init( data )

	self.texcoord = math.Rand( 0, 20 )/3
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	

	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()
	

	self.Entity:SetCollisionBounds( self.StartPos -  self.EndPos, Vector( 110, 110, 110 ) )
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos, Vector()*8 )
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	
	self.Alpha = 255
	self.FlashA = 255
	
	self.WeaponEnt 		= data:GetEntity()
	self.Attachment 		= data:GetAttachment()
	
	self.Position 		= self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)
	self.Forward 		= data:GetNormal()
	self.Angle 			= self.Forward:Angle()
	self.Right 			= self.Angle:Right()
	self.Up 			= self.Angle:Up()
	
	
	
end


function EFFECT:Think( )

	self.FlashA = self.FlashA - 1150 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1150 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return true

end


function EFFECT:Render( )
	
	self.Length = (self.StartPos - self.EndPos):Length()
	
	local texcoord = self.texcoord
	
		render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos, 										// Start
					 self.EndPos,											// End
					 6,													// Width
					 texcoord,														// Start tex coord
					 texcoord + self.Length / 256,									// End tex coord
					 Color( 222, 25, 11, math.Clamp(self.Alpha, 0,100)) )		// Color (optional)'
					 
end

--addons/arccw_weapons/lua/effects/thetalaser_hot/init.lua:

EFFECT.Mat = Material( "effects/beam_generic01" )


function EFFECT:Init( data )

	self.texcoord = math.Rand( 0, 20 )/3
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	

	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()
	

	self.Entity:SetCollisionBounds( self.StartPos -  self.EndPos, Vector( 110, 110, 110 ) )
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos, Vector()*8 )
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	
	self.Alpha = 255
	self.FlashA = 255
	
	self.WeaponEnt 		= data:GetEntity()
	self.Attachment 		= data:GetAttachment()
	
	self.Position 		= self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)
	self.Forward 		= data:GetNormal()
	self.Angle 			= self.Forward:Angle()
	self.Right 			= self.Angle:Right()
	self.Up 			= self.Angle:Up()
	

	
	local emitter 		= ParticleEmitter(self.Position)
					local particle = emitter:Add("effects/yellowflare", self.Position)
			particle:SetVelocity(500 * self.Forward + 15 * VectorRand()) -- + AddVel)
			particle:SetAirResistance(0)
			particle:SetGravity(Vector(0, 0, math.Rand(25, 100)))
			particle:SetDieTime(math.Rand(1, 2))
			particle:SetStartAlpha(0)
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(8, 12))
			particle:SetEndSize(0)
			particle:SetRoll(math.Rand(-5, 45))
			particle:SetRollDelta(math.Rand(-0.05, 0.05))
			particle:SetColor(0, 0, 0)
			
								
			

	emitter:Finish()
	
	
end


function EFFECT:Think( )

	self.FlashA = self.FlashA - 1150 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1150 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return true

end


function EFFECT:Render( )
	
	self.Length = (self.StartPos - self.EndPos):Length()
	
	local texcoord = self.texcoord
	
		render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos, 										// Start
					 self.EndPos,											// End
					 3,													// Width
					 texcoord,														// Start tex coord
					 texcoord + self.Length / 256,									// End tex coord
					 Color( 255, 93, 0, math.Clamp(self.Alpha, 0,255)) )		// Color (optional)'
					 
end

--addons/reconnect_crash_screen/lua/crashmenu/cl_init.lua:
include("crashmenu/vgui/ReconnectPanel.lua")

local function create()
    if not IsValid(crashmenu.Panel) then
        crashmenu.Panel = vgui.Create("ReconnectPanel")
        crashmenu.Panel:Hide()
    end
end
hook.Add("PostRender", "crashmenu", function()
    timer.Simple(0, function()
        create()
    end)
    hook.Remove("PostRender", "crashmenu")
end)

local function urlencode(url)
    if not url then
        return
    end

    url = tostring(url)
    url = url:gsub("\n", "\r\n")
    url = url:gsub("([^%w ])", function(c)
        return string.format("%%%02X", string.byte(c))
    end)
    url = url:gsub(" ", "+")
    return url
end
local function ping(success)
    local host = GetGlobal2String("crashmenu.ServerHost")
    if host == "" then host = game.GetIPAddress() end
    HTTP({
        url = ("%s/server/status?host=%s&hostname=%s&chatroomUuid=%s"):format(
            crashmenu.Host,
            urlencode(host),
            urlencode(GetHostName()),
            urlencode(crashmenu.Config.ChatRoomID)
            -- urlencode(os.time())
        ),
        method = "GET",
        success = success,
        failed = function(...) print(...) end
    })
end

local checkDelay = 1
local offlineTimes = 0
local lastCheck = 0
local lastUpdate = 0
local joinTime
hook.Add("Think", "crashmenu", function()
    if not IsValid(crashmenu.Panel) then return end
    if RealTime() < lastCheck then return end

    if not joinTime then
        joinTime = 0
        ping(function(code, res)
            if res == "Not registered" then Msg("[crashmenu] ")print("your server is not registered") end
            if code == 200 then
                joinTime = (tonumber(res) or 0)
            else
                joinTime = nil
            end
        end)
    end

    local _, update = engine.ServerFrameTime()

    if lastUpdate == update then
        offlineTimes = offlineTimes + 1
        if offlineTimes > 20 then
            checkDelay = 5
            crashmenu.Panel:Show()
            ping(function(code, res)
                if code == 200 and joinTime < (tonumber(res) or 0) then
                    crashmenu.Panel.Reconnecting = true
                    crashmenu.Panel.NextTry = RealTime() + 3
                end
            end)
        end
    else
        checkDelay = 1
        offlineTimes = 0
        crashmenu.Panel.Reconnecting = false
        crashmenu.Panel.NextTry = nil
        crashmenu.Panel:Hide()
    end

    lastCheck = RealTime() + checkDelay
    lastUpdate = update
end)
